<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes">
          <source>On a single line:</source>
          <target>一行:</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes">
          <source>On multiple lines:</source>
          <target>複数行:</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target>スニペットの最後の行では、&lt;code&gt;ReadonlyArray&lt;/code&gt;全体を通常の配列に代入することも違法であることがわかります。 ただし、次のようにタイプ・アサーションで上書きすることもできます。</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target>組織の面では、論理的に関連するオブジェクトとタイプをグローバル・スコープでグループ化するには、ネームスペースが便利です。 たとえば、C#では、System.Collectionsのすべてのコレクション型が検索されます。 型を階層的な名前空間に編成することで、これらの型のユーザーに優れた&amp;ldquo;検出&amp;rdquo;エクスペリエンスを提供します。 一方、モジュールは、必然的にファイル・システムにすでに存在しています。 パスとファイル名で解決する必要があるため、論理的な編成スキームを使用できます。 リストモジュールを含む/collections/generic/フォルダを作成できます。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target>一方、インタフェースを使用して図形を表現できず、ユニオン型またはタプル型を使用する必要がある場合は、通常、型の別名を使用します。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target>一方、&lt;code&gt;forEach&lt;/code&gt;などのメソッドは呼び出し可能になりましたが、&lt;code&gt;noImplicitAny&lt;/code&gt;では問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target>一度定義すれば、他のインターフェースと同じようにこの関数型インターフェースを使用することができます。 ここでは、関数型の変数を作成し、それに同じ型の関数値を代入する方法を示します。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target>クラス・タイプが確立されると、インスタンス・タイプは、クラス・タイプの構成体または呼び出しシグニチャー(いずれか存在する方)の戻り型の結合によって決定されます。 この場合も、ES6クラスの場合、インスタンス・タイプはそのクラスのインスタンスのタイプになり、ファクトリー関数の場合は関数から返される値のタイプになります。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target>複数のファイルが含まれる場合は、コンパイルされたコードがすべてロードされていることを確認する必要があります。 これには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target>ジェネリックID関数を作成したら、次の2つの方法のいずれかで呼び出すことができます。 最初の方法は、型引数を含むすべての引数を関数に渡すことです。</target>
        </trans-unit>
        <trans-unit id="7d458455fccb04675b7f0468c6426d4313a046c4" translate="yes">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;acirc;&amp;euro;&amp;trade;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target>この方法の利点の1つは、呼び出し可能なコンストラクター・パターンを簡単に表現できることと、名前空間をこれらの宣言とマージできることです(&lt;code&gt;var&lt;/code&gt;宣言は&lt;code&gt;namespace&lt;/code&gt;sとマージできるため)。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target>一般的なタスクの1つは、既存の型を取り、その各プロパティーを完全にオプションにすることです。 &lt;code&gt;人&lt;/code&gt;がいるとします。</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target>前述の例との1つの違いは、コンストラクタ関数を含む各派生クラスは、&lt;em&gt;基本クラスのコンストラクタを実行する&lt;code&gt;super()&lt;/code&gt;を&lt;/em&gt;呼び出さなければならないことである。 さらに、コンストラクタ本体の&lt;code&gt;this&lt;/code&gt;のプロパティに&lt;em&gt;アクセスする前に、&lt;em&gt;&lt;/em&gt;で&lt;code&gt;super()&lt;/code&gt;を呼び出します。これは、TypeScriptが強制する重要なルールです。</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target>1つの違いは、インターフェイスによって、すべての場所で使用される新しい名前が作成されることです。 「aliases don&amp;rsquo;t create a new name」と入力します。たとえば、エラー・メッセージでは別名が使用されません。 以下のコードでは、エディタで&lt;code&gt;interfaces&lt;/code&gt;の上にカーソルを置くと、&lt;code&gt;Interface&lt;/code&gt;を返すことが示されますが、&lt;code&gt;aliased&lt;/code&gt;はオブジェクトリテラル型を返すことが示されます。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target>この規則の例外の1つは、特殊化された署名です。 シグネチャに&lt;em&gt;単一&lt;/em&gt;文字列リテラル型のパラメータがある場合(文字列リテラルの集合ではない場合など)、マージされたオーバーロード・リストの先頭に向かってバブリングされます。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target>これらのチェックを回避するための最後の方法は、少し意外かもしれませんが、オブジェクトを別の変数に割り当てることです。 &lt;code&gt;squareOptions&lt;/code&gt;は余分なプロパティチェックを受けないため、コンパイラはエラーを表示しません。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target>これの大きな利点の1つは、&lt;code&gt;--noImplicitAny&lt;/code&gt;を使用して実行する場合に、&lt;em&gt;暗黙的&lt;code&gt;エラーが&lt;/em&gt;大幅に減少することです。 暗黙的な&lt;code&gt;すべての&lt;/code&gt;エラーは、コンパイラが型注釈なしに変数の型を知ることができない場合にのみ報告されます。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target>環境列挙と非環境列挙の重要な違いの1つは、通常の列挙では、先行する列挙メンバーが定数と見なされる場合、初期化子を持たないメンバーが定数と見なされることです。 対照的に、初期化子を持たないアンビエント(かつ非const)enumメンバは、&lt;em&gt;常に&lt;/em&gt;計算されると見なされます。</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target>TypeScript&amp;rsquo;の中心的な原則の1つは、型チェックは値が持つ&lt;em&gt;形状&lt;/em&gt;に焦点を当てるということです。 これは、&amp;ldquo;ダックタイプ&amp;rdquo;または&amp;ldquo;構造サブタイプ&amp;rdquo;と呼ばれることがあります。 TypeScriptでは、インターフェースはこれらの型に名前を付ける役割を果たし、プロジェクト外のコードとの契約と同様に、コード内の契約を定義する強力な方法です。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target>C#やJavaのような言語におけるインターフェースの最も一般的な使用方法の1つである、クラスが特定のコントラクトを満たすように明示的に強制することも、TypeScriptで可能です。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target>&lt;code&gt;window.someName&lt;/code&gt;への1つ以上の代入</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target>このような例の1つは、関数とオブジェクトの両方として機能するオブジェクトで、追加のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target>注意すべき点は、&lt;code&gt;const&lt;/code&gt;アサーションは、単純なリテラル式に対してのみ即座に適用できるということです。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target>&amp;lsquo;.d.ts&amp;rsquo;宣言ファイルのみを出力します。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target>ブラウザで&lt;code&gt;greeter.html&lt;/code&gt;を開き、最初の簡単なTypeScript Webアプリケーションを実行します。</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target>&lt;strong&gt;Dependencies&amp;gt;Manage NuGet Packages&amp;gt;Browseを開きます。&lt;/strong&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt;と&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;を検索してインストールします。</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target>&lt;code&gt;Startup.cs&lt;/code&gt;ファイルを開き、&lt;code&gt;Configure&lt;/code&gt;関数を次のように編集します。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes">
          <source>Option</source>
          <target>オプション</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target>Option&lt;code&gt;--outDir&lt;/code&gt;は、入力階層を出力に複製します。 コンパイラは、入力ファイルのルートをすべての入力ファイルの最長共通パスとして計算し、それを使用して出力内のすべてのサブ構造を複製します。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target>オプションの&lt;code&gt;catch&lt;/code&gt;句変数</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes">
          <source>Optional Chaining</source>
          <target>オプションの連鎖</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target>オプションモジュールのロードおよびその他の高度なロードのシナリオ</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes">
          <source>Optional Parameters and Rest Parameters</source>
          <target>オプションパラメータとレストパラメータ</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes">
          <source>Optional Parameters in Callbacks</source>
          <target>コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes">
          <source>Optional Properties</source>
          <target>オプションのプロパティ</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes">
          <source>Optional and Default Parameters</source>
          <target>オプションおよびデフォルトのパラメータ</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target>オプションの連鎖には、他の2つの操作も含まれます。 最初に、&lt;em&gt;オプションの要素アクセス&lt;/em&gt;があります。これは、オプションのプロパティアクセスと同様に機能しますが、識別子以外のプロパティ(任意の文字列、数値、記号など)にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes">
          <source>Optional chaining is &lt;a href="https://github.com/microsoft/TypeScript/issues/16"&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target>オプションの連鎖は、&lt;a href="https://github.com/microsoft/TypeScript/issues/16"&gt;issue#16&lt;/a&gt;です。 ちなみに、それ以来TypeScriptの課題追跡ツールには23,000以上の問題がある。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes">
          <source>Optional class properties</source>
          <target>オプションのクラスプロパティ</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes">
          <source>Optional elements in tuple types</source>
          <target>タプル型のオプション要素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes">
          <source>Optional elements in tuple types.</source>
          <target>タプル型のオプション要素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes">
          <source>Optional parameters and properties</source>
          <target>オプションのパラメータとプロパティ</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target>オプションのパラメータとプロパティには、型注釈に&lt;code&gt;undefined&lt;/code&gt;が含まれていない場合でも、自動的に&lt;code&gt;undefined&lt;/code&gt;が型に追加されます。たとえば、次の2つの型は同じです。</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target>オプションのプロパティとメソッドをクラスで宣言できるようになりました。これはインタフェースですでに許可されているものと同じです。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target>オプション:Visual Studioで&lt;code&gt;greeter.ts&lt;/code&gt;を開くか、コードをTypeScriptプレイグラウンドにコピーします。 識別子の上にカーソルを移動すると、そのタイプが表示されます。 場合によっては、これらのタイプが自動的に推測されます。 最後の行を再入力すると、DOM要素の型に基づいた補完リストとパラメーター・ヘルプが表示されます。 greeter関数への参照にカーソルを合わせ、F12キーを押して定義を表示します。 シンボルを右クリックし、リファクタリングを使用して名前を変更することもできます。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from "module"&lt;/code&gt; syntax.</source>
          <target>オプションで、モジュールは1つまたは複数のモジュールをラップし、&lt;code&gt;export*from"module"&lt;/code&gt;構文を使用してすべてのエクスポートを結合できます。</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes">
          <source>Or ignore trailing elements, or other elements:</source>
          <target>または、末尾の要素または他の要素を無視します。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes">
          <source>Or other elements:</source>
          <target>その他の要素:</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes">
          <source>Or we might want a readonly version:</source>
          <target>また、読み取り専用バージョンが必要な場合もあります。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target>または、指定されていない&lt;code&gt;Function&lt;/code&gt;型を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes">
          <source>Or, even manually set all the values in the enum:</source>
          <target>あるいは、enumのすべての値を手動で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target>あるいは、&lt;code&gt;any&lt;/code&gt;型を使用してID関数を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes">
          <source>Ordering</source>
          <target>順序</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes">
          <source>Organizing Types</source>
          <target>タイプの編成</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes">
          <source>Other types from Closure also work:</source>
          <target>Closureの他のタイプも使用できます:</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes">
          <source>Other variants are allowed as well:</source>
          <target>その他の変形も可能です。</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target>それ以外の場合は、&lt;code&gt;--keyofStringsOnly&lt;/code&gt;コンパイラオプションを使用して、新しい動作を無効にします。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target>それ以外の場合、条件は1つ以上の型変数に依存し、条件型は遅延されます。</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href="https://nodejs.org/"&gt;Node.js&lt;/a&gt; with &lt;a href="https://www.npmjs.com/"&gt;npm&lt;/a&gt;.</source>
          <target>それ以外の場合は、すでに&lt;a href="https://nodejs.org/"&gt;npm&lt;/a&gt;で&lt;a href="https://www.npmjs.com/"&gt;Node.js&lt;/a&gt;を使用していると仮定します。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes">
          <source>Our First Interface</source>
          <target>最初のインタフェース</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;"dependencies"&lt;/code&gt; and not &lt;code&gt;"devDependencies"&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target>このパッケージはそれぞれの宣言を公開しているので、&lt;code&gt;browserify typescript extension&lt;/code&gt;パッケージのユーザーは、これらの依存関係も持つ必要があります。 そのため、&lt;code&gt;"dependencies"&lt;/code&gt;ではなく&lt;code&gt;"dependencies"&lt;/code&gt;を使用しました。&lt;code&gt;"devDependencies"&lt;/code&gt;でなければ、これらのパッケージを手動でインストールする必要がありました。 コマンドラインアプリケーションを作成したばかりで、パッケージがライブラリとして使用されることを想定していなかった場合は、&lt;code&gt;devDependencies&lt;/code&gt;を使用した可能性があります。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes">
          <source>Output</source>
          <target>出力</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes">
          <source>Output File Extension</source>
          <target>出力ファイル拡張子</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes">
          <source>Output directory for generated declaration files.</source>
          <target>生成された宣言ファイルの出力ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes">
          <source>Output generation</source>
          <target>出力生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target>&lt;code&gt;.tsx&lt;/code&gt;ファイル以外では、山括弧のアサーション構文も使用できます。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes">
          <source>Overall Structure</source>
          <target>全体構造</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes">
          <source>Overloaded Function</source>
          <target>オーバーロードされた関数</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes">
          <source>Overloaded Functions</source>
          <target>オーバーロードされた関数</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes">
          <source>Overloads</source>
          <target>オーバーロード</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes">
          <source>Overloads and Callbacks</source>
          <target>オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes">
          <source>Overview</source>
          <target>概要</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes">
          <source>Packages under the &lt;a href="https://www.npmjs.com/~types"&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped"&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href="https://github.com/Microsoft/types-publisher"&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped"&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href="http://definitelytyped.org/guides/contributing.html"&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target>&lt;a href="https://www.npmjs.com/~types"&gt;@types&lt;/a&gt;組織のパッケージは、&lt;a href="https://github.com/Microsoft/types-publisher"&gt;タイプ発行ツール&lt;/a&gt;を使用して&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped"&gt;DefinitelyTyped&lt;/a&gt;から自動的に発行されます。@typesパッケージとして発行された宣言を取得するには、&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped"&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;にプルリクエストを送信してください。詳細については、&lt;a href="http://definitelytyped.org/guides/contributing.html"&gt;貢献のガイドラインのページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes">
          <source>Packaging dependent declarations</source>
          <target>パッケージ依存宣言</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes">
          <source>Parameter Decorators</source>
          <target>パラメータ修飾子</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes">
          <source>Parameter properties</source>
          <target>パラメータのプロパティ</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target>パラメータプロパティを宣言するには、コンストラクタパラメータの前にアクセシビリティ修飾子または&lt;code&gt;readonly&lt;/code&gt;、あるいはその両方を付けます。 パラメータプロパティに&lt;code&gt;private&lt;/code&gt;を使用すると、privateメンバを宣言して初期化します。同様に、&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、および&lt;code&gt;readonly&lt;/code&gt;についても同様です。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target>&lt;code&gt;_&lt;/code&gt;で始まる名前を持つパラメータ宣言は、未使用のパラメータチェックから除外されます。 例:</target>
        </trans-unit>
        <trans-unit id="dedec891c79376a205d8bacaa74301ba59590fa1" translate="yes">
          <source>Parameters&lt;T&gt;</source>
          <target state="translated">Parameters&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes">
          <source>Parse in strict mode and emit &lt;code&gt;"use strict"&lt;/code&gt; for each source file</source>
          <target>strictモードで解析し、ソースファイルごとに&lt;code&gt;"use strict"&lt;/code&gt;を出力する</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target>ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes">
          <source>Parses all the code in strict mode.</source>
          <target>strictモードですべてのコードを解析します。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target>複合プロジェクト(&lt;code&gt;composite&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;に設定した&lt;code&gt;tsconfig.json&lt;/code&gt;)の目的の一部は、異なるプロジェクト間の参照をインクリメンタルに構築できることです。 したがって、複合プロジェクトは&lt;strong&gt;常に&lt;/strong&gt;&lt;code&gt;.ツバイルドインフォ&lt;/code&gt;ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="4559303d2afaf6c943cdd9c2789462ca9afeffa9" translate="yes">
          <source>Partial&lt;T&gt;</source>
          <target state="translated">Partial&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target>&lt;code&gt;--reactNamespace&amp;lt;JSX factory Name&amp;gt;&lt;/code&gt;を&lt;code&gt;--jsx react&lt;/code&gt;とともに渡すと、デフォルトの&lt;code&gt;React&lt;/code&gt;とは異なるJSX factoryを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes">
          <source>Path mapping</source>
          <target>パスマッピング</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes">
          <source>Patterns that are known NOT to be supported</source>
          <target>サポートされていないことがわかっているパターン</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes">
          <source>Per-file JSX factories</source>
          <target>ファイル単位のJSXファクトリー</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function"&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript"&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target>別のコンパイル(&lt;a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function"&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt;や&lt;a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript"&gt;@babel/plugin transform typescript&lt;/a&gt;など)が安全であることを確認するために、追加のチェックを実行します。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes">
          <source>Performance Improvements</source>
          <target>パフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="38777db9796d83a5327d67f885a76a2df366cf8a" translate="yes">
          <source>Pick&lt;T,K&gt;</source>
          <target>&lt;T,K&gt;を選択します。</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes">
          <source>Pitfalls of Namespaces and Modules</source>
          <target>名前空間とモジュールの落とし穴</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target>コンパイラには、出力可能なファイルが含まれていないことに注意してください。たとえば、入力に&lt;code&gt;index.ts&lt;/code&gt;が含まれている場合、&lt;code&gt;index.d.ts&lt;/code&gt;および&lt;code&gt;index.js&lt;/code&gt;は除外されます。 一般に、拡張子だけが異なるファイルを隣接させることはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target>このコメントはエラー報告を抑制するだけであることに注意してください。このコメントは&lt;em&gt;慎重に&lt;/em&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target>これには、非配列値の実行時にネイティブな&lt;code&gt;Symbol.iterator&lt;/code&gt;または&lt;code&gt;Symbol.iterator&lt;/code&gt;shimが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target>typescriptのローダはts loaderだけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes">
          <source>Please notice that &lt;code&gt;"paths"&lt;/code&gt; are resolved relative to &lt;code&gt;"baseUrl"&lt;/code&gt;. When setting &lt;code&gt;"baseUrl"&lt;/code&gt; to another value than &lt;code&gt;"."&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;"baseUrl": "./src"&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;"../node_modules/jquery/dist/jquery"&lt;/code&gt;.</source>
          <target>&lt;code&gt;"paths"&lt;/code&gt;は、&lt;code&gt;"baseUrl"&lt;/code&gt;に対して相対的に解決されることに注意してください。&lt;code&gt;"baseUrl"&lt;/code&gt;を&lt;code&gt;"."&lt;/code&gt;(&lt;code&gt;tsconfig.json&lt;/code&gt;のディレクトリ)以外の値に設定する場合は、それに応じてマッピングを変更する必要があります。 例えば、上記の例で&lt;code&gt;"baseUrl":"./src"&lt;/code&gt;を設定すると、jqueryは&lt;code&gt;"./node_modules/jquery/dist/jquery"&lt;/code&gt;にマップされるはずです。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">ポリモーフィックな this 型</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes">
          <source>Polymorphic this types</source>
          <target>この型のポリモーフィック</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes">
          <source>Possible values are:</source>
          <target>指定できる値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target>オブジェクトリテラル型のプロパティ型で接尾記号が等しい場合、オプションのプロパティは指定されません:</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes">
          <source>Predefined conditional types</source>
          <target>事前定義された条件タイプ</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target>プロジェクトの前には、プロジェクトの出力が現在のプロジェクトの出力の上に含まれます。 これは&lt;code&gt;.js&lt;/code&gt;ファイルと&lt;code&gt;.d.ts&lt;/code&gt;ファイルの両方で動作し、ソースマップファイルも正しく出力されます。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes">
          <source>Preprocessing input files</source>
          <target>入力ファイルの前処理</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target>Pretty&lt;code&gt;--pretty&lt;/code&gt;出力</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target>&lt;code&gt;tsc&lt;/code&gt;からのエラーメッセージの表示</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes">
          <source>Preventing Name Conflicts</source>
          <target>名前の競合の防止</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target>以前は、CommonJS/AMD/UMDモジュールはES6モジュールと同じように扱われていたため、いくつかの問題が発生していました。 つまり</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target>以前はエラーでしたが、TypeScript1.8でサポートされるようになりました。 ループ内の&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;宣言と関数内でキャプチャされた&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;のフレッシュセマンティクスと正しく一致するように、&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;宣言が発行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href="https://github.com/rollup/rollup"&gt;rollup&lt;/a&gt;.</source>
          <target>以前は無効なフラグの組み合わせとしてフラグが立てられていましたが、&lt;code&gt;target:es5&lt;/code&gt;と&amp;lsquo;module:es6&amp;rsquo;がサポートされるようになりました。 これにより、&lt;a href="https://github.com/rollup/rollup"&gt;rollup&lt;/a&gt;のようなES2015ベースのツリーシェーカーの使用が容易になります。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target>以前は、ターゲットがES6/ES2015以降の場合にのみジェネレータがサポートされていました。 さらに、&lt;code&gt;for.of&lt;/code&gt;のようなIteratorプロトコルで動作する構成体は、ES6/ES2015以下のターゲットのアレイで動作する場合にのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target>以前は、&lt;/code&gt;変数の&lt;code&gt;for.in&lt;/code&gt;の型は&lt;code&gt;any&lt;/code&gt;と推論されていました。これにより、コンパイラは&lt;code&gt;for.in&lt;/code&gt;本体内の無効な使用を無視できました。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes">
          <source>Previously there were two options:</source>
          <target>以前は、次の2つのオプションがありました。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target>以前は、&lt;code&gt;obj&lt;/code&gt;に対してタイプ&lt;code&gt;{}&lt;/code&gt;が推測されていましたが、&lt;code&gt;obj&lt;/code&gt;にプロパティがないように見えるため、2行目でエラーが発生しました。 これは明らかに理想的ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target>以前は、ディスクリミナタド以外のユニオンでは、そのメンバーに対して&lt;em&gt;余分な&lt;/em&gt;プロパティ・チェックが行われていなかったため、&lt;code&gt;name&lt;/code&gt;プロパティが正しく入力されなかった。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target>以前は、TypeScriptが変数の型を認識できなかった場合、&lt;code&gt;任意の&lt;/code&gt;型を選択していました。</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target>以前は、単一のtsconfigファイルを使うと、この構造体を扱いにくいものでした。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes">
          <source>Print help message.</source>
          <target>ヘルプメッセージを印刷します。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes">
          <source>Print names of files part of the compilation.</source>
          <target>コンパイルの一部であるファイルの名前を出力します。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes">
          <source>Print names of generated files part of the compilation.</source>
          <target>コンパイルの一部として生成されたファイルの名前を出力します。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target>コンパイラのバージョンを印刷します。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target>3.3より前のバージョンでは、&lt;code&gt;--build--watch&lt;/code&gt;を使用して複合プロジェクトを構築する際に、この増分ファイル監視インフラストラクチャは実際には使用されていませんでした。 &lt;code&gt;--build--watch&lt;/code&gt;モードで1つのプロジェクトを更新すると、そのプロジェクト内のどのファイルが影響を受けたかを判断するのではなく、そのプロジェクトの完全なビルドが強制されます。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target>TypeScript2.4より前の次の例</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target>TypeScript2.4より前のバージョンでは、この例は成功するでしょう。 &lt;code&gt;map&lt;/code&gt;の型を関連付けるとき、TypeScriptはそれらのパラメータ(すなわち&lt;code&gt;f&lt;/code&gt;の型)を双方向に関連付ける。 各&lt;code&gt;f&lt;/code&gt;を関連付けるとき、TypeScriptは&lt;em&gt;それらの&lt;/em&gt;パラメータの型を双方向に関連付ける。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes">
          <source>Private and Protected Constructors</source>
          <target>privateおよびprotectedコンストラクタ</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target>クラス内のプライベートメンバーと保護されたメンバーは、その互換性に影響します。 クラスのインスタンスの互換性をチェックするときに、ターゲット・タイプにプライベート・メンバーが含まれている場合は、ソース・タイプにも同じクラスから生成されたプライベート・メンバーが含まれている必要があります。 同様に、保護されたメンバーを持つインスタンスについても同様です。 これにより、クラスはそのスーパークラスと割り当て互換性を持つことができますが、他の点では同じ形状を持つ、異なる継承階層のクラスとは&lt;em&gt;互換性がありません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes">
          <source>Private and protected members in classes</source>
          <target>クラス内のプライベートメンバーと保護されたメンバー</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes">
          <source>ProgrammerCalculator.ts</source>
          <target>ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes">
          <source>Project Configuration</source>
          <target>プロジェクト構成</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes">
          <source>Project References</source>
          <target>プロジェクト参照</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes">
          <source>Project References: Build Mode for TypeScript</source>
          <target>プロジェクト参照:TypeScriptの構築モード</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes">
          <source>Project References: Caveats</source>
          <target>プロジェクト参照: 警告</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes">
          <source>Project References: Caveats for Project References</source>
          <target>プロジェクト参照: プロジェクト参照に関する注意事項</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes">
          <source>Project References: MSBuild</source>
          <target>プロジェクト参照:MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes">
          <source>Project References: Overall Structure</source>
          <target>プロジェクト参照: 全体構造</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes">
          <source>Project References: Structuring for outFiles</source>
          <target>プロジェクト参照: outFilesの構造化</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes">
          <source>Project References: Structuring for relative modules</source>
          <target>プロジェクト参照: 相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes">
          <source>Project References: What is a Project Reference?</source>
          <target>プロジェクト参照: プロジェクトリファレンスとは。</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes">
          <source>Project References: composite</source>
          <target>プロジェクト参照:合成</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes">
          <source>Project References: declarationMaps</source>
          <target>プロジェクト参照:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes">
          <source>Project References: prepend with outFile</source>
          <target>プロジェクト参照:先頭にoutFileを付加</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes">
          <source>Project References: tsc -b Commandline</source>
          <target>プロジェクト参照:tsc-bコマンドライン</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target>プロジェクト参照はTypeScript3.0の新機能で、TypeScriptプログラムをより小さな部分に構造化できる。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes">
          <source>Project references can solve all of these problems and more.</source>
          <target>プロジェクト参照を使用すると、これらの問題をすべて解決できます。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target>プロジェクト参照には、注意すべきいくつかのトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;によるプロジェクトサポート</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes">
          <source>Properties are inferred from assignments in class bodies</source>
          <target>プロパティはクラスボディの割り当てから推定されます</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes">
          <source>Properties declarations on functions</source>
          <target>関数のプロパティ宣言</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target>オブジェクト・バインディング・パターン内のプロパティーのうち、オブジェクト・リテラル内に一致しないプロパティーは、オブジェクト・バインディング・パターン内にデフォルト値が必要であり、自動的にオブジェクト・リテラル・タイプに追加されます。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target>オブジェクト・バインディング・パターンに一致しないオブジェクト・リテラルのプロパティはエラーです。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target>オブジェクト・バインディング・パターンにデフォルト値があるプロパティは、オブジェクト・リテラルではオプションになります。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes">
          <source>Property Decorators</source>
          <target>プロパティー修飾子</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target>プロパティの代入と非ジェネリックの展開式は、ジェネリックの展開式の両側で可能な限りマージされます。 例:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes">
          <source>Property renaming</source>
          <target>プロパティ名の変更</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes">
          <source>Prototype assignment</source>
          <target>プロトタイプの割り当て</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target>ES5またはES3をターゲットとする場合、&lt;code&gt;for.of&lt;/code&gt;内の反復可能性を完全にサポートし、分散と構造解除を行います。</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes">
          <source>Public by default</source>
          <target>デフォルトでパブリック</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes">
          <source>Public, private, and protected modifiers</source>
          <target>public、private、protected修飾子</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes">
          <source>Publish to &lt;a href="https://www.npmjs.com/~types"&gt;@types&lt;/a&gt;</source>
          <target>&lt;a href="https://www.npmjs.com/~types"&gt;@types&lt;/a&gt;に発行する</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes">
          <source>Publish to npm</source>
          <target>npmにパブリッシュする</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes">
          <source>Publishing</source>
          <target>発行</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes">
          <source>Publishing: Dependencies</source>
          <target>公開:依存関係</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes">
          <source>Publishing: Publish to @types</source>
          <target>発行:@タイプに発行</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes">
          <source>Publishing: Red flags</source>
          <target>パブリッシュ中:警告</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes">
          <source>Put a breakpoint on the line with return.</source>
          <target>returnで行にブレークポイントを置きます。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes">
          <source>Putting all of the above rules together in an example</source>
          <target>上記のすべてのルールを1つの例にまとめる</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes">
          <source>Putting it all together</source>
          <target>まとめ</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target>&lt;code&gt;任意の&lt;/code&gt;型を含む&lt;code&gt;this&lt;/code&gt;式でエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target>暗黙の&lt;code&gt;any&lt;/code&gt;型を持つ式と宣言でエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target>他の入力オプションとconfigファイルを使って実際にビルドを実行するのではなく、出力に最終的な暗黙のconfigファイルを表示します。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target>再コンパイルすると、エラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes">
          <source>Re-declarations and Shadowing</source>
          <target>再宣言とシャドーイング</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes">
          <source>Re-export to extend</source>
          <target>延長するための再エクスポート</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes">
          <source>Re-exporting</source>
          <target>再エクスポート</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes">
          <source>Re-exports</source>
          <target>再エクスポート</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target>&lt;code&gt;tsc greeter.ts&lt;/code&gt;を再実行すると、生成されたJavaScriptが以前のコードと同じであることが確認できます。 TypeScriptのクラスは、JavaScriptで頻繁に使用されるプロトタイプベースのOOの略です。</target>
        </trans-unit>
        <trans-unit id="e9192027041411d6b4ea43ab3d2abaa7789f3108" translate="yes">
          <source>React &amp; Webpack</source>
          <target>ReactとWebpack</target>
        </trans-unit>
        <trans-unit id="d60197c0069397d811ef8e8cfd613ee78915221b" translate="yes">
          <source>React &amp; Webpack: Add a TypeScript configuration file</source>
          <target>React&amp;Webpack:TypeScript設定ファイルを追加</target>
        </trans-unit>
        <trans-unit id="4900e6182fa1b0641c8fe82ddb97be916cb7da5c" translate="yes">
          <source>React &amp; Webpack: Create a webpack configuration file</source>
          <target>React&amp;Webpack:Webpack設定ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="956cb1c66303c129b745c9e9ca384f20d4c70c79" translate="yes">
          <source>React &amp; Webpack: Initialize the project</source>
          <target>React&amp;Webpack:プロジェクトを初期化</target>
        </trans-unit>
        <trans-unit id="793691063497b2cc90622fe41d2d0553070318d6" translate="yes">
          <source>React &amp; Webpack: Install our dependencies</source>
          <target>React&amp;Webpack:依存関係をインストールする</target>
        </trans-unit>
        <trans-unit id="fd4ad992382715487e5d3290959b47bbe4281a10" translate="yes">
          <source>React &amp; Webpack: Lay out the project</source>
          <target>React&amp;Webpack:プロジェクトのレイアウト</target>
        </trans-unit>
        <trans-unit id="b411f0b4704e9cec32d0ca3c922f9acb0fdc84a8" translate="yes">
          <source>React &amp; Webpack: Putting it all together</source>
          <target>React&amp;Webpack:すべてをまとめる</target>
        </trans-unit>
        <trans-unit id="61affa26d33430951c75b6957dc71f21c23d9938" translate="yes">
          <source>React &amp; Webpack: Write some code</source>
          <target>React&amp;Webpack:コードを書く</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React &amp;amp; Webpack</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes">
          <source>React integration</source>
          <target>React統合</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target>React-nativeビルドパイプラインでは、ファイルにJSX構文が含まれている場合でも、すべてのファイルに&lt;code&gt;.js&lt;/code&gt;拡張子が必要です。 新しい&lt;code&gt;--jsx&lt;/code&gt;値&lt;code&gt;react-native&lt;/code&gt;は、出力ファイルのJSX構文に従いますが、&lt;code&gt;.js&lt;/code&gt;拡張子を与えます。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target>&lt;code&gt;src&lt;/code&gt;ディレクトリにある(&lt;code&gt;include&lt;/code&gt;を持つ)ファイルを読み込む。</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes">
          <source>Read-only properties and index signatures</source>
          <target>読み取り専用プロパティとインデックスシグネチャ</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target>読み込み専用プロパティには初期化子があり、同じクラス宣言内のコンストラクタでに割り当てられる場合がありますが、それ以外の場合は読み込み専用プロパティへの割り当ては許可されません。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes">
          <source>Readonly modifier</source>
          <target>読み取り専用モディファイア</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes">
          <source>Readonly properties</source>
          <target>読み取り専用プロパティ</target>
        </trans-unit>
        <trans-unit id="2ace04f66bd3f258f1efe7a3cdd72fde9308dcdd" translate="yes">
          <source>Readonly&lt;T&gt;</source>
          <target state="translated">Readonly&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes">
          <source>Ready? Take a look:</source>
          <target>いいか? 見てください:</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target>しかし、実際のアプリケーションは、上記の&lt;code&gt;Readonly&lt;/code&gt;または&lt;code&gt;Partial&lt;/code&gt;のように見えます。 既存のタイプに基づいてプロパティを変換します。 &lt;code&gt;keyof&lt;/code&gt;とインデックス付きアクセスタイプがある場所:</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes">
          <source>Recall how to write a type assertion:</source>
          <target>型アサーションの書き方を思い出してください。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target>Node.jsは&lt;code&gt;moduleB.js&lt;/code&gt;という名前のファイルを探し、次に該当する&lt;code&gt;package.json&lt;/code&gt;、そして&lt;code&gt;index.js&lt;/code&gt;を探したことを思い出してください。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target>前述の&lt;code&gt;setTimeout&lt;/code&gt;例では、&lt;code&gt;for&lt;/code&gt;ループの反復ごとに変数の状態を取得するためにIIFEを使用する必要があることを思い出してください。 実際には、キャプチャした変数の新しい変数環境を作成していました。 これは少し面倒なことでしたが、幸いなことに、TypeScriptでこれを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes">
          <source>Recommendations</source>
          <target>推奨事項</target>
        </trans-unit>
        <trans-unit id="29a577d3a81a218d182a18d0cee2b6083b8ce39a" translate="yes">
          <source>Record&lt;K,T&gt;</source>
          <target state="translated">Record&lt;K,T&gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes">
          <source>Red Flags</source>
          <target>レッドフラッグ</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes">
          <source>Red flags</source>
          <target>赤のフラグ</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes">
          <source>Redirect output structure to the directory.</source>
          <target>出力構造をディレクトリにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target>参照プロジェクトでは、新しい&lt;code&gt;composite&lt;/code&gt;設定を有効にする必要があります。 この設定は、TypeScriptが参照先プロジェクトの出力の場所をすばやく判断できるようにするために必要です。 &lt;code&gt;composite&lt;/code&gt;フラグを有効にすると、いくつかの点が変わります。</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target>値空間のオブジェクトを型として参照しても、オブジェクトがコンストラクター関数のように型を作成しない限り、&amp;rsquo;は動作しません。</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes">
          <source>Related</source>
          <target>関連</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require("./moduleB");&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target>相対パスはかなり単純です。 例として、&lt;code&gt;/root/src/moduleA.js&lt;/code&gt;にあるファイルにimport&lt;code&gt;var x=require("./moduleB");&lt;/code&gt;Node.jsが次の順序でインポートを解決する場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes">
          <source>Relative vs. Non-relative module imports</source>
          <target>相対モジュールインポートと非相対モジュールインポート</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes">
          <source>Relaxing declaration emit visiblity rules</source>
          <target>表示規則の緩和宣言</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target>変数の取り込みについて前に説明したことを思い出してください。 &lt;code&gt;setTimeout&lt;/code&gt;に渡すすべての関数式は、実際には同じスコープの同じ&lt;code&gt;i&lt;/code&gt;を参照します。</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target>&lt;code&gt;/*!&lt;/code&gt;で始まるcopy-rightヘッダコメントを除くすべてのコメントを削除します。</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target>関数タイプからこのパラメータを削除します。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの内容を次のように置き換えます。</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes">
          <source>Report an error when not all code paths in function return a value.</source>
          <target>関数内のすべてのコードパスが値を返さない場合は、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target>switchステートメントで、fallthroughのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルのエラーを報告します。 &lt;code&gt;--allowJs&lt;/code&gt;と組み合わせて使用します。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes">
          <source>Report errors on unused locals.</source>
          <target>未使用のローカルのエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes">
          <source>Report errors on unused parameters.</source>
          <target>未使用のパラメータに関するエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes">
          <source>Report module resolution log messages.</source>
          <target>レポート・モジュール解決ログ・メッセージ。</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target>必須のタイプパラメータは、オプションのタイプパラメータに続けないでください。</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target>必須、オプション、およびデフォルトのパラメータには、一度に1つのパラメータについて説明するという共通点があります。 複数のパラメータを1つのグループとして扱う場合や、関数が最終的に取るパラメータの数がわからない場合があります。 JavaScriptでは、すべての関数本体内に表示される&lt;code&gt;arguments&lt;/code&gt;変数を使用して、引数を直接操作できます。</target>
        </trans-unit>
        <trans-unit id="b231253b8b2e62c56e31b5d92b6a089e8bb1a9d2" translate="yes">
          <source>Required&lt;T&gt;</source>
          <target state="translated">Required&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target>&lt;code&gt;keyof&lt;/code&gt;を文字列値のプロパティ名のみに解決します(数字や記号は使用しません)。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes">
          <source>Rest Parameters</source>
          <target>レストパラメータ</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes">
          <source>Rest elements in tuple types</source>
          <target>タプル型のrest要素</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes">
          <source>Rest elements in tuple types.</source>
          <target>タプル型のrest要素。</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes">
          <source>Rest parameters with tuple types</source>
          <target>タプル型を持つrestパラメータ</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes">
          <source>Results in an output such as:</source>
          <target>結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes">
          <source>Results in the following generated code:</source>
          <target>次のコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes">
          <source>Results in:</source>
          <target>結果:</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes">
          <source>Return Types of Callbacks</source>
          <target>コールバックの戻り値の型</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes">
          <source>Return types as inference targets</source>
          <target>推論ターゲットとして型を返す</target>
        </trans-unit>
        <trans-unit id="e721f0c08be45ae1fbe1c928cddcbc237d341b06" translate="yes">
          <source>ReturnType&lt;T&gt;</source>
          <target state="translated">ReturnType&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes">
          <source>Reusable Types (Interfaces)</source>
          <target>再利用可能型(インタフェース)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes">
          <source>Reusable Types (Type Aliases)</source>
          <target>再利用可能な型(型別名)</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes">
          <source>Reverse mappings</source>
          <target>逆マッピング</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target>&lt;code&gt;scripts&lt;/code&gt;を右クリックし、&lt;strong&gt;New Item&lt;/strong&gt;をクリックします。次に、&lt;strong&gt;TypeScript File&lt;/strong&gt;を選択し、ファイルに&lt;code&gt;app.ts&lt;/code&gt;という名前を付けます。</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target>&lt;code&gt;wwwroot&lt;/code&gt;フォルダを右クリックし(フォルダが表示されない場合は、プロジェクトを構築してみてください)、&lt;code&gt;index.html&lt;/code&gt;という名前の新しいアイテムを内部に追加します。 &lt;code&gt;index.html&lt;/code&gt;には次のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target>プロジェクトを右クリックし、[&lt;strong&gt;New Item&lt;/strong&gt;]をクリックします。次に、[&lt;strong&gt;JavaScript File&lt;/strong&gt;]を選択し、&lt;code&gt;ガルプフィル.js&lt;/code&gt;という名前を使用します。</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target>右クリック-&amp;gt;NuGetパッケージの管理</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target>ディレクトリ内で&lt;code&gt;tsc--init&lt;/code&gt;を実行して、このディレクトリ内にデフォルト設定で初期&lt;code&gt;tsconfig.json&lt;/code&gt;を作成します。 オプションで、コマンドライン引数を&lt;code&gt;--init&lt;/code&gt;とともに渡し、作成時に最初のtsconfig.jsonに格納します。</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes">
          <source>Run the application and make sure that it works.</source>
          <target>アプリケーションを実行し、動作することを確認します。</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href="configuring-watch"&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target>コンパイラを監視モードで実行します。 入力ファイルを監視し、変更時に再コンパイルをトリガーします。 監視ファイルおよびディレクトリの実装は、環境変数を使用して構成できます。詳細については、&lt;a href="configuring watch"&gt;configuring watch&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes">
          <source>Run the project</source>
          <target>プロジェクトを実行する</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target>&lt;code&gt;tsc--build&lt;/code&gt;(略して&lt;code&gt;tsc-b&lt;/code&gt;)を実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes">
          <source>Running your TypeScript web app</source>
          <target>TypeScript Webアプリケーションの実行</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target>サンプル:System.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target>例:require.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes">
          <source>Schema</source>
          <target>スキーマ</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes">
          <source>Schema can be found at: &lt;a href="http://json.schemastore.org/tsconfig"&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target>スキーマは&lt;a href="http://json.schemastore.org/tsconfig"&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;にあります。</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes">
          <source>Scoping rules</source>
          <target>範囲ルール</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;を検索します</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target>プロジェクト検索バーで&lt;strong&gt;.NET Core&lt;/strong&gt;を検索</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes">
          <source>Searching</source>
          <target>検索中</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target>2番目に、&lt;code&gt;--importHelpers&lt;/code&gt;を使用してファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target>第2に、Typescriptコンパイラは、ジェネリック関数からの型パラメータの拡散を許可しません。 この機能は、将来のバージョンで使用される予定です。</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target>次に、クラスフィールドを使用して基本クラスのプロパティを特殊化することもできません。</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes">
          <source>Sections</source>
          <target>横断</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes">
          <source>See &lt;a href="../project-references"&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target>詳細については、&lt;a href="./project-references"&gt;Project References handbook page&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes">
          <source>See &lt;a href="http://www.typescriptlang.org/docs/handbook/module-resolution.html"&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target>詳細については、&lt;a href="http://www.typescriptlang.org/docs/handbook/module-resolution.html"&gt;モジュールの解決&lt;/a&gt;のマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes">
          <source>See &lt;a href="https://github.com/Microsoft/TypeScript/issues/1256"&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/1256"&gt;課題#1256&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes">
          <source>See &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files"&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files"&gt;Type checking JavaScript Filesのマニュアル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes">
          <source>See &lt;a href="https://www.npmjs.com/package/ts-loader"&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target>ts loaderの詳細については、&lt;a href="https://www.npmjs.com/package/ts-loader"&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes">
          <source>See &lt;a href="tsconfig-json"&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target>詳細については、&lt;a href="tsconfig json"&gt;tsconfig.json&lt;/a&gt;のマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes">
          <source>See the &lt;a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json"&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target>詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json"&gt;tsconfig.json wikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes">
          <source>See the &lt;a href="modules"&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href="namespaces"&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target>モジュールの詳細については、&lt;a href="modules"&gt;Modules&lt;/a&gt;のマニュアルを参照してください。名前空間の詳細については、&lt;a href="namespaces"&gt;Namespaces&lt;/a&gt;のマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target>TypeScriptでのJSXの使用についての詳細は、[[JSX]]wikiページを参照してください。</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target>[&lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt;]を選択し、[次へ&lt;/em&gt;]ボタンを押します。</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes">
          <source>Semicolon Formatter Option</source>
          <target>セミコロンフォーマッタオプション</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes">
          <source>Semicolon-Aware Code Edits</source>
          <target>セミコロン対応のコード編集</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes">
          <source>Sequentially Added Properties</source>
          <target>順次追加されるプロパティ</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes">
          <source>Set up the build</source>
          <target>ビルドのセットアップ</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes">
          <source>Set up the server</source>
          <target>サーバーをセットアップする</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target>&lt;code&gt;baseUrl&lt;/code&gt;を設定すると、コンパイラにモジュールの場所が通知されます。 相対的でない名前を持つすべてのモジュールインポートは、&lt;code&gt;baseUrl&lt;/code&gt;に相対的であると見なされます。</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target>最上位のプロパティー&lt;code&gt;compileOnSave&lt;/code&gt;を設定すると、IDEに対して、保存時に指定されたtsconfig.jsonのすべてのファイルを生成するシグナルが送られます。</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes">
          <source>Setting compiler options in &lt;a href="compiler-options-in-msbuild"&gt;MSBuild projects&lt;/a&gt;.</source>
          <target>&lt;a href="compiler options in msbuild"&gt;MSBuild projects&lt;/a&gt;でコンパイラオプションを設定する。</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes">
          <source>Setting compiler options in &lt;a href="tsconfig-json"&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target>&lt;a href="tsconfig json"&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt;ファイルでコンパイラオプションを設定する。</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target>新しいコンパイラ・フラグ&lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt;を設定すると、モジュール・ローダーが、インポートされた.tsまたは.d.tsに示されていない、何らかの合成デフォルト・インポート・メンバーの作成を実行することを示します。 コンパイラは、モジュール全体の形状を持つ&lt;code&gt;default&lt;/code&gt;エクスポートの存在を推測します。</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes">
          <source>Setting up your Directories</source>
          <target>ディレクトリの設定</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes">
          <source>Setup</source>
          <target>セットアップ</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target>より明確なコードを書くために、シャドウイングは&lt;em&gt;通常&lt;/em&gt;避けるべきです。 これを利用するのに適している場合もありますが、最善の判断をする必要があります。</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes">
          <source>Shorthand ambient module declarations</source>
          <target>短縮環境モジュール宣言</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes">
          <source>Shorthand ambient modules</source>
          <target>簡易環境モジュール</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes">
          <source>Show diagnostic information.</source>
          <target>診断情報を表示します。</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes">
          <source>Show verbose diagnostic information</source>
          <target>詳細な診断情報を表示する</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path="..." /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types="..." /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target>&lt;code&gt;///&amp;lt;reference path="."/&amp;gt;&lt;/code&gt;ディレクティブ(&lt;em&gt;dependency&lt;/em&gt;の宣言として機能)と同様に、&lt;code&gt;///&amp;lt;reference types="."/&amp;gt;&lt;/code&gt;ディレクティブはパッケージへの依存性を宣言します。</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target>配列の展開と同様に、オブジェクトを展開すると、浅いコピーを取得するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target>ユニオン型やインターセクション型と同様に、条件型はそれ自体を再帰的に参照できません。 例えば、以下はエラーです。</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from "foo"&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require("foo").default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from "fs"&lt;/code&gt; or &lt;code&gt;import express from "express"&lt;/code&gt; are not allowed.</source>
          <target>同様に、CommonJS/AMD/UMDモジュールのデフォルトインポート(&lt;code&gt;import d from"foo"&lt;/code&gt;)は、&lt;code&gt;const d=require("foo").default&lt;/code&gt;に相当します。現在利用可能なほとんどのCommonJS/AMD/UMDモジュールには、&lt;code&gt;default&lt;/code&gt;エクスポートがないため、このインポートパターンをES以外のモジュール(CommonJS/AMD/UMD)のインポートに使用することは事実上不可能です。 たとえば、&lt;code&gt;import fs from"fs"&lt;/code&gt;または&lt;code&gt;import express from"express"&lt;/code&gt;は許可されていません。</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap["daniel"]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target>インタフェースを使用して関数型を記述する方法と同様に、&lt;code&gt;a[10]&lt;/code&gt;や&lt;code&gt;ageMap["daniel"]&lt;/code&gt;など、&amp;rdquo;にインデックスを付けることができる型も記述できます。インデックス可能型には、オブジェクトにインデックスを付けるために使用できる型と、インデックスを付けるときに対応する戻り型を記述する&lt;em&gt;インデックス署名&lt;/em&gt;があります。 の例を示します。</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target>インタフェースと同様に、同じ名前の名前空間もメンバーをマージします。 名前空間は名前空間と値の両方を作成するので、両方のマージ方法を理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target>同様に、&lt;code&gt;--target ES2017&lt;/code&gt;はコンパイラに、&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;のようなES2017固有の機能を変換しないように指示する。</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from "moduleB"&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target>同様に、非相対インポートはNode.jsの解決ロジックに従い、まずファイルを検索し、次に該当するフォルダを検索します。 したがって、ソースファイル&lt;code&gt;/root/src/moduleA.ts&lt;/code&gt;の&lt;code&gt;import{b}from"moduleB"&lt;/code&gt;は、次のような検索を行います。</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target>同様に、分解は関数パラメータ宣言で使用できます。</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target>同様に、名前空間を使用して、静的メンバーでenumを拡張できます。</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target>同様に、グローバルスコープは、&lt;code&gt;declare global&lt;/code&gt;宣言を使用してモジュールから拡張できます。</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target>同様に、greeter呼び出しのすべての引数を削除してみてください。 TypeScriptは、予期しない数のパラメータでこの関数を呼び出したことを通知します。 どちらの場合も、TypeScriptはコードの構造と提供する型アノテーションの両方に基づいた静的分析を提供することができます。</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target>同様に、複数の異なるオブジェクトを合成できます。 次の例では、&lt;code&gt;merged&lt;/code&gt;に&lt;code&gt;foo&lt;/code&gt;、&lt;code&gt;bar&lt;/code&gt;、および&lt;code&gt;baz&lt;/code&gt;の各プロパティがあります。</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target>同様に、&lt;code&gt;readonly&lt;/code&gt;-nessを除去し、&lt;code&gt;readonly&lt;/code&gt;配列コンテナを変換してそれらの可変の同等物に戻す、&lt;code&gt;Writable&lt;/code&gt;マップ型のようなユーティリティ型を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target>単純な組み合わせ: 1つの名前、複数の意味</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes">
          <source>Simple Example</source>
          <target>簡単な例</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target>Reactでの&lt;code&gt;props&lt;/code&gt;型管理の単純化</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target>&lt;code&gt;keyof&lt;/code&gt;は、タイプ&lt;code&gt;number&lt;/code&gt;をキータイプに含めることによって、数値インデックスシグネチャの存在を反映するようになったため、&lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt;などのマップされたタイプは、数値インデックスシグネチャを持つオブジェクトタイプに適用すると正しく動作します。</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target>JavaScriptは行の終わりで&lt;code&gt;return&lt;/code&gt;文を自動的に終了するため、オブジェクト・リテラルはブロックになります。</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target>1つのファイルの宣言は、他のファイルの型チェックに影響を与える可能性があるため、&lt;code&gt;--skipLibCheck&lt;/code&gt;が指定されている場合、一部のエラーが検出されないことがあります。 たとえば、非宣言ファイルが宣言ファイルで宣言された型を補強する場合、宣言ファイルがチェックされたときにのみ報告されるエラーが発生することがあります。 しかし、実際にはこのような状況はまれです。</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target>ヌル可能な型はユニオンで実装されているため、&lt;code&gt;null&lt;/code&gt;を取り除くために型ガードを使用する必要があります。幸い、これはJavaScriptで作成するコードと同じです。</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target>範囲は重複する可能性があるため、どのリダイレクトが適用されるかは順序に依存します。 つまり、上記の例では、&lt;code&gt;&amp;gt;=3.2&lt;/code&gt;および&lt;code&gt;&amp;gt;=3.1&lt;/code&gt;の両方のmatcherがTypeScript3.2以上をサポートしていても、順序を逆にすると動作が異なる可能性があるため、上記のサンプルは次のようにはなりません。</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target>&lt;code&gt;.tsx&lt;/code&gt;ファイルでは上記の構文を使用できないため、&lt;code&gt;as&lt;/code&gt;という別のタイプのアサーション演算子を使用する必要があります。この例は、&lt;code&gt;as&lt;/code&gt;演算子を使用すると簡単に記述できます。</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target>クラスは&lt;code&gt;この&lt;/code&gt;型を使用するため、この型を拡張することができ、新しいクラスは変更なしで古いメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target>厳密なチェックを行うと、以前に報告されていないエラーが明らかになる可能性があるため、これは&lt;code&gt;--strict&lt;/code&gt;モードの重大な変更です。</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target>Java Scriptには汎用型パラメータを指定するための自然な構文がないため、型パラメータを指定しないと&lt;code&gt;any&lt;/code&gt;がデフォルトになります。</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target>ES2015以前のJavascriptではパラメータのオプション性を指定する方法がないため、&lt;code&gt;.js&lt;/code&gt;ファイルのすべての関数パラメータはオプションと見なされます。 宣言されたパラメータ数よりも少ない引数を持つ呼び出しが許可されます。</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target>これは重大な変更であるため、厳密なオブジェクトリテラルチェックの場合と同じ回避策について知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes">
          <source>Skip type checking of &lt;a href="triple-slash-directives#-reference-no-default-libtrue"&gt;default library declaration files&lt;/a&gt;.</source>
          <target>&lt;a href="triple slash directives#-reference no defaultリブッラー"&gt;default library declaration files&lt;/a&gt;の型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target>すべての宣言ファイル(&lt;code&gt;*.d.ts&lt;/code&gt;)の型チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes">
          <source>Smarter Auto-Import Syntax</source>
          <target>スマートな自動インポート構文</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes">
          <source>Smarter union type checking</source>
          <target>よりスマートなユニオン型チェック</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target>これまでのところ、&amp;rsquo;は&amp;ldquo;compatible&amp;rdquo;を使用していますが、これは言語仕様で定義された用語ではありません。 TypeScriptには、サブタイプと割り当ての2種類の互換性があります。 これらの違いは、割り当てがサブタイプの互換性を拡張して、&lt;code&gt;任意の&lt;/code&gt;への割り当ておよび&lt;code&gt;enum&lt;/code&gt;からの割り当てを可能にし、対応する数値でサブタイプの互換性を拡張するという点だけである。</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target>したがって、次の入力が与えられると、結果の&lt;code&gt;.js&lt;/code&gt;ファイルには&lt;code&gt;ツリブ&lt;/code&gt;へのインポートが含まれ、インライン化する代わりに&lt;code&gt;__assign&lt;/code&gt;ヘルパーが使用されます。</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;"package-name"&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target>上記の例では、&lt;code&gt;"package-name"&lt;/code&gt;からインポートしている場合、TypeScript3.1で実行するときに&lt;code&gt;[.]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt;(およびその他の関連するパス)から解決しようとします。 &lt;code&gt;package-name/foo&lt;/code&gt;からインポートする場合は、&lt;code&gt;[.]/node_modules/package-name/ts3.3/foo.d.ts&lt;/code&gt;および&lt;code&gt;[.]/node_modules/package-name/ts3.3/foo/index.d.ts&lt;/code&gt;を検索します。1 1。</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path="..." /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target>したがって、コンパイルからファイルを除外するには、そのファイルと&lt;code&gt;import&lt;/code&gt;または&lt;code&gt;//&amp;lt;reference path="."/&amp;gt;&lt;/code&gt;ディレクティブを持つ&lt;strong&gt;すべての&lt;/strong&gt;ファイルを除外する必要があります。</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target>&lt;code&gt;never&lt;/code&gt;を返す関数の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target>&lt;code&gt;never&lt;/code&gt;を返す関数の使用例を次に示します。</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href="https://github.com/rbuckton/ReflectDecorators"&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target>一部の例では、&lt;a href="https://github.com/rbuckton/ReflectDecorators"&gt;実験用メタデータAPI&lt;/a&gt;のポリフィルを追加する&lt;code&gt;reflect metadata&lt;/code&gt;ライブラリを使用しています。このライブラリは、まだECMAScript(JavaScript)標準には含まれていません。 しかし、デコレータがECMAScript標準の一部として正式に採用されれば、これらの拡張は採用のために提案されるだろう。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes">
          <source>Some examples:</source>
          <target>例:</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">一部の種類の宣言は、複数の宣言にまたがって組み合わせることができます。 たとえば、&lt;code&gt;class C { }&lt;/code&gt; と &lt;code&gt;interface C { }&lt;/code&gt; は共存でき、両方とも &lt;code&gt;C&lt;/code&gt;型にプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target>一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしないように設計されています(グローバル変数)。 これらは、&lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt;モジュールと呼ばれます。 これらのライブラリには、インポート変数またはグローバル変数を使用してアクセスできます。 例:</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt; or &lt;a href="http://isomorphic.net"&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target>一部のライブラリは、多くのモジュールローダーで使用するように設計されているか、モジュールをロードしないように設計されています(グローバル変数)。 これらは、&lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt;または&lt;a href="http://isomorphic.net"&gt;Isomorphic&lt;/a&gt;モジュールと呼ばれます。 これらのライブラリには、インポート変数またはグローバル変数を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target>一部のライブラリは、モジュールローダ環境でのみ動作します。 たとえば、&lt;code&gt;express&lt;/code&gt;はNode.jsでのみ動作し、CommonJS&lt;code&gt;require&lt;/code&gt;関数を使用してロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes">
          <source>Some module loaders such as &lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax"&gt;SystemJS&lt;/a&gt; and &lt;a href="https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html"&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target>&lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax"&gt;SystemJS&lt;/a&gt;や&lt;a href="https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html"&gt;AMD&lt;/a&gt;などの一部のモジュールローダーでは、JavaScript以外のコンテンツをインポートできます。 これらは通常、プレフィックスまたはサフィックスを使用して、特殊な読み込みセマンティクスを示します。 ワイルドカード・モジュール宣言を使用すると、このような場合をカバーできます。</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target>TypeScriptのユニークな概念のいくつかは、JavaScriptオブジェクトの形状を型レベルで記述します。 TypeScript特有の例として、&amp;lsquo;宣言のマージ&amp;rsquo;という概念があります。 この概念を理解すると、既存のJavaScriptを使用するときに有利になります。 また、より高度な抽象概念への扉も開きます。</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target>オブジェクトを作成し、その直後にプロパティを追加する方が、見た目が美しいと感じる人もいます。</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target>一部のプラグインは、既存のモジュールのトップレベルエクスポートを追加または変更します。 これはCommonJSや他のローダでは合法ですが、ES6モジュールは不変とみなされ、このパターンは不可能です。 TypeScriptはローダに依存しないので、コンパイル時にこのポリシーを強制することはありませんが、ES6モジュールローダに移行しようとする開発者はこのことを知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target>一部のプロパティは、オブジェクトを最初に作成したときにのみ変更できます。 これを指定するには、プロパティ名の前に&lt;code&gt;readonly&lt;/code&gt;を付けます。</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target>読者の中には、この例をダブル・テイクする人もいます。 変数&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;if&lt;/code&gt;ブロック&lt;/em&gt;内で宣言されましたが、そのブロックの外部からアクセスすることができました。 &lt;code&gt;var&lt;/code&gt;宣言は、それを含む関数、モジュール、名前空間、またはグローバルスコープ内のどこからでもアクセス可能であるため、&lt;code&gt;var&lt;/code&gt;宣言は、それを含むブロックに関係なく、後で説明します。 これを&lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt;または&lt;em&gt;関数scoping&lt;/em&gt;と呼ぶ人もいます。 パラメータも関数スコープです。</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target>一部のチームはmsbuildベースのワークフローを設定しており、tsconfigファイルはペアになっている管理プロジェクトと同じ&lt;em&gt;暗黙的&lt;/em&gt;グラフ順序を持ちます。 このようなソリューションであれば、&lt;code&gt;tsc-p&lt;/code&gt;とともに&lt;code&gt;msbuild&lt;/code&gt;をプロジェクト参照とともに引き続き使用できます。これらは完全に相互運用可能です。</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target>注目すべき点は、ブロックスコープ変数を宣言する前に&lt;em&gt;キャプチャ&lt;/em&gt;できることです。 唯一の落とし穴は、宣言の前にその関数を呼び出すことは違法であるということです。 ES2015をターゲットにしている場合、最新のランタイムはエラーをスローしますが、現時点ではTypeScriptは許容的であり、これをエラーとして報告しません。</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;"jquery"&lt;/code&gt; would be translated at runtime to &lt;code&gt;"node_modules/jquery/dist/jquery.slim.min.js"&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href="http://requirejs.org/docs/api.html#config-paths"&gt;RequireJs documentation&lt;/a&gt; and &lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths"&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target>モジュールが&lt;em&gt;baseUrl&lt;/em&gt;の下に直接配置されていない場合があります。たとえば、モジュール&lt;code&gt;"SystemJS"&lt;/code&gt;へのインポートは、実行時に&lt;code&gt;"node_modules/jquery/dist/jquery.slim.min.js"&lt;/code&gt;に変換されます。ローダーはマッピング構成を使用して、実行時にモジュール名をファイルにマッピングします。詳細については、&lt;a href="http://requirejs.org/docs/api.html#config-paths"&gt;RequireJs documentation&lt;/a&gt;および&lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths"&gt;jquery documentation&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href="http://requirejs.org/docs/api.html#config-paths"&gt;RequireJs documentation&lt;/a&gt; and &lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config"&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target>モジュールが&lt;em&gt;baseUrl&lt;/em&gt;の下に直接置かれていない場合があります。 ローダーはマッピング構成を使用して、実行時にモジュール名をファイルにマップします。&lt;a href="http://requirejs.org/docs/api.html#config-paths"&gt;RequireJsのマニュアル&lt;/a&gt;および&lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config"&gt;SystemJSのマニュアル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target>コンパイル時に複数のディレクトリからのプロジェクトソースがすべて結合され、単一の出力ディレクトリが生成されることがあります。 これは、&amp;ldquo;virtual&amp;rdquo;ディレクトリを作成するソースディレクトリのセットとして表示できます。</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target>たとえば、&lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt;と&lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt;を入力すると、出力構造は&lt;code&gt;FolderA\FolderB\&lt;/code&gt;を反映したものになります。ここで、新しいファイル&lt;code&gt;FolderA\3.ts&lt;/code&gt;を入力に追加すると、出力構造は&lt;code&gt;FolderA\&lt;/code&gt;を反映したものになります。</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target>時には、TypeScriptよりも価値についてよく知っている状況になってしまいます。 通常、これは、エンティティのタイプが現在のタイプよりも具体的である場合に起こります。</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target>exportsオブジェクトを完全に上書きすることもあります。 これはモジュールをすぐに呼び出せるようにするためによく使われるパターンです。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes">
          <source>Specifically:</source>
          <target>具体的には</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target>デバッガがソースの場所ではなくTypeScriptファイルを検索する場所を指定します。 ソースが実行時に、設計時とは異なる場所に配置される場合は、このフラグを使用します。 指定された場所はsourceMapに埋め込まれ、ソース・ファイルが置かれるデバッガーを指示します。</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target>デバッガが生成された場所ではなくマップファイルを検索する場所を指定します。 mapファイルが実行時に.jsファイルとは別の場所にある場合は、このフラグを使用します。 指定された場所はsourceMapに埋め込まれ、デバッガーにマップファイルの場所を指示します。 このフラグは、指定されたパスを作成せず、その場所にマップファイルを生成します。 代わりに、ファイルを指定したパスに移動する構築後の手順を作成します。</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;"react"&lt;/code&gt; JSX emit.</source>
          <target>&lt;code&gt;"react"&lt;/code&gt;JSX emitをターゲットとするときに、&lt;code&gt;createElement&lt;/code&gt;および&lt;code&gt;_spread&lt;/code&gt;に対して呼び出されるオブジェクトを指定します。</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target>入力ファイルのルートディレクトリを指定します。 &lt;code&gt;--outDir&lt;/code&gt;を使用して出力ディレクトリ構造を制御する場合にのみ使用します。</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes">
          <source>Specify &lt;code&gt;"types": []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target>&lt;code&gt;"types":[]&lt;/code&gt;を指定すると、&lt;code&gt;@types&lt;/code&gt;パッケージが自動的に含まれなくなります。</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes">
          <source>Specify ECMAScript target version:</source>
          <target>ECMAScriptターゲットバージョンを指定:</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes">
          <source>Specify module code generation: &lt;code&gt;"None"&lt;/code&gt;, &lt;code&gt;"CommonJS"&lt;/code&gt;, &lt;code&gt;"AMD"&lt;/code&gt;, &lt;code&gt;"System"&lt;/code&gt;, &lt;code&gt;"UMD"&lt;/code&gt;, &lt;code&gt;"ES6"&lt;/code&gt;, &lt;code&gt;"ES2015"&lt;/code&gt; or &lt;code&gt;"ESNext"&lt;/code&gt;.</source>
          <target>モジュールコードの生成を指定してください:&lt;code&gt;"None"&lt;/code&gt;,&lt;code&gt;"CommonJS"&lt;/code&gt;,&lt;code&gt;"AMD"&lt;/code&gt;,&lt;code&gt;"System"&lt;/code&gt;,&lt;code&gt;"UMD"&lt;/code&gt;,&lt;code&gt;"ES6"&lt;/code&gt;,&lt;code&gt;"ES2015"&lt;/code&gt;または&lt;code&gt;"ESNext"&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target>react JSX emitをターゲットにするときに使用するJSXファクトリ関数を指定します。たとえば、&lt;code&gt;React.createElement&lt;/code&gt;または&lt;code&gt;h&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes">
          <source>Specify what file to store incremental build information in.</source>
          <target>増分ビルド情報を格納するファイルを指定します。</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target>&lt;code&gt;--outFile&lt;/code&gt;を&lt;code&gt;--module amd&lt;/code&gt;または&lt;code&gt;--module system&lt;/code&gt;とともに指定すると、コンパイル内のすべてのモジュールが、複数のモジュールクロージャを含む単一の出力ファイルに連結されます。</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target>関数の&lt;code&gt;this&lt;/code&gt;の型の指定</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes">
          <source>Speed improvements</source>
          <target>速度の向上</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes">
          <source>Splitting Across Files</source>
          <target>ファイル間で分割する</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes">
          <source>Spread</source>
          <target>スプレッド</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes">
          <source>Spread expressions with tuple types</source>
          <target>タプル型を持つ式の展開</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes">
          <source>Stable packages are available here:</source>
          <target>安定版パッケージはこちらから入手できます:</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href="https://nodejs.org/api/tty.html"&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target>出力デバイスがカラフルなテキストに適用できる場合、デフォルトでは&lt;code&gt;--pretty&lt;/code&gt;の下にTypeScript2.9エラーが表示されます。 TypeScriptは、出力ストリームに&lt;a href="https://nodejs.org/api/tty.html"&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt;プロパティが設定されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href="https://github.com/Microsoft/TypeScript/issues/2338"&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target>リリース1.6以降、TypeScriptコンパイラは、&amp;lsquo;commonjs&amp;rsquo;をターゲットにした場合、モジュール名を解決するために異なるルールセットを使用します。 これらの&lt;a href="https://github.com/Microsoft/TypeScript/issues/2338"&gt;ルール&lt;/a&gt;は、ノードによって使用されるモジュール参照プロシージャをモデル化しようとしました。 これは、ノード・モジュールがその型指定に関する情報を含むことができ、TypeScriptコンパイラーがそれを見つけることができることを意味します。 ただし、&lt;code&gt;--moduleResolution&lt;/code&gt;コマンドラインオプションを使用すると、コンパイラによって選択されたモジュール解決ルールを上書きできます。 指定できる値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes">
          <source>Starting out</source>
          <target>開始</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target>ECMAScript2015以降では、&lt;code&gt;symbol&lt;/code&gt;は&lt;code&gt;number&lt;/code&gt;や&lt;code&gt;string&lt;/code&gt;のような原始的なデータ型です。</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target>ECMAScript2015以降、JavaScriptにはモジュールという概念があります。 TypeScriptはこの概念を共有している。</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target>ECMAScript2015以降、モジュールは言語のネイティブな部分であり、準拠するすべてのエンジン実装でサポートされる必要があります。 したがって、新しいプロジェクトでは、モジュールがコード編成メカニズムとして推奨されます。</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target>TypeScript1.8以降、Typescriptコンパイラ(&lt;code&gt;tsc.exe&lt;/code&gt;)およびMSBuild統合(&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;および&lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;)用の公式NuGetパッケージが利用できる。</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes">
          <source>Starting with TypeScript 1.8:</source>
          <target>TypeScript1.8以降:</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;"strict": true&lt;/code&gt; setting in the &lt;code&gt;"compilerOptions"&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target>TypeScript2.3以降、&lt;code&gt;tsc--init&lt;/code&gt;によって生成されるデフォルトの&lt;code&gt;tsconfig.json&lt;/code&gt;には、&lt;code&gt;"compilerOptions"&lt;/code&gt;セクションに&lt;code&gt;"strict":true&lt;/code&gt;設定が含まれています。 したがって、&lt;code&gt;tsc--init&lt;/code&gt;で開始された新規プロジェクトでは、デフォルトで最高レベルの型安全性が有効になります。</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target>実行時に実行されないことが保証された文は、到達不能コードエラーとして正しくフラグ付けされるようになりました。 たとえば、無条件の&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt;、または&lt;code&gt;continue&lt;/code&gt;ステートメントに続くステートメントは、到達不能と見なされます。 &lt;code&gt;--allowUnreachableCode&lt;/code&gt;を使用して、到達不能コードの検出とレポートを無効にします。</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes">
          <source>Static Properties</source>
          <target>静的プロパティ</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target>エクスポートされたクラスの静的メソッドにも同様の問題があり、クラス自体がネストの層を追加します。 明確に有用な方法で表現力や意図を高めない限り、ヘルパー関数を単純にエクスポートすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes">
          <source>StaticZipCodeValidator.ts</source>
          <target>StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes">
          <source>Strategies</source>
          <target>戦略</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target>厳密な&lt;code&gt;null&lt;/code&gt;&amp;amp;&lt;code&gt;undefined&lt;/code&gt;チェック</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes">
          <source>Strict Class Initialization</source>
          <target>クラスの厳密な初期化</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes">
          <source>Strict contravariance for callback parameters</source>
          <target>コールバックパラメータの厳密な矛盾</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes">
          <source>Strict function types</source>
          <target>厳密な関数型</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes">
          <source>Stricter Generators</source>
          <target>より厳格なジェネレータ</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes">
          <source>Stricter Generics</source>
          <target>ジェネリックの厳格化</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes">
          <source>Stricter checking for generic functions</source>
          <target>汎用関数のチェック強化</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes">
          <source>Stricter object literal assignment checks</source>
          <target>厳密なオブジェクトリテラル割り当てチェック</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes">
          <source>String</source>
          <target>文字列</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes">
          <source>String Enums</source>
          <target>文字列の列挙</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes">
          <source>String Literal Types</source>
          <target>文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes">
          <source>String enums</source>
          <target>文字列列挙</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes">
          <source>String enums are a similar concept, but have some subtle &lt;a href="#enums-at-runtime"&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target>文字列の列挙も同様の概念ですが、以下に説明するように、&lt;a href="#enums at runtime"&gt;ランタイムの違い&lt;/a&gt;がいくつかあります。 文字列列挙では、各メンバーは文字列リテラルまたは別の文字列列挙メンバーで初期化された定数である必要があります。</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes">
          <source>String literal types</source>
          <target>文字列リテラル型</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target>文字列リテラル型を使用すると、文字列に必要な正確な値を指定できます。 実際には、文字列リテラル型はユニオン型、型ガード、型エイリアスとうまく組み合わせます。 これらの機能を組み合わせて使用すると、文字列の列挙型の動作を取得できます。</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target>文字列リテラル型は、オーバーロードを区別するために同じ方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;"abc"&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target>文字列、数値およびブールリテラル型(たとえば、&lt;code&gt;"abc"&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、および&lt;code&gt;true&lt;/code&gt;)は、明示的な型注釈が存在する場合にのみ、以前に推論されていた。 TypeScript2.1以降、&lt;code&gt;const&lt;/code&gt;変数と&lt;code&gt;readonly&lt;/code&gt;プロパティに対して、リテラル型は&lt;em&gt;常に&lt;/em&gt;推論されます。</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target>オブジェクト型の文字列型のプロパティは、識別子、文字列リテラル、または文字列リテラル型の計算されたプロパティ名を使用して宣言されたプロパティです。</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes">
          <source>StringValidator.ts</source>
          <target>文字列バリデータ.ts</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target>構造的には同一だが異なるクラス型がユニオン型で保存されるようになりました(1つを除くすべてを削除するのではなく)。</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes">
          <source>Structuring for outFiles</source>
          <target>outFilesの構造化</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes">
          <source>Structuring for relative modules</source>
          <target>相対モジュールの構造化</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target>必要なAPI形状を正確に提供するようにモジュールを構成するには、注意が必要です。 例えば、&lt;code&gt;new&lt;/code&gt;の有無にかかわらず呼び出し可能なモジュールが、異なる型を生成し、階層で公開されたさまざまな名前付き型を持ち、モジュール・オブジェクトにもいくつかのプロパティーを持つようにしたいとします。</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes">
          <source>Stylize errors and messages using color and context.</source>
          <target>色とコンテキストを使用してエラーとメッセージにスタイルを適用します。</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes">
          <source>Sublime Text</source>
          <target state="translated">Sublime Text</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes">
          <source>Subtype vs Assignment</source>
          <target>サブタイプと割り当て</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target>サポート&amp;lsquo;ターゲット:es5&amp;rsquo;with&amp;lsquo;module:es6&amp;rsquo;</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target>&lt;code&gt;number&lt;/code&gt;および&lt;code&gt;symbol&lt;/code&gt;名前付きプロパティを&lt;code&gt;keyof&lt;/code&gt;およびマップされた型でサポートする</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;"react"&lt;/code&gt;, &lt;code&gt;"preserve"&lt;/code&gt;, &lt;code&gt;"react-native"&lt;/code&gt;. See &lt;a href="jsx"&gt;JSX&lt;/a&gt;.</source>
          <target>&lt;code&gt;.tsx&lt;/code&gt;ファイルでJSXをサポートします:&lt;code&gt;"react"&lt;/code&gt;,&lt;code&gt;"preserve"&lt;/code&gt;,&lt;code&gt;"react-native"&lt;/code&gt;。&lt;a href="jsx"&gt;JSX&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target>&lt;code&gt;--target ES2016&lt;/code&gt;、&lt;code&gt;--target ES2017&lt;/code&gt;、および&lt;code&gt;--target ESNext&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target>&lt;code&gt;--target ES6&lt;/code&gt;と&lt;code&gt;--module&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target>&lt;code&gt;UMD&lt;/code&gt;および&lt;code&gt;System&lt;/code&gt;モジュール出力のサポート</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target>&lt;code&gt;default&lt;/code&gt;import interop with SystemJSのサポート</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target>JSXにおける&lt;code&gt;defaultProps&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes">
          <source>Support for &lt;code&gt;import d from "cjs"&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target>&lt;code&gt;--esModuleInterop&lt;/code&gt;を使用したCommonJSモジュールからの&lt;code&gt;import d from"cjs"&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target>&lt;code&gt;import.meta&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target>&lt;code&gt;new.target&lt;/code&gt;のサポート</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes">
          <source>Support for Mix-in classes</source>
          <target>Mix-inクラスのサポート</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes">
          <source>Support for UMD module definitions</source>
          <target>UMDモジュール定義のサポート</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes">
          <source>Support for decorators when targeting ES3</source>
          <target>ES3をターゲットとする場合のデコレータのサポート</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target>外部ヘルパーライブラリのサポート(&lt;code&gt;ツリブ&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target>プレーンJavaScriptファイルのサポート(&lt;code&gt;allowJS&lt;/code&gt;およびオプションで&lt;code&gt;checkJs&lt;/code&gt;を使用)</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes">
          <source>Support for spread operator on JSX element children</source>
          <target>JSX要素の子に対するスプレッド演算子のサポート</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes">
          <source>Support output to IPC-driven files</source>
          <target>IPCドリブンファイルへの出力をサポートする</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes">
          <source>Supported JSDoc</source>
          <target>サポートされているJSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href="https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362"&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target>Suppress&lt;code&gt;--インデックスシグネチャを持たないオブジェクトのインデックス付けに関するnoImplicitAny&lt;/code&gt;エラー。 詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362"&gt;課題#1232&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target>&amp;lsquo;//@ts ignore&amp;rsquo;コメントを使用して.tsファイルのエラーを抑制する</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes">
          <source>Suppress excess property checks for object literals.</source>
          <target>オブジェクトリテラルの過剰なプロパティチェックを抑制します。</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target>オブジェクトタイプのシンボルに似たプロパティは、一意のシンボルタイプの計算されたプロパティ名を使用して宣言されたプロパティです。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes">
          <source>Symbols</source>
          <target>記号</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes">
          <source>Symbols are immutable, and unique.</source>
          <target>シンボルは不変で、一意です。</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target>シンボルを計算されたプロパティ宣言と組み合わせて、オブジェクトプロパティとクラスメンバを宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes">
          <source>Symbols: match</source>
          <target>記号:一致</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes">
          <source>Symbols: split</source>
          <target state="translated">split</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes">
          <source>System SimpleModule.js</source>
          <target>システムSimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes">
          <source>System modules have this flag on by default.</source>
          <target>システムモジュールでは、デフォルトでこのフラグがオンになっています。</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes">
          <source>Table of Contents</source>
          <target>目次</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes">
          <source>Table of contents</source>
          <target>目次</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes">
          <source>Tagged template strings in ES3/ES5</source>
          <target>ES3/ES5のタグ付きテンプレート文字列</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target>タグ付きテンプレートは、ECMAScript2015で導入された呼び出し形式です。 呼び出し式と同様に、汎用関数はタグ付きテンプレートで使用でき、TypeScriptは使用される型引数を推測します。</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes">
          <source>Tagged union types</source>
          <target>タグ付きユニオン型</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target>2番目に、次のスニペットの出力を推測します。</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target>ECMAScript2015以降を対象にする</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes">
          <source>Targeting ES5 and ES3</source>
          <target>ES5とES3をターゲットにする</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target>技術的には列挙型は文字列と数値のメンバーを混在させることができますが、なぜそうする必要があるのかは不明です。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes">
          <source>Template</source>
          <target>テンプレート</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes">
          <source>Template strings</source>
          <target>テンプレート文字列</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes">
          <source>Templates</source>
          <target>テンプレート</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes">
          <source>Test</source>
          <target>テスト</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target>glpを実行し、ブラウザで&lt;code&gt;dist/index.html&lt;/code&gt;を開いてページをテストします。 ページに&amp;ldquo;Hello from TypeScript&amp;rdquo;が表示されます。</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes">
          <source>Test the resulting app</source>
          <target>結果のアプリケーションをテストする</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes">
          <source>TestCalculator.ts</source>
          <target>TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes">
          <source>TestProgrammerCalculator.ts</source>
          <target>TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes">
          <source>Thanks to work done by &lt;a href="https://github.com/tinganho"&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target>&lt;a href="https://github.com/tinganho"&gt;@ティンガンホ&lt;/a&gt;による作業のおかげで、TypeScript2.5は、&lt;code&gt;catch&lt;/code&gt;節の変数を省略できる新しいECMAScript機能を実装した。 例えば、&lt;code&gt;JSON.parse&lt;/code&gt;を使用する場合、&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;で関数の呼び出しをラップする必要があるかもしれませんが、入力が誤っている場合にスローされる&lt;code&gt;SyntaxError&lt;/code&gt;を使用することにはならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;"react"&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target>&lt;code&gt;@types/&lt;/code&gt;プレフィックスは、ReactとReact DOMの宣言ファイルも取得したいことを意味します。 通常、&lt;code&gt;"react"&lt;/code&gt;のようなパスをインポートすると、&lt;code&gt;react&lt;/code&gt;パッケージ自体の内部を検索しますが、すべてのパッケージに宣言ファイルが含まれているわけではないので、TypeScriptは&lt;code&gt;@types/react&lt;/code&gt;パッケージも検索します。 後でこれについて考える必要もない。</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes">
          <source>That is, in the example:</source>
          <target>この例では、次のようになります。</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target>最後の例は、実際にはタイプセーフではありません。</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target>これにより、&lt;code&gt;undefined&lt;/code&gt;が分割される可能性があります。&lt;code&gt;strictNullChecks&lt;/code&gt;では、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target>これは&lt;code&gt;tsconfig.json&lt;/code&gt;を自動的にインクルードすることです。 これは、上述したようなモジュール解像度を埋め込まない。 コンパイラがファイルをモジュールインポートのターゲットとして識別した場合、前の手順で除外したかどうかにかかわらず、そのファイルがコンパイルに含まれます。</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target>&lt;code&gt;S&lt;/code&gt;は&lt;code&gt;{done:false,value:number}&lt;/code&gt;にも&lt;code&gt;{done:true,value:number}&lt;/code&gt;にも割り当てることができないためです。なぜですか?&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;done&lt;/code&gt;プロパティは十分に特定されていないためです-&lt;code&gt;T&lt;/code&gt;の各構成要素には、&lt;code&gt;done&lt;/code&gt;プロパティがありますが、&lt;code&gt;T&lt;/code&gt;の各構成要素は、特に&lt;code&gt;true&lt;/code&gt;または&lt;false&gt;の各構成要素があります。 その場合、次のような不良コードが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target>これはTypeScript3.7が導入したものだ。 タイプエイリアスの&amp;ldquo;トップレベル&amp;rdquo;では、TypeScriptはこれらのパターンを許可するためにタイプ引数の解決を保留します。</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target>&amp;rsquo;sは、ブロックスコープ変数が関数スコープ変数で宣言されることは決してありません。 ブロック・スコープ変数は、明確に異なるブロック内で宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target>&amp;ldquo;short-shorting&amp;rdquo;のオプションチェインの動作は、制限されたプロパティアクセス、呼び出し、要素アクセスです。これらの式からは拡張されません。 つまり</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href="http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx"&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target>1.1コンパイラは通常、以前のリリースよりも約4倍高速です。印象的なグラフについては、&lt;a href="http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx"&gt;このブログ投稿を参照してください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes">
          <source>The &lt;a href="https://github.com/tc39/proposal-async-iteration"&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target>&lt;a href="https://github.com/tc39/proposal-async-iteration"&gt;Async Iteration proposal&lt;/a&gt;では、非同期関数である&amp;ldquo;Async Generator&amp;rdquo;を導入しています。これも部分的な計算結果を得るために使用できます。 Async Generatorは、&lt;code&gt;yield*&lt;/code&gt;経由で、iterableまたはasync iterableのどちらかにコールを委譲することもできる。</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes">
          <source>The &lt;a href="library-structures"&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target>「&lt;a href="library structures"&gt;ライブラリ構造&lt;/a&gt;」ガイドでは、一般的なライブラリ形式と、各形式に適した正しい宣言ファイルを記述する方法について説明します。 既存のファイルを編集している場合は、このセクションを読む必要はありません。 新しい宣言ファイルの作成者は、ライブラリのフォーマットが宣言ファイルの作成にどのように影響するかを正しく理解するために、このセクションを読む必要があります。</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes">
          <source>The &lt;a href="publishing"&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target>「&lt;a href="publishing"&gt;発行&lt;/a&gt;」セクションでは、宣言ファイルをnpmパッケージに発行する方法と、依存パッケージを管理する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes">
          <source>The &lt;code&gt;"compilerOptions"&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href="compiler-options"&gt;Compiler Options&lt;/a&gt;.</source>
          <target>&lt;code&gt;"compilerOptions"&lt;/code&gt;プロパティは省略できます。この場合、コンパイラのデフォルトが使用されます。 サポートされている&lt;a href="compiler options"&gt;コンパイラオプション&lt;/a&gt;の完全なリストを参照してください。</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes">
          <source>The &lt;code&gt;"files"&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;"include"&lt;/code&gt; and &lt;code&gt;"exclude"&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;プロパティは、相対ファイルパスまたは絶対ファイルパスのリストを取ります。 &lt;code&gt;"include"&lt;/code&gt;および&lt;code&gt;"exclude"&lt;/code&gt;プロパティは、glob形式のファイルパターンのリストを取ります。 globワイルドカードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target>&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;演算子は、左オペランドの型に存在する型に応じて、&lt;code&gt;null&lt;/code&gt;および/または&lt;code&gt;undefined&lt;/code&gt;を右オペランドの型に追加し、&lt;code&gt;&lt;/code&gt;演算子は、結果のユニオン型の左オペランドの型から&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;の両方を削除します。</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target>&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt;フラグ</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target>TypeScriptの&lt;code&gt;--declaration&lt;/code&gt;フラグを使用すると、&lt;code&gt;.ts&lt;/code&gt;および&lt;code&gt;.tsx&lt;/code&gt;ファイルなどのTypeScriptソースファイルから&lt;code&gt;.d.ts&lt;/code&gt;ファイル(宣言ファイル)を生成できます。 これらの&lt;code&gt;.d.ts&lt;/code&gt;ファイルは、いくつかの理由から重要です。</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target>&lt;code&gt;--noResolve&lt;/code&gt;コンパイラオプションは、コマンドラインで渡されなかったファイルをコンパイルに追加しないようにコンパイラに指示します。 それでもモジュールをファイルに解決しようとしますが、ファイルが指定されていない場合は含まれません。</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target>&lt;code&gt;--preserveSymlinks&lt;/code&gt;コンパイラフラグ</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target>&lt;code&gt;--project&lt;/code&gt;(&lt;code&gt;-p&lt;/code&gt;)フラグは、任意のファイルパスを使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target>&lt;code&gt;--project&lt;/code&gt;コマンドラインオプションは、もともと&lt;code&gt;tsconfig.json&lt;/code&gt;を含むフォルダへのパスしか持てませんでした。ビルド構成のシナリオが異なるので、&lt;code&gt;--project&lt;/code&gt;が他の互換性のあるJSONファイルを指すようにするのは理にかなっています。 例えば、ユーザーはES2015をNode5用のCommonJSモジュールで、ES5をブラウザ用のAMDモジュールでターゲットにしたいと思うかもしれません。 この新しい作業により、ユーザーは&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを別々のディレクトリに置くなどの面倒な回避策を実行することなく、&lt;code&gt;tsc&lt;/code&gt;だけを使用して2つの別々のビルドターゲットを容易に管理することができる。</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;フラグは、この問題を修正します。変数を宣言すると、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;が自動的に含まれなくなります。ユニオン型を使用して明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes">
          <source>The &lt;code&gt;/// &amp;lt;reference path="..." /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target>&lt;code&gt;///&amp;lt;reference path="."/&amp;gt;&lt;/code&gt;ディレクティブは、このグループの中で最も一般的です。 ファイル間の&lt;em&gt;依存関係&lt;/em&gt;の宣言として機能します。</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target>&lt;code&gt;?&lt;/code&gt;演算子は、デフォルト値を使用するときに&lt;code&gt;&lt;/code&gt;の使用を置き換えることができます。 たとえば、次のコードは、&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt;に最後に保存されたボリュームをフェッチしようとします(フェッチされている場合)。ただし、&lt;code&gt;&lt;/code&gt;を使用するため、バグがあります。</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target>&lt;code&gt;@enum&lt;/code&gt;タグを使用すると、指定した型のすべてのメンバを持つオブジェクトリテラルを作成できます。 Javascriptのほとんどのオブジェクトリテラルとは異なり、他のメンバは許可されません。</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href="#decorator-factories"&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target>&lt;code&gt;@enumerable(false)&lt;/code&gt;デコレータは、&lt;a href="#decorator factors"&gt;デコレータ・ファクトリ&lt;/a&gt;です。&lt;code&gt;@enumerable(false)&lt;/code&gt;デコレータが呼び出されると、プロパティ記述子の&lt;code&gt;enumerable&lt;/code&gt;プロパティが変更されます。</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes">
          <source>The &lt;code&gt;@format("Hello, %s")&lt;/code&gt; decorator here is a &lt;a href="#decorator-factories"&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format("Hello, %s")&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target>&lt;code&gt;@format("Hello,%s")&lt;/code&gt;デコレータは、&lt;a href="#decorator factories"&gt;デコレータファクトリ&lt;/a&gt;です。&lt;code&gt;@format("Hello,%s")&lt;/code&gt;が呼び出されると、&lt;code&gt;reflectメタデータ&lt;/code&gt;ライブラリの&lt;code&gt;Reflect.metadata&lt;/code&gt;関数を使用して、プロパティのメタデータエントリが追加されます。 &lt;code&gt;getFormat&lt;/code&gt;が呼び出されると、フォーマットのメタデータ値が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target>&lt;code&gt;@required&lt;/code&gt;デコレータは、必要に応じてパラメータをマークするメタデータエントリを追加します。 &lt;code&gt;@validate&lt;/code&gt;デコレータは、元のメソッドを呼び出す前に引数を検証する関数で、既存の&lt;code&gt;greet&lt;/code&gt;メソッドをラップします。</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target>&lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt;型を使用すると、コンストラクタ関数型のすべてのパラメータ型を抽出できます。 すべてのパラメータ型を持つタプル型を生成します(&lt;code&gt;T&lt;/code&gt;が関数でない場合は、&lt;code&gt;never&lt;/code&gt;型)。</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target>&lt;code&gt;Iterator&lt;/code&gt;型では、生成された型、返された型、&lt;code&gt;next&lt;/code&gt;が受け付ける型をユーザーが指定できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target>&lt;code&gt;Omit&lt;/code&gt;ヘルパー型</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target>&lt;code&gt;ReadonlyArray&lt;/code&gt;タイプは、読み取り専用の&lt;code&gt;Array&lt;/code&gt;を表します。 &lt;code&gt;ReadonlyArray&lt;/code&gt;を参照する変数は、配列の要素を追加、削除、または置換できません。</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target>&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt;マーカインタフェースは、&lt;code&gt;lib.d.ts&lt;/code&gt;で宣言された単なる空のインタフェースです。 オブジェクトリテラルのコンテキスト型で認識されるだけでなく、このインタフェースは空のインタフェースと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target>&lt;code&gt;amd dependency&lt;/code&gt;ディレクティブには、オプションの&lt;code&gt;name&lt;/code&gt;プロパティも指定できます。これにより、amd dependencyにオプションの名前を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target>&lt;code&gt;amd module&lt;/code&gt;ディレクティブを使用すると、コンパイラにオプションのモジュール名を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target>&lt;code&gt;any&lt;/code&gt;型は、既存のJavaScriptを操作する強力な方法であり、コンパイル中に型チェックを徐々にオプトインしたり、オプトアウトしたりすることができます。 &lt;code&gt;Object&lt;/code&gt;は、他の言語と同様の役割を果たすことが期待できます。 ただし、&lt;code&gt;Object&lt;/code&gt;型の変数には、任意の値を割り当てることしかできません。 任意のメソッドを呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target>&lt;code&gt;any&lt;/code&gt;型は、型の一部を知っている場合にも便利ですが、すべてを知っているわけではないかもしれません。 たとえば、配列があっても、その配列にさまざまなタイプが混在しているとします。</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target>&lt;code&gt;as&lt;/code&gt;演算子</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target>&lt;code&gt;as&lt;/code&gt;演算子は、&lt;code&gt;.ts&lt;/code&gt;ファイルと&lt;code&gt;.tsx&lt;/code&gt;ファイルの両方で使用できます。動作は山括弧タイプのアサーションスタイルと同じです。</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target>&lt;code&gt;exclude&lt;/code&gt;リストはビルカーズをサポートしていません。 ファイルやディレクトリのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target>&lt;code&gt;export=&lt;/code&gt;構文は、モジュールからエクスポートされる単一のオブジェクトを指定します。 これは、クラス、インタフェース、名前空間、関数、または列挙型です。</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target>クラスの&lt;code&gt;extends&lt;/code&gt;句では、型参照を指定する必要がありました。 式の後にタイプ引数リストをオプションで指定できるようになりました。 式の型は、&lt;code&gt;extends&lt;/code&gt;節で指定された型引数の数と同数の型パラメータを持つ少なくとも1つの構成体シグネチャを持つコンストラクタ関数型である必要があります。 一致する構成体シグネチャの戻り型は、クラスインスタンス型が継承する基本型です。 これにより、&lt;code&gt;extends&lt;/code&gt;句で実際のクラスと&amp;ldquo;class-like&amp;rdquo;式の両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target>&lt;code&gt;extends&lt;/code&gt;は、&lt;code&gt;tsconfig.json&lt;/code&gt;の最上位プロパティです(&lt;code&gt;compilerOptions&lt;/code&gt;、&lt;code&gt;files&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;、および&lt;code&gt;exclude&lt;/code&gt;と並んで)。 &lt;code&gt;extends&lt;/code&gt;&amp;rsquo;valueは、継承元の別の構成ファイルへのパスを含む文字列です。 パスはNode.jsスタイルの解決を使用できます。</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target>&lt;/code&gt;ステートメントの&lt;code&gt;for await</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target>&lt;code&gt;for.await.of&lt;/code&gt;文は、非同期関数または非同期ジェネレータ内でのみ有効です。</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target>&lt;code&gt;getWidget&lt;/code&gt;関数は、数値を受け取りWidgetを返したり、文字列を受け取りWidget配列を返したりします。</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target>&lt;code&gt;greeter&lt;/code&gt;オブジェクトは、ファイルに記録したり、警告を表示したりできます。 &lt;code&gt;.log(...)&lt;/code&gt;にLogOptionsを指定し、&lt;code&gt;.alert(...)&lt;/code&gt;にアラート・オプションを指定できます。</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target>&lt;code&gt;in&lt;/code&gt;演算子は、型を狭める式として機能するようになりました。</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target>オプション要素を持つタプル型の&lt;code&gt;length&lt;/code&gt;プロパティは、可能な長さを表す数値リテラル型の集合です。 たとえば、&lt;code&gt;[number,string?,boolean?]&lt;/code&gt;タプル・タイプの&lt;code&gt;length&lt;/code&gt;プロパティのタイプは、&lt;code&gt;1 2 3&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target>&lt;code&gt;never&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target>&lt;code&gt;never&lt;/code&gt;タイプには、次の特徴があります。</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target>&lt;code&gt;never&lt;/code&gt;タイプは、すべてのタイプのサブタイプであり、割り当て可能です。ただし、&lt;em&gt;no&lt;/em&gt;タイプは、&lt;code&gt;never&lt;/code&gt;のサブタイプまたは割り当て可能です(&lt;code&gt;never&lt;/code&gt;自体を除く)。 &lt;code&gt;any&lt;/code&gt;であっても、&lt;code&gt;never&lt;/code&gt;に割り当てることはできません。</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target>&lt;code&gt;never&lt;/code&gt;型は、決して発生しない値の型を表します。たとえば、&lt;code&gt;never&lt;/code&gt;は、常に例外をスローする関数式または矢印関数式の戻り値の型です。変数は、真にならない型ガードによって絞り込まれると、&lt;code&gt;never&lt;/code&gt;型も取得します。</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target>&lt;code&gt;new.target&lt;/code&gt;メタプロパティは、ES2015で導入された新しい構文です。 コンストラクタのインスタンスが&lt;code&gt;new&lt;/code&gt;によって作成される場合、&lt;code&gt;new.target&lt;/code&gt;の値は、インスタンスの割り当てに最初に使用されるコンストラクタ関数への参照として設定されます。 関数が&lt;code&gt;new&lt;/code&gt;で構築されずに呼び出された場合、&lt;code&gt;new.target&lt;/code&gt;は&lt;code&gt;undefined&lt;/code&gt;に設定されます。</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target>&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;型は、完全なNULLチェックモードでは&lt;code&gt;any&lt;/code&gt;に拡張されません&lt;em&gt;。</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target>&lt;code&gt;null&lt;/code&gt;の削除はここでは明らかですが、簡潔な演算子も使用できます。</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target>各リファレンスの&lt;code&gt;path&lt;/code&gt;プロパティは、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルが格納されたディレクトリ、または(任意の名前を持つ)構成ファイル自体を指します。</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target>&lt;code&gt;preserve&lt;/code&gt;モードでは、JSX式が出力の一部として保持され、別の変換ステップでさらに消費されます。 &lt;em&gt;さらに、出力には&lt;code&gt;.jsx&lt;/code&gt;ファイル拡張子が付きます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target>&lt;code&gt;protected&lt;/code&gt;修飾子は、&lt;code&gt;private&lt;/code&gt;修飾子とほとんど同じように動作しますが、&lt;code&gt;protected&lt;/code&gt;と宣言されたメンバにも派生クラス内でアクセスできる点が異なります。 たとえば</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target>&lt;code&gt;react&lt;/code&gt;モードは&lt;code&gt;React.createElement&lt;/code&gt;を出力し、使用前にJSX変換を行う必要はなく、出力には&lt;code&gt;.js&lt;/code&gt;ファイル拡張子が付きます。</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target>&lt;code&gt;ref&lt;/code&gt;および&lt;code&gt;key&lt;/code&gt;プロパティは、すべてのコンポーネントで正しいタイプで表示されます。</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target>ステートレス関数コンポーネントのインスタンスでは、&lt;code&gt;ref&lt;/code&gt;プロパティは正しく使用できません。</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target>&lt;code&gt;rootDir&lt;/code&gt;設定は、明示的に設定されていない場合、&lt;code&gt;tsconfig&lt;/code&gt;ファイルを含むディレクトリにデフォルト設定されます。</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target>&lt;code&gt;target&lt;/code&gt;オプション(ユーザーは&lt;code&gt;es5&lt;/code&gt;から&lt;code&gt;es3&lt;/code&gt;,&lt;code&gt;es2015&lt;/code&gt;,&lt;code&gt;esnext&lt;/code&gt;などに切り替えることができる)</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target>&lt;code&gt;この&lt;/code&gt;型は、Mixinスタイルパターンを使って継承を記述するライブラリ(例えばEmber.js)を記述する際に、交差型とともに有用です。</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target>&lt;code&gt;useDefineForClassFields&lt;/code&gt;フラグと&lt;code&gt;declare&lt;/code&gt;プロパティ修飾子</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target>メンバーの&lt;em&gt;プロパティ記述子&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target>&lt;em&gt;ヌリシ結合演算子&lt;/em&gt;は、オプションの連鎖と連携するもう一つのECMAScript機能であり、私たちのチームはTC39のサポートに関わってきました。</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target>非同期反復では、&lt;code&gt;AsyncIterator&lt;/code&gt;が導入されます。これは、&lt;code&gt;Iterator&lt;/code&gt;に似ています。違いは、&lt;code&gt;AsyncIterator&lt;/code&gt;の&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;、および&lt;code&gt;throw&lt;/code&gt;メソッドが、結果そのものではなく、反復結果の&lt;code&gt;Promise&lt;/code&gt;を返すという事実にあります。 これにより、呼び出し側は、&lt;code&gt;AsyncIterator&lt;/code&gt;が値を生成する時点まで進んだ時点で、非同期通知に登録することができます。 &lt;code&gt;AsyncIterator&lt;/code&gt;の形は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes">
          <source>The Examples</source>
          <target>例</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target>モジュールコールシグネチャに対するES6の影響</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes">
          <source>The Impact of ES6 on Module Plugins</source>
          <target>ES6がモジュールプラグインに与える影響</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target>Iteratorプロトコルはまた、&lt;code&gt;for.of&lt;/code&gt;やスプレッド演算子のようないくつかのES2015機能のターゲットを定義し、配列はアシニメネスを分解します。</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes">
          <source>The JSX result type</source>
          <target>JSX結果タイプ</target>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target>TypeScriptコンパイラには、最終的な出力を生成するためにソースに対して起こると予想される変換をコンパイラに通知するための一連の追加フラグがあります。</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;"paths"&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target>TypeScriptコンパイラは、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの&lt;code&gt;"paths"&lt;/code&gt;プロパティを使用して、このようなマッピングの宣言をサポートする。</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;"paths"&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;"paths"&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target>TypeScriptコンパイラは、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの&lt;code&gt;"paths"&lt;/code&gt;プロパティを使用して、このようなマッピングの宣言をサポートする。 次に、&lt;code&gt;jquery&lt;/code&gt;の&lt;code&gt;"paths"&lt;/code&gt;プロパティを指定する例を示します。</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target>TypeScriptコンパイラは、&lt;code&gt;@Reflect.metadata&lt;/code&gt;デコレータを使用して、設計時型情報を注入します。 これは、次のTypeScriptに相当します。</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target>TypeScriptコンパイラは、これらのバージョンを対象とする場合、配列の.をイディオムのようなES3/ES5Java Scriptに変換します。</target>
        </trans-unit>
        <trans-unit id="d0a3305c57ab8c904f89cf46fc29e453fdc3f953" translate="yes">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href="https://github.com/agentcooper"&gt;Artem Tyurin&lt;/a&gt;&amp;acirc;&amp;euro;&amp;trade;s &lt;a href="https://github.com/agentcooper/typescript-play"&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target>TypeScriptの遊び場は、便利な新機能で待望の更新を受けた! この新しい遊び場は、主に&lt;a href="https://github.com/agentcooper"&gt;Artem Tyurin&lt;/a&gt;&amp;acirc;&amp;euro;&amp;trade;s&lt;a href="https://github.com/agentcooper/typescript-play"&gt;TypeScript playground&lt;/a&gt;の分岐であり、コミュニティのメンバーはますます利用している。 Artemにはここで助けてくれて感謝してる!</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target>TypeSriptコンパイラは、必要に応じて&lt;code&gt;__extends&lt;/code&gt;のようなヘルパーを生成します。 ヘルパーは、参照されるすべてのファイルに放出されます。 すべてのヘルパーを1つの場所に統合する場合、またはデフォルトの動作をオーバーライドする場合は、&lt;code&gt;--noEmitHelpers&lt;/code&gt;を使用して、ヘルパーを生成しないようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target>上記のコードでは、文字列を数値で除算できないため、エラーが発生します。 &lt;code&gt;preserve&lt;/code&gt;オプションを使用すると、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target>&lt;code&gt;squareOptions&lt;/code&gt;と&lt;code&gt;SquareConfig&lt;/code&gt;の間に共通のプロパティがある限り、上記の回避策は機能します。この例では、プロパティ&lt;code&gt;width&lt;/code&gt;です。ただし、変数に共通のオブジェクトプロパティがない場合は失敗します。 例:</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target>よりネストされたスコープに新しい名前を導入する行為は、&lt;em&gt;シャドウイング&lt;/em&gt;と呼ばれます。これは、偶発的なシャドウイングの場合に特定のバグを単独で導入し、特定のバグを防止できるという点で、両刃の剣です。 例えば、&lt;code&gt;let&lt;/code&gt;変数を使って&lt;code&gt;sumMatrix&lt;/code&gt;関数を作成したとします。</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target>オプションのプロパティの利点は、インタフェースの一部ではないプロパティを使用できないようにしながら、これらの使用可能なプロパティを記述できることです。 たとえば、&lt;code&gt;createSquare&lt;/code&gt;の&lt;code&gt;color&lt;/code&gt;プロパティの名前を誤って入力すると、次のようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target>代わりに、言語がコードを分析できるようにコードを書き直すという方法もありましたが、これは便利ではありません。</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target>その答えは、オーバーロードのリストとして同じ関数に対して複数の関数型を提供することです。 このリストは、コンパイラが関数呼び出しを解決するために使用するものです。 &amp;rsquo;sは、&lt;code&gt;pickCard&lt;/code&gt;が受け入れるものと、返されるものを記述するオーバーロードのリストを作成します。</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target>引数には、有効なJSON設定ファイルへのファイルパス、または&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを含むディレクトリへのディレクトリパスを指定できます。</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes">
          <source>The as operator</source>
          <target>as演算子</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target>TypeScriptの構造型システムの基本ルールは、&lt;code&gt;y&lt;/code&gt;が少なくとも&lt;code&gt;x&lt;/code&gt;と同じメンバを持つ場合、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;と互換性があるということです。例:</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors["RED"]&lt;/code&gt; to get the string &lt;code&gt;"Red"&lt;/code&gt;.</source>
          <target>ただし、初期化された文字列enumsは、元のenumメンバ名を取得するために逆マップすることはできない。 つまり、&lt;code&gt;Colors["RED"]&lt;/code&gt;を記述して&lt;code&gt;"Red"&lt;/code&gt;という文字列を取得することはできません。</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes">
          <source>The character set of the input files.</source>
          <target>入力ファイルの文字セット。</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target>分類をさらにカスタマイズするには、&lt;code&gt;ツール&lt;/code&gt;-&amp;gt;&lt;code&gt;オプション&lt;/code&gt;-&amp;gt;&lt;code&gt;環境&lt;/code&gt;-&amp;gt;&lt;code&gt;フォントと色&lt;/code&gt;ページで、&lt;code&gt;VB XML&lt;/code&gt;のフォントと色の設定とフォントの設定を変更します。</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target>コード・サンプルは、ミックスインとして機能する2つのクラスから始まります。 それぞれが特定のアクティビティまたは機能に焦点を当てていることがわかります。 後でこれらを組み合わせて、両方の機能から新しいクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target>コメントプラグマバージョンは、次のように使用できます(TypeScript2.8)。</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target>コンパイラは通常、処理するコンテキストがあるときに&lt;code&gt;this&lt;/code&gt;の型を見つけることができる。 実行しない場合は、&lt;code&gt;@this&lt;/code&gt;で&lt;code&gt;this&lt;/code&gt;のタイプを明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target>コンパイラは、&lt;code&gt;manufacturer&lt;/code&gt;および&lt;code&gt;model&lt;/code&gt;が実際に&lt;code&gt;Car&lt;/code&gt;のプロパティであることを確認します。この例では、新しい型の演算子をいくつか導入しています。 1つ目は、&lt;code&gt;keyof T&lt;/code&gt;、&lt;strong&gt;インデックス型のクエリ演算子&lt;/strong&gt;です。&lt;code&gt;T&lt;/code&gt;型にかかわらず、&lt;code&gt;keyof T&lt;/code&gt;は、&lt;code&gt;T&lt;/code&gt;という既知のパブリック・プロパティ名の集合です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target>コンパイラは、&lt;em&gt;制御フローベースの型分析&lt;/em&gt;を実行することによって、変数が確実に割り当てられているかどうかをチェックします。このトピックの詳細については、後で説明します。</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target>コンパイラは、発行されたJavaScriptで各モジュールが使用されているかどうかを検出します。 モジュール識別子が型注釈の一部としてのみ使用され、式としては決して使用されない場合、そのモジュールに対して&lt;code&gt;require&lt;/code&gt;呼び出しは発行されない。 この未使用の参照の除去は、優れたパフォーマンス最適化であり、これらのモジュールの任意のロードを可能にする。</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target>コンパイラは、このプロパティの割り当てに基づいてコンストラクタ関数を推測しますが、次のように&lt;code&gt;@constructor&lt;/code&gt;タグを追加すると、チェックをより厳密にすることができ、提案をより適切に行うことができます。</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target>コンパイラは入力ファイルに対して前処理パスを実行し、すべてのトリプルスラッシュ参照ディレクティブを解決します。 このプロセス中に、コンパイルにファイルが追加されます。</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target>コンパイラは、ファイル内の参照タグに基づいて、出力ファイルを自動的に並べ替えます。 各ファイルを個別に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target>コンパイラは、&lt;code&gt;for.of&lt;/code&gt;ループに対して、次のような単純な&lt;code&gt;for&lt;/code&gt;ループを生成します。</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target>コンパイラは、'./#{locale}/messages'&lt;/code&gt;からの&lt;code&gt;import messageを、ツーリング目的で'./zh/messages'&lt;/code&gt;からの&lt;code&gt;import messageに解決します。これにより、設計時のサポートを損なうことなく、ロケールに依存しない方法で開発できるようになります。</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target>コンパイラは、適切なパスを持つ&lt;code&gt;.ts&lt;/code&gt;、&lt;code&gt;.tsx&lt;/code&gt;、&lt;code&gt;.d.ts&lt;/code&gt;を検索します。 特定のファイルが見つからなかった場合、コンパイラは&lt;em&gt;アンビエント・モジュール宣言&lt;/em&gt;を探します。 これらは&lt;code&gt;.d.ts&lt;/code&gt;ファイルで宣言する必要があることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target>基本ファイルの設定が最初にロードされ、次に継承する設定ファイルの設定によって上書きされます。</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target>基本ファイルの設定が最初にロードされ、次に継承する設定ファイルの設定によって上書きされます。 循環が発生すると、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target>mixinクラスのコンストラクタ(存在する場合)には、&lt;code&gt;any[]&lt;/code&gt;型のrestパラメータが1つ必要です。また、これらのパラメータを&lt;code&gt;super(.args)&lt;/code&gt;呼び出しの引数として渡すには、spread演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require("...")&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target>このパターンの基本的な考え方は、&lt;code&gt;import id=require("...")&lt;/code&gt;ステートメントによって、モジュールによって公開される型にアクセスできるということです。 モジュール・ローダーは、以下の&lt;code&gt;if&lt;/code&gt;ブロックに示すように、(&lt;code&gt;require&lt;/code&gt;によって)動的に呼び出されます。 これは、参照の最適化を利用して、モジュールが必要なときにのみロードされるようにする。 このパターンが機能するためには、&lt;code&gt;import&lt;/code&gt;で定義されたシンボルが型位置でのみ使用される(つまり、JavaScriptに出力される位置では決して使用されない)ことが重要です。</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target>対応する&lt;code&gt;tsconfig.json&lt;/code&gt;は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target>この例の&lt;code&gt;Animals&lt;/code&gt;の宣言マージは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target>TypeScriptコンパイラのデフォルトの動作は、型エラーがあった場合(例えば、&lt;code&gt;string&lt;/code&gt;を&lt;code&gt;number&lt;/code&gt;に割り当てようとした場合)も.jsファイルを出力することです。 これは、&amp;ldquo;clean&amp;rdquo;ビルドからの出力のみが必要なビルドサーバやその他のシナリオでは望ましくない場合があります。 新しいフラグ&lt;code&gt;noEmitOnError&lt;/code&gt;は、エラーがあった場合にコンパイラが.jsコードを発行するのを防ぐ。</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target>既定のプロパティは、&lt;code&gt;defaultProps&lt;/code&gt;プロパティタイプから推測されます。 &lt;code&gt;static defaultProps:Partial&amp;lt;Props&amp;gt;;&lt;/code&gt;のように明示的な型注釈が追加された場合、コンパイラはデフォルトを持つプロパティを識別できません(&lt;code&gt;defaultProps&lt;/code&gt;の型には&lt;code&gt;Props&lt;/code&gt;のすべてのプロパティが含まれているため)。</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target>確定代入アサーションは、インスタンスプロパティと変数宣言の後に&lt;code&gt;!&lt;/code&gt;を配置して、変数が実際にすべての目的のために割り当てられていることをTypeScriptにリレーできるようにする機能です。これは、TypeScriptの分析では検出できない場合でも同様です。</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target>条件付き型の分布特性は、&lt;em&gt;union型をフィルタする&lt;/em&gt;ために便利に使用できます。</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target>この2つは、&lt;em&gt;インデックス付きアクセス・タイプ&lt;/em&gt;であり、&lt;em&gt;ルックアップ・タイプ&lt;/em&gt;とも呼ばれます。 構文的には、要素アクセスとまったく同じように見えますが、型として記述されます。</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target>&lt;code&gt;readonly&lt;/code&gt;と&lt;code&gt;const&lt;/code&gt;のどちらを使用するかを覚える最も簡単な方法は、変数とプロパティのどちらで使用するかを確認することです。 変数は&lt;code&gt;const&lt;/code&gt;を使用し、プロパティは&lt;code&gt;readonly&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target>インタフェースの動作を確認する最も簡単な方法は、簡単な例から始めることです。</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target>エレメント属性タイプは、JSXで属性をタイプチェックするために使用されます。 オプションおよび必須のプロパティがサポートされています。</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target>要素インスタンス・タイプは、&lt;code&gt;JSX.ElementClass&lt;/code&gt;に割り当て可能でなければならないため、興味深いものです。そうしないとエラーが発生します。 デフォルトでは、&lt;code&gt;JSX.ElementClass&lt;/code&gt;は&lt;code&gt;{}&lt;/code&gt;ですが、JSXの使用を適切なインターフェースに適合する型に限定するように拡張することができます。</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target>省略記号は、restパラメータを持つ関数の型でも使用されます。</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target>enumメンバは、定数enum式で初期化されます。 定数enum式は、コンパイル時に完全に評価できるTypeScript式のサブセットです。 式は、次の場合は定数のenum式です。</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement("div")&lt;/code&gt; instead of &lt;code&gt;React.createElement("div")&lt;/code&gt;.</source>
          <target>&lt;code&gt;jsx:react&lt;/code&gt;コンパイラオプションで使用される正確なファクトリ関数は設定可能です。 ファイル単位で設定するには、&lt;code&gt;jsxFactory&lt;/code&gt;コマンドラインオプション、またはインライン&lt;code&gt;@jsx&lt;/code&gt;コメントプラグマを使用します。 たとえば、&lt;code&gt;jsxFactory&lt;/code&gt;を&lt;code&gt;createElement&lt;/code&gt;に設定すると、&lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt;は、&lt;code&gt;React.createElement("div")&lt;/code&gt;ではなく、&lt;code&gt;createElement("div")&lt;/code&gt;として出力します。</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target>この例では、サブクラスに特化したメソッドでベースクラスのメソッドをオーバーライドする方法も示します。 &lt;code&gt;Snake&lt;/code&gt;と&lt;code&gt;Horse&lt;/code&gt;は、&lt;code&gt;Animal&lt;/code&gt;からの&lt;code&gt;move&lt;/code&gt;を上書きする&lt;code&gt;move&lt;/code&gt;メソッドを作成し、各クラスに固有の機能を提供します。 &lt;code&gt;tom&lt;/code&gt;が&lt;code&gt;Animal&lt;/code&gt;として宣言されていても、その値は&lt;code&gt;Horse&lt;/code&gt;であるため、&lt;code&gt;tom.move(34)&lt;/code&gt;を呼び出すと、&lt;code&gt;Horse&lt;/code&gt;のオーバーライドメソッドが呼び出されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target>この例ではネストされた関数を使用しています。これは、コンパイラがネストされた関数内のNULLを削除できないためです(すぐに呼び出される関数式を除く)。 これは、特に外部関数から返された場合に、ネストされた関数へのすべての呼び出しを追跡できないためです。 関数が呼び出される場所を知らなくても、本体が実行されるときに&lt;code&gt;name&lt;/code&gt;の型が何であるかを知ることはできません。</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target>アクセサー修飾子の式は、次の3つの引数を使用して、実行時に関数として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target>クラス・デコレータの式は、装飾されたクラスのコンストラクタを唯一の引数として、実行時に関数として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target>メソッド・デコレータの式は、次の3つの引数を持つ関数として実行時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target>パラメータデコレータの式は、次の3つの引数を持つ関数として実行時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target>プロパティー修飾子の式は、次の2つの引数を持つ関数として実行時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target>各デコレータの式は、上から下に評価されます。</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target>選択されたファクトリは、グローバルネームスペースに戻る前に(型チェック情報のために)&lt;code&gt;JSX&lt;/code&gt;ネームスペースが検索される場所にも影響します。 ファクトリが&lt;code&gt;React.createElement&lt;/code&gt;(デフォルト)として定義されている場合、コンパイラは&lt;code&gt;React.JSX&lt;/code&gt;をチェックしてから、グローバル&lt;code&gt;JSX&lt;/code&gt;をチェックします。ファクトリが&lt;code&gt;h&lt;/code&gt;として定義されている場合、&lt;code&gt;h.JSX&lt;/code&gt;がグローバル&lt;code&gt;JSX&lt;/code&gt;の前にチェックされます。</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target>最初の割り当てはエラーになります。 &lt;code&gt;T&lt;/code&gt;は、&lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt;パラメータの位置でのみ使用されるため、実質的には&lt;code&gt;T&lt;/code&gt;は&lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt;と対照的である。</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target>最初の割り当てはデフォルトの型チェックモードでは許可されますが、strict関数型モードではエラーとしてフラグが付けられます。 直感的には、デフォルトモードでは&lt;em&gt;おそらく&lt;/em&gt;サウンドであるため割り当てが許可されますが、完全な関数型モードでは&lt;em&gt;証明できる&lt;/em&gt;サウンドではないためエラーになります。 どちらのモードでも、3番目の割り当ては&lt;em&gt;決して&lt;/em&gt;音ではないため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target>1つ目は、enumメンバも型になるということです。 たとえば、特定のメンバがenumメンバの値を持つことができるのは&lt;em&gt;only&lt;/em&gt;と言えます。</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target>最初の行は、ビルドが完了した後にタスク&amp;lsquo;default&amp;rsquo;を実行するようにVisual Studioに指示します。 また、Visual Studioにビルドのクリーンアップを要求すると、&amp;lsquo;clean&amp;rsquo;タスクが実行されます。</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target>属性の型チェックの最初の手順は、&lt;em&gt;要素属性の型&lt;/em&gt;を決定することです。これは、組み込み要素と値ベース要素では少し異なります。</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href="declaration-merging"&gt;declaration merging&lt;/a&gt;.</source>
          <target>上記で最初に気付くのは、&lt;code&gt;SmartObject&lt;/code&gt;クラスの&lt;code&gt;Disposable&lt;/code&gt;および&lt;code&gt;Activateable&lt;/code&gt;を拡張する代わりに、&lt;code&gt;SmartObject&lt;/code&gt;インターフェイスで拡張するということです。 &lt;code&gt;SmartObject&lt;/code&gt;インターフェイスは、&lt;a href="declaration mergeing"&gt;宣言のマージ&lt;/a&gt;のため、&lt;code&gt;SmartObject&lt;/code&gt;クラスに混在します。</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target>最初のタイプのアサーション署名は、ノードの&lt;code&gt;assert&lt;/code&gt;関数の動作をモデル化します。 これにより、チェックされるすべての条件が、包含スコープの残りの部分に対して真でなければならないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target>&lt;code&gt;rootDirs&lt;/code&gt;の柔軟性は、論理的にマージされる物理ソースディレクトリのリストを指定することに限定されない。 提供された配列には、存在するかどうかにかかわらず、任意の数のアドホック・ディレクトリー名を含めることができます。 これにより、コンパイラは、高度なバンドル化およびランタイム機能(条件付きインクルードやプロジェクト固有のローダープラグインなど)を安全な方法で取得できます。</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target>次の例では、共変の位置にある同じ型変数の複数の候補によってユニオン型が推定される方法を示します。</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target>次に、&lt;code&gt;Greeter&lt;/code&gt;クラスに適用されるクラスデコレータ(&lt;code&gt;@sealed&lt;/code&gt;)の例を示します。</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target>次に、&lt;code&gt;Greeter&lt;/code&gt;クラスのメソッドに適用されるメソッドデコレータ(&lt;code&gt;@enumerable&lt;/code&gt;)の例を示します。</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target>次に、&lt;code&gt;Greeter&lt;/code&gt;クラスのメンバのパラメータに適用されるパラメータデコレータ(&lt;code&gt;@required&lt;/code&gt;)の例を示します。</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target>次に、&lt;code&gt;Point&lt;/code&gt;クラスのメンバに適用されるアクセサ修飾子(&lt;code&gt;@configurable&lt;/code&gt;)の例を示します。</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target>グローバル変数&lt;code&gt;foo&lt;/code&gt;には、存在するウィジェットの数が含まれます。</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target>グローバル変数&lt;code&gt;myLib&lt;/code&gt;には、グリーティングを作成する関数&lt;code&gt;makeGreeting&lt;/code&gt;と、これまでに作成されたグリーティングの数を示すプロパティ&lt;code&gt;numberOfGreetings&lt;/code&gt;があります。</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes">
          <source>The guide is broken down into the following sections.</source>
          <target>このガイドは、次のセクションに分かれています。</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target>&lt;code&gt;getDisplayName&lt;/code&gt;と&lt;code&gt;getLength&lt;/code&gt;は簡単に参照できる型を使用しているので、推論プロセスはここではかなり単純です。 しかし、TypeScript3.3以前では、&lt;code&gt;compose&lt;/code&gt;のような一般的な関数は、他の一般的な関数を渡されてもあまりうまく動作しませんでした。</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target>関数の推定戻り型は、関数内でローカルに宣言された型である可能性があります。 関数の呼び出し元がこのようなローカル型を参照することはできませんが、構造的に一致させることはできます。 例:</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target>クラス・コンストラクター・オブジェクトは変更されません。 例:</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874"&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target>&lt;code&gt;never&lt;/code&gt;を返す関数の目的は、決して返さないことです。 例外がスローされたか、エラーが停止したか、プログラムが終了したことを示します。 たとえば、&lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt;の&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874"&gt;&lt;code&gt;process.exit(...)&lt;/code&gt;は、&lt;code&gt;never&lt;/code&gt;を返すように指定されています。</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target>インターフェイス&lt;code&gt;LabeledValue&lt;/code&gt;は、前の例の要件を説明するために使用できる名前です。 これは、&lt;code&gt;string&lt;/code&gt;型の&lt;code&gt;label&lt;/code&gt;という1つのプロパティを持つことを表しています。&lt;code&gt;printLabel&lt;/code&gt;に渡すオブジェクトが、他の言語と同様にこのインターフェイスを実装していることを明示的に指定する必要はありません。 ここでは、形状のみが重要です。 関数に渡すオブジェクトがリストされた要件を満たしている場合、そのオブジェクトは許可されます。</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target>重要な違いは、構文ではなくセマンティクスです。これについては、ここで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target>タプル型の最後の要素は、&lt;code&gt;.X&lt;/code&gt;という形式のrest要素にすることができます。&lt;code&gt;X&lt;/code&gt;は配列型です。 rest要素は、タプル・タイプがオープンエンドであり、配列要素タイプの要素を0個以上追加できることを示します。 たとえば、&lt;code&gt;[number,.string[]]&lt;/code&gt;は、&lt;code&gt;number&lt;/code&gt;要素の後に任意の数の&lt;code&gt;string&lt;/code&gt;要素が続くタプルを意味します。</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target>宣言ファイルのレイアウトは、ライブラリのレイアウトと同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes">
          <source>The library can then be used as an import within modules:</source>
          <target>ライブラリは、モジュール内のインポートとして使用できます。</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target>以下のリストは、JSDoc注釈を使用してJavaScriptファイルに型情報を提供するときに現在サポートされている構文の概要です。</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target>エラーメッセージの表示に使用するロケール(例:en-us)。</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target>このハンドブックの大部分は&lt;code&gt;let&lt;/code&gt;宣言を使用しています。</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target>node_modulesで検索し、JavaScriptファイルをロードするための最大依存性の深さ。 &lt;code&gt;--allowJs&lt;/code&gt;にのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target>意味は通常、ウセイズドキ.orgで与えられたタグの意味と同じか、スーパーセットです。 次のコードでは、違いを説明し、各タグの使用例を示します。</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href="modules"&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target>モジュール名の解決方法は、&lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;のモジュール指定子と同じです。詳細については、&lt;a href="modules"&gt;Modules&lt;/a&gt;を参照してください。 次に、拡張の宣言は、元のファイルと同じファイルで宣言されているかのようにマージされます。</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target>Javascriptのモジュールサポートは、Typescriptのモジュールサポートよりも構文的に寛容です。 代入と宣言のほとんどの組み合わせがサポートされています。</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target>最も基本的なデータ型は、JavaScriptとTypeScriptが&lt;code&gt;boolean&lt;/code&gt;値を呼び出す単純なtrue/false値です。</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target>TypeScript3.7では、JSDocアノテーション付きJavaScriptでライブラリを作成し、TypeScriptユーザーをサポートすることができる。</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target>やる気を起こさせる例は、コールバックを取る関数の一般的なパターンで、(プログラマーにとっては)予測可能であるが(型システムにとっては)未知の数の引数でそれを呼び出す。</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target>モジュール拡張の名前は、&lt;code&gt;import&lt;/code&gt;および&lt;code&gt;export&lt;/code&gt;宣言のモジュール指定子と同じ規則のセットを使用して解決されます。 モジュール拡張の宣言は、同じファイルで宣言された場合と同じ方法で、既存の宣言とマージされます。</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes">
          <source>The name of the member.</source>
          <target>メンバーの名前。</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target>新しい&lt;code&gt;--showConfig&lt;/code&gt;フラグ</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target>新しい&lt;code&gt;--strict&lt;/code&gt;コンパイラオプションは、多くの型チェックオプションの推奨設定を表します。 具体的には、&lt;code&gt;--strict&lt;/code&gt;を指定することは、次のすべてのオプションを指定することに相当します(将来、さらに多くのオプションが指定される可能性もあります)。</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target>新しい&lt;code&gt;amd dependency name&lt;/code&gt;プロパティを使用すると、amd dependencyのオプション名を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target>新しい&lt;code&gt;amd module name&lt;/code&gt;タグを使用すると、コンパイラにオプションのモジュール名を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target>クラスの新しい&lt;code&gt;protected&lt;/code&gt;修飾子は、C++、C#、Javaなどの使い慣れた言語と同じように動作します。 クラスの&lt;code&gt;protected&lt;/code&gt;メンバは、宣言されたクラスのサブクラス内でのみ可視です。</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target>TypeScriptでサポートされるようになった新しいES6キーワード&lt;code&gt;let&lt;/code&gt;は、より直観的な&amp;ldquo;block&amp;rdquo;セマンティクスを持つ変数を宣言します。 &lt;code&gt;let&lt;/code&gt;変数は宣言の後でのみ参照でき、定義された構文ブロックにスコープされます。</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target>新しいファクトリ名は、&lt;code&gt;createElement&lt;/code&gt;および&lt;code&gt;__spread&lt;/code&gt;関数を呼び出すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target>新機能は、厳密なNULLチェックモードと通常の型チェックモードの両方で使用できるように設計されています。 特に、&lt;code&gt;null&lt;/code&gt;型と&lt;code&gt;undefined&lt;/code&gt;型は、通常の型チェックモードではユニオン型から自動的に削除されます(他のすべての型のサブタイプであるため)。また、&lt;code&gt;!&lt;/code&gt;非NULLのアサーション式演算子は許可されますが、通常の型チェックモードでは無効です。 したがって、NULLおよび未定義の対応型を使用するように更新された宣言ファイルは、後方互換性のために通常の型検査モードで使用することができます。</target>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target>また、テセーヴェルでの視聴のパフォーマンスも向上している。 監視ロジックは、変更イベントに対してより迅速に応答するように完全に書き直されました。</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target>新しいモジュール&lt;code&gt;ProgrammerCalculator&lt;/code&gt;は、元の&lt;code&gt;Calculator&lt;/code&gt;モジュールと類似したAPI図形をエクスポートしますが、元のモジュール内のオブジェクトを拡張しません。 ここに私たちのProgrammerCalculatorクラスのテストがあります。</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes">
          <source>The new playground now supports many new options including:</source>
          <target>新しい遊び場は、次のような多くの新しいオプションをサポートしている。</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes">
          <source>The nightlies are available on &lt;a href="https://www.myget.org/gallery/typescript-preview"&gt;www.myget.org&lt;/a&gt;.</source>
          <target>ナイトリーは&lt;a href="https://www.myget.org/gallery/typescript-preview"&gt;www.myget.org&lt;/a&gt;で入手できます。</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target>現在、nightlyビルドには完全なプラグインのセットアップは含まれていませんが、夜間にインストーラを公開する作業も行っています。</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target>ディレクトリを指定しても、以前の動作は同じままです。コンパイラは、&lt;code&gt;tsconfig.json&lt;/code&gt;という名前のディレクトリでファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target>展開操作を指定する順序によって、結果のオブジェクトになるプロパティが決まります。後で作成されるプロパティは、以前に作成されたプロパティに対して&amp;ldquo;を展開します。</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target>関数のパラメータリスト内のパラメータの序数インデックス。</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href="advanced-types#union-types"&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target>もう1つの変更点は、enum型自体が各enumメンバの&lt;em&gt;union&lt;/em&gt;になることです。 &lt;a href="advanced types#union types"&gt;union types&lt;/a&gt;についてはまだ説明していませんが、型システムがenum自体に存在する値の正確なセットを知っているという事実を活用できることを知っておく必要があります。 そのため、TypeScriptは、値を誤って比較している可能性のあるばかげたバグを見つけることができます。 例:</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target>TypeScriptでサポートされる他の新しいES6宣言タイプは&lt;code&gt;const&lt;/code&gt;である。 &lt;code&gt;const&lt;/code&gt;変数はに割り当てることができず、宣言された場所で初期化する必要があります。 これは、初期化後に値を変更しない宣言に便利です。</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target>もう1つのタイプのアサーション署名は、条件をチェックするのではなく、特定の変数またはプロパティが異なる型を持つことをTypeScriptに伝えます。</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target>一般的なライブラリD3は、その機能を&lt;code&gt;D3&lt;/code&gt;というグローバルオブジェクトで定義します。このライブラリは、モジュールローダーの代わりに&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグを使用してロードされるため、宣言では名前空間を使用して形状を定義します。 TypeScriptコンパイラでこのシェイプを表示するには、アンビエント名前空間宣言を使用します。 たとえば、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target>上記の2つの型は、Typescript型&lt;code&gt;{[x:string]:number}&lt;/code&gt;および&lt;code&gt;{[x:number]:any}&lt;/code&gt;に相当します。コンパイラは両方の構文を認識します。</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target>ディレクトリに&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルがあることは、そのディレクトリがTypeScriptプロジェクトのルートであることを示します。 &lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは、プロジェクトのコンパイルに必要なルートファイルとコンパイラオプションを指定します。 プロジェクトは次のいずれかの方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target>&lt;code&gt;padLeft&lt;/code&gt;の問題は、&lt;code&gt;padding&lt;/code&gt;パラメータが&lt;code&gt;any&lt;/code&gt;として型指定されていることです。つまり、&lt;code&gt;number&lt;/code&gt;でも&lt;code&gt;string&lt;/code&gt;でもない引数で呼び出すことができますが、TypeScriptでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target>これらのパッケージ名を解決するプロセスは、&lt;code&gt;import&lt;/code&gt;ステートメントでモジュール名を解決するプロセスと似ています。 トリプル・スラッシュ参照型ディレクティブは、宣言パッケージの&lt;code&gt;import&lt;/code&gt;と考えるのが簡単です。</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;"files"&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target>プロセスは一連の&lt;em&gt;ルート・ファイル&lt;/em&gt;で始まります。これらは、コマンド・ラインまたは&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの&lt;code&gt;"files"&lt;/code&gt;リストで指定されたファイル名です。 これらのルートファイルは、指定された順序で前処理されます。 ファイルがリストに追加される前に、ファイル内のすべてのトリプルスラッシュ参照が処理され、そのターゲットが含まれます。 3つのスラッシュ参照は、ファイル内での表示順に、深さ優先で解決されます。</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target>プログラムによって&amp;ldquo;Hello from TypeScript!&amp;rdquo;が印刷されます。</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target>このガイドの目的は、高品質の定義ファイルを作成する方法を説明することです。 このガイドは、いくつかのAPIのドキュメントとそのAPIの使用例を示し、対応する宣言の記述方法を説明することで構成されています。</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target>参照タグを使用すると、環境モジュールの宣言を含む宣言ファイルを見つけることができます。 これは、いくつかのTypeScriptサンプルが使用する&lt;code&gt;node.d.ts&lt;/code&gt;ファイルが使用される方法です。</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target>このセクションの残りの部分では、&lt;code&gt;typescript@next&lt;/code&gt;がすでにインストールされているものとします。</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target>その結果、ファイル&lt;code&gt;greeter.js&lt;/code&gt;が作成されます。このファイルには、入力したものと同じJavaScriptが含まれています。 JavaScriptアプリケーションでTypeScriptを使用して再起動します。</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target>&lt;code&gt;Document&lt;/code&gt;のマージされた宣言は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes">
          <source>The resulting type of the property.</source>
          <target>プロパティの結果のタイプ。</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target>その結果は、下から上へ関数として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes">
          <source>The return value of the parameter decorator is ignored.</source>
          <target>パラメーター修飾子の戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target>&lt;code&gt;instanceof&lt;/code&gt;の右側はコンストラクタ関数である必要があり、TypeScriptは以下のように絞り込まれる。</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes">
          <source>The same &lt;a href="#the-impact-of-es6-on-module-plugins"&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target>同じ&lt;a href="#the impact of es6on module plugins"&gt;footnote&lt;/a&gt;がこれらのモジュールに適用されます。</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes">
          <source>The same goes for &lt;a href="https://github.com/TypeStrong/ts-loader"&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader"&gt;here&lt;/a&gt;.</source>
          <target>&lt;a href="https://github.com/TypeStrong/ts-loader"&gt;ts loader&lt;/a&gt;(Webpack用の別のTypeScriptローダー)についても同様です。 この2つの違いの詳細については、&lt;a href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader"&gt;ここ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes">
          <source>The same is true for optional properties:</source>
          <target>オプションのプロパティについても同様です。</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target>関数呼び出しの引数をチェックするときにも、同じ割り当て規則が使用されます。</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target>空の配列に対しても同様のトラッキングが行われるようになりました。</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target>通常のタプルが&lt;code&gt;Array&lt;/code&gt;-a tuple with elements of type&lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;,&lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;,&amp;ヘリプ;&lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt;&lt;code&gt;extends from&lt;code&gt;Array&amp;lt;T&lt;sub&gt;1&lt;/sub&gt;\T&lt;sub&gt;2&lt;/sub&gt;\.T&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;-&lt;readonly&gt;code&gt;タプルは、&lt;sub/sub&gt;ReadonlyArray&gt;から拡張されたコードである。1 2 1 2ReadonlyArrayヘリプ。</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target>2番目の代入はエラーです。&lt;code&gt;y&lt;/code&gt;には、&lt;code&gt;x&lt;/code&gt;にはない必須の2番目のパラメータがあるため、代入は許可されません。</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes">
          <source>The second block creates the following name meanings:</source>
          <target>2番目のブロックは、次の名前の意味を作成します。</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target>2番目の方法では、コンパイラが網羅性をチェックするために使用する&lt;code&gt;never&lt;/code&gt;型を使用します。</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target>2番目の演算子は&lt;code&gt;T[K]&lt;/code&gt;で、&lt;strong&gt;インデックス付きアクセス演算子&lt;/strong&gt;です。ここで、型構文は式構文を反映しています。 これは、&lt;code&gt;person['name']&lt;/code&gt;のタイプが&lt;code&gt;Person['name']&lt;/code&gt;&amp;mdash;この例では&lt;code&gt;string&lt;/code&gt;だけであることを意味します。ただし、インデックス型クエリと同様に、&lt;code&gt;T[K]&lt;/code&gt;を汎用的なコンテキストで使用することができます。このコンテキストでは、&lt;code&gt;T[K]&lt;/code&gt;の真の威力が発揮されます。 型変数&lt;code&gt;Kがkeyof T&lt;/code&gt;を拡張していることを確認するだけです。ここでは、&lt;code&gt;getProperty&lt;/code&gt;という関数を使用した別の例を示します。</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target>2番目の部分は戻り型です。 パラメータとリターンタイプの間に太い矢印(&lt;code&gt;=&amp;gt;&lt;/code&gt;)を使用して、どちらがリターンタイプであるかを明確にします。 前述したように、これは関数型の必須部分なので、関数が値を返さない場合は、関数をオフにする代わりに&lt;code&gt;void&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target>2番目の理由は、コンシューマがTypeScriptの&amp;ldquo;strict null checking&amp;rdquo;機能を使用する場合です。 JavaScriptでは、指定されていないパラメータは&lt;code&gt;undefined&lt;/code&gt;として表示されるため、通常、オプションの引数を使用して明示的な&lt;code&gt;undefined&lt;/code&gt;を関数に渡すことは問題ありません。 たとえば、次のコードは、厳密なNULLの場合はOKです。</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target>2番目の方法もおそらく最も一般的です。 ここでは、&lt;em&gt;型引数の推論&lt;/em&gt;&amp;ndash;つまり、渡された引数の型に基づいて、コンパイラが自動的に&lt;code&gt;T&lt;/code&gt;の値を設定するようにします。</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target>2番目の方法では、汎用の配列タイプ&lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target>構造化解除の最も単純な形式は、配列の割り当ての構造化解除です。</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target>最も単純で、おそらく最も一般的なタイプの宣言マージは、インターフェース・マージです。 最も基本的なレベルでは、マージは両方の宣言のメンバーを同じ名前の単一のインターフェースに機械的に結合します。</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target>上記のスニペットは型推論の一例であり、ハンドブックの後半で説明します。</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes">
          <source>The spread operator also works:</source>
          <target>スプレッド演算子は次のようにも機能します。</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target>分散演算子は、非構造化の逆です。 配列を別の配列に、またはオブジェクトを別のオブジェクトに展開できます。 例:</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes">
          <source>The strategy the compiler is following</source>
          <target>コンパイラが従う方針</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target>より厳密なチェックは、メソッド宣言またはコンストラクタ宣言で生成された&lt;em&gt;以外の&lt;/em&gt;すべての関数タイプに適用されます。 メソッドは、一般的なクラスとインタフェース(&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;など)のほとんどが共変に関連することを保証するために、特に除外されます。</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target>文字列リテラルユニオン&lt;code&gt;Keys&lt;/code&gt;。繰り返し処理するプロパティの名前を含みます。</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes">
          <source>The supported glob wildcards are:</source>
          <target>globワイルドカードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target>この構文は、&lt;code&gt;for.in&lt;/code&gt;が内部にあるインデックス署名の構文に似ています。 次の3つの部分があります。</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target>以前にC#またはJavaを使用したことがある場合は、この構文はおなじみのはずです。 新しいクラス&lt;code&gt;Greeter&lt;/code&gt;を宣言します。このクラスには、&lt;code&gt;greeting&lt;/code&gt;というプロパティ、コンストラクタ、およびメソッド&lt;code&gt;greet&lt;/code&gt;の3つのメンバがあります。</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes">
          <source>The template file &lt;a href="templates/global-d-ts"&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href="#preventing-name-conflicts"&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target>テンプレートファイル&lt;a href="templates/global d ts"&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt;は、サンプルライブラリ&lt;code&gt;myLib&lt;/code&gt;を定義します。&lt;a href="#preventing name conflicts"&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo;脚注&lt;/a&gt;を必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes">
          <source>The test files import the implementation files and do some testing:</source>
          <target>テストファイルは実装ファイルをインポートし、いくつかのテストを行います。</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target>3つのインタフェースがマージされ、次のように1つの宣言が作成されます。</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target>最上位のモジュールである&lt;code&gt;Shapes&lt;/code&gt;は、&lt;code&gt;Triangle&lt;/code&gt;と&lt;code&gt;Square&lt;/code&gt;を理由なくラップします。 これはモジュールの利用者にとって混乱して迷惑です。</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes">
          <source>The two biggest changes are the following:</source>
          <target>2つの大きな変更点は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target>この2つのオプションでは、さらに多くのものが必要でした。 また、ヘルパーを含まないため、お客様は独自のヘルパーライブラリをメンテナンスする必要がありました。</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target>2つのサンプルは同等です。 どちらか一方を使用するのが優先度の選択ですが、JSXでTypeScriptを使用する場合は、&lt;/code&gt;形式のアサーションとして&lt;code&gt;のみが許可されます。</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target>上記のタイプは、&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;U&lt;/code&gt;に割り当てられる場合、タイプが&lt;code&gt;X&lt;/code&gt;であることを意味します。それ以外の場合、タイプは&lt;code&gt;Y&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target>型チェッカーは、&lt;code&gt;printLabel&lt;/code&gt;の呼び出しをチェックします。&lt;code&gt;printLabel&lt;/code&gt;関数には、渡されたオブジェクトが&lt;code&gt;string&lt;/code&gt;型の&lt;code&gt;label&lt;/code&gt;というプロパティを持つことを必要とする単一のパラメータがあります。実際には、このオブジェクトにはこれよりも多くのプロパティがありますが、コンパイラは、必要な&lt;em&gt;が少なくとも&lt;/em&gt;存在し、必要な型と一致することのみをチェックします。 TypeScriptが寛容でない場合もありますが、これについては少し説明します。</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target>型チェッカーは以前、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;を任意のものに割り当てることができると考えていました。 事実上、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;は&lt;em&gt;すべての&lt;/em&gt;タイプの有効な値であり、それらを明示的に除外することはできません(したがって、それらの誤った使用を検出することはできません)。</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target>型注釈のない&lt;code&gt;const&lt;/code&gt;変数または&lt;code&gt;readonly&lt;/code&gt;プロパティに対して推論される型は、リテラル初期化子の型です。 &lt;code&gt;let&lt;/code&gt;変数、&lt;code&gt;var&lt;/code&gt;変数、パラメータ、または型注釈のない&lt;code&gt;readonly&lt;/code&gt;プロパティに対して推論される型は、初期化子の拡張リテラル型です。 ここで、文字列リテラル型の拡張型は、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;(数値リテラル型)、&lt;code&gt;boolean&lt;/code&gt;(&lt;code&gt;true&lt;/code&gt;または&lt;code&gt;false&lt;/code&gt;)、およびenumリテラル型の包含enumです。</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target>提供されるタイプ情報は、アプリケーション・スケールでJavaScriptを操作するためのツールとともに機能します。 TypeScriptでできることの例については、Webサイトの「サンプル」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target>&lt;code&gt;import.meta&lt;/code&gt;の型は、&lt;code&gt;lib.es5.d.ts&lt;/code&gt;で定義されているグローバルな&lt;code&gt;ImportMeta&lt;/code&gt;型です。このインタフェースは非常に限定されています。 ノードまたはブラウザによく知られたプロパティを追加するには、インターフェイスのマージと、状況に応じたグローバルな拡張が必要です。</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target>&lt;code&gt;for.in&lt;/code&gt;ステートメントで宣言された変数の型は、暗黙的に&lt;code&gt;string&lt;/code&gt;である。</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target>ジェネリック関数の型は、関数宣言と同様に、型パラメータが最初に表示されます。</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target>rest要素を持つタプル型の&lt;code&gt;length&lt;/code&gt;プロパティの型は&lt;code&gt;number&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target>&lt;code&gt;x&lt;/code&gt;変数の型は、&lt;code&gt;number&lt;/code&gt;であると推測されます。この種の推測は、変数とメンバーの初期化、パラメータのデフォルト値の設定、および関数の戻り値の型の決定の際に行われます。</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target>&lt;code&gt;extends&lt;/code&gt;式の型パラメータ型は、mixinコンストラクタ型に制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target>型システムは、ソース関数の戻り型がターゲット型の戻り型のサブタイプであることを強制します。</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target>タイプ変数&lt;code&gt;K&lt;/code&gt;。各プロパティに順番にバインドされます。</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target>JSX要素に渡される属性のタイプは、別に検索する必要があります。 組み込みの要素属性は&lt;em&gt;本質的に&lt;/em&gt;認識されている必要がありますが、コンポーネントは独自の属性セットを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target>プロジェクトファイルの&lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt;プロパティの値は、ビルドに使用するコンパイラのバージョンを示します(この例では1.7)。 これにより、異なるマシン上の同じバージョンのコンパイラに対してプロジェクトを構築できます。</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target>&lt;code&gt;extends&lt;/code&gt;の値は、継承元の別の構成ファイルへのパスを含む文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target>変数は、TypeScriptで問題があることを示すために、必ずしも両方の変数をブロックスコープにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target>マージされたメンバーの可視性規則は、&amp;lsquo;Mergeing Namespaces&amp;rsquo;セクションで説明されているものと同じなので、マージされたクラスの&lt;code&gt;AlbumLabel&lt;/code&gt;クラスをエクスポートして表示する必要があります。 その結果、クラスは別のクラスの内部で管理されます。 名前空間を使用して、既存のクラスに静的メンバーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="a151878e667d147c786ea5d4fee9f01a5d29212a" translate="yes">
          <source>The watching of directory on platforms that don&amp;acirc;&amp;euro;&amp;trade;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target>&amp;acirc;&amp;euro;&amp;trade;tがノードでネイティブに再帰的なディレクトリ監視をサポートしないプラットフォームでのディレクトリ監視は、&lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;で選択された異なるオプションを使用して、子ディレクトリのディレクトリ監視プログラムを再帰的に作成することによってサポートされます。ネイティブの再帰的なディレクトリ監視をサポートするプラットフォーム(たとえば、ウィンドウ)では、この環境変数の値は無視されます。</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href="https://github.com/npm/node-semver#ranges"&gt;semver ranges&lt;/a&gt;.</source>
          <target>TypeScriptがコンパイラ&amp;amp;言語のバージョンが一致するかどうかを判断する方法は、ノードの&lt;a href="https://github.com/npm/node-semver#ranges"&gt;semver範囲&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target>これが機能するのは、&lt;code&gt;allowJs&lt;/code&gt;を使用する場合、TypeScriptには一般的なJavaScriptパターンを理解するためのベストエフォート分析があるということですが、一部のパターンがJavaScriptで表現される方法は、必ずしもTypeScriptの等価なパターンのようには見えません。 &lt;code&gt;declaration&lt;/code&gt;emitがオンになっていると、TypeScriptはJSDocコメントとCommonJSエクスポートを有効な型宣言などに変換する最良の方法を&lt;code&gt;.d.ts&lt;/code&gt;ファイルで見つける。</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes">
          <source>Then consumed it:</source>
          <target>次のように使用します。</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href="https://www.npmjs.com/package/gulp-typescript"&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target>次に、&lt;code&gt;typescript&lt;/code&gt;、&lt;code&gt;gulp&lt;/code&gt;、および&lt;code&gt;gulp typescript&lt;/code&gt;をプロジェクトのdev依存関係にインストールします。 &lt;a href="https://www.npmjs.com/package/gulp-typescript"&gt;Gulp typescript&lt;/a&gt;は、Typescript用のgulpプラグインです。</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: "rich"&lt;/code&gt;, which is not what we want in this case.</source>
          <target>次に、&lt;code&gt;defaults&lt;/code&gt;の&lt;code&gt;food&lt;/code&gt;プロパティによって&lt;code&gt;food:"rich"&lt;/code&gt;が上書きされます。これは、この場合の目的とは異なります。</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target>次に、&lt;code&gt;T'&lt;/code&gt;型変数がすべて&lt;code&gt;infer&lt;/code&gt;型変数に置き換えられる&lt;code&gt;T'&lt;/code&gt;型のインスタンスである&lt;code&gt;T'&lt;/code&gt;が与えられた場合、&lt;code&gt;T'&lt;/code&gt;が&lt;code&gt;U&lt;/code&gt;に&lt;em&gt;確実に割り当てられる&lt;/em&gt;ならば、条件型は&lt;code&gt;X&lt;/code&gt;に解決される。型変数制約が考慮されないことを除いて、明確に割り当てられる関係は通常の割り当て可能な関係と同じである。 直感的に、ある型が別の型に確実に割り当てられる場合、&lt;em&gt;それらの型のすべてのインスタンス化&lt;/em&gt;に割り当てられることがわかっています。</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target>次に、主イニシャライザではなく、非構造化プロパティのオプションプロパティのデフォルトを指定する必要があります。 &lt;code&gt;C&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;オプションで定義されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target>&lt;code&gt;tsc-b&lt;/code&gt;に固有のフラグもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target>ここには基本的に3つの変更がありますが、コードを少しリファクタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target>TypeScriptが特定の型を理解できない場合がある。 できるだけ寛大にするために、その代わりに&lt;code&gt;any&lt;/code&gt;型を使用することにします。 これはマイグレーションには最適ですが、&lt;code&gt;any&lt;/code&gt;を使用することは、型の安全性が得られないことを意味します。 &lt;code&gt;noImplicitAny&lt;/code&gt;オプションを使用すると、これらの場所にフラグを付けてエラーを発生させるようにTypeScriptに指示できます。</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target>プロパティを間接的に(おそらくヘルパーメソッドや依存性注入ライブラリによって)初期化できる場合があります。その場合、プロパティに対して新しい&lt;em&gt;definitive assignment assertion modifiers&lt;/em&gt;を使用できます(後述)。</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target>ライブラリには、いくつかの種類の依存関係があります。 ここでは、宣言ファイルにインポートする方法について説明します。</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes">
          <source>There are three templates available for modules, &lt;a href="templates/module-d-ts"&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href="templates/module-class-d-ts"&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href="templates/module-function-d-ts"&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target>モジュールには、&lt;a href="templates/module d ts"&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;、&lt;a href="templates/module class d ts"&gt;&lt;code&gt;module class.d.ts&lt;/code&gt;&lt;/a&gt;、&lt;a href="templates/module function d ts"&gt;&lt;code&gt;module function.d.ts&lt;/code&gt;&lt;/a&gt;の3つのテンプレートがあります。</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target>TypeScriptツールを取得するには、主に次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes">
          <source>There are two packages:</source>
          <target>2つのパッケージがあります。</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes">
          <source>There are two possible module resolution strategies: &lt;a href="#node"&gt;Node&lt;/a&gt; and &lt;a href="#classic"&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href="#classic"&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href="#node"&gt;Node&lt;/a&gt; otherwise.</source>
          <target>モジュールの解決方法には、&lt;a href="#node"&gt;ノード&lt;/a&gt;と&lt;a href="#classic"&gt;クラシック&lt;/a&gt;の2種類があります。&lt;code&gt;--moduleResolution&lt;/code&gt;フラグを使用すると、モジュールの解決方法を指定できます。 指定しない場合、デフォルトは&lt;a href="#classic"&gt;Classic&lt;/a&gt;for&lt;code&gt;--module AMD System ES2015&lt;/code&gt;または&lt;a href="#node"&gt;Node&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;"100"&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target>サポートされているインデックスシグネチャには、stringとnumberの2つのタイプがあります。 どちらのタイプのインデクサもサポートできますが、数値インデクサから返されるタイプは、文字列インデクサから返されるタイプのサブタイプである必要があります。 これは、&lt;code&gt;number&lt;/code&gt;を使用してインデックスを作成する場合、JavaScriptは実際にオブジェクトにインデックスを作成する前にそれを&lt;code&gt;string&lt;/code&gt;に変換するからです。 つまり、&lt;code&gt;100&lt;/code&gt;(&lt;code&gt;number&lt;/code&gt;)でインデックスを作成することは、&lt;code&gt;"100"&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;)でインデックスを作成することと同じであるため、2つのインデックスには一貫性が必要です。</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes">
          <source>There are two ways to define a value-based element:</source>
          <target>値ベースの要素を定義するには、次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target>これには2つの方法があります。 1つ目は、&lt;code&gt;--strictNullChecks&lt;/code&gt;をオンにし、戻り値の型を指定することです。</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target>&amp;rsquo;t calculated:literal enum membersという、定数enumメンバの特別なサブセットがあります。 リテラルenumメンバは、初期化された値がないか、またはに初期化された値を持つ定数enumメンバです。</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target>クラス内のさまざまな宣言に適用されるデコレータの適用方法には、明確に定義された順序があります。</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;のテンプレートは、ほとんどのプロジェクトタイプにはありません。</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target>予期しないことが発生した場合に&lt;code&gt;エラーをスローする&lt;/code&gt;特定の関数セットがあります。 &amp;rsquo;は&amp;ldquo;assertion&amp;rdquo;関数と呼ばれます。 例えば、Node.jsには&lt;code&gt;assert&lt;/code&gt;という専用の関数があります。</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target>また、&amp;rsquo;s&lt;em&gt;オプションの呼び出し&lt;/em&gt;を使用すると、式が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;でない場合に、条件付きで式を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target>最新のチェックが組み込まれていないため、常に&lt;code&gt;tsc&lt;/code&gt;を2回実行することになる</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target>これらの&lt;code&gt;.ツバイルドインフォ&lt;/code&gt;ファイルは安全に削除でき、実行時にコードに影響を与えることはありません。これらのファイルは、コンパイルを高速化するためにのみ使用されます。 また、任意の名前を付けて、&lt;code&gt;--tsBuildInfoFile&lt;/code&gt;フラグを使用して任意の場所に配置することもできます。</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === "typename"&lt;/code&gt; and &lt;code&gt;typeof v !== "typename"&lt;/code&gt;, where &lt;code&gt;"typename"&lt;/code&gt; must be &lt;code&gt;"number"&lt;/code&gt;, &lt;code&gt;"string"&lt;/code&gt;, &lt;code&gt;"boolean"&lt;/code&gt;, or &lt;code&gt;"symbol"&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target>これらの&lt;em&gt;&lt;code&gt;typeof&lt;/code&gt;type guards&lt;/em&gt;は、&lt;code&gt;typeof v==="typename"&lt;/code&gt;と&lt;code&gt;typeof v!="typename"&lt;/code&gt;の2つの形式で認識されます。&lt;code&gt;"typename"&lt;/code&gt;は、&lt;code&gt;"number"&lt;/code&gt;、&lt;code&gt;"string"&lt;/code&gt;、&lt;code&gt;"boolean"&lt;/code&gt;、または&lt;code&gt;"symbol"&lt;/code&gt;である必要があります。TypeScriptでは、他の文字列と比較する必要はありませんが、言語ではガード式として認識されます。</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target>これらは明示的に書かれることはめったにありませんが、問題を絞り込むときに役立ち、バグを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target>これらのアサーション・シグニチャーは、型述部シグニチャーの作成に非常に似ています。</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes">
          <source>These could be imported as</source>
          <target>次のようにインポートできます。</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target>これらの例は、複雑さがほぼ増大する順に並べられている。</target>
        </trans-unit>
        <trans-unit id="3ee462960f4b0d3257bbbd6141bad74f198c5cad" translate="yes">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;acirc;&amp;euro;&amp;oelig;oh, don&amp;acirc;&amp;euro;&amp;trade;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;acirc;&amp;euro;�.</source>
          <target>これらのオプションは、遊び場のサンプルへのリンクを共有する場合にも維持され、ユーザが受信者に&amp;acirc;&amp;euro;&amp;オエリゴ;oh,don&amp;acirc;&amp;euro;&amp;trade;&lt;code&gt;noImplicitAny&lt;/code&gt;オプションをオンにするのを忘れずに、より確実にサンプルを共有できるようになります。</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target>これらのスコーピング規則は、いくつかの種類の間違いを引き起こす可能性がある。 彼らが悪化させている問題の一つは、同じ変数を何度も宣言するのは誤りではないという事実である。</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target>これらは、&lt;code&gt;--out&lt;/code&gt;または&lt;code&gt;--outFile&lt;/code&gt;を使用するときに出力を順序付けるメソッドとしても機能します。ファイルは、前処理パスの後、入力と同じ順序で出力ファイルの場所に出力されます。</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target>また、&lt;code&gt;exports&lt;/code&gt;オブジェクトをカスタムの単一オブジェクトに置き換えることもできます。 デフォルトのエクスポートは、この動作の代替として機能するようになっていますが、この2つのエクスポートには互換性がありません。 TypeScriptは、従来のCommonJSとAMDのワークフローをモデル化する&lt;code&gt;export=&lt;/code&gt;をサポートしている。</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target>これらは&lt;code&gt;let&lt;/code&gt;宣言に似ていますが、名前が示すように、バインドされると値を変更できません。 つまり、&lt;code&gt;let&lt;/code&gt;と同じスコープルールがありますが、再割り当てはできません。</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes">
          <source>They will rarely have:</source>
          <target>次のようなことはめったにありません。</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes">
          <source>Things to look out for</source>
          <target>注意事項</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ "*": ["ts3.1/*"] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target>この&lt;code&gt;package.json&lt;/code&gt;は、現在のバージョンのTypeScriptが実行されているかどうかをチェックするようTypeScriptに指示します。 &amp;rsquo;s3.1以降の場合は、パッケージに対してインポートしたパスを計算し、パッケージの&lt;code&gt;ts3.2&lt;/code&gt;フォルダから読み込みます。1。 この&amp;rsquo;s&lt;code&gt;{"*":["ts3.2/*"]}&lt;/code&gt;の意味するところ-現在のパスマッピングに精通している場合は、まったく同じように動作します。1。</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target>この&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルには、&lt;code&gt;./node_modules/@types/node&lt;/code&gt;、&lt;code&gt;./node_modules/@types/lodash&lt;/code&gt;および&lt;code&gt;./node_modules/@types/express&lt;/code&gt;が&lt;em&gt;のみ&lt;/em&gt;含まれます。&lt;code&gt;node_modules/@types/*&lt;/code&gt;の下の他のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target>これにより、&lt;code&gt;copy html&lt;/code&gt;タスクが追加され、&lt;code&gt;default&lt;/code&gt;の依存関係として追加されます。つまり、&lt;code&gt;default&lt;/code&gt;が実行されるたびに、&lt;code&gt;copy html&lt;/code&gt;が最初に実行される必要があります。 また、&lt;code&gt;default&lt;/code&gt;を、gump typescriptではなく、ツーフィプラグインを使用してBrowserifyを呼び出すように変更しました。 便利なことに、どちらも同じオプション・オブジェクトをTypeScriptコンパイラーに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes">
          <source>This also applies to numeric and string literals.</source>
          <target>これは数値リテラルと文字列リテラルにも適用されます。</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target>これはJSDocコメントでも動作し、&lt;code&gt;.js&lt;/code&gt;の他のモジュールの型を参照する。</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes">
          <source>This also works with classes:</source>
          <target>これは、クラスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target>これは、変数&lt;code&gt;bar&lt;/code&gt;が型&lt;code&gt;foo&lt;/code&gt;を持つことを表明します。TypeScriptは型表明に山括弧も使用するので、それをJSXの構文と組み合わせると、ある種の構文解析の困難を招くことになります。 その結果、TypeScriptは&lt;code&gt;.tsx&lt;/code&gt;ファイルでの不等号括弧型のアサーションを禁止します。</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes">
          <source>This can be used to pipe output between commands as well.</source>
          <target>これは、コマンド間で出力をパイプするためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target>これは、継承を使用する既存のコードにかなりの悪影響を与える可能性があります。 まず、ベースクラスの&lt;code&gt;set&lt;/code&gt;accessorはトリガされず、完全に上書きされます。</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target>TypeScriptの&lt;code&gt;enum&lt;/code&gt;構文を使用しない場合は、これを使用して、プレーンなJavaScriptコードで&lt;code&gt;enum&lt;/code&gt;のようなパターンを有効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target>これは、&lt;code&gt;@param&lt;/code&gt;タグを持つ基本的な関数を超えることができます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work"&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target>この変更により、&lt;code&gt;Error&lt;/code&gt;、&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;などの組み込みクラスを拡張する動作が中断されます。 詳細については、&lt;a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work"&gt;拡張ビルトインBreaking Change文書&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target>このチェックは画期的な変更ですが、そのためチェックは非常に保守的です。 このエラーは&lt;code&gt;if&lt;/code&gt;条件でのみ発生し、オプションのプロパティ、&lt;code&gt;strictNullChecks&lt;/code&gt;がオフの場合、または関数が後で&lt;code&gt;if&lt;/code&gt;の本体内で呼び出された場合には発生しません。</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target>この比較プロセスは再帰的に進み、各メンバーとサブメンバーのタイプを調べます。</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target>この構成ファイルには、&lt;code&gt;./typings&lt;/code&gt;の下の&lt;em&gt;すべての&lt;/em&gt;パッケージが含まれ、&lt;code&gt;./node_modules/@types&lt;/code&gt;のパッケージは含まれません。</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target>これにより、デフォルト値の&lt;code&gt;package.json&lt;/code&gt;ファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target>これにより、&lt;code&gt;o.a&lt;/code&gt;および&lt;code&gt;o.b&lt;/code&gt;から新しい変数&lt;code&gt;a&lt;/code&gt;および&lt;code&gt;b&lt;/code&gt;が作成されます。&lt;code&gt;c&lt;/code&gt;が必要でない場合は、スキップできます。</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target>これにより、&lt;code&gt;first&lt;/code&gt;および&lt;code&gt;2nd&lt;/code&gt;という名前の2つの新しい変数が作成されます。これはインデックスを使用する場合と同じですが、より便利です。</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target>このディレクティブを使用すると、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target>このディレクティブは、デフォルト・ライブラリ(&lt;code&gt;lib.d.ts&lt;/code&gt;)をコンパイルに含めないようにコンパイラに指示します。 ここでの影響は、コマンドラインで&lt;code&gt;--noLib&lt;/code&gt;を渡すのと似ています。</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target>このディレクティブは、ファイルを&lt;em&gt;デフォルトライブラリ&lt;/em&gt;としてマークします。このコメントは、&lt;code&gt;lib.d.ts&lt;/code&gt;およびその異なるバリアントの上部に表示されます。</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target>&lt;code&gt;A.B&lt;/code&gt;は、タイプまたは値である必要はありません。</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target>この例では、これまでに説明していないその他の機能について説明します。 ここでも、&lt;code&gt;extends&lt;/code&gt;キーワードを使用して、&lt;code&gt;Animal&lt;/code&gt;の2つの新しいサブクラス&lt;code&gt;Horse&lt;/code&gt;と&lt;code&gt;Snake&lt;/code&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target>この例は、最も基本的な継承機能を示しています。クラスは、基本クラスからプロパティとメソッドを継承します。 ここで、&lt;code&gt;Dog&lt;/code&gt;は、&lt;code&gt;extends&lt;/code&gt;キーワードを使用して&lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt;クラスから派生する&lt;em&gt;派生クラスです。 派生クラスは&lt;em&gt;サブクラス&lt;/em&gt;と呼ばれることが多く、基本クラスは&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれることが多い。</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target>この機能は、大規模な組織や、多数の依存関係が分散されたプロジェクトに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href="https://github.com/TypeStrong/atom-typescript#compile-on-save"&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target>この機能は現在、TypeScript1.8.4以降と&lt;a href="https://github.com/TypeStrong/atom-typescript#compile-on-save"&gt;atom typescript&lt;/a&gt;プラグインを含むVisual Studio2015でサポートされている。</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target>この特徴は、コンパイラに不変性を暗示するためだけに使用されるタイプがしばしば省略されることを意味する。</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target>この機能はTypeScript2.1より前にサポートされていましたが、ES6/ES2015をターゲットにしている場合にのみサポートされます。 TypeScript2.1はES3とES5の実行時間に機能を提供するので、どんな環境を使っていても自由に利用できる。</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target>これにより、bothPlusに値&lt;code&gt;[0 1 2 3 4 5]&lt;/code&gt;が与えられます。分散によって、&lt;code&gt;first&lt;/code&gt;と&lt;code&gt;2nd&lt;/code&gt;のコピーが浅く作成されます。これらは分散によって変更されません。</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes">
          <source>This gives the user a way of describing inner classes.</source>
          <target>これにより、ユーザーは内部クラスを記述することができます。</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target>このガイダンスは、宣言ファイルのユーザを破ることなく、ライブラリをUMDに移行できることも保証する。</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target>このガイドは、高品質なTypeScript宣言ファイルを作成する方法を学ぶことを目的としています。</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href="https://reactjs.org/"&gt;React&lt;/a&gt; and &lt;a href="https://webpack.js.org/"&gt;webpack&lt;/a&gt;.</source>
          <target>このガイドでは、&lt;a href="https://reactjs.org/"&gt;React&lt;/a&gt;および&lt;a href="https://webpack.js.org/"&gt;webpack&lt;/a&gt;とTypeScriptを関連付ける方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target>これはJavaScriptでは頻繁に発生するため、TypeScriptは古いタイプに基づいて新しいタイプを作成する方法を提供します:&lt;strong&gt;マップされたタイプ&lt;/strong&gt;。 マップされたタイプでは、新しいタイプは同じ方法で古いタイプの各プロパティを変換します。 たとえば、タイプ&lt;code&gt;のすべてのプロパティを読み取り専用&lt;/code&gt;にするか、オプションにすることができます。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target>これには非常に具体的な意味があります。&lt;code&gt;done&lt;/code&gt;コールバックは、1つの引数で呼び出すことも、2つの引数で呼び出すこともできます。 作成者はおそらく、コールバックが&lt;code&gt;elapsedTime&lt;/code&gt;パラメータを考慮していない可能性があると言おうとしていましたが、これを実行するためにパラメータをオプションにする必要はありません。より少ない引数を受け入れるコールバックを提供することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target>これは、重複定義エラーの一般的な原因の1つです。 インタフェース上の同じメンバーを定義する複数の宣言ファイル。</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target>これには上記と同じ問題があります。&lt;code&gt;getDistance&lt;/code&gt;のスペルを間違えて、エラーが発生しなかった可能性があります。 このため、TypeScriptには&lt;code&gt;noImplicitThis&lt;/code&gt;オプションがあります。 このオプションが設定されている場合、&lt;code&gt;this&lt;/code&gt;が明示的な(または推論された)型なしで使用されると、TypeScriptはエラーを発行します。 修正方法は、&lt;code&gt;this&lt;/code&gt;パラメータを使用して、インタフェースまたは関数自体に明示的な型を与えることです。</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target>これは画期的な変更です。以前は、&lt;code&gt;keyof&lt;/code&gt;演算子とマップされた型は、&lt;code&gt;string&lt;/code&gt;名前付きプロパティのみをサポートしていました。 &lt;code&gt;keyof T&lt;/code&gt;でタイプされた値が常に&lt;code&gt;string&lt;/code&gt;sであると仮定したコードは、エラーとしてフラグが立てられる。</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target>これは、&lt;code&gt;GenericNumber&lt;/code&gt;クラスを文字通りに使用したものですが、&lt;code&gt;number&lt;/code&gt;型のみを使用するように制限するものは何もないことにお気付きかもしれません。 代わりに&lt;code&gt;string&lt;/code&gt;やもっと複雑なオブジェクトを使うこともできます。</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target>これは合理的な制限です。なぜなら、&lt;code&gt;Foo&lt;/code&gt;の使用は、&lt;code&gt;Foo&lt;/code&gt;で置き換えられる必要があり、&lt;code&gt;Foo&lt;/code&gt;で置き換えられる必要があり、&lt;code&gt;Foo&lt;/code&gt;which&amp;ヘリプ;で置き換えられる必要があるからです。 最後に、&lt;code&gt;Foo&lt;/code&gt;の代わりに意味のある型がありません。</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target>これは、&lt;code&gt;lib.d.ts&lt;/code&gt;に&lt;code&gt;CallableFunction&lt;/code&gt;と&lt;code&gt;NewableFunction&lt;/code&gt;の2つの新しい型を導入することによって実現されます。これらの型には、&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;、および&lt;code&gt;apply&lt;/code&gt;のそれぞれに対して、通常の関数とコンストラクタ関数のための特殊な汎用メソッド宣言が含まれています。 宣言では、一般的なrestパラメータ(#24897を参照)を使用して、強く型付けされた方法でパラメータリストを取得し、反映します。 &lt;code&gt;--strictBindCallApply&lt;/code&gt;モードでは、これらの宣言は&lt;code&gt;Function&lt;/code&gt;型で提供される(非常に許容的な)宣言の代わりに使用される。</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target>これは、クラスがインターフェースを実装する場合、クラスのインスタンス側のみがチェックされるためです。 コンストラクタは静的な側にあるため、このチェックには含まれません。</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target>これは&amp;ldquo;context typing&amp;rdquo;という型推論の形式です。 これにより、プログラムの入力を維持するための労力を削減できます。</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target>これは、次のように&lt;code&gt;文&lt;/code&gt;を宣言することと同じです。</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes">
          <source>This is fairly &lt;a href="https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms"&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target>これは&lt;a href="https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms"&gt;他の言語での型エイリアスの扱い方&lt;/a&gt;とほぼ一致していますが、ユーザーがこの機能をどのように利用するかについて、少し意外なシナリオがいくつかあります。 たとえば、TypeScript3.6以前では、次の場合にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target>これは、競合が発生しない限り合法です。 一般的な経験則として、値は&lt;code&gt;namespace&lt;/code&gt;sとして宣言されていない限り、常に同じ名前の他の値と競合し、型エイリアス宣言(&lt;code&gt;types=string&lt;/code&gt;)で宣言されている場合は型が競合し、名前空間は決して競合しません。</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target>TypeScriptは、クラスのインスタンスメソッド内で&lt;code&gt;this&lt;/code&gt;という特別な型を持つように&lt;code&gt;this&lt;/code&gt;を推論するようになった。 &lt;code&gt;this&lt;/code&gt;typeはそのように記述されており、基本的には&amp;ldquo;メソッド呼び出しのドットの左側の型&amp;rdquo;を意味します。</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target>これはMSBuildプロジェクトのデフォルトです。これにより、出力はクリーンビルドでのみ生成されるため、MSBuildインクリメンタルビルドを期待どおりに動作させることができます。</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target>これは、&lt;code&gt;--noImplicitAny&lt;/code&gt;が設定されている場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target>これは消費者にとって最適です。 タイプには任意の名前を付けることができ(この場合は&lt;code&gt;t&lt;/code&gt;)、オブジェクトを見つけるために過度なドットを付ける必要はありません。</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target>これはTypeScript3.3ではまだ厳密に可能であり、明示的な型アノテーションを追加することができます。</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target>インターフェースを導入することで、ユーザーが実質的に同じコードを書くことができるような使い方には、技術的に何の問題もないので、これは奇妙です。</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target>これは型システムの観点からは適切ではありませんが、実行時の観点からは、&lt;code&gt;undefined&lt;/code&gt;をその位置に渡すことはほとんどの関数に対して同等であるため、オプションパラメータの概念は一般的に十分に実施されていません。</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target>これは、大きな継承階層があるが、特定のプロパティを持つサブクラスのみでコードが動作するように指定する場合に便利です。 サブクラスは、基本クラスから継承する以外に関連する必要はありません。 例:</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target>この種のイテレーターは、Arrayの要素やMapのキーなど、同期的に使用可能な値を反復する場合に便利です。 反復をサポートするオブジェクトは、&lt;code&gt;Iterator&lt;/code&gt;オブジェクトを返す&lt;code&gt;Symbol.iterator&lt;/code&gt;メソッドを持つ場合、&amp;ldquo;iterable&amp;rdquo;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target>これは混乱しているように思えるかもしれませんが、過度に負荷をかけない限り、実際にはとても便利です。 &amp;rsquo;sは、この結合動作のいくつかの有用な側面を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target>これは、以下のようなコードがJSONとヘリプを表現しようとしていたことを意味する。</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target>これは、共用体タイプと&lt;code&gt;instanceof&lt;/code&gt;が構造的に同一のクラスを正しく区別することを意味します。</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target>つまり、他のモジュールやライブラリを条件付きで遅延インポートすることができます。 たとえば、必要なときにのみユーティリティライブラリをインポートする&lt;code&gt;async&lt;/code&gt;関数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target>このモードでは、第3者ライブラリとのミキシングやマッチングを柔軟に行うことができます。第2者ライブラリでは、モジュール内からでも、ライブラリが宣言するグローバル変数を常に使用できます。</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target>この名前空間のマージ・モデルは出発点として役に立ちますが、エクスポートされていないメンバーで何が起こるかを理解する必要もあります。 エクスポートされていないメンバーは、元の(マージされていない)名前空間でのみ表示されます。 つまり、マージ後、他の宣言から取得したマージされたメンバーは、エクスポートされていないメンバーを参照できません。</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target>この新しい動作は、ユニオン内の1つのタイプに複数のオーバーロードがあり、ユニオン内の1つのタイプに一般的なシグネチャがある場合にのみ適用されます。 つまり、&lt;code&gt;number[]string[]&lt;/code&gt;のような&lt;code&gt;map&lt;/code&gt;(これは一般的です)のメソッドは、呼び出しできません。</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target>この新しい緩和によって、タプルの型別名も再帰的に参照できるようになります。 エラーが発生していた次のコードは、有効なTypeScriptコードになりました。</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target>この奇妙なパターンは、実際にはかなり一般的です。 パラメータリストの&lt;code&gt;i&lt;/code&gt;は、実際には&lt;code&gt;for&lt;/code&gt;ループで宣言された&lt;code&gt;i&lt;/code&gt;に影を付けますが、それらに同じ名前を付けたので、ループ本体をあまりにも修正する必要がありません。</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target>これにより、コードを非常にエレガントに記述することができますが、&lt;code&gt;BasicCalculator&lt;/code&gt;から拡張しようとするクラスには問題がありました。 ユーザが&lt;code&gt;ScientificCalculator&lt;/code&gt;を書き始めたとします。</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target>これは、&lt;em&gt;明示的&lt;/em&gt;文字列インデックスシグネチャを持つ型にのみ適用されます。 &lt;code&gt;.&lt;/code&gt;表記を使用してタイプの不明なプロパティにアクセスすると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target>このオプションは&lt;code&gt;UseFsEvents&lt;/code&gt;に似ていますが、&lt;code&gt;fs.watch&lt;/code&gt;を使用した監視の作成に失敗した場合、フォールバック監視は動的ポーリングキューを通じて行われます(&lt;code&gt;DynamicPriorityPolling&lt;/code&gt;で説明)。</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target>このオプションは、&lt;code&gt;fs.watch&lt;/code&gt;(ファイルシステムイベントを使用)でファイルの親ディレクトリを監視するため、CPU使用率は低くなりますが、精度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target>この記事では、TypeScriptで名前空間(以前の&amp;ldquo;internal modules&amp;rdquo;)を使ってコードを編成するさまざまな方法について概説する。 用語について説明したように、&amp;ldquo;内部モジュール&amp;rdquo;は&amp;ldquo;名前空間&amp;rdquo;と呼ばれるようになりました。 また、内部モジュールを宣言するときに&lt;code&gt;module&lt;/code&gt;キーワードが使用された場所では、&lt;code&gt;namespace&lt;/code&gt;キーワードを代わりに使用できます。 これにより、類似した名前の用語で新しいユーザーをオーバーロードすることで、新しいユーザーを混乱させることがなくなります。</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target>この記事では、TypeScriptで名前空間とモジュールを使用してコードを編成するさまざまな方法について概説する。 また、名前空間とモジュールの使用方法に関する高度なトピックについても説明し、TypeScriptで使用する際によくある落とし穴に対処します。</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target>これは単純なエントリー・ポイントです。例えば、TypeScriptリポジトリでは、&lt;code&gt;src/tsconfig.json&lt;/code&gt;にすべてのサブプロジェクトをリストするので、&lt;code&gt;tsc-b src&lt;/code&gt;を実行してすべてのエンドポイントを構築するだけです。</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target>これは、消費コードの構造を解除する非常に良い機会を提供します。</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href="http://gulpjs.com"&gt;gulp&lt;/a&gt; and then add &lt;a href="http://browserify.org"&gt;Browserify&lt;/a&gt;, &lt;a href="http://lisperator.net/uglifyjs/"&gt;uglify&lt;/a&gt;, or &lt;a href="https://github.com/substack/watchify"&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt; functionality using &lt;a href="https://github.com/babel/babelify"&gt;Babelify&lt;/a&gt;.</source>
          <target>このクイックスタートガイドでは、&lt;a href="http://gulpjs.com"&gt;gulp&lt;/a&gt;を使用してTypeScriptを構築し、&lt;a href="http://browserify.org"&gt;Browserify&lt;/a&gt;、&lt;a href="http://lisperator.net/uglifyjs/"&gt;uglify&lt;/a&gt;、または&lt;a href="https://github.com/substack/watchify"&gt;Watchify&lt;/a&gt;をgulpパイプラインに追加する方法について説明します。 また、&lt;a href="https://github.com/babel/babelify"&gt;Babelify&lt;/a&gt;を使用して&lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt;の機能を追加する方法についても説明します。</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes">
          <source>This resolution strategy attempts to mimic the &lt;a href="https://nodejs.org/"&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href="https://nodejs.org/api/modules.html#modules_all_together"&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target>この解決方法では、実行時に&lt;a href="https://nodejs.org/"&gt;Node.js&lt;/a&gt;モジュールの解決メカニズムを模倣しようとします。 Node.jsの完全な解決アルゴリズムについては、&lt;a href="https://nodejs.org/api/modules.html#modules_all_together"&gt;Node.js module documentation&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes">
          <source>This results in the generated JS</source>
          <target>これにより生成されるJS</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href="modules"&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target>このセクションでは、モジュールに関する基本的な知識を前提としています。 詳細については、&lt;a href="modules"&gt;モジュール&lt;/a&gt;のマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target>これは、参照する値が&lt;em&gt;不変&lt;/em&gt;であるという考えと混同しないでください。</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target>この単純な例は、インポートとエクスポートの際に使用される名前がどのようにモジュール・ロード・コードに変換されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;"*"&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target>これにより、パターン&lt;code&gt;"*"&lt;/code&gt;(つまり、すべての値)に一致するモジュールインポートのコンパイラは、次の2つの場所を検索します。</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target>これはクラスをインターフェースとして扱い、DisposableとActivatorableの背後にある型を実装ではなくSmartObject型に混合するだけです。 これは、クラスで実装を提供する必要があることを意味します。 ただし、これはミックスインを使用することで回避したいものです。</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target>これは以前、TypeScriptのデフォルトの解決方法でした。 今日では、この戦略は主に下位互換性のために存在します。</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target>このユーティリティは、変換された型を返しません。 代わりに、コンテキスト&lt;code&gt;この&lt;/code&gt;型のマーカーとして機能します。 このユーティリティを使用するには、&lt;code&gt;--noImplicitThis&lt;/code&gt;フラグを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"&gt;frozen object&lt;/a&gt;).</source>
          <target>このユーティリティは、実行時(&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"&gt;凍結オブジェクト&lt;/a&gt;のプロパティを再割り当てするときなど)に失敗する代入式を表す場合に便利です。</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target>内側のループの&lt;code&gt;i&lt;/code&gt;が外側のループの&lt;code&gt;i&lt;/code&gt;に影を付けているため、このバージョンのループは実際に合計を正しく実行します。</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target>これは、矢印関数が外側の&lt;code&gt;this&lt;/code&gt;を使用するので、&lt;code&gt;this:void&lt;/code&gt;を想定したものにいつでも渡すことができます。ただし、Handler型のオブジェクトごとに1つの矢印関数が作成されるという欠点があります。 一方、メソッドは一度だけ作成され、ハンドラのプロトタイプに付加されます。 ハンドラ型のすべてのオブジェクト間で共有されます。</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target>これはTypeScriptでも問題なく動作しますが、コンパイラは&lt;code&gt;Observable.prototype.map&lt;/code&gt;を認識していません。モジュール拡張を使用して、コンパイラにそのことを伝えることができます。</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target>これは十分に機能しますが、&lt;code&gt;SomeType&lt;/code&gt;と&lt;code&gt;SomeVar&lt;/code&gt;は非常に密接に関連しており、同じ名前を持つことを好む場合があります。 次の2つの異なるオブジェクト(値とタイプ)を同じ名前&lt;code&gt;Bar&lt;/code&gt;で表すには、combiningを使用します。</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes">
          <source>ThisParameterType</source>
          <target>ThisParameterType</target>
        </trans-unit>
        <trans-unit id="a76438beddfb8c955093d8ab197f48807e657fb5" translate="yes">
          <source>ThisType&lt;T&gt;</source>
          <target state="translated">ThisType&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target>推奨される方法ではありませんが、一部のモジュールでは、他のモジュールで使用できるグローバル状態が設定されています。 これらのモジュールには、エクスポートがない場合や、消費者がエクスポートに関心がない場合があります。 これらのモジュールをインポートするには、次を使用します。</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes">
          <source>Thus, the following calls are equivalent:</source>
          <target>したがって、次の呼び出しは同等です。</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target>戻り値と生成された値を区別できるようにするために、TypeScript3.6は&lt;code&gt;IteratorResult&lt;/code&gt;型を識別されたユニオン型に変換します。</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target>まず、JavaScriptと同様に、TypeScript関数は名前付き関数としても匿名関数としても作成できます。 これにより、APIで関数のリストを作成する場合でも、別の関数に渡す場合でも、アプリケーションに最適な方法を選択できます。</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target>&lt;code&gt;x&lt;/code&gt;が&lt;code&gt;y&lt;/code&gt;に代入可能かどうかを確認するには、まずパラメータリストを調べます。 &lt;code&gt;x&lt;/code&gt;内の各パラメータには、&lt;code&gt;y&lt;/code&gt;内の互換性のあるタイプの対応するパラメータが必要です。 パラメータの名前は考慮されず、タイプのみが考慮されます。 この場合、&lt;code&gt;x&lt;/code&gt;の各パラメータは、&lt;code&gt;y&lt;/code&gt;に対応する互換パラメータを持つため、代入が可能となる。</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target>&lt;code&gt;y&lt;/code&gt;が&lt;code&gt;x&lt;/code&gt;に割り当てられるかどうかをチェックするために、コンパイラは&lt;code&gt;x&lt;/code&gt;の各プロパティをチェックして、&lt;code&gt;y&lt;/code&gt;内の対応する互換性のあるプロパティを見つけます。この場合、&lt;code&gt;y&lt;/code&gt;には、&lt;code&gt;name&lt;/code&gt;という文字列であるメンバが必要です。 そのため、割り当ては許可されます。</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target>コンパイルするには、コマンドラインでモジュールターゲットを指定する必要があります。 Node.jsの場合は&lt;code&gt;--module commonjs&lt;/code&gt;を使用し、require.jsの場合は&lt;code&gt;--module amd&lt;/code&gt;を使用します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target>&lt;code&gt;next()&lt;/code&gt;の呼び出しからジェネレータに渡される型を正しく表現するために、TypeScript3.6は、ジェネレータ関数の本体内で&lt;code&gt;yield&lt;/code&gt;の特定の使用を推論する。</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target>型ガードを定義するには、戻り型が&lt;em&gt;型述語&lt;/em&gt;である関数を定義するだけです。</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target>インタフェースを持つ関数型を記述するために,インタフェースにコールシグネチャを与える。 これは、パラメーター・リストと戻り値の型のみを指定する関数宣言のようなものです。 パラメータリストの各パラメータには、名前とタイプの両方が必要です。</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target>TypeScriptで書かれていないライブラリの形を記述するには、ライブラリが公開するAPIを宣言する必要がある。</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target>TypeScriptで書かれていないライブラリの形を記述するには、ライブラリが公開するAPIを宣言する必要がある。 ほとんどのJavaScriptライブラリーは少数の最上位オブジェクトしか公開しないため、名前空間はそれらを表現するための優れた方法です。</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target>アクセサに関する問題を検出するために、TypeScript3.7は&lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;アクセサを&lt;code&gt;.d.ts&lt;/code&gt;ファイルに出力し、TypeScriptで上書きされたアクセサをチェックできるようにします。</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target>そのためには、制約を記述するインタフェースを作成します。 ここでは、単一の&lt;code&gt;.length&lt;/code&gt;プロパティを持つインタフェースを作成し、このインタフェースを使用して&lt;code&gt;extends&lt;/code&gt;キーワードで制約を示します。</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target>そのためには、入力ファイルのリストとすべてのコンパイル設定を含む&lt;code&gt;tsconfig.json&lt;/code&gt;を作成する必要があります。 &lt;code&gt;tsconfig.json&lt;/code&gt;という名前の新しいファイルをプロジェクトルートに作成し、次の内容を入力します。</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>デコレータの試験的サポートを有効にするには、コマンドラインまたは&lt;code&gt;tsconfig.json&lt;/code&gt;で&lt;code&gt;experimentalDecorators&lt;/code&gt;コンパイラオプションを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target>上記の再帰的な型エイリアスパターンを有効にするために、&lt;code&gt;typeArguments&lt;/code&gt;プロパティが&lt;code&gt;TypeReference&lt;/code&gt;インタフェースから削除されました。 &lt;code&gt;TypeChecker&lt;/code&gt;インスタンスでは、&lt;code&gt;getTypeArguments&lt;/code&gt;関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target>シンボルを一意のリテラルとして扱うために、新しいタイプ&lt;code&gt;一意のシンボル&lt;/code&gt;を使用できます。 &lt;code&gt;unique symbol&lt;/code&gt;は&lt;code&gt;symbol&lt;/code&gt;のサブタイプであり、&lt;code&gt;Symbol()&lt;/code&gt;または&lt;code&gt;Symbol.for()&lt;/code&gt;を呼び出すか、明示的な型注釈からのみ生成されます。 新しいタイプは、&lt;code&gt;const&lt;/code&gt;宣言と&lt;code&gt;readonly static&lt;/code&gt;プロパティでのみ使用できます。特定の一意のシンボルを参照するには、&lt;code&gt;typeof&lt;/code&gt;演算子を使用する必要があります。 &lt;code&gt;一意のシンボル&lt;/code&gt;への各参照は、指定された宣言に関連付けられた完全に一意のIDを意味します。</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target>より具体的にするために、&amp;rsquo;sは何らかの動機を構築し、次の&lt;code&gt;compose&lt;/code&gt;関数を検討します。</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target>同じコードを動作させるには、型アサーションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target>2番目の問題を軽減するには、明示的な初期化子を追加するか、プロパティにエミットを持たないように指示する&lt;code&gt;declare&lt;/code&gt;修飾子を追加します。</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target>上記の例で&lt;code&gt;x&lt;/code&gt;の型を推測するには、各配列要素の型を考慮する必要があります。 ここでは、配列の型として&lt;code&gt;number&lt;/code&gt;と&lt;code&gt;null&lt;/code&gt;の2つの選択肢が与えられます。最も一般的な型アルゴリズムでは、各候補型が考慮され、他のすべての候補と互換性のある型が選択されます。</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes">
          <source>To learn more, &lt;a href="https://github.com/microsoft/TypeScript/pull/31116"&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/31116"&gt;GitHub&lt;/a&gt;でオリジナルのプルリクエストを確認してください。</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target>型の安全性を維持するには、&lt;code&gt;typeof&lt;/code&gt;キーワードを使用します。 &lt;code&gt;typeof&lt;/code&gt;キーワードを型位置で使用すると、値の型(この場合はモジュールの型)が生成されます。</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target>名前空間の値をマージするには、各宣言サイトで、指定された名前を持つ名前空間がすでに存在する場合、既存の名前空間を取得し、エクスポートされた2番目の名前空間のメンバを最初の名前空間に追加することによって、さらに拡張します。</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target>名前空間をマージするには、各名前空間で宣言されたエクスポートされたインタフェースの型定義がマージされ、内部にマージされたインタフェース定義を持つ単一の名前空間が形成されます。</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target>既存の機能を維持するために、&lt;code&gt;fullName&lt;/code&gt;を修正せずに取得する単純なゲッターも追加します。</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target>アクセサーが値の長さをチェックしていることを証明するために、10文字を超える名前を割り当てて、エラーが発生することを確認します。</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target>JavaScriptでのこれら2つの方法の概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes">
          <source>To read up more about assertion signatures, &lt;a href="https://github.com/microsoft/TypeScript/pull/32695"&gt;check out the original pull request&lt;/a&gt;.</source>
          <target>アサーション署名の詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32695"&gt;オリジナルのプルリクエストをチェックしてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target>モジュールの内容に名前を付けない理由をもう一度言うと、名前空間の一般的な考え方は、構成体を論理的にグループ化し、名前の衝突を防ぐことです。 モジュールファイル自体は既に論理グループ化されており、その最上位レベルの名前はインポートするコードによって定義されているため、エクスポートされたオブジェクトに追加のモジュール画層を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes">
          <source>To specify this relationship to the compiler, use&lt;code&gt;"rootDirs"&lt;/code&gt;. &lt;code&gt;"rootDirs"&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target>この関係をコンパイラに指定するには、&lt;code&gt;"rootDirs"&lt;/code&gt;を使用します。&lt;code&gt;"rootDirs"&lt;/code&gt;は、実行時に内容がマージされる&lt;em&gt;ルートのリストを指定します。&lt;/em&gt;。 この例では、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target>最初に、&amp;rsquo;sに&amp;ldquo;の&amp;ldquo;hello world&amp;rdquo;のID関数を実行させます。 identity関数は、渡されたものを返す関数です。 これは、&lt;code&gt;echo&lt;/code&gt;コマンドと同じように考えることができます。</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target>まず、次の方法でプロジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes">
          <source>To understand the full impact, read &lt;a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier"&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target>影響を完全に理解するには、&lt;a href="#theウシャドーフィネフォークロスフィールドスflag and the declare property modifier"&gt;上の&lt;code&gt;useDefineForClassFields&lt;/code&gt;フラグのセクション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target>TSコンパイラが従うステップを理解するには,Node.jsモジュールに光を当てることが重要だ。 従来、Node.jsへのインポートは、&lt;code&gt;require&lt;/code&gt;という名前の関数を呼び出して実行されていました。&lt;code&gt;require&lt;/code&gt;に相対パスが指定されているか、非相対パスが指定されているかによって、Node.jsの動作は異なります。</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes">
          <source>To use JSX with React you should use the &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react"&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target>ReactでJSXを使用するには、&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react"&gt;React型&lt;/a&gt;を使用する必要があります。これらの型は、Reactで使用する&lt;code&gt;JSX&lt;/code&gt;名前空間を適切に定義します。</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes">
          <source>To use JSX-support with React you should use the &lt;a href="https://github.com/borisyankov/DefinitelyTyped/tree/master/react"&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target>ReactでJSXサポートを使用するには、&lt;a href="https://github.com/borisyankov/DefinitelyTyped/tree/master/react"&gt;React型&lt;/a&gt;を使用する必要があります。これらの型は&lt;code&gt;JSX&lt;/code&gt;名前空間を定義し、TypeScriptがReactのJSX式を正しくチェックできるようにします。 例:</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target>今日、世界中で利用されているライブラリーのほとんどは、実際にはUMDライブラリーとして作成されています(下記参照)。 UMDライブラリのドキュメントは、グローバルライブラリのドキュメントと区別するのが困難です。 グローバル宣言ファイルを作成する前に、ライブラリが実際にUMDでないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target>(1)と(2)を組み合わせると、&lt;code&gt;browserify&lt;/code&gt;への呼び出しを&lt;code&gt;default&lt;/code&gt;タスクから移動する必要があります。 また、&lt;code&gt;default&lt;/code&gt;関数に名前を指定する必要があります。これは、WatchifyとGulpの両方が名前を呼び出す必要があるためです。 (3)でのロギングの追加はオプションですが、セットアップのデバッグには非常に便利です。</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target>交差タイプとともに、次のような非常に柔軟なタイプを作成できます。</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes">
          <source>Too many/too few arguments</source>
          <target>引数が多すぎる/少なすぎる</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes">
          <source>ToolsVersion</source>
          <target>ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target>最上位レベルの&lt;code&gt;var&lt;/code&gt;ステートメントまたは&lt;code&gt;関数&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes">
          <source>Tracing module resolution</source>
          <target>トレーシング・モジュールの解決</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes">
          <source>Trade-offs of Modules</source>
          <target>モジュールのトレードオフ</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target>従来のJavaScriptでは、関数とプロトタイプベースの継承を使用して再利用可能なコンポーネントを構築していましたが、クラスが機能を継承し、オブジェクトがこれらのクラスから構築されるオブジェクト指向のアプローチに慣れているプログラマーには、少し違和感があるかもしれません。 ECMAScript2015(ECMAScript6とも呼ばれます)以降、JavaScriptプログラマーは、このオブジェクト指向クラスベースのアプローチを使用してアプリケーションを構築できるようになります。 TypeScriptでは、開発者がこれらのテクニックを今すぐ使うことができ、次のバージョンのJavaScriptを待たずに、主要なすべてのブラウザとプラットフォームで動作するJavaScriptにコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href="https://jeffmo.github.io/es-trailing-function-commas/"&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target>関数パラメータおよび引数リストの末尾にカンマを使用できるようになりました。 これは、&lt;a href="https://jeffmo.github.io/es-trailing-function-commas/"&gt;Stage3ECMAScriptプロポーザル&lt;/a&gt;の実装であり、有効なES3/ES5/ES6を生成します。</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes">
          <source>Trailing commas in function parameter and argument lists</source>
          <target>関数パラメータと引数リストの末尾のコンマ</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target>新しいJavaScript構文をECMAScript5のような古いバージョンに変換する(&lt;code&gt;target&lt;/code&gt;を使用)。</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes">
          <source>Triple-Slash Directives</source>
          <target>トリプルスラッシュディレクティブ</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target>トリプル・スラッシュ・ディレクティブは、それを含むファイルの先頭で&lt;strong&gt;のみ&lt;/strong&gt;有効です。 トリプル・スラッシュ・ディレクティブの前には、他のトリプル・スラッシュ・ディレクティブも含め、1行または複数行のコメントのみを付けることができます。 ステートメントまたは宣言の後に出現する場合は、通常の1行コメントとして扱われ、特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target>トリプルスラッシュディレクティブは、1つのXMLタグを含む1行のコメントです。 コメントの内容は、コンパイラディレクティブとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target>トリプルスラッシュ参照は、コンパイルプロセスに追加ファイルを含めるようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes">
          <source>Tuple</source>
          <target>タプル</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes">
          <source>Tuple destructuring</source>
          <target>タプルの分解</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes">
          <source>Tuple types</source>
          <target>タプル型</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target>タプル型を使用すると、型が既知であるが同じである必要がない要素を一定数持つ配列を表現できます。 たとえば、値を&lt;code&gt;string&lt;/code&gt;と&lt;code&gt;number&lt;/code&gt;のペアとして表す場合があります。</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target>タプル型は、特定の要素の型がわかっている配列を表しますが、同じである必要はありません。 たとえば、位置0に&lt;code&gt;string&lt;/code&gt;、位置1に&lt;code&gt;number&lt;/code&gt;を持つ配列を表すとします。</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target>タプル型では、要素がオプションであることを示すために、要素型の&lt;code&gt;?&lt;/code&gt;接尾辞を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes">
          <source>Tuples in rest parameters and spread expressions</source>
          <target>restパラメータとspread式のタプル</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target>タプルは配列のように分解できます。分解変数は対応するタプル要素の型を取得します。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes">
          <source>Tutorials</source>
          <target>チュートリアル</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes">
          <source>Type</source>
          <target>タイプ</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes">
          <source>Type Alias</source>
          <target state="translated">型エイリアス</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes">
          <source>Type Aliases</source>
          <target state="translated">型エイリアス</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes">
          <source>Type Checking</source>
          <target>タイプチェック</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes">
          <source>Type Checking JavaScript Files</source>
          <target>型チェックJavaScriptファイル</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes">
          <source>Type Checking JavaScript Files: @enum</source>
          <target>型チェックJavaScriptファイル:@enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes">
          <source>Type Checking JavaScript Files: @this</source>
          <target>型チェックJavaScriptファイル:@this</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes">
          <source>Type Checking JavaScript Files: @type</source>
          <target>型チェックJavaScriptファイル:@type</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes">
          <source>Type Compatibility</source>
          <target>タイプの互換性</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes">
          <source>Type Compatibility: Enums</source>
          <target>タイプの互換性:列挙型</target>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes">
          <source>Type Guards</source>
          <target>タイプガード</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes">
          <source>Type Guards and Differentiating Types</source>
          <target>タイプガードと区別タイプ</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes">
          <source>Type Inference</source>
          <target>型推論</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">型のエイリアスは、元の型とまったく同じです。単なる代替名です。</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target>タイプエイリアスは、タイプの新しい名前を作成します。 型の別名はインタフェースに似ていることがありますが、プリミティブ、共用体、タプル、その他、手動で作成する必要のある型に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target>タイプエイリアスには、&amp;ldquo;recursively&amp;rdquo;参照方法に常に制限があります。 その理由は、型エイリアスを使用する場合には、そのエイリアスが何であれ、それ自体を置き換えることができる必要があるからです。 &amp;rsquo;が不可能な場合があるので、コンパイラは次のような再帰的なエイリアスを拒否します。</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes">
          <source>Type annotations</source>
          <target state="translated">型アノテーション</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target>TypeScriptの型アノテーションは、関数または変数の意図されたコントラクトを記録する簡単な方法です。 この例では、greeter関数を単一の文字列パラメータで呼び出します。 代わりに、callgreeterを変更して配列を渡してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target>&lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts check&lt;/code&gt;モードでアサーション/キャスト構文を入力します</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes">
          <source>Type assertions</source>
          <target>型アサーション</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target>型アサーションには2つの形式があります。 1つは&amp;ldquo;angle&amp;rdquo;の構文です。</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target>&lt;code&gt;instanceof&lt;/code&gt;演算子の型チェックは、左オペランドの型&lt;em&gt;が右オペランドで示された型から派生しているかどうかに基づいて行われます(構造サブタイプチェックとは異なります)。</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target>TypeScriptでの型の互換性は、構造的なサブタイピングに基づいています。 構造型定義は、型をそのメンバーのみに基づいて関連付ける方法です。 これは名目上の型付けとは対照的である。 次のコードを検討してください。</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes">
          <source>Type guards and type assertions</source>
          <target>型ガードと型アサーション</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target>ドット付き名の型ガードは、ユーザ定義型ガード関数、&lt;code&gt;typeof&lt;/code&gt;および&lt;code&gt;instanceof&lt;/code&gt;演算子とも動作し、&lt;code&gt;--strictNullChecks&lt;/code&gt;コンパイラオプションに依存しません。</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target>&lt;/code&gt;演算子の&lt;code&gt;から推測される型ガード</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes">
          <source>Type guards on the common property.</source>
          <target>共有財産にタイプガード。</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target>以前は、型ガードはローカル変数とパラメータのチェックのみをサポートしていました。 タイプガードは、1つまたは複数のプロパティアクセスに続く変数名またはパラメータ名で構成される&amp;ldquo;dotted names&amp;rdquo;のチェックをサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target>ボックスに値を入力し、ブレークポイントがTypeScriptコードでヒットし、検査が正しく動作することを確認します。</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target>型推論は、&amp;ldquo;もう一方の方向&amp;rdquo;でも動作します。 これは&amp;ldquo;コンテキストタイプ&amp;rdquo;と呼ばれます。 前後関係の型付けは、式の型がその位置によって暗黙的に指定されている場合に行われます。 例:</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes">
          <source>Type inference in conditional types</source>
          <target>条件付き型の型推論</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes">
          <source>Type parameter inference from contextual types</source>
          <target>コンテキストタイプからのタイプパラメータの推定</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes">
          <source>Type parameters as constraints</source>
          <target>制約としてパラメータを入力</target>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes">
          <source>Type widening</source>
          <target>タイプの拡幅区間</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target>&lt;code&gt;globalThis&lt;/code&gt;の型チェック</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes">
          <source>Type-checking speed-ups</source>
          <target>型チェックの高速化</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target>TypeScript1.5は、ES6の宣言と割り当ての構造化解除をサポートする。</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target>TypeScript1.5では、ES6でのES3/ES5のアレイ上のループのサポートと、ES6をターゲットとする場合のIteratorインターフェースの完全なサポートが追加された。</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target>TypeScript1.5はECMAScript6(ES6)モジュールをサポートする。 ES6モジュールは、新しい構文を持つTypeScript外部モジュールです。 ES6モジュールは、別個にロードされたソースファイルであり、他のモジュールをインポートしたり、外部からアクセス可能な多数のエクスポートを提供します。 ES6モジュールには、エクスポートとインポートの宣言がいくつか追加されています。 TypeScriptライブラリとアプリケーションを更新して新しい構文を使用することをお勧めしますが、必須ではありません。 新しいES6モジュール構文は、TypeScript&amp;rsquo;のオリジナルの内部および外部モジュール構文と共存しており、構成は自由に組み合わせて使用できます。</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target>TypeScript1.6は、&lt;code&gt;typeof&lt;/code&gt;と&lt;code&gt;instanceof&lt;/code&gt;に加えて、&lt;code&gt;if&lt;/code&gt;ブロック内の変数型を狭める新しい方法を追加します。ユーザ定義型ガード関数は、&lt;code&gt;x is T&lt;/code&gt;という形式の戻り型注釈を持つ関数です。&lt;code&gt;x&lt;/code&gt;は署名で宣言されたパラメータであり、&lt;code&gt;T&lt;/code&gt;は任意の型です。 &lt;code&gt;if&lt;/code&gt;ブロック内の変数に対してユーザ定義型ガード関数が呼び出されると、変数の型は&lt;code&gt;T&lt;/code&gt;に絞り込まれます。</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target>TypeScript1.6では、クラスとそのメソッドの&lt;code&gt;abstract&lt;/code&gt;キーワードのサポートが追加された。 抽象クラスは、実装されていないメソッドを持つことができ、構築することはできません。</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target>TypeScript1.6はES6クラス式のサポートを追加した。 クラス式では、クラス名は省略可能で、指定された場合は、クラス式自体のスコープ内にのみ存在します。 これは、関数式のオプション名に似ています。 クラス式のクラスインスタンスタイプをクラス式の外部で参照することはできませんが、そのタイプは構造的に一致させることができます。 例:</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target>TypeScript1.6は、コンストラクタ関数を計算する任意の式を拡張するクラスのサポートを追加する。 つまり、組み込み型をクラス宣言で拡張できるようになりました。</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target>TypeScript1.6では、ES6をターゲットとする場合にジェネレータのサポートが追加されている。</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target>TypeScript1.6では、余分なプロパティやスペルミスのあるプロパティを検出するために、より厳密なオブジェクトリテラル割り当てチェックを強制します。 特に、新しいオブジェクトリテラルが変数に割り当てられるか、空でないターゲット型の引数として渡される場合、オブジェクトリテラルがターゲット型に存在しないプロパティを指定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target>TypeScript1.6は新しい&lt;code&gt;.tsx&lt;/code&gt;ファイル拡張子を導入する。 この拡張機能は2つのことを行います:TypeScriptファイル内でJSXを有効にし、新しい&lt;code&gt;as&lt;/code&gt;演算子をキャストのデフォルトの方法にします(JSX式とTypeScriptプレフィックスキャスト演算子の間の曖昧さを除去します)。 例:</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target>TypeScript1.6では、ES6をターゲットにした&lt;code&gt;async&lt;/code&gt;関数を実験的にサポートしている。 非同期関数は、非同期操作を呼び出し、プログラムの通常の実行をブロックすることなく、その結果を待ちます。 これは、ES6と互換性のある&lt;code&gt;Promise&lt;/code&gt;実装を使用し、関数本体を互換性のある形式に変換して、待ち望まれていた非同期操作が完了したときに実行を再開することによって達成された。</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target>TypeScript1.6では、論理的に結合型を補完する交差型を導入しています。 ユニオン・タイプ&lt;code&gt;AB&lt;/code&gt;は、タイプ&lt;code&gt;A&lt;/code&gt;またはタイプ&lt;code&gt;B&lt;/code&gt;のいずれかであるエンティティを表し、交差タイプ&lt;code&gt;A&amp;amp;B&lt;/code&gt;は、タイプ&lt;code&gt;A&lt;/code&gt;&lt;em&gt;および&lt;/em&gt;タイプ&lt;code&gt;B&lt;/code&gt;の両方であるエンティティを表します。</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target>TypeScript1.7は、&lt;code&gt;--module&lt;/code&gt;フラグに使用可能なオプションのリストに&lt;code&gt;ES6&lt;/code&gt;を追加し、&lt;code&gt;ES6&lt;/code&gt;をターゲットとするときにモジュール出力を指定できるようにします。これにより、特定のランタイムで必要な機能を正確にターゲットとする柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target>TypeScript1.7では、オブジェクトリテラルや配列リテラルの初期化子を使ってパターンの構造化をチェックするのが難しくなく、直感的になる。</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes">
          <source>TypeScript 1.7 supports upcoming &lt;a href="https://github.com/rwaldron/exponentiation-operator"&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target>TypeScript1.7は、次の&lt;a href="https://github.com/rwaldron/exponentiation-operator"&gt;ES7/ES2016指数演算子&lt;/a&gt;:&lt;code&gt;*&lt;/code&gt;および&lt;code&gt;*=&lt;/code&gt;をサポートしています。これらの演算子は、&lt;code&gt;Math.pow&lt;/code&gt;を使用して、出力でES3/ES5に変換されます。</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target>TypeScript1.8では、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルをすべてのプロジェクトタイプで使用できます。 これには、ASP.NET v4プロジェクト、&lt;em&gt;コンソールアプリケーション&lt;/em&gt;、および&lt;em&gt;TypeScriptを使用したHTMLアプリケーション&lt;/em&gt;プロジェクトタイプが含まれます。 さらに、単一の&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルに制限されることなく、複数のファイルを追加することができ、それぞれがプロジェクトの一部として構築されます。 これにより、複数の異なるプロジェクトを使用することなく、アプリケーションの異なる部分の構成を分離できます。</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target>TypeScript1.8では、ユーザは&lt;code&gt;--outFile&lt;/code&gt;引数を、名前付きパイプやデバイスなどの特殊なファイルシステムエンティティで使用できます。</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes">
          <source>TypeScript 1.8 extends &lt;a href="typescript-1.6#user-defined-type-guard-functions"&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target>TypeScript1.8は、&lt;a href="typescript1.6#user defined type guard functions"&gt;user-defined type guard functions&lt;/a&gt;をclassおよびinterfaceメソッドに拡張したものです。</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target>TypeScript1.8では、ソース側とターゲット側の両方が和集合タイプまたは交差タイプである場合の型推論が改善されている。 例えば、&lt;code&gt;string[]&lt;/code&gt;から&lt;code&gt;string T&lt;/code&gt;に推論する場合、型を&lt;code&gt;string[]&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;に縮小し、&lt;code&gt;string[]&lt;/code&gt;を&lt;code&gt;T&lt;/code&gt;に推論する。</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target>TypeScript1.8では制御フロー解析を導入し、ユーザが遭遇する可能性のある一般的なエラーをキャッチするのに役立てています。詳細については、次を参照してください。</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes">
          <source>TypeScript 2.0</source>
          <target state="translated">TypeScript 2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target>TypeScript2.0では、宣言ファイル(拡張子&lt;code&gt;.d.ts&lt;/code&gt;を持つファイル)の型チェックをスキップする新しい&lt;code&gt;--skipLibCheck&lt;/code&gt;コンパイラオプションが追加された。 プログラムに大きな宣言ファイルが含まれている場合、コンパイラはエラーが含まれていないことがわかっている宣言の型チェックに多くの時間を費やし、宣言ファイル型チェックをスキップすることによってコンパイル時間を大幅に短縮することができる。</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target>TypeScript2.0には、クリーンなコードベースを維持するのに役立つ2つの新しいフラグがあります。 &lt;code&gt;--noUnusedParameters&lt;/code&gt;は、使用されていない関数またはメソッドパラメータのエラーにフラグを付けます。 &lt;code&gt;--noUnusedLocals&lt;/code&gt;は、変数、関数、クラス、インポート、その他&amp;ヘリプなどの未使用のローカル(エクスポートされていない)宣言にフラグを付けます。 また、クラスの使用されていないプライベートメンバには、&lt;code&gt;--noUnusedLocals&lt;/code&gt;の下にエラーフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target>TypeScript2.0は、ローカル変数とパラメータの制御フローベースの型分析を実装します。 以前は、型ガードに対して実行される型分析は、&lt;code&gt;if&lt;/code&gt;ステートメントおよび&lt;code&gt;?:&lt;/code&gt;条件式に限定され、&lt;code&gt;return&lt;/code&gt;および&lt;code&gt;break&lt;/code&gt;ステートメントなどの代入および制御フロー構成体の影響を含まなかった。 TypeScript2.0では、型チェッカーはステートメントと式のすべての可能な制御フローを分析して、ユニオン型であると宣言されたローカル変数またはパラメータの任意の場所で可能な最も具体的な型(&lt;em&gt;絞り込み型&lt;/em&gt;)を生成します。</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target>TypeScript2.0は、タグ付き(または区別される)ユニオン型のサポートを実装する。 具体的には、TSコンパイラは、識別プロパティのテストに基づいてユニオン型を絞り込み、さらに&lt;code&gt;switch&lt;/code&gt;文にその機能を拡張する型ガードをサポートする。</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target>TypeScript2.0は、新しいプリミティブ型&lt;code&gt;never&lt;/code&gt;を導入します。&lt;code&gt;never&lt;/code&gt;型は、決して発生しない値の型を表します。 具体的には、&lt;code&gt;never&lt;/code&gt;は決して返さない関数の戻り型であり、&lt;code&gt;never&lt;/code&gt;は決して真でない型ガード下の変数の型です。</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target>TypeScript2.0は、コンパイラに特定のモジュールの宣言を見つける場所を&lt;em&gt;知らせるための追加モジュール解決knopsのセットを提供する。</target>
        </trans-unit>
        <trans-unit id="3f3705d152a2f1f40c51f05e54dd28f6cc6cc047" translate="yes">
          <source>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have &lt;em&gt;identical&lt;/em&gt; types.</source>
          <target>TypeScript2.0はこの制約を緩和し、&lt;em&gt;同一の&lt;/em&gt;型を持つ限り、ブロック間で識別子の重複を許可します。</target>
        </trans-unit>
        <trans-unit id="1a29a22cd01cb9654bf025f544accb002ba6f777" translate="yes">
          <source>TypeScript 2.0 supports the use of the wildcard character (&lt;code&gt;*&lt;/code&gt;) to declare a &amp;ldquo;family&amp;rdquo; of module names; this way, a declaration is only required once for an extension, and not for every resource.</source>
          <target>TypeScript2.0では、ワイルドカード文字(&lt;code&gt;*&lt;/code&gt;)を使用して、モジュール名の&amp;ldquo;family&amp;rdquo;を宣言できます。この方法では、すべてのリソースではなく、拡張に対して1回だけ宣言が必要です。</target>
        </trans-unit>
        <trans-unit id="e87039bc208381c858aaf91b34ef9a99581764c4" translate="yes">
          <source>TypeScript 2.1</source>
          <target state="translated">TypeScript 2.1</target>
        </trans-unit>
        <trans-unit id="0eb31cb3569ffcba88f7cd6f2aa1426af6d2ca9f" translate="yes">
          <source>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</source>
          <target>TypeScript2.1では、これらのファイルを別のモジュールに一度だけプロジェクトに含めることができ、コンパイラは必要に応じてインポートをそれらに発行する。</target>
        </trans-unit>
        <trans-unit id="4d20c0e4270450dc5df5d6df69b86f9a3084c753" translate="yes">
          <source>TypeScript 2.1 brings support for &lt;a href="https://github.com/sebmarkbage/ecmascript-rest-spread"&gt;ESnext Spread and Rest&lt;/a&gt;.</source>
          <target>TypeScript2.1は&lt;a href="https://github.com/sebmarkbage/ecmascript-rest-spread"&gt;ESnext Spread and Rest&lt;/a&gt;をサポートする。</target>
        </trans-unit>
        <trans-unit id="1a2602f6bc15b060152681aebb2deae22d1b7344" translate="yes">
          <source>TypeScript 2.1 supports inheriting configuration using &lt;code&gt;extends&lt;/code&gt;, where:</source>
          <target>TypeScript2.1では、&lt;code&gt;extends&lt;/code&gt;を使用した構成の継承をサポートしています。</target>
        </trans-unit>
        <trans-unit id="e46023b88cb014edcb72d5fe91dd5e9bb7df4962" translate="yes">
          <source>TypeScript 2.1 supports three new target values &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;.</source>
          <target>TypeScript2.1は3つの新しい目標値&lt;code&gt;--target ES2016&lt;/code&gt;,&lt;code&gt;--target ES2017&lt;/code&gt;,&lt;code&gt;--target ESNext&lt;/code&gt;をサポートする。</target>
        </trans-unit>
        <trans-unit id="9b933ffe70d107fc6bfc7a208af67d2175dec62d" translate="yes">
          <source>TypeScript 2.2</source>
          <target state="translated">TypeScript 2.2</target>
        </trans-unit>
        <trans-unit id="af11383d0a489a01508b14d16cfebecdac9851f5" translate="yes">
          <source>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins"&gt;MDN Mixin description&lt;/a&gt; and &lt;a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/"&gt;&amp;ldquo;Real&amp;rdquo; Mixins with JavaScript Classes&lt;/a&gt; for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</source>
          <target>TypeScript2.2では、ECMAScript2015ミックスインクラスパターン(詳細については、&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins"&gt;MDN Mixin description&lt;/a&gt;および&lt;a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/"&gt;&amp;ldquo;Real&amp;rdquo;Mixins with JavaScript Classes&lt;/a&gt;を参照)のサポート、および交差点タイプの通常の構成シグネチャとミックスイン構成シグネチャを結合するためのルールが追加されている。</target>
        </trans-unit>
        <trans-unit id="0a2dbbdfdaba8d57c906119c6fac6d8266bfac36" translate="yes">
          <source>TypeScript 2.2 adds support for using spread on a JSX element children. Please see &lt;a href="https://github.com/facebook/jsx/issues/57"&gt;facebook/jsx#57&lt;/a&gt; for more details.</source>
          <target>TypeScript2.2では、JSX要素の子でスプレッドを使用できるようになった。 詳細については、&lt;a href="https://github.com/facebook/jsx/issues/57"&gt;facebook/jsx#57&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c48aa745cc516094ac80f0eaa3816fe06bddfbf" translate="yes">
          <source>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</source>
          <target>TypeScript2.2では、式内のヌル可能なオペランドのチェックが改善されました。 具体的には、エラーとしてフラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="d38d07af3e985997222428fd513a69781f6cc8f7" translate="yes">
          <source>TypeScript 2.3</source>
          <target state="translated">TypeScript 2.3</target>
        </trans-unit>
        <trans-unit id="b61f4d2dcbfa7df846edf73961314986771cb44f" translate="yes">
          <source>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with &lt;code&gt;--downlevelIteration&lt;/code&gt; flag.</source>
          <target>TypeScript2.3では、ジェネレータの完全なサポートと、&lt;code&gt;--downlevelIteration&lt;/code&gt;フラグを持つES3およびES5ターゲットのIteratorプロトコルが追加された。</target>
        </trans-unit>
        <trans-unit id="c7db822200563cfa58805541c7f52f40509bd7eb" translate="yes">
          <source>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</source>
          <target>TypeScript2.3では、ジェネリック型パラメータのデフォルト宣言のサポートが追加された。</target>
        </trans-unit>
        <trans-unit id="576c3abf51df0a1e8501d6946731fd5b93e9a596" translate="yes">
          <source>TypeScript 2.3 adds support for the async iterators and generators as described by the current &lt;a href="https://github.com/tc39/proposal-async-iteration"&gt;TC39 proposal&lt;/a&gt;.</source>
          <target>TypeScript2.3は、現在の&lt;a href="https://github.com/tc39/proposal-async-iteration"&gt;TC39&lt;/a&gt;提案で説明されているように、非同期反復子とジェネレータのサポートを追加する。</target>
        </trans-unit>
        <trans-unit id="f9905a786ea9066024ac4028d0fd104e321fa970" translate="yes">
          <source>TypeScript 2.3 and later support type-checking and reporting errors in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target>TypeScript2.3以降では、&lt;code&gt;--checkJs&lt;/code&gt;を使用した&lt;code&gt;.js&lt;/code&gt;ファイルの型チェックとエラー報告をサポートしている。</target>
        </trans-unit>
        <trans-unit id="a711e374d74b34d98e80b0011ffc309914ec3f56" translate="yes">
          <source>TypeScript 2.4</source>
          <target state="translated">TypeScript 2.4</target>
        </trans-unit>
        <trans-unit id="63121e1a86e22e0c3bb62dbea7a515bd9e567278" translate="yes">
          <source>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</source>
          <target>TypeScript2.4では、ジェネリックの推定方法に関していくつかの素晴らしい変更を導入している。</target>
        </trans-unit>
        <trans-unit id="4047de971a7748310180f70bca2f83ce413444e5" translate="yes">
          <source>TypeScript 2.4 introduces the concept of &amp;ldquo;weak types&amp;rdquo;. Any type that contains nothing but a set of all-optional properties is considered to be &lt;em&gt;weak&lt;/em&gt;. For example, this &lt;code&gt;Options&lt;/code&gt; type is a weak type:</source>
          <target>TypeScript2.4には、&amp;ldquo;weak types&amp;rdquo;という概念が導入されています。 すべてのオプション・プロパティのセットのみを含むタイプは、&lt;em&gt;weak&lt;/em&gt;とみなされます。たとえば、この&lt;code&gt;Options&lt;/code&gt;タイプはweakタイプです。</target>
        </trans-unit>
        <trans-unit id="86b2369322c0e2cb12bd30f7af1523fb15f271df" translate="yes">
          <source>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</source>
          <target>TypeScript2.4では、2つのコールバックタイプを関連付けるときに、これを強化する。 例:</target>
        </trans-unit>
        <trans-unit id="76b70868a8ecce2623fa642627ea2865c40679ae" translate="yes">
          <source>TypeScript 2.4 now allows enum members to contain string initializers.</source>
          <target>TypeScript2.4では、enumメンバに文字列初期化子を含めることができるようになった。</target>
        </trans-unit>
        <trans-unit id="c757b8632386bce7302d5253a3fe5a403ad48f5b" translate="yes">
          <source>TypeScript 2.5</source>
          <target state="translated">TypeScript 2.5</target>
        </trans-unit>
        <trans-unit id="96d62a44f6ecea4f2d8ccb3d978b4697f85a8fe0" translate="yes">
          <source>TypeScript 2.5 brings the &lt;code&gt;preserveSymlinks&lt;/code&gt; flag, which parallels the behavior of &lt;a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks"&gt;the &lt;code&gt;--preserve-symlinks&lt;/code&gt; flag in Node.js&lt;/a&gt;. This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and vice-versa).</source>
          <target>TypeScript2.5は、&lt;code&gt;preserveSymlinks&lt;/code&gt;フラグをもたらします。これは、&lt;a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks"&gt;Node.jsの&lt;code&gt;-preserve symlinks&lt;/code&gt;フラグ&lt;/a&gt;の動作と同じです。このフラグは、Webpack&amp;rsquo;s&lt;code&gt;preserveSymlinks&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;に設定することと、Webpack&amp;rsquo;s&lt;code&gt;resolve.symlinks&lt;/code&gt;を&lt;code&gt;false&lt;/code&gt;に設定すること、およびその逆の動作も示します。</target>
        </trans-unit>
        <trans-unit id="c8ad58c085604fcd7c2e1f3468a3e3e991a926ce" translate="yes">
          <source>TypeScript 2.5 introduces the ability to &lt;a href="https://github.com/Microsoft/TypeScript/issues/5158"&gt;assert the type of expressions when using plain JavaScript in your projects&lt;/a&gt;. The syntax is an &lt;code&gt;/** @type {...} */&lt;/code&gt; annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:</source>
          <target>TypeScript2.5には、プロジェクトで単純なJavaScriptを使用するときに式の型を&lt;a href="https://github.com/Microsoft/TypeScript/issues/5158"&gt;アサートする機能が導入されています&lt;/a&gt;。構文は、&lt;code&gt;/**@type{.}*/&lt;/code&gt;注釈コメントの後に、型を再評価する必要がある括弧で括られた式が続きます。 例:</target>
        </trans-unit>
        <trans-unit id="669d038e7cc1925c80d686495e192a922f14d7e5" translate="yes">
          <source>TypeScript 2.6</source>
          <target state="translated">TypeScript 2.6</target>
        </trans-unit>
        <trans-unit id="f05ad28a2eccdd4292c999695e9643dff88f04a9" translate="yes">
          <source>TypeScript 2.6 adds revised implementation the &lt;code&gt;--noUnusedLocals&lt;/code&gt; and &lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href="../compiler-options"&gt;compiler options&lt;/a&gt;. Declarations are only written to but never read from are now flagged as unused.</source>
          <target>TypeScript2.6では、&lt;code&gt;--noUnusedLocals&lt;/code&gt;と&lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href="./compiler options"&gt;コンパイラオプション&lt;/a&gt;の改訂版が追加された。 宣言はにのみ書き込まれ、からは読み込まれないため、未使用としてフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="b3d5a37c18c460f27ef01973c59f69c2b7e4b6db" translate="yes">
          <source>TypeScript 2.6 also improves type inference involving contravariant positions:</source>
          <target>TypeScript2.6では、逆位を含む型推論も改善されている。</target>
        </trans-unit>
        <trans-unit id="597afbba7d51bc72adeb8bdd4361ee8ee1244087" translate="yes">
          <source>TypeScript 2.6 brings a faster &lt;code&gt;--watch&lt;/code&gt; implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in &lt;em&gt;only&lt;/em&gt; regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.</source>
          <target>TypeScript2.6はより高速な&lt;code&gt;--watch&lt;/code&gt;実装をもたらす。 新バージョンでは、ESモジュールを使ってコード生成とコードベースのチェックを最適化する。 モジュールファイルで変更が検出された場合、変更されたモジュールとそれに依存するファイルは、プロジェクト全体ではなく&lt;em&gt;のみ&lt;/em&gt;再生成されます。 ファイル数が多いプロジェクトでは、この変更によるメリットが最も大きくなります。</target>
        </trans-unit>
        <trans-unit id="bff2120308b7a70612c6347b0884825c125b9bb6" translate="yes">
          <source>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the &lt;a href="https://tc39.github.io/ecma262/#sec-gettemplateobject"&gt;ECMAScript spec&lt;/a&gt;, every time a template tag is evaluated, the &lt;em&gt;same&lt;/em&gt; template strings object (the same &lt;code&gt;TemplateStringsArray&lt;/code&gt;) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. &lt;a href="https://github.com/PolymerLabs/lit-html/issues/58"&gt;lit-html&lt;/a&gt;.</source>
          <target>TypeScript2.6は、タグ付き文字列テンプレートemitを修正し、ECMAScript仕様に合わせて調整する。 &lt;a href="https://tc39.github.io/ecma262/#sec-gettemplateobject"&gt;ECMAScript仕様&lt;/a&gt;に従って、テンプレートタグが評価されるたびに、&lt;em&gt;同じ&lt;/em&gt;テンプレート文字列オブジェクト(同じ&lt;code&gt;TemplateStringsArray&lt;/code&gt;)が最初の引数として渡される必要があります。 TypeScript2.6以前では、生成される出力は毎回まったく新しいテンプレートオブジェクトでした。 文字列の内容は同じですが、このemit関数は、キャッシュを無効にする目的で文字列のIDを使用するライブラリ、たとえば&lt;a href="https://github.com/PolymerLabs/lit-html/issues/58"&gt;lit html&lt;/a&gt;に影響します。</target>
        </trans-unit>
        <trans-unit id="3332e1f0228da76e93e5e699b31c42f80f487ec2" translate="yes">
          <source>TypeScript 2.6 introduces a new strict checking flag, &lt;code&gt;--strictFunctionTypes&lt;/code&gt;. The &lt;code&gt;--strictFunctionTypes&lt;/code&gt; switch is part of the &lt;code&gt;--strict&lt;/code&gt; family of switches, meaning that it defaults to on in &lt;code&gt;--strict&lt;/code&gt; mode. You can opt-out by setting &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; on your command line or in your tsconfig.json.</source>
          <target>TypeScript2.6では、新しい厳密なチェックフラグ&lt;code&gt;--strictFunctionTypes&lt;/code&gt;が導入されています。&lt;code&gt;--strictFunctionTypes&lt;/code&gt;スイッチは、&lt;code&gt;-strict&lt;/code&gt;スイッチファミリの一部であり、&lt;code&gt;-strict&lt;/code&gt;モードではデフォルトでオンになっています。 オプションとして、コマンドラインまたはtsconfig.jsonに&lt;code&gt;--strictFunctionTypes false&lt;/code&gt;を設定します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
