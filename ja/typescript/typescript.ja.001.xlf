<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target>&amp;copy;2012-2019Microsoft</target>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target>&amp;ldquo;Defaults declarations&amp;rdquo;は、論理和の左側で宣言された名前を参照する初期化子を許可します。</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target>&amp;ldquo;Do&amp;rdquo;sと&amp;ldquo;Don&amp;rdquo;s</target>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target>&amp;lsquo;classic&amp;rsquo;-1.6以前のTypeScriptコンパイラで使用されるモジュール解決ルール</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target>&amp;lsquo;ノード&amp;rsquo;-ノードに似たモジュール解決</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target>&amp;lsquo;package.json&amp;rsquo;には&amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;を参照する&lt;strong&gt;&amp;lsquo;タイプ&amp;rsquo;&lt;/strong&gt;フィールド&amp;lsquo;./lib/typescript.d.ts&amp;rsquo;があります。</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes">
          <source>(More) Recursive Type Aliases</source>
          <target>(詳細) 再帰タイプの別名</target>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target>*注:react JSX emit with&lt;code&gt;--jsxFactory&lt;/code&gt;オプション(デフォルトは&lt;code&gt;React.createElement&lt;/code&gt;)をターゲットにするときに使用するJSXファクトリ関数を指定できます。</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes">
          <source>1 - greeting: Mandatory string</source>
          <target>1-greeting:必須文字列</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target>2-duration:オプションの時間(ミリ秒)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target>3-色: オプションの文字列。例:&amp;lsquo;#ff00ff&amp;rsquo;</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes">
          <source>3.7 API Changes</source>
          <target>3.7APIの変更</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes">
          <source>3.7 Breaking Changes</source>
          <target>3.7変更の分割</target>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes">
          <source>&lt;a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier"&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target>&lt;a href="#theウシャドーフィネフォークロスフィールドスflag and the declare property modifier"&gt;前述のように&lt;/a&gt;、TypeScript3.7では&lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt;accessorが&lt;code&gt;.d.ts&lt;/code&gt;ファイルに出力されます。これにより、3.5以前のバージョンのTypeScriptでは、コンシューマに対して変更の中断が発生する可能性があります。 TypeScript3.6のユーザーは影響を受けない。</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes">
          <source>&lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects"&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target>&lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects"&gt;ES2015では、&lt;code&gt;Iterator&lt;/code&gt;インタフェースと&lt;code&gt;yield&lt;/code&gt;キーワードを使用して部分的な計算結果を得るために使用できる関数である、&amp;ldquo;Generator&amp;rdquo;&lt;/a&gt;も導入されました。 ジェネレータは、&lt;code&gt;yield*&lt;/code&gt;を使用して、呼び出しを内部的に別のiterableに委任することもできます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes">
          <source>&lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iteration"&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target>&lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iteration"&gt;ES2015で導入された&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;は、次のインターフェイスに従って、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;の3つのメソッドを公開するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes">
          <source>&lt;a href="https://facebook.github.io/jsx/"&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href="https://reactjs.org/"&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target>&lt;a href="https://facebook.github.io/jsx/"&gt;JSX&lt;/a&gt;は、埋め込み可能なXML形式の構文です。 有効なJavaScriptに変換されることを意図していますが、その変換のセマンティクスは実装固有です。 JSXは&lt;a href="https://reactjs.org/"&gt;React&lt;/a&gt;フレームワークで人気を博したが、その後他の実装も見られるようになった。 TypeScriptは、埋め込み、型チェック、JSXのJavaScriptへの直接コンパイルをサポートしている。</target>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes">
          <source>&lt;a href="https://github.com/microsoft/TypeScript/pull/33627"&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target>&lt;a href="https://github.com/microsoft/TypeScript/pull/33627"&gt;&lt;code&gt;lib.dom.d.ts&lt;/code&gt;の型が更新されました&lt;/a&gt;。これらの変更は、NULL値を使用できるかどうかに関連する正確性の変更ですが、影響は最終的にはコードベースによって異なります。</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes">
          <source>&lt;a href="https://github.com/umdjs/umd"&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target>&lt;a href="https://github.com/umdjs/umd"&gt;UMDモジュール&lt;/a&gt;は、モジュールローダー環境の存在をチェックします。 これは、次のような簡単なパターンです。</target>
        </trans-unit>
        <trans-unit id="0dc48f16354d32430f84152fcd0da39b3eb901cf" translate="yes">
          <source>&lt;amd-dependency /&gt;</source>
          <target state="translated">&lt;amd-dependency /&gt;</target>
        </trans-unit>
        <trans-unit id="f0a53f8a70ddac763fcd87262a3056238d4b67c8" translate="yes">
          <source>&lt;amd-module /&gt;</source>
          <target state="translated">&lt;amd-module /&gt;</target>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes">
          <source>&lt;b&gt;&lt;a href="#table-of-contents"&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href="#table-of-contents"&gt;トップに戻る&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes">
          <source>&lt;code&gt;"*"&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target>&lt;code&gt;"*"&lt;/code&gt;:同じ名前が変更されていないことを意味するため、map&lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt;=&amp;gt;&lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes">
          <source>&lt;code&gt;"generated/*"&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target>&lt;code&gt;"generated/*"&lt;/code&gt;は、モジュール名に&amp;ldquo;generated&amp;rdquo;が付加されたものを意味するため、map&lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt;=&amp;gt;&lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes">
          <source>&lt;code&gt;"noImplicitAny"&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;"compileOnSave"&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target>&lt;code&gt;「noImplicitAny」&lt;/code&gt;は、新しいコードを作成するときには常に有効です。型指定されていないコードを誤って作成しないようにしてください。 &lt;code&gt;"compileOnSave"&lt;/code&gt;を使用すると、実行中のWebアプリケーションでコードを簡単に更新できます。</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes">
          <source>&lt;code&gt;"rootDirs"&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target>&lt;code&gt;"rootDirs"&lt;/code&gt;は、実行時に内容がマージされる&lt;em&gt;ルート&lt;/em&gt;のリストを指定します。 この例では、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target>&lt;code&gt;**/&lt;/code&gt;は任意のサブディレクトリに再帰的にマッチします</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target>&lt;code&gt;*&lt;/code&gt;は0文字以上の文字に一致します(ディレクトリ区切り文字を除く)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target>&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;%&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;&lt;/code&gt;,&lt;code&gt;&lt;/code&gt;,&lt;code&gt;^&lt;/code&gt;オペランドとして列挙定数式を持つ2進演算子</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target>&lt;code&gt;--clean&lt;/code&gt;:指定したプロジェクトの出力を削除します(&lt;code&gt;--dry&lt;/code&gt;と組み合わせることができます)。</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target>&lt;code&gt;--宣言&lt;/code&gt;および&lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target>&lt;code&gt;--declarationDir&lt;/code&gt;を使用すると、JavaScriptファイルとは異なる場所に宣言ファイルを生成できます。</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target>&lt;code&gt;--dry&lt;/code&gt;:実際には何もビルドしないが実行される内容を表示します。</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt;では、宣言ファイルを生成する&lt;em&gt;だけが許可されます。&lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt;の出力生成は、このフラグによってスキップされます。 このフラグは、&lt;code&gt;.js&lt;/code&gt;の出力生成がBabelのような別のトランスパイラによって処理される場合に便利です。</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target>&lt;code&gt;--force&lt;/code&gt;:すべてのプロジェクトが古くなったように動作します。</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target>&lt;code&gt;--インクリメンタル&lt;/code&gt;の改善</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target>&lt;code&gt;--init&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target>&lt;code&gt;--inlineSourceMap&lt;/code&gt;および&lt;code&gt;inlineSources&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target>&lt;code&gt;--inlineSourceMap&lt;/code&gt;を指定すると、ソースマップファイルは、独立した&lt;code&gt;.js.map&lt;/code&gt;ファイルではなく、生成された&lt;code&gt;.js&lt;/code&gt;ファイルにインラインで書き込まれます。 &lt;code&gt;--inlineSources&lt;/code&gt;では、ソース&lt;code&gt;.ts&lt;/code&gt;ファイルを&lt;code&gt;.js&lt;/code&gt;ファイルにさらにインライン化できます。</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target>&lt;code&gt;--NewLine&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target>&lt;code&gt;--noEmitHelpers&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target>&lt;code&gt;--pretty&lt;/code&gt;出力(デフォルト)</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target>&lt;code&gt;--rootDir&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target>&lt;code&gt;--rootDir&lt;/code&gt;は、出力を計算する代わりに、出力にミラーリングする入力ディレクトリを指定します。</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;は、新しい完全NULLチェックモードに切り替わります。</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href="https://github.com/tc39/proposals"&gt;ES proposed features&lt;/a&gt;.</source>
          <target>&lt;code&gt;--target ESNext&lt;/code&gt;は、サポートされている最新の&lt;a href="https://github.com/tc39/proposals"&gt;ES提案機能&lt;/a&gt;を対象としています。</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target>&lt;code&gt;--traceResolution&lt;/code&gt;は、コンパイラによってモジュールがどのように解決されたかを理解する便利な方法を提供する。</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target>&lt;code&gt;--verbose&lt;/code&gt;:何が起こっているかを説明する冗長なログを出力します(他のフラグと組み合わせることもできます)。</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target>&lt;code&gt;--watch&lt;/code&gt;コンパイラの実装は、nodeによって提供される&lt;code&gt;fs.watch&lt;/code&gt;と&lt;code&gt;fs.watchFile&lt;/code&gt;に依存します。どちらのメソッドにも長所と短所があります。</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target>&lt;code&gt;--watch&lt;/code&gt;:ウォッチモード(&lt;code&gt;--verbose&lt;/code&gt;以外のフラグと組み合わせることはできない)</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target>&lt;code&gt;-noEmitOnError&lt;/code&gt;コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルを&lt;code&gt;tsc&lt;/code&gt;への入力として使用できるようになりました。TypeScriptコンパイラは、入力された&lt;code&gt;.js&lt;/code&gt;ファイルの構文エラーをチェックし、&lt;code&gt;--target&lt;/code&gt;および&lt;code&gt;--module&lt;/code&gt;フラグに基づいて有効な出力を生成します。 出力は、他の&lt;code&gt;.ts&lt;/code&gt;ファイルと組み合わせることもできます。 ソースマップは、&lt;code&gt;.ts&lt;/code&gt;ファイルと同様に&lt;code&gt;.js&lt;/code&gt;ファイルに対して生成されます。</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript"&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルは、標準のECMAScript機能のみが含まれていることを確認するためにチェックされます。型注釈は&lt;code&gt;.ts&lt;/code&gt;ファイルでのみ許可され、&lt;code&gt;.js&lt;/code&gt;ファイルではエラーとしてフラグが立てられます。 JSDocコメントは、JavaScriptコードに型情報を追加するために使用できます。サポートされているJSDoc構成体の詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript"&gt;JSDocサポート文書&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target>TypeScriptファイルの&lt;code&gt;//@ts nocheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path="x" /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target>&lt;code&gt;///&amp;lt;amd dependency path="x"/&amp;gt;&lt;/code&gt;は、結果のモジュールのrequire呼び出しに注入する必要がある非TSモジュールの依存関係についてコンパイラに通知する。</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path="x" /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target>&lt;code&gt;///&amp;lt;amd dependency path="x"/&amp;gt;&lt;/code&gt;は、結果のモジュールに注入する必要のあるTS以外のモジュールの依存関係についてコンパイラに通知します。&amp;rsquo;s require call;しかしながら、TSコードでこのモジュールを利用する方法はありませんでした。</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;reference lib="..." /&amp;gt;&lt;/code&gt; reference directives</source>
          <target>&lt;code&gt;///&amp;lt;reference lib="."/&amp;gt;&lt;/code&gt;reference directives</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target>&lt;code&gt;///&amp;lt;参照&amp;gt;&lt;/code&gt;-モジュール</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"main"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"main"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"types"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"types"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"main"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"main"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"types"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"types"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"types"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"types"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"main"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"main"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;"types"&lt;/code&gt; property)</source>
          <target>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt;(&lt;code&gt;"types"&lt;/code&gt;プロパティを指定する場合)</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target>&lt;code&gt;?&lt;/code&gt;は任意の1文字に一致します(ディレクトリ区切り文字を除く)。</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target>&lt;code&gt;@callback&lt;/code&gt;は&lt;code&gt;@typedef&lt;/code&gt;と似ていますが、オブジェクト型ではなく関数型を指定します。</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target>&lt;code&gt;@class&lt;/code&gt;(または&lt;code&gt;@constructor&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target>&lt;code&gt;@extends&lt;/code&gt;(または&lt;code&gt;@augments&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target>&lt;code&gt;@param&lt;/code&gt;(または&lt;code&gt;@arg&lt;/code&gt;または&lt;code&gt;@argument&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target>&lt;code&gt;@param&lt;/code&gt;では、oneoff型の指定に対して同様の構文を使用できます。 ネストされたプロパティ名の前には、パラメータの名前を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target>&lt;code&gt;@param&lt;/code&gt;および&lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target>&lt;code&gt;@param&lt;/code&gt;は、&lt;code&gt;@type&lt;/code&gt;と同じ型構文を使用しますが、パラメータ名を追加します。 このパラメータは、名前を角かっこで囲むことによってオプションとして宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target>&lt;code&gt;@returns&lt;/code&gt;(または&lt;code&gt;@return&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target>&lt;code&gt;@type&lt;/code&gt;では、ユニオンタイプを指定できます。たとえば、文字列またはブール値を指定できます。</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target>&lt;code&gt;@typedef&lt;/code&gt;は、複合型の定義に使用できます。 &lt;code&gt;@param&lt;/code&gt;と同様の構文が使用できます。</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target>&lt;code&gt;@typedef&lt;/code&gt;、&lt;code&gt;@callback&lt;/code&gt;、および&lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target>&lt;code&gt;@types&lt;/code&gt;、&lt;code&gt;typeRoots&lt;/code&gt;、&lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target>&lt;code&gt;AMD&lt;/code&gt;、&lt;code&gt;CommonJs&lt;/code&gt;、&lt;code&gt;UMD&lt;/code&gt;、&lt;code&gt;System&lt;/code&gt;、または&lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target>&lt;code&gt;CRLF&lt;/code&gt;または&lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target>&lt;code&gt;クラシック&lt;/code&gt;または&lt;code&gt;ノード&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target>&lt;code&gt;ES3&lt;/code&gt;、&lt;code&gt;ES5&lt;/code&gt;、または&lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target>&lt;code&gt;Exclude&amp;lt;T,U&amp;gt;&lt;/code&gt;&amp;ndash;Exclude from&lt;code&gt;T&lt;/code&gt;&lt;code&gt;U&lt;/code&gt;に割り当てられるタイプを除外する。</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target>&lt;code&gt;Extract&amp;lt;T,U&amp;gt;&lt;/code&gt;&amp;ndash;Extract from&lt;code&gt;T&lt;/code&gt;&lt;code&gt;U&lt;/code&gt;に割り当てられるタイプ。</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt;&amp;ndash;コンストラクタ関数型のインスタンス型を取得します。</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target>&lt;code&gt;MapToPromise&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型をとり、その型が&lt;code&gt;Coordinate&lt;/code&gt;のようなタプルである場合、数値プロパティのみが変換される。 &lt;code&gt;[number,number]&lt;/code&gt;には、&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の2つの数値で名前が付けられたプロパティがあります。このようなタプルが指定された場合、&lt;code&gt;MapToPromise&lt;/code&gt;は、&lt;code&gt;0&lt;/code&gt;および&lt;code&gt;1&lt;/code&gt;プロパティが元の型の&lt;code&gt;Promise&lt;/code&gt;である新しいタプルを作成します。 したがって、結果のタイプ&lt;code&gt;PromiseCoordinate&lt;/code&gt;は、タイプ&lt;code&gt;[Promise&amp;lt;number&amp;gt;,Promise&amp;lt;number&amp;gt;]&lt;/code&gt;になります。</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;:ツールのみ(&lt;code&gt;tsc.exe&lt;/code&gt;、&lt;code&gt;lib.d.ts&lt;/code&gt;など)。</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:前述のツール、およびMSBuildタスクとターゲット(&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;、&lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;など)</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;を&lt;code&gt;T&lt;/code&gt;から除外する。</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target>&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target>JavaScriptでの&lt;code&gt;Object.defineProperty&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target>前述の&lt;code&gt;Partial&lt;/code&gt;と&lt;code&gt;Readonly&lt;/code&gt;は、非常に有用な構成体です。 次のような一般的なJSルーチンを記述するために使用できます。</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target>&lt;code&gt;Partial&lt;/code&gt;、&lt;code&gt;Readonly&lt;/code&gt;、&lt;code&gt;Record&lt;/code&gt;、&lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target>&lt;code&gt;Readonly&lt;/code&gt;、&lt;code&gt;Partial&lt;/code&gt;、&lt;code&gt;Pick&lt;/code&gt;は準同形ですが、&lt;code&gt;Record&lt;/code&gt;は準同形ではありません。 &lt;code&gt;Record&lt;/code&gt;が準同型でないことを示す1つの手がかりは、次のものからプロパティをコピーするために入力タイプを取らないことである。</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt;&amp;ndash;関数型の戻り型を取得します。</target>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target>&lt;code&gt;abstract&lt;/code&gt;クラスとメソッド</target>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target>&lt;code&gt;any&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、および&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target>&lt;code&gt;assert&lt;/code&gt;condition&lt;/code&gt;は、&lt;code&gt;assert&lt;/code&gt;から返された場合、&lt;code&gt;condition&lt;/code&gt;パラメータに渡されたものはすべてtrueでなければならないことを示しています(そうでない場合はエラーがスローされます)。 つまり、残りの範囲では、その条件はトルトーでなければならないということです。 例として、このアサーション関数を使用すると、元の&lt;code&gt;yell&lt;/code&gt;例を&lt;em&gt;do&lt;/em&gt;がキャッチされます。</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target>ES6ターゲット(ノードv4+)での&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;サポート</target>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target>&lt;code&gt;compose&lt;/code&gt;は、他に2つの関数を取ります。</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target>&lt;code&gt;compose&lt;/code&gt;は、&lt;code&gt;f&lt;/code&gt;、&lt;code&gt;g&lt;/code&gt;の順に引数を与える関数を返す。</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target>&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target>&lt;code&gt;const enum&lt;/code&gt;(完全にインライン化されたenum)</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target>&lt;code&gt;const&lt;/code&gt;アサーション</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target>&lt;code&gt;const&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target>&lt;code&gt;const&lt;/code&gt;宣言は、変数を宣言するもう1つの方法です。</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target>&lt;code&gt;const&lt;/code&gt;enum</target>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target>&lt;code&gt;const&lt;/code&gt;は、ECMAScript6(&lt;code&gt;--target ES6&lt;/code&gt;)をターゲットにしている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target>&lt;code&gt;宣言&lt;/code&gt;をオンにする必要があります</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target>&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target>&lt;code&gt;default&lt;/code&gt;のエクスポートは非常に便利です。 たとえば、jQueryのようなライブラリには、デフォルトで&lt;code&gt;jQuery&lt;/code&gt;または&lt;code&gt;$&lt;/code&gt;のエクスポートがあり、おそらく&lt;code&gt;$&lt;/code&gt;または&lt;code&gt;jQuery&lt;/code&gt;という名前でインポートされる。</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target>&lt;code&gt;default&lt;/code&gt;exportsには、次の値も指定できます。</target>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target>tsconfig.jsonでの&lt;code&gt;exclude&lt;/code&gt;プロパティのサポート</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target>&lt;code&gt;export*&lt;/code&gt;は、別のモジュールのすべてのエクスポートを再エクスポートするために使用できます。 これは、他の複数のモジュールのエクスポートを集約するモジュールを作成する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target>&lt;code&gt;export=&lt;/code&gt;および&lt;code&gt;import=require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target>&lt;code&gt;extends&lt;/code&gt;は、&lt;code&gt;tsconfig.json&lt;/code&gt;の新しい最上位プロパティです(&lt;code&gt;compilerOptions&lt;/code&gt;、&lt;code&gt;files&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;、および&lt;code&gt;exclude&lt;/code&gt;と並んで)。</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target>&lt;code&gt;f&lt;/code&gt;:引数(&lt;code&gt;A&lt;/code&gt;型)を受け取り、&lt;code&gt;B&lt;/code&gt;型の値を返す</target>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target>&lt;code&gt;files&lt;/code&gt;,&lt;code&gt;include&lt;/code&gt;,&lt;code&gt;exclude&lt;/code&gt;を継承構成ファイルから&lt;em&gt;上書き&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target>&lt;code&gt;for.of&lt;/code&gt;は、オブジェクト上の&lt;code&gt;Symbol.iterator&lt;/code&gt;プロパティを呼び出して、オブジェクトをループします。 次に、アレイ上の&lt;/code&gt;ループの単純な&lt;code&gt;を示します。</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target>&lt;code&gt;for.of&lt;/code&gt;ステートメント</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target>&lt;code&gt;for.of&lt;/code&gt;ステートメント、Array Destructuring、およびArray、Call、およびNew式のSpread要素は、&lt;code&gt;--downlevelIteration&lt;/code&gt;を使用するときに使用可能な場合、ES5/E3で&lt;code&gt;Symbol.iterator&lt;/code&gt;をサポートしますが、実行時または設計時に&lt;code&gt;Symbol.iterator&lt;/code&gt;を定義していない場合でも、Arrayで使用できます。</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target>&lt;code&gt;for.of&lt;/code&gt;と&lt;code&gt;for.in&lt;/code&gt;ステートメント</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target>&lt;code&gt;fs.watch&lt;/code&gt;は、ファイルシステムのイベントを使用して、ファイル/ディレクトリの変更を通知します。 しかし、これはOSに依存しており、通知は完全に信頼できるものではなく、多くのOSで期待どおりに動作しない。 また、例えばlinuxのように、作成できる時計の数に制限がある場合もありますし、大量のファイルを含むプログラムでは、すぐに使い果たしてしまうかもしれません。 ただし、これはファイル・システム・イベントを使用するため、CPUサイクルはそれほど必要ありません。 コンパイラは通常、&lt;code&gt;fs.watch&lt;/code&gt;を使用してディレクトリを監視する(例:configファイルに含まれるソースディレクトリ、モジュールの解決に失敗したディレクトリ) これらは、変更を通知する際の精度の不足を処理できます。 ただし、再帰的な監視はWindowsとOSXでのみサポートされています。 つまり、他のOSの再帰的な性質を置き換えるものが必要なのです。</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target>&lt;code&gt;fs.watchFile&lt;/code&gt;はポーリングを使用するため、CPUサイクルを消費します。 しかし、これはファイル/ディレクトリーの状況を更新するための最も信頼できるメカニズムです。 コンパイラは通常、&lt;code&gt;fs.watchFile&lt;/code&gt;を使用して、ソースファイル、設定ファイル、および見つからないファイル(ファイル参照が見つからない)を監視します。これは、CPU使用率がプログラム内のファイル数に依存することを意味します。</target>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target>&lt;code&gt;g&lt;/code&gt;:&lt;code&gt;B&lt;/code&gt;型の引数(&lt;code&gt;f&lt;/code&gt;が返す型)を取り、&lt;code&gt;C&lt;/code&gt;型の値を返す</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target>&lt;code&gt;get&lt;/code&gt;および&lt;code&gt;set&lt;/code&gt;アクセサは環境コンテキストで許可される</target>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target>&lt;code&gt;import.meta&lt;/code&gt;SystemJSでのサポート</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target>&lt;code&gt;import.meta&lt;/code&gt;は、&lt;code&gt;ESNext&lt;/code&gt;モジュールおよびECMAScriptターゲットをターゲットにしている場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target>&lt;code&gt;import&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target>&lt;code&gt;instanceof&lt;/code&gt;型ガード</target>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target>&lt;code&gt;keyof Car&lt;/code&gt;は、&lt;code&gt;'manufacturer'model''year'&lt;/code&gt;と完全に互換性があります。&lt;code&gt;Car&lt;/code&gt;に別のプロパティを追加すると、たとえば&lt;code&gt;ownersAddress:string&lt;/code&gt;と指定すると、&lt;code&gt;keyof Car&lt;/code&gt;は自動的に&lt;code&gt;'manufacturer'model'year'ownersAddress'&lt;/code&gt;に更新されます。また、&lt;code&gt;pluck&lt;/code&gt;のような一般的なコンテキストで&lt;/code&gt;の&lt;code&gt;keyof&lt;/code&gt;を使用すると、プロパティ名を事前に知ることができます。 つまり、コンパイラは正しいプロパティ名のセットを渡して&lt;code&gt;pluck&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target>&lt;code&gt;keyof X&lt;/code&gt;は、文字列型、数値型、およびシンボル型のプロパティを表すリテラル型の集合です。</target>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target>&lt;code&gt;keyof&lt;/code&gt;と&lt;code&gt;T[K]&lt;/code&gt;はインデックスシグネチャと相互作用する。 インデックスシグネチャパラメータタイプは&amp;lsquo;string&amp;rsquo;または&amp;lsquo;number&amp;rsquo;でなければなりません。 文字列インデックスシグネチャを持つ型の場合、&lt;code&gt;keyof T&lt;/code&gt;は&lt;code&gt;string number&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;だけではない。JavaScriptでは、文字列(&lt;code&gt;object['42'&lt;/code&gt;])または数値(&lt;code&gt;object[42]&lt;/code&gt;)を使用してオブジェクトプロパティにアクセスできるからである。 &lt;code&gt;T[string]&lt;/code&gt;はインデックスシグネチャの型です。</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target>&lt;code&gt;keyof&lt;/code&gt;と参照タイプ</target>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href="basic-types#a-note-about-let"&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target>&lt;code&gt;let&lt;/code&gt;と&lt;code&gt;const&lt;/code&gt;は、JavaScriptの変数宣言の比較的新しい2つのタイプです。 &lt;a href="basic types#a note about let"&gt;&lt;/a&gt;で説明したように、&lt;code&gt;let&lt;/code&gt;はいくつかの点で&lt;code&gt;var&lt;/code&gt;と似ていますが、ユーザーがJavaScriptで遭遇する一般的な&amp;ldquo;gotcha&amp;rdquo;の一部を回避できます。 &lt;code&gt;const&lt;/code&gt;は、変数への再割り当てを防ぐという点で、&lt;code&gt;let&lt;/code&gt;を拡張したものです。</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target>&lt;code&gt;let&lt;/code&gt;および&lt;code&gt;const&lt;/code&gt;がサポートする</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target>&lt;code&gt;let&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target>&lt;code&gt;let&lt;/code&gt;宣言は、ループの一部として宣言された場合には、動作が大幅に異なります。 これらの宣言では、ループ自体に新しい環境を導入するだけではなく、反復ごとに新しいスコープ&lt;em&gt;&lt;/em&gt;を作成します。 これはIIFEで行っていたことなので、古い&lt;code&gt;setTimeout&lt;/code&gt;の例を&lt;code&gt;let&lt;/code&gt;宣言を使うように変更できます。</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target>&lt;code&gt;let&lt;/code&gt;は、ECMAScript6(&lt;code&gt;--target ES6&lt;/code&gt;)をターゲットにしている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target>&lt;code&gt;let&lt;/code&gt;vs.&lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target>&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;const&lt;/code&gt;、および&lt;code&gt;var&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes">
          <source>&lt;code&gt;module === "system"&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target>&lt;code&gt;module==="system"&lt;/code&gt;または&lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target>&lt;code&gt;namespace&lt;/code&gt;キーワード</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target>&lt;code&gt;never&lt;/code&gt;は、のサブタイプであり、すべてのタイプに割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target>&lt;code&gt;new.target&lt;/code&gt;は、次のような構成可能な関数を記述する場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target>&lt;code&gt;new.target&lt;/code&gt;は、&lt;code&gt;Object.setPrototypeOf&lt;/code&gt;または&lt;code&gt;_proto__&lt;/code&gt;をクラスコンストラクタで設定する必要がある場合に便利です。 そのようなユースケースの一つは、NodeJS v4以降の&lt;code&gt;Error&lt;/code&gt;からの継承です。</target>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;これは、&lt;code&gt;switch&lt;/code&gt;ブロックの&lt;code&gt;case&lt;/code&gt;間に&lt;code&gt;break&lt;/code&gt;ステートメントがあることを忘れたくない場合に便利です。</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target>&lt;code&gt;noImplicitAny&lt;/code&gt;:暗黙の&lt;code&gt;any&lt;/code&gt;型を持つ式と宣言でエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target>&lt;code&gt;noImplicitReturns&lt;/code&gt;関数の最後に戻るのを忘れないようにする。</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target>&lt;code&gt;object&lt;/code&gt;は、非プリミティブ型を表す型である。すなわち、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;bigint&lt;/code&gt;、&lt;code&gt;symbol&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、または&lt;code&gt;undefined&lt;/code&gt;でない型である。</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target>&lt;code&gt;object&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target>&lt;code&gt;onEmitOnError&lt;/code&gt;:エラーが報告されても出力を行わない。</target>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target>この例では、&lt;code&gt;petはFish&lt;/code&gt;です。 述語は、&lt;code&gt;parameterName is Type&lt;/code&gt;という形式をとります。&lt;code&gt;parameterName&lt;/code&gt;は、現在の関数シグネチャのパラメータ名である必要があります。</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target>&lt;code&gt;prepend&lt;/code&gt;with&lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target>&lt;code&gt;react&lt;/code&gt;,&lt;code&gt;react-native&lt;/code&gt;,&lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target>&lt;code&gt;readonly&lt;/code&gt;マップされた型修飾子と&lt;code&gt;readonly&lt;/code&gt;配列</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target>&lt;code&gt;readonly&lt;/code&gt;タプル</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target>&lt;code&gt;readonly&lt;/code&gt;vs&lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target>&lt;code&gt;sourceMap&lt;/code&gt;:対応する&lt;code&gt;.map&lt;/code&gt;ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target>&lt;code&gt;strictNullChecks&lt;/code&gt;は無効です</target>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target>&lt;code&gt;symbol&lt;/code&gt;値は、&lt;code&gt;Symbol&lt;/code&gt;コンストラクタを呼び出すことによって作成されます。</target>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target>&lt;code&gt;target&lt;/code&gt;:ECMAScriptターゲット・バージョンを指定します。</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target>&lt;code&gt;this is T&lt;/code&gt;は、クラスおよびインタフェースのメソッドに対して有効な戻り型注釈です。 型ナロウィング位置(例えば&lt;code&gt;if&lt;/code&gt;ステートメント)で使用される場合、呼び出し式ターゲットオブジェクトの型は&lt;code&gt;T&lt;/code&gt;に狭められる。</target>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target>&lt;code&gt;this:void&lt;/code&gt;は、&lt;code&gt;addClickListener&lt;/code&gt;が&lt;code&gt;onclick&lt;/code&gt;を&lt;code&gt;this&lt;/code&gt;型を必要としない関数であると想定していることを意味します。</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target>&lt;code&gt;this:void&lt;/code&gt;は、&lt;code&gt;addClickListener&lt;/code&gt;が&lt;code&gt;onclick&lt;/code&gt;を&lt;code&gt;this&lt;/code&gt;型を必要としない関数であると想定していることを意味します。 2番目に、呼び出しコードに&lt;code&gt;this&lt;/code&gt;で注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target>&lt;code&gt;この&lt;/code&gt;および矢印関数</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target>&lt;code&gt;この&lt;/code&gt;パラメータ</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target>コールバックの&lt;code&gt;this&lt;/code&gt;パラメータ</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target>&lt;code&gt;この&lt;/code&gt;ベースのタイプガード</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target>&lt;code&gt;this&lt;/code&gt;-入力</target>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target>&lt;code&gt;composite&lt;/code&gt;がオンの場合は&lt;code&gt;true&lt;/code&gt;、それ以外の場合は&lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target>別のプログラムにパイプしたり、出力をファイルにリダイレクトしたりしない限り、&lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target>&lt;code&gt;tsc-b&lt;/code&gt;コマンドライン</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target>&lt;code&gt;tsc-w&lt;/code&gt;は、複数の構成ファイルで同時に実行できない</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target>&lt;code&gt;tsc&lt;/code&gt;は、このプロセスを実行するためにディスク上の既存のファイルのみを使用します。そのため、一部のプロジェクトの出力が結果ファイルに複数回存在するため、正しい出力ファイルを生成できないプロジェクトを作成できます。 例:</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target>TypeScriptコンパイラである&lt;code&gt;tsc&lt;/code&gt;は、&lt;code&gt;-showConfig&lt;/code&gt;という新しいフラグをサポートしている。&lt;code&gt;tsc-showConfig&lt;/code&gt;を実行すると、TypeScriptは(&lt;code&gt;extends&lt;/code&gt;フィールドから継承されたオプションを計算した後で)有効な&lt;code&gt;tsconfig.json&lt;/code&gt;を計算し、それを出力する。 これは、一般的に構成の問題を診断する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルには、&lt;code&gt;references&lt;/code&gt;という新しい最上位プロパティがあります。参照するプロジェクトを指定するオブジェクトの配列です。</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;Node.jsパッケージによる継承</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;は、フォルダを&amp;ldquo;プロジェクト&amp;rdquo;に変換します。 &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;または&lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;エントリを指定しないと、&lt;code&gt;tsconfig.json&lt;/code&gt;とそのすべてのサブディレクトリを含むフォルダ内のすべてのファイルがコンパイルに含まれます。 一部のファイルを除外するには、&lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;を使用します。コンパイラにファイルを参照させるのではなく、すべてのファイルを指定する場合は、&lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target>&lt;code&gt;tsconfig.ノストリクトヌル.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target>&lt;code&gt;typeof&lt;/code&gt;型ガード</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target>&lt;code&gt;typesVersions&lt;/code&gt;は、複数のフィールドをサポートできます。各フィールド名は、照合する範囲で指定します。</target>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target>&lt;code&gt;var&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target>&lt;code&gt;var&lt;/code&gt;宣言には、他の言語で使用されるものに対して奇妙なスコープルールがあります。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target>&lt;code&gt;void&lt;/code&gt;は、&lt;code&gt;any&lt;/code&gt;とは逆に、型を持たないという意味です。 これは一般に、値を返さない関数の戻り型とみなされることがあります。</target>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target>&lt;code&gt;y&lt;/code&gt;は、&lt;code&gt;any&lt;/code&gt;型を持つことになります。これは、プログラムが型チェックを行うことを意味しますが、技術的には、次のように&lt;code&gt;y&lt;/code&gt;を使って何かを行うことができます。</target>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target>&lt;em&gt;(共通ルート・ディレクトリは入力ファイルのリストから計算されます)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target>&lt;em&gt;(プラットフォーム固有)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt;型ガード&lt;/em&gt;は、コンストラクタ関数を使用して型を絞り込む方法です。 たとえば、&amp;rsquo;sは先ほどの工業用ストリングパッドの例を借用します。</target>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target>&lt;em&gt;任意のコンパイラオプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target>&lt;em&gt;クラス・デコレータ&lt;/em&gt;がクラスに適用されます。</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target>&lt;em&gt;コード&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target>&lt;em&gt;TypeScriptコンパイラを構成する&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target>&lt;em&gt;宣言&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target>宣言ファイルをパッケージ化しない場合は、npmタイプ宣言パッケージに依存しないでください。&lt;em&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target>&lt;em&gt;並べ替えを実行する&lt;/em&gt;:特定の署名の後に、より一般的な署名を追加してオーバーロードをソートします。</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types="..." /&amp;gt;&lt;/code&gt; instead.</source>
          <target>&lt;em&gt;代わりに&lt;code&gt;///&amp;lt;reference types="."/&amp;gt;&lt;/code&gt;を使用してください。&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target>&lt;em&gt;Do&lt;/em&gt;は、可能な限りオプションのパラメータを使用します。</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target>&lt;em&gt;値が無視されるコールバックには、&lt;/em&gt;戻り値の型&lt;code&gt;void&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target>&lt;em&gt;Do&lt;/em&gt;:&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、および&lt;code&gt;symbol&lt;/code&gt;の型を使用します。</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target>&lt;em&gt;可能な限りユニオン型を使用する&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target>&lt;em&gt;Do&lt;/em&gt;:最大アリティを使用して単一のオーバーロードを記述します。</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target>&lt;em&gt;Do&lt;/em&gt;:コールバック・パラメータを非オプションとして書き込みます。</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target>&lt;em&gt;ドキュメント&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target>&lt;em&gt;お客様のファイルと組み合わせて&lt;/em&gt;、それぞれのファイルに保存してください。</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target>パッケージ内の宣言もコピーしないでください。&lt;em&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---"&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target>&lt;em&gt;タイプパラメータを使用しない汎用タイプはありません。詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---"&gt;TypeScript FAQページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt;は、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;、または&lt;code&gt;Object&lt;/code&gt;型を使用します。これらの型は、JavaScriptコードではほとんど適切に使用されない、プリミティブではないボックス・オブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target>&lt;em&gt;より具体的なオーバーロードの前に、より一般的なオーバーロードを配置しない&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path="..." /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target>&lt;em&gt;宣言ファイルで&lt;code&gt;///&amp;lt;reference path="."/&amp;gt;&lt;/code&gt;を使用しないでください。&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target>&lt;em&gt;コールバックでオプションのパラメータを使用しないでください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target>&lt;em&gt;値が無視されるコールバックには、&lt;/em&gt;戻り値の型&lt;code&gt;any&lt;/code&gt;を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target>&lt;em&gt;タイプごとに異なるオーバーロードを1つの引数位置にのみ記述しない&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target>&lt;em&gt;コールバックアリティのみが異なる別個のオーバーロードを作成しない&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target>&lt;em&gt;後続パラメータのみが異なる複数のオーバーロードを記述しない&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target>&lt;em&gt;まず、ES2016の用語について説明します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target>&lt;em&gt;グローバル・プラグイン&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target>&lt;em&gt;モジュールのグローバル変更&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target>&lt;em&gt;MSBuild専用オプション&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target>&lt;em&gt;モジュール・プラグイン&lt;/em&gt;または&lt;em&gt;UMDプラグイン&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from "moduleA"&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target>&lt;em&gt;モジュール解決&lt;/em&gt;は、インポートが何を参照しているかを判断するためにコンパイラが使用するプロセスです。 &lt;code&gt;import{a}from"moduleA"&lt;/code&gt;;のようなimport文を考えてみてください。&lt;code&gt;a&lt;/code&gt;の使用をチェックするには、コンパイラはそれが何を表しているかを正確に知る必要があり、その定義&lt;code&gt;moduleA&lt;/code&gt;をチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target>&lt;em&gt;MSBuildではサポートされていません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target>&lt;em&gt;注意:現在、ジスパムのTypeScriptサポートは0.16ベータ版です&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target>&lt;em&gt;パラメータ修飾子&lt;/em&gt;がコンストラクタに適用されます。</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target>各インスタンス・メンバーには、&lt;em&gt;パラメータ・デコレータ&lt;/em&gt;、&lt;em&gt;メソッド&lt;/em&gt;、&lt;em&gt;アクセサ&lt;/em&gt;、または&lt;em&gt;プロパティ・デコレータ&lt;/em&gt;が適用されます。</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target>&lt;em&gt;パラメータ・デコレータ&lt;/em&gt;、&lt;em&gt;メソッド&lt;/em&gt;、&lt;em&gt;アクセサ&lt;/em&gt;、または&lt;em&gt;プロパティ・デコレータ&lt;/em&gt;が各静的メンバーに適用されます。</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target>&lt;em&gt;レストパラメータ&lt;/em&gt;は、無限の数のオプションパラメータとして扱われます。 restパラメータに引数を渡す場合は、必要な数だけ引数を使用できます。何も渡すことはできません。 コンパイラは、渡された引数の配列を、省略記号(&lt;code&gt;.&lt;/code&gt;)の後に指定された名前で構築し、関数で使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target>&lt;em&gt;NPMをセットアップする&lt;/em&gt;#</target>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target>&lt;em&gt;glpを設定する&lt;/em&gt;#</target>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target>&lt;em&gt;型アサーション&lt;/em&gt;は、コンパイラに&amp;ldquo;trust me,I know what I doing.&amp;rdquo;を伝える方法です。型アサーションは、他の言語でキャストされた型と似ていますが、データの特別なチェックや再構築は行いません。 ランタイムへの影響はなく、純粋にコンパイラによって使用されます。 TypeScriptは、プログラマーであるあなたが必要な特別なチェックを行ったことを前提としています。</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target>&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target>&lt;em&gt;理由&lt;/em&gt;: コールバックがパラメータを無視することは常に許されるので、より短いオーバーロードは不要です。 短いコールバックを提供すると、最初のオーバーロードと一致するため、誤って入力された関数が渡されます。</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target>&lt;em&gt;理由&lt;/em&gt;: これは、&amp;ldquo;passing through&amp;rdquo;a value to your function:</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target>&lt;em&gt;理由&lt;/em&gt;: これは2つの理由から重要です。</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target>&lt;em&gt;その理由&lt;/em&gt;:関数呼び出しを解決するときに、&lt;em&gt;最初に一致するオーバーロード&lt;/em&gt;をTypeScriptが選択します。 以前のオーバーロードが後のオーバーロードよりも&amp;ldquo;より一般的&amp;rdquo;である場合、後のオーバーロードは事実上非表示になり、呼び出すことができません。</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target>&lt;em&gt;理由&lt;/em&gt;: &lt;code&gt;void&lt;/code&gt;を使用すると、&lt;code&gt;x&lt;/code&gt;の戻り値をチェックされていない方法で誤って使用することを防止できるため、より安全です。</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target>&lt;em&gt;自動&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7faca3a82509c33a07036d3cb1d05d4597451134" translate="yes">
          <source>&lt;reference lib="..." /&gt;</source>
          <target>&lt;reference lib="."/&gt;</target>
        </trans-unit>
        <trans-unit id="bd10d54a1629943bbc005d93a244ef91799d2db3" translate="yes">
          <source>&lt;reference no-default-lib="true"/&gt;</source>
          <target>&lt;reference nodefaultlib="true"/&gt;</target>
        </trans-unit>
        <trans-unit id="6f2a0d7f50932d9605f33af5f202acae6d8023d1" translate="yes">
          <source>&lt;reference path="..." /&gt;</source>
          <target state="translated">&lt;reference path="..." /&gt;</target>
        </trans-unit>
        <trans-unit id="e3b72ced05cde876d8719c81f9105a261d04984a" translate="yes">
          <source>&lt;reference types="..." /&gt;</source>
          <target state="translated">&lt;reference types="..." /&gt;</target>
        </trans-unit>
        <trans-unit id="0dceac607b0e0dff2935b3a3c7eb8893cf215a13" translate="yes">
          <source>&lt;reference&gt;-ing a module</source>
          <target state="translated">&lt;reference&gt;-ing a module</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href="http://www.ecma-international.org/ecma-262/6.0/"&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target>&lt;strong&gt;用語に関する注意:&lt;/strong&gt;TypeScript1.5では用語が変更されたことに注意してください。 &amp;ldquo;内部モジュール&amp;rdquo;は現在&amp;ldquo;名前空間&amp;rdquo;です。 &amp;ldquo;External modules&amp;rdquo;は、&lt;a href="http://www.ecma-international.org/ecma-262/6.0/"&gt;ECMAScript2015&lt;/a&gt;&amp;rsquo;の用語に合わせて、単に&amp;ldquo;modules&amp;rdquo;になりました(つまり、&lt;code&gt;module X{&lt;/code&gt;は、現在推奨されている&lt;code&gt;namespace X{&lt;/code&gt;と同じです)。</target>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target>&lt;strong&gt;の後&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target>&lt;strong&gt;前&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target>&lt;strong&gt;コマンドライン&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import "moduleName";&lt;/code&gt; statements instead.</source>
          <target>&lt;strong&gt;注意&lt;/strong&gt;:このディレクティブは廃止されました。 代わりに&lt;code&gt;import"moduleName";&lt;/code&gt;ステートメントを使用してください。</target>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target>&lt;strong&gt;使用法&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes">
          <source>&lt;sup id="ts-3-1-only-homomorphic"&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target>&lt;sup id="ts-3-1-only homomorphic"&gt;[1]&lt;/sup&gt;より具体的には、上記のような準同形写像型です。</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target>&lt;sup&gt;[1]&lt;/sup&gt;これらのオプションは実験的です。</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target>&lt;sup&gt;[2]&lt;/sup&gt;これらのオプションは&lt;code&gt;tsconfig.json&lt;/code&gt;でのみ使用でき、コマンドラインスイッチでは使用できません。</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target>==========モジュール名&amp;lsquo;typescript&amp;rsquo;は&amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;に&lt;strong&gt;正常に解決されました&lt;/strong&gt;。========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target>=========&lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;からモジュール&lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt;を解決しています。==========</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes">
          <source>@param and @returns</source>
          <target state="translated">@param and @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target>&amp;ldquo;bare import&amp;rdquo;を使用してモジュールをインポートできるのは、モジュールの副次的な影響だけです。</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target>&lt;code&gt;//@ts ignore&lt;/code&gt;コメントは、次の行で発生するすべてのエラーを抑制します。 &lt;code&gt;@ts ignore&lt;/code&gt;に続くコメントの残りの部分に、どのエラーが抑制されているかを説明することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target>&lt;code&gt;クラス&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target>&lt;code&gt;関数&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target>&lt;code&gt;namespace&lt;/code&gt;宣言を使用すると、競合が発生しない方法で、新しい型、値、および名前空間を追加できます。</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target>値を含む&lt;code&gt;namespace&lt;/code&gt;または&lt;code&gt;module&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは、&lt;code&gt;extends&lt;/code&gt;プロパティを使用して、別のファイルから設定を継承できます。</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは完全に空にすることができ、デフォルトで含まれるすべてのファイルをデフォルトのコンパイラオプションでコンパイルする。</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target>&lt;em&gt;Class Decorator&lt;/em&gt;は、クラス宣言の直前に宣言されます。 クラスデコレータは、クラスのコンストラクタに適用され、クラス定義の観察、変更、または置換に使用できます。 クラス・デコレータは、宣言ファイルやその他の環境コンテキスト(&lt;code&gt;declare&lt;/code&gt;クラスなど)では使用できません。</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href="#class-decorators"&gt;class declaration&lt;/a&gt;, &lt;a href="#method-decorators"&gt;method&lt;/a&gt;, &lt;a href="#accessor-decorators"&gt;accessor&lt;/a&gt;, &lt;a href="#property-decorators"&gt;property&lt;/a&gt;, or &lt;a href="#parameter-decorators"&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target>&lt;em&gt;Decorator&lt;/em&gt;は、&lt;a href="#class decorators"&gt;クラス宣言&lt;/a&gt;、&lt;a href="#method decorators"&gt;メソッド&lt;/a&gt;、&lt;a href="#accessor decorators"&gt;accessor&lt;/a&gt;、&lt;a href="#property decorators"&gt;プロパティ&lt;/a&gt;、または&lt;a href="#parameter decorators"&gt;パラメータ&lt;/a&gt;に付加できる特別な種類の宣言です。 デコレータは、&lt;code&gt;@expression&lt;/code&gt;という形式を使用します。&lt;code&gt;expression&lt;/code&gt;は、装飾された宣言に関する情報とともに実行時に呼び出される関数に評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target>&lt;em&gt;Method Decorator&lt;/em&gt;は、メソッド宣言の直前に宣言されます。 デコレータは、メソッドの&lt;em&gt;プロパティ記述子&lt;/em&gt;に適用され、メソッド定義の監視、変更、または置換に使用できます。 メソッド修飾子は、宣言ファイル、オーバーロード、その他の環境コンテキスト(&lt;code&gt;declare&lt;/code&gt;クラスなど)では使用できません。</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target>&lt;em&gt;パラメータ・デコレータ&lt;/em&gt;は、パラメータ宣言の直前に宣言されます。 パラメータ・デコレータは、クラス・コンストラクタまたはメソッド宣言の関数に適用されます。 パラメータデコレータは、宣言ファイル、オーバーロード、その他の環境コンテキスト(&lt;code&gt;declare&lt;/code&gt;クラスなど)では使用できません。</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target>&lt;em&gt;Property Decorator&lt;/em&gt;は、プロパティ宣言の直前に宣言されます。 プロパティデコレータは、宣言ファイルやその他の環境コンテキスト(&lt;code&gt;declare&lt;/code&gt;クラスなど)では使用できません。</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href="http://momentjs.com/"&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target>&lt;em&gt;UMD&lt;/em&gt;モジュールは、&lt;em&gt;インポートを通じてモジュールとして使用することも、&lt;/em&gt;モジュール・ローダーのない環境で実行する場合はグローバルとして使用することもできます。 &lt;a href="http://momentjs.com/"&gt;Moment.js&lt;/a&gt;のような人気のあるライブラリの多くは、このように書かれている。 例えば、Node.jsやRequireJSでは、次のように書く。</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target>&lt;em&gt;判別プロパティタイプガード&lt;/em&gt;は、&lt;code&gt;x.p==v&lt;/code&gt;、&lt;code&gt;x.p===v&lt;/code&gt;、&lt;code&gt;x.p!=v&lt;/code&gt;、または&lt;code&gt;x.p!=v&lt;/code&gt;という形式の式です。&lt;code&gt;p&lt;/code&gt;および&lt;code&gt;v&lt;/code&gt;は、プロパティおよび文字列リテラルタイプの式、または文字列リテラルタイプの和集合です。 識別特性タイプガードは、&lt;code&gt;x&lt;/code&gt;のタイプを、&lt;code&gt;v&lt;/code&gt;の可能な値の1つを持つ識別特性&lt;code&gt;p&lt;/code&gt;を持つ&lt;code&gt;x&lt;/code&gt;の構成要素タイプに絞り込む。</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target>&lt;em&gt;グローバルプラグイン&lt;/em&gt;は、一部のグローバルの形状を変更するグローバルコードです。 &lt;em&gt;グローバル修正モジュール&lt;/em&gt;と同様に、これらのモジュールは実行時に競合する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target>&lt;em&gt;グローバル変更モジュール&lt;/em&gt;は、インポート時にグローバルスコープ内の既存の値を変更します。 たとえば、インポート時に&lt;code&gt;String.prototype&lt;/code&gt;に新しいメンバを追加するライブラリがあるとします。 このパターンは実行時に競合が発生する可能性があるため、多少危険ですが、宣言ファイルを作成することはできます。</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target>&lt;em&gt;global&lt;/em&gt;ライブラリは、グローバルスコープからアクセスできるライブラリです(つまり、&lt;code&gt;import&lt;/code&gt;の形式を使用しない)。 多くのライブラリは、使用する1つまたは複数のグローバル変数を公開するだけです。 たとえば、&lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;を使用している場合、&lt;code&gt;$&lt;/code&gt;変数を参照するだけで使用できます。</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target>&lt;em&gt;モジュールプラグイン&lt;/em&gt;は、別のモジュール(UMDまたはモジュール)の形状を変更します。 たとえば、Moment.jsの&lt;code&gt;moment range&lt;/code&gt;は、&lt;code&gt;moment&lt;/code&gt;オブジェクトに新しい&lt;code&gt;range&lt;/code&gt;メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target>&lt;em&gt;相対インポート&lt;/em&gt;は、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;./&lt;/code&gt;、または&lt;code&gt;./&lt;/code&gt;で始まるインポートです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target>&lt;strong&gt;mixinクラス&lt;/strong&gt;は、型パラメータ型の式を&lt;code&gt;拡張した&lt;/code&gt;クラス宣言または式です。 mixinクラスの宣言には次の規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target>&lt;strong&gt;mixinコンストラクタ型&lt;/strong&gt;は、&lt;code&gt;any[]&lt;/code&gt;型の唯一のrest引数とオブジェクト型の戻り型を持つ単一の構造体シグネチャを持つ型を指します。 たとえば、オブジェクトタイプ&lt;code&gt;X&lt;/code&gt;が指定された場合、&lt;code&gt;new(.args:any[])=&amp;gt;X&lt;/code&gt;はインスタンスタイプ&lt;code&gt;X&lt;/code&gt;を持つミックスインコンストラクタタイプです。</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target>オブジェクトをArray.prototype.concatによって配列要素に統合する必要があることを示すブール値。</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes">
          <source>A Note on Soundness</source>
          <target>健全性に関する注記</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target>オブジェクトの既定の文字列の説明を作成するときに使用する文字列型(String)の値を指定します。 組み込みメソッド&lt;code&gt;Object.prototype.toString&lt;/code&gt;によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;"./template"&lt;/code&gt;.</source>
          <target>ビルド・ステップでは、&lt;code&gt;/src/views&lt;/code&gt;と&lt;code&gt;/generated/templates/views&lt;/code&gt;のファイルを出力の同じディレクトリーにコピーします。 実行時には、ビューはそのテンプレートがその横に存在することを期待できるため、相対名を使用して&lt;code&gt;"./template"&lt;/code&gt;としてインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target>ジェネリック関数の呼び出しでは、引数を使用して型パラメーターを推測します。 推論ソースがないために、このプロセスで型を推論できない場合があります。このような場合、型パラメータのデフォルトは&lt;code&gt;any&lt;/code&gt;になります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target>クラス・コンストラクタは、&lt;code&gt;private&lt;/code&gt;または&lt;code&gt;protected&lt;/code&gt;とマークされます。privateコンストラクタを持つクラスは、クラス本体の外部でインスタンス化できません。また、拡張することもできません。 protectedコンストラクタを持つクラスは、クラス本体の外部でインスタンス化できませんが、拡張できます。</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target>クラス宣言(&lt;code&gt;class C{}&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target>既存のクラスまたはインタフェース宣言とマージするクラスまたはインタフェース宣言は、既存の型パラメータにデフォルトを導入することができる。</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target>既存のクラスまたはインタフェース宣言と結合するクラスまたはインタフェース宣言は、デフォルトを指定する限り、新しい型パラメータを導入することができます。</target>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target>一般的で危険なエラーは、関数の呼び出しを忘れることです。特に、関数に0個の引数がある場合や、関数ではなくプロパティである可能性があることを示す名前が付けられている場合に起こります。</target>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from "...";&lt;/code&gt;, &lt;code&gt;import x = require("...");&lt;/code&gt;, etc.) path.</source>
          <target>よくある間違いは、&lt;code&gt;import&lt;/code&gt;ステートメントを使用するのではなく、&lt;code&gt;///&amp;lt;reference./&amp;gt;&lt;/code&gt;構文を使用してモジュールファイルを参照しようとすることです。 区別を理解するには、まずコンパイラが&lt;code&gt;import&lt;/code&gt;のパス(例えば、&lt;code&gt;import x from".";&lt;/code&gt;,&lt;code&gt;import x=require("...");&lt;/code&gt;などの&lt;code&gt;.&lt;/code&gt;)に基づいて、モジュールの型情報を見つける方法を理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target>JavaScriptの一般的なパターンは、&lt;code&gt;typeof&lt;/code&gt;または&lt;code&gt;instanceof&lt;/code&gt;を使用して、実行時に式の型を調べることです。 TypeScriptはこれらの条件を理解するようになり、&lt;code&gt;if&lt;/code&gt;ブロックで使用されると、それに応じて型推論を変更する。</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target>一般的なタスクは、既存の型を取得し、それぞれのプロパティをオプションにすることです。</target>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target>一般的な回避策として、IIFE(Immediately Invoked Function Expression)を使用して、反復のたびに&lt;code&gt;i&lt;/code&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target>条件付きタイプ&lt;code&gt;T extends U?X:Y&lt;/code&gt;は、&lt;em&gt;resolved&lt;/em&gt;to&lt;code&gt;X&lt;/code&gt;または&lt;code&gt;Y&lt;/code&gt;、または&lt;em&gt;deferred&lt;/em&gt;のいずれかです。これは、条件が1つ以上のタイプ変数に依存するためです。 &lt;code&gt;T&lt;/code&gt;または&lt;code&gt;U&lt;/code&gt;に型変数が含まれる場合、&lt;code&gt;X&lt;/code&gt;または&lt;code&gt;Y&lt;/code&gt;に解決するか、延期するかは、&lt;code&gt;T&lt;/code&gt;が常に&lt;code&gt;U&lt;/code&gt;に割り当て可能であると結論するのに十分な情報が型システムにあるかどうかによって決定される。</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target>条件付きタイプ&lt;code&gt;T extends U?X:Y&lt;/code&gt;は、&lt;em&gt;resolved&lt;/em&gt;to&lt;code&gt;X&lt;/code&gt;または&lt;code&gt;Y&lt;/code&gt;、または&lt;em&gt;deferred&lt;/em&gt;のいずれかです。これは、条件が1つ以上のタイプ変数に依存するためです。 解決するか延期するかは、次のように決定されます。</target>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target>コンストラクタには、&lt;code&gt;protected&lt;/code&gt;とマークすることもできます。これは、クラスを含むクラスの外部でインスタンス化できないが、拡張できることを意味します。 たとえば</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes">
          <source>A couple of limitations</source>
          <target>2つの制限</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes">
          <source>A couple of things to note about accessors:</source>
          <target>アクセサーについては、次の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes">
          <source>A decorator is:</source>
          <target>デコレータ:</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target>構造化宣言は、1つまたは複数の名前付き変数を導入し、オブジェクトまたは配列の要素のプロパティから抽出された値で初期化します。</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target>最上位レベルの宣言が&lt;code&gt;export namespace Foo{.}&lt;/code&gt;のみであるファイル(&lt;code&gt;Foo&lt;/code&gt;を削除して、すべてを上位レベルに移動)</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target>派生オブジェクトの作成に使用されるコンストラクタ関数である関数値プロパティ。</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target>本体が&lt;code&gt;arguments&lt;/code&gt;参照への参照を持つ関数は、暗黙的にvar argパラメータを持つと見なされます(つまり、&lt;code&gt;(.arg:any[])=&amp;gt;any&lt;/code&gt;)。 JSDoc var arg構文を使用して、引数の型を指定します。</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target>関数の型には、引数の型と戻り値の型の2つの部分があります。 関数型全体を書き出す場合は、両方の部分が必要です。 パラメーター・リストのようにパラメーター・タイプを書き出し、各パラメーターに名前とタイプを付けます。 この名前は読みやすくするためだけのものです。 代わりに次のように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target>生成関数は、関数と同様に戻り値型の注釈を持つことができます。 注釈は、関数が返すジェネレータの型を表します。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target>型注釈のない生成関数は、推論された型注釈を持つことができる。 したがって、次の場合、タイプはyieldステートメントから推測されます。</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target>ジェネリッククラスは、ジェネリックインタフェースに似た形状をしています。 ジェネリッククラスには、クラス名の後に山括弧(&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;)で囲まれたジェネリック型パラメータリストがあります。</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes">
          <source>A generic parameter default follows the following rules:</source>
          <target>汎用パラメータのデフォルトは次の規則に従います。</target>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target>列挙型の便利な機能の1つは、列挙型の中で数値からその値の名前に移動できることです。 たとえば、値&lt;code&gt;2&lt;/code&gt;があっても、上記の&lt;code&gt;Color&lt;/code&gt;enumで何にマップされているかがわからない場合、対応する名前を検索できます。</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target>JavaScriptのデータ型の標準的なセットに&lt;code&gt;enum&lt;/code&gt;を追加すると便利です。C#などの言語と同様に、enumは数値のセットにわかりやすい名前を付ける方法です。</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target>TypeScriptのモジュールの重要な特徴は、2つの異なるモジュールが同じスコープに名前を提供しないことです。 モジュールのコンシューマが割り当てる名前を決定するので、エクスポートされたシンボルをネームスペースにラップする必要はありません。</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes">
          <source>A library can consist of multiple modules, such as</source>
          <target>ライブラリは、次のような複数のモジュールで構成できます。</target>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target>待望の機能は、TypeScriptプロジェクト用のスマートインクリメンタルビルドだ。 3.0では、&lt;code&gt;tsc&lt;/code&gt;に&lt;code&gt;--build&lt;/code&gt;フラグを使用することができます。これは、単純なコンパイラよりもビルド・オーケストレータのように動作する&lt;code&gt;tsc&lt;/code&gt;の新しいエントリ・ポイントです。</target>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target>ソフトウェアエンジニアリングの主要な部分は、明確で一貫性のあるAPIを持つだけでなく、再利用可能なコンポーネントを構築することです。 今日のデータと将来のデータを処理できるコンポーネントは、大規模なソフトウェアシステムを構築するための最も柔軟な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target>マップされた型&lt;code&gt;{[P in K]:XXX}&lt;/code&gt;は、&lt;code&gt;string number symbol&lt;/code&gt;に割り当て可能な任意の&lt;code&gt;K&lt;/code&gt;を許可する。</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target>オブジェクトを対応するプリミティブ値に変換するメソッド。 &lt;code&gt;ToPrimitive&lt;/code&gt;抽象操作によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target>コンストラクタオブジェクトがオブジェクトをコンストラクタのインスタンスの1つとして認識するかどうかを決定するメソッド。 instanceof演算子のセマンティクスによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target>オブジェクトのデフォルトのイテレーターを戻すメソッド。 for文のセマンティクスによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target>&lt;code&gt;+&lt;/code&gt;または&lt;code&gt;-&lt;/code&gt;プレフィックスのない修飾子は、&lt;code&gt;+&lt;/code&gt;プレフィックスのある修飾子と同じです。 したがって、上記の&lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt;タイプは</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target>モジュール名は、&lt;code&gt;rootDir&lt;/code&gt;に対する相対位置に基づいて、各モジュールに対して計算されます。</target>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target>より高度な例では、prototypeプロパティーを使用して、コンストラクター関数とクラス型のインスタンス側との関係を推測し、制約します。</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target>この機能で検出される一般的なエラーは、&lt;code&gt;return&lt;/code&gt;文の後に改行を追加することです。</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target>名前空間&lt;code&gt;X&lt;/code&gt;(&lt;code&gt;名前空間&lt;/code&gt;宣言が型&lt;code&gt;Y&lt;/code&gt;を含むため)</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target>名前空間&lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from "foo"&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target>名前空間インポート(つまり、&lt;code&gt;import*as foo from"foo"&lt;/code&gt;)がアンカラブリとして正しくフラグ付けされるようになりました。 これを呼び出すとエラーになります。</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target>新しい&lt;code&gt;!&lt;/code&gt;後置式演算子を使用して、型チェッカーがその事実を結論づけることができないコンテキストで、そのオペランドが非NULLかつ非未定義であることをアサートすることができる。 具体的には、演算&lt;code&gt;x!&lt;/code&gt;は、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;を除外した&lt;code&gt;x&lt;/code&gt;の型の値を生成する。 &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt;および&lt;code&gt;x as T&lt;/code&gt;という形式の型アサーションと同様に、&lt;code&gt;!&lt;/code&gt;非NULLアサーション演算子は、発行されたJavaScriptコードから単純に削除されます。</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target>TypeScript2.0には新しいフラグも追加され、明示的な型注釈なしに関数内の&lt;code&gt;this&lt;/code&gt;のすべての使用にフラグを付ける。</target>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target>&lt;code&gt;ReadonlyArray&lt;/code&gt;の新しい構文</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes">
          <source>A nightly build from the &lt;a href="https://github.com/Microsoft/TypeScript/tree/master"&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target>&lt;a href="https://github.com/Microsoft/TypeScript/tree/master"&gt;TypeScript&amp;rsquo;の&lt;code&gt;master&lt;/code&gt;&lt;/a&gt;ブランチからの夜間ビルドは、PSTの深夜にNPMとNuGetに発行されます。 ここでは、ツールを入手して使用する方法を示します。</target>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href="modules#ambient-modules"&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target>相対でないインポートは、&lt;code&gt;baseUrl&lt;/code&gt;を基準にして解決するか、パスマッピングを使用して解決できます。パスマッピングについては、後で説明します。 また、&lt;a href="modules#ambient modules"&gt;ambient module declarations&lt;/a&gt;に解決することもできます。外部依存関係をインポートする場合は、相対パス以外を使用してください。</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from "moduleB"&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;"moduleB"&lt;/code&gt;:</source>
          <target>ソースファイル&lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;内の&lt;code&gt;import{b}from"moduleB"&lt;/code&gt;のように、&lt;code&gt;moduleB&lt;/code&gt;に対して相対的でないインポートを行うと、&lt;code&gt;"moduleB"&lt;/code&gt;を見つけるために次の場所が試行されます。</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target>&amp;lsquo;let&amp;rsquo;に関するメモ</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target>&lt;code&gt;let&lt;/code&gt;に関するメモ</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes">
          <source>A partial version of it would be:</source>
          <target>その一部を次に示します。</target>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target>多様な&lt;code&gt;この&lt;/code&gt;型は、包含するクラスまたはインタフェースの&lt;em&gt;サブタイプ&lt;/em&gt;である型を表す。 これを&lt;em&gt;F&lt;/em&gt;有界多形と呼ぶ。 これにより、例えば階層的な流れるようなインターフェースを表現しやすくなります。 各操作の後に&lt;code&gt;this&lt;/code&gt;を返す簡単な計算機を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target>プロジェクトソースのレイアウトが出力のレイアウトと一致しない場合があります。 通常、一連のビルド・ステップによって最終出力が生成されます。 これには、&lt;code&gt;.ts&lt;/code&gt;ファイルを&lt;code&gt;.js&lt;/code&gt;にコンパイルすることや、異なるソースロケーションから単一の出力ロケーションに依存関係をコピーすることが含まれる。 その結果、実行時のモジュールは、定義を含むソースファイルとは異なる名前を持つ可能性があります。 または、最終出力のモジュールパスが、コンパイル時に対応するソースファイルパスと一致しない場合があります。</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target>オブジェクトまたは関数が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;を含む型である場合、プロパティアクセスまたは関数呼び出しはコンパイル時エラーを生成します。ただし、型ガードは非NULLおよび非未定義チェックをサポートするように拡張されています。</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target>&lt;code&gt;get&lt;/code&gt;アクセサーで宣言され、&lt;code&gt;set&lt;/code&gt;アクセサーがないプロパティは、読み取り専用と見なされます。</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target>プロパティまたはインデックスのシグネチャを、&lt;code&gt;readonly&lt;/code&gt;修飾子を読み取り専用として宣言できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target>正規表現を文字列と照合する正規表現メソッド。 &lt;code&gt;String.prototype.match&lt;/code&gt;メソッドによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target>ストリングの一致するサブストリングを置き換える正規表現メソッド。 &lt;code&gt;String.prototype.replace&lt;/code&gt;メソッドによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target>正規表現に一致する文字列内のインデックスを返す正規表現メソッド。 &lt;code&gt;String.prototype.search&lt;/code&gt;メソッドによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target>正規表現に一致するインデックスで文字列を分割する正規表現メソッド。 &lt;code&gt;String.prototype.split&lt;/code&gt;メソッドによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target>相対インポートはインポートファイルを基準にして解決され、&lt;em&gt;は環境モジュール宣言に解決できません&lt;/em&gt;。 実行時に相対位置を維持することが保証されているモジュールには、相対インポートを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from "./moduleB"&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target>相対インポートは、インポートファイルを基準にして解決されます。 したがって、ソース・ファイル&lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;の&lt;code&gt;import{b}from"./moduleB"&lt;/code&gt;は、次のように検索されます。</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target>restパラメータは配列型に制約されたgeneric型を持つことが許され、型推論はそのようなgeneric restパラメータのタプル型を推測することができます。 これにより、部分的なパラメータ・リストの高次の取得と分散が可能になります。</target>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target>従うべき簡単なルールは、ライブラリが定義するグローバル変数で型&lt;em&gt;名前空間&lt;/em&gt;を宣言するだけです。 たとえば、ライブラリがグローバルな価値を定義する場合は、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target>トリプルスラッシュ参照パスは、ルートが存在しない場合は、そのファイルを基準にして解決されます。</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target>ファイルプロパティを指定しない(したがって、すべてのサブディレクトリ内のすべての*.tsファイルを暗黙的に参照する)tsconfig.jsonファイルに、コンパイルから除外するファイルやディレクトリのリストを指定するexcludeプロパティを含めることができる。 excludeプロパティーは、tsconfig.jsonファイルの場所に相対的なファイル名またはフォルダ名を指定するストリングの配列である必要があります。 例:</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target>タプル型では、型に接尾記号&lt;code&gt;?&lt;/code&gt;修飾子があり、その右側にあるすべての要素にも&lt;code&gt;?&lt;/code&gt;修飾子がある場合に、要素を省略できます。</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target>&lt;code&gt;X.Z&lt;/code&gt;名前空間の&lt;code&gt;C&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target>タイプ&lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target>&lt;code&gt;X&lt;/code&gt;名前空間の&lt;code&gt;Y&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target>&lt;code&gt;X&lt;/code&gt;名前空間(クラスのインスタンスシェイプ)の&lt;code&gt;Z&lt;/code&gt;型</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target>型別名宣言(&lt;code&gt;type sn=number string;&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target>これらのタイプの和集合(&lt;em&gt;union&lt;/em&gt;)をとるタイプエイリアス。</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target>タイプには、超過プロパティが許可されていることを明示的に示すインデックスシグネチャを含めることができます。</target>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target>ドットで区切られた名前の型ガードは、ドットで区切られた名前のどの部分への代入の後にも効果がありません。 たとえば、&lt;code&gt;x.y.z&lt;/code&gt;の型ガードは、&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;x.y&lt;/code&gt;、または&lt;code&gt;x.y.z&lt;/code&gt;への代入後は無効になります。</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target>型パラメータにデフォルトがある場合は、オプションと見なされます。</target>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target>typesパッケージは、&lt;code&gt;index.d.ts&lt;/code&gt;というファイルを含むフォルダ、または&lt;code&gt;types&lt;/code&gt;フィールドを含む&lt;code&gt;package.json&lt;/code&gt;を含むフォルダです。</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target>共用体タイプは、いくつかのタイプのうちの1つであり得る値を記述する。 各タイプを区切るには、縦線(&lt;code&gt;&lt;/code&gt;)を使用します。したがって、&lt;code&gt;number string boolean&lt;/code&gt;は、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、または&lt;code&gt;boolean&lt;/code&gt;になる値のタイプです。</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target>ユーザは&lt;code&gt;2*5+1&lt;/code&gt;を次のように表現できます。</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target>&lt;code&gt;X.Z&lt;/code&gt;値のプロパティである値&lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target>値&lt;code&gt;X&lt;/code&gt;(&lt;code&gt;namespace&lt;/code&gt;宣言に値&lt;code&gt;Z&lt;/code&gt;が含まれているため)</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target>&lt;code&gt;X&lt;/code&gt;値のプロパティである値&lt;code&gt;Y&lt;/code&gt;(タイプ&lt;code&gt;number&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target>&lt;code&gt;X&lt;/code&gt;値のプロパティである値&lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target>&lt;code&gt;X&lt;/code&gt;値(クラスのコンストラクタ関数)のプロパティである値&lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target>型注釈なしで宣言され、初期値が&lt;code&gt;[]&lt;/code&gt;である変数は、暗黙的な&lt;code&gt;any[]&lt;/code&gt;変数と見なされます。 ただし、後続の&lt;code&gt;x.push(value)&lt;/code&gt;、&lt;code&gt;x.unshift(value)&lt;/code&gt;、または&lt;code&gt;x[n]=value&lt;/code&gt;オペレーション&lt;em&gt;は、変数に追加される要素に応じて変数のタイプを展開します&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target>AMD/RequireJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes">
          <source>AMD Module names</source>
          <target>AMDモジュール名</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes">
          <source>AMD-dependency optional names</source>
          <target>AMD依存関係オプション名</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes">
          <source>API Changes</source>
          <target>APIの変更</target>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target>&lt;code&gt;--build&lt;/code&gt;および&lt;code&gt;--incremental&lt;/code&gt;をサポートするAPI</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes">
          <source>ASP.NET Core</source>
          <target>ASP.NETコア</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes">
          <source>ASP.NET Core + TypeScript</source>
          <target>ASP.NET Core+TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes">
          <source>ASP.NET Core: Add TypeScript</source>
          <target>ASP.NETコア:TypeScriptの追加</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes">
          <source>ASP.NET Core: Setup</source>
          <target>ASP.NETコア:セットアップ</target>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target>上の例では、&lt;code&gt;T&lt;/code&gt;に対するすべての推論は逆位に由来するので、&lt;code&gt;T&lt;/code&gt;に対する&lt;em&gt;best common subtype&lt;/em&gt;を推論する。これは、&lt;em&gt;best common supertype&lt;/em&gt;を推論する共変位からの推論とは対照的である。</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target>上の例では、インデックス・シグネチャを持つ&lt;code&gt;StringArray&lt;/code&gt;インタフェースがあります。 このインデックスシグネチャは、&lt;code&gt;StringArray&lt;/code&gt;が&lt;code&gt;number&lt;/code&gt;でインデックス付けされると、&lt;code&gt;string&lt;/code&gt;を返すことを示します。</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target>上記の例では、&lt;code&gt;Up&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;で初期化される数値のenumがあります。次のメンバはすべて、その時点から自動的にインクリメントされます。 つまり、&lt;code&gt;Direction.Up&lt;/code&gt;の値は&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;Down&lt;/code&gt;の値は&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;Left&lt;/code&gt;の値は&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;Right&lt;/code&gt;の値は&lt;code&gt;4&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes">
          <source>Abstract Classes</source>
          <target>抽象クラス</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target>抽象クラスは、他のクラスを派生させることができる基本クラスです。 直接インスタンス化することはできません。 インターフェースとは異なり、抽象クラスには、そのメンバーの実装の詳細が含まれます。 &lt;code&gt;abstract&lt;/code&gt;キーワードは、抽象クラス内の抽象クラスと抽象メソッドを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes">
          <source>Abstract properties and accessors</source>
          <target>抽象プロパティとアクセサ</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target>JavaScriptファイルを入力として受け入れます(&lt;code&gt;allowJs&lt;/code&gt;を使用)。</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target>既知のインデックスのセット外の要素にアクセスすると、次のエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes">
          <source>Accessor Decorators</source>
          <target>アクセサー修飾子</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes">
          <source>Accessors</source>
          <target>アクセサ</target>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes">
          <source>Add TypeScript</source>
          <target>TypeScriptを追加</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes">
          <source>Add TypeScript code</source>
          <target>TypeScriptコードを追加</target>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes">
          <source>Add a TypeScript configuration file</source>
          <target>TypeScript設定ファイルを追加する</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target>ウィーク型にインデックスシグネチャを追加します(&lt;code&gt;[propName:string]:{}&lt;/code&gt;)。</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes">
          <source>Add example code</source>
          <target>サンプルコードの追加</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes">
          <source>Add modules to the code</source>
          <target>コードにモジュールを追加する</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target>&lt;code&gt;app.ts&lt;/code&gt;ファイルに次のコードを追加します。</target>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルをディレクトリに追加すると、そのディレクトリがTypeScriptプロジェクトのルートであることを示す。 tsconfig.jsonファイルは、プロジェクトのコンパイルに必要なルートファイルとコンパイラオプションを指定します。 プロジェクトは次のいずれかの方法でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target>&lt;code&gt;名前空間&lt;/code&gt;を使用した追加</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">インターフェースを使用した追加</target>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes">
          <source>Additional module resolution flags</source>
          <target>追加モジュール解決フラグ</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes">
          <source>Additionally, &lt;a href="https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450"&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target>さらに、この新機能の&lt;a href="https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450"&gt;&lt;/a&gt;に関するもう1つの注意事項として、&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;、および&lt;code&gt;apply&lt;/code&gt;には、特定の制限があるため、オーバーロードのある一般的な関数や関数を完全にモデル化できないことがあります。 これらのメソッドを汎用関数で使用すると、型パラメータが空のオブジェクト型(&lt;code&gt;{}&lt;/code&gt;)で置き換えられ、オーバーロードがある関数で使用すると、最後のオーバーロードのみがモデル化されます。</target>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target>さらに、ジェネレーターは、&lt;code&gt;yield&lt;/code&gt;の型が常に&lt;code&gt;any&lt;/code&gt;であると仮定しました。</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target>さらに、&lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt;インタフェースを使用して、Reactの&lt;code&gt;key&lt;/code&gt;などのコンポーネントや引数では通常使用されない、JSXフレームワークで使用される追加プロパティを指定することができます。 さらに特殊化して、一般的な&lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt;タイプを使用して、(関数コンポーネントではなく)クラスコンポーネントだけに同じ種類の追加属性を指定することもできます。 この型では、汎用パラメータがクラスインスタンス型に対応します。 Reactでは、これは&lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;型の&lt;code&gt;ref&lt;/code&gt;属性を許可するために使用されます。一般に、JSXフレームワークのユーザーがすべてのタグに何らかの属性を提供する必要がある場合を除き、これらのインタフェースのすべてのプロパティはオプションである必要があります。</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target>また、既存の構築ワークフローとの互換性を維持するために、&lt;code&gt;--build&lt;/code&gt;スイッチで呼び出されない限り、&lt;code&gt;tsc&lt;/code&gt;は依存関係を自動的に構築&lt;em&gt;しません&lt;/em&gt;。 &lt;code&gt;--build&lt;/code&gt;の詳細については、&amp;rsquo;sを参照してください。</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes">
          <source>Adjustments in module resolution logic</source>
          <target>モジュール分解能ロジックの調整</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes">
          <source>Advanced Combinations</source>
          <target>高度な組み合わせ</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes">
          <source>Advanced Techniques</source>
          <target>高度なテクニック</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes">
          <source>Advanced Topics</source>
          <target>高度なトピック</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes">
          <source>Advanced Types</source>
          <target state="translated">拡張型</target>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target>&lt;code&gt;bundle&lt;/code&gt;を呼び出した後、&lt;code&gt;source&lt;/code&gt;(vinyl source streamのエイリアス)を使用して、出力バンドルに&lt;code&gt;bundle.js&lt;/code&gt;という名前を付けます。</target>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target>その後、lodashを問題なくインポートして、正確な完了を取得できます。</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target>ソリューション・エクスプローラに&lt;code&gt;npm&lt;/code&gt;フォルダが表示された後</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes">
          <source>Again, being explicit, the following things create values:</source>
          <target>ここでも明示的に、次のことが値を作成します。</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes">
          <source>Again, the above code is equivalent to the following.</source>
          <target>この場合も、上記のコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target>ここでも、&lt;code&gt;Bar&lt;/code&gt;を型と値の両方として使用しています。 &lt;code&gt;Bar&lt;/code&gt;値が&lt;code&gt;Bar&lt;/code&gt;タイプであると宣言する必要はありません(&amp;rsquo;re independent)。</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes">
          <source>Aliases</source>
          <target state="translated">エイリアス</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target>エイリアスは実際に新しいタイプを作成するのではなく、そのタイプを参照する新しい&lt;em&gt;名&lt;/em&gt;を作成します。 プリミティブにエイリアスを付けることは、ドキュメントの形式として使用できますが、あまり有用ではありません。</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;"dependencies"&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target>すべての依存関係はnpmによって管理されます。 依存するすべての宣言パッケージが、&lt;code&gt;package.json&lt;/code&gt;の&lt;code&gt;"dependencies"&lt;/code&gt;セクションで適切にマークされていることを確認します。たとえば、BrowserifyとTypeScriptを使用したパッケージを作成したとします。</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target>すべての実装ファイルは、&lt;code&gt;include&lt;/code&gt;パターンで照合するか、&lt;code&gt;files&lt;/code&gt;配列にリストする必要があります。 この制約に違反すると、&lt;code&gt;tsc&lt;/code&gt;は指定されていないファイルを通知します。</target>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target>ショートハンドモジュールからのインポートはすべて&lt;code&gt;any&lt;/code&gt;型を持つ。</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes">
          <source>All imports from a shorthand module will have the any type.</source>
          <target>ショートハンドモジュールからのインポートはすべて、任意の型を持ちます。</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target>&lt;code&gt;myLibrary&lt;/code&gt;の下にある任意のモジュールへのすべてのインポートは、コンパイラによって&lt;code&gt;any&lt;/code&gt;型を持つと見なされます。したがって、これらのモジュールの形状または型のチェックはすべて停止されます。</target>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target>以下は、モジュール構造化のための警告です。 次のいずれかがファイルに適用される場合は、外部モジュールに名前を付けないようにしてください。</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target>構成ファイルで見つかったすべての相対パスは、元の構成ファイルを基準にして解決されます。</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target>すべての厳格性フラグ(&lt;code&gt;strict&lt;/code&gt;のみを含む)</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes">
          <source>AllValidators.ts</source>
          <target>AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes">
          <source>Allow JavaScript files to be compiled.</source>
          <target>JavaScriptファイルのコンパイルを許可します。</target>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes">
          <source>Allow accessing UMD globals from modules.</source>
          <target>モジュールからUMDグローバルへのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target>キャプチャされた&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt;をループで許可する</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes">
          <source>Allow comments in tsconfig.json</source>
          <target>tsconfig.jsonのコメントを許可する</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target>デフォルトのエクスポートなしでモジュールからのデフォルトのインポートを許可します。 これはコード・エミットには影響せず、単にタイプ・チェックを行います。</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes">
          <source>Allow duplicate identifiers across declarations</source>
          <target>宣言間で識別子の重複を許可する</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes">
          <source>Allowed Values</source>
          <target>許容値</target>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target>&lt;code&gt;--strict&lt;/code&gt;をデフォルトでオンに設定すると、&lt;code&gt;tsc--init&lt;/code&gt;の出力が拡張されます。 &lt;code&gt;tsc--init&lt;/code&gt;によって生成されたデフォルトの&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルには、コメントアウトされた説明とともに、一般的なコンパイラオプションのセットが含まれる。 目的の動作を得るために設定したい構成のコメントを外してください。新しい出力によって、新しいプロジェクトのセットアップが簡単になり、プロジェクトの成長に合わせて構成ファイルを読み取れるようにしたいと思います。</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target>従来のOO階層と同様に、再利用可能なコンポーネントからクラスを構築するもう1つの一般的な方法は、単純な部分クラスを組み合わせてクラスを構築することです。 Scalaのような言語のためのミックスインやtraitの概念には慣れているかもしれませんが、このパターンはJavaScriptコミュニティーでもある程度の人気を得ています。</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target>また、それ自身のボディ内でのみ呼び出される関数も未使用と見なされます。</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;"bigint"&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target>&lt;code&gt;bigint&lt;/code&gt;は、&lt;code&gt;typeof&lt;/code&gt;演算子&lt;code&gt;"bigint"&lt;/code&gt;を使用するときに新しい文字列を生成することにも注意してください。したがって、TypeScriptは、期待どおりに&lt;code&gt;typeof&lt;/code&gt;を使用して正しく絞り込まれます。</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;"types"&lt;/code&gt; property, though it is advisable to do so.</source>
          <target>また、メイン宣言ファイルの名前が&lt;code&gt;index.d.ts&lt;/code&gt;で、パッケージのルート(&lt;code&gt;index.js&lt;/code&gt;の隣)にある場合は、&lt;code&gt;"types"&lt;/code&gt;プロパティにマークを付ける必要はありませんが、そのようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib="true"/&amp;gt;&lt;/code&gt;.</source>
          <target>また、&lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;を渡すと、コンパイラは&lt;code&gt;///&amp;lt;reference nodefaultlib="true"/&amp;gt;&lt;/code&gt;を持つチェックファイルのみをスキップすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target>また、コンストラクタの引数に&lt;code&gt;public&lt;/code&gt;を使用すると、その名前のプロパティを自動的に作成することができます。</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes">
          <source>Also see our wiki page on &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file"&gt;using a custom language service file&lt;/a&gt;.</source>
          <target>&lt;a href="https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file"&gt;カスタム言語サービスファイルを使用する&lt;/a&gt;のWikiページも参照してください。</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes">
          <source>Also, a nightly NuGet package to match the &lt;a href="http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx"&gt;nightly npm package&lt;/a&gt; is available on &lt;a href="https://myget.org"&gt;myget&lt;/a&gt;:</source>
          <target>また、&lt;a href="http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx"&gt;nightly npmパッケージ&lt;/a&gt;と一致するnightly NuGetパッケージは、&lt;a href="https://myget.org"&gt;myget&lt;/a&gt;から入手できます。</target>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target>あるいは、ファイル単位のコンパイル(デフォルト)を使用して、入力ファイルごとに1つのJavaScriptファイルを生成することもできます。 複数のJSファイルが生成された場合、Webページで&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグを使用して、各発行ファイルを適切な順序でロードする必要があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target>あるいは、&lt;code&gt;options&lt;/code&gt;の型が&lt;code&gt;any&lt;/code&gt;であると言ってもよいでしょう。これは最も簡単な方法ですが、最もメリットが少ない方法です。</target>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes">
          <source>Alternatives:</source>
          <target>選択肢:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target>JavaScriptモジュールはマージをサポートしていませんが、既存のオブジェクトをインポートして更新することで、既存のオブジェクトにパッチを適用できます。 おもちゃのObservableの例を見てみよう。</target>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes">
          <source>Ambient Classes and Functions Can Merge</source>
          <target>Ambientクラスと関数がマージできる</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes">
          <source>Ambient Modules</source>
          <target>環境モジュール</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes">
          <source>Ambient Namespaces</source>
          <target>アンビエント名前空間</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes">
          <source>Ambient enums</source>
          <target>環境変数</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target>Ambient列挙型は、既存の列挙型の形状を記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target>&lt;code&gt;enum&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target>型を参照する&lt;code&gt;import&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target>値を参照する&lt;code&gt;import&lt;/code&gt;宣言</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target>&lt;em&gt;Accessor Decorator&lt;/em&gt;は、アクセサー宣言の直前に宣言されます。 アクセサー修飾子は、アクセサーの&lt;em&gt;プロパティ記述子&lt;/em&gt;に適用され、アクセサーの定義を観察、変更、または置換するために使用できます。 アクセサー修飾子は、宣言ファイルやその他の環境コンテキスト(&lt;code&gt;declare&lt;/code&gt;クラスなど)では使用できません。</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target>&lt;em&gt;async関数&lt;/em&gt;は、&lt;code&gt;async&lt;/code&gt;修飾子を先頭に持つ関数またはメソッドです。 この修飾子は、関数本体の転置が必要であること、およびキーワード&lt;code&gt;await&lt;/code&gt;を識別子ではなく単項式として扱う必要があることをコンパイラに通知します。 &lt;em&gt;Async Function&lt;/em&gt;は、互換性のある&lt;code&gt;Promise&lt;/code&gt;型を指す戻り型注釈を提供しなければならない。 戻り型推論は、グローバルに定義された互換性のある&lt;code&gt;Promise&lt;/code&gt;型がある場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes">
          <source>An Example Project</source>
          <target>サンプルプロジェクト</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target>クラスまたは空のオブジェクトリテラルである関数を返すIIFEも、名前空間として認識されます。</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target>関連付けられたオブジェクトの&amp;rsquo;環境バインドを持つ&amp;lsquo;から除外されたプロパティ名をプロパティ名として持つオブジェクト。</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target>抽象クラスは、抽象プロパティーやアクセサーを宣言できます。 どのサブクラスも、抽象プロパティーを宣言するか、抽象としてマークする必要があります。 抽象プロパティには初期化子を指定できません。 抽象アクセサは本体を持つことができません。</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from "foo"&lt;/code&gt;).</source>
          <target>ES2015名前空間インポートを介してアクセスされるエンティティは、読み取り専用と見なされます(たとえば、&lt;code&gt;foo&lt;/code&gt;が&lt;code&gt;import*as foo from"foo"&lt;/code&gt;として宣言されている場合、&lt;code&gt;foo.x&lt;/code&gt;は読み取り専用です)。</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target>&lt;code&gt;import&lt;/code&gt;文で宣言されたエンティティは読み取り専用と見なされます。</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target>列挙宣言(&lt;code&gt;enum E{A,B,C}&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target>エクスポートデフォルト宣言では、モジュールのデフォルトエクスポートとなる式を指定します。</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target>宣言ファイルのないモジュールへのインポートでも、&lt;code&gt;--noImplicitAny&lt;/code&gt;の下にエラーとしてフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target>重要なルールは、&lt;code&gt;export&lt;/code&gt;と&lt;code&gt;import&lt;/code&gt;宣言がターゲットのすべての意味&lt;/em&gt;をエクスポートまたはインポートすることです。</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target>あるタイプ&lt;code&gt;T&lt;/code&gt;に対するインデックスタイプ&lt;code&gt;keyof T&lt;/code&gt;は、&lt;code&gt;string number symbol&lt;/code&gt;のサブタイプである。</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target>1つのインターフェイスで複数のインターフェイスを拡張し、すべてのインターフェイスの組み合わせを作成できます。</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target>インタフェース宣言(&lt;code&gt;interface I{x:number[];}&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target>交差タイプは、複数のタイプを1つに結合します。 これにより、既存の型を追加して、必要なすべての機能を持つ単一の型を得ることができます。 たとえば、&lt;code&gt;Person&amp;amp;Serializable&amp;amp;Loggable&lt;/code&gt;は、&lt;code&gt;Person&lt;/code&gt;&lt;em&gt;および&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;および&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;です。つまり、このタイプのオブジェクトには、3つのタイプすべてのメンバーが含まれます。</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href="symbols#symboliterator"&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target>オブジェクトに&lt;a href="symbols#スイムボリテラトー"&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;プロパティの実装がある場合、そのオブジェクトはiterableとみなされます。 &lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Int32Array&lt;/code&gt;、&lt;code&gt;Uint32Array&lt;/code&gt;などの一部の組み込み型には、&lt;code&gt;Symbol.iterator&lt;/code&gt;プロパティがすでに実装されています。 オブジェクトの&lt;code&gt;Symbol.iterator&lt;/code&gt;関数は、反復する値のリストを返します。</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target>オブジェクトリテラル内のすべての既知のプロパティがインデックスシグネチャに割り当てられる場合、オブジェクトリテラル型はインデックスシグネチャを持つ型に割り当てられるようになりました。 これにより、マップまたはディクショナリを必要とする関数に、パラメータとしてオブジェクトリテラルで初期化された変数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target>非同期反復をサポートするオブジェクトは、&lt;code&gt;AsyncIterator&lt;/code&gt;オブジェクトを返す&lt;code&gt;Symbol.asyncIterator&lt;/code&gt;メソッドを持つ場合、&amp;ldquo;iterable&amp;rdquo;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target>オペランドの型が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;である場合、または&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;を含むユニオン型である場合、オペランドはNULL入力可能とみなされます。ユニオン型の場合は、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;&lt;/code&gt;が従来の型チェック・モードではユニオンから削除されるため、&lt;code&gt;-strictNullChecks&lt;/code&gt;モードでのみ発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target>JSDocの型引数が指定されていない場合、デフォルトは次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes">
          <source>And help in Japanese:</source>
          <target>日本語での助け:</target>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target>そして、型述部シグニチャーと同様に、これらのアサーション・シグニチャーは驚くほど表現豊かです。 これらを使えばかなり洗練されたアイデアを表現できます。</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes">
          <source>And results in</source>
          <target>結果</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target>もう1つは&lt;code&gt;as&lt;/code&gt;-構文です。</target>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes">
          <source>And to use it:</source>
          <target>使用方法:</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes">
          <source>And usage would be:</source>
          <target>使用方法は次のようになります。</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes">
          <source>And with parameters to a function:</source>
          <target>関数のパラメータを使用する場合:</target>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target>また、ES2015以前のコードでは、静的メソッドをシミュレートするために使用できます。</target>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target>TypeScriptが持っているもう一つのECMAScript2015の機能は、構造化解除である。 詳細については、&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"&gt;Mozilla Developer Networkの記事&lt;/a&gt;を参照してください。 このセクションでは、簡単な概要を説明します。</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target>もう1つの違いは、&lt;code&gt;for.in&lt;/code&gt;が任意のオブジェクトに対して動作することです。これは、このオブジェクトのプロパティを検査する手段として機能します。 一方、&lt;/code&gt;の&lt;code&gt;for.は、主にIterableオブジェクトの値に関心があります。 &lt;code&gt;Map&lt;/code&gt;や&lt;code&gt;Set&lt;/code&gt;などの組み込みオブジェクトは、&lt;code&gt;Symbol.iterator&lt;/code&gt;プロパティを実装し、格納された値にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target>もう1つの例は、&lt;code&gt;TypeName&lt;/code&gt;型のエイリアスで、ネストされた条件付き型を使用します。</target>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;"&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target>Webページやサーバー用のプログラムをJavaScriptで作成するもう1つの基本的な部分は、テキスト・データを扱うことです。 他の言語と同様に、これらのテキストデータ型を参照するには&lt;code&gt;string&lt;/code&gt;型を使用します。 JavaScriptと同様に、TypeScriptも文字列データを囲むために二重引用符(&lt;code&gt;"&lt;/code&gt;)または一重引用符(&lt;code&gt;'&lt;/code&gt;)を使用します。</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target>もう1つの良いプラクティスは、&amp;ldquo;solution&amp;rdquo;&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを持つことです。このファイルは、&lt;code&gt;がすべてのリーフノードプロジェクトを参照する&lt;/code&gt;だけを持ち、&lt;code&gt;files&lt;/code&gt;を空の配列に設定します(そうしないと、ソリューションファイルによってファイルが二重にコンパイルされます)。 3.0以降では、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルに少なくとも1つの&lt;code&gt;reference&lt;/code&gt;がある場合、空の&lt;code&gt;files&lt;/code&gt;配列を持つことはエラーにならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target>ブロックスコープ変数のもう1つの特性は、実際に宣言される前に読み取りまたは書き込みができないことです。 これらの変数は、そのスコープ全体を通じて&amp;ldquo;現在&amp;rdquo;ですが、宣言されるまでのすべてのポイントは&lt;em&gt;temporal dead zone&lt;/em&gt;の一部です。これは、&lt;code&gt;let&lt;/code&gt;ステートメントの前にこれらの変数にアクセスできないようにするための洗練された方法です。幸いなことに、TypeScriptによってそれが通知されます。</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes">
          <source>Another simple way is to use class expressions:</source>
          <target>もう1つの簡単な方法は、クラス式を使用することです。</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target>&lt;code&gt;const&lt;/code&gt;コンテキストは、式を完全に不変なものに直ちに変換しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require("name")&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target>ネームスペースの操作を簡単にするもう1つの方法は、&lt;code&gt;import q=x.y.z&lt;/code&gt;を使用して、一般的に使用されるオブジェクトに短い名前を作成することです。 モジュールの読み込みに使用される&lt;code&gt;import x=require("name")&lt;/code&gt;構文と混同しないように、この構文は単に指定されたシンボルのエイリアスを作成します。 モジュールインポートから作成されたオブジェクトを含む任意の種類の識別子に対して、これらの種類のインポート(別名)を使用できます。</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target>この例を説明するもう1つの方法は、型&lt;code&gt;(x: T)=&amp;gt;void&lt;/code&gt;は、デフォルトの型チェックモードでは&lt;code&gt;T&lt;/code&gt;に対して&lt;em&gt;bivariant&lt;/em&gt;(つまり共変&lt;em&gt;または&lt;/em&gt;contravariant)であるが、strict関数型モードでは&lt;em&gt;contravariant&lt;/em&gt;であるということです。</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target>&lt;code&gt;export&lt;/code&gt;キーワードを追加すると、任意の宣言(変数、関数、クラス、型エイリアス、インターフェイスなど)をエクスポートできます。</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes">
          <source>Any files that are referenced by files included via the &lt;code&gt;"files"&lt;/code&gt; or &lt;code&gt;"include"&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;"exclude"&lt;/code&gt; list.</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;または&lt;code&gt;"include"&lt;/code&gt;プロパティを介してインクルードされるファイルによって参照されるすべてのファイルもインクルードされます。 同様に、ファイル&lt;code&gt;B.ts&lt;/code&gt;が別のファイル&lt;code&gt;A.ts&lt;/code&gt;によって参照されている場合、参照ファイル&lt;code&gt;A.ts&lt;/code&gt;が&lt;code&gt;"exclude"&lt;/code&gt;リストにも指定されていない限り、&lt;code&gt;B.ts&lt;/code&gt;は除外できません。</target>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target>オプションのパラメータはすべて、必須のパラメータに従う必要があります。 姓ではなく名をオプションにする場合は、関数内のパラメータの順序を変更して、名をリストの最後にする必要があります。</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target>その他のインポートは、&lt;strong&gt;非相対&lt;/strong&gt;と見なされます。 次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target>何らかの変数を指定して&lt;code&gt;isFish&lt;/code&gt;が呼び出されると、元の型に互換性がある場合、TypeScriptはその変数を&lt;em&gt;絞り込み&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target>NULLまたはundefinedで初期化された変数、パラメータ、またはプロパティは、完全なNULLチェックがオンになっていても、any型になります。 []で初期化された変数、パラメータ、またはプロパティは、完全なNULLチェックがオンになっている場合でも、any[]型になります。 唯一の例外は、上記のように複数の初期化子を持つプロパティの場合です。</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target>挨拶が必要な場所には、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;を返す関数、または&lt;code&gt;Greeter&lt;/code&gt;インスタンスを指定できます。</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target>Apache Cordova Appsには、単一の&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルという既存の制限があり、これはrootまたは&lt;code&gt;scripts&lt;/code&gt;フォルダのいずれかに存在しなければならない。</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes">
          <source>Applying the &lt;a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege"&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target>最小権限&lt;/a&gt;の原則&lt;a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege"&gt;を適用すると、変更する予定の宣言以外のすべての宣言に&lt;code&gt;const&lt;/code&gt;を使用する必要があります。その理由は、変数を書き込む必要がない場合、同じコードベースで作業する他の宣言は自動的にオブジェクトに書き込むことができないため、変数に再割り当てする必要があるかどうかを検討する必要があるためです。 &lt;code&gt;const&lt;/code&gt;を使用すると、データの流れについて推論するときにコードをより予測可能にすることもできる。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes">
          <source>Array</source>
          <target state="translated">配列</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes">
          <source>Array destructuring</source>
          <target state="translated">配列の分解</target>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target>注意点として、&lt;code&gt;strictNullChecks&lt;/code&gt;を使用する場合は、&lt;code&gt;strictNullChecks&lt;/code&gt;を使用するように依存関係を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target>おまけとして、重複パッケージから&lt;code&gt;.d.ts&lt;/code&gt;ファイルをロードしないようにすることで、コンパイラと言語サービスのメモリとランタイムのフットプリントを削減することもできます。</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target>注:可能であれば&lt;code&gt;--strictNullChecks&lt;/code&gt;を使用することを推奨しますが、このハンドブックの目的上、このオプションはオフになっているものとします。</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target>その結果、TypeScript3.2では、次の例の&lt;code&gt;error&lt;/code&gt;プロパティは判別式であると見なされますが、&lt;code&gt;Error&lt;/code&gt;はシングルトン型であるため、&lt;code&gt;error&lt;/code&gt;は判別式ではないと見なされます。このため、&lt;code&gt;unwrap&lt;/code&gt;関数の本体では絞り込みが正しく機能します。</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target>その結果、ユーザはTypeScript3.6の環境コンテキストでgetterとsetterを書くことができる。</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target>個別のインポートの代わりに、名前空間インポートを使用してモジュール全体をインポートできます。</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes">
          <source>As an example of new errors you might spot as a result:</source>
          <target>新しいエラーの例として、次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target>すぐに解決されるタイプの例として、次の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;"\uD842\uDFB7"&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target>たとえば、文字&amp;lsquo;ョキ&amp;rsquo;を含む文字列をエスケープする必要があるとします。 UTF-16/UCS2では、&amp;lsquo;ョキ&amp;rsquo;はサロゲートペアとして表されます。つまり、&amp;rsquo;は16ビットのコード値のペア、特に&lt;code&gt;0xD842&lt;/code&gt;と&lt;code&gt;0xDFB7&lt;/code&gt;を使用してエンコードされます。 これまでは、コードポイントを&lt;code&gt;"\uD842\uDFB7"&lt;/code&gt;としてエスケープする必要がありました。これには、サロゲートペアから2つの独立した文字を区別するのが難しいという大きな欠点がありました。</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target>たとえば、lodashのようなライブラリーの宣言を取得するには、次のコマンドを実行するだけです。</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target>たとえば、多くのUnixライクなシステムでは、標準出力ストリームには&lt;code&gt;/dev/stdout&lt;/code&gt;ファイルからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes">
          <source>As an example, the following code snippet</source>
          <target>例として、次のコードを示します。</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href="https://www.npmjs.com/package/pretty-js"&gt;pretty-js&lt;/a&gt;:</source>
          <target>例えば、&lt;a href="https://www.npmjs.com/package/pretty-js"&gt;pretty js&lt;/a&gt;のように、出力されたJavaScriptをきれいなプリンタにパイプすることができます。</target>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target>前述したように、コンパイラはモジュールを解決するときに、現在のフォルダ外のファイルを参照できます。 これは、モジュールが解決されない理由、または誤った定義に解決される理由を診断するときに困難になることがあります。 &lt;code&gt;--traceResolution&lt;/code&gt;を使用してコンパイラモジュール解決トレースを有効にすると、モジュール解決プロセス中に何が起こったのかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target>JavaScriptと同様に、TypeScriptのすべての数値は浮動小数点値です。 これらの浮動小数点数は、&lt;code&gt;number&lt;/code&gt;型を取得します。TypeScriptでは、16進数および10進数のリテラルに加えて、ECMAScript2015で導入されたバイナリおよび8進数のリテラルもサポートしています。</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target>パラメータの種類が揃っている限り、関数の種類にパラメータ名を指定しても、&amp;rsquo;sはその関数の有効な種類と見なされます。</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target>前述したように、&lt;code&gt;if&lt;/code&gt;ステートメント条件内で関数が呼び出されていないように見えると、TypeScriptでエラーが発生するようになりました。 次のいずれかに該当する場合を除き、&lt;code&gt;if&lt;/code&gt;条件で関数型がチェックインされると、エラーが発行されます。</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes">
          <source>As mentioned in &lt;a href="enums#union-enums-and-enum-member-types"&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target>&lt;a href="enums#union enums and enum member types"&gt;列挙型に関するセクション&lt;/a&gt;で説明したように、列挙型メンバは、すべてのメンバがリテラルで初期化されるときに型を持ちます。</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target>アプリケーションが成長するにつれて、保守を容易にするためにコードを複数のファイルに分割したいと考えています。</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target>アサーション・シグニチャーの作業の一環として、TypeScriptはどこで、どの関数が呼び出されたのかをもっとエンコードする必要がありました。 これにより、&lt;code&gt;never&lt;/code&gt;を返す関数という別のクラスのサポートを拡張する機会が得られました。</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target>ECMAScriptで指定されているように、算術演算で&lt;code&gt;number&lt;/code&gt;と&lt;code&gt;bigint&lt;/code&gt;を混ぜるとエラーになります。 値を&lt;code&gt;BigInt&lt;/code&gt;に明示的に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target>したがって、TypeScriptの1つの宣言で複数のデコレータを評価する場合は、次の手順を実行します。</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target>名前が示すように、コンポーネントはJavaScript関数として定義され、最初の引数は&lt;code&gt;props&lt;/code&gt;オブジェクトです。 TSは、その戻り型が&lt;code&gt;JSX.Element&lt;/code&gt;に割り当て可能でなければならないことを強制します。</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target>バリデータを追加するにつれて、型を追跡し、他のオブジェクトとの名前の衝突を心配しないようにするために、ある種の編成スキームが必要になります。 グローバル名前空間にさまざまな名前を入れる代わりに、でオブジェクトを名前空間にラップします。</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes">
          <source>As we covered in &lt;a href="classes"&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target>&lt;a href="classes"&gt;クラスに関するセクション&lt;/a&gt;で説明したように、クラスには、静的な側面とインスタンスの側面という2つの側面があります。 汎用クラスは、静的側ではなくインスタンス側でのみ汎用であるため、クラスを操作する場合、静的メンバーはクラスのtypeパラメータを使用できません。</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes">
          <source>As we improve the playground and the website, &lt;a href="https://github.com/microsoft/TypeScript-Website/"&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target>遊び場とWebサイトを改善するにあたり、&lt;a href="https://github.com/microsoft/TypeScript-Website/"&gt;GitHubでフィードバックを歓迎し、リクエストをプルします&lt;/a&gt;!</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target>前に述べたように、インターフェースは実世界のJavaScriptに存在するリッチ・タイプを記述することができます。 JavaScriptの動的で柔軟な性質のために、上で説明したタイプのいくつかを組み合わせたオブジェクトに遭遇することがあります。</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target>すでに説明したように、BigIntのサポートは&lt;code&gt;esnext&lt;/code&gt;ターゲットでのみ使用できます。 これは明らかではないかもしれませんが、BigIntは&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;などの数学演算子に対して異なる動作をするため、(&lt;code&gt;es2017&lt;/code&gt;以下のように)機能が存在しない古いターゲットに機能を提供するには、これらの操作のそれぞれを書き直す必要があります。 TypeScriptは型に応じて適切な動作にディスパッチする必要があるため、加算、文字列連結、乗算などを行うたびに関数呼び出しが必要になります。</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target>前述したように、型別名はインタフェースのように動作しますが、多少の違いがあります。</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target>前のセクションで説明したように、クラス宣言では、クラスのインスタンスを表す型とコンストラクター関数の2つの要素が作成されます。 クラスは型を作成するので、インターフェースを使用できる場所と同じ場所で型を使用できます。</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target>ジェネレータと同様に、非同期ジェネレータは関数宣言、関数式、またはクラスまたはオブジェクトリテラルのメソッドのみです。 Arrow関数を非同期ジェネレータにすることはできません。 非同期ジェネレータには、有効な&lt;code&gt;Symbol.asyncIterator&lt;/code&gt;リファレンス(ネイティブシンボルまたはshim)に加えて、有効なグローバル&lt;code&gt;Promise&lt;/code&gt;実装(ネイティブまたはES2015互換のpolyfill)が必要です。</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target>配列と同様に、&lt;code&gt;.&lt;/code&gt;を使用して残りのタプルを分解し、より短いタプルを取得できます。</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes">
          <source>As with assertion functions, you can &lt;a href="https://github.com/microsoft/TypeScript/pull/32695"&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target>アサーション関数と同じように、&lt;a href="https://github.com/microsoft/TypeScript/pull/32695"&gt;プル要求でさらに情報を読み取ることができます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target>グローバルモジュールと同様に、これらの例はUMDモジュールのマニュアルに記載されている場合があるため、コードまたはマニュアルを必ず確認してください。</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target>型の場合と同様に、値とは何かを理解しているはずです。 値は、式で参照できるランタイム名です。 たとえば、&lt;code&gt;let x=5;&lt;/code&gt;は、&lt;code&gt;x&lt;/code&gt;という値を作成します。</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target>&lt;code&gt;a&lt;/code&gt;という名前の変数を&lt;code&gt;10&lt;/code&gt;という値で宣言しました。</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target>ボックスに入力すると、メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target>&lt;code&gt;/root/src/moduleB.js&lt;/code&gt;という名前のファイルが存在するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target>フォルダ&lt;code&gt;/root/src/moduleB&lt;/code&gt;に&lt;code&gt;index.js&lt;/code&gt;という名前のファイルが含まれているかどうかを確認します。このファイルは、フォルダ&amp;rsquo;s&amp;ldquo;main&amp;rdquo;モジュールと暗黙的にみなされます。</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;"main"&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ "main": "lib/mainModule.js" }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target>フォルダ&lt;code&gt;/root/src/moduleB&lt;/code&gt;に、&lt;code&gt;"main"&lt;/code&gt;モジュールを指定する&lt;code&gt;package.json&lt;/code&gt;という名前のファイルがあるかどうかを問い合わせます。 この例では、Node.jsが&lt;code&gt;{"main":"lib/mainModule.js"}&lt;/code&gt;を含む&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt;ファイルを見つけた場合、Node.jsは&lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;を参照します。</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes">
          <source>Assertion Functions</source>
          <target>アサーション関数</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target>JavaScriptのアサーションは、不適切な型が渡されないようにするためによく使われます。 たとえば</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes">
          <source>Assigned-before-use checking</source>
          <target>使用前のチェック</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target>ユニオンタイプへの割り当ては非常に直感的に機能します。ユニオンタイプのメンバーに割り当てることができるものはすべて、ユニオンに割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes">
          <source>Assignments</source>
          <target>割り当て</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target>最上位レベルの割り当ても同様に動作します。つまり、&lt;code&gt;var&lt;/code&gt;または&lt;code&gt;const&lt;/code&gt;宣言は必要ありません。</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target>&lt;code&gt;exports&lt;/code&gt;または&lt;code&gt;module.exports&lt;/code&gt;への割り当て</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target>&lt;code&gt;window&lt;/code&gt;または&lt;code&gt;global&lt;/code&gt;のプロパティへの割り当て</target>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target>これらの各モジュールが文字列の配列をエクスポートすると仮定します。 たとえば、&lt;code&gt;./zh/messages&lt;/code&gt;には次のメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target>&lt;code&gt;__dirname&lt;/code&gt;が&lt;code&gt;import.meta&lt;/code&gt;で常に使用可能であると仮定すると、宣言は&lt;code&gt;ImportMeta&lt;/code&gt;インタフェースを再度開くことによって行われます。</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target>&lt;code&gt;document&lt;/code&gt;や&lt;code&gt;window&lt;/code&gt;のようなDOMプリミティブが存在するという仮定</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target>たとえば、&lt;em&gt;type&lt;/em&gt;リストと&lt;em&gt;value&lt;/em&gt;リストの両方に、&lt;code&gt;class&lt;/code&gt;が表示されています。 宣言&lt;code&gt;クラスC{}&lt;/code&gt;は、クラスのインスタンス形状を参照する&lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt;と、クラスのコンストラクタ関数を参照する&lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt;の2つのものを作成します。 enum宣言も同様に動作します。</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes">
          <source>Async Generators</source>
          <target>非同期ジェネレータ</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes">
          <source>Async Iteration</source>
          <target>非同期反復</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes">
          <source>Async iterators</source>
          <target>非同期反復子</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target>コアでは、オプションの連鎖によって、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;に遭遇した場合に、TypeScriptがすぐにいくつかの式の実行を停止できるコードを書くことができます。オプションの連鎖におけるshowのスターは、&lt;em&gt;オプションのプロパティアクセス&lt;/em&gt;に対する新しい&lt;code&gt;.&lt;/code&gt;演算子です。</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes">
          <source>At the command line, run the TypeScript compiler:</source>
          <target>コマンドラインでTypeScriptコンパイラを実行します。</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target>この時点で、プロジェクトのルートで&lt;code&gt;tsc&lt;/code&gt;を実行すると、&lt;code&gt;built&lt;/code&gt;ディレクトリに出力ファイルが表示されます。 &lt;code&gt;built&lt;/code&gt;内のファイルのレイアウトは、&lt;code&gt;src&lt;/code&gt;のレイアウトと同じになるはずです。これで、プロジェクトでTypeScriptを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target>この時点で、コンパイラは&amp;ldquo;what&amp;rsquo;s the shape of&lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo;を確認します。これは簡単に聞こえるかもしれませんが、&lt;code&gt;moduleA&lt;/code&gt;は、独自の&lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt;ファイルの1つ、またはコードが依存する&lt;code&gt;.d.ts&lt;/code&gt;で定義できます。</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target>この時点で、TypeScriptファイルを使い始める準備ができているはずです。 最初の手順は、&lt;code&gt;.js&lt;/code&gt;ファイルの1つを&lt;code&gt;.ts&lt;/code&gt;に名前変更することです。ファイルがJSXを使用している場合は、&lt;code&gt;.tsx&lt;/code&gt;に名前変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes">
          <source>Attribute type checking</source>
          <target>属性タイプのチェック</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes">
          <source>Augmenting global/module scope from modules</source>
          <target>モジュールからのグローバル/モジュール範囲の拡張</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes">
          <source>Automatically set to PreferredUILang value</source>
          <target>自動的にPreferredUILang値に設定する</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes">
          <source>Babel</source>
          <target>バベル</target>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target>Babelは、ES2015以降をES5とES3に変換する非常に柔軟なコンパイラです。 これにより、TypeScriptでサポートされていない広範でカスタマイズされた変換を追加できます。</target>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target>Babel&amp;rsquo;のES5出力は、このような単純なスクリプトに対するTypeScript&amp;rsquo;の出力と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target>TypeScriptが公開クラスのフィールドを実装したとき、私たちは以下のコードができる限りのことをすると仮定しました。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes">
          <source>Background</source>
          <target>背景</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes">
          <source>Bare Import</source>
          <target>ベアインポート</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes">
          <source>Base URL</source>
          <target>ベースURL</target>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes">
          <source>Base directory to resolve non-relative module names. See &lt;a href="module-resolution#base-url"&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target>相対的でないモジュール名を解決するためのベースディレクトリ。詳細については、&lt;a href="module resolution#baseurl"&gt;モジュール解決のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent"&gt;UIEvent&lt;/a&gt;, and not a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target>上記の関数が&lt;code&gt;Window.onscroll&lt;/code&gt;に割り当てられているという事実に基づき、Typescriptは&lt;code&gt;uiEvent&lt;/code&gt;が&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent"&gt;UIEvent&lt;/a&gt;であり、前の例のような&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"&gt;MouseEvent&lt;/a&gt;ではないことを認識します。 &lt;code&gt;UIEvent&lt;/code&gt;オブジェクトには&lt;code&gt;button&lt;/code&gt;プロパティが含まれていないため、Typescriptはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes">
          <source>Basic Concepts</source>
          <target>基本概念</target>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes">
          <source>Basic Gruntfile.js</source>
          <target>基本的なGruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes">
          <source>Basic Types</source>
          <target>基本型</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes">
          <source>Basic Types: Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes">
          <source>Basic Types: Array</source>
          <target state="translated">配列</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes">
          <source>Basic Types: Enum</source>
          <target state="translated">列挙型</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes">
          <source>Basic Types: Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes">
          <source>Basic Types: Tuple</source>
          <target state="translated">タプル</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes">
          <source>Basic Types: Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes">
          <source>Basic Usage</source>
          <target>基本的な使用方法</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes">
          <source>Basic gulpfile.js</source>
          <target>基本的なガルプフィル.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes">
          <source>Basic usage</source>
          <target>基本的な使用方法</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target>Web pack1使用時の基本webpack.config.js</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target>Web pack2使用時の基本webpack.config.js</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes">
          <source>Basics</source>
          <target>基本</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes">
          <source>Be sure to read the &lt;a href="#the-impact-of-es6-on-module-plugins"&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target>&lt;a href="#the impact of es6on module plugins"&gt;脚注&amp;ldquo;The Impact of ES6on Module Call Signatures&amp;rdquo;&lt;/a&gt;を必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes">
          <source>Because &lt;a href="https://en.wikipedia.org/wiki/Open/closed_principle"&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target>&lt;a href="https://en.wikipedia.org/wiki/Open/closed_principle"&gt;ソフトウェアの理想的な特性は、拡張に対してオープンである&lt;/a&gt;ため、可能であれば常にタイプエイリアス上のインターフェイスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target>&lt;code&gt;Dog&lt;/code&gt;は&lt;code&gt;Animal&lt;/code&gt;の機能を拡張しているため、&lt;code&gt;bark()&lt;/code&gt;と&lt;code&gt;move()&lt;/code&gt;の両方を実行できる&lt;code&gt;Dog&lt;/code&gt;のインスタンスを作成できました。</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target>&lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;の最初のパラメータは&lt;code&gt;ClockConstructor&lt;/code&gt;型であるため、&lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;では、&lt;code&gt;AnalogClock&lt;/code&gt;に正しいコンストラクタシグネチャがあるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target>&lt;code&gt;haveMuscles&lt;/code&gt;はエクスポートされないため、シンボルを表示できるのは、マージされていない同じ名前空間を共有する&lt;code&gt;animalsHaveMuscles&lt;/code&gt;関数だけです。 &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt;関数は、マージされた&lt;code&gt;Animal&lt;/code&gt;名前空間の一部であるにもかかわらず、エクスポートされていないメンバを参照できません。</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target>&lt;code&gt;never&lt;/code&gt;はすべての型のサブタイプであるため、常にユニオン型から省略され、他の型が返される限り関数の戻り値型推論では無視されます。</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target>&lt;code&gt;never&lt;/code&gt;はすべての型に割り当てることができるので、特定の型を返すコールバックが必要な場合は、&lt;code&gt;never&lt;/code&gt;を返す関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target>&lt;code&gt;onClickGood&lt;/code&gt;は&lt;code&gt;この&lt;/code&gt;型を&lt;code&gt;void&lt;/code&gt;と指定しているので、&lt;code&gt;addClickListener&lt;/code&gt;に渡すことができます。 もちろん、これは&lt;code&gt;this.info&lt;/code&gt;を使用できないことも意味します。両方を使用する場合は、次のように矢印関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target>TypeScriptは構造タイプシステムであるため、タイプパラメータは、メンバのタイプの一部として使用されるときに、結果のタイプにのみ影響します。 たとえば</target>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target>TypeScriptは、&lt;code&gt;この&lt;/code&gt;を返す&lt;code&gt;BasicCalculator&lt;/code&gt;内の各メソッドの型&lt;code&gt;BasicCalculator&lt;/code&gt;を推測するために使用されるので、型システムは、&lt;code&gt;BasicCalculator&lt;/code&gt;メソッドを使用するときは常に&lt;code&gt;ScientificCalculator&lt;/code&gt;を持っていたことを忘れます。</target>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target>関数コンポーネントは単なるJavaScript関数なので、ここでも関数オーバーロードを使用できます。</target>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target>依存プロジェクトでは、依存関係から構築された&lt;code&gt;.d.ts&lt;/code&gt;ファイルを使用するため、誤ったエラーが表示されないように、プロジェクトをエディタでナビゲートする前に、特定の構築出力をチェックインするか、クローン後にプロジェクトを構築する必要があります。&lt;em&gt;。 これを軽減できるような舞台裏の.d.ts生成プロセスに取り組んでいますが、現時点では、開発者に対してクローニング後に構築するように通知することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target>各&lt;code&gt;一意のシンボル&lt;/code&gt;は完全に別個のIDを持つため、2つの&lt;code&gt;一意のシンボル&lt;/code&gt;タイプを割り当てたり、互いに比較したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target>インターフェース(およびその他のオブジェクト型)はあるレベルの間接化を導入し、その完全な構造を熱心に構築する必要がないため、TypeScriptはこの構造を扱うのに問題はありません。</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target>通常、グローバルライブラリをUMDライブラリに変換するのは簡単であるため、グローバル形式で作成されている一般的なライブラリはほとんどありません。 ただし、サイズが小さくDOMを必要とする(または依存関係が&lt;em&gt;存在しない&lt;/em&gt;)ライブラリは、グローバルである可能性があります。</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target>そのため、既定では標準ライブラリに含まれています。</target>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target>&lt;code&gt;switch&lt;/code&gt;は完全ではなくなったため、TypeScriptは関数が&lt;code&gt;undefined&lt;/code&gt;を返す場合があることを認識しています。明示的な戻り型&lt;code&gt;number&lt;/code&gt;がある場合は、戻り型が実際には&lt;code&gt;number undefined&lt;/code&gt;であるというエラーが発生します。ただし、このメソッドは非常に微妙であり、また、&lt;code&gt;-strictNullChecks&lt;/code&gt;が古いコードで常に動作するとは限りません。</target>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target>提供された候補型の中から最適な共通型を選択する必要があるため、型が共通の構造を共有する場合がありますが、すべての候補型のスーパー型が1つの型ではない場合があります。 例:</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target>ジェネリック関数がコンストレインされたので、すべてのタイプで機能しなくなります。</target>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target>JSX式では、これら2つのタイプの値ベースの要素は互いに区別できないため、最初のTSは、オーバーロードの解決を使用して、式を関数コンポーネントとして解決しようとします。 処理が成功すると、TSは式を宣言に解決します。 値が関数コンポーネントとして解決できない場合、TSはその値をクラスコンポーネントとして解決しようとします。 これが失敗すると、TSはエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target>環境内から&lt;code&gt;city&lt;/code&gt;をキャプチャしたので、&lt;code&gt;if&lt;/code&gt;ブロックの実行が終了したにもかかわらず、&lt;code&gt;city&lt;/code&gt;にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target>ES2015以前は、Javascriptはクラスではなくコンストラクタ関数を使用していました。 コンパイラはこのパターンをサポートしており、コンストラクタ関数はES2015クラスと同等であると認識します。 上記のプロパティ推論規則は、まったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from "./moduleA.js"&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;"moduleA.js"&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href="https://github.com/systemjs/systemjs"&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target>TypeScript2.0以前では、モジュール識別子は常に拡張なしと想定されていました。例えば、"./moduleA.js"&lt;/code&gt;から&lt;code&gt;import dとしてインポートされた場合、コンパイラは&lt;code&gt;./moduleA.js.ts&lt;/code&gt;または&lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;の&lt;code&gt;"moduleA.js"&lt;/code&gt;の定義を参照していました。そのため、URI&amp;rsquo;を期待する&lt;a href="https://github.com/systemjs/systemjs"&gt;SystemJS&lt;/a&gt;のようなツールをバンドル/ロードすることが困難になりました。</target>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target>Browserifyに行く前に、&amp;rsquo;sがコードをビルドして、モジュールをミックスに追加しましょう。 これは、実際のアプリケーションで使用する可能性が高い構造です。</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target>&lt;code&gt;n&lt;/code&gt;と&lt;code&gt;m&lt;/code&gt;の値は決して&lt;em&gt;read&lt;/em&gt;されないので、両方とも未使用としてマークされます。 以前のTypeScriptでは、値が&lt;em&gt;参照されているかどうかをチェックするだけでした。</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target>以下では、前の例で使用したバリデータ実装を統合して、各モジュールから1つの名前付きエクスポートのみをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes">
          <source>Best common type</source>
          <target>最も一般的なタイプ</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes">
          <source>Better Module Visibility Rules</source>
          <target>モジュール可視性ルールの改善</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target>&lt;code&gt;never&lt;/code&gt;-Returning Functionsのサポート強化</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes">
          <source>Better Type Inference</source>
          <target>より良い型推論</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes">
          <source>Better Unicode Support for Identifiers</source>
          <target>識別子のユニコード・サポートの改善</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target>式のオペランドで&lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;をチェックする機能が向上</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target>&lt;code&gt;.js&lt;/code&gt;ファイルの名前空間パターンの処理を改善</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes">
          <source>Better inference for literal types</source>
          <target>リテラル型に対するより良い推論</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes">
          <source>BigInt</source>
          <target>BigInt型</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target>TypeScriptのBigIntサポートは、&lt;code&gt;bigint&lt;/code&gt;(すべて小文字)と呼ばれる新しいプリミティブ型を導入する。 &lt;code&gt;bigint&lt;/code&gt;を取得するには、&lt;code&gt;BigInt()&lt;/code&gt;関数を呼び出すか、任意の整数リテラルの末尾に&lt;code&gt;n&lt;/code&gt;を追加してBigIntリテラルを記述します。</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target>BigIntsは、ECMAScriptの今後の提案の一部であり、理論的に任意の大きさの整数をモデル化することができる。 TypeScript3.2では、BigIntの型チェックと&lt;code&gt;esnext&lt;/code&gt;をターゲットにしたときのBigIntリテラルの発行をサポートしている。</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes">
          <source>Block scoped</source>
          <target>ブロック範囲</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes">
          <source>Block-scoped variable capturing</source>
          <target>ブロックスコープ変数の取得</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes">
          <source>Block-scoping</source>
          <target>ブロックスコープ</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target>&lt;code&gt;for.of&lt;/code&gt;ステートメントと&lt;code&gt;for.in&lt;/code&gt;ステートメントは、どちらもリストを反復します。反復される値は異なりますが、&lt;code&gt;for.in&lt;/code&gt;は、反復されるオブジェクトの&lt;em&gt;キー&lt;/em&gt;のリストを返し、&lt;code&gt;for.of&lt;/code&gt;は、反復されるオブジェクトの数値プロパティの&lt;em&gt;値&lt;/em&gt;のリストを返します。</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target>一般に、CommonJSとAMDはどちらも、モジュールからのすべてのエクスポートを含む&lt;code&gt;exports&lt;/code&gt;オブジェクトという概念を持っています。</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target>これらの依存関係はどちらも、TypeScriptとwebpackをうまく連携させます。 ts loaderは、&lt;code&gt;tsconfig.json&lt;/code&gt;という名前のTypeScriptの標準構成ファイルを使用してTypeScriptコードをコンパイルするのに役立ちます。 ソースマップローダーは、TypeScriptからのソースマップ出力を使用して、&lt;em&gt;自身の&lt;/em&gt;ソースマップを生成するときにWebpackに通知します。 これにより、オリジナルのTypeScriptソースコードをデバッグしているかのように、最終出力ファイルをデバッグできます。</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes">
          <source>Breaking Changes</source>
          <target>変更の分割</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target>大まかに言うと、宣言ファイルを&lt;em&gt;構造化&lt;/em&gt;する方法は、ライブラリの使用方法によって異なります。 JavaScriptで使用するためのライブラリーを提供する方法は数多くあり、それに合わせて宣言ファイルを作成する必要があります。 このガイドでは、共通のライブラリパターンを識別する方法と、そのパターンに対応する宣言ファイルを作成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes">
          <source>Browserify</source>
          <target>ブラウザ化</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes">
          <source>Build Mode for TypeScript</source>
          <target>TypeScriptのビルドモード</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target>ビルドモード(以下を参照)は、必要に応じて参照されるプロジェクトを自動的にビルドします。</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes">
          <source>Build out-of-date projects in the correct order</source>
          <target>古いプロジェクトを正しい順序で作成する</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes">
          <source>Build tools</source>
          <target>構築ツール</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes">
          <source>Build-Free Editing with Project References</source>
          <target>プロジェクト参照を使用したフリー編集の構築</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target>その成果を基にして、新しい&lt;code&gt;Generator&lt;/code&gt;型は&lt;code&gt;Iterator&lt;/code&gt;であり、常に&lt;code&gt;return&lt;/code&gt;メソッドと&lt;code&gt;throw&lt;/code&gt;メソッドの両方が存在し、これもまた由緒あるものです。</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes">
          <source>Building your first TypeScript file</source>
          <target>最初のTypeScriptファイルを作成する</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes">
          <source>Builds this project and all of its dependencies specified by &lt;a href="project-references"&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href="project-references"&gt;here&lt;/a&gt;</source>
          <target>このプロジェクトと、&lt;a href="project-references"&gt;Project References&lt;/a&gt;で指定されたすべての依存関係をビルドします。このフラグは、このページの他のフラグと互換性がないことに注意してください。詳細については、&lt;a href="project-references"&gt;ここ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;"lib"&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib="es2015"&lt;/code&gt; and not &lt;code&gt;lib="lib.es2015.d.ts"&lt;/code&gt;, etc.).</source>
          <target>組み込みの&lt;em&gt;lib&lt;/em&gt;ファイルは、&lt;em&gt;tsconfig.json&lt;/em&gt;の&lt;code&gt;"lib"&lt;/code&gt;コンパイラオプションと同じ方法で参照されます(たとえば、&lt;code&gt;lib="lib.es2015.d.ts"&lt;/code&gt;ではなく&lt;code&gt;lib="es2015"&lt;/code&gt;を使用するなど)。</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes">
          <source>Built-in Combinations</source>
          <target>組み込みの組み合わせ</target>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target>&lt;em&gt;ではなく&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target>しかし、条件付き型が遅延される場所の例として、分岐を選択する代わりに固定される場所を次に示します。</target>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target>ただし、一般的なバージョンがあると便利です。</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target>しかし、パラメータにはデフォルトを指定する方が一般的であり、構造化を解除してデフォルトを正しく取得するのは難しい場合があります。 まず、デフォルト値の前にパターンを置くことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target>しかし、このインターフェースを導入するという回避策は、ユーザーにとって直感的ではなかった。 そして原則として、&lt;code&gt;Array&lt;/code&gt;を直接使用した&lt;code&gt;ValueOrArray&lt;/code&gt;の元のバージョンには、何も問題はありません。 コンパイラが少しばかりの&amp;ldquo;lazier&amp;rdquo;で、必要なときに&lt;code&gt;Array&lt;/code&gt;への型引数だけを計算した場合、TypeScriptはこれらを正しく表現できます。</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes">
          <source>By Example</source>
          <target>例</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes">
          <source>By Example: Classes</source>
          <target>例:クラス</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes">
          <source>By Example: Global Functions</source>
          <target>例:グローバル関数</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes">
          <source>By Example: Global Variables</source>
          <target>例:グローバル変数</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes">
          <source>By Example: Objects with Properties</source>
          <target>例:プロパティを持つオブジェクト</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes">
          <source>By Example: Organizing Types</source>
          <target>例:タイプの編成</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes">
          <source>By Example: Overloaded Functions</source>
          <target>例:オーバーロードされた関数</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target>例:再利用可能な型(インタフェース)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target>例:再利用可能な型(型別名)</target>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target>デフォルトでは、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;は、他のすべてのタイプのサブタイプです。 つまり、&lt;code&gt;number&lt;/code&gt;のようなものに&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target>デフォルトでは、AMDモジュールは匿名で生成されます。 これは、他のツールを使って、バンドラー(例えば、&lt;code&gt;r.js&lt;/code&gt;)のような結果のモジュールを処理する場合に問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target>デフォルトでは、AMDモジュールは匿名で生成されます。 これは、他のツール(例えば、&lt;code&gt;r.js&lt;/code&gt;)を使用して、結果として得られるモジュールを処理する場合に問題になる可能性がある。</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target>デフォルトでは、すべての&lt;em&gt;visible&lt;/em&gt;&amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo;パッケージがコンパイルに含まれます。 &lt;code&gt;node_modules/@types&lt;/code&gt;内のパッケージは、&lt;em&gt;可視&lt;/em&gt;と見なされます。具体的には、&lt;code&gt;内のパッケージを意味します。/node_modules/@types/&lt;/code&gt;、&lt;code&gt;././node_modules/@types/&lt;/code&gt;、&lt;code&gt;././node_modules/@types/&lt;/code&gt;などです。</target>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target>デフォルトでは、TypeScriptコンパイラは、&lt;code&gt;--allowJs&lt;/code&gt;の使用を含む.jsファイルのエラーを報告しません。TypeScript2.3では、&lt;code&gt;--checkJs&lt;/code&gt;を含む&lt;code&gt;.js&lt;/code&gt;ファイルでも型チェックエラーを報告できます。</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target>デフォルトでは、出力の改行文字は、Windowsベースのシステムでは&lt;code&gt;\r\n&lt;/code&gt;、*nixベースのシステムでは&lt;code&gt;\n&lt;/code&gt;です。 &lt;code&gt;--NewLine&lt;/code&gt;コマンド・ライン・フラグを使用すると、この動作を上書きして、生成された出力ファイルで使用する新しい行文字を指定できます。</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target>デフォルトでは、JSX式の結果は&lt;code&gt;any&lt;/code&gt;と入力されます。&lt;code&gt;JSX.Element&lt;/code&gt;インタフェースを指定して、型をカスタマイズできます。 ただし、このインタフェースからJSXの要素、属性、または子に関するタイプ情報を取得することはできません。 ブラックボックスだ。</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target>デフォルトでは、関数内の&lt;code&gt;this&lt;/code&gt;の型は&lt;code&gt;any&lt;/code&gt;です。 TypeScript2.0以降では、&lt;code&gt;この&lt;/code&gt;パラメータを明示的に指定できます。 &lt;code&gt;この&lt;/code&gt;パラメータは、関数のパラメータリストの先頭にあるフェイクパラメータです。</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target>デフォルトでは、これらの設定で&lt;code&gt;tsc&lt;/code&gt;を実行すると、TypeScriptは&lt;code&gt;.ツバイルドインフォ&lt;/code&gt;というファイルを出力ディレクトリ(&lt;code&gt;./lib&lt;/code&gt;)で検索します。 &lt;code&gt;./lib/.ツバイルドインフォ&lt;/code&gt;が存在しない場合は、&amp;rsquo;が生成されます。 しかし、そうであれば、&lt;code&gt;tsc&lt;/code&gt;はそのファイルを使用して、インクリメンタルな型チェックと出力ファイルの更新を試みます。</target>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target>デフォルトでは、TypeScriptは&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;がすべての型のドメインにあると想定します。 つまり、型&lt;code&gt;number&lt;/code&gt;で宣言されたものは、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;である可能性があります。&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;は、JavaScriptおよびTypeScriptで頻繁に発生するバグの原因であるため、TypeScriptには&lt;code&gt;strictNullChecks&lt;/code&gt;オプションがあり、これらの問題を心配する必要がありません。</target>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target>デフォルトでは、列挙型は&lt;code&gt;0&lt;/code&gt;から始まるメンバーの番号付けを開始します。これは、メンバーのいずれかの値を手動で設定することで変更できます。 たとえば、&lt;code&gt;0&lt;/code&gt;ではなく&lt;code&gt;1&lt;/code&gt;から前の例を開始できます。</target>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target>こうすることで、ビルド時間を大幅に短縮し、コンポーネント間の論理的な分離を強制し、コードを新しくより良い方法で編成することができます。</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target>TypeScriptのVisual Studioプラグインをインストールする</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target>入力ファイルなしでtscを呼び出し、tsconfig.jsonファイルを含むディレクトリーのパスを指定する-project(または単に-p)コマンド行オプションを呼び出す。</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target>入力ファイルなしでtscを呼び出し、&lt;code&gt;--project&lt;/code&gt;(または単に&lt;code&gt;-p&lt;/code&gt;)コマンドラインオプションを使用して、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを含むディレクトリのパス、または構成を含む有効な&lt;code&gt;.json&lt;/code&gt;ファイルのパスを指定します。</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target>入力ファイルを指定せずにtscを起動すると、コンパイラは現在のディレクトリから始まる&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを検索し、親のディレクトリチェーンを続けます。</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target>入力ファイルを指定せずにtscを呼び出すと、コンパイラーはtsconfig.jsonファイルを現在のディレクトリーから検索し、親ディレクトリー・チェーンを継続します。</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target>&lt;code&gt;--pretty&lt;/code&gt;コマンドラインオプションを渡すだけで、TypeScriptはどこが悪いのかというコンテキストで、よりカラフルな出力を提供する。</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>&lt;code&gt;rootDirs&lt;/code&gt;を利用することで、コンパイラにこのマッピングを通知し、ディレクトリが存在しない場合でも、コンパイラが&lt;code&gt;./#{locale}/messages&lt;/code&gt;を安全に解決できるようになります。 たとえば、次の&lt;code&gt;tsconfig.json&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target>&lt;code&gt;var&lt;/code&gt;にいくつかの問題があることがわかったので、&lt;code&gt;let&lt;/code&gt;ステートメントが導入されました。 使用されるキーワードを除き、&lt;code&gt;let&lt;/code&gt;ステートメントは&lt;code&gt;var&lt;/code&gt;ステートメントと同じように記述されます。</target>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target>このガイドを読むことで、分かりやすいAPIサーフェスを公開する複雑な定義ファイルを作成するツールを使用できます。 このガイドでは、モジュール(またはUMD)ライブラリに焦点を当てています。これは、ここでのオプションがより多様であるためです。</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target>複数のプロジェクトに分割することで、型チェックとコンパイルの速度が大幅に向上し、エディタを使用するときのメモリ使用量が削減され、プログラムの論理グループ化の実行が改善されます。</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target>ところで、いくつかの言語(例えばC#やScala)はバリアンスアノテーション(&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;または&lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;)を必要とするが、バリアンスはTypeScriptの構造型システムのために、ジェネリック型の中で型パラメータを実際に使用することから自然に現れる。</target>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes">
          <source>Cache tagged template objects in modules</source>
          <target>タグ付きテンプレートオブジェクトをモジュールにキャッシュする</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes">
          <source>Callback Types</source>
          <target>コールバックの種類</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target>&lt;code&gt;showHello&lt;/code&gt;を呼び出すと、&lt;code&gt;sayHello&lt;/code&gt;が呼び出され、段落のテキストが変更されます。 ガルプフィルを次のように変更します。</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target>&lt;code&gt;define(...)&lt;/code&gt;の呼び出し</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target>モジュール以外のファイル&lt;code&gt;global script.ts&lt;/code&gt;で使用できます。</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes">
          <source>Case clause fall-throughs</source>
          <target>Case句の適用範囲</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes">
          <source>Casts</source>
          <target>キャスト</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes">
          <source>Caveats</source>
          <target>警告</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes">
          <source>Caveats for Project References</source>
          <target>プロジェクト参照に関する注意事項</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target>特定のターゲットには、PolyfillまたはBigIntのようなランタイムオブジェクトが含まれます。 そのためには、コンパイラオプションの&lt;code&gt;lib&lt;/code&gt;設定に&lt;code&gt;esnext.bigint&lt;/code&gt;を追加します。</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes">
          <source>Changes include:</source>
          <target>変更点は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">Changes to &lt;code&gt;@types/React&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target>実装ファイルの&lt;em&gt;内部&lt;/em&gt;のみを変更するには、新しいエラーが発生しない場合でも、テストを再度タイプチェックする必要がありました。&lt;em&gt;</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target>テストだけを変更するには、何も変更されていない場合でも、実装を再度タイプチェックする必要がありました。</target>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target>&lt;code&gt;require&lt;/code&gt;や&lt;code&gt;define&lt;/code&gt;のようなモジュールローダのチェックや使用</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes">
          <source>Children Type Checking</source>
          <target>子の型チェック</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target>&lt;strong&gt;File&lt;/strong&gt;を選択します。</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target>&lt;strong&gt;New Project&lt;/strong&gt;を選択します(Ctrl+Shift+N)。</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target>&amp;ldquo;insert&amp;rdquo;または&amp;ldquo;remove&amp;rdquo;の値を選択すると、自動インポートの形式、抽出されるタイプ、およびTypeScriptサービスによって提供されるその他の生成されるコードにも影響します。 デフォルト値の&amp;ldquo;ignore&amp;rdquo;の設定をそのままにしておくと、生成されるコードが現在のファイルで検出されたセミコロンプリファレンスに一致します。</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes">
          <source>Circularity between configuration files is not allowed.</source>
          <target>構成ファイル間の循環は許可されていません。</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes">
          <source>Class</source>
          <target>クラス</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes">
          <source>Class Component</source>
          <target>クラスコンポーネント</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes">
          <source>Class Decorators</source>
          <target>クラス修飾子</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes">
          <source>Class Field Mitigations</source>
          <target>クラスフィールド緩和</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes">
          <source>Class Types</source>
          <target>クラスタイプ</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes">
          <source>Class expressions</source>
          <target>クラス式</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes">
          <source>Classes</source>
          <target>クラス</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target>クラスと関数の宣言は、デフォルトのエクスポートとして直接作成できます。 デフォルトのエクスポート・クラス名と関数宣言名はオプションです。</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target>クラスは&lt;code&gt;.js&lt;/code&gt;ファイルの名前空間です。 これは、次のようにクラスをネストするために使用できます。</target>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target>クラスは、静的型とインスタンス型の両方を持つという1つの例外を除いて、オブジェクトリテラル型とインターフェースと同様に動作します。 クラスタイプの2つのオブジェクトを比較する場合、インスタンスのメンバーのみが比較されます。 静的メンバーとコンストラクタは互換性に影響しません。</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes">
          <source>Classes, functions, and object literals are namespaces</source>
          <target>クラス、関数、オブジェクトリテラルは名前空間</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes">
          <source>Classic</source>
          <target>クラシック</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target>&lt;code&gt;--watch&lt;/code&gt;モードでのクリーナ出力</target>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes">
          <source>Code Generation for Modules</source>
          <target>モジュールのコード生成</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes">
          <source>Code generation</source>
          <target>コード生成</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target>クラスフィールドの変更によって影響を受けるコードは、フィールド初期化子をコンストラクタ本体の代入に変換することによって、この問題を回避できます。</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes">
          <source>Colorization of JSX code in VS 2015</source>
          <target>VS2015でのJSXコードのカラー化</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes">
          <source>Comma-separated list of strings</source>
          <target>文字列のコンマ区切りリスト</target>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes">
          <source>Common Questions</source>
          <target>よくある質問</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes">
          <source>CommonJS / Node SimpleModule.js</source>
          <target>CommonJS/Node SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes">
          <source>CommonJS modules are supported</source>
          <target>CommonJSモジュールをサポート</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require("fs");&lt;/code&gt;</source>
          <target>&lt;code&gt;var fs=require("fs");&lt;/code&gt;形式のCommonJS/Node.js形式のインポート</target>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes">
          <source>Comparing two functions</source>
          <target>2つの関数の比較</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes">
          <source>Compatibility</source>
          <target>互換性</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes">
          <source>Compile a project given a valid configuration file.</source>
          <target>有効な構成ファイルを指定してプロジェクトをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes">
          <source>Compiled with:</source>
          <target>コンパイル時:</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes">
          <source>Compiler Option</source>
          <target>コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes">
          <source>Compiler Options</source>
          <target>コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes">
          <source>Compiler Options in MSBuild</source>
          <target>MSBuildのコンパイラオプション</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target>MSBuildのコンパイラオプション:マッピング</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target>MSBuildのコンパイラオプション:ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target>MSBuildのコンパイラオプション:TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target>コンパイラオプションは、MSBuildプロジェクト内のMSBuildプロパティを使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target>コマンドラインで指定されたコンパイラオプションは、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルで指定されたオプションよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target>コンパイラは、環境変数を使用したファイルとディレクトリの監視方法の設定をサポートしています。</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes">
          <source>Compiles to exactly:</source>
          <target>次のようにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target>&lt;code&gt;--noResolve&lt;/code&gt;を使用して&lt;code&gt;app.ts&lt;/code&gt;をコンパイルすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target>出力をコンパイルして実行すると、ES3/ES5エンジン上で正しく動作するはずです。</target>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes">
          <source>Compiling your code</source>
          <target>コードのコンパイル</target>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes">
          <source>Composite projects</source>
          <target>複合プロジェクト</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes">
          <source>Composition</source>
          <target>構成</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes">
          <source>Computed and constant members</source>
          <target>計算されるメンバーと定数メンバー</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes">
          <source>Computed properties</source>
          <target>計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target>&lt;code&gt;AMD&lt;/code&gt;および&lt;code&gt;System&lt;/code&gt;モジュールを&lt;code&gt;--outFile&lt;/code&gt;と連結する</target>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-"&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target>出力を連結して1つのファイルに出力します。 連結の順序は、コマンドラインでコンパイラに渡されるファイルのリストと、トリプルスラッシュ参照およびインポートによって決まります。詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-"&gt;出力ファイルの順序に関するドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target>概念的には、&lt;code&gt;[number,string]&lt;/code&gt;型は、&lt;code&gt;NumStrTuple&lt;/code&gt;の次の宣言と等価であると考えることができます。</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes">
          <source>Conditional Types</source>
          <target>条件タイプ</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target>条件タイプは、マップされたタイプと組み合わせると特に便利です。</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target>条件タイプをネストして、次の順序で評価される一連のパターンマッチを形成できます。</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target>チェック・タイプがネイキッド・タイプ・パラメータである条件タイプは、&lt;em&gt;分散条件タイプ&lt;/em&gt;と呼ばれます。 分散条件型は、インスタンス化中にユニオン型に自動的に分散されます。 たとえば、&lt;code&gt;T&lt;/code&gt;の型引数&lt;code&gt;A B C&lt;/code&gt;を持つ&lt;code&gt;T extends U?X:Y&lt;/code&gt;のインスタンス化は、&lt;code&gt;(A extends U?X:Y)(B extends U?X:Y)(C extends U?X:Y)&lt;/code&gt;として解決されます。</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes">
          <source>Configuration inheritance</source>
          <target>構成の継承</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target>&lt;code&gt;extends&lt;/code&gt;による設定の継承</target>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes">
          <source>Configuring Watch</source>
          <target>ウォッチポイントの設定</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes">
          <source>Configuring Watch: Background</source>
          <target>ウォッチポイントの設定:背景</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target>環境変数&lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;を使用したディレクトリ監視の設定</target>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target>環境変数&lt;code&gt;TSC_WATCHFILE&lt;/code&gt;を使用したファイル監視の設定</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target>紛らわしいことに、ここのコロンはタイプを示していません。 型を指定する場合は、全体を分解した後に型を記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target>TypeScriptフロントエンドで独自の.NET Coreプロジェクトを構築したことをお祝いします。</target>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target>新しい&lt;code&gt;HTMLElement&lt;/code&gt;を作成する関数を引数なしで呼び出すと、&lt;code&gt;Div&lt;/code&gt;が生成されます。オプションで子のリストを渡すこともできます。 これまでは、次のように定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target>モジュール&lt;code&gt;Calculator.ts&lt;/code&gt;で定義された単純な計算機の実装を考えてみます。このモジュールは、入力文字列のリストを渡して結果を最後に書き込むことで、計算機の機能をテストするヘルパー関数もエクスポートします。</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target>国際化対応のシナリオとして、ビルドツールが特殊なパストークン、たとえば&lt;code&gt;#{locale}&lt;/code&gt;を&lt;code&gt;./#{locale}/messages&lt;/code&gt;のような相対モジュールパスの一部として補間することによって、ロケール固有のバンドルを自動的に生成する場合を考えてみましょう。この仮想的な設定では、ツールはサポートされているロケールを列挙し、抽象化されたパスを&lt;code&gt;./zh/messages&lt;/code&gt;、&lt;code&gt;./de/messages&lt;/code&gt;などにマッピングします。</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target>次の例では、&lt;code&gt;Animal&lt;/code&gt;が&lt;code&gt;Dog&lt;/code&gt;および&lt;code&gt;Cat&lt;/code&gt;のスーパータイプであるとします。</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes">
          <source>Consider:</source>
          <target>考慮事項:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes">
          <source>Const</source>
          <target>定数</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target>const enumは、定数enum式のみを使用でき、通常のenumとは異なり、コンパイル時に完全に削除されます。 const enumメンバは、使用サイトでインライン化されます。 これは、constに計算されたメンバを持たせることができないためです。</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes">
          <source>Constant-named properties</source>
          <target>名前付き定数プロパティ</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes">
          <source>Constraints</source>
          <target>制約</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes">
          <source>Constructor functions</source>
          <target>コンストラクタ</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes">
          <source>Constructor functions are equivalent to classes</source>
          <target>コンストラクタ関数はクラスに相当します。</target>
        </trans-unit>
        <trans-unit id="509e1963e8574b2c7a76ebbd1378e3e921c56e2c" translate="yes">
          <source>ConstructorParameters&lt;T&gt;</source>
          <target>ConstructorParameters&lt;T&gt;</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target>関数型&lt;code&gt;T&lt;/code&gt;のパラメータ型のタプル型を構築します。</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target>&lt;code&gt;T&lt;/code&gt;から&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;を除外して型を構成します。</target>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target>&lt;code&gt;U&lt;/code&gt;に割り当てられるすべてのプロパティを&lt;code&gt;T&lt;/code&gt;から除外することによって型を構成します。</target>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target>&lt;code&gt;U&lt;/code&gt;に割り当てられるすべてのプロパティを&lt;code&gt;T&lt;/code&gt;から抽出して型を構成します。</target>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target>&lt;code&gt;T&lt;/code&gt;からすべてのプロパティを選択し、&lt;code&gt;K&lt;/code&gt;を削除してタイプを作成します。</target>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target>&lt;code&gt;T&lt;/code&gt;からプロパティ&lt;code&gt;K&lt;/code&gt;のセットを選択してタイプを作成します。</target>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target>&lt;code&gt;T&lt;/code&gt;のすべてのプロパティがrequiredに設定された型を構築する。</target>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target>コンストラクタ関数型&lt;code&gt;T&lt;/code&gt;のインスタンス型からなる型を構築する。</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target>関数&lt;code&gt;T&lt;/code&gt;の戻り型からなる型を構築する。</target>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target>&lt;code&gt;T&lt;/code&gt;型のプロパティ&lt;code&gt;K&lt;/code&gt;のセットを持つ型を作成します。このユーティリティを使用すると、型のプロパティを別の型にマップできます。</target>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target>&lt;code&gt;T&lt;/code&gt;のすべてのプロパティが&lt;code&gt;readonly&lt;/code&gt;に設定された型を構成します。つまり、構成された型のプロパティは再割り当てできません。</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target>&lt;code&gt;T&lt;/code&gt;のすべてのプロパティがoptionalに設定された型を構築する。 このユーティリティは、特定の型のすべてのサブセットを表す型を返します。</target>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes">
          <source>Consumer.ts</source>
          <target>コンシューマ.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target>エクスポートするものを使用するときは、モジュールのコンシューマにできるだけ摩擦がないようにする必要があります。 ネストのレベルを追加しすぎると面倒になるので、オブジェクトの構造を慎重に検討してください。</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes">
          <source>Consuming</source>
          <target>消費</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes">
          <source>Consuming Dependencies</source>
          <target>依存関係の使用</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes">
          <source>Consumption</source>
          <target>消込</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes">
          <source>Consumption: Consuming</source>
          <target>消込:消込</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes">
          <source>Consumption: Downloading</source>
          <target>消込:ダウンロード</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes">
          <source>Consumption: Searching</source>
          <target>消込:検索</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes">
          <source>Contextual Typing</source>
          <target>コンテキストに応じた入力</target>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target>コンテキスト型付けは多くの場合に適用されます。 一般的なケースには、関数呼び出しの引数、代入の右側、型アサーション、オブジェクトリテラルと配列リテラルのメンバー、およびreturn文があります。 コンテキスト型は、最も一般的な型の候補としても機能します。 例:</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes">
          <source>Control flow analysis errors</source>
          <target>制御フロー解析エラー</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes">
          <source>Control flow based type analysis</source>
          <target>制御フロー型解析</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target>ヌル可能な型はユニオン型を使って表現されるので、制御フローベースの型分析は&lt;code&gt;--strictNullChecks&lt;/code&gt;モードで特に重要です。</target>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes">
          <source>Conversely when importing:</source>
          <target>逆にインポートする場合:</target>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target>コマンドラインで渡された&lt;code&gt;moduleA&lt;/code&gt;を正しく検出する。</target>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target>&lt;code&gt;@types/React&lt;/code&gt;の&lt;code&gt;JSX&lt;/code&gt;名前空間に&lt;code&gt;LibraryManagedAttributes&lt;/code&gt;定義を追加するために、対応する変更がまだ必要である。 いくつかの制限があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target>&lt;code&gt;ガルプフィル.js&lt;/code&gt;を作成する</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target>プロジェクトディレクトリのルートに&lt;code&gt;webpack.config.js&lt;/code&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target>&lt;code&gt;src/greet.ts&lt;/code&gt;という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target>&lt;code&gt;src&lt;/code&gt;に&lt;code&gt;index.html&lt;/code&gt;という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes">
          <source>Create a new project</source>
          <target>新しいプロジェクトを作成する</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes">
          <source>Create a page</source>
          <target>ページを作成する</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes">
          <source>Create a webpack configuration file</source>
          <target>Web Pack設定ファイルを作成する</target>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target>現在、&lt;code&gt;useDefineForClassFields&lt;/code&gt;はES5以降をターゲットにしている場合にのみ使用できます。これは、&lt;code&gt;Object.defineProperty&lt;/code&gt;がES3に存在しないためです。 同様の問題チェックを行うには、ES5をターゲットとし、&lt;code&gt;--noEmit&lt;/code&gt;を使用して完全ビルドを回避する別個のプロジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target>&lt;code&gt;--reactNamespace&lt;/code&gt;を使用するカスタムJSXファクトリー</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes">
          <source>D3.d.ts (simplified excerpt)</source>
          <target>D3.d.ts(抜粋)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target>非推奨。 代わりに&lt;code&gt;--jsxFactory&lt;/code&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target>非推奨。 代わりに&lt;code&gt;--outFile&lt;/code&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target>非推奨。 代わりに&lt;code&gt;--skipLibCheck&lt;/code&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes">
          <source>DOM Changes</source>
          <target>DOMの変更</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes">
          <source>Debug</source>
          <target>デバッグ</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes">
          <source>Declaration Files</source>
          <target>宣言ファイル</target>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes">
          <source>Declaration Merging</source>
          <target>宣言のマージ</target>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes">
          <source>Declaration Type</source>
          <target>宣言タイプ</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes">
          <source>Declarations</source>
          <target>宣言</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target>宣言は、初期化子がなくても&lt;em&gt;常に&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;に初期化されます。</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target>宣言は&lt;code&gt;Object.defineProperty&lt;/code&gt;で初期化されます。</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target>&lt;code&gt;import*as a from'b';&lt;/code&gt;または&lt;code&gt;export c;&lt;/code&gt;のような宣言</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes">
          <source>Declare the properties if they really do exist.</source>
          <target>プロパティが実際に存在する場合は、プロパティを宣言します。</target>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target>JavaScriptで変数を宣言するには、&lt;code&gt;var&lt;/code&gt;キーワードを使用します。</target>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target>&lt;code&gt;void&lt;/code&gt;型の変数を宣言することは、&lt;code&gt;null&lt;/code&gt;(&lt;code&gt;--strictNullChecks&lt;/code&gt;が指定されていない場合のみ、次のセクションを参照)または&lt;code&gt;undefined&lt;/code&gt;をそれらに割り当てることができるため、役に立ちません。</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes">
          <source>Decorator Composition</source>
          <target>デコレータ構成</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes">
          <source>Decorator Evaluation</source>
          <target>デコレータ評価</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes">
          <source>Decorator Factories</source>
          <target>デコレーターファクトリー</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes">
          <source>Decorators</source>
          <target>デコレーター</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target>デコレータ&lt;code&gt;readonly&lt;/code&gt;および&lt;code&gt;enumerable(false)&lt;/code&gt;は、クラス&lt;code&gt;C&lt;/code&gt;にインストールされる前に、プロパティ&lt;code&gt;メソッド&lt;/code&gt;に適用されます。これにより、デコレータは実装を変更できます。この場合、記述子を書き込み可能:falseおよび列挙可能:falseに追加します。</target>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target>ES3をターゲットとする場合にデコレータを使用できるようになりました。 TypeScript1.7は、ES5固有の&lt;code&gt;reduceRight&lt;/code&gt;の使用を&lt;code&gt;_decord&lt;/code&gt;ヘルパーから削除する。 この変更により、&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;および&lt;code&gt;Object.defineProperty&lt;/code&gt;も下位互換性のある方法でインラインコールされ、前述の&lt;code&gt;Object&lt;/code&gt;メソッドへのさまざまな繰り返しコールを削除することで、ES5以降のemitをクリーンアップできるようになります。</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes">
          <source>Deduplicated and redirected packages</source>
          <target>重複除外およびリダイレクトされたパッケージ</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes">
          <source>Deep Dive</source>
          <target>ディープダイブ</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes">
          <source>Deep Dive: Advanced Combinations</source>
          <target>ディープ・ダイブ:高度な組み合わせ</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target>ディープ・ダイブ:定義ファイル理論:ディープ・ダイブ</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes">
          <source>Deep Dive: Using with export = or import</source>
          <target>ディープ・ダイブ:export=またはimportでの使用</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes">
          <source>Default</source>
          <target>デフォルト</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes">
          <source>Default Export</source>
          <target>デフォルトエクスポート</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes">
          <source>Default exports</source>
          <target>デフォルトエクスポート</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href="https://github.com/Microsoft/TypeScript/issues/14080"&gt;#14080&lt;/a&gt; for details)</source>
          <target>既定のエクスポートも拡張できず、名前付きエクスポートのみが拡張できます(エクスポート名で拡張する必要があり、&lt;code&gt;default&lt;/code&gt;は予約語であるため、詳細については&lt;a href="https://github.com/Microsoft/TypeScript/issues/14080"&gt;#14080&lt;/a&gt;を参照)。</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from "fs"&lt;/code&gt;), and should work as expected.</source>
          <target>CommonJS/AMD/UMDへのデフォルトインポートが可能になりました(例えば、&lt;code&gt;import fs from"fs"&lt;/code&gt;)。</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target>タイプパラメータの既定のタイプは、タイプパラメータの制約を満たす必要があります(存在する場合)。</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes">
          <source>Default values</source>
          <target>デフォルト値</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target>デフォルト値を使用すると、プロパティが未定義の場合にデフォルト値を指定できます。</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target>すべての必須パラメータがオプションとして扱われた後のデフォルトの初期化パラメータは、それぞれの関数を呼び出すときに省略できます。 つまり、オプションパラメータと末尾のデフォルトパラメータは、タイプの共通性を共有します。</target>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes">
          <source>Defaulted declarations</source>
          <target>デフォルトの宣言</target>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes">
          <source>Definite Assignment Assertions</source>
          <target>確定代入アサーション</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes">
          <source>Definition File Theory: A Deep Dive</source>
          <target>定義ファイル理論の詳細</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes">
          <source>Dependencies</source>
          <target>依存関係</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes">
          <source>Dependencies on Global Libraries</source>
          <target>グローバルライブラリへの依存関係</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes">
          <source>Dependencies on Modules</source>
          <target>モジュールへの依存関係</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes">
          <source>Dependencies on UMD libraries</source>
          <target>UMDライブラリへの依存関係</target>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href="http://wiki.commonjs.org/wiki/CommonJS"&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href="https://github.com/amdjs/amdjs-api/wiki/AMD"&gt;AMD&lt;/a&gt;), &lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt;, &lt;a href="https://github.com/systemjs/systemjs"&gt;SystemJS&lt;/a&gt;, or &lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules"&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target>コンパイラは、コンパイル中に指定されたモジュールターゲットに応じて、Node.js(&lt;a href="http://wiki.commonjs.org/wiki/CommonJS"&gt;CommonJS&lt;/a&gt;)、require.js(&lt;a href="https://github.com/amdjs/amdjs-api/wiki/AMD"&gt;AMD&lt;/a&gt;)、&lt;a href="https://github.com/umdjs/umd"&gt;UMD&lt;/a&gt;、&lt;a href="https://github.com/systemjs/systemjs"&gt;SystemJS&lt;/a&gt;、または&lt;a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules"&gt;ECMAScript2015ネイティブモジュール&lt;/a&gt;(ES6)のモジュールローディングシステムに適切なコードを生成します。 生成されたコードで&lt;code&gt;define&lt;/code&gt;、&lt;code&gt;require&lt;/code&gt;、および&lt;code&gt;register&lt;/code&gt;呼び出しが何を行うかについての詳細は、各モジュールローダのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes">
          <source>Description</source>
          <target>説明</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target>その外観にもかかわらず、&lt;code&gt;readonly&lt;/code&gt;型修飾子は、配列型とタプル型の構文でのみ使用できます。 汎用タイプの演算子ではありません。</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes">
          <source>Destructuring</source>
          <target>構造解除</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target>構造化解除は、関数宣言でも機能します。 単純な場合、これは単純です。</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target>宣言の構造化を解除すると、配列から値を抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes">
          <source>Destructuring in declarations and assignments</source>
          <target>宣言と代入における構造化解除</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target>正規の代入式では、パターンの構造を解除することもできます。 たとえば、2つの変数をスワップすると、1つの構造化解除割り当てとして記述できます。</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes">
          <source>Destructuring works with already-declared variables as well:</source>
          <target>構造化解除は、すでに宣言されている変数に対しても機能します。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes">
          <source>Details</source>
          <target>詳細</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes">
          <source>Detect if they are up-to-date</source>
          <target>最新かどうかを検出する</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes">
          <source>Determine how modules get resolved. Either &lt;code&gt;"Node"&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;"Classic"&lt;/code&gt;. See &lt;a href="module-resolution"&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target>モジュールの解決方法を決定します。 &lt;code&gt;"Node"&lt;/code&gt;for Node.js/io.js style resolution、または&lt;code&gt;"Classic"&lt;/code&gt;のいずれかです。詳細については、&lt;a href="module resolution"&gt;Module Resolution documentation&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes">
          <source>Difference between the static and instance sides of classes</source>
          <target>クラスの静的側とインスタンス側の違い</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target>言語のさまざまな場所で、状況に応じて2つの互換性メカニズムのいずれかが使用されます。 &lt;code&gt;implements&lt;/code&gt;節と&lt;code&gt;extends&lt;/code&gt;節の場合であっても、実用的には、型の互換性は割り当ての互換性によって決定される。</target>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes">
          <source>Disable bivariant parameter checking for function types.</source>
          <target>関数型のbivariantパラメータチェックを無効にします。</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes">
          <source>Disable size limitation on JavaScript project.</source>
          <target>JavaScriptプロジェクトのサイズ制限を無効にします。</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target>関数型の汎用シグネチャの厳密なチェックを無効にします。</target>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target>同一ファイルへの大文字と小文字が一致しない参照を禁止します。</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes">
          <source>Disallowed Merges</source>
          <target>許可されていない結合</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes">
          <source>Discriminated Unions</source>
          <target>被差別組合</target>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes">
          <source>Distributive conditional types</source>
          <target>分布条件型</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target>&lt;code&gt;///&amp;lt;reference&lt;/code&gt;ディレクティブを使用してUMDライブラリへの依存関係を宣言しないでください。&lt;em&gt;&lt;/em&gt;！</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target>トリプルスラッシュ参照またはモジュールインポートターゲットをコンパイル済みファイルのリストに追加しないでください。</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes">
          <source>Do not emit &lt;code&gt;"use strict"&lt;/code&gt; directives in module output.</source>
          <target>モジュール出力で&lt;code&gt;"use strict"&lt;/code&gt;ディレクティブを発行しないでください。</target>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes">
          <source>Do not emit outputs if any errors were reported.</source>
          <target>エラーが報告された場合は、出力を行わない。</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes">
          <source>Do not emit outputs.</source>
          <target>出力を出さない。</target>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes">
          <source>Do not erase const enum declarations in generated code. See &lt;a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations"&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target>生成されたコード内のconst enum宣言は削除しないでください。詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations"&gt;const enumsのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target>コンパイルされた出力に&lt;code&gt;__extends&lt;/code&gt;のようなカスタムヘルパー関数を生成しないでください。</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target>デフォルトのライブラリファイル(&lt;code&gt;lib.d.ts&lt;/code&gt;)は含めないでください。</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes">
          <source>Do not report errors on unreachable code.</source>
          <target>到達不能コードのエラーを報告しない。</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes">
          <source>Do not report errors on unused labels.</source>
          <target>使用されていないラベルにエラーを報告しない。</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target>シンボリックリンクを実際のパスに解決しないでください。シンボリックリンクファイルを実際のファイルのように扱います。</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes">
          <source>Do not truncate error messages.</source>
          <target>エラー・メッセージを切り捨てないでください。</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes">
          <source>Do not use namespaces in modules</source>
          <target>モジュールで名前空間を使用しない</target>
        </trans-unit>
        <trans-unit id="d328c595cbbcd65b45ebd4e46479f933972ea958" translate="yes">
          <source>Do's &amp; Don'ts</source>
          <target>注意事項</target>
        </trans-unit>
        <trans-unit id="4d785ac3a4b3828cf309e66ed3918bb56ac497e2" translate="yes">
          <source>Do's &amp; Don'ts: Generics</source>
          <target>推奨事項:ジェネリック</target>
        </trans-unit>
        <trans-unit id="93f96ae833025b715432d87457fff1181f6fec0a" translate="yes">
          <source>Do's &amp; Don'ts: Optional Parameters in Callbacks</source>
          <target>注意事項:コールバックのオプションパラメータ</target>
        </trans-unit>
        <trans-unit id="fab69ff067aebc1b1d9b25caf9802998b29ef6bb" translate="yes">
          <source>Do's &amp; Don'ts: Ordering</source>
          <target>注意事項:注文</target>
        </trans-unit>
        <trans-unit id="60af8ee88a4ba753c39b5d3469e47ad6fecb73f9" translate="yes">
          <source>Do's &amp; Don'ts: Overloads and Callbacks</source>
          <target>注意事項:オーバーロードとコールバック</target>
        </trans-unit>
        <trans-unit id="b95e9e00255eab131c78a7f05b9c10e7be958ea5" translate="yes">
          <source>Do's &amp; Don'ts: Return Types of Callbacks</source>
          <target>注意事項: コールバックの戻り値の型</target>
        </trans-unit>
        <trans-unit id="a7591fe7d55aae882e5e362a86a771797c5e0751" translate="yes">
          <source>Do's &amp; Don'ts: Use Optional Parameters</source>
          <target>注意事項: オプションパラメータを使用</target>
        </trans-unit>
        <trans-unit id="fb6bb00859e0ff33129a2ba7a57b7c720e714c83" translate="yes">
          <source>Do's &amp; Don'ts: Use Union Types</source>
          <target>注意事項: ユニオン型を使用</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes">
          <source>Do's and Don'ts</source>
          <target>すべきこととすべきでないこと</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target>ライブラリを&lt;code&gt;require&lt;/code&gt;またはimportする方法を記述した文書</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target>UMDライブラリのドキュメントでは、&lt;code&gt;require&lt;/code&gt;を示す&amp;ldquo;Using in Node.js&amp;rdquo;の例、および&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグを使用してスクリプトをロードする方法を示す&amp;ldquo;Using in the browser&amp;rdquo;の例も頻繁に紹介されます。</target>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target>ここにある手順の数に驚かないでください(&amp;R)-TypeScriptはまだ手順(9)と(17)でディレクトリを2回ジャンプするだけです。 これはNode.jsがやっていることと同じくらい複雑なものです。</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target>コマンドラインに渡すファイルの順序を気にする必要はありません。&lt;code&gt;tsc&lt;/code&gt;は必要に応じてファイルの順序を変更し、常に依存関係が最初に構築されるようにします。</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes">
          <source>Dotted names in type guards</source>
          <target>タイプガードのドット名</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes">
          <source>Dotted property for types with string index signatures</source>
          <target>文字列インデックスシグネチャを持つ型のDottedプロパティ</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes">
          <source>Downlevel Async Functions</source>
          <target>下位レベルの非同期関数</target>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes">
          <source>Download the &lt;a href="https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1"&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target>&lt;a href="https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1"&gt;VSDevMode.ps1&lt;/a&gt;スクリプトをダウンロードします。</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes">
          <source>Downloading</source>
          <target>ダウンロード中</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target>バグのため、以前はTypeScriptで次の構文を使用できました。</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target>TypeScript3.4で型引数を推定する際、関数型を返す汎用関数の呼び出しに対して、TypeScript&lt;em&gt;は必要に応じて、型パラメータを汎用関数引数から結果の関数型に伝達する&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target>動的&lt;code&gt;import&lt;/code&gt;式はECMAScriptの新機能であり、ユーザがプログラムの任意の時点でモジュールを非同期に要求できるようにする。</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes">
          <source>Dynamic Import Expressions</source>
          <target>ダイナミックインポート式</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes">
          <source>Dynamic Module Loading in Node.js</source>
          <target>Node.jsでの動的モジュールロード</target>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target>ECMAScript2015(ES2015、ECMAScript6、ES6とも呼ばれます)、CommonJS、RequireJSには、&lt;em&gt;import&lt;/em&gt;a&lt;em&gt;module&lt;/em&gt;という同様の概念があります。 例えば、JavaScript CommonJS(Node.js)では、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target>ES2015には、クラスのプロパティを宣言する手段がありません。 プロパティは、オブジェクトリテラルと同様に動的に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target>ES3およびES5をターゲットとする場合、ES6&lt;code&gt;let&lt;/code&gt;および&lt;code&gt;const&lt;/code&gt;宣言がサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes">
          <source>ES6 Modules</source>
          <target>ES6モジュール</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes">
          <source>ES6 generators</source>
          <target>ES6ジェネレータ</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target>ES6では、エスケープを1つだけ使用してUnicodeコードポイントを表現できるエスケープが導入されています。</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes">
          <source>ES7 exponentiation operator</source>
          <target>ES7指数演算子</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target>各enumメンバには、&lt;em&gt;constant&lt;/em&gt;または&lt;em&gt;computed&lt;/em&gt;のいずれかの値が関連付けられています。 enumメンバは、次の場合に定数と見なされます。</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target>各モジュールは、オプションで&lt;code&gt;default&lt;/code&gt;エクスポートをエクスポートできます。 デフォルトエクスポートはキーワード&lt;code&gt;default&lt;/code&gt;でマークされ、モジュールごとに&lt;code&gt;default&lt;/code&gt;エクスポートは1つだけです。 &lt;code&gt;default&lt;/code&gt;エクスポートは、別のインポートフォームを使用してインポートされます。</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes">
          <source>Each of these declaration forms creates a new type name.</source>
          <target>これらの宣言フォームはそれぞれ、新しい型名を作成します。</target>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href="templates"&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target>主要なライブラリ構造化パターンの各タイプには、&lt;a href="templates"&gt;Templates&lt;/a&gt;セクションに対応するファイルがあります。 これらのテンプレートを使用すると、作業を迅速に進めることができます。</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes">
          <source>Early Benefits</source>
          <target>早期のメリット</target>
        </trans-unit>
        <trans-unit id="b63018569ba21a6a8335741b5e9fee7a7cedecf6" translate="yes">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;acirc;&amp;euro;&amp;trade; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target>Visual StudioやVisual Studio Codeのようなエディタは、他のモジュールから値を自動的にインポートするようなクイックフィックス、リファクタリング、その他の変換を自動的に適用することができる。 これらの変換はTypeScriptによって実行され、古いバージョンのTypeScriptではすべてのステートメントの末尾に無条件にセミコロンが追加されていました。残念なことに、多くのユーザが&amp;acirc;&amp;euro;&amp;trade;スタイルのガイドラインに同意せず、多くのユーザがエディタがセミコロンを挿入することに不満を持っていました。</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target>静的メンバーのクラスのコンストラクタ関数、またはインスタンス・メンバーのクラスのプロトタイプ。</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target>配列バインドパターン内の配列リテラル内に一致しない要素は、配列バインドパターン内にデフォルト値を持つ必要があり、自動的に配列リテラル型に追加されます。</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes">
          <source>Embedding Expressions</source>
          <target>式の埋め込み</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target>&lt;code&gt;__importStar&lt;/code&gt;および&lt;code&gt;__importDefault&lt;/code&gt;ヘルパを発生させて実行時のバベルエコシステムの互換性を確保し、&lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt;を有効にして型システムの互換性を確保する。</target>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target>出力ファイルの先頭にUTF-8バイトオーダーマーク(BOM)を出力します。</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target>個別のファイルではなく、ソースマップを使用して1つのファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target>&lt;code&gt;built&lt;/code&gt;内のすべての出力ファイルを&lt;code&gt;outDir&lt;/code&gt;で出力します。</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target>ECMAScript標準セマンティクスを持つクラスフィールドを生成します。</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href="https://github.com/Microsoft/TypeScript/issues/2577"&gt;issue #2577&lt;/a&gt; for details.</source>
          <target>ソース内の装飾された宣言に対して、デザインタイプのメタデータを発行します。詳細については、&lt;a href="https://github.com/Microsoft/TypeScript/issues/2577"&gt;issue#2577&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target>1つのファイル内でソースマップの横にソースを出力します。&lt;code&gt;--inlineSourceMap&lt;/code&gt;または&lt;code&gt;--sourceMap&lt;/code&gt;を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes">
          <source>Enable all strict type checking options.</source>
          <target>すべての厳密な型チェックオプションを有効にします。</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target>以前のコンパイルからディスク上のファイルに情報を読み書きすることで、インクリメンタルコンパイルを有効にします。 このファイルは、&lt;code&gt;--tsBuildInfoFile&lt;/code&gt;フラグによって制御されます。</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target>関数の&lt;code&gt;bind&lt;/code&gt;メソッド、&lt;code&gt;call&lt;/code&gt;メソッド、および&lt;code&gt;apply&lt;/code&gt;メソッドのチェックを強化する。</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target>&lt;code&gt;jsx&lt;/code&gt;オプションを有効にする</target>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes">
          <source>Enables experimental support for ES decorators.</source>
          <target>ESデコレータの実験的サポートを有効にします。</target>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target>&lt;code&gt;-declarationMap&lt;/code&gt;を&lt;code&gt;--宣言&lt;/code&gt;と同時に有効にすると、コンパイラは&lt;code&gt;.d.ts.map&lt;/code&gt;ファイルを&lt;code&gt;.d.ts&lt;/code&gt;ファイルと同時に出力します。 Language Servicesは、これらのマップファイルを理解することもでき、宣言ファイルベースの定義の場所を、利用可能な場合は元のソースにマップするために使用できます。</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target>&lt;code&gt;-strict&lt;/code&gt;を有効にすると、&lt;code&gt;--noImplicitAny&lt;/code&gt;、&lt;code&gt;--noImplicitThis&lt;/code&gt;、&lt;code&gt;-alwaysStrict&lt;/code&gt;、&lt;code&gt;--strictBindCallApply&lt;/code&gt;、&lt;code&gt;--strictNullChecks&lt;/code&gt;、&lt;code&gt;-strictFunctionTypes&lt;/code&gt;、&lt;code&gt;-strictPropertyInitialization&lt;/code&gt;が有効になります。</target>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target>拡張&lt;code&gt;--init&lt;/code&gt;出力</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target>TypeScriptが、プロジェクトをコンパイルするために参照されるプロジェクトの出力をどこで見つけるかを決定できることを確認する。</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target>未定義でないクラスプロパティがコンストラクタで初期化されていることを確認します。 このオプションを有効にするには、&lt;code&gt;--strictNullChecks&lt;/code&gt;を有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target>Index Type Queryまたは&lt;code&gt;keyof&lt;/code&gt;と入力します。インデックス付きタイプのクエリ&lt;code&gt;keyof T&lt;/code&gt;は、&lt;code&gt;T&lt;/code&gt;に許可されたプロパティ名のタイプを返します。 &lt;code&gt;keyof T&lt;/code&gt;型は、&lt;code&gt;string&lt;/code&gt;のサブタイプと見なされます。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes">
          <source>Enum</source>
          <target>列挙型</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes">
          <source>Enum Member Types</source>
          <target>列挙型メンバの種類</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes">
          <source>Enums</source>
          <target>列挙</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target>列挙型を使用すると、一連の名前付き定数を定義できます。 列挙を使用すると、意図を文書化したり、個別のケースを作成したりするのが容易になります。 TypeScriptは、数値ベースと文字列ベースの両方の列挙を提供します。</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target>列挙型は数値と互換性があり、数値は列挙型と互換性があります。 異なる列挙型の列挙値は互換性がないと見なされます。 たとえば</target>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target>列挙型は実行時に存在する実オブジェクトです。 例えば、以下のenum</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target>列挙型は非常に便利ですが、一部のプログラムは実際には生成されたコードを必要とせず、列挙型メンバーのすべてのインスタンスを単純に等価な数値でインライン化することでメリットが得られます。 新しい&lt;code&gt;const enum&lt;/code&gt;宣言は、型安全性のために通常の&lt;code&gt;enum&lt;/code&gt;と同じように動作しますが、コンパイル時に完全に消去されます。</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes">
          <source>Enums at compile time</source>
          <target>コンパイル時の列挙型</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes">
          <source>Enums at runtime</source>
          <target>実行時の列挙</target>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target>渡されなかったため、&lt;code&gt;moduleB&lt;/code&gt;が見つからないというエラー。</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes">
          <source>Error messages in Russian:</source>
          <target>ロシア語のエラーメッセージ:</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes">
          <source>Errors</source>
          <target>エラー</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target>&lt;code&gt;--checkJs&lt;/code&gt;を含む.jsファイルのエラー</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes">
          <source>Evaluation</source>
          <target>評価</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt; or &lt;a href="https://visualstudio.com"&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target>この時点でも、TypeScriptがプロジェクトを理解することで大きなメリットが得られます。 &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt;や&lt;a href="https://visualstudio.com"&gt;Visual Studio&lt;/a&gt;のようなエディタを開くと、補完などのツールサポートを受けることができます。 次のようなオプションを使用して、特定のバグを検出することもできます。</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target>さらに良いことに、コンパイラに&lt;code&gt;--noImplicitThis&lt;/code&gt;フラグを渡すと、TypeScriptはこの間違いを犯したときに警告を発する。 &lt;code&gt;this.shoes[pickedSuit]&lt;/code&gt;の&lt;code&gt;this&lt;/code&gt;が&lt;code&gt;any&lt;/code&gt;型であることを指摘する。</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target>Enumは実行時に存在する実際のオブジェクトですが、&lt;code&gt;keyof&lt;/code&gt;キーワードの動作は通常のオブジェクトとは異なります。 代わりに、&lt;code&gt;keyof typeof&lt;/code&gt;を使用して、すべての列挙キーを文字列として表すTypeを取得します。</target>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target>コンパイラは、&lt;code&gt;rootDirs&lt;/code&gt;のサブフォルダ内に相対モジュールインポートを見つけるたびに、&lt;code&gt;rootDirs&lt;/code&gt;の各エントリでこのインポートを検索します。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes">
          <source>Example</source>
          <target>例</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの例:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes">
          <source>Examples</source>
          <target>例</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes">
          <source>Examples of Global Libraries</source>
          <target>グローバルライブラリの例</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes">
          <source>Examples of Modular Libraries</source>
          <target>モジュールライブラリの例</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes">
          <source>Examples of UMD libraries</source>
          <target>UMDライブラリの例</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes">
          <source>Excess Property Checks</source>
          <target>超過プロパティチェック</target>
        </trans-unit>
        <trans-unit id="00efa3e22fd44a3b920cde7fd909797635b45d93" translate="yes">
          <source>Exclude&lt;T,U&gt;</source>
          <target>除外&lt;T,U&gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes">
          <source>Execute Babel from the command line</source>
          <target>コマンドラインからBabelを実行する</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes">
          <source>Exhaustiveness checking</source>
          <target>網羅性チェック</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target>タプル型を持つ休止パラメータを個別のパラメータに展開します。</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target>タプル型を持つ展開式を個別の引数に展開します。</target>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target>&lt;code&gt;async&lt;/code&gt;関数の実験的サポート</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target>&lt;code&gt;defaultProps&lt;/code&gt;の明示的な型</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes">
          <source>Explicitly list imported names</source>
          <target>インポートされた名前を明示的にリストする</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes">
          <source>Export</source>
          <target>エクスポート</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes">
          <source>Export Declarations</source>
          <target>エクスポート宣言</target>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes">
          <source>Export as close to top-level as possible</source>
          <target>できるだけ最上位レベルに近いレベルでエクスポート</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes">
          <source>Export statements</source>
          <target>ステートメントのエクスポート</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target>エクスポート文は、コンシューマ用にエクスポートの名前を変更する必要がある場合に便利です。上記の例は次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes">
          <source>Exporting a declaration</source>
          <target>宣言のエクスポート</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target>モジュールから名前空間をエクスポートするのは、ネストのレイヤを追加しすぎた例です。 名前空間にはその用途がある場合もありますが、モジュールを使用する場合には、間接的なレベルが追加されます。 これはすぐにユーザーの悩みの種になり、通常は不要です。</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes">
          <source>Exporting from Modules</source>
          <target>モジュールからのエクスポート</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes">
          <source>Expression operators</source>
          <target>式演算子</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target>式演算子を使用すると、オペランドの型に&lt;code&gt;null&lt;/code&gt;や&lt;code&gt;undefined&lt;/code&gt;を含めることができますが、常に非NULL型と非未定義型の値が生成されます。</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes">
          <source>Extending Classes</source>
          <target>クラスの拡張</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
