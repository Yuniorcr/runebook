<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="50b83579cf141ddf3a24a6600e359e207807258a" translate="yes">
          <source>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using &lt;code&gt;--locale&lt;/code&gt; flag on the command line.</source>
          <target>TypeScript2.6npmパッケージには、13言語用のローカライズ版の診断メッセージが同梱されています。 ローカライズされたメッセージは、コマンドラインで&lt;code&gt;--locale&lt;/code&gt;フラグを使用すると使用できます。</target>
        </trans-unit>
        <trans-unit id="71107e6f11d3d9498db10524c3f3c164f19e9415" translate="yes">
          <source>TypeScript 2.6 support suppressing errors in .js files using &lt;code&gt;// @ts-ignore&lt;/code&gt; comments placed above the offending lines.</source>
          <target>TypeScript2.6は、問題の行の上に置かれた&lt;code&gt;//@ts ignore&lt;/code&gt;コメントを使用して、.jsファイルのエラーを抑制することをサポートしている。</target>
        </trans-unit>
        <trans-unit id="bef45e6468d0c0a17f09c30d2b82dd8a05124a51" translate="yes">
          <source>TypeScript 2.7</source>
          <target state="translated">TypeScript 2.7</target>
        </trans-unit>
        <trans-unit id="79e7e447b60909166288dcf8cb72e27e89f7cec5" translate="yes">
          <source>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</source>
          <target>TypeScript2.7では、ECMAScriptシンボルを含む型にconst名のプロパティを宣言するサポートが追加された。</target>
        </trans-unit>
        <trans-unit id="a51783c99c59b3257833940324affc2689b71a24" translate="yes">
          <source>TypeScript 2.7 also introduced &lt;code&gt;--watch&lt;/code&gt; mode builds via a new incremental &amp;ldquo;builder&amp;rdquo; API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing &lt;em&gt;intra&lt;/em&gt;-project builds.</source>
          <target>TypeScript2.7では、新しいインクリメンタル&amp;ldquo;builder&amp;rdquo;APIを使用した&lt;code&gt;--watch&lt;/code&gt;モードのビルドも導入されました。 同様に、このモードでは、変更されたファイルまたは依存関係がタイプ・チェックに影響を与える可能性のあるファイルのみを再チェックして再出力するようにします。 これは、&lt;em&gt;intra&lt;/em&gt;-projectビルドを最適化することと考えることができます。</target>
        </trans-unit>
        <trans-unit id="162b6515dd83712cce22c0f4cc8d254c9b33661b" translate="yes">
          <source>TypeScript 2.7 brings support for &lt;a href="https://github.com/tc39/proposal-numeric-separator"&gt;ES Numeric Separators&lt;/a&gt;. Numeric literals can now be separated into segments using &lt;code&gt;_&lt;/code&gt;.</source>
          <target>TypeScript2.7は、&lt;a href="https://github.com/tc39/proposal-numeric-separator"&gt;ES数値セパレータ&lt;/a&gt;をサポートします。数値リテラルは、&lt;code&gt;_&lt;/code&gt;を使用してセグメントに分割できるようになりました。</target>
        </trans-unit>
        <trans-unit id="af59c15c50945a988e8dab909a898e4259657c00" translate="yes">
          <source>TypeScript 2.7 improves the handling of structurally identical classes in union types and &lt;code&gt;instanceof&lt;/code&gt; expressions:</source>
          <target>TypeScript2.7では、ユニオン型と&lt;code&gt;instanceof&lt;/code&gt;式における構造的に同一のクラスの処理が改善されている。</target>
        </trans-unit>
        <trans-unit id="91f038aff687710c549846983751034fac966226" translate="yes">
          <source>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now &lt;em&gt;normalize&lt;/em&gt; the object literal types such that all properties are present in each constituent of the union type.</source>
          <target>TypeScript2.7は、同じコンテキストで発生する複数のオブジェクトリテラルの型推論を改善する。 複数のオブジェクトリテラル型がユニオン型に関係する場合、すべてのプロパティがユニオン型の各構成要素に存在するように、オブジェクトリテラル型を&lt;em&gt;正規化&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="6ab94d5588595f01a47bea04f5db381bcbb5dba9" translate="yes">
          <source>TypeScript 2.7 introduces a new flag called &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example</source>
          <target>TypeScript2.7には、&lt;code&gt;--strictPropertyInitialization&lt;/code&gt;と呼ばれる新しいフラグが導入されています。このフラグは、クラスの各インスタンスプロパティがコンストラクタ本体で、またはプロパティ初期化子によって初期化されることを確認するためのチェックを実行します。 例:</target>
        </trans-unit>
        <trans-unit id="50a1f4f6bc66299bafe27e7f60a3413972205937" translate="yes">
          <source>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an &lt;code&gt;__esModule&lt;/code&gt; indicator under &lt;code&gt;--esModuleInterop&lt;/code&gt;. The change brings the generated output from TypeScript closer to that generated by Babel.</source>
          <target>TypeScript2.7は、CommonJS/AMD/UMDモジュールemitを更新し、&lt;code&gt;--esModuleInterop&lt;/code&gt;の下に&lt;code&gt;__esModule&lt;/code&gt;インジケータがあることに基づいて名前空間レコードを統合します。この変更により、TypeScriptから生成される出力は、Babelによって生成される出力に近くなります。</target>
        </trans-unit>
        <trans-unit id="4e42d10f15cd2510b82037d64e9dbecd5c11e732" translate="yes">
          <source>TypeScript 2.8</source>
          <target state="translated">TypeScript 2.8</target>
        </trans-unit>
        <trans-unit id="3b84208a266962375c246ada5aa0bd123c9cfe9e" translate="yes">
          <source>TypeScript 2.8 adds several predefined conditional types to &lt;code&gt;lib.d.ts&lt;/code&gt;:</source>
          <target>TypeScript2.8では、&lt;code&gt;lib.d.ts&lt;/code&gt;にいくつかの定義済み条件タイプが追加されています。</target>
        </trans-unit>
        <trans-unit id="c5e0ed8e368b2f12d192ed317481ad4102d428b8" translate="yes">
          <source>TypeScript 2.8 adds support for a per-file configurable JSX factory name using &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory can be configured for a compilation using &lt;code&gt;--jsxFactory&lt;/code&gt; (default is &lt;code&gt;React.createElement&lt;/code&gt;). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</source>
          <target>TypeScript2.8では、&lt;code&gt;@jsx dom&lt;/code&gt;プラグマを使用して、ファイルごとに構成可能なJSXファクトリ名のサポートが追加された。 JSXファクトリーは、&lt;code&gt;--jsxFactory&lt;/code&gt;(デフォルトは&lt;code&gt;React.createElement&lt;/code&gt;)を使用してコンパイル用に構成できます。 TypeScript2.8では、ファイルの先頭にコメントを追加することで、これをファイル単位で上書きすることができる。</target>
        </trans-unit>
        <trans-unit id="4f6ad1955b40525b81ee6b350e3efda1dca7803e" translate="yes">
          <source>TypeScript 2.8 adds support for understanding more namespace patterns in &lt;code&gt;.js&lt;/code&gt; files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</source>
          <target>TypeScript2.8では、&lt;code&gt;.js&lt;/code&gt;ファイルのより多くの名前空間パターンを理解するためのサポートが追加された。 最上位レベルの空のオブジェクトリテラル宣言は、関数やクラスと同様に、JavaScriptで名前空間宣言として認識されるようになりました。</target>
        </trans-unit>
        <trans-unit id="f9e15ad123318d14a1567d61a8eb9b88ec3f14c9" translate="yes">
          <source>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; property modifier in a mapped type can now be prefixed with either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to indicate that the modifier should be added or removed.</source>
          <target>TypeScript2.8は、マップされた型が特定の修飾子を追加または削除する機能を追加する。 具体的には、マップされたタイプの&lt;code&gt;readonly&lt;/code&gt;または&lt;code&gt;?&lt;/code&gt;プロパティ修飾子に、&lt;code&gt;+&lt;/code&gt;または&lt;code&gt;-&lt;/code&gt;のいずれかの接頭辞を付けて、修飾子を追加または削除する必要があることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="ccbc7d666b3ba41052f2f21dcaf1e812e9bac36a" translate="yes">
          <source>TypeScript 2.8 introduces &lt;em&gt;conditional types&lt;/em&gt; which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target>TypeScript2.8では、&lt;em&gt;条件付き型&lt;/em&gt;が導入され、不均一型マッピングを表現する機能が追加された。 条件型は、型関係テストとして表現された条件に基づいて、次の2つの型のいずれかを選択します。</target>
        </trans-unit>
        <trans-unit id="38d22337c31f40538f05a1b3be32d35d5d040ad3" translate="yes">
          <source>TypeScript 2.9</source>
          <target state="translated">TypeScript 2.9</target>
        </trans-unit>
        <trans-unit id="79a8a3cdfaf2e7ea5b694163b786814a57e8ccbe" translate="yes">
          <source>TypeScript 2.9 adds support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties in index types and mapped types. Previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties.</source>
          <target>TypeScript2.9では、インデックス型とマップ型の&lt;code&gt;number&lt;/code&gt;および&lt;code&gt;symbol&lt;/code&gt;名前付きプロパティのサポートが追加された。 以前は、&lt;code&gt;keyof&lt;/code&gt;演算子とマップされた型は、&lt;code&gt;string&lt;/code&gt;名前付きプロパティのみをサポートしていました。</target>
        </trans-unit>
        <trans-unit id="f3af31e687b53bc6028a7656648578f8526d1535" translate="yes">
          <source>TypeScript 2.9 allows passing generic type arguments to tagged template strings.</source>
          <target>TypeScript2.9では、タグ付きテンプレート文字列に総称型引数を渡すことができる。</target>
        </trans-unit>
        <trans-unit id="c576ebab33996a3a7642529b1b3cf098557fad0c" translate="yes">
          <source>TypeScript 2.9 and earlier didn&amp;rsquo;t leverage &lt;a href="https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values"&gt;React &lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt; declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of &lt;code&gt;render&lt;/code&gt;, or they&amp;rsquo;d use type-assertions to fix up the type of the component before exporting it.</source>
          <target>TypeScript2.9以前では、JSXコンポーネント内の&lt;a href="https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values"&gt;React&lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt;宣言を利用していません。 多くの場合、ユーザはプロパティをオプションとして宣言し、&lt;code&gt;render&lt;/code&gt;内で非NULLのアサーションを使用するか、タイプのアサーションを使用して、エクスポートする前にコンポーネントのタイプを修正します。</target>
        </trans-unit>
        <trans-unit id="54d0224b3f561c10aa0b8f9cc4af3cf6fc0acd70" translate="yes">
          <source>TypeScript 2.9 introduces support for &lt;code&gt;import.meta&lt;/code&gt;, a new meta-property as described by the current &lt;a href="https://github.com/tc39/proposal-import-meta"&gt;TC39 proposal&lt;/a&gt;.</source>
          <target>TypeScript2.9では、&lt;code&gt;import.meta&lt;/code&gt;のサポートが導入されています。これは、現在の&lt;a href="https://github.com/tc39/proposal-import-meta"&gt;TC39プロポーザル&lt;/a&gt;で説明されている新しいメタプロパティです。</target>
        </trans-unit>
        <trans-unit id="ff47669d6e3d77ab534a2150af62bcea4228ce7e" translate="yes">
          <source>TypeScript 3.0</source>
          <target state="translated">TypeScript 3.0</target>
        </trans-unit>
        <trans-unit id="1b5495b8f8bb8ada5fe9aabb083f17ca19955412" translate="yes">
          <source>TypeScript 3.0 adds support for a new type alias in the &lt;code&gt;JSX&lt;/code&gt; namespace called &lt;code&gt;LibraryManagedAttributes&lt;/code&gt;. This helper type defines a transformation on the component&amp;rsquo;s &lt;code&gt;Props&lt;/code&gt; type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</source>
          <target>TypeScript3.0では、&lt;code&gt;LibraryManagedAttributes&lt;/code&gt;と呼ばれる&lt;code&gt;JSX&lt;/code&gt;名前空間の新しい型別名のサポートが追加されました。このヘルパー型は、コンポーネントの&lt;code&gt;Props&lt;/code&gt;型の変換を定義してから、それを対象とするJSX式をチェックします。これにより、提供されたpropsと推論されたpropsの間の競合の処理方法、推論のマッピング方法、オプション性の処理方法、および異なる場所からの推論を組み合わせる方法などのカスタマイズが可能になります。</target>
        </trans-unit>
        <trans-unit id="898331749799c0ae0af6a27a2c4a2bf1b9107b53" translate="yes">
          <source>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:</source>
          <target>TypeScript3.0は、関数パラメータリストをタプル型として扱うための複数の新しい機能のサポートを追加する。 TypeScript3.0では次のサポートが追加された。</target>
        </trans-unit>
        <trans-unit id="24d0fe89da15fd3c400693e525d5250f550dd57a" translate="yes">
          <source>TypeScript 3.0 also introduces a new mode for tsc, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand-in-hand with project references to enable faster TypeScript builds.</source>
          <target>TypeScript3.0では、tscの新しいモードである&lt;code&gt;--build&lt;/code&gt;フラグも導入されている。このフラグは、より高速なTypeScriptビルドを可能にするために、プロジェクト参照と連携して動作する。</target>
        </trans-unit>
        <trans-unit id="76ebacc06303039a717759a1bc81f839c55d819c" translate="yes">
          <source>TypeScript 3.0 introduced a new feature for structuring builds called &amp;ldquo;composite projects&amp;rdquo;. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use &lt;code&gt;--build&lt;/code&gt; mode to recompile only the set of projects and dependencies. You can think of this as optimizing &lt;em&gt;inter&lt;/em&gt;-project builds.</source>
          <target>TypeScript3.0では、&amp;ldquo;composite projects&amp;rdquo;というビルドを構造化する新機能が導入されました。 ここでの目標の1つは、ユーザが既存のTypeScriptの経験を損なうことなく、大きなプロジェクトを小さな部分に分割し、素早く構築してプロジェクト構造を維持できるようにすることでした。 複合プロジェクトのおかげで、TypeScriptは&lt;code&gt;--build&lt;/code&gt;モードを使って、プロジェクトと依存関係のセットだけを再コンパイルすることができる。 これは、&lt;em&gt;inter&lt;/em&gt;-projectビルドを最適化することと考えることができます。</target>
        </trans-unit>
        <trans-unit id="38f62e5c968f53d348dfeece0c30cb452f80382a" translate="yes">
          <source>TypeScript 3.0 introduced support for referencing other and building them incrementally using the &lt;code&gt;--build&lt;/code&gt; flag. Additionally, TypeScript 3.4 introduced the &lt;code&gt;--incremental&lt;/code&gt; flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn&amp;acirc;&amp;euro;&amp;trade;t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</source>
          <target>TypeScript3.0では、他を参照し、&lt;code&gt;--build&lt;/code&gt;フラグを使用してそれらを増分的に構築するサポートが導入された。 さらに、TypeScript3.4では、特定のファイルだけを再構築するために、以前のコンパイルに関する情報を保存する&lt;code&gt;--incremental&lt;/code&gt;フラグが導入された。 これらのフラグは、プロジェクトをより柔軟に構成し、ビルドを高速化するのに非常に役立ちました。 残念ながら、これらのフラグを使うと、GulpやWebpackのような第3者のビルドツールでは動作しない。 TypeScript3.6では、プロジェクト参照とインクリメンタルなプログラム構築を操作するために2セットのAPIが公開された。</target>
        </trans-unit>
        <trans-unit id="ef2e2b53b736d1c6d2b067c0b85011c12a528c2f" translate="yes">
          <source>TypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing &lt;code&gt;tsconfig.json&lt;/code&gt; files to reference other &lt;code&gt;tsconfig.json&lt;/code&gt; files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.</source>
          <target>TypeScript3.0は、プロジェクト参照の新しい概念を導入する。 プロジェクト参照によって、TypeScriptプロジェクトは他のTypeScriptプロジェクトに依存することができ、具体的には、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルが他の&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを参照することができる。 これらの依存関係を指定すると、TypeScript(およびその周りのツール)がビルドの順序と出力構造を理解する方法を提供するので、コードをより小さなプロジェクトに分割するのが容易になります。</target>
        </trans-unit>
        <trans-unit id="303ce39af16c9af3efeedd99c02704afd6f021df" translate="yes">
          <source>TypeScript 3.0 introduces a new top type &lt;code&gt;unknown&lt;/code&gt;. &lt;code&gt;unknown&lt;/code&gt; is the type-safe counterpart of &lt;code&gt;any&lt;/code&gt;. Anything is assignable to &lt;code&gt;unknown&lt;/code&gt;, but &lt;code&gt;unknown&lt;/code&gt; isn&amp;rsquo;t assignable to anything but itself and &lt;code&gt;any&lt;/code&gt; without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an &lt;code&gt;unknown&lt;/code&gt; without first asserting or narrowing to a more specific type.</source>
          <target>TypeScript3.0には、新しいトップ型&lt;code&gt;unknown&lt;/code&gt;が導入されています。&lt;code&gt;unknown&lt;/code&gt;は、&lt;code&gt;any&lt;/code&gt;のタイプセーフ版です。&lt;code&gt;unknown&lt;/code&gt;には何でも代入できますが、&lt;code&gt;unknown&lt;/code&gt;は、型アサーションや制御フローベースの絞り込みなしでは、それ自身と&lt;code&gt;any&lt;/code&gt;以外に代入できません。 同様に、&lt;code&gt;unknown&lt;/code&gt;に対しては、まず特定の型をアサートしたり絞り込んだりしない限り、いかなる操作も許されない。</target>
        </trans-unit>
        <trans-unit id="7978444d69de42e59647fdd6e697c61c835aefcc" translate="yes">
          <source>TypeScript 3.1</source>
          <target state="translated">TypeScript 3.1</target>
        </trans-unit>
        <trans-unit id="277efbe36e840571109f3bbb5578c95d9d3c2d0f" translate="yes">
          <source>TypeScript 3.1 brings the ability to define properties on function declarations and &lt;code&gt;const&lt;/code&gt;-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to &lt;code&gt;namespace&lt;/code&gt; hacks. For example:</source>
          <target>TypeScript3.1では、関数宣言と&lt;code&gt;const&lt;/code&gt;宣言された関数のプロパティを、同じスコープ内の関数のプロパティに割り当てるだけで定義できます。 これにより、&lt;code&gt;namespace&lt;/code&gt;のハックに頼ることなく、標準的なJavaScriptコードを書くことができます。 例:</target>
        </trans-unit>
        <trans-unit id="b9f00fd1052d436127e4de48e371112ca1399051" translate="yes">
          <source>TypeScript 3.2</source>
          <target state="translated">TypeScript 3.2</target>
        </trans-unit>
        <trans-unit id="1bd9c97a859cbb3246a80b48f6fdb33c3666de34" translate="yes">
          <source>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; helper types from &lt;code&gt;lib.d.ts&lt;/code&gt;, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</source>
          <target>TypeScript3.2では、ジェネリック変数からレストバインディングを分解することもできます。 これを行うには、事前定義された&lt;code&gt;Pick&lt;/code&gt;と&lt;code&gt;Exclude&lt;/code&gt;ヘルパー型を&lt;code&gt;lib.d.ts&lt;/code&gt;から使用し、問題の汎用型と共に分解パターン内の他のバインディングの名前を使用します。</target>
        </trans-unit>
        <trans-unit id="32739636ab98224be8b965eab8472c294e08c8bd" translate="yes">
          <source>TypeScript 3.2 introduces a new &lt;code&gt;--strictBindCallApply&lt;/code&gt; compiler option (in the &lt;code&gt;--strict&lt;/code&gt; family of options) with which the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on function objects are strongly typed and strictly checked.</source>
          <target>TypeScript3.2では、関数オブジェクトの&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;、および&lt;code&gt;apply&lt;/code&gt;メソッドが厳密に型指定され、厳密にチェックされる新しい&lt;code&gt;--strictBindCallApply&lt;/code&gt;コンパイラオプション(&lt;code&gt;-strict&lt;/code&gt;オプション群)が導入されている。</target>
        </trans-unit>
        <trans-unit id="b0c6e2bed7992d15f04fd899cadd250b20a960e6" translate="yes">
          <source>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain &lt;em&gt;some&lt;/em&gt; singleton type (e.g. a string literal, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;), and they contain no generics.</source>
          <target>TypeScript3.2では、判別特性と見なされるもののルールを緩和することで、絞り込みが容易になる。 共用体の共通プロパティーは、&lt;em&gt;何らかの&lt;/em&gt;シングルトン型(例えば、文字列リテラル、&lt;code&gt;null&lt;/code&gt;、または&lt;code&gt;undefined&lt;/code&gt;)を含み、総称を含まない限り、判別式と見なされます。</target>
        </trans-unit>
        <trans-unit id="7a26700dbb32ecd2b75ac980f07316d21f373a07" translate="yes">
          <source>TypeScript 3.2 now resolves &lt;code&gt;tsconfig.json&lt;/code&gt;s from &lt;code&gt;node_modules&lt;/code&gt;. When using a bare path for the &lt;code&gt;"extends"&lt;/code&gt; field in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript will dive into &lt;code&gt;node_modules&lt;/code&gt; packages for us.</source>
          <target>TypeScript3.2では、&lt;code&gt;tsconfig.json&lt;/code&gt;を&lt;code&gt;node_modules&lt;/code&gt;から解決するようになりました。&lt;code&gt;tsconfig.json&lt;/code&gt;の&lt;code&gt;extends"&lt;/code&gt;フィールドのベアパスを使用すると、TypeScriptは&lt;code&gt;node_modules&lt;/code&gt;パッケージに組み込まれます。</target>
        </trans-unit>
        <trans-unit id="cfd2b961db2e8cd46070f763e5c724b34d770631" translate="yes">
          <source>TypeScript 3.3</source>
          <target state="translated">TypeScript 3.3</target>
        </trans-unit>
        <trans-unit id="151f809570316cd705748f077714354101e09c3c" translate="yes">
          <source>TypeScript 3.4</source>
          <target state="translated">TypeScript 3.4</target>
        </trans-unit>
        <trans-unit id="289b2ef5b5dba27b6f9d27a73f1f934655330ac2" translate="yes">
          <source>TypeScript 3.4 also introduces new support for &lt;code&gt;readonly&lt;/code&gt; tuples. We can prefix any tuple type with the &lt;code&gt;readonly&lt;/code&gt; keyword to make it a &lt;code&gt;readonly&lt;/code&gt; tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, &lt;code&gt;readonly&lt;/code&gt; tuples only permit reading from those positions.</source>
          <target>TypeScript3.4では、&lt;code&gt;readonly&lt;/code&gt;タプルも新たにサポートされた。 &lt;code&gt;readonly&lt;/code&gt;キーワードで任意のタプル・タイプを接頭辞として使用して、&lt;code&gt;readonly&lt;/code&gt;タプルにすることができます。これは、配列の短縮構文で使用できるようになりました。 ご想像の通り、スロットを書き込むことができる通常のタプルとは異なり、&lt;code&gt;readonly&lt;/code&gt;タプルでは、これらの位置からの読み取りのみが許可されます。</target>
        </trans-unit>
        <trans-unit id="d5ae4e4e2dd524eb742ca067c90d1124fa510b9b" translate="yes">
          <source>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.</source>
          <target>TypeScript3.4は、他のジェネリック関数からの推論が推論のためのフリー型変数を生成するときに、ジェネリック関数型を生成することができる。 つまり、3.4では多くの関数構成パターンがよりうまく機能するようになりました。</target>
        </trans-unit>
        <trans-unit id="bf09bd81476b0409b652aa37d69d0d04e6689320" translate="yes">
          <source>TypeScript 3.4 introduces a new construct for literal values called &lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt; assertions. Its syntax is a type assertion with &lt;code&gt;const&lt;/code&gt; in place of the type name (e.g. &lt;code&gt;123 as const&lt;/code&gt;). When we construct new literal expressions with &lt;code&gt;const&lt;/code&gt; assertions, we can signal to the language that</source>
          <target>TypeScript3.4は、&lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt;アサーションと呼ばれるリテラル値のための新しい構成を導入する。 その構文は型名の代わりに&lt;code&gt;const&lt;/code&gt;を持つ型アサーションです(例えば&lt;code&gt;123as const&lt;/code&gt;)。 &lt;code&gt;const&lt;/code&gt;アサーションを使用して新しいリテラル式を作成する場合、次のようなシグナルを言語に送ることができます。</target>
        </trans-unit>
        <trans-unit id="1d6b24572a67a82fae359fdfff1468ec35fb0de9" translate="yes">
          <source>TypeScript 3.4 introduces a new flag called &lt;code&gt;--incremental&lt;/code&gt; which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with &lt;code&gt;--incremental&lt;/code&gt;, it will use that information to detect the least costly way to type-check and emit changes to your project.</source>
          <target>TypeScript3.4では、&lt;code&gt;--incremental&lt;/code&gt;と呼ばれる新しいフラグが導入され、最後のコンパイルからのプロジェクトグラフに関する情報を保存するようTypeScriptに指示します。 次回&lt;code&gt;--incremental&lt;/code&gt;を指定してTypeScriptを呼び出すと、その情報を使って、タイプチェックをしてプロジェクトに変更を加えるための最もコストのかからない方法を検出します。</target>
        </trans-unit>
        <trans-unit id="ac5af210d9695056d6101c62263f01f5967d4e08" translate="yes">
          <source>TypeScript 3.4 introduces a new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt; using a new &lt;code&gt;readonly&lt;/code&gt; modifier for array types.</source>
          <target>TypeScript3.4では、配列型に新しい&lt;code&gt;readonly&lt;/code&gt;修飾子を使用する&lt;code&gt;ReadonlyArray&lt;/code&gt;の新しい構文が導入されました。</target>
        </trans-unit>
        <trans-unit id="12a10c24cba59cb68af585f1698de8ae3445244e" translate="yes">
          <source>TypeScript 3.4 introduces support for type-checking ECMAScript&amp;rsquo;s new &lt;code&gt;globalThis&lt;/code&gt; - a global variable that, well, refers to the global scope. Unlike the above solutions, &lt;code&gt;globalThis&lt;/code&gt; provides a standard way for accessing the global scope which can be used across different environments.</source>
          <target>TypeScript3.4では、型チェックECMAScript&amp;rsquo;の新しい&lt;code&gt;globalThis&lt;/code&gt;-これは、グローバルスコープを参照するグローバル変数です。 上記のソリューションとは異なり、&lt;code&gt;global&lt;/code&gt;は、さまざまな環境で使用できるグローバルスコープにアクセスするための標準的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="f91b4dd92032cff1d431b2484ffb02c538b2840a" translate="yes">
          <source>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</source>
          <target>TypeScript3.4では、読み込み専用の配列型を使うのが少し簡単になった。</target>
        </trans-unit>
        <trans-unit id="9ab9e17f2ce04fc3d04ccc515b149cf9aa3aa203" translate="yes">
          <source>TypeScript 3.4 produces the type</source>
          <target>TypeScript3.4は型を生成する</target>
        </trans-unit>
        <trans-unit id="10f518faa467d8e0e2925a31d9b4b672b9c2e19b" translate="yes">
          <source>TypeScript 3.5</source>
          <target state="translated">TypeScript 3.5</target>
        </trans-unit>
        <trans-unit id="359b79f7544026e6404a7f5dc527aa3cfdbf0be7" translate="yes">
          <source>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</source>
          <target>TypeScript3.5には、型チェックをより効率的に行うために、TypeScript3.4よりもいくつかの最適化が含まれている。 これらの改善は、型チェックがコード補完リストのような操作を駆動するエディタシナリオで、より顕著になります。</target>
        </trans-unit>
        <trans-unit id="a6938b07665eedd653729021d3cce39e74883c08" translate="yes">
          <source>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</source>
          <target>TypeScript3.5では、この動作を一般化してコンストラクタ関数にも適用する。</target>
        </trans-unit>
        <trans-unit id="a73d70bff8d5fc727c0bd14cb107e1c1b473750e" translate="yes">
          <source>TypeScript 3.5 improves on 3.4&amp;rsquo;s &lt;code&gt;--incremental&lt;/code&gt; build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript&amp;rsquo;s project references in &lt;code&gt;--build&lt;/code&gt; mode, &lt;a href="https://github.com/Microsoft/TypeScript/pull/31101"&gt;we&amp;rsquo;ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4&lt;/a&gt;!</source>
          <target>TypeScript3.5は、世界の状態がどのように計算されたか、コンパイラ設定、ファイルが検索された理由、ファイルが見つかった場所などの情報を保存することによって、3.4&amp;rsquo;の&lt;code&gt;--incremental&lt;/code&gt;ビルドモードを改善しました。&lt;code&gt;--build&lt;/code&gt;モードでTypeScriptのプロジェクト参照を使用する数100のプロジェクトを含むシナリオでは、&lt;a href="https://github.com/Microsoft/TypeScript/pull/31101"&gt;&lt;/rsquo;ve,ve,the amount in units(real)は、TypeScript3.4&lt;/a&gt;と比較して、再ビルド時間を68%も削減できることを発見しました!</target>
        </trans-unit>
        <trans-unit id="8870d39de72c9538f7b989e9c665dcecc3f792f4" translate="yes">
          <source>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</source>
          <target>TypeScript3.5では型チェックとインクリメンタルビルドに関していくつかの最適化が導入されている。</target>
        </trans-unit>
        <trans-unit id="a67354830dc88bba666b8a01f15200fc520abe67" translate="yes">
          <source>TypeScript 3.5 introduces the new &lt;code&gt;Omit&lt;/code&gt; helper type, which creates a new type with some properties dropped from the original.</source>
          <target>TypeScript3.5では、新しい&lt;code&gt;Omit&lt;/code&gt;ヘルパー型が導入され、オリジナルからいくつかのプロパティが削除された新しい型が作成されます。</target>
        </trans-unit>
        <trans-unit id="860169965c68715ea7e25ddf2b4ae280a663fdd6" translate="yes">
          <source>TypeScript 3.6</source>
          <target state="translated">TypeScript 3.6</target>
        </trans-unit>
        <trans-unit id="43040204a5b205b20ce117e9abeba80afa37f954" translate="yes">
          <source>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</source>
          <target>TypeScript3.6では、ES2015以降のターゲットに送信する際に、識別子のユニコード文字のサポートが改善されている。</target>
        </trans-unit>
        <trans-unit id="bd36d48e4d1462dffb6c3c392323087bb23fcc1d" translate="yes">
          <source>TypeScript 3.6 introduces a new &lt;code&gt;__spreadArrays&lt;/code&gt; helper to accurately model what happens in ECMAScript 2015 in older targets outside of &lt;code&gt;--downlevelIteration&lt;/code&gt;. &lt;code&gt;__spreadArrays&lt;/code&gt; is also available in &lt;a href="https://github.com/Microsoft/tslib/"&gt;tslib&lt;/a&gt;.</source>
          <target>TypeScript3.6には新しい&lt;code&gt;__spreadArrays&lt;/code&gt;ヘルパーが導入され、&lt;code&gt;--downlevelIteration&lt;/code&gt;以外の古いターゲットでECMAScript2015で起こることを正確にモデル化します。&lt;code&gt;__spreadArrays&lt;/code&gt;は&lt;a href="https://github.com/Microsoft/tslib/"&gt;ツリブ&lt;/a&gt;でも利用できます。</target>
        </trans-unit>
        <trans-unit id="33cd49dc97acf9b88dbc38ffefb886129306a9c4" translate="yes">
          <source>TypeScript 3.6 introduces some improvements for when &lt;code&gt;Promise&lt;/code&gt;s are mis-handled.</source>
          <target>TypeScript3.6では、&lt;code&gt;Promise&lt;/code&gt;が誤って処理された場合にいくつかの改善が行われている。</target>
        </trans-unit>
        <trans-unit id="74c9e7c03722726e70a2ffe1f76f8a558869d112" translate="yes">
          <source>TypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</source>
          <target>TypeScript3.6では、イテレーターとジェネレーター関数のチェックが強化されています。 以前のバージョンでは、ジェネレーターのユーザーは、値がジェネレーターから生成されたか戻されたかを区別する方法がありませんでした。</target>
        </trans-unit>
        <trans-unit id="81aa3de148cf46d845b3cd5b3e434a89e256c4c6" translate="yes">
          <source>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can &lt;a href="https://github.com/microsoft/TypeScript/pull/32684"&gt;see more details in the original pull request here&lt;/a&gt;.</source>
          <target>TypeScript3.6は、他のモジュールを自動的にインポートする方法を決定する前に、既存のインポートを見ることについて、少し賢くなった。 詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32684"&gt;オリジナルのプルリクエストの&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="314b10ba05a1161535cb19963756c6c11ff953ee" translate="yes">
          <source>TypeScript 3.6 supports transforming &lt;code&gt;import.meta&lt;/code&gt; to &lt;code&gt;context.meta&lt;/code&gt; when your &lt;code&gt;module&lt;/code&gt; target is set to &lt;code&gt;system&lt;/code&gt;.</source>
          <target>TypeScript3.6は、&lt;code&gt;モジュール&lt;/code&gt;ターゲットが&lt;code&gt;system&lt;/code&gt;に設定されている場合、&lt;code&gt;import.meta&lt;/code&gt;を&lt;code&gt;context.meta&lt;/code&gt;に変換することをサポートする。</target>
        </trans-unit>
        <trans-unit id="5f7ed4364cfc54d058bc3677d8dbecd5e3827aa5" translate="yes">
          <source>TypeScript 3.7</source>
          <target state="translated">TypeScript 3.7</target>
        </trans-unit>
        <trans-unit id="27083dbf128c773c5403938ac6b066e57d56ab6a" translate="yes">
          <source>TypeScript 3.7 allows us to add &lt;code&gt;// @ts-nocheck&lt;/code&gt; comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of &lt;code&gt;checkJs&lt;/code&gt;, but we&amp;rsquo;ve expanded support to TypeScript files to make migrations easier for all users.</source>
          <target>TypeScript3.7では、&lt;code&gt;//@ts nocheck&lt;/code&gt;コメントをTypeScriptファイルの先頭に追加して、セマンティックチェックを無効にすることができます。 これまで、このコメントは&lt;code&gt;checkJs&lt;/code&gt;が存在するJavaScriptソースファイルでのみ尊重されていましたが、すべてのユーザが移行を簡単に行えるように、TypeScriptファイルのサポートを拡張しました。</target>
        </trans-unit>
        <trans-unit id="79e6c0e6d51157bb20e26a7e863eb63b56787312" translate="yes">
          <source>TypeScript Documentation</source>
          <target state="translated">TypeScript ドキュメント</target>
        </trans-unit>
        <trans-unit id="403fb75c6290c33e1ee26eea036308b48aa46bfe" translate="yes">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</source>
          <target>タイプスクリプトのバージョン: npmをインストールした場合:&lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9bf97b3981273152e80b422491273038dfba6f7" translate="yes">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</source>
          <target>タイプスクリプトのバージョン: npmをインストールした場合:&lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9786e84531c7e9e6709c98099bfd87c8dde49dc4" translate="yes">
          <source>TypeScript adds a new triple-slash-reference directive (&lt;code&gt;/// &amp;lt;reference lib="name" /&amp;gt;&lt;/code&gt;), allowing a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target>TypeScriptは、新しいトリプルスラッシュ参照ディレクティブ(&lt;code&gt;///&amp;lt;reference lib="name"/&amp;gt;&lt;/code&gt;)を追加し、ファイルに既存の組み込み&lt;em&gt;lib&lt;/em&gt;ファイルを明示的に含めることを可能にします。</target>
        </trans-unit>
        <trans-unit id="627afeb35305a2b7b628a49f47ad27ec0e7523cd" translate="yes">
          <source>TypeScript also has numeric literal types.</source>
          <target>TypeScriptには数値リテラル型もあります。</target>
        </trans-unit>
        <trans-unit id="f845ee328e4da8982a9cb87a1d1fe60de76cba85" translate="yes">
          <source>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned &lt;em&gt;off&lt;/em&gt; by default, and can be enabled using &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;.</source>
          <target>TypeScriptは、case節が空でないswitch文の中のfall-through caseのエラーを報告することができます。 このチェックはデフォルトで&lt;em&gt;オフ&lt;/em&gt;になっており、&lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;を使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="3883e486fe04d1f7d13e0ad9f1b9eb0d552664b9" translate="yes">
          <source>TypeScript comes with a &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that is the same as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; with all mutating methods removed, so you can make sure you don&amp;rsquo;t change your arrays after creation:</source>
          <target>TypeScriptには、&lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt;タイプが付属しています。これは、&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;と同じタイプで、すべての変更メソッドが削除されているため、作成後に配列を変更しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="c46782ad571ccfa1375c328c08d6d8a52aae9f4e" translate="yes">
          <source>TypeScript comes with certain checks to give you more safety and analysis of your program. Once you&amp;rsquo;ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.</source>
          <target>TypeScriptには、プログラムの安全性と分析を高めるためのチェック機能が付属しています。 コードベースをTypeScriptに変換したら、これらのチェックを有効にして安全性を高めることができます。</target>
        </trans-unit>
        <trans-unit id="982bd44a5cc8b5512117571aef28b0ebcb320b22" translate="yes">
          <source>TypeScript decorators are based on the &lt;a href="https://github.com/wycats/javascript-decorators"&gt;ES7 decorator proposal&lt;/a&gt;.</source>
          <target>TypeScriptデコレータは、&lt;a href="https://github.com/wycats/javascript-decorators"&gt;ES7デコレータ提案書&lt;/a&gt;に基づいています。</target>
        </trans-unit>
        <trans-unit id="250cd79d3d3268a25a6551d40fbaae96eebab0e3" translate="yes">
          <source>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;. Enter the new &lt;code&gt;object&lt;/code&gt; type.</source>
          <target>TypeScriptには、非プリミティブ型を表す型がありませんでした。つまり、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;symbol&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、または&lt;code&gt;undefined&lt;/code&gt;でない型です。新しい&lt;code&gt;object&lt;/code&gt;型を入力してください。</target>
        </trans-unit>
        <trans-unit id="fada45685495c730f9a9cc2a93bbb49026908546" translate="yes">
          <source>TypeScript doesn&amp;rsquo;t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we&amp;rsquo;re going to look at how you might start out. We assume you&amp;rsquo;ve read enough of the handbook to write new TypeScript code.</source>
          <target>TypeScriptは真空中には存在しない。 これはJavaScriptエコシステムを念頭に構築されたものであり、今日では多くのJavaScriptが存在します。 JavaScriptコードベースをTypeScriptに変換するのは少々面倒ですが、通常は難しくありません。 このチュートリアルでは、を開始する方法について説明します。 新しいTypeScriptコードを書くのに十分なハンドブックを読んだことを前提としています。</target>
        </trans-unit>
        <trans-unit id="1c8cdf286fbbcc4e7b49af3039a27393efcafa25" translate="yes">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler and end up in &lt;code&gt;dist&lt;/code&gt;.</source>
          <target>TypeScriptファイルは&lt;code&gt;src&lt;/code&gt;フォルダから始まり、TypeScriptコンパイラを通じて&lt;code&gt;dist&lt;/code&gt;に置かれる。</target>
        </trans-unit>
        <trans-unit id="59c18fee8487cdeda3b2f34b4ca8e8a543f5cab1" translate="yes">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler, then webpack, and end up in a &lt;code&gt;main.js&lt;/code&gt; file in &lt;code&gt;dist&lt;/code&gt;. Any components that we write will go in the &lt;code&gt;src/components&lt;/code&gt; folder.</source>
          <target>TypeScriptファイルは、&lt;code&gt;src&lt;/code&gt;フォルダから始まり、TypeScriptコンパイラ、webpackを経て、&lt;code&gt;dist&lt;/code&gt;内の&lt;code&gt;main.js&lt;/code&gt;ファイルになります。記述するコンポーネントは、&lt;code&gt;src/components&lt;/code&gt;フォルダに入ります。</target>
        </trans-unit>
        <trans-unit id="a367ff679df04f05c3c34e6560229bdc2557a732" translate="yes">
          <source>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with &lt;code&gt;Promise&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s.</source>
          <target>TypeScriptでは、常にパラメータを双方向に比較しています。 これにはいくつかの理由がありますが、&lt;code&gt;Promise&lt;/code&gt;や&lt;code&gt;Observable&lt;/code&gt;に見られる悪影響を見るまでは、これはユーザーにとって大きな問題ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="db02a42b5c74e823760580106f119d33d32acab0" translate="yes">
          <source>TypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.</source>
          <target>TypeScriptは従来、モジュールのインポート方法に関して過度に厳格でした。 これは、入力ミスを回避し、ユーザがモジュールを誤って使用するのを防ぐためです。</target>
        </trans-unit>
        <trans-unit id="b5b5002b156ed20abcb2373b3f1a34e30ef133d5" translate="yes">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href="basic-types"&gt;the Basic Types section&lt;/a&gt;. By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href="https://en.wikipedia.org/wiki/Null_pointer#History"&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target>TypeScriptには、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;の2つの特殊な型があり、それぞれ値nullとundefinedを持ちます。 これらについては、&lt;a href="basic types"&gt;「基本型」セクション&lt;/a&gt;で簡単に説明しました。デフォルトでは、型チェッカーは&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;を任意の型に割り当てることができます。 事実上、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;は、すべてのタイプの有効な値です。 つまり、どのタイプにも割り当てられないように&lt;em&gt;停止&lt;/em&gt;することはできません。 &lt;code&gt;null&lt;/code&gt;の考案者であるTony Hoare氏は、これを&lt;a href="https://en.wikipedia.org/wiki/Null_pointer#History"&gt;&amp;ldquo;1,000,000,000ドルの間違い&amp;rdquo;&lt;/a&gt;と呼んでいる。</target>
        </trans-unit>
        <trans-unit id="75fc1f90351ac73e35a5f3f576d18314c46dc6c2" translate="yes">
          <source>TypeScript has two special types, Null and Undefined, that have the values &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Previously it was not possible to explicitly name these types, but &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; may now be used as type names regardless of type checking mode.</source>
          <target>TypeScriptには、&lt;code&gt;null&lt;/code&gt;と&lt;code&gt;undefined&lt;/code&gt;という2つの特殊な型があります。 以前は、これらの型に明示的に名前を付けることはできませんでしたが、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;が型チェックモードに関係なく型名として使用されるようになりました。</target>
        </trans-unit>
        <trans-unit id="669ae0c383f0ebc9a1b71a33795f2fba316ff636" translate="yes">
          <source>TypeScript in 5 minutes</source>
          <target state="translated">5分で覚えるTypeScript</target>
        </trans-unit>
        <trans-unit id="452bd92ef7047873dae5fa9a26760186598678c6" translate="yes">
          <source>TypeScript in 5 minutes: Building your first TypeScript file</source>
          <target state="translated">5分で覚えるTypeScript:最初のTypeScriptファイルを構築する</target>
        </trans-unit>
        <trans-unit id="cfe56778efe914c509395d743856f638e0b2dc80" translate="yes">
          <source>TypeScript in 5 minutes: Classes</source>
          <target state="translated">5分で覚えるTypeScript:クラス</target>
        </trans-unit>
        <trans-unit id="66f6d1b030c2c31817cfd629aeaf4e9f8e001440" translate="yes">
          <source>TypeScript in 5 minutes: Compiling your code</source>
          <target state="translated">5分で覚えるTypeScript:コードをコンパイルする</target>
        </trans-unit>
        <trans-unit id="64b3883005157157bc3e05fd1909ad05a7782093" translate="yes">
          <source>TypeScript in 5 minutes: Installing TypeScript</source>
          <target state="translated">5分で覚えるTypeScript:TypeScriptをインストールする</target>
        </trans-unit>
        <trans-unit id="679437aa54596d7921f489403e44c2b30fef5aed" translate="yes">
          <source>TypeScript in 5 minutes: Interfaces</source>
          <target state="translated">5分で覚えるTypeScript:インターフェイス</target>
        </trans-unit>
        <trans-unit id="520fec1d849d26fa3641ec76d5fda0df2e56b07e" translate="yes">
          <source>TypeScript in 5 minutes: Running your TypeScript web app</source>
          <target state="translated">5分で覚えるTypeScript:TypeScript Webアプリケーションを実行する</target>
        </trans-unit>
        <trans-unit id="6a574132fb48839d07c1e73530345fd9189655e2" translate="yes">
          <source>TypeScript in 5 minutes: Type annotations</source>
          <target state="translated">5分で覚えるTypeScript:型アノテーション</target>
        </trans-unit>
        <trans-unit id="fa27fdf7da61b594edc2419147ebeb6293bab089" translate="yes">
          <source>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>TypeScriptには、デコレータを持つ宣言のための特定のタイプのメタデータを送信する実験的なサポートが含まれている。 この試験的サポートを有効にするには、コマンドラインまたは&lt;code&gt;tsconfig.json&lt;/code&gt;で&lt;code&gt;emitDecoratorMetadata&lt;/code&gt;コンパイラオプションを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="65097970997af32f38424bf7e3969825b3d282b6" translate="yes">
          <source>TypeScript injects a handful of helper functions such as &lt;code&gt;__extends&lt;/code&gt; for inheritance, &lt;code&gt;__assign&lt;/code&gt; for spread operator in object literals and JSX elements, and &lt;code&gt;__awaiter&lt;/code&gt; for async functions.</source>
          <target>TypeScriptは、継承のための&lt;code&gt;__extends&lt;/code&gt;、オブジェクトリテラルとJSX要素の拡散演算子のための&lt;code&gt;__assign&lt;/code&gt;、非同期関数のための&lt;code&gt;__アワイター&lt;/code&gt;など、いくつかのヘルパー関数を注入します。</target>
        </trans-unit>
        <trans-unit id="4865203c87f3f94d8f8566ed718390d0119234fb" translate="yes">
          <source>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</source>
          <target>TypeScriptは構造型システムです。 2つの異なる型をどこから来たかにかかわらず比較するとき、すべてのメンバーの型が互換性がある場合、型自体が互換性があると言います。</target>
        </trans-unit>
        <trans-unit id="34561d366244e5a8026b992c9607c61e8831d43f" translate="yes">
          <source>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won&amp;acirc;&amp;euro;&amp;trade;t add one.</source>
          <target>TypeScriptは、これらの種類の編集を適用するときに、ファイルがセミコロンを使用しているかどうかを検出できるようになりました。 通常、ファイルにセミコロンがない場合、TypeScriptは&amp;acirc;&amp;euro;&amp;trade;を追加しません。</target>
        </trans-unit>
        <trans-unit id="c0716da88bf8553ba341ae10829c8d80565f07b2" translate="yes">
          <source>TypeScript might compile this down to something like the the following JavaScript:</source>
          <target>TypeScriptはこれを次のようなJavaScriptにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="32fed70cd34feef29d0649f498d61da78cbda0ab" translate="yes">
          <source>TypeScript now only strictly enforces the visibility of types in modules if the &lt;code&gt;--declaration&lt;/code&gt; flag is provided. This is very useful for Angular scenarios, for example:</source>
          <target>TypeScriptは、&lt;code&gt;--declaration&lt;/code&gt;フラグが指定された場合にのみ、モジュール内の型の可視性を厳密に強制します。 これは、次のようなAngularシナリオで非常に便利です。</target>
        </trans-unit>
        <trans-unit id="bf627cab04633b795ac087dea296a4bdb609bc4d" translate="yes">
          <source>TypeScript now supports &lt;a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components"&gt;Function components&lt;/a&gt;. These are lightweight components that easily compose other components:</source>
          <target>TypeScriptは、&lt;a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components"&gt;関数コンポーネント&lt;/a&gt;をサポートするようになりました。これらは、他のコンポーネントを簡単に構成できる軽量コンポーネントです。</target>
        </trans-unit>
        <trans-unit id="52d1c2115b1983ad21a42bf4d3fb47956062ab0c" translate="yes">
          <source>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</source>
          <target>TypeScriptがES6テンプレート文字列をサポートするようになった。 次に、任意の式を文字列に埋め込む簡単な方法を示します。</target>
        </trans-unit>
        <trans-unit id="dca2d3b95767ef524c8d3421355c36053ab3819a" translate="yes">
          <source>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the &lt;code&gt;async&lt;/code&gt; keyword; &lt;code&gt;await&lt;/code&gt; suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the &lt;code&gt;Promise&lt;/code&gt; returned.</source>
          <target>TypeScriptはES6ジェネレータ(例えばNode v4以上)をネイティブでサポートするエンジンの非同期関数をサポートする。 非同期関数には、&lt;code&gt;async&lt;/code&gt;キーワードがプレフィクスとして付加されます。&lt;code&gt;await&lt;/code&gt;は、非同期関数のリターンのpromiseが満たされるまで実行を中断し、返された&lt;code&gt;Promise&lt;/code&gt;の値をアンラップします。</target>
        </trans-unit>
        <trans-unit id="0e7958ec88d9f0faef067488c643d885da64e7bf" translate="yes">
          <source>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you&amp;rsquo;ll get stricter checks when relating two generic signatures, and may catch some bugs.</source>
          <target>TypeScriptは、2つの単一シグネチャ型を比較するときに型パラメータを統一しようとするようになった。 その結果、2つの一般的な署名を関連付けるときにチェックが厳しくなり、いくつかのバグが見つかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d62273ee78dee44c5da22f4945f26ce4659fc27f" translate="yes">
          <source>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</source>
          <target>TypeScriptには、一般的な型変換を容易にするいくつかのユーティリティ型があります。 これらのユーティリティはグローバルに使用できます。</target>
        </trans-unit>
        <trans-unit id="988860fc02a853b3a27d2af5425c58bd62c2eceb" translate="yes">
          <source>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, &lt;em&gt;and extraneous arguments are allowed&lt;/em&gt;. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</source>
          <target>TypeScriptは、ソースの引数&lt;em&gt;と無関係な引数&lt;/em&gt;を使用してターゲットの署名を呼び出せるかどうかを確認することで、署名の互換性を解決します。たとえば、次のコードでは、オプションのパラメータを使用して署名が正しく書き込まれた場合にのみバグが発生します。</target>
        </trans-unit>
        <trans-unit id="8a0c2fdfc90997d639e7e23066198c7742ba74d7" translate="yes">
          <source>TypeScript ships with three JSX modes: &lt;code&gt;preserve&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt;, and &lt;code&gt;react-native&lt;/code&gt;. These modes only affect the emit stage - type checking is unaffected. The &lt;code&gt;preserve&lt;/code&gt; mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. &lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt;). Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension. The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension. The &lt;code&gt;react-native&lt;/code&gt; mode is the equivalent of &lt;code&gt;preserve&lt;/code&gt; in that it keeps all JSX, but the output will instead have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target>TypeScriptには、&lt;code&gt;preserve&lt;/code&gt;、&lt;code&gt;react&lt;/code&gt;、および&lt;code&gt;react-native&lt;/code&gt;の3つのJSXモードが付属しています。これらのモードは、emitステージにのみ影響し、型チェックは影響を受けません。 &lt;code&gt;preserve&lt;/code&gt;モードは、別の変換ステップ(例えば&lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt;)によってさらに消費されるように、出力の一部としてJSXを維持します。 また、出力にはファイル拡張子&lt;code&gt;.jsx&lt;/code&gt;が付きます。 &lt;code&gt;react&lt;/code&gt;モードは&lt;code&gt;React.createElement&lt;/code&gt;を出力し、使用前にJSX変換を行う必要はなく、出力には&lt;code&gt;.js&lt;/code&gt;ファイル拡張子が付きます。 &lt;code&gt;react-native&lt;/code&gt;モードは、すべてのJSXを保持するという点で&lt;code&gt;preserve&lt;/code&gt;と同じですが、出力には&lt;code&gt;.js&lt;/code&gt;ファイル拡張子が付きます。</target>
        </trans-unit>
        <trans-unit id="f2cd47e8e27537ecdbea6c76c0813851141bdf88" translate="yes">
          <source>TypeScript ships with two JSX modes: &lt;code&gt;preserve&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt;.</source>
          <target>TypeScriptには、&lt;code&gt;preserve&lt;/code&gt;と&lt;code&gt;react&lt;/code&gt;の2つのJSXモードが付属している。</target>
        </trans-unit>
        <trans-unit id="a68cb065a26c6d898de1ad77c499a5380c7336c0" translate="yes">
          <source>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</source>
          <target>TypeScriptは、オブジェクトのメンバへのアクセスをインターセプトする方法として、getter/setterをサポートします。 これにより、各オブジェクトでメンバーにアクセスする方法をより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="b66debd096de5790d32615c82aeae20dd89c1b00" translate="yes">
          <source>TypeScript treats a namespace import (i.e. &lt;code&gt;import * as foo from "foo"&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const foo = require("foo")&lt;/code&gt;.Things are simple here, but they don&amp;rsquo;t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (&lt;code&gt;foo&lt;/code&gt; in the example above) is not callable, though allowed by TypeScript</source>
          <target>TypeScriptは、CommonJS/AMD/UMDモジュールの名前空間インポート(つまり、&lt;code&gt;import*as foo from"foo"&lt;/code&gt;)を、&lt;code&gt;const foo=require("foo")&lt;/code&gt;と同じように扱います。ここでは簡単ですが、インポートされるプライマリオブジェクトがプリミティブであるか、クラスまたは関数である場合には、うまくいきません。 ECMAScript仕様では、名前空間レコードはプレーンオブジェクトであり、名前空間インポート(上記の例では&lt;code&gt;foo&lt;/code&gt;)はTypeScriptで許可されているが、呼び出せないと規定している。</target>
        </trans-unit>
        <trans-unit id="190d779979c1c225024b4faf8c71539ad6be2768" translate="yes">
          <source>TypeScript used the &lt;code&gt;module&lt;/code&gt; keyword to define both &amp;ldquo;internal modules&amp;rdquo; and &amp;ldquo;external modules&amp;rdquo;; this has been a bit of confusion for developers new to TypeScript. &amp;ldquo;Internal modules&amp;rdquo; are closer to what most people would call a namespace; likewise, &amp;ldquo;external modules&amp;rdquo; in JS speak really just are modules now.</source>
          <target>TypeScriptは、&lt;code&gt;module&lt;/code&gt;キーワードを使用して、&amp;ldquo;internal modules&amp;rdquo;と&amp;ldquo;external modules&amp;rdquo;の両方を定義しました。これは、TypeScriptを初めて使用する開発者にとっては少し混乱していました。 &amp;ldquo;Internal modules&amp;rdquo;は、ほとんどの人が名前空間と呼ぶものに近いです。同様に、JSの&amp;ldquo;external modules&amp;rdquo;は、まさに現在のモジュールです。</target>
        </trans-unit>
        <trans-unit id="1b58b6b726ed6ef37d5ab19f3e08450acedef197" translate="yes">
          <source>TypeScript uses a file called &lt;code&gt;tsconfig.json&lt;/code&gt; for managing your project&amp;rsquo;s options, such as which files you want to include, and what sorts of checking you want to perform. Let&amp;rsquo;s create a bare-bones one for our project:</source>
          <target>TypeScriptは&lt;code&gt;tsconfig.json&lt;/code&gt;というファイルを使用して、含めるファイルや実行するチェックの種類など、プロジェクトのオプションを管理します。 プロジェクトに必要なものだけを作成する:</target>
        </trans-unit>
        <trans-unit id="f56d1e973d936e7e25808ece950aef4bac63d378" translate="yes">
          <source>TypeScript uses the &lt;a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components"&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target>TypeScriptは、&lt;a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components"&gt;Reactと同じ規則&lt;/a&gt;を使ってこれらを区別する。 組み込み要素は常に小文字で始まり、値ベースの要素は常に大文字で始まります。</target>
        </trans-unit>
        <trans-unit id="a94cd2357ef6caf93ae4025491d6f6435c0dfc38" translate="yes">
          <source>TypeScript will also now compute enum values when possible:</source>
          <target>TypeScriptは可能な場合にはenum値も計算する。</target>
        </trans-unit>
        <trans-unit id="363493eaf871474aebe9c026f44b9b57be878dd1" translate="yes">
          <source>TypeScript will also warn about unreachable code and labels, which you can disable with &lt;code&gt;allowUnreachableCode&lt;/code&gt; and &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectively.</source>
          <target>TypeScriptは到達不能なコードとラベルについても警告します。これらはそれぞれ&lt;code&gt;allowUnreachableCode&lt;/code&gt;と&lt;code&gt;allowUnusedLabels&lt;/code&gt;で無効にできます。</target>
        </trans-unit>
        <trans-unit id="e8a61643ec3271fd661861cae15f39927b074e83" translate="yes">
          <source>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt;) over Node&amp;rsquo;s resolution logic. TypeScript will also use a field in &lt;code&gt;package.json&lt;/code&gt; named &lt;code&gt;"types"&lt;/code&gt; to mirror the purpose of &lt;code&gt;"main"&lt;/code&gt; - the compiler will use it to find the &amp;ldquo;main&amp;rdquo; definition file to consult.</source>
          <target>TypeScriptは、コンパイル時にモジュールの定義ファイルを見つけるために、Node.jsのランタイム解決戦略を模倣する。 これを実現するために、TypeScriptはTypeScriptソースファイル拡張子(&lt;code&gt;.ts&lt;/code&gt;、&lt;code&gt;.tsx&lt;/code&gt;、および&lt;code&gt;.d.ts&lt;/code&gt;)をノードの解決ロジックの上に重ねます。 TypeScriptはまた、&lt;code&gt;"types"&lt;/code&gt;という名前の&lt;code&gt;package.json&lt;/code&gt;内のフィールドを使用して、&lt;code&gt;"main"&lt;/code&gt;の目的を反映させます。コンパイラはこのフィールドを使用して、参照する&amp;ldquo;main&amp;rdquo;定義ファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="d20fd8b3bcedf7d11d40c55cf087585df77e7708" translate="yes">
          <source>TypeScript will say that you can&amp;rsquo;t assign to &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;volume&lt;/code&gt; because it first figured out the type of &lt;code&gt;options&lt;/code&gt; as &lt;code&gt;{}&lt;/code&gt; which doesn&amp;rsquo;t have any properties. If you instead moved the declarations into the object literal themselves, you&amp;rsquo;d get no errors:</source>
          <target>TypeScriptは&lt;code&gt;color&lt;/code&gt;と&lt;code&gt;volume&lt;/code&gt;には代入できないと言っています。なぜなら、&lt;code&gt;options&lt;/code&gt;のタイプを&lt;code&gt;{}&lt;/code&gt;として最初に見つけたからです。 宣言をオブジェクトリテラル自体に移動した場合、エラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="cd367b77df54efafc687e3d2bce712bf9f604879" translate="yes">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--pretty&lt;/code&gt; flag can make error messages easier to read and manage. &lt;code&gt;--pretty&lt;/code&gt; now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</source>
          <target>TypeScript&amp;rsquo;s&lt;code&gt;--pretty&lt;/code&gt;フラグを使用すると、エラーメッセージの読み取りと管理が容易になります。 &lt;code&gt;--pretty&lt;/code&gt;は、ファイル名、診断コード、および行番号に色を使用するようになりました。 ファイル名と位置も共通の端末(例えばVisual Studio Code端末)でナビゲーションできるようにフォーマットされるようになった。</target>
        </trans-unit>
        <trans-unit id="82367d5505123220713eb9aa76910332cb1314fc" translate="yes">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; mode now clears the screen after a re-compilation is requested.</source>
          <target>TypeScript&amp;rsquo;s&lt;code&gt;--watch&lt;/code&gt;モードで、再コンパイルが要求された後に画面がクリアされるようになりました。</target>
        </trans-unit>
        <trans-unit id="e240610ed534bc76d20bc7bebb7e8fd4ee492fe3" translate="yes">
          <source>TypeScript&amp;rsquo;s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript&amp;rsquo;s automatic semicolon insertion (ASI) rules. The setting is available now in &lt;a href="https://code.visualstudio.com/insiders/"&gt;Visual Studio Code Insiders&lt;/a&gt;, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</source>
          <target>TypeScript&amp;rsquo;の組み込みフォーマッタで、JavaScript&amp;rsquo;の自動セミコロン挿入(ASI)規則のために末尾のセミコロンがオプションの場所で、セミコロンの挿入と削除がサポートされるようになりました。 この設定は、現在&lt;a href="https://code.visualstudio.com/insiders/"&gt;Visual Studio Code Insiders&lt;/a&gt;で利用可能であり、Visual Studio16.4Preview2の[ツール][オプション]メニューで利用できる。</target>
        </trans-unit>
        <trans-unit id="08c6179dcf1375ce19533b773a6b25765f412389" translate="yes">
          <source>TypeScript&amp;rsquo;s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn&amp;rsquo;t been built (or whose output was out of date) meant that the editing experience wouldn&amp;rsquo;t work well.</source>
          <target>TypeScript&amp;rsquo;のプロジェクトリファレンスを使用すると、コードベースを簡単に分割してコンパイルを高速化できます。 残念ながら、依存関係が構築されていない(または出力が最新でない)プロジェクトを編集することは、編集作業がうまくいかないことを意味していました。</target>
        </trans-unit>
        <trans-unit id="8e33dd464f3004daae495bfbf61b1d8f4515a8bc" translate="yes">
          <source>TypeScript&amp;rsquo;s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it&amp;rsquo;s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</source>
          <target>TypeScript&amp;rsquo;の構造型システムは、通常のJavaScriptコードの記述方法に基づいて設計されました。 JavaScriptは関数式やオブジェクトリテラルのような匿名オブジェクトを広く使用しているので、JavaScriptライブラリにある関係の種類を、名目上の型システムではなく構造型システムで表現する方がずっと自然です。</target>
        </trans-unit>
        <trans-unit id="bb4cd132d17765763f4ec7ad513fe8c0ba6e5307" translate="yes">
          <source>TypeScript&amp;rsquo;s type system allows certain operations that can&amp;rsquo;t be known at compile-time to be safe. When a type system has this property, it is said to not be &amp;ldquo;sound&amp;rdquo;. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we&amp;rsquo;ll explain where these happen and the motivating scenarios behind them.</source>
          <target>TypeScript&amp;rsquo;の型システムでは、コンパイル時に認識できない操作を安全に実行できます。 タイプシステムにこのプロパティがある場合、&amp;ldquo;sound&amp;rdquo;ではないと言われます。 TypeScriptが不健全な振る舞いを許す場所は注意深く考慮され、本書を通して、それらがどこで起こるか、そしてそれらの動機となるシナリオを説明します。</target>
        </trans-unit>
        <trans-unit id="349e8ba90638f01a95ebe613d90e5ffbcee9736b" translate="yes">
          <source>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &lt;code&gt;[]&lt;/code&gt; to denote an array of that element type:</source>
          <target>TypeScriptでは、JavaScriptと同様に、値の配列を操作できます。 配列型は、次の2つの方法のいずれかで記述できます。 最初の例では、要素の型の後に&lt;code&gt;[]&lt;/code&gt;を付けて、その要素型の配列を示します。</target>
        </trans-unit>
        <trans-unit id="4ad04619aba3f2f4ed81caa26fedf4a7d7810729" translate="yes">
          <source>TypeScript-Preview</source>
          <target>TypeScriptプレビュー</target>
        </trans-unit>
        <trans-unit id="41d9bbe35312804100303ce4556c7c954c09e309" translate="yes">
          <source>TypeScriptAdditionalFlags</source>
          <target>TypeScriptAdditionalFlags</target>
        </trans-unit>
        <trans-unit id="7b5fe2a5e0980eb4438ba0537940cad4dba1cbf4" translate="yes">
          <source>TypeScriptAllowSyntheticDefaultImports</source>
          <target>TypeScriptAllowSyntheticDefaultImports</target>
        </trans-unit>
        <trans-unit id="a94bfbe88239bd8121e18f907e172dde0a5dee8d" translate="yes">
          <source>TypeScriptAllowUnreachableCode</source>
          <target>TypeScriptAllowUnreachableCode</target>
        </trans-unit>
        <trans-unit id="a57b98365d2468c29049e5c8c8ee824604a3fdb7" translate="yes">
          <source>TypeScriptAllowUnusedLabels</source>
          <target>TypeScriptAllowUnusedLabels</target>
        </trans-unit>
        <trans-unit id="52c7a27301fde259e8f6bb99fc56cb8133f9b303" translate="yes">
          <source>TypeScriptAlwaysStrict</source>
          <target>TypeScriptAlwaysStrict</target>
        </trans-unit>
        <trans-unit id="2ed81307b38a7333d37096546abf4a0b57b93c74" translate="yes">
          <source>TypeScriptBaseUrl</source>
          <target>TypeScriptBaseUrl</target>
        </trans-unit>
        <trans-unit id="77f797b2abb4954f5643abb4b5b80d59868c9236" translate="yes">
          <source>TypeScriptCharset</source>
          <target>TypeScriptCharset</target>
        </trans-unit>
        <trans-unit id="107cd94d243e6194c069f50feafef3b1230a7556" translate="yes">
          <source>TypeScriptCompileBlocked</source>
          <target>TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="7acf8c8a12467f8aca42a0fb5a3ef1f764482e71" translate="yes">
          <source>TypeScriptDeclarationDir</source>
          <target>TypeScriptDeclarationDir</target>
        </trans-unit>
        <trans-unit id="4a2236f58ea00d2b0bb17b6cea7aca0c8a68c053" translate="yes">
          <source>TypeScriptESModuleInterop</source>
          <target>TypeScriptESModuleInterop</target>
        </trans-unit>
        <trans-unit id="55c811b895566e510d35f99a3a36ec8a3177f330" translate="yes">
          <source>TypeScriptEmitBOM</source>
          <target>TypeScriptEmitBOM</target>
        </trans-unit>
        <trans-unit id="b2959142651db2ba36f7a76acb1a7cd0464dd2f0" translate="yes">
          <source>TypeScriptEmitDeclarationOnly</source>
          <target>TypeScriptEmitDeclarationOnly</target>
        </trans-unit>
        <trans-unit id="17656226f24afbbb0494dc47d1fdf5cb6aec6e7e" translate="yes">
          <source>TypeScriptEmitDecoratorMetadata</source>
          <target>TypeScriptEmitDecoratorMetadata</target>
        </trans-unit>
        <trans-unit id="f1a24003307b278d63a345cf4646070ee3538d81" translate="yes">
          <source>TypeScriptExperimentalAsyncFunctions</source>
          <target>TypeScriptExperimentalAsyncFunctions</target>
        </trans-unit>
        <trans-unit id="f178eb0d68749f84390526fcfcf73643580199b8" translate="yes">
          <source>TypeScriptExperimentalDecorators</source>
          <target>TypeScriptExperimentalDecorators</target>
        </trans-unit>
        <trans-unit id="227102f3c5d5c0c4fe35d5a94e14769df56ea3ea" translate="yes">
          <source>TypeScriptForceConsistentCasingInFileNames</source>
          <target>TypeScriptForceConsistentCasingInFileNames</target>
        </trans-unit>
        <trans-unit id="e8221bda0f5ae2cb80b553adafbf9c7d7eb1ff79" translate="yes">
          <source>TypeScriptGeneratesDeclarations</source>
          <target>TypeScriptGeneratesDeclarations</target>
        </trans-unit>
        <trans-unit id="12faa091e4a57a36c933420258af4a9f60dccc85" translate="yes">
          <source>TypeScriptImportHelpers</source>
          <target>TypeScriptImportHelpers</target>
        </trans-unit>
        <trans-unit id="ee1203ba67f873be0ddd284d0922dc4eaed56181" translate="yes">
          <source>TypeScriptInlineSourceMap</source>
          <target>TypeScriptInlineSourceMap</target>
        </trans-unit>
        <trans-unit id="388355e20cca01322235dfa01c312ca0d6781b5a" translate="yes">
          <source>TypeScriptInlineSources</source>
          <target>TypeScriptInlineSources</target>
        </trans-unit>
        <trans-unit id="d77acf48160dec4408ea9726aa2e65d9aca96302" translate="yes">
          <source>TypeScriptIsolatedModules</source>
          <target>TypeScriptIsolatedModules</target>
        </trans-unit>
        <trans-unit id="956314972e52b72d9e36530ee0a4e72a92acae0b" translate="yes">
          <source>TypeScriptJSXEmit</source>
          <target>TypeScriptJSXEmit</target>
        </trans-unit>
        <trans-unit id="a67c071d130c25aefdb45b19dfa130ff6bb485ad" translate="yes">
          <source>TypeScriptJSXFactory</source>
          <target>TypeScriptJSXFactory</target>
        </trans-unit>
        <trans-unit id="4552cc5179a4f2f2d43bbca69cfe48ae1d8a59ca" translate="yes">
          <source>TypeScriptLib</source>
          <target>TypeScriptLib</target>
        </trans-unit>
        <trans-unit id="0572909efb507dda301b9d8012fab7e5de772948" translate="yes">
          <source>TypeScriptMapRoot</source>
          <target>TypeScriptMapRoot</target>
        </trans-unit>
        <trans-unit id="dc7b169788198faee3555056c08f9f57327e0a3f" translate="yes">
          <source>TypeScriptModuleKind</source>
          <target>TypeScriptModuleKind</target>
        </trans-unit>
        <trans-unit id="421c0ae622f44c1602b14f2b708d2cca0d2934ce" translate="yes">
          <source>TypeScriptModuleResolution</source>
          <target>TypeScriptModuleResolution</target>
        </trans-unit>
        <trans-unit id="35fa542971e052e37cc4839000b5258adf72a14c" translate="yes">
          <source>TypeScriptNewLine</source>
          <target>TypeScriptNewLine</target>
        </trans-unit>
        <trans-unit id="fc2a8ef1565c45f435f3d5ef342d1c6dae60cbb5" translate="yes">
          <source>TypeScriptNoEmitHelpers</source>
          <target>TypeScriptNoEmitHelpers</target>
        </trans-unit>
        <trans-unit id="e36e19ff5e1f6a8202b09c668028ec57276c68b9" translate="yes">
          <source>TypeScriptNoEmitOnError</source>
          <target>TypeScriptNoEmitOnError</target>
        </trans-unit>
        <trans-unit id="5b756225451ecee18834373559b43fedcb96fba8" translate="yes">
          <source>TypeScriptNoFallthroughCasesInSwitch</source>
          <target>TypeScriptNoFallthroughCasesInSwitch</target>
        </trans-unit>
        <trans-unit id="d92e432f5565e45efa98aec9e0c61f938d26c756" translate="yes">
          <source>TypeScriptNoImplicitAny</source>
          <target>TypeScriptNoImplicitAny</target>
        </trans-unit>
        <trans-unit id="1c9c8201c130add485ca511eb79ea6e375bc4375" translate="yes">
          <source>TypeScriptNoImplicitReturns</source>
          <target>TypeScriptNoImplicitReturns</target>
        </trans-unit>
        <trans-unit id="3f55bf3dfa28bf03f3b28f94aa19817851b78cae" translate="yes">
          <source>TypeScriptNoImplicitThis</source>
          <target>TypeScriptNoImplicitThis</target>
        </trans-unit>
        <trans-unit id="6f256f510247fb48347ab1a84a79bfdc18f35187" translate="yes">
          <source>TypeScriptNoImplicitUseStrict</source>
          <target>TypeScriptNoImplicitUseStrict</target>
        </trans-unit>
        <trans-unit id="8bd63af2b503b90aadf320b0938c7cc2e9e1080f" translate="yes">
          <source>TypeScriptNoLib</source>
          <target>TypeScriptNoLib</target>
        </trans-unit>
        <trans-unit id="aba68b0d2bfe600c1b7505f9cf090259fafedf3a" translate="yes">
          <source>TypeScriptNoResolve</source>
          <target>TypeScriptNoResolve</target>
        </trans-unit>
        <trans-unit id="362c0511319630974131db1f54ca0f8546597ce7" translate="yes">
          <source>TypeScriptNoStrictGenericChecks</source>
          <target>TypeScriptNoStrictGenericChecks</target>
        </trans-unit>
        <trans-unit id="dfa69886ed42a2dc63f9a0eab77d8450ce96b009" translate="yes">
          <source>TypeScriptNoUnusedLocals</source>
          <target>TypeScriptNoUnusedLocals</target>
        </trans-unit>
        <trans-unit id="cefd9f6aa4a0ee3b0be73fb43be3ecc77bfe22df" translate="yes">
          <source>TypeScriptNoUnusedParameters</source>
          <target>TypeScriptNoUnusedParameters</target>
        </trans-unit>
        <trans-unit id="6565a78c53fe02fdb81995bb6c6ec68f1f0ea3bd" translate="yes">
          <source>TypeScriptOutDir</source>
          <target>TypeScriptOutDir</target>
        </trans-unit>
        <trans-unit id="b14c0569c9dd07bb52cefa5e53a9ee362f59b00f" translate="yes">
          <source>TypeScriptOutFile</source>
          <target>TypeScriptOutFile</target>
        </trans-unit>
        <trans-unit id="644b7783acc77f0caa187daf9c367ba62b739548" translate="yes">
          <source>TypeScriptPreserveConstEnums</source>
          <target>TypeScriptPreserveConstEnums</target>
        </trans-unit>
        <trans-unit id="44c9e768eb6070e00bdba352e27ce7e68b24160f" translate="yes">
          <source>TypeScriptPreserveSymlinks</source>
          <target>TypeScriptPreserveSymlinks</target>
        </trans-unit>
        <trans-unit id="4130284b0addaca5f98609c12c577055315ad705" translate="yes">
          <source>TypeScriptReactNamespace</source>
          <target>TypeScriptReactNamespace</target>
        </trans-unit>
        <trans-unit id="373f7134beec8752f28917f8c2d07c6972a8eda7" translate="yes">
          <source>TypeScriptRemoveComments</source>
          <target>TypeScriptRemoveComments</target>
        </trans-unit>
        <trans-unit id="72de35523759783c4427070755e0bb5453621f68" translate="yes">
          <source>TypeScriptRootDir</source>
          <target>TypeScriptRootDir</target>
        </trans-unit>
        <trans-unit id="6aa743721c9942df651b926d8a6b9d1d8b06dee1" translate="yes">
          <source>TypeScriptSkipDefaultLibCheck</source>
          <target>TypeScriptSkipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="8bfb0bbce64d6d061521026129b6afc021fdb739" translate="yes">
          <source>TypeScriptSkipLibCheck</source>
          <target>TypeScriptSkipLibCheck</target>
        </trans-unit>
        <trans-unit id="11cea9751a4427f602e3999e641567437522451c" translate="yes">
          <source>TypeScriptSourceMap</source>
          <target>TypeScriptSourceMap</target>
        </trans-unit>
        <trans-unit id="981b0099a78995ed3e09e63f3468ae20d833111d" translate="yes">
          <source>TypeScriptSourceRoot</source>
          <target>TypeScriptSourceRoot</target>
        </trans-unit>
        <trans-unit id="144320f2ae79b3129b36ee19ddeac0b49fefd1cb" translate="yes">
          <source>TypeScriptStrict</source>
          <target>TypeScriptStrict</target>
        </trans-unit>
        <trans-unit id="dd87b21546d155f9fa69bfbdc72090ba951be0b1" translate="yes">
          <source>TypeScriptStrictFunctionTypes</source>
          <target>TypeScriptStrictFunctionTypes</target>
        </trans-unit>
        <trans-unit id="a6d54bf19b0c132487ec76f847985482640ea044" translate="yes">
          <source>TypeScriptStrictNullChecks</source>
          <target>TypeScriptStrictNullChecks</target>
        </trans-unit>
        <trans-unit id="102ce2e8221cdb409f6a7a01055c5b3f52db3b57" translate="yes">
          <source>TypeScriptStrictPropertyInitialization</source>
          <target>TypeScriptStrictPropertyInitialization</target>
        </trans-unit>
        <trans-unit id="565bf41241b63a69256bebd7801f835b429830df" translate="yes">
          <source>TypeScriptStripInternal</source>
          <target>TypeScriptStripInternal</target>
        </trans-unit>
        <trans-unit id="558de0db52b8fdbbfefba7315f0e5b368e1bccc8" translate="yes">
          <source>TypeScriptSuppressExcessPropertyErrors</source>
          <target>TypeScriptSuppressExcessPropertyErrors</target>
        </trans-unit>
        <trans-unit id="321f13b1fb2371cd5951fbfd893bddec800abf02" translate="yes">
          <source>TypeScriptSuppressImplicitAnyIndexErrors</source>
          <target>TypeScriptSuppressImplicitAnyIndexErrors</target>
        </trans-unit>
        <trans-unit id="1df2c0c33e87134f7b9585a2fc5c306565947b0c" translate="yes">
          <source>TypeScriptTarget</source>
          <target>TypeScriptTarget</target>
        </trans-unit>
        <trans-unit id="71d1dceb1918725eab2477bf3bc8195ca94011da" translate="yes">
          <source>TypeScriptUseDefineForClassFields</source>
          <target>TypeScriptUseDefineForClassFields</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes">
          <source>Types</source>
          <target>種類</target>
        </trans-unit>
        <trans-unit id="34915d42cc54d52a01ea82c5bdce2991a6ef1cbb" translate="yes">
          <source>Types can exist in &lt;em&gt;namespaces&lt;/em&gt;. For example, if we have the declaration &lt;code&gt;let x: A.B.C&lt;/code&gt;, we say that the type &lt;code&gt;C&lt;/code&gt; comes from the &lt;code&gt;A.B&lt;/code&gt; namespace.</source>
          <target>型は&lt;em&gt;名前空間&lt;/em&gt;に存在できます。たとえば、&lt;code&gt;let x: A.B.C&lt;/code&gt;、型&lt;code&gt;C&lt;/code&gt;は&lt;code&gt;A.B&lt;/code&gt;名前空間に由来すると言います。</target>
        </trans-unit>
        <trans-unit id="4983c5239614810aa77447dfbec17bd7041d4202" translate="yes">
          <source>Types that have a common, singleton type property &amp;mdash; the &lt;em&gt;discriminant&lt;/em&gt;.</source>
          <target>共通のシングルトンタイププロパティを持つタイプ:&lt;em&gt;判別式&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ab7315f529976c1e9046634d7f86b088c404171a" translate="yes">
          <source>Types with a string index signature can be indexed using the &lt;code&gt;[]&lt;/code&gt; notation, but were not allowed to use the &lt;code&gt;.&lt;/code&gt;. Starting with TypeScript 2.2 using either should be allowed.</source>
          <target>文字列インデックスシグネチャを持つ型は、&lt;code&gt;[]&lt;/code&gt;表記を使用してインデックスを作成できますが、&lt;code&gt;.&lt;/code&gt;を使用することはできません。 TypeScript2.2以降では、どちらかを使用することが許されるべきです。</target>
        </trans-unit>
        <trans-unit id="eefc11c2a4fd735c4e7783f6bcfa193306bfe237" translate="yes">
          <source>Typescript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target>TypescriptはClosureからキャスト構文を借用している。 これにより、括弧で括られた式の前に&lt;code&gt;@type&lt;/code&gt;タグを追加することで、型を他の型にキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="4c9358fb040ac0e3e60567763fe2b8b87185ed9b" translate="yes">
          <source>Typescript is smart enough to infer the type of things in other contexts as well:</source>
          <target>Typescriptは賢いので、他のコンテキストにあるものの型も推測できる。</target>
        </trans-unit>
        <trans-unit id="aa237f14744bf9c080f4239d70330d26fd6782a1" translate="yes">
          <source>Typically, exporting from a module involves adding properties to a value like &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:</source>
          <target>通常、モジュールからエクスポートするには、&lt;code&gt;exports&lt;/code&gt;または&lt;code&gt;module.exports&lt;/code&gt;のような値にプロパティを追加する必要があります。TypeScriptでは、最上位レベルのエクスポート文を使用できます。 たとえば、次のような関数をエクスポートしたとします。</target>
        </trans-unit>
        <trans-unit id="c2df529fd52e531e7ccfbb71ef147f00c590c161" translate="yes">
          <source>Typing the function</source>
          <target>関数の入力</target>
        </trans-unit>
        <trans-unit id="1184391d4660ab61ecb650550cc662801a4ad10e" translate="yes">
          <source>UMD SimpleModule.js</source>
          <target>UMD SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="afb3e96e84eea2d4709a70ab3751ff0f583aa243" translate="yes">
          <source>UMD modules</source>
          <target>UMDモジュール</target>
        </trans-unit>
        <trans-unit id="bf3e09cfd260f3d9900f06488088b667722b7926" translate="yes">
          <source>Uglify</source>
          <target state="translated">Uglify</target>
        </trans-unit>
        <trans-unit id="0a5bbb787c318135c5901c5f8fb697634bd5bb32" translate="yes">
          <source>Uglify compacts your code so that it takes less time to download.</source>
          <target>Uglifyはコードを圧縮してダウンロードにかかる時間を短縮します。</target>
        </trans-unit>
        <trans-unit id="ae386e47ac367ccb8dc289004083400a638ccbc5" translate="yes">
          <source>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called &amp;ldquo;assertion signatures&amp;rdquo; which model these assertion functions.</source>
          <target>TypeScriptの最終的な目標は、既存のJavaScript構成体を最も混乱の少ない方法でタイプすることです。 そのため、TypeScript3.7では、これらのアサーション関数をモデル化する&amp;ldquo;assertion signatures&amp;rdquo;という新しい概念を導入しています。</target>
        </trans-unit>
        <trans-unit id="4339e741945b9652bb1d49489e6a98543eef7bb2" translate="yes">
          <source>Uncalled Function Checks</source>
          <target>呼び出されていない関数チェック</target>
        </trans-unit>
        <trans-unit id="180b1f03e6992ccd4fc623bfa5063f77a58ada25" translate="yes">
          <source>Unconditional calls to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target>&lt;code&gt;require&lt;/code&gt;または&lt;code&gt;define&lt;/code&gt;の無条件呼び出し</target>
        </trans-unit>
        <trans-unit id="b497122fd6b99841feeae2f0b3528acf90c34986" translate="yes">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; function type parameter positions are checked &lt;em&gt;contravariantly&lt;/em&gt; instead of &lt;em&gt;bivariantly&lt;/em&gt;. For some background on what variance means for function types check out &lt;a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance"&gt;What are covariance and contravariance?&lt;/a&gt;.</source>
          <target>&lt;code&gt;--strictFunctionTypes&lt;/code&gt;では、関数型パラメータの位置が&lt;em&gt;バヴァリアントリ&lt;/em&gt;ではなく&lt;em&gt;コントラヴァリアントリ&lt;/em&gt;にチェックされます。関数型の分散とは何を意味するかについては、&lt;a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance"&gt;What are covariance and convariance?&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2346be489fd11bd810e990b096f9680008f047bd" translate="yes">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; the first assignment is still permitted if &lt;code&gt;compare&lt;/code&gt; was declared as a method. Effectively, &lt;code&gt;T&lt;/code&gt; is bivariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in method parameter positions.</source>
          <target>&lt;code&gt;--strictFunctionTypes&lt;/code&gt;の下では、&lt;code&gt;compare&lt;/code&gt;がメソッドとして宣言された場合でも、最初の代入は許可されます。 &lt;code&gt;T&lt;/code&gt;は、&lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt;では、メソッドのパラメータ位置でのみ使用されるため、実質的に2変数です。</target>
        </trans-unit>
        <trans-unit id="33054f0cbee74c9f788ca4bd77541c3e143d3d3f" translate="yes">
          <source>Under the new &lt;code&gt;--esModuleInterop&lt;/code&gt; these two issues should be addressed:</source>
          <target>新しい&lt;code&gt;--esModuleInterop&lt;/code&gt;では、次の2つの問題に対処する必要があります。</target>
        </trans-unit>
        <trans-unit id="128561d89ec896d82327b08129ac6710b805e301" translate="yes">
          <source>Understanding &lt;code&gt;private&lt;/code&gt;</source>
          <target>&lt;code&gt;private&lt;/code&gt;について</target>
        </trans-unit>
        <trans-unit id="54219e3d20bedb021463636f2132089eb4de56ba" translate="yes">
          <source>Understanding &lt;code&gt;protected&lt;/code&gt;</source>
          <target>&lt;code&gt;protected&lt;/code&gt;について</target>
        </trans-unit>
        <trans-unit id="e23e9d7d02cff72c54df81048c1a4380b98b0319" translate="yes">
          <source>Understanding private</source>
          <target>プライベートとは</target>
        </trans-unit>
        <trans-unit id="95841ad8022df544f75a9cb58504b9e361799465" translate="yes">
          <source>Understanding protected</source>
          <target>保護されているとは</target>
        </trans-unit>
        <trans-unit id="ce277cc9234cfe2b86b777dd92906ff2f86a4ffc" translate="yes">
          <source>Understanding the sample</source>
          <target>サンプルについて</target>
        </trans-unit>
        <trans-unit id="b8046695cbb07b887254bfc5fba8b62777baab42" translate="yes">
          <source>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</source>
          <target>各宣言で作成される内容を理解すると、宣言マージを実行するときにマージされる内容を理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="b6d31265a9d2bb701584804cfe2084c1e863a4e3" translate="yes">
          <source>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</source>
          <target>残念ながらTypeScriptでは、これらのチェックを正しくエンコードできませんでした。 疎に型付けされたコードでは、TypeScriptのチェックが少なくなり、やや保守的なコードでは、ユーザーに型アサーションの使用を強要していました。</target>
        </trans-unit>
        <trans-unit id="f5ac25ede763c83433a3b880f5f3fc5c401f7ac2" translate="yes">
          <source>Unfortunately, &lt;code&gt;--declaration&lt;/code&gt; didn&amp;rsquo;t work with the &lt;code&gt;--allowJs&lt;/code&gt; flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn&amp;rsquo;t use the &lt;code&gt;--declaration&lt;/code&gt; flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!</source>
          <target>残念ながら、&lt;code&gt;--declaration&lt;/code&gt;は、TypeScriptとJavaScriptの入力ファイルを混在させることができる&lt;code&gt;--allowJs&lt;/code&gt;フラグでは動作しませんでした。 これは、たとえJSDocアノテーションが付けられていたとしても、コードベースを移行する際に&lt;code&gt;--declaration&lt;/code&gt;フラグを使用できないことを意味するため、苛立たしい制限でした。 TypeScript3.7はこれを変更し、2つのオプションを一緒に使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="90407376a294ed45dab6024b8ace72b1f1a4f495" translate="yes">
          <source>Unfortunately, mapped types like the &lt;code&gt;Readonly&lt;/code&gt; utility type were effectively no-ops on array and tuple types.</source>
          <target>残念ながら、&lt;code&gt;Readonly&lt;/code&gt;ユーティリティ型のようなマップされた型は、配列型とタプル型では実質的にno-opsでした。</target>
        </trans-unit>
        <trans-unit id="c9f9b24434ff80b111bededc5c17e2eb1610c1fc" translate="yes">
          <source>Unfortunately, the type of &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is still &lt;code&gt;any&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;this&lt;/code&gt; comes from the function expression inside the object literal. To fix this, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target>残念ながら、&lt;code&gt;this.shoes[pickedSuit]&lt;/code&gt;の型は、まだ&lt;code&gt;any&lt;/code&gt;です。これは、&lt;code&gt;this&lt;/code&gt;がオブジェクトリテラル内の関数式から来ているためです。 これを修正するには、&lt;code&gt;この&lt;/code&gt;パラメータを明示的に指定します。 &lt;code&gt;この&lt;/code&gt;パラメータは、関数のパラメータリストの先頭にあるフェイクパラメータです。</target>
        </trans-unit>
        <trans-unit id="e53ce54f63b88cf452ded6201871a14783c0be8e" translate="yes">
          <source>Unfortunately, this means that constructor functions that are also callable cannot use &lt;code&gt;@constructor&lt;/code&gt;.</source>
          <target>残念ながら、これは、同じく呼び出し可能なコンストラクター関数が&lt;code&gt;@constructor&lt;/code&gt;を使用できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="da9748783613337de4d74ee2abacadcb4e991578" translate="yes">
          <source>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:</source>
          <target>残念なことに、これは当初の提案の方向性のように思われましたが、公開クラスのフィールドが異なって標準化される可能性は非常に高いです。 その代わりに、元のコード・サンプルを次のようなものに分解する必要があります。</target>
        </trans-unit>
        <trans-unit id="b582e2c337ad84d8772f97cd78414fbed01f687b" translate="yes">
          <source>Unicode codepoint escapes in strings</source>
          <target>文字列内のユニコードコードポイントエスケープ</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes">
          <source>Union Types</source>
          <target>ユニオン型</target>
        </trans-unit>
        <trans-unit id="b7ed90cee7078e9ede776e2d455827cd6c390d7b" translate="yes">
          <source>Union enums and enum member types</source>
          <target>Union列挙型と列挙型メンバ型</target>
        </trans-unit>
        <trans-unit id="aba2f05474229fdcd9d1da33808bf8c11dd33d17" translate="yes">
          <source>Union type subtype reduction only removes a class type if it is a subclass of &lt;em&gt;and&lt;/em&gt; derives from another class type in the union.</source>
          <target>&lt;em&gt;のサブクラスであり、&lt;/em&gt;が共用体の別のクラス・タイプから派生している場合にのみ、共用体タイプ・サブタイプ縮小によってクラス・タイプが除去されます。</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes">
          <source>Union types</source>
          <target>ユニオン型</target>
        </trans-unit>
        <trans-unit id="56de4c1005168da2654053cbc54188220ab6bb4f" translate="yes">
          <source>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</source>
          <target>ユニオン型を使用すると、配列や、コレクションに複数の種類の値が含まれる可能性のあるその他の場所で、より適切な型推論が可能になります。</target>
        </trans-unit>
        <trans-unit id="3e7108953bcfc1c7c0311e2518816a93bc306b40" translate="yes">
          <source>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;string[]&lt;/code&gt; or a function that returns a &lt;code&gt;string&lt;/code&gt;. You can now write:</source>
          <target>ユニオン型は、複数の型のいずれかである値を表現する強力な方法です。 たとえば、コマンドラインを&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;string[]&lt;/code&gt;、または&lt;code&gt;string&lt;/code&gt;を返す関数として受け取るプログラムを実行するためのAPIがあるとします。この場合、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="70635a04ab9351bca09c5621dffee8f76929cc2c" translate="yes">
          <source>Union types are an advanced topic that we&amp;rsquo;ll cover in a later chapter.</source>
          <target>ユニオン型は、後の章で説明する高度なトピックです。</target>
        </trans-unit>
        <trans-unit id="3fa5955704db38dbb3e16e34ca92691e9ea2bbf5" translate="yes">
          <source>Union types are closely related to intersection types, but they are used very differently. Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target>ユニオンタイプは交差点タイプと密接に関連していますが、使用方法は大きく異なります。 パラメータが&lt;code&gt;number&lt;/code&gt;または&lt;code&gt;string&lt;/code&gt;であることを期待するライブラリに遭遇することがあります。たとえば、次の関数を使用します。</target>
        </trans-unit>
        <trans-unit id="cd921c2ea01c32f5a34e452b767384ff1f31852e" translate="yes">
          <source>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a &lt;code&gt;Fish&lt;/code&gt;? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</source>
          <target>ユニオン型は、値が重複する可能性がある場合にモデリングを行う場合に便利です。 &lt;code&gt;Fish&lt;/code&gt;があるかどうかを具体的に知る必要がある場合はどうなりますか。 2つの可能な値を区別するためのJavaScriptでの一般的なイディオムは、メンバーの存在をチェックすることです。 前述したように、アクセスできるのは、ユニオン・タイプのすべての構成要素に含まれることが保証されているメンバーのみです。</target>
        </trans-unit>
        <trans-unit id="d4d68a0298812ddd887befc8ebd536a465311e12" translate="yes">
          <source>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type &lt;code&gt;A | B&lt;/code&gt;, we only know for &lt;em&gt;certain&lt;/em&gt; that it has members that both &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;B&lt;/code&gt; have. In this example, &lt;code&gt;Bird&lt;/code&gt; has a member named &lt;code&gt;fly&lt;/code&gt;. We can&amp;rsquo;t be sure whether a variable typed as &lt;code&gt;Bird | Fish&lt;/code&gt; has a &lt;code&gt;fly&lt;/code&gt; method. If the variable is really a &lt;code&gt;Fish&lt;/code&gt; at runtime, then calling &lt;code&gt;pet.fly()&lt;/code&gt; will fail.</source>
          <target>ユニオン型はここでは少し扱いにくいかもしれませんが、慣れるには少し直感が必要です。 値のタイプが&lt;code&gt;A B&lt;/code&gt;である場合、&lt;code&gt;A&lt;/code&gt;&lt;em&gt;と&lt;/em&gt;&lt;code&gt;B&lt;/code&gt;の両方が持つメンバを&lt;em&gt;特定の&lt;/em&gt;だけが知っています。 この例では、&lt;code&gt;Bird&lt;/code&gt;に&lt;code&gt;fly&lt;/code&gt;という名前のメンバがあります。&lt;code&gt;Bird Fish&lt;/code&gt;として型指定された変数に&lt;code&gt;fly&lt;/code&gt;メソッドがあるかどうか確認できません。 変数が実行時に&lt;code&gt;Fish&lt;/code&gt;である場合、&lt;code&gt;pet.fly()&lt;/code&gt;の呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="ece8b3c6faf7510538396ff92255b9fc5deb4014" translate="yes">
          <source>Unless you take specific measures to avoid it, the internal state of a &lt;code&gt;const&lt;/code&gt; variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are &lt;code&gt;readonly&lt;/code&gt;. The &lt;a href="interfaces"&gt;chapter on Interfaces&lt;/a&gt; has the details.</source>
          <target>これを避けるために特別な手段を講じない限り、&lt;code&gt;const&lt;/code&gt;変数の内部状態は変更可能です。 幸い、TypeScriptを使用すると、オブジェクトのメンバが&lt;code&gt;readonly&lt;/code&gt;であることを指定できます。詳細については、「インターフェイス」の&lt;a href="interfaces"&gt;の章を参照してください。</target>
        </trans-unit>
        <trans-unit id="c861cf88ebb1a5b494f6992b73222db7fff28246" translate="yes">
          <source>Unless you&amp;rsquo;re really trying to take advantage of JavaScript&amp;rsquo;s runtime behavior in a clever way, it&amp;rsquo;s advised that you don&amp;rsquo;t do this.</source>
          <target>JavaScriptの実行時の動作をうまく利用しようとしているのでない限り、これをしないようにしてください。</target>
        </trans-unit>
        <trans-unit id="1a1461542d00d5010806839c20e64aa1678fdff5" translate="yes">
          <source>Unlike JSDoc&amp;rsquo;s type system, Typescript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;ndash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target>JSDoc&amp;rsquo;の型システムとは異なり、Typescriptでは型にNULLを含むかどうかをマークできるだけです。 非null許容値が明示的に指定されていない&amp;ndash;strictNullChecksがオンの場合、&lt;code&gt;number&lt;/code&gt;はnull不可になりません。 オフの場合、&lt;code&gt;number&lt;/code&gt;はヌル可能です。</target>
        </trans-unit>
        <trans-unit id="51985852906766cae660d6a12174c73de43d98b6" translate="yes">
          <source>Unlike plain optional parameters, default-initialized parameters don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass &lt;code&gt;undefined&lt;/code&gt; to get the default initialized value. For example, we could write our last example with only a default initializer on &lt;code&gt;firstName&lt;/code&gt;:</source>
          <target>単純なオプションパラメータとは異なり、デフォルトで初期化されるパラメータは、必須パラメータの後に&lt;/em&gt;指定する必要がありません。 デフォルトで初期化されたパラメータが必要なパラメータの前に来る場合、ユーザは明示的に&lt;code&gt;undefined&lt;/code&gt;を渡して、デフォルトで初期化された値を取得する必要があります。 たとえば、&lt;code&gt;firstName&lt;/code&gt;にデフォルトの初期化子のみを使用して、最後の例を作成することができます。</target>
        </trans-unit>
        <trans-unit id="4b497f9d0d5c2c4f2547035f0fcd80ba5746c84a" translate="yes">
          <source>Unreachable code</source>
          <target>到達不能コード</target>
        </trans-unit>
        <trans-unit id="1d0500c74b8aa49d1d2f3d7c0b7c86b3a9d2a921" translate="yes">
          <source>Unspecified type parameters default to &lt;code&gt;any&lt;/code&gt;</source>
          <target>タイプパラメータが指定されていない場合は、デフォルトで&lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1948c97816d203ebc2f90700d76faedc4fbbccfe" translate="yes">
          <source>Untyped imports</source>
          <target>型指定されていないインポート</target>
        </trans-unit>
        <trans-unit id="42a377f570d337b6d69100d6ff55ff5b9e97a424" translate="yes">
          <source>Unused labels</source>
          <target>未使用のラベル</target>
        </trans-unit>
        <trans-unit id="950c29b1f717e4fff1d2a159fa44b64e58240c0f" translate="yes">
          <source>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; to stop reporting these errors.</source>
          <target>使用されていないラベルにもフラグが付けられます。 到達不能コードチェックと同様に、これらはデフォルトでオンになっています。&lt;code&gt;--allowUnusedLabels&lt;/code&gt;を使用して、これらのエラーの報告を停止します。</target>
        </trans-unit>
        <trans-unit id="3ea5ca14dc52b9bd423f61c07136cde4865d6a52" translate="yes">
          <source>Up to this point, we&amp;rsquo;ve only talked about the &lt;em&gt;instance&lt;/em&gt; members of the class, those that show up on the object when it&amp;rsquo;s instantiated. We can also create &lt;em&gt;static&lt;/em&gt; members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &lt;code&gt;static&lt;/code&gt; on the origin, as it&amp;rsquo;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &lt;code&gt;this.&lt;/code&gt; in front of instance accesses, here we prepend &lt;code&gt;Grid.&lt;/code&gt; in front of static accesses.</source>
          <target>ここまでは、クラスの&lt;em&gt;インスタンス&lt;/em&gt;メンバー、つまりインスタンス化されたときにオブジェクトに表示される&lt;em&gt;インスタンス&lt;/em&gt;メンバーについてのみ説明しました。 クラスの&lt;em&gt;静的&lt;/em&gt;メンバを作成することもできます。静的&lt;/em&gt;メンバは、インスタンスではなくクラス自体に表示されます。 この例では、すべてのグリッドの一般的な値であるため、原点に&lt;code&gt;static&lt;/code&gt;を使用します。 各インスタンスは、クラス名の前に付けることによってこの値にアクセスします。 インスタンスアクセスの前に&lt;code&gt;this.&lt;/code&gt;をプリペンディングするのと同様に、ここでは静的アクセスの前に&lt;code&gt;Grid.&lt;/code&gt;をプリペンディングします。</target>
        </trans-unit>
        <trans-unit id="ad67feee99a0f439a0e27027c5ea3dcbcf7ff3d4" translate="yes">
          <source>Update &lt;code&gt;.vscode/settings.json&lt;/code&gt; with the following:</source>
          <target>&lt;code&gt;.vscode/settings.json&lt;/code&gt;を以下で更新する。</target>
        </trans-unit>
        <trans-unit id="0c453d2caa8ecb4d47c7c21d916dd5de2c9571a9" translate="yes">
          <source>Update project file to include locally installed &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (at the top) and &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (at the bottom) files:</source>
          <target>ローカルにインストールされた&lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;(上部)および&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;(下部)ファイルを含むようにプロジェクトファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="61ef22d6991101f4978ea02b3e277ed08f8a02ed" translate="yes">
          <source>Update the &lt;code&gt;Settings - User&lt;/code&gt; file with the following:</source>
          <target>&lt;code&gt;Settings-User&lt;/code&gt;ファイルを次のように更新します。</target>
        </trans-unit>
        <trans-unit id="8b2b612f6daeee72c04fac6bf2b62e95619d91d9" translate="yes">
          <source>Updating your IDE to use the nightly builds</source>
          <target>夜間ビルドを使用するためのIDEの更新</target>
        </trans-unit>
        <trans-unit id="4dc2e4b6eb759a2e235283631204f80eaa19dc57" translate="yes">
          <source>Use &lt;a href="templates/module-class-d-ts"&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target>&lt;code&gt;new&lt;/code&gt;を使用してモジュールを&lt;em&gt;構築できる場合は、&lt;a href="templates/module class d ts"&gt;&lt;code&gt;module class.d.ts&lt;/code&gt;&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="dcb83b510816e0232e4eea4a6e8821858e1d88cf" translate="yes">
          <source>Use &lt;a href="templates/module-function-d-ts"&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target>モジュールを関数のように&lt;em&gt;呼び出すことができる場合は、&lt;a href="templates/module function d ts"&gt;&lt;code&gt;module function.d.ts&lt;/code&gt;&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="9135ad666eb865ef0f03b22c777b4833dda580f4" translate="yes">
          <source>Use &lt;code&gt;--pretty false&lt;/code&gt; on the command line or set &lt;code&gt;"pretty": false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; to disable &lt;code&gt;--pretty&lt;/code&gt; output.</source>
          <target>&lt;code&gt;--pretty&lt;/code&gt;出力を無効にするには、コマンドラインで&lt;code&gt;--pretty&lt;/code&gt;を使用するか、&lt;code&gt;tsconfig.json&lt;/code&gt;で&lt;code&gt;"pretty":false&lt;/code&gt;を設定します。</target>
        </trans-unit>
        <trans-unit id="d777cba827da4d9bd0a80b90d7cc7d35bc7eb763" translate="yes">
          <source>Use &lt;code&gt;declare class&lt;/code&gt; to describe a class or class-like object. Classes can have properties and methods as well as a constructor.</source>
          <target>&lt;code&gt;declare class&lt;/code&gt;を使用して、クラスまたはクラスに類似したオブジェクトを記述します。 クラスには、コンストラクタだけでなくプロパティとメソッドも含めることができます。</target>
        </trans-unit>
        <trans-unit id="1d25646e3d1c96527dec663a49cd97e0a677f024" translate="yes">
          <source>Use &lt;code&gt;declare function&lt;/code&gt; to declare functions.</source>
          <target>関数を宣言するには、&lt;code&gt;declare function&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="dc5e87631ffbf23b795c1170d5135c6525f91882" translate="yes">
          <source>Use &lt;code&gt;declare namespace&lt;/code&gt; to describe types or values accessed by dotted notation.</source>
          <target>ドット表記でアクセスする型または値を記述するには、&lt;code&gt;declare namespace&lt;/code&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="646cf6b60f19ec39b9a348c993659c06af5ff17e" translate="yes">
          <source>Use &lt;code&gt;declare var&lt;/code&gt; to declare variables. If the variable is read-only, you can use &lt;code&gt;declare const&lt;/code&gt;. You can also use &lt;code&gt;declare let&lt;/code&gt; if the variable is block-scoped.</source>
          <target>&lt;code&gt;declare var&lt;/code&gt;を使用して変数を宣言します。 変数が読み取り専用の場合は、&lt;code&gt;declare const&lt;/code&gt;を使用できます。また、変数のスコープがブロックの場合は、&lt;code&gt;declare let&lt;/code&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="fc7b733452effbd68c17f48699824b764aa4d5c8" translate="yes">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; to watch directories and child directories</source>
          <target>&lt;code&gt;fs.watch&lt;/code&gt;を使用して、ディレクトリと子ディレクトリを監視する</target>
        </trans-unit>
        <trans-unit id="a20558d88b96350c2a6617d2a8806bb939c26e75" translate="yes">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; which uses file system events (but might not be accurate on different OS) to get the notifications for the file changes/creation/deletion. Note that few OS eg. linux has limit on number of watches and failing to create watcher using &lt;code&gt;fs.watch&lt;/code&gt; will result it in creating using &lt;code&gt;fs.watchFile&lt;/code&gt;</source>
          <target>ファイル・システム・イベントを使用する&lt;code&gt;fs.watch&lt;/code&gt;を使用して(ただし、異なるOSでは正確でない場合があります)、ファイルの変更/作成/削除に関する通知を取得します。 注意して欲しいのは、Linuxのようにウォッチの数に制限があるOSはほとんどないということです。&lt;code&gt;fs.watch&lt;/code&gt;を使ってwatcherを作成しないと、&lt;code&gt;fs.watchFile&lt;/code&gt;を使って作成することになります。</target>
        </trans-unit>
        <trans-unit id="b8a0ecc46b3020c85d683ef9e7bfc225a06e140d" translate="yes">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; but use different polling intervals for source files, config files and missing files</source>
          <target>&lt;code&gt;fs.watchFile&lt;/code&gt;を使用しますが、ソースファイル、構成ファイル、および見つからないファイルに対して異なるポーリング間隔を使用します。</target>
        </trans-unit>
        <trans-unit id="d9b3f25a00b42d34692eae633c97a930b3ef45c2" translate="yes">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; to watch the directories and child directories which is a polling watch (consuming CPU cycles)</source>
          <target>&lt;code&gt;fs.watchFile&lt;/code&gt;を使用して、ポーリングウォッチであるディレクトリと子ディレクトリを監視します(CPUサイクルを消費します)。</target>
        </trans-unit>
        <trans-unit id="b82d02e810b66cfc5287f1002d1703389ec9f322" translate="yes">
          <source>Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, "name"&amp;gt;;&lt;/code&gt; as an explicit type annotation instead, or do not add a type annotation as done in the example above.</source>
          <target>代わりに&lt;code&gt;static defaultProps:&amp;lt;Props,"name"&amp;gt;;&lt;/code&gt;を明示的なタイプ注釈として使用するか、上記の例のようにタイプ注釈を追加しないでください。</target>
        </trans-unit>
        <trans-unit id="c797e1ab4188af4e8f2f348f9d4813348e879b0b" translate="yes">
          <source>Use JSDoc &lt;code&gt;@augments&lt;/code&gt; to specify the types explicitly. for instance:</source>
          <target>型を明示的に指定するには、JSDoc&lt;code&gt;@augments&lt;/code&gt;を使用します。 例:</target>
        </trans-unit>
        <trans-unit id="26914e7e48730258a108abb453430cd3518851d2" translate="yes">
          <source>Use Optional Parameters</source>
          <target>オプションパラメータを使用</target>
        </trans-unit>
        <trans-unit id="1f551ab7cd042c6186f08b5016c6fbb015348adf" translate="yes">
          <source>Use Union Types</source>
          <target>ユニオン型を使用</target>
        </trans-unit>
        <trans-unit id="c6e9ca22aa2af3128ca0dfccc6ca984b9a53e2f4" translate="yes">
          <source>Use a dynamic queue where in the frequently modified files will be polled at shorter interval and the files unchanged will be polled less frequently</source>
          <target>頻繁に変更されるファイルは短い間隔でポーリングされ、変更されていないファイルは短い間隔でポーリングされる動的キューを使用する</target>
        </trans-unit>
        <trans-unit id="b6bcaab1110f17c72658c24deb9f410172d12ea7" translate="yes">
          <source>Use a type assertion (i.e. &lt;code&gt;opts as Options&lt;/code&gt;).</source>
          <target>型アサーションを使用します(&lt;code&gt;opts as Options&lt;/code&gt;など)。</target>
        </trans-unit>
        <trans-unit id="c373f04992cf46cf315a11d0cfd773d124512011" translate="yes">
          <source>Use an &lt;code&gt;interface&lt;/code&gt; to define a type with properties.</source>
          <target>&lt;code&gt;インタフェース&lt;/code&gt;を使用して、プロパティを持つタイプを定義します。</target>
        </trans-unit>
        <trans-unit id="de6bf5682731fffe8d17a1a2893ad0e0e875fbd9" translate="yes">
          <source>Use comma or multiple tags to declare multiple type parameters:</source>
          <target>カンマまたは複数のタグを使用して、複数の型パラメータを宣言します。</target>
        </trans-unit>
        <trans-unit id="813eb2c164fdf97484adee07af475b49c979cbf5" translate="yes">
          <source>Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets &lt;em&gt;really&lt;/em&gt; hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.</source>
          <target>分解は慎重に行ってください。 前の例で説明したように、最も単純な構造化解除式以外は混乱します。 これは、深くネストされた非構造化の場合に特に当てはまります。これは、名前の変更、デフォルト値、型アノテーションを積み上げなくても&lt;em&gt;本当に&lt;/em&gt;理解しにくくなります。 式の構造化を小さく単純にしてください。 構造を解除すると自分で生成される割り当てをいつでも作成できます。</target>
        </trans-unit>
        <trans-unit id="84ca1d512ea34e66413a09bf03aea43da1cd5e61" translate="yes">
          <source>Use dynamic polling queue to poll changes to the directory and child directories.</source>
          <target>ダイナミックポーリングキューを使用して、ディレクトリおよび子ディレクトリに対する変更をポーリングします。</target>
        </trans-unit>
        <trans-unit id="476bd570b1cb323c844b457111807cf0bfe14c03" translate="yes">
          <source>Use namespaces to organize types.</source>
          <target>名前空間を使用して型を編成します。</target>
        </trans-unit>
        <trans-unit id="a7fb2226e7d1637c125b100d2ae8ebe1ff2bbb66" translate="yes">
          <source>Use returned values from super calls as &amp;lsquo;this&amp;rsquo;</source>
          <target>スーパーコールから返された値を&amp;lsquo;this&amp;rsquo;として使用する</target>
        </trans-unit>
        <trans-unit id="cec0cfa03e45ca3f1d25fc09af8034cc6ba3a098" translate="yes">
          <source>Use the &lt;a href="templates/global-modifying-module-d-ts"&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target>&lt;a href="templates/global modifying module d ts"&gt;&lt;code&gt;global modifying module.d.ts&lt;/code&gt;&lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="467a1132d18100a2fea14dea179fb807cc8c9786" translate="yes">
          <source>Use the &lt;a href="templates/global-plugin-d-ts"&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target>&lt;a href="templates/global plugin d ts"&gt;&lt;code&gt;global plugin.d.ts&lt;/code&gt;&lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="ded88ccc850f489f2c1db682f66acc6ce6e89c02" translate="yes">
          <source>Use the &lt;a href="templates/module-plugin-d-ts"&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target>&lt;a href="templates/module plugin d ts"&gt;&lt;code&gt;module plugin.d.ts&lt;/code&gt;&lt;/a&gt;テンプレートを使用します。</target>
        </trans-unit>
        <trans-unit id="d00f93f8ed19c310af833f02b233f61189f29867" translate="yes">
          <source>Use the namespace import pattern if you&amp;rsquo;re importing a large number of things</source>
          <target>多数のものをインポートする場合は、名前空間インポートパターンを使用する</target>
        </trans-unit>
        <trans-unit id="181dfdffa543aacf139786370fa1942354e5e0e8" translate="yes">
          <source>Use the specified end of line sequence to be used when emitting files: &lt;code&gt;"crlf"&lt;/code&gt; (windows) or &lt;code&gt;"lf"&lt;/code&gt; (unix).&amp;rdquo;</source>
          <target>&lt;code&gt;"crlf"&lt;/code&gt;(windows)または&lt;code&gt;"lf"&lt;/code&gt;(unix).&amp;rdquo;のように、ファイルを出力するときに使用する行の末尾のシーケンスを指定します。</target>
        </trans-unit>
        <trans-unit id="6c5dbc74cf020a727ea7578eaadc331456e2cdd0" translate="yes">
          <source>Use these directives only when you&amp;rsquo;re authoring a &lt;code&gt;d.ts&lt;/code&gt; file by hand.</source>
          <target>これらのディレクティブは、&lt;code&gt;d.ts&lt;/code&gt;ファイルを手動でオーサリングする場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="3c9eac17e15f70b4957575dc44afd54e3e8ed5d8" translate="yes">
          <source>Use your best judgement, and if applicable, consult the matter with the rest of your team.</source>
          <target>最善の判断を下し、該当する場合は、チームの他のメンバーと相談してください。</target>
        </trans-unit>
        <trans-unit id="49e789822c27891d496e2d1c824f3137fc0a60e8" translate="yes">
          <source>User Combinations</source>
          <target>ユーザーの組み合わせ</target>
        </trans-unit>
        <trans-unit id="6db409b39dc46fb85822ac1924c1fb876244cc1a" translate="yes">
          <source>User-Defined Type Guards</source>
          <target>ユーザ定義タイプガード</target>
        </trans-unit>
        <trans-unit id="d8895e69c18f832a3dc18dc0b25ac0287a552c83" translate="yes">
          <source>User-defined type guard functions</source>
          <target>ユーザ定義型ガード関数</target>
        </trans-unit>
        <trans-unit id="865aa2eab27a2eebc9f8c1b7ee2b45dba99a5722" translate="yes">
          <source>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the &lt;code&gt;declare module "foo" { }&lt;/code&gt; syntax), and are directly nested either your own modules, or in another top level ambient external module.</source>
          <target>ユーザは、作成したい任意の拡張を宣言することができます。また、他のユーザが既に作成した拡張を既存のモジュールに宣言することもできます。 モジュールの拡張は、単純な古いアンビエントモジュール宣言(すなわち、&lt;code&gt;declare module"foo"{}&lt;/code&gt;構文)のように見え、あなた自身のモジュールか、あるいは別のトップレベルのアンビエント外部モジュールのどちらかに直接ネストされます。</target>
        </trans-unit>
        <trans-unit id="b92638c4a093946ffe782b9c6ea843146edd2d04" translate="yes">
          <source>Users can now ensure that the type system will catch such errors. Here&amp;rsquo;s our new &lt;code&gt;AnimationOptions&lt;/code&gt; using string literal types:</source>
          <target>ユーザーは、型システムがこのようなエラーを確実にキャッチできるようになりました。 文字列リテラル型を使用する新しい&lt;code&gt;AnimationOptions&lt;/code&gt;を次に示します。</target>
        </trans-unit>
        <trans-unit id="971fc6da1fad26d48864984a1a77ed97685d4f3a" translate="yes">
          <source>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</source>
          <target>新しいバージョンのTSを使用している場合は、最初のロード時にプロジェクトをアップグレードするように求めるプロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="076baa79ca77082f0ca2b3320f7136b88d1a143c" translate="yes">
          <source>Using &amp;lsquo;rootDirs&amp;rsquo;, you can inform the compiler of the &lt;em&gt;roots&lt;/em&gt; making up this &amp;ldquo;virtual&amp;rdquo; directory; and thus the compiler can resolve relative modules imports within these &amp;ldquo;virtual&amp;rdquo; directories &lt;em&gt;as if&lt;/em&gt; were merged together in one directory.</source>
          <target>&amp;lsquo;rootDirs&amp;rsquo;を使用すると、この&amp;ldquo;virtual&amp;rdquo;ディレクトリを構成する&lt;em&gt;ルート&lt;/em&gt;をコンパイラに通知できます。したがって、コンパイラは、これらの&amp;ldquo;virtual&amp;rdquo;ディレクトリ&lt;em&gt;内の相対モジュールインポートを、1つのディレクトリにマージされたように解決できます。</target>
        </trans-unit>
        <trans-unit id="9c907fc236b5576ec4b9496e0b00bbfb71e593bd" translate="yes">
          <source>Using --noResolve</source>
          <target>使用--noResolve</target>
        </trans-unit>
        <trans-unit id="fea016f48554330486c9c94e60974382dcd30124" translate="yes">
          <source>Using &lt;code&gt;"paths"&lt;/code&gt; also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</source>
          <target>&lt;code&gt;"paths"&lt;/code&gt;を使用すると、複数のフォールバックロケーションを含むより高度なマッピングも可能になります。 ある場所では一部のモジュールのみが使用可能で、残りは別の場所にあるプロジェクト構成を考えてみます。</target>
        </trans-unit>
        <trans-unit id="42ba4227d3af5762437561f59f30ce6a1e5f2260" translate="yes">
          <source>Using &lt;code&gt;"paths"&lt;/code&gt; also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</source>
          <target>&lt;code&gt;"paths"&lt;/code&gt;を使用すると、複数のフォールバックロケーションを含むより高度なマッピングも可能になります。 ある場所では一部のモジュールのみが使用可能で、残りは別の場所にあるプロジェクト構成を考えてみます。 ビルド・ステップを実行すると、すべてが1つの場所にまとめられます。 プロジェクトのレイアウトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="06cd012e6c788da38d72b27da1a7bbf3bef7051d" translate="yes">
          <source>Using &lt;code&gt;--noResolve&lt;/code&gt;</source>
          <target>&lt;code&gt;--noResolve&lt;/code&gt;を使用する</target>
        </trans-unit>
        <trans-unit id="8afa8edba85ebf100416b76304f95c6450f3141c" translate="yes">
          <source>Using &lt;code&gt;/// &amp;lt;reference lib="es2017.string" /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target>コンパイル内のファイルの1つに&lt;code&gt;///&amp;lt;reference lib="es2017.string"/&amp;gt;&lt;/code&gt;を使用することは、&lt;code&gt;--lib es2017.string&lt;/code&gt;でコンパイルすることと同じです。</target>
        </trans-unit>
        <trans-unit id="7e4933f2a2e7814cc135c9b1388e792cdd66475c" translate="yes">
          <source>Using &lt;code&gt;from&lt;/code&gt; clause a module can copy the exports of a given module to the current module without introducing local names.</source>
          <target>&lt;code&gt;from&lt;/code&gt;句を使用すると、モジュールはローカル名を使用せずに、特定のモジュールのエクスポートを現在のモジュールにコピーできます。</target>
        </trans-unit>
        <trans-unit id="37a797ad92e300fcb869331595d2c4e343d74dfd" translate="yes">
          <source>Using &lt;code&gt;import("mod")&lt;/code&gt; in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</source>
          <target>型アノテーションで&lt;code&gt;import("mod")&lt;/code&gt;を使用すると、モジュールにアクセスし、インポートせずにエクスポートされた宣言にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="72074f269aec1329aae7105fabf958e05d5c07ed" translate="yes">
          <source>Using &lt;code&gt;instanceof&lt;/code&gt; with classes and union types:</source>
          <target>&lt;code&gt;instanceof&lt;/code&gt;をクラスとユニオン型で使用する</target>
        </trans-unit>
        <trans-unit id="3148c33827558727523c9ea9ec8a97850719dfe8" translate="yes">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; to test a variable:</source>
          <target>&lt;code&gt;typeof&lt;/code&gt;を使用して変数をテストする</target>
        </trans-unit>
        <trans-unit id="3512c5d8c5a6f92bc7eb3bc3316fb1091e9fc207" translate="yes">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; with union types and &lt;code&gt;else&lt;/code&gt;:</source>
          <target>&lt;code&gt;typeof&lt;/code&gt;をユニオン型と&lt;code&gt;else&lt;/code&gt;で使用する場合:</target>
        </trans-unit>
        <trans-unit id="4d577340ac4bb94fb9a7eb6e17e1355af2faee1e" translate="yes">
          <source>Using API</source>
          <target>APIの使用</target>
        </trans-unit>
        <trans-unit id="aea338f92c90962e364abdd73770a9a8e0a22f76" translate="yes">
          <source>Using Class Types in Generics</source>
          <target>ジェネリックでのクラスタイプの使用</target>
        </trans-unit>
        <trans-unit id="43300137282de05306e305d02f5a4e3a4a8e2d0d" translate="yes">
          <source>Using Command Line Interface</source>
          <target>コマンドラインインタフェースを使用する</target>
        </trans-unit>
        <trans-unit id="8b74d8a06cce7b65888ba4e8c7818fe0688bd9a8" translate="yes">
          <source>Using Modules</source>
          <target>モジュールの使用</target>
        </trans-unit>
        <trans-unit id="c5dfdd934dc02ab2c210cf3f3003872dcd3d25e6" translate="yes">
          <source>Using Namespaces</source>
          <target>ネームスペースの使用</target>
        </trans-unit>
        <trans-unit id="2340df0448163b853367fed9720dff6a29c60ae1" translate="yes">
          <source>Using NuGet with MSBuild</source>
          <target>MSBuildでNuGetを使う</target>
        </trans-unit>
        <trans-unit id="547f3d366f6ba6dbebb442ff52e5209ac22bfe3d" translate="yes">
          <source>Using React</source>
          <target>Reactの使用</target>
        </trans-unit>
        <trans-unit id="d7491bb32b4d14f757fef9c824559f69f7177e06" translate="yes">
          <source>Using Type Guards, you can easily work with a variable of a union type:</source>
          <target>タイプガードを使用すると、ユニオン型の変数を簡単に操作できます。</target>
        </trans-unit>
        <trans-unit id="eccd06efc2831f9179398ffcb9ce80cec01c9e63" translate="yes">
          <source>Using Type Parameters in Generic Constraints</source>
          <target>ジェネリック拘束でのタイプパラメータの使用</target>
        </trans-unit>
        <trans-unit id="ba60f8a349037067c0634dc31a0ac923864cdd8c" translate="yes">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target>&lt;code&gt;baseUrl&lt;/code&gt;を使用することは、AMDモジュールローダーを使用するアプリケーションでは一般的な方法です。モジュールは、実行時に1つのフォルダに&amp;ldquo;配置&amp;rdquo;されます。 相対的でない名前を持つすべてのモジュールインポートは、&lt;code&gt;baseUrl&lt;/code&gt;に相対的であると見なされます。</target>
        </trans-unit>
        <trans-unit id="eb2a81ce273392d8c282cd088fcd0585336e4cfd" translate="yes">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</source>
          <target>&lt;code&gt;baseUrl&lt;/code&gt;を使用することは、AMDモジュールローダーを使用するアプリケーションでは一般的な方法です。モジュールは、実行時に1つのフォルダに&amp;ldquo;配置&amp;rdquo;されます。 これらのモジュールのソースは異なるディレクトリに置くことができますが、ビルド・スクリプトがそれらをまとめます。</target>
        </trans-unit>
        <trans-unit id="b5e01fea434d511ae7f89196d33d7e8c07fa0679" translate="yes">
          <source>Using a class as an interface</source>
          <target>クラスをインタフェースとして使用する</target>
        </trans-unit>
        <trans-unit id="b21dff09db83d498fc08fa858a2c6f95c4bc7857" translate="yes">
          <source>Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:</source>
          <target>列挙を使用するのは簡単です。列挙自体のプロパティとして任意のメンバにアクセスし、列挙の名前を使用して型を宣言します。</target>
        </trans-unit>
        <trans-unit id="e8cff08e29703580b7ac86809f0f79615642a204" translate="yes">
          <source>Using npm</source>
          <target>npmの使用</target>
        </trans-unit>
        <trans-unit id="f97748b0bee558e2605da416afdbef74fd01695b" translate="yes">
          <source>Using other JSX frameworks</source>
          <target>他のJSXフレームワークの使用</target>
        </trans-unit>
        <trans-unit id="5c78cf487464fa0e7c06524cc2aed76314129a78" translate="yes">
          <source>Using target &lt;code&gt;--target ES2016&lt;/code&gt; will instruct the compiler not to transform ES2016-specific features, e.g. &lt;code&gt;**&lt;/code&gt; operator.</source>
          <target>target&lt;code&gt;--target ES2016&lt;/code&gt;を使用すると、コンパイラは&lt;code&gt;**&lt;/code&gt;演算子などのES2016固有の機能を変換しないように指示されます。</target>
        </trans-unit>
        <trans-unit id="c2bbd5627cb0ada9bd95ef8d96473ec05f861c62" translate="yes">
          <source>Using the &lt;code&gt;"files"&lt;/code&gt; property</source>
          <target>&lt;code&gt;"files"&lt;/code&gt;プロパティの使用</target>
        </trans-unit>
        <trans-unit id="dd019ddcfa9a356cc6a71911adc51d98cc08a82d" translate="yes">
          <source>Using the &lt;code&gt;"include"&lt;/code&gt; and &lt;code&gt;"exclude"&lt;/code&gt; properties</source>
          <target>&lt;code&gt;"include"&lt;/code&gt;および&lt;code&gt;"exclude"&lt;/code&gt;プロパティの使用</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target>&lt;code&gt;in&lt;/code&gt;演算子の使用</target>
        </trans-unit>
        <trans-unit id="05695053496c73d09b9080abbb8ddbcec5718d22" translate="yes">
          <source>Using this ability, &lt;code&gt;lib.d.ts&lt;/code&gt; now has a new &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; type. This type strips &lt;code&gt;?&lt;/code&gt; modifiers from all properties of &lt;code&gt;T&lt;/code&gt;, thus making all properties required.</source>
          <target>この機能を使用すると、&lt;code&gt;lib.d.ts&lt;/code&gt;に新しい&lt;code&gt;必須&amp;lt;T&amp;gt;&lt;/code&gt;タイプが追加されます。 この型は、&lt;code&gt;T&lt;/code&gt;のすべてのプロパティから&lt;code&gt;?&lt;/code&gt;修飾子を取り除くため、すべてのプロパティが必要になります。</target>
        </trans-unit>
        <trans-unit id="6f3cf80ca63760070e6103046db8653a28ce64e1" translate="yes">
          <source>Using tsconfig.json</source>
          <target>tsconfig.jsonの使用</target>
        </trans-unit>
        <trans-unit id="e3ff1e8a9c36f6f4750c05884c5f542d5a46249b" translate="yes">
          <source>Using type predicates</source>
          <target>タイプ述部の使用</target>
        </trans-unit>
        <trans-unit id="3601427971630988ad2755ef28a7717d757f3df8" translate="yes">
          <source>Using with &lt;code&gt;export =&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;</source>
          <target>&lt;code&gt;export=&lt;/code&gt;または&lt;code&gt;import&lt;/code&gt;で使用する</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes">
          <source>Utility Types</source>
          <target>ユーティリティタイプ</target>
        </trans-unit>
        <trans-unit id="afdf32ce970b80477ef67d464ba5d9d15cfb327c" translate="yes">
          <source>Validation.ts</source>
          <target state="translated">Validation.ts</target>
        </trans-unit>
        <trans-unit id="524163f0faa0530bac2b1baaeb887189c9c73216" translate="yes">
          <source>Validators in a single file</source>
          <target>単一ファイル内のバリデータ</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes">
          <source>Value</source>
          <target>値</target>
        </trans-unit>
        <trans-unit id="5a0535139a31a774a3c9068d34adc7058d5bf642" translate="yes">
          <source>Value of &lt;em&gt;baseUrl&lt;/em&gt; is determined as either:</source>
          <target>&lt;em&gt;baseUrl&lt;/em&gt;の値は次のいずれかで決定されます。</target>
        </trans-unit>
        <trans-unit id="577084450a5e984b5f6966940c5dcc148307a726" translate="yes">
          <source>Value-based elements</source>
          <target>値ベースの要素</target>
        </trans-unit>
        <trans-unit id="3f2f78c89fa82d18f5843ae8eee30d072a82336b" translate="yes">
          <source>Value-based elements are simply looked up by identifiers that are in scope.</source>
          <target>値ベースの要素は、スコープ内の識別子によって単純に検索されます。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes">
          <source>Values</source>
          <target>値</target>
        </trans-unit>
        <trans-unit id="d79ccf393d6a199b4ad9ea5944ca607bfd113cf4" translate="yes">
          <source>Var-args parameter declaration inferred from use of &lt;code&gt;arguments&lt;/code&gt;</source>
          <target>&lt;code&gt;引数&lt;/code&gt;の使用から推測されるVarargsパラメータ宣言</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes">
          <source>Variable</source>
          <target>可変</target>
        </trans-unit>
        <trans-unit id="532e17316f9909fba79f94428471eb6888d1b255" translate="yes">
          <source>Variable Declarations</source>
          <target>変数宣言</target>
        </trans-unit>
        <trans-unit id="b3912d587e9569bb7bfd495613a05ef2130c8e37" translate="yes">
          <source>Variable capturing quirks</source>
          <target>変数を取り込む癖</target>
        </trans-unit>
        <trans-unit id="7c09718bb5da0232e2044986eb3a280f493f26a9" translate="yes">
          <source>Variables declared in a &lt;code&gt;catch&lt;/code&gt; clause also have similar scoping rules.</source>
          <target>&lt;code&gt;catch&lt;/code&gt;句で宣言された変数にも、同様のスコープルールがあります。</target>
        </trans-unit>
        <trans-unit id="b11bd74b68068c8cda414d69c145cdd12377e1bb" translate="yes">
          <source>Version selection with &lt;code&gt;typesVersions&lt;/code&gt;</source>
          <target>&lt;code&gt;typesVersions&lt;/code&gt;のバージョン選択</target>
        </trans-unit>
        <trans-unit id="4133624045854a306b02e62768cbf604af93f40f" translate="yes">
          <source>Via npm (the Node.js package manager)</source>
          <target>npm(Node.jsパッケージマネージャ)経由</target>
        </trans-unit>
        <trans-unit id="bbef03a29ac970d4beb2f168015277f559e746e0" translate="yes">
          <source>Virtual Directories with &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target>&lt;code&gt;rootDirs&lt;/code&gt;を持つ仮想ディレクトリ</target>
        </trans-unit>
        <trans-unit id="fd7f9c3ff1ebf06a17bf0502aaa043bb8f017fe6" translate="yes">
          <source>Visual Studio 2013 and 2015</source>
          <target>Visual Studio2013および2015</target>
        </trans-unit>
        <trans-unit id="023fa801554be0ffd9cb5b6327c0e269a7154d1a" translate="yes">
          <source>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href="https://www.typescriptlang.org/#download-links"&gt;download it&lt;/a&gt;.</source>
          <target>Visual Studio2015とVisual Studio2013Update2にはデフォルトでTypeScriptが含まれている。 Visual StudioでTypeScriptをインストールしていない場合でも、&lt;a href="https://www.typescriptlang.org/#download-links"&gt;ダウンロード&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="353b01045c518e21b3e08d0cee10940ef65c683f" translate="yes">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href="https://www.typescriptlang.org/#download-links"&gt;download it&lt;/a&gt;.</source>
          <target>Visual Studio2017とVisual Studio2015Update3にはデフォルトでTypeScriptが含まれている。 Visual StudioでTypeScriptをインストールしていない場合でも、&lt;a href="https://www.typescriptlang.org/#download-links"&gt;ダウンロード&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes">
          <source>Visual Studio Code</source>
          <target>Visual Studio Code</target>
        </trans-unit>
        <trans-unit id="a54600c66809939b059f9682e260da90c5cc8595" translate="yes">
          <source>Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.</source>
          <target>ファイルを保存するとすぐに、Visual Studioはglpとdelのインストールを開始します。 そうでない場合は、package.jsonを右クリックし、Restore Packagesを選択します。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="369e965336691b4254b406f11997b3fb8754eafe" translate="yes">
          <source>Watchify</source>
          <target>Watchify</target>
        </trans-unit>
        <trans-unit id="4306cbf1196af02448fb51c54f07ce1e5c41ddbb" translate="yes">
          <source>Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.</source>
          <target>Watchifyは、ファイルを保存するたびに徐々にコンパイルしながら、強制終了を開始して実行を続けます。 これにより、ブラウザでの編集-保存-更新サイクルを維持できます。</target>
        </trans-unit>
        <trans-unit id="2e4ac287a7b8a6ec87dd3885f171fdb1cb26939c" translate="yes">
          <source>Watchify, Babel, and Uglify</source>
          <target>Watchify、バベル、ウグリフィ</target>
        </trans-unit>
        <trans-unit id="f89058c451cdea76e04b5f0c00e5ff23bd62a1b8" translate="yes">
          <source>We added two overload signatures to &lt;code&gt;myCoolFunction&lt;/code&gt;. The first checks states that &lt;code&gt;myCoolFunction&lt;/code&gt; takes a function (which takes a &lt;code&gt;number&lt;/code&gt;), and then a list of &lt;code&gt;number&lt;/code&gt;s. The second one says that it will take a function as well, and then uses a rest parameter (&lt;code&gt;...nums&lt;/code&gt;) to state that any number of arguments after that need to be &lt;code&gt;number&lt;/code&gt;s.</source>
          <target>&lt;code&gt;myCoolFunction&lt;/code&gt;に2つのオーバーロードシグネチャを追加しました。最初のチェックでは、&lt;code&gt;myCoolFunction&lt;/code&gt;は関数(&lt;code&gt;number&lt;/code&gt;を取る)を取り、次に&lt;code&gt;number&lt;/code&gt;のリストを取ります。 2番目の例では、関数も使用するとし、restパラメータ(&lt;code&gt;.nums&lt;/code&gt;)を使用して、それ以降の引数は&lt;code&gt;number&lt;/code&gt;sである必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="906c596e0e9e46a347b462739c927291c09ad640" translate="yes">
          <source>We also disable the project properties page when you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file. This means that all configuration changes have to be made in the &lt;code&gt;tsconfig.json&lt;/code&gt; file itself.</source>
          <target>また、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを追加すると、プロジェクトプロパティーページが無効になります。 つまり、すべての設定変更は&lt;code&gt;tsconfig.json&lt;/code&gt;ファイル自体で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="fce7ec51558a4620670481cd3447782aedb45ad7" translate="yes">
          <source>We also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let&amp;rsquo;s modify &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target>TypeScriptターゲットES2015も必要です。 Babelは、TypeScriptが生成するES2015コードからES5を生成する。 &lt;code&gt;tsconfig.json&lt;/code&gt;を変更する:</target>
        </trans-unit>
        <trans-unit id="eca6da16584407722c05c582e9312d4b12506c7e" translate="yes">
          <source>We assume that you&amp;rsquo;re already using &lt;a href="https://nodejs.org/"&gt;Node.js&lt;/a&gt; with &lt;a href="https://www.npmjs.com/"&gt;npm&lt;/a&gt;.</source>
          <target>すでに&lt;a href="https://nodejs.org/"&gt;npm&lt;/a&gt;で&lt;a href="https://www.npmjs.com/"&gt;Node.js&lt;/a&gt;を使用していると仮定します。</target>
        </trans-unit>
        <trans-unit id="dccbace9aee63165dc6770bfacb34962fe498a76" translate="yes">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target>&amp;rsquo;が実装&amp;ldquo;アンビエント&amp;rdquo;を定義しない宣言を呼び出します。 通常、これらは&lt;code&gt;.d.ts&lt;/code&gt;ファイルで定義されます。 C/C++に精通している場合は、&lt;code&gt;.h&lt;/code&gt;ファイルと考えることができます。 いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="92c076044fe3078a3a2d956ae660fa0b4723354a" translate="yes">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically, these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target>&amp;rsquo;が実装&amp;ldquo;アンビエント&amp;rdquo;を定義しない宣言を呼び出します。 通常、これらは&lt;code&gt;.d.ts&lt;/code&gt;ファイルで定義されます。 C/C++に精通している場合は、&lt;code&gt;.h&lt;/code&gt;ファイルと考えることができます。 いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d7554b9ee0145ef5796d9b34e5b993a1e04de397" translate="yes">
          <source>We called &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; to log to the console.</source>
          <target>コンソールにログインするために&lt;code&gt;watchedBrowserify.on('log',fancy_log);&lt;/code&gt;を呼び出しました。</target>
        </trans-unit>
        <trans-unit id="5dedc9b8f5d0ca8dda8092dbf79a3b7121e6221e" translate="yes">
          <source>We called &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; so that Browserify will run the &lt;code&gt;bundle&lt;/code&gt; function every time one of your TypeScript files changes.</source>
          <target>&lt;code&gt;watchedBrowserify.on('update',bundle);&lt;/code&gt;を呼び出し、TypeScriptファイルが変更されるたびに&lt;code&gt;bundle&lt;/code&gt;関数が実行されるようにしました。</target>
        </trans-unit>
        <trans-unit id="d78c8a7db971a258629029d93d5ac32c8f9a6480" translate="yes">
          <source>We can add additional members to an &lt;code&gt;interface&lt;/code&gt; with another &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target>別の&lt;code&gt;interface&lt;/code&gt;宣言を使用して、&lt;code&gt;interface&lt;/code&gt;にメンバを追加できます。</target>
        </trans-unit>
        <trans-unit id="72346222530ba2a9b0966af45f7d0245b45ebadb" translate="yes">
          <source>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</source>
          <target>それぞれのパラメータに型を追加し、関数自体に戻り型を追加することができます。 TypeScriptはreturnステートメントを見ることで戻り型を判断できるので、多くの場合、オプションでこれをオフにすることもできます。</target>
        </trans-unit>
        <trans-unit id="3ffa5dba257543828c847bbd33acb3e1bdc1db72" translate="yes">
          <source>We can also declare a variable inside of a function:</source>
          <target>関数内で変数を宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="661d963b4beb85aa27dfba66adb8817f5f2d18c5" translate="yes">
          <source>We can also explicitly give type information to the function&amp;rsquo;s argument to override any contextual type:</source>
          <target>関数の引数に型情報を明示的に与えて、コンテキスト型をオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="eaa8774bff1b83856163130bd5db5fa1d1e6c687" translate="yes">
          <source>We can also have a type alias refer to itself in a property:</source>
          <target>プロパティ内でタイプエイリアスがそれ自体を参照するようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="a869a9aafbfef91521e95e5db94bb387cae93e3a" translate="yes">
          <source>We can also write the generic type as a call signature of an object literal type:</source>
          <target>オブジェクトリテラル型の呼び出しシグネチャとしてジェネリック型を記述することもできます。</target>
        </trans-unit>
        <trans-unit id="658e04fc9fb0e75106204a24f2c9d06bdf8f78c2" translate="yes">
          <source>We can alternatively write the sample example this way:</source>
          <target>代わりに、次のようにサンプルを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="ff36204ad2dc388ad3938b7f629d5c14ff6e7faf" translate="yes">
          <source>We can define the &lt;code&gt;@configurable&lt;/code&gt; decorator using the following function declaration:</source>
          <target>&lt;code&gt;@configurable&lt;/code&gt;デコレータは、次の関数宣言を使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="82bc383c0b279737360de0b5872e4eaf53cabffa" translate="yes">
          <source>We can define the &lt;code&gt;@enumerable&lt;/code&gt; decorator using the following function declaration:</source>
          <target>&lt;code&gt;@enumerable&lt;/code&gt;デコレータは、次の関数宣言を使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="7089db4e18a0f27d1d43d048ff6a50fbd3dce944" translate="yes">
          <source>We can define the &lt;code&gt;@sealed&lt;/code&gt; decorator using the following function declaration:</source>
          <target>&lt;code&gt;@sealed&lt;/code&gt;デコレータは、次の関数宣言を使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="12d89086425b5ee284135e15deb90e23ed2590c7" translate="yes">
          <source>We can fix this by making sure the function is bound to the correct &lt;code&gt;this&lt;/code&gt; before we return the function to be used later. This way, regardless of how it&amp;rsquo;s later used, it will still be able to see the original &lt;code&gt;deck&lt;/code&gt; object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the &lt;code&gt;this&lt;/code&gt; where the function is created rather than where it is invoked:</source>
          <target>これを修正するには、後で使用する関数を返す前に、関数が正しい&lt;code&gt;this&lt;/code&gt;にバインドされていることを確認します。 この方法では、後でどのように使用するかに関係なく、元の&lt;code&gt;deck&lt;/code&gt;オブジェクトを見ることができます。 そのためには、ECMAScript6の矢印構文を使用するように関数式を変更します。 矢印関数は、関数が呼び出された場所ではなく、関数が作成された場所にある&lt;code&gt;this&lt;/code&gt;を取り込みます。</target>
        </trans-unit>
        <trans-unit id="c6ea0d2b6b5f45da1e1324a08cfc0e11b786897c" translate="yes">
          <source>We can see this in action in the following example:</source>
          <target>次の例で、これを実際に確認できます。</target>
        </trans-unit>
        <trans-unit id="65140ca83fcc5d0530859c1beb185464ff42f37a" translate="yes">
          <source>We can see this more clearly in this example:</source>
          <target>この例では、これがより明確にわかります。</target>
        </trans-unit>
        <trans-unit id="ee21326f232b62bacd8134f20c57de98fb355244" translate="yes">
          <source>We can then define the &lt;code&gt;@format&lt;/code&gt; decorator and &lt;code&gt;getFormat&lt;/code&gt; functions using the following function declarations:</source>
          <target>次に、次の関数宣言を使用して、&lt;code&gt;@format&lt;/code&gt;デコレータと&lt;code&gt;getFormat&lt;/code&gt;関数を定義します。</target>
        </trans-unit>
        <trans-unit id="bd3c3bda45ff67c029de2e2368aec01e7ef3a4eb" translate="yes">
          <source>We can then define the &lt;code&gt;@required&lt;/code&gt; and &lt;code&gt;@validate&lt;/code&gt; decorators using the following function declarations:</source>
          <target>次に、以下の関数宣言を使用して、&lt;code&gt;@required&lt;/code&gt;および&lt;code&gt;@validate&lt;/code&gt;修飾子を定義します。</target>
        </trans-unit>
        <trans-unit id="db549ad2d4eebb5605913a990e51c4ee29c07c32" translate="yes">
          <source>We can use this information to record metadata about the property, as in the following example:</source>
          <target>次の例のように、この情報を使用してプロパティに関するメタデータを記録できます。</target>
        </trans-unit>
        <trans-unit id="ea01d2c138e3b5218d8e1d52564f033747bdd0ce" translate="yes">
          <source>We can write a decorator factory in the following fashion:</source>
          <target>デコレーター・ファクトリーは以下のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="171a94c1fd6a31b533d269529646e906879fde4e" translate="yes">
          <source>We can write the same example again, this time using an interface to describe the requirement of having the &lt;code&gt;label&lt;/code&gt; property that is a string:</source>
          <target>同じ例をもう一度書くことができますが、今度はインターフェースを使って、&lt;code&gt;label&lt;/code&gt;プロパティが文字列であるという要件を記述します。</target>
        </trans-unit>
        <trans-unit id="d0f35bfcf99e7f68867547c0414c1be9551ec721" translate="yes">
          <source>We could also add a namespaced type to a class:</source>
          <target>名前空間型をクラスに追加することもできます。</target>
        </trans-unit>
        <trans-unit id="f1593c28383f7f19b9f300464de36e13bda32294" translate="yes">
          <source>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</source>
          <target>型変数の数と型変数の使用方法が同じであれば、型の汎用型パラメーターに別の名前を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="13a79655a0f6dc78edf29c467dcf807b7ee04905" translate="yes">
          <source>We just imported our &lt;code&gt;Hello&lt;/code&gt; component into &lt;code&gt;index.tsx&lt;/code&gt;. Notice that unlike with &lt;code&gt;"react"&lt;/code&gt; or &lt;code&gt;"react-dom"&lt;/code&gt;, we used a &lt;em&gt;relative path&lt;/em&gt; to &lt;code&gt;Hello.tsx&lt;/code&gt; - this is important. If we hadn&amp;rsquo;t, TypeScript would&amp;rsquo;ve instead tried looking in our &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target>&lt;code&gt;Hello&lt;/code&gt;コンポーネントを&lt;code&gt;index.tsx&lt;/code&gt;にインポートしました。&lt;code&gt;"react"&lt;/code&gt;や&lt;code&gt;"react dom"&lt;/code&gt;とは異なり、&lt;code&gt;Hello.tsx&lt;/code&gt;への&lt;em&gt;相対パス&lt;/em&gt;を使用しています。これは重要です。 もしこれがなければ、TypeScriptは代わりに&lt;code&gt;node_modules&lt;/code&gt;フォルダを検索します。</target>
        </trans-unit>
        <trans-unit id="e3b6c237e5c56a0727a6cedbb2962b0899558457" translate="yes">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target>アプリケーションを作成するときにわからない変数のタイプを記述する必要があるかもしれません。 これらの値は、動的コンテンツ、例えばユーザ又は第3者のライブラリから得ることができる。 このような場合には、型チェックを行わないようにして、コンパイル時に値をチェックするようにします。 これを行うには、これらに&lt;code&gt;any&lt;/code&gt;タイプのラベルを付けます。</target>
        </trans-unit>
        <trans-unit id="7e0b762a7d5b6b35f90cd8500631ccf9ab22b8c1" translate="yes">
          <source>We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;NPM Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target>JavaScriptパッケージをダウンロードできるように、NPMをセットアップする必要があります。 プロジェクトを右クリックし、&lt;strong&gt;New Item&lt;/strong&gt;を選択します。次に&lt;strong&gt;NPM Configuration File&lt;/strong&gt;を選択し、&lt;code&gt;package.json&lt;/code&gt;というデフォルト名を使用します。</target>
        </trans-unit>
        <trans-unit id="ebc466c22e7712a5cff2da5cf89c0cc81b64e2a7" translate="yes">
          <source>We owe a big thanks to GitHub user &lt;a href="https://github.com/jwbay"&gt;@jwbay&lt;/a&gt; who took the initiative to create a &lt;a href="https://github.com/microsoft/TypeScript/pull/32802"&gt;proof-of-concept&lt;/a&gt; and iterated to provide us with with &lt;a href="https://github.com/microsoft/TypeScript/pull/33178"&gt;the current version&lt;/a&gt;.</source>
          <target>GitHubユーザー&lt;a href="https://github.com/jwbay"&gt;@ヨウバイ&lt;/a&gt;が率先して&lt;a href="https://github.com/microsoft/TypeScript/pull/32802"&gt;概念実証&lt;/a&gt;を行い、&lt;a href="https://github.com/microsoft/TypeScript/pull/33178"&gt;現在のバージョン&lt;/a&gt;を提供してくれたことに感謝する。</target>
        </trans-unit>
        <trans-unit id="894e0a020d31c47096948e05d4d7e1a77b0f6785" translate="yes">
          <source>We owe a large thanks to community members &lt;a href="https://github.com/Kingwl"&gt;Wenlu Wang&lt;/a&gt; and &lt;a href="https://github.com/dragomirtitian"&gt;Titian Cernicova Dragomir&lt;/a&gt; for implementing this feature! For more details, &lt;a href="https://github.com/microsoft/TypeScript/pull/32883"&gt;check out their pull request&lt;/a&gt; and &lt;a href="https://github.com/tc39/proposal-nullish-coalescing/"&gt;the nullish coalescing proposal repository&lt;/a&gt;.</source>
          <target>この機能を実装してくれた&lt;a href="https://github.com/Kingwl"&gt;Wenlu・ワン&lt;/a&gt;と&lt;a href="https://github.com/dragomirtitian"&gt;ティツィアーノ・ヴェチェッリオ・Cernicova・ドラゴミール&lt;/a&gt;のコミュニティ・メンバーに感謝します。 詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32883"&gt;プルリクエスト&lt;/a&gt;と&lt;a href="https://github.com/tc39/proposal-nullish-coalescing/"&gt;ヌリシ合体提案リポジトリ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2be98474a5452e0a16847898535c758700d80e71" translate="yes">
          <source>We say that this version of the &lt;code&gt;identity&lt;/code&gt; function is generic, as it works over a range of types. Unlike using &lt;code&gt;any&lt;/code&gt;, it&amp;rsquo;s also just as precise (ie, it doesn&amp;rsquo;t lose any information) as the first &lt;code&gt;identity&lt;/code&gt; function that used numbers for the argument and return type.</source>
          <target>&lt;code&gt;identity&lt;/code&gt;関数のこのバージョンは、さまざまな型で動作するため、汎用的であると言えます。 &lt;code&gt;any&lt;/code&gt;とは異なり、この関数は、引数と戻り値の型に数字を使用した最初の&lt;code&gt;identity&lt;/code&gt;関数と同じくらい正確です(つまり、情報を失うことはありません)。</target>
        </trans-unit>
        <trans-unit id="b6da2cbd96b3e75b9187d15de475de9ac9b10faa" translate="yes">
          <source>We strongly encourage users to try the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</source>
          <target>&lt;code&gt;useDefineForClassFields&lt;/code&gt;フラグを試して、問題追跡ツールまたは以下のコメントで報告することを強くお勧めします。 これには、移行を容易にする方法を理解できるように、フラグの採用の難しさに関するフィードバックも含まれます。</target>
        </trans-unit>
        <trans-unit id="c7a2b84a24b11f7b028b0dbae7870221e6b866b5" translate="yes">
          <source>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</source>
          <target>モノクロで大量に出力するのは、目に見えて少し難しいこともある。 色は、メッセージの開始位置と終了位置を識別するのに役立ち、エラー出力が圧倒的に大きくなると、これらの視覚的な手がかりが重要になります。</target>
        </trans-unit>
        <trans-unit id="9c538d5dd6bb04252a1e101d363501930cb1f96c" translate="yes">
          <source>We used a &lt;code&gt;.ts&lt;/code&gt; extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</source>
          <target state="translated">ファイル名に &lt;code&gt;.ts&lt;/code&gt; 拡張子を使用しましたが、このコードは単なる JavaScript です。 これを既存の JavaScript アプリケーションから直接コピー/ペーストすることもできます。</target>
        </trans-unit>
        <trans-unit id="5123383e9966536bbcb7f101d2b7d8f6a074dca8" translate="yes">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;Triangle&lt;/code&gt; to &lt;code&gt;Shape&lt;/code&gt;, we need to update &lt;code&gt;area&lt;/code&gt; as well:</source>
          <target>差別化された和集合のすべての変形を網羅しない場合には、コンパイラに知らせてほしい。 たとえば、&lt;code&gt;Shape&lt;/code&gt;に&lt;code&gt;Triangle&lt;/code&gt;を追加する場合は、&lt;code&gt;area&lt;/code&gt;も更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c5b24b66e133e695b5340a53b29a9a03a4588c0" translate="yes">
          <source>We wrapped our &lt;code&gt;browserify&lt;/code&gt; instance in a call to &lt;code&gt;watchify&lt;/code&gt;, and then held on to the result.</source>
          <target>&lt;code&gt;browserify&lt;/code&gt;インスタンスを&lt;code&gt;バッチフィ&lt;/code&gt;呼び出しにラップし、結果を保持しました。</target>
        </trans-unit>
        <trans-unit id="b6077b883e1d7e622df4d40c8eae3398ce7b9837" translate="yes">
          <source>We&amp;rsquo;d like to extend a huge thanks to &lt;a href="https://github.com/calebsander"&gt;Caleb Sander&lt;/a&gt; for all the work on this feature. We&amp;rsquo;re grateful for the contribution, and we&amp;rsquo;re sure our users are too!</source>
          <target>この機能に関するすべての作業について、&lt;a href="https://github.com/calebsander"&gt;Caleb Sander&lt;/a&gt;に深く感謝します。 この貢献に感謝しています。また、ユーザーにも感謝しています。</target>
        </trans-unit>
        <trans-unit id="2955af2348407c162d10bf22c8f15b1a2bc20810" translate="yes">
          <source>We&amp;rsquo;ll also need a page to display our &lt;code&gt;Hello&lt;/code&gt; component. Create a file at the root of &lt;code&gt;proj&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt; with the following contents:</source>
          <target>&lt;code&gt;Hello&lt;/code&gt;コンポーネントを表示するページも必要です。 &lt;code&gt;proj&lt;/code&gt;のルートに、次の内容を含む&lt;code&gt;index.html&lt;/code&gt;という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="eb0e5a7f6725b7d626b76e36ae307b3fc402a1e2" translate="yes">
          <source>We&amp;rsquo;ll discuss index signatures in a bit, but here we&amp;rsquo;re saying a &lt;code&gt;SquareConfig&lt;/code&gt; can have any number of properties, and as long as they aren&amp;rsquo;t &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;width&lt;/code&gt;, their types don&amp;rsquo;t matter.</source>
          <target>インデックスシグネチャについては少し説明しますが、ここでは&lt;code&gt;SquareConfig&lt;/code&gt;には任意の数のプロパティを指定できます。&lt;code&gt;color&lt;/code&gt;または&lt;code&gt;width&lt;/code&gt;を指定しない限り、その型は関係ありません。</target>
        </trans-unit>
        <trans-unit id="1a2f59b32ace790506f0abdad902dd97d8982882" translate="yes">
          <source>We&amp;rsquo;ll first start off with numeric enums, which are probably more familiar if you&amp;rsquo;re coming from other languages. An enum can be defined using the &lt;code&gt;enum&lt;/code&gt; keyword.</source>
          <target>最初に列挙型の数値を使用します。他の言語から使用する場合は、列挙型の方が一般的です。 enumは、&lt;code&gt;enum&lt;/code&gt;キーワードを使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="19448f8bcee986b6f99112a504f95247ef4c159e" translate="yes">
          <source>We&amp;rsquo;ll start with Watchify to provide background compilation:</source>
          <target>バックグラウンドでコンパイルするには、まずWatchifyを使用します:</target>
        </trans-unit>
        <trans-unit id="0b37518565138e9254324247a79b02efcfc6deef" translate="yes">
          <source>We&amp;rsquo;re also creating another value that we call the &lt;em&gt;constructor function&lt;/em&gt;. This is the function that is called when we &lt;code&gt;new&lt;/code&gt; up instances of the class. To see what this looks like in practice, let&amp;rsquo;s take a look at the JavaScript created by the above example:</source>
          <target>また、&lt;em&gt;コンストラクタ関数&lt;/em&gt;と呼ばれる別の値も作成します。これは、クラスのインスタンスを&lt;code&gt;new&lt;/code&gt;upするときに呼び出される関数です。 実際にどのように見えるかを確認するには、上記の例で作成されたJavaScriptを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="7aff8cf77620ede7bc7d3e8d39158810b0f689b3" translate="yes">
          <source>We&amp;rsquo;re also including two other utility types as well: &lt;code&gt;Record&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt;.</source>
          <target>&lt;code&gt;Record&lt;/code&gt;および&lt;code&gt;Pick&lt;/code&gt;という2つのユーティリティタイプも含まれています。</target>
        </trans-unit>
        <trans-unit id="6f3e9714b389303e76259f45a7e8e4a3371445cb" translate="yes">
          <source>We&amp;rsquo;re also introducing a new mode for &lt;code&gt;tsc&lt;/code&gt;, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand in hand with project references to enable faster TypeScript builds.</source>
          <target>また、&lt;code&gt;tsc&lt;/code&gt;の新しいモードである&lt;code&gt;--build&lt;/code&gt;フラグも導入しました。このモードは、プロジェクト参照と連携して動作し、TypeScriptのビルドを高速化します。</target>
        </trans-unit>
        <trans-unit id="0a856c3b5c5d0b1b8b27ac26776fabf8b60ed0f0" translate="yes">
          <source>We&amp;rsquo;ve also added support for &lt;a href="https://github.com/Microsoft/TypeScript/issues/14479"&gt;declaration source maps&lt;/a&gt;. If you enable &lt;code&gt;--declarationMap&lt;/code&gt;, you&amp;rsquo;ll be able to use editor features like &amp;ldquo;Go to Definition&amp;rdquo; and Rename to transparently navigate and edit code across project boundaries in supported editors.</source>
          <target>また、&lt;a href="https://github.com/Microsoft/TypeScript/issues/14479"&gt;宣言ソースマップ&lt;/a&gt;のサポートも追加されました。&lt;code&gt;--declarationMap&lt;/code&gt;を有効にすると、&amp;ldquo;Go to Definition&amp;rdquo;やRenameなどのエディタ機能を使用して、サポートされているエディタでプロジェクトの境界を越えて透過的にコードをナビゲートおよび編集できるようになります。</target>
        </trans-unit>
        <trans-unit id="f8e13c786c22514d18489b8a515cda5e549982a7" translate="yes">
          <source>We&amp;rsquo;ve now added a type variable &lt;code&gt;T&lt;/code&gt; to the identity function. This &lt;code&gt;T&lt;/code&gt; allows us to capture the type the user provides (e.g. &lt;code&gt;number&lt;/code&gt;), so that we can use that information later. Here, we use &lt;code&gt;T&lt;/code&gt; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</source>
          <target>アイデンティティー関数に型変数&lt;code&gt;T&lt;/code&gt;を追加しました。 この&lt;code&gt;T&lt;/code&gt;を使用すると、ユーザーが入力したタイプ(たとえば、&lt;code&gt;number&lt;/code&gt;)を取得できるため、後でその情報を使用できます。 ここでも、&lt;code&gt;T&lt;/code&gt;を戻り型として使用します。 検査の結果、引数と戻り値に同じ型が使用されていることがわかります。 これにより、関数の一方の側でその型の情報をやり取りし、もう一方の側でその情報をやり取りすることができます。</target>
        </trans-unit>
        <trans-unit id="5d422ede737ddc07ca03c94e0a0c10b9d58412d1" translate="yes">
          <source>Weak Type Detection</source>
          <target>弱検出</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="c81830d8b730ad2fae90f8032a7776f8b0e39714" translate="yes">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;awesome-typescript-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target>Webpackの統合は非常に簡単です。 &lt;code&gt;awesome typescript loader&lt;/code&gt;というTypeScriptローダを&lt;code&gt;source map loader&lt;/code&gt;と組み合わせて使うとデバッグが容易になる。 シンプルに実行</target>
        </trans-unit>
        <trans-unit id="0f41141dbd3f1cbecbaad98cf3de708ecdf41b9b" translate="yes">
          <source>Webpack is a tool that will bundle your code and optionally all of its dependencies into a single &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target>Webpackは、コードとそのすべての依存関係を1つの&lt;code&gt;.js&lt;/code&gt;ファイルにバンドルするツールです。</target>
        </trans-unit>
        <trans-unit id="7901ed28bacfe5bf0d524efc7190b1e5a54f7326" translate="yes">
          <source>Webpack will eventually generate the &lt;code&gt;dist&lt;/code&gt; directory for us.</source>
          <target>Webpackは最終的に&lt;code&gt;dist&lt;/code&gt;ディレクトリを生成します。</target>
        </trans-unit>
        <trans-unit id="39db66a63832d879643a9c74c80d078ce3a9abfa" translate="yes">
          <source>Weeding out Errors</source>
          <target>エラーの除去</target>
        </trans-unit>
        <trans-unit id="e97ac55d12c65e8ccc90515dafcb06d1bbf38e6c" translate="yes">
          <source>Well-known Symbols</source>
          <target>既知シンボル</target>
        </trans-unit>
        <trans-unit id="b453e4894b5221614db3412183873d5d5a3d6fc9" translate="yes">
          <source>What if we want to also log the length of the argument &lt;code&gt;arg&lt;/code&gt; to the console with each call? We might be tempted to write this:</source>
          <target>呼び出しごとに引き数&lt;code&gt;arg&lt;/code&gt;の長さもコンソールに記録したい場合はどうすればよいでしょうか。 次のように書きたくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="45fda52dea40ed49a1af31b0fc06e0a0f19b734d" translate="yes">
          <source>What if we&amp;rsquo;re not running in TypeScript 3.1 in this example? Well, if none of the fields in &lt;code&gt;typesVersions&lt;/code&gt; get matched, TypeScript falls back to the &lt;code&gt;types&lt;/code&gt; field, so here TypeScript 3.0 and earlier will be redirected to &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt;.</source>
          <target>この例のTypeScript3.1で実行していない場合はどうなりますか? さて、&lt;code&gt;typesVersions&lt;/code&gt;のフィールドのどれにも一致しない場合、TypeScriptは&lt;code&gt;types&lt;/code&gt;フィールドに戻るので、TypeScript3.0以前は&lt;code&gt;[.]/node_modules/package-name/index.d.ts&lt;/code&gt;にリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="6349e923db276196bacfe2471e600626fa732ab4" translate="yes">
          <source>What is a Project Reference?</source>
          <target>プロジェクトリファレンスとは。</target>
        </trans-unit>
        <trans-unit id="59beb27768eff0de85903d679ab600335df3cfc4" translate="yes">
          <source>What is supported in my version of Visual Studio?</source>
          <target>使用しているバージョンのVisual Studioでは何がサポートされていますか。</target>
        </trans-unit>
        <trans-unit id="6ebc3fc3da860ce67243a9d91e606b84eda07cf2" translate="yes">
          <source>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</source>
          <target>この2つの結論は、プロパティーとアクセサーを混在させると問題が発生し、初期化子のないプロパティーを再宣言することになります。</target>
        </trans-unit>
        <trans-unit id="a2efe202772f684e9538c631455d896fa7d07336" translate="yes">
          <source>What's New</source>
          <target>最新情報</target>
        </trans-unit>
        <trans-unit id="b19f846e4de2aa633d8a22d53f27123620724843" translate="yes">
          <source>When &lt;code&gt;@sealed&lt;/code&gt; is executed, it will seal both the constructor and its prototype.</source>
          <target>&lt;code&gt;@sealed&lt;/code&gt;が実行されると、コンストラクターとそのプロトタイプの両方が封印されます。</target>
        </trans-unit>
        <trans-unit id="030f0dfcec29d2c5288e91c918593dc6c753cec6" translate="yes">
          <source>When &lt;code&gt;localStorage.volume&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, the page will set the volume to &lt;code&gt;0.5&lt;/code&gt; which is unintended. &lt;code&gt;??&lt;/code&gt; avoids some unintended behavior from &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;""&lt;/code&gt; being treated as falsy values.</source>
          <target>&lt;code&gt;localStorage.volume&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;に設定されている場合、ページはボリュームを&lt;code&gt;0.5&lt;/code&gt;に設定しますが、これは意図しないことです。 &lt;code&gt;?&lt;/code&gt;は、&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;、および&lt;code&gt;"&lt;/code&gt;がファルシ値として扱われることによる意図しない動作を回避します。</target>
        </trans-unit>
        <trans-unit id="f8cdcfeef8004c101022b373d173e5e67f254a91" translate="yes">
          <source>When &lt;code&gt;outFile&lt;/code&gt; is used, the build information file&amp;rsquo;s name will be based on the output file&amp;rsquo;s name. As an example, if our output JavaScript file is &lt;code&gt;./output/foo.js&lt;/code&gt;, then under the &lt;code&gt;--incremental&lt;/code&gt; flag, TypeScript will generate the file &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt;. As above, this can be controlled with the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target>&lt;code&gt;outFile&lt;/code&gt;が使用される場合、ビルド情報ファイルの名前は、出力ファイルの名前に基づきます。 例えば、出力JavaScriptファイルが&lt;code&gt;./output/foo.js&lt;/code&gt;の場合、&lt;code&gt;--incremental&lt;/code&gt;フラグの下で、TypeScriptはファイル&lt;code&gt;./output/foo.ツバイルドインフォ&lt;/code&gt;を生成します。上記のように、これは&lt;code&gt;--tsBuildInfoFile&lt;/code&gt;フラグで制御できます。</target>
        </trans-unit>
        <trans-unit id="f520248f652ff2167281b35bfd68546d3ba6914b" translate="yes">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is enabled, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; get their own types called &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Whenever anything is &lt;em&gt;possibly&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;, you can use a union type with the original type. So for instance, if something could be a &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you&amp;rsquo;d write the type out as &lt;code&gt;number | null&lt;/code&gt;.</source>
          <target>&lt;code&gt;strictNullChecks&lt;/code&gt;が有効な場合、&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;は、それぞれ&lt;code&gt;null&lt;/code&gt;および&lt;code&gt;undefined&lt;/code&gt;と呼ばれる独自の型を取得します。 &lt;em&gt;&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;の可能性がある場合は常に、元の型のユニオン型を使用できます。 たとえば、&lt;code&gt;number&lt;/code&gt;または&lt;code&gt;null&lt;/code&gt;である可能性がある場合、タイプを&lt;code&gt;number null&lt;/code&gt;として書き出します。</target>
        </trans-unit>
        <trans-unit id="5bbf9f8fcdd1b99e48e1893b7a75fd930f81e35d" translate="yes">
          <source>When Javascript classes extend a generic base class, there is nowhere to specify what the type parameter should be. The &lt;code&gt;@extends&lt;/code&gt; tag provides a place for that type parameter:</source>
          <target>Java Scriptクラスが汎用ベース・クラスを拡張する場合、型パラメーターを指定する場所はありません。 &lt;code&gt;@extends&lt;/code&gt;タグは、その型パラメータの場所を提供します。</target>
        </trans-unit>
        <trans-unit id="ac8c176e99ff6882e6b0d9b7305bf530d1b1a588" translate="yes">
          <source>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</source>
          <target>関数呼び出しの最後の引数にタプル型の展開式が含まれている場合、展開式はタプル要素型の個別の引数のシーケンスに対応します。</target>
        </trans-unit>
        <trans-unit id="9c33bce0f75302f0d6e1a7e860836fefe8f472c2" translate="yes">
          <source>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</source>
          <target>関数にrestパラメータがある場合、関数は無限の一連のオプションパラメータとして扱われます。</target>
        </trans-unit>
        <trans-unit id="fd713400776c7d40925b3ed1ecacc3ed2345c946" translate="yes">
          <source>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</source>
          <target>関数にオーバーロードがある場合、ソース・タイプの各オーバーロードは、ターゲット・タイプの互換性のあるシグネチャと一致する必要があります。 これにより、ソース関数と同じ状況でターゲット関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="5607cf867fc582d411cd22588c4ee37feb393557" translate="yes">
          <source>When a member is marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target>&lt;code&gt;private&lt;/code&gt;とマークされたメンバは、そのメンバを含むクラスの外部からはアクセスできません。 例:</target>
        </trans-unit>
        <trans-unit id="584d36e45bec249f6c98a43c17d122b7fd42bae9" translate="yes">
          <source>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:</source>
          <target>restパラメータがタプル型を持つ場合、タプル型は一連の離散パラメータに展開されます。 たとえば、次の2つの宣言は同等です。</target>
        </trans-unit>
        <trans-unit id="564e9e469a41360585db50dc07312fe0e7a957af" translate="yes">
          <source>When a type inference is made from several expressions, the types of those expressions are used to calculate a &amp;ldquo;best common type&amp;rdquo;. For example,</source>
          <target>複数の式から型推論を行う場合は、それらの式の型を使用して&amp;ldquo;best common type&amp;rdquo;を計算します。 たとえば</target>
        </trans-unit>
        <trans-unit id="5b460fc1b0afb2a95c11c3857f5c3f8edcb0a57d" translate="yes">
          <source>When a variable is declared using &lt;code&gt;let&lt;/code&gt;, it uses what some call &lt;em&gt;lexical-scoping&lt;/em&gt; or &lt;em&gt;block-scoping&lt;/em&gt;. Unlike variables declared with &lt;code&gt;var&lt;/code&gt; whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or &lt;code&gt;for&lt;/code&gt;-loop.</source>
          <target>&lt;code&gt;let&lt;/code&gt;を使用して変数を宣言すると、&lt;em&gt;字句スコープ&lt;/em&gt;または&lt;em&gt;ブロックスコープ&lt;/em&gt;と呼ばれるものが使用されます。 &lt;code&gt;var&lt;/code&gt;で宣言された変数のスコープがその変数を含む関数にリークするのとは異なり、ブロックスコープ変数は、&lt;/code&gt;-loopのための最も近い包含ブロックまたは&lt;code&gt;の外には見えない。</target>
        </trans-unit>
        <trans-unit id="e90a72104ebe8868314228d24725924c08766c5b" translate="yes">
          <source>When accessing an element with a known index, the correct type is retrieved:</source>
          <target>既知のインデックスを持つ要素にアクセスすると、正しい型が取得されます。</target>
        </trans-unit>
        <trans-unit id="d43b1825ee2b2cb0d745c365143986923701b4d7" translate="yes">
          <source>When all members in an enum have literal enum values, some special semantics come to play.</source>
          <target>enum内のすべてのメンバがリテラルenum値を持つ場合、いくつかの特別な意味論が働く。</target>
        </trans-unit>
        <trans-unit id="84234191fb7cb5a1d6647ae5bcd64e2e66fdf73e" translate="yes">
          <source>When an array literal is contextually typed by the implied type of an array binding pattern:</source>
          <target>配列リテラルが配列バインディングパターンの暗黙の型によってコンテキスト的に型付けされる場合:</target>
        </trans-unit>
        <trans-unit id="6db5ea81f7f1151fab25e118bfe8501e1c5b8304" translate="yes">
          <source>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</source>
          <target>インターフェース・タイプがクラス・タイプを拡張すると、そのインターフェース・タイプはクラスのメンバーを継承しますが、その実装は継承しません。 これは、インターフェースが実装を提供せずにクラスのすべてのメンバーを宣言したようなものです。 インターフェースは、基本クラスのprivateメンバーとprotectedメンバーも継承します。 つまり、プライベートメンバーまたは保護されたメンバーを持つクラスを拡張するインターフェイスを作成する場合、そのインターフェイスの種類はそのクラスまたはそのサブクラスによってのみ実装できます。</target>
        </trans-unit>
        <trans-unit id="5744d6fdcbf8dc3476727393bac3b4cddf93ada3" translate="yes">
          <source>When an object literal is contextually typed by the implied type of an object binding pattern:</source>
          <target>オブジェクト・リテラルがオブジェクト・バインディング・パターンの暗黙の型によってコンテキスト的に型付けされる場合:</target>
        </trans-unit>
        <trans-unit id="be88d1b03a9be5d8830da895b57d21e37b131ee9" translate="yes">
          <source>When an object with a numeric index signature of type &lt;code&gt;T&lt;/code&gt; (such as an array) is indexed by a &lt;code&gt;for..in&lt;/code&gt; variable of a containing &lt;code&gt;for..in&lt;/code&gt; statement for an object &lt;em&gt;with&lt;/em&gt; a numeric index signature and &lt;em&gt;without&lt;/em&gt; a string index signature (again such as an array), the value produced is of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target>&lt;code&gt;T&lt;/code&gt;型の数値インデックスシグネチャ(配列など)を持つオブジェクトが、&lt;code&gt;for.in&lt;/code&gt;ステートメントの&lt;code&gt;for.in&lt;/code&gt;変数によって、&lt;/em&gt;数値インデックスシグネチャを持ち&lt;/em&gt;文字列インデックスシグネチャ(配列など)を持たない&lt;em&gt;オブジェクトに対してインデックス付けされる場合、生成される値の型は&lt;code&gt;T&lt;/code&gt;である。</target>
        </trans-unit>
        <trans-unit id="6a191b524d20c2c29223783fb417af58e807f338" translate="yes">
          <source>When calling this function, TypeScript will try to figure out the types of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; through a process called &lt;em&gt;type argument inference&lt;/em&gt;. This inference process usually works pretty well:</source>
          <target>この関数を呼び出すと、TypeScriptは&lt;em&gt;型引数推論&lt;/em&gt;と呼ばれるプロセスを通じて&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、および&lt;code&gt;C&lt;/code&gt;の型を計算しようとします。この推論プロセスは通常、非常にうまく機能します。</target>
        </trans-unit>
        <trans-unit id="a79acd611da5588e33a3cd349e2f634dc5e04388" translate="yes">
          <source>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.</source>
          <target>互換性のために関数を比較する場合、オプションのパラメータと必須のパラメータは交換可能です。 ソース・タイプの追加オプション・パラメータはエラーではなく、ソース・タイプに対応するパラメータがないターゲット・タイプのオプション・パラメータはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="03084317d53b13f20dd727e5c86474664f6cced3" translate="yes">
          <source>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</source>
          <target>関数パラメータのタイプを比較する場合、ソースパラメータがターゲットパラメータに代入可能であれば代入は成功し、その逆も同様です。 これは、呼び出し側に、より特殊化された型を取る関数が与えられ、より特殊化されていない型で関数が呼び出される可能性があるためです。 実際には、この種のエラーはまれであり、これを許可することで、多くの一般的なJavaScriptパターンが可能になります。 簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="e381f7d0b16f43f925b00a27f8c4e30f5d16099b" translate="yes">
          <source>When compiled in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, optional properties and methods automatically have &lt;code&gt;undefined&lt;/code&gt; included in their type. Thus, the &lt;code&gt;b&lt;/code&gt; property above is of type &lt;code&gt;number | undefined&lt;/code&gt; and the &lt;code&gt;g&lt;/code&gt; method above is of type &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt;. Type guards can be used to strip away the &lt;code&gt;undefined&lt;/code&gt; part of the type:</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;モードでコンパイルすると、オプションのプロパティとメソッドは自動的に&lt;code&gt;undefined&lt;/code&gt;を型に含めます。 したがって、上記の&lt;code&gt;b&lt;/code&gt;プロパティは&lt;code&gt;number undefined&lt;/code&gt;型であり、上記の&lt;code&gt;g&lt;/code&gt;メソッドは&lt;code&gt;(()=&amp;gt;number)undefined&lt;/code&gt;型です。型ガードを使用すると、型の&lt;code&gt;undefined&lt;/code&gt;部分を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="5bbcd2d4cb15d58c0854ed82d657d8c796031edd" translate="yes">
          <source>When compiled, each module will become a separate &lt;code&gt;.js&lt;/code&gt; file. As with reference tags, the compiler will follow &lt;code&gt;import&lt;/code&gt; statements to compile dependent files.</source>
          <target>コンパイルされると、各モジュールは別々の&lt;code&gt;.js&lt;/code&gt;ファイルになります。 参照タグと同様に、コンパイラは&lt;code&gt;import&lt;/code&gt;ステートメントに従って依存ファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="751fdd8e03ce07c29b56146fecc9f825067cb792" translate="yes">
          <source>When compiling to pre-ES6 targets, the string is decomposed:</source>
          <target>ES6以前のターゲットにコンパイルすると、文字列が分解されます。</target>
        </trans-unit>
        <trans-unit id="4156655ae276c8b3ed96d041dfc8baeba1797652" translate="yes">
          <source>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</source>
          <target>ジェネリックを使用してTypeScriptでファクトリを作成する場合は、コンストラクタ関数でクラス型を参照する必要があります。 たとえば</target>
        </trans-unit>
        <trans-unit id="f2a561b2561570486c65edf072423fc080bd866b" translate="yes">
          <source>When enabled, as long as the &lt;code&gt;reflect-metadata&lt;/code&gt; library has been imported, additional design-time type information will be exposed at runtime.</source>
          <target>有効にすると、&lt;code&gt;reflect metadata&lt;/code&gt;ライブラリがインポートされている限り、実行時に追加のデザインタイムタイプ情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="7c2be8d3bddd72617c23414391cc48bc565dfaa5" translate="yes">
          <source>When exporting a module using &lt;code&gt;export =&lt;/code&gt;, TypeScript-specific &lt;code&gt;import module = require("module")&lt;/code&gt; must be used to import the module.</source>
          <target>&lt;code&gt;export=&lt;/code&gt;を使用してモジュールをエクスポートする場合は、TypeScript固有の&lt;code&gt;import module=require("module")&lt;/code&gt;を使用してモジュールをインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="06ca5da26932f2433c3883f2ba92d649c8f8ac14" translate="yes">
          <source>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</source>
          <target>最初にモジュールベースの組織に移行するときは、エクスポートを名前空間の追加レイヤーでラップするのが一般的です。 モジュールには独自のスコープがあり、エクスポートされた宣言のみがモジュールの外部から表示されます。 このことを念頭に置くと、モジュールを扱う際に名前空間が提供する価値は、あるとしてもごくわずかです。</target>
        </trans-unit>
        <trans-unit id="e0cbb0349fc79c96ec431ec47e8f342090438ecb" translate="yes">
          <source>When importing using the &lt;code&gt;Node&lt;/code&gt; module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from &amp;ldquo;identical&amp;rdquo; packages. If a file originates from a package with a &lt;code&gt;package.json&lt;/code&gt; containing the same &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain &lt;code&gt;private&lt;/code&gt; members that cause them to be structurally incompatible.</source>
          <target>TypeScript2.5の&lt;code&gt;Node&lt;/code&gt;モジュール解決方法を使用してインポートする場合、コンパイラはファイルが&amp;ldquo;同一の&amp;rdquo;パッケージから生成されたものかどうかをチェックするようになりました。 ファイルが&lt;code&gt;package.json&lt;/code&gt;を持つパッケージから生成され、&lt;code&gt;name&lt;/code&gt;フィールドと&lt;code&gt;version&lt;/code&gt;フィールドが以前に出てきたパッケージと同じである場合、TypeScriptは自身を最上位のパッケージにリダイレクトする。 これにより、2つのパッケージに同じクラス宣言が含まれていても、構造的に互換性がない&lt;code&gt;private&lt;/code&gt;メンバが含まれている場合の問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="e53d751bb35ec11bb8d50707759e0855efc875fb" translate="yes">
          <source>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the &lt;em&gt;last&lt;/em&gt; signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</source>
          <target>複数の呼び出しシグネチャを持つ型(オーバーロードされた関数の型など)から推論する場合、&lt;em&gt;最後の&lt;/em&gt;シグネチャから推論が行われます(これは、おそらく最も許容的なキャッチオールの場合です)。 引数型のリストに基づいてオーバーロードを解決することはできません。</target>
        </trans-unit>
        <trans-unit id="c0e5d12e818f1a128405e0dcf37599e5124ab4c5" translate="yes">
          <source>When input files are specified on the command line, &lt;code&gt;tsconfig.json&lt;/code&gt; files are ignored.</source>
          <target>コマンドラインで入力ファイルを指定すると、&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="c7dbba16b050a53843a9368cb4cf7aacd6cb532e" translate="yes">
          <source>When install is complete, rebuild!</source>
          <target>インストールが完了したら、再構築します。</target>
        </trans-unit>
        <trans-unit id="9030ab49af527527a3048a47ea128f0c0c219027" translate="yes">
          <source>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</source>
          <target>サード・パーティーのJavaScriptと対話する場合は、上記のようなパターンを使用して型の形状を完全に記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="6164dc5fed96c16868282dad3b94f86d550f8593" translate="yes">
          <source>When looking at the code of a global library, you&amp;rsquo;ll usually see:</source>
          <target>グローバルライブラリのコードを見ると、通常は次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="5b922be38a1d8a16178d415d54259031e8aa4f6f" translate="yes">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href="http://en.wikipedia.org/wiki/Function_composition"&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target>複数のデコレータが1つの宣言に適用される場合、その評価は数学&lt;/a&gt;における&lt;a href="http://en.wikipedia.org/wiki/Function_composition"&gt;関数の構成と同様です。 このモデルでは、関数&lt;em&gt;f&lt;/em&gt;と&lt;em&gt;g&lt;/em&gt;を合成すると、&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)と&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;))が等しくなります。</target>
        </trans-unit>
        <trans-unit id="1f6f6092ccbf1d0a9294c7e4c282859a027ca09d" translate="yes">
          <source>When no best common type is found, the resulting inference is the union array type, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt;.</source>
          <target>最適な共通型が見つからない場合は、ユニオン配列型&lt;code&gt;(Rhino Elephant Snake)[]&lt;/code&gt;が推論されます。</target>
        </trans-unit>
        <trans-unit id="577abe4bb126beb561a8efdcb48a28392a4a75af" translate="yes">
          <source>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; has a single construct signature &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt;.</source>
          <target>mixinコンストラクタ型を含む交差型の構成体シグネチャを取得する場合、mixin構成体シグネチャは破棄され、そのインスタンス型は交差型の他の構成体シグネチャの戻り型に混合されます。 たとえば、交差タイプ&lt;code&gt;{new(.args:any[])=&amp;gt;A}&amp;amp;{new(s:string)=&amp;gt;B}&lt;/code&gt;には、単一の構文シグネチャ&lt;code&gt;new(s:string)=&amp;gt;A&amp;amp;B&lt;/code&gt;があります。</target>
        </trans-unit>
        <trans-unit id="c5037d7b746e687be44f9da9ad23e7dc846aba52" translate="yes">
          <source>When reading from a union type, you can see any properties that are shared by them:</source>
          <target>共用体タイプから読み込むと、共用されているすべてのプロパティーが表示されます。</target>
        </trans-unit>
        <trans-unit id="35582d74eec1d631b57c2de10a47c90c793d3dde" translate="yes">
          <source>When relating the type of &lt;code&gt;map&lt;/code&gt; in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</source>
          <target>TS2.4で&lt;code&gt;map&lt;/code&gt;の型を関連付けるとき、言語は各パラメータがコールバック型であるかどうかをチェックし、コールバック型である場合、それらのパラメータが現在のリレーションに対して逆にチェックされることを保証する。</target>
        </trans-unit>
        <trans-unit id="1ff10b12f6a9033fbc10cf950cc0ed31b94b4a4d" translate="yes">
          <source>When specifying a greeting, you must pass a &lt;code&gt;GreetingSettings&lt;/code&gt; object. This object has the following properties:</source>
          <target>挨拶を指定するときは、&lt;code&gt;GreetingSettings&lt;/code&gt;オブジェクトを渡す必要があります。 このオブジェクトには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="43988d6b430a774a26861955cc54fd9c702d0452" translate="yes">
          <source>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</source>
          <target>型引数を指定する場合は、必要な型パラメータに型引数を指定するだけです。 タイプパラメータが指定されていない場合は、既定のタイプに解決されます。</target>
        </trans-unit>
        <trans-unit id="1ebe929f8f784ba5280922a50ab6e379d8859057" translate="yes">
          <source>When targeting ES3/ES5, the following code</source>
          <target>ES3/ES5をターゲットにする場合は、以下のコードを実行します。</target>
        </trans-unit>
        <trans-unit id="156025a3f40907ffeac72e030a3a730a1deebeb1" translate="yes">
          <source>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate &lt;code&gt;for..of&lt;/code&gt; loops to target the built-in iterator implementation in the engine.</source>
          <target>ECMAScipt2015準拠のエンジンをターゲットとする場合、コンパイラは&lt;code&gt;for.of&lt;/code&gt;ループを生成し、エンジン内の組み込みイテレータ実装をターゲットにします。</target>
        </trans-unit>
        <trans-unit id="81f1ae5ab6877859c51c53b6981d29f05adff0a6" translate="yes">
          <source>When targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of &lt;code&gt;Array&lt;/code&gt; type. It is an error to use &lt;code&gt;for..of&lt;/code&gt; loops on non-Array values, even if these non-Array values implement the &lt;code&gt;Symbol.iterator&lt;/code&gt; property.</source>
          <target>ES5またはES3準拠のエンジンを対象とする場合、イテレーターは&lt;code&gt;Array&lt;/code&gt;型の値に対してのみ使用できます。 配列以外の値に対して&lt;code&gt;for.of&lt;/code&gt;ループを使用すると、これらの配列以外の値が&lt;code&gt;Symbol.iterator&lt;/code&gt;プロパティを実装している場合でもエラーになります。</target>
        </trans-unit>
        <trans-unit id="2fff15c1d3e5e5f2e18f1d4a6ac9350c4a78b3f2" translate="yes">
          <source>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</source>
          <target>タプル・タイプがレスト・パラメータに対して推論される場合、ソースのオプション・パラメータは、推論されるタイプのオプション・タプル要素になります。</target>
        </trans-unit>
        <trans-unit id="75737547c96987306eebfed378fbd115f0634d72" translate="yes">
          <source>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;. A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target>TypeScript3.1でノードモジュール解決を使用する場合、TypeScriptは&lt;code&gt;package.json&lt;/code&gt;ファイルをクラックして読み込む必要のあるファイルを見つけると、まず&lt;code&gt;typesVersions&lt;/code&gt;という新しいフィールドを調べます。 &lt;code&gt;typesVersions&lt;/code&gt;フィールドを持つ&lt;code&gt;package.json&lt;/code&gt;は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="4850716ae612670ae2d56349b6a2660a6446e72a" translate="yes">
          <source>When we do, the compiler will give us an error that we&amp;rsquo;re using the &lt;code&gt;.length&lt;/code&gt; member of &lt;code&gt;arg&lt;/code&gt;, but nowhere have we said that &lt;code&gt;arg&lt;/code&gt; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &lt;code&gt;number&lt;/code&gt; instead, which does not have a &lt;code&gt;.length&lt;/code&gt; member.</source>
          <target>これを行うと、コンパイラは&lt;code&gt;arg&lt;/code&gt;の&lt;code&gt;.length&lt;/code&gt;メンバを使用しているというエラーを返しますが、&lt;code&gt;arg&lt;/code&gt;にこのメンバがあるとは言っていません。 前述したように、これらの型変数はすべての型を表すので、この関数を使用する人は、&lt;code&gt;.length&lt;/code&gt;メンバを持たない&lt;code&gt;number&lt;/code&gt;を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="217dd70751ec70c2507f34daeb4f28f27ba30001" translate="yes">
          <source>When we first touched on the idea of variable capturing with &lt;code&gt;var&lt;/code&gt; declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an &amp;ldquo;environment&amp;rdquo; of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.</source>
          <target>&lt;code&gt;var&lt;/code&gt;宣言を使って変数をキャプチャーするという考えに最初に触れたとき、変数がいったんキャプチャーされるとどのように動作するかについて簡単に説明しました。 これをより直感的に理解するために、スコープが実行されるたびに、変数の&amp;ldquo;環境&amp;rdquo;が作成されます。 その環境とキャプチャーされた変数は、そのスコープ内のすべての実行が終了した後でも存在することができます。</target>
        </trans-unit>
        <trans-unit id="3ff7f4efa05e217597245c432a821c2527e220ab" translate="yes">
          <source>When working with classes and interfaces, it helps to keep in mind that a class has &lt;em&gt;two&lt;/em&gt; types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</source>
          <target>クラスとインタフェースを使用する場合、クラスには&lt;em&gt;2つの&lt;/em&gt;タイプがあることに注意してください。静的側のタイプとインスタンス側のタイプです。 構文シグネチャを持つインタフェースを作成し、このインタフェースを実装するクラスを作成しようとすると、次のようなエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="59ca9320ae741734ed0a3e6c543e8c5deef3ad35" translate="yes">
          <source>When writing in JavaScript files (using &lt;code&gt;allowJs&lt;/code&gt;), TypeScript now recognizes declarations that use &lt;code&gt;Object.defineProperty&lt;/code&gt;. This means you&amp;rsquo;ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the &lt;code&gt;checkJs&lt;/code&gt; option or adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to the top of your file).</source>
          <target>&lt;code&gt;allowJs&lt;/code&gt;を使用してJavaScriptファイルに書き込む場合、TypeScriptは&lt;code&gt;Object.defineProperty&lt;/code&gt;を使用する宣言を認識するようになりました。これは、&lt;code&gt;checkJs&lt;/code&gt;オプションをオンにするか、ファイルの先頭に&lt;code&gt;//@ts check&lt;/code&gt;コメントを追加することによって、JavaScriptファイルの型チェックを有効にしたときに、より良い補完とより強力な型チェックが得られることを意味します。</target>
        </trans-unit>
        <trans-unit id="ec5f993452425d2ee4ab0f5de68ed85198028eec" translate="yes">
          <source>When you begin to use generics, you&amp;rsquo;ll notice that when you create generic functions like &lt;code&gt;identity&lt;/code&gt;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</source>
          <target>ジェネリックスを使い始めると、&lt;code&gt;identity&lt;/code&gt;のようなジェネリック関数を作成するときに、コンパイラは関数本体で一般的に型指定されたパラメータを正しく使用するように強制します。 つまり、これらのパラメータは、実際にはあらゆるタイプであるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="bb76a0dfbc0b927a30bc60fb3308eae1c0c32030" translate="yes">
          <source>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the &lt;em&gt;instance&lt;/em&gt; of the class.</source>
          <target>TypeScriptでクラスを宣言すると、実際には複数の宣言を同時に作成することになります。 1つ目は、クラスの&lt;em&gt;インスタンス&lt;/em&gt;のタイプです。</target>
        </trans-unit>
        <trans-unit id="cbca5cdf2d57a23f367d0a1514252e4f2c75c7b6" translate="yes">
          <source>When you reference a project, new things happen:</source>
          <target>プロジェクトを参照すると、新しいことが起こります。</target>
        </trans-unit>
        <trans-unit id="34a19e5b1b2f656dfeb0df790e074ddaa8c1d34a" translate="yes">
          <source>When you use the &lt;code&gt;this&lt;/code&gt; keyword outside of classes, it has the type &lt;code&gt;any&lt;/code&gt; by default. For instance, imagine a &lt;code&gt;Point&lt;/code&gt; class, and imagine a function that we wish to add as a method:</source>
          <target>&lt;code&gt;this&lt;/code&gt;キーワードをクラスの外部で使用すると、デフォルトで&lt;code&gt;any&lt;/code&gt;型になります。 たとえば、&lt;code&gt;Point&lt;/code&gt;クラスを考え、メソッドとして追加したい関数を考えます。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes">
          <source>Where:</source>
          <target>ここで</target>
        </trans-unit>
        <trans-unit id="962849684c80963bf61b9a409447ab660d400c45" translate="yes">
          <source>Which in turn can be imported using default imports:</source>
          <target>次に、デフォルトインポートを使用してインポートできます。</target>
        </trans-unit>
        <trans-unit id="cf6447c6242e379fc5cad3f436eb54be60f4dba3" translate="yes">
          <source>Which leads us to writing our first generic interface. Let&amp;rsquo;s take the object literal from the previous example and move it to an interface:</source>
          <target>そこで、最初の汎用インターフェースを作成します。 前の例のオブジェクトリテラルをインタフェースに移動する:</target>
        </trans-unit>
        <trans-unit id="70bd03441762cc2b325aef1bac1f313f2d0e16b5" translate="yes">
          <source>Which translates to:</source>
          <target>つまり、次のようになります。</target>
        </trans-unit>
        <trans-unit id="acfe760aa187d990362b3f4c61beb430484ea0d1" translate="yes">
          <source>Which would print this output to the console:</source>
          <target>この出力をコンソールに出力するのはどれですか。</target>
        </trans-unit>
        <trans-unit id="53ebf7ccbab25bb66042f79bfb51a8652406a52d" translate="yes">
          <source>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to &amp;ldquo;just work&amp;rdquo; TypeScript. Additionally, this approach for property declarations allows us to express common patterns like &lt;code&gt;defaultProps&lt;/code&gt; and &lt;code&gt;propTypes&lt;/code&gt; on React function components (formerly known as SFCs).</source>
          <target>多くの場合、ECMAScriptエクスポートはこの機能を提供するためのより良い方法ですが、この新しいサポートによって、このスタイルで書かれたコードを&amp;ldquo;just work&amp;rdquo;TypeScriptにすることができます。 さらに、プロパティ宣言のためのこのアプローチによって、&lt;code&gt;defaultProps&lt;/code&gt;や&lt;code&gt;propTypes&lt;/code&gt;のような共通のパターンをReact関数コンポーネント(以前はSFCと呼ばれていた)上で表現することができる。</target>
        </trans-unit>
        <trans-unit id="fad58bbb4ff5e3b9b95e4764b17888edf69eef4d" translate="yes">
          <source>While TypeScript 3.7 isn&amp;rsquo;t changing any existing emit by default, we&amp;rsquo;ve been rolling out changes incrementally to help users mitigate potential future breakage. We&amp;rsquo;ve provided a new flag called &lt;code&gt;useDefineForClassFields&lt;/code&gt; to enable this emit mode with some new checking logic.</source>
          <target>TypeScript3.7はデフォルトでは既存の発生源を変更しないが、将来的に発生する可能性のある破損をユーザが軽減できるように、段階的に変更を展開している。 &lt;code&gt;useDefineForClassFields&lt;/code&gt;と呼ばれる新しいフラグを提供し、新しいチェックロジックでこの放出モードを有効にしました。</target>
        </trans-unit>
        <trans-unit id="f56a592c618616410fc71f4bbabb49d78514f411" translate="yes">
          <source>While allowing people to randomly set &lt;code&gt;fullName&lt;/code&gt; directly is pretty handy, we may also want enforce some constraints when &lt;code&gt;fullName&lt;/code&gt; is set.</source>
          <target>&lt;code&gt;fullName&lt;/code&gt;をランダムに直接設定できるようにするのは非常に便利ですが、&lt;code&gt;fullName&lt;/code&gt;が設定されている場合は、いくつかの制約を適用することもできます。</target>
        </trans-unit>
        <trans-unit id="636d4d19d4405d30263f2aa95da0f2c2a734da53" translate="yes">
          <source>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let&amp;rsquo;s start with a basic example of two functions that differ only in their parameter lists:</source>
          <target>プリミティブ型とオブジェクト型を比較するのは比較的簡単ですが、互換性があると見なされる関数の種類については、もう少し詳しく説明します。 パラメータリストだけが異なる2つの関数の基本的な例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="03a5fd4e6d293c6d495eff753858affb70025397" translate="yes">
          <source>While it&amp;rsquo;s good practice to use &lt;code&gt;ReadonlyArray&lt;/code&gt; over &lt;code&gt;Array&lt;/code&gt; when no mutation is intended, it&amp;rsquo;s often been a pain given that arrays have a nicer syntax. Specifically, &lt;code&gt;number[]&lt;/code&gt; is a shorthand version of &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;, just as &lt;code&gt;Date[]&lt;/code&gt; is a shorthand for &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;.</source>
          <target>変更が意図されていない場合は、&lt;code&gt;ReadonlyArray&lt;/code&gt;を&lt;code&gt;Array&lt;/code&gt;より優先して使用することをお勧めしますが、&amp;rsquo;は、配列の構文がより優れていることを考えると、多くの場合面倒です。 具体的には、&lt;code&gt;number[]&lt;/code&gt;は&lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;の短縮形です。&lt;code&gt;Date[]&lt;/code&gt;は&lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;の短縮形です。</target>
        </trans-unit>
        <trans-unit id="2c74aaa3335f7bff7bf6990f82abec0b22352a01" translate="yes">
          <source>While not a breakage per se, opting in to the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag can cause breakage when:</source>
          <target>破損自体はありませんが、&lt;code&gt;useDefineForClassFields&lt;/code&gt;フラグを選択すると、次の場合に破損が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ebbe87035da271030af0d806842f81f2cc35cc3b" translate="yes">
          <source>While not strictly a language change, nightly builds are now available by installing with the following command:</source>
          <target>厳密には言語の変更ではありませんが、次のコマンドを使用してをインストールすることで、夜間ビルドを使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3360869251a9b9ea8953b44e203398f6f81cb993" translate="yes">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href="#enums-at-runtime"&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target>文字列列挙は自動的に増加する動作をしませんが、文字列列挙は&amp;ldquo;serialize&amp;rdquo;という利点があります。 言い換えれば、デバッグ中に数値のenumのランタイム値を読み込まなければならない場合、その値はしばしば不透明であり、(&lt;a href="#enums at runtime"&gt;reverse mapping&lt;/a&gt;はしばしば助けになるが)有用な意味を伝達しない。string enumは、enumメンバ自身の名前とは無関係に、コードの実行時に意味のある読みやすい値を与えることができる。</target>
        </trans-unit>
        <trans-unit id="f4c063d2ee2675e04f30864acccf31e9c245c672" translate="yes">
          <source>While string index signatures are a powerful way to describe the &amp;ldquo;dictionary&amp;rdquo; pattern, they also enforce that all properties match their return type. This is because a string index declares that &lt;code&gt;obj.property&lt;/code&gt; is also available as &lt;code&gt;obj["property"]&lt;/code&gt;. In the following example, &lt;code&gt;name&lt;/code&gt;&amp;rsquo;s type does not match the string index&amp;rsquo;s type, and the type checker gives an error:</source>
          <target>文字列インデックスシグネチャは&amp;ldquo;辞書&amp;rdquo;パターンを記述する強力な方法ですが、すべてのプロパティが戻り値の型に一致するように強制します。 これは、文字列インデックスによって、&lt;code&gt;obj.property&lt;/code&gt;が&lt;code&gt;obj["property"]&lt;/code&gt;としても使用可能であることが宣言されているためです。次の例では、&lt;code&gt;name&lt;/code&gt;&amp;rsquo;s typeが文字列インデックス&amp;rsquo;s typeと一致しないため、型チェッカーはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="205fbdc2b0eb96d4c083fa10d1cf873197618502" translate="yes">
          <source>While using &lt;code&gt;any&lt;/code&gt; is certainly generic in that it will cause the function to accept any and all types for the type of &lt;code&gt;arg&lt;/code&gt;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</source>
          <target>&lt;code&gt;any&lt;/code&gt;を使用すると、&lt;code&gt;arg&lt;/code&gt;の型に対してあらゆる型を関数が受け入れるようになるという点では確かに汎用的ですが、関数が返す型に関する情報は実際には失われています。 数値を渡すと、どんな型でも返すことができるという情報しかありません。</target>
        </trans-unit>
        <trans-unit id="3773d499a43f196d119753de15012adfe413581f" translate="yes">
          <source>While you might imagine close interaction between &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;bigint&lt;/code&gt;, the two are separate domains.</source>
          <target>&lt;code&gt;number&lt;/code&gt;と&lt;code&gt;bigint&lt;/code&gt;の間の密接な相互作用を想像することもできますが、この2つのドメインは別々のドメインです。</target>
        </trans-unit>
        <trans-unit id="7942bdf53c9b517b254a399642caadffcd723ac5" translate="yes">
          <source>Why does a module in the exclude list still get picked up by the compiler?</source>
          <target>除外リスト内のモジュールがコンパイラによって選択されるのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="dd7392a9f697967405bb99a3337ee2df7f8bb374" translate="yes">
          <source>Wildcard character in module names</source>
          <target>モジュール名のワイルドカード文字</target>
        </trans-unit>
        <trans-unit id="90ff022ca86ce297643ad53057127508fda59a21" translate="yes">
          <source>Wildcard module declarations</source>
          <target>ワイルドカードモジュール宣言</target>
        </trans-unit>
        <trans-unit id="e1deac0ee95462765acc0e4d19e587e5b367dac8" translate="yes">
          <source>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as &lt;code&gt;any&lt;/code&gt;.</source>
          <target>ワイルドカード・モジュール名は、型指定されていないコード・ベースからマイグレーションする場合に、さらに便利です。 Shorthand ambientモジュール宣言と組み合わせると、一連のモジュールを&lt;code&gt;any&lt;/code&gt;として簡単に宣言できます。</target>
        </trans-unit>
        <trans-unit id="294ac8947e55f645c50e17c1f027a18712e8f38f" translate="yes">
          <source>Will generate the following JavaScript output:</source>
          <target>次のJavaScript出力が生成されます。</target>
        </trans-unit>
        <trans-unit id="49659e5a07d9ec9ddbc5ea2cded9dfed86235252" translate="yes">
          <source>Will generate:</source>
          <target>次の情報が生成されます。</target>
        </trans-unit>
        <trans-unit id="74eea0f1c70b52371bc0816bb556d0f8780652ce" translate="yes">
          <source>Will produce a &lt;code&gt;.d.ts&lt;/code&gt; file like</source>
          <target>次のような&lt;code&gt;.d.ts&lt;/code&gt;ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="8dc5830cdd248d481961de84dd0f5250619d9bd8" translate="yes">
          <source>Will result in assigning the name &lt;code&gt;NamedModule&lt;/code&gt; to the module as part of calling the AMD &lt;code&gt;define&lt;/code&gt;:</source>
          <target>AMD&lt;code&gt;define&lt;/code&gt;を呼び出す際に、モジュールに&lt;code&gt;NamedModule&lt;/code&gt;という名前が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="13740d4f0b7aedad3ff699e83aa212feeaefbb89" translate="yes">
          <source>With &lt;code&gt;--downlevelIteration&lt;/code&gt;, the compiler uses new type check and emit behavior that attempts to call a &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</source>
          <target>&lt;code&gt;--downlevelIteration&lt;/code&gt;を使用すると、コンパイラは新しい型チェックとエミットの動作を使用して、反復されるオブジェクトが見つかった場合はそのオブジェクトに対して&lt;code&gt;[Symbol.iterator]()&lt;/code&gt;メソッドを呼び出し、見つからなかった場合はそのオブジェクトに対して合成配列イテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="0baf96b645c93694808d46132810c65e4ff0d180" translate="yes">
          <source>With &lt;code&gt;--esModuleInterop&lt;/code&gt; two new helpers are generated &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; for import &lt;code&gt;*&lt;/code&gt; and import &lt;code&gt;default&lt;/code&gt; respectively. For instance input like:</source>
          <target>&lt;code&gt;--esModuleInterop&lt;/code&gt;では、import&lt;code&gt;*&lt;/code&gt;とimport&lt;code&gt;default&lt;/code&gt;にそれぞれ&lt;code&gt;__importStar&lt;/code&gt;と&lt;code&gt;_importDefault&lt;/code&gt;の2つの新しいヘルパーが生成されます。 たとえば、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="3da68912666fd5861031d156bf5a2c7082eb8729" translate="yes">
          <source>With &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;, this example will trigger an error:</source>
          <target>&lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;を指定すると、次の例でエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f2e90c030cc7f4b83e2a77c542e137b8a0ccca5d" translate="yes">
          <source>With &lt;code&gt;--strictNullChecks&lt;/code&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target>&lt;code&gt;--strictNullChecks&lt;/code&gt;を指定すると、オプションのパラメータによって&lt;code&gt;undefined&lt;/code&gt;が自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="32a499399a274aac8c9b26572f194ee6506912c8" translate="yes">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. You will also get an error if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target>&lt;code&gt;@constructor&lt;/code&gt;では、&lt;code&gt;this&lt;/code&gt;がコンストラクタ関数&lt;code&gt;C&lt;/code&gt;内でチェックされるため、&lt;code&gt;initialize&lt;/code&gt;メソッドの候補が表示され、数値を渡すとエラーが発生します。 また、&lt;code&gt;C&lt;/code&gt;を作成する代わりに呼び出すと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="b1ea5d91d6887a555bb6f2794a07c5714e99ed42" translate="yes">
          <source>With &lt;code&gt;import&lt;/code&gt; types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</source>
          <target>&lt;code&gt;import&lt;/code&gt;型が使用可能な場合、宣言ファイル生成時に報告される可視性エラーの多くは、入力を変更することなくコンパイラで処理できます。</target>
        </trans-unit>
        <trans-unit id="f84d42cb295076793894c8acadb047e99a4e746a" translate="yes">
          <source>With &lt;code&gt;object&lt;/code&gt; type, APIs like &lt;code&gt;Object.create&lt;/code&gt; can be better represented. For example:</source>
          <target>&lt;code&gt;object&lt;/code&gt;型を使用すると、&lt;code&gt;Object.create&lt;/code&gt;のようなAPIの表現が向上します。 例:</target>
        </trans-unit>
        <trans-unit id="5fa847821456a4401d0546fcc0d18f6208406246" translate="yes">
          <source>With &lt;code&gt;this&lt;/code&gt; annotated, you make it explicit that &lt;code&gt;onClickBad&lt;/code&gt; must be called on an instance of &lt;code&gt;Handler&lt;/code&gt;. Then TypeScript will detect that &lt;code&gt;addClickListener&lt;/code&gt; requires a function that has &lt;code&gt;this: void&lt;/code&gt;. To fix the error, change the type of &lt;code&gt;this&lt;/code&gt;:</source>
          <target>&lt;code&gt;this&lt;/code&gt;アノテーションを付けて、&lt;code&gt;onClickBad&lt;/code&gt;が&lt;code&gt;Handler&lt;/code&gt;のインスタンスで呼び出される必要があることを明示します。次に、TypeScriptは&lt;code&gt;addClickListener&lt;/code&gt;が&lt;code&gt;this:void&lt;/code&gt;を持つ関数を必要とすることを検出します。エラーを修正するには、&lt;code&gt;this&lt;/code&gt;の型を変更します。</target>
        </trans-unit>
        <trans-unit id="275d348200c6c9320565561ab80694a7f189a460" translate="yes">
          <source>With &lt;code&gt;var&lt;/code&gt; declarations, we mentioned that it didn&amp;rsquo;t matter how many times you declared your variables; you just got one.</source>
          <target>&lt;code&gt;var&lt;/code&gt;宣言では、変数を何回宣言しても、変数は1つしかありません。</target>
        </trans-unit>
        <trans-unit id="c9b5a6af6e81107e965d92874d8f98c54b8d5351" translate="yes">
          <source>With ES6&amp;rsquo;s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: &lt;code&gt;"\u{20bb7}"&lt;/code&gt;. TypeScript will emit the string in ES3/ES5 as &lt;code&gt;"\uD842\uDFB7"&lt;/code&gt;.</source>
          <target>ES6&amp;rsquo;のコードポイントエスケープを使用すると、&lt;code&gt;"\u{20bb7}"&lt;/code&gt;という1つのエスケープで、文字列とテンプレート文字列内のその文字を正確に表すことができます。TypeScriptは、ES3/ES5の文字列を&lt;code&gt;"\uD842\uDFB7"&lt;/code&gt;として出力します。</target>
        </trans-unit>
        <trans-unit id="a3fe0d7c3c1bcf18bd50d0141170db310dc43d9e" translate="yes">
          <source>With TypeScript 1.6, type aliases can be generic. For example:</source>
          <target>TypeScript1.6では、型別名を汎用にできます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="460f7c766e92b496f73d02d4ccf0cc4d7ee440b6" translate="yes">
          <source>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as &lt;a href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification"&gt;F-Bounded Polymorphism&lt;/a&gt;.</source>
          <target>TypeScript1.8では、型パラメータ制約が同じ型パラメータリストから型パラメータを参照することが可能になる。 これまではエラーでした。 この機能は通常、&lt;a href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification"&gt;F Bounded Polymorphism&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="10bf274b692b3bbc5a7692bb92ffc8f07852abb4" translate="yes">
          <source>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</source>
          <target>TypeScript1.8では、JSXタグがVisual Studio2015で分類され、カラー化される。</target>
        </trans-unit>
        <trans-unit id="c62a9b4ded80d831595f6cf41c707a66d7b472df" translate="yes">
          <source>With TypeScript 1.8, we&amp;rsquo;ve introduced string literal types. These types are written the same way string literals are, but in type positions.</source>
          <target>TypeScript1.8では、文字列リテラル型を導入しました。 これらの型は文字列リテラルと同じように記述されますが、型位置にあります。</target>
        </trans-unit>
        <trans-unit id="cafdb66c7fc578df947b8db9b1207f3133582261" translate="yes">
          <source>With TypeScript 2.0, the compiler will look up definition of &lt;code&gt;"moduleA.js"&lt;/code&gt; in &lt;code&gt;./moduleA.ts&lt;/code&gt; or &lt;code&gt;./moduleA.d.t&lt;/code&gt;.</source>
          <target>TypeScript2.0では、コンパイラは&lt;code&gt;./moduleA.ts&lt;/code&gt;または&lt;code&gt;./moduleA.d.t&lt;/code&gt;内の&lt;code&gt;"moduleA.js"&lt;/code&gt;の定義を検索します。</target>
        </trans-unit>
        <trans-unit id="d4f9f7cdd4003c7ab1f53ac08b77e405631b7232" translate="yes">
          <source>With TypeScript 2.1, instead of just choosing &lt;code&gt;any&lt;/code&gt;, TypeScript will infer types based on what you end up assigning later on.</source>
          <target>TypeScript2.1では、単に&lt;code&gt;any&lt;/code&gt;を選択するのではなく、TypeScriptは後で割り当てたものに基づいて型を推測する。</target>
        </trans-unit>
        <trans-unit id="9277e32824b441ad62cb76d21644b7bd58f69e2f" translate="yes">
          <source>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as &lt;code&gt;declare module "foo" { ... }&lt;/code&gt; or &lt;code&gt;node_modules/@types/foo&lt;/code&gt;) still takes priority if it exists.</source>
          <target>TypeScript2.1では、型宣言を必要とせずにJavaScriptモジュールをインポートできます。 型宣言(&lt;code&gt;declare module"foo"{.}&lt;/code&gt;や&lt;code&gt;node_modules/@types/foo&lt;/code&gt;など)が存在する場合は、優先されます。</target>
        </trans-unit>
        <trans-unit id="fbf94ecb57bb0f01e4f682c5fcfc23891843f05c" translate="yes">
          <source>With TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; applied to an intersection type is transformed to a union of &lt;code&gt;keyof&lt;/code&gt; applied to each intersection constituent. In other words, types of the form &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; are transformed to be &lt;code&gt;keyof A | keyof B&lt;/code&gt;. This change should address inconsistencies with inference from &lt;code&gt;keyof&lt;/code&gt; expressions.</source>
          <target>TypeScript2.8&lt;code&gt;keyof&lt;/code&gt;を交差型に適用すると、各交差構成要素に適用される&lt;code&gt;keyof&lt;/code&gt;の和集合に変換されます。 つまり、&lt;code&gt;keyof(A&amp;amp;B)&lt;/code&gt;という形式の型は、&lt;code&gt;keyof(A&amp;amp;B)&lt;/code&gt;の&lt;code&gt;keyof A keyof B&lt;/code&gt;に変換されます。この変更は、&lt;code&gt;keyof&lt;/code&gt;式からの推論との不一致に対処するものです。</target>
        </trans-unit>
        <trans-unit id="799099f20671837db4b655a12286097f02ebcd18" translate="yes">
          <source>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</source>
          <target>TypeScript2.9ではエラーは報告されず、生成されたファイルは以下のようになる。</target>
        </trans-unit>
        <trans-unit id="d61e7a4d8ea1ab6a29d0ab09e04c9367f5313f2f" translate="yes">
          <source>With TypeScript being a superset of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target>TypeScriptはJavaScriptのスーパーセットであるため、言語は当然&lt;code&gt;let&lt;/code&gt;と&lt;code&gt;const&lt;/code&gt;をサポートします。ここでは、これらの新しい宣言と、それらが&lt;code&gt;var&lt;/code&gt;よりも好ましい理由について、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="82f558e3e809cb29cfb2ac66cc2514576d7422f4" translate="yes">
          <source>With definite assignment assertions, we can assert that &lt;code&gt;x&lt;/code&gt; is really assigned by appending an &lt;code&gt;!&lt;/code&gt; to its declaration:</source>
          <target>確定代入アサーションを使用すると、宣言に&lt;code&gt;!&lt;/code&gt;を追加することで、&lt;code&gt;x&lt;/code&gt;が実際に代入されていることをアサートできます。</target>
        </trans-unit>
        <trans-unit id="1b9ea4bd3d43c0f24f8d1235be222ef088964840" translate="yes">
          <source>With generic parameter defaults we can reduce it to:</source>
          <target>汎用パラメータのデフォルト値を使用すると、次のように減らすことができます。</target>
        </trans-unit>
        <trans-unit id="285525d91c532d67502baa5d535e42948f1fec46" translate="yes">
          <source>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</source>
          <target>インデックス型を使用すると、動的プロパティ名を使用するコードをコンパイラでチェックできます。 たとえば、一般的なJavaScriptパターンでは、オブジェクトからプロパティのサブセットを選択します。</target>
        </trans-unit>
        <trans-unit id="16dcd92f3ae6feec4cfbb7198eb7027566939a02" translate="yes">
          <source>With more &lt;code&gt;tsconfig.json&lt;/code&gt; files, you&amp;rsquo;ll usually want to use &lt;a href="tsconfig-json"&gt;Configuration file inheritance&lt;/a&gt; to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.</source>
          <target>多くの&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルを使用する場合、通常は&lt;a href="tsconfig json"&gt;Configuration file inheritance&lt;/a&gt;を使用して、共通のコンパイラオプションを一元化します。 これにより、複数のファイルを編集しなくても、1つのファイルの設定を変更できます。</target>
        </trans-unit>
        <trans-unit id="dc980dcbd81da3823a44dd1638ddc07a1ed0b4b4" translate="yes">
          <source>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a &lt;a href="https://github.com/tc39/proposal-decorators"&gt;stage 2 proposal&lt;/a&gt; for JavaScript and are available as an experimental feature of TypeScript.</source>
          <target>TypeScriptとES6にClassesが導入されたことで、クラスやクラスメンバのアノテーションや変更をサポートするための追加機能を必要とするシナリオがある。 デコレータは、アノテーションとメタプログラミング構文の両方をクラス宣言とメンバーに追加する方法を提供します。 デコレータは、JavaScriptの&lt;a href="https://github.com/tc39/proposal-decorators"&gt;第2段階の提案&lt;/a&gt;であり、TypeScriptの実験的な機能として利用できます。</target>
        </trans-unit>
        <trans-unit id="f8c7c6883f9c76d8e00e3e2c0ffe4b6a8b55fa95" translate="yes">
          <source>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</source>
          <target>これらの機能により、関数とそのパラメータリストを変換する多数の高階関数を強力に型指定することが可能になります。</target>
        </trans-unit>
        <trans-unit id="433e4f23f467e7ae0dc8cfdd04d371137cd886c1" translate="yes">
          <source>With this change, the overloads now give us type checked calls to the &lt;code&gt;pickCard&lt;/code&gt; function.</source>
          <target>この変更により、オーバーロードによって&lt;code&gt;pickCard&lt;/code&gt;関数への型チェック呼び出しが可能になりました。</target>
        </trans-unit>
        <trans-unit id="50288405a714a4c057a990453fc548fab19c0a86" translate="yes">
          <source>With union types able to represent a wide range of type scenarios, we&amp;rsquo;ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</source>
          <target>ユニオン型はさまざまな型シナリオを表現できるため、ある種の総称呼び出しの厳密さを改善することにしました。 以前は、このようなコードは(驚くべきことに)エラーなしにコンパイルされていました。</target>
        </trans-unit>
        <trans-unit id="4aaf334cc02fe3036ee03973d99bc9627c8d8c34" translate="yes">
          <source>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</source>
          <target>ユニオン型を使用すると、関数宣言サイトと呼び出しサイトの両方で必要な動作を指定できます。</target>
        </trans-unit>
        <trans-unit id="1faa6ed78c77561690bfff2329835e7f699fad40" translate="yes">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method), but the &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Location&lt;/code&gt; classes are not.</source>
          <target>&lt;code&gt;Control&lt;/code&gt;クラス内では、&lt;code&gt;SelectableControl&lt;/code&gt;のインスタンスを介して&lt;code&gt;state&lt;/code&gt;プライベートメンバにアクセスすることができます。 事実上、&lt;code&gt;SelectableControl&lt;/code&gt;は、&lt;code&gt;select&lt;/code&gt;メソッドを持つことが知られている&lt;code&gt;Control&lt;/code&gt;のように動作する。 &lt;code&gt;Button&lt;/code&gt;クラスと&lt;code&gt;TextBox&lt;/code&gt;クラスは、&lt;code&gt;SelectableControl&lt;/code&gt;のサブタイプです(どちらも&lt;code&gt;Control&lt;/code&gt;を継承し、&lt;code&gt;select&lt;/code&gt;メソッドを持っているため)。しかし、&lt;code&gt;Image&lt;/code&gt;と&lt;code&gt;Location&lt;/code&gt;クラスはそうではありません。</target>
        </trans-unit>
        <trans-unit id="11991f5f3539f8365b2755a33096a790d376c466" translate="yes">
          <source>Within the &lt;code&gt;extends&lt;/code&gt; clause of a conditional type, it is now possible to have &lt;code&gt;infer&lt;/code&gt; declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple &lt;code&gt;infer&lt;/code&gt; locations for the same type variable.</source>
          <target>条件付き型の&lt;code&gt;extends&lt;/code&gt;節内で、推論される型変数を導入する&lt;code&gt;infer&lt;/code&gt;宣言を持つことが可能になりました。 そのような推論された型変数は、条件型の真の分岐で参照されることがある。 同じ型変数に対して複数の&lt;code&gt;infer&lt;/code&gt;位置を持つことができる。</target>
        </trans-unit>
        <trans-unit id="025d407dde53ca8d56d3a7b67f8687df35d8b119" translate="yes">
          <source>Within the same block duplicate definitions are still disallowed.</source>
          <target>同じブロック内では、重複する定義は許可されません。</target>
        </trans-unit>
        <trans-unit id="244687c671b9bf5c3bf00c75ac23daf9254dabd2" translate="yes">
          <source>Without &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;ScientificCalculator&lt;/code&gt; would not have been able to extend &lt;code&gt;BasicCalculator&lt;/code&gt; and keep the fluent interface. &lt;code&gt;multiply&lt;/code&gt; would have returned &lt;code&gt;BasicCalculator&lt;/code&gt;, which doesn&amp;rsquo;t have the &lt;code&gt;sin&lt;/code&gt; method. However, with &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;multiply&lt;/code&gt; returns &lt;code&gt;this&lt;/code&gt;, which is &lt;code&gt;ScientificCalculator&lt;/code&gt; here.</source>
          <target>&lt;code&gt;この&lt;/code&gt;型がなければ、&lt;code&gt;ScientificCalculator&lt;/code&gt;は&lt;code&gt;BasicCalculator&lt;/code&gt;を拡張することも、流れるようなインターフェースを維持することもできなかったでしょう。 &lt;code&gt;multiply&lt;/code&gt;は、&lt;code&gt;sin&lt;/code&gt;メソッドを持たない&lt;code&gt;BasicCalculator&lt;/code&gt;を返します。 しかし、&lt;code&gt;この&lt;/code&gt;型では、&lt;code&gt;multiply&lt;/code&gt;は&lt;code&gt;this&lt;/code&gt;を返します。これは&lt;code&gt;ScientificCalculator&lt;/code&gt;です。</target>
        </trans-unit>
        <trans-unit id="4e062851d9b41c2fc52e761a5a5db277213a8a79" translate="yes">
          <source>Without generics, we would either have to give the identity function a specific type:</source>
          <target>ジェネリックがなければ、ID関数に特定の型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2f67c21f22ceab8ce26ba774a06869c3e5ea9d49" translate="yes">
          <source>Working with Generic Type Variables</source>
          <target>ジェネリック型変数の操作</target>
        </trans-unit>
        <trans-unit id="5dec7390553f0c8e11febdec62abeb23d870ba14" translate="yes">
          <source>Working with Other JavaScript Libraries</source>
          <target>他のJavaScriptライブラリの操作</target>
        </trans-unit>
        <trans-unit id="944e87083d9fc0d208f24e3ca6004e001d6ee8c0" translate="yes">
          <source>Write a HTML page</source>
          <target>HTMLページを作成する</target>
        </trans-unit>
        <trans-unit id="9a3206c5e21cfc9c171ea878cfc1acee74565cd8" translate="yes">
          <source>Write a simple example</source>
          <target>簡単な例を書く</target>
        </trans-unit>
        <trans-unit id="e885a108400a007a39fa103119566542fbe5da72" translate="yes">
          <source>Write some code</source>
          <target>コードを書く</target>
        </trans-unit>
        <trans-unit id="efab40cfd729fdef6a3321a502f603a5fd3d1efd" translate="yes">
          <source>Write-only references now flagged as unused</source>
          <target>書き込み専用参照に未使用のフラグが付けられました</target>
        </trans-unit>
        <trans-unit id="1f09dbf6607d2b3a3fef434b06897c0d44094e34" translate="yes">
          <source>Writes &lt;code&gt;"use strict";&lt;/code&gt; directive atop every generated file.</source>
          <target>生成されたすべてのファイルに&lt;code&gt;"use strict";&lt;/code&gt;ディレクティブを書き込みます。</target>
        </trans-unit>
        <trans-unit id="caefe3ddb12a11eef5e5aa559be74af44b08a512" translate="yes">
          <source>Writing a Configuration File</source>
          <target>構成ファイルの書き込み</target>
        </trans-unit>
        <trans-unit id="8d3bf80dd76a472762dc04013242f325f5d4630a" translate="yes">
          <source>Writing the function type</source>
          <target>関数型の記述</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="124e1188da963d3aaab4e295c7a108fbd2a41dd4" translate="yes">
          <source>You &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see:</source>
          <target>次の項目が表示されません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0826b2d3de77311d09a836d3625c330fde392d4" translate="yes">
          <source>You also need to include &lt;code&gt;esnext&lt;/code&gt; in your &lt;code&gt;--lib&lt;/code&gt; option, to get the &lt;code&gt;AsyncIterator&lt;/code&gt; declaration if you do not already have it.</source>
          <target>また、&lt;code&gt;esnext&lt;/code&gt;を&lt;code&gt;--lib&lt;/code&gt;オプションに含めて、&lt;code&gt;AsyncIterator&lt;/code&gt;宣言を取得する必要があります(まだ取得していない場合)。</target>
        </trans-unit>
        <trans-unit id="62d178984134105b099386ca1a8bdc43d115ba87" translate="yes">
          <source>You can &lt;a href="https://github.com/Microsoft/TypeScript/pull/29435"&gt;see more details in the pull request&lt;/a&gt;.</source>
          <target>プル要求の詳細を&lt;a href="https://github.com/Microsoft/TypeScript/pull/29435"&gt;参照できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fc0ff3454e62e27b1d1616762b98ba9e340784f" translate="yes">
          <source>You can &lt;a href="https://github.com/microsoft/TypeScript/pull/32028"&gt;read up more about this change by reading up on its pull request&lt;/a&gt;.</source>
          <target>この変更に関する詳細については、&lt;a href="https://github.com/microsoft/TypeScript/pull/32028"&gt;プルリクエスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f2d37b1f71e5cef3cd269ee2fede52081b3627c" translate="yes">
          <source>You can also add declarations to the global scope from inside a module:</source>
          <target>モジュール内からグローバルスコープに宣言を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="aa5e7508cbf31286f90d3fa92778943caff41bbb" translate="yes">
          <source>You can also create nested namespaces in one declaration:</source>
          <target>ネストされた名前空間を1つの宣言で作成することもできます。</target>
        </trans-unit>
        <trans-unit id="c9e0636992c973f4dd8a12b1aab83b4e3dc21c83" translate="yes">
          <source>You can also describe methods in an interface that are implemented in the class, as we do with &lt;code&gt;setTime&lt;/code&gt; in the below example:</source>
          <target>また、次の例の&lt;code&gt;setTime&lt;/code&gt;と同様に、クラスに実装されたインタフェース内のメソッドを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="10881a4ac29a88d1e8e385325bacc892d71cbc57" translate="yes">
          <source>You can also destructure objects:</source>
          <target>オブジェクトを分解することもできます。</target>
        </trans-unit>
        <trans-unit id="f263658c8957170383fc6acd098a9e253a17a6eb" translate="yes">
          <source>You can also enable prepending the output of a dependency using the &lt;code&gt;prepend&lt;/code&gt; option in a reference:</source>
          <target>参照の&lt;code&gt;prepend&lt;/code&gt;オプションを使用して、依存関係の出力をプリペンディングすることもできます。</target>
        </trans-unit>
        <trans-unit id="7a3ee9c0b30719b4ec3010d9b67f41513948956a" translate="yes">
          <source>You can also give different names to properties:</source>
          <target>プロパティに別の名前を付けることもできます。</target>
        </trans-unit>
        <trans-unit id="fa56c11bed0da0fe19acfcb08f266a5ef3e86db8" translate="yes">
          <source>You can also import declarations from other files using import types. This syntax is Typescript-specific and differs from the JSDoc standard:</source>
          <target>インポートタイプを使用して、他のファイルから宣言をインポートすることもできます。 この構文はTypescript固有であり、JSDoc標準とは異なります。</target>
        </trans-unit>
        <trans-unit id="dca8a7aa37da66a7e0661bda41e830a52a5189ae" translate="yes">
          <source>You can also override existing properties and add new ones:</source>
          <target>既存のプロパティをオーバーライドして新しいプロパティを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="e783edc2ccbd9e24ba2f903e758def00265edb8b" translate="yes">
          <source>You can also run into errors with &lt;code&gt;this&lt;/code&gt; in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. With some work you can use &lt;code&gt;this&lt;/code&gt; parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with &lt;code&gt;this&lt;/code&gt;:</source>
          <target>また、後で関数を呼び出すライブラリに関数を渡すと、コールバックの&lt;code&gt;this&lt;/code&gt;でエラーが発生することがあります。 コールバックを呼び出すライブラリは通常の関数と同様にコールバックを呼び出すため、&lt;code&gt;this&lt;/code&gt;は&lt;code&gt;undefined&lt;/code&gt;になります。いくつかの作業では、&lt;code&gt;this&lt;/code&gt;パラメータを使用してコールバックのエラーを防ぐこともできます。 まず、ライブラリの作成者はコールバックタイプに&lt;code&gt;this&lt;/code&gt;という注釈を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="8bc617eb0b3c708d101d575cea082665b2e4c486" translate="yes">
          <source>You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:</source>
          <target>タイプパラメータ名の前にタイプ拘束を指定することもできます。 リストの最初のタイプパラメータのみが拘束されます。</target>
        </trans-unit>
        <trans-unit id="d00d3142af394bb2294c1c64058dcebe2e496a01" translate="yes">
          <source>You can also specify object literal types. For example, an object with properties &amp;lsquo;a&amp;rsquo; (string) and &amp;lsquo;b&amp;rsquo; (number) uses the following syntax:</source>
          <target>オブジェクトリテラル型を指定することもできます。 たとえば、プロパティ&amp;lsquo;a&amp;rsquo;(string)と&amp;lsquo;b&amp;rsquo;(number)を持つオブジェクトは、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="fe8328cdac7d502c96b86354aece870f05fd04b3" translate="yes">
          <source>You can also spread objects:</source>
          <target>オブジェクトをスプレッドすることもできます。</target>
        </trans-unit>
        <trans-unit id="1908bbe93e9847a90199e01d70ec2bf4ba120262" translate="yes">
          <source>You can also update your IDE to use the nightly drop. First you will need to install the package through npm. You can either install the npm package globally or to a local &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target>ID Eを更新してnightly dropを使用することもできます。 まずnpmを使ってパッケージをインストールする必要があります。 npmパッケージは、グローバルにインストールすることも、ローカルの&lt;code&gt;node_modules&lt;/code&gt;フォルダーにインストールすることもできます。</target>
        </trans-unit>
        <trans-unit id="2fd769df0df5d6f0aa6315e5bbbcccdf2351c2f6" translate="yes">
          <source>You can also use &lt;em&gt;template strings&lt;/em&gt;, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (&lt;code&gt;`&lt;/code&gt;) character, and embedded expressions are of the form &lt;code&gt;${ expr }&lt;/code&gt;.</source>
          <target>&lt;em&gt;テンプレート文字列&lt;/em&gt;を使用することもできます。テンプレート文字列は複数行にまたがることができ、式を埋め込むことができます。 これらの文字列はbacktick/backquote(&lt;code&gt;`&lt;/code&gt;)文字で囲まれ、埋め込み式は&lt;code&gt;${expr}&lt;/code&gt;という形式になります。</target>
        </trans-unit>
        <trans-unit id="f55dd36012d4dbcf4dacc5832f2294fe2f575c7c" translate="yes">
          <source>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</source>
          <target>オブジェクトリテラルをprototypeプロパティに直接割り当てることができます。 個々のプロトタイプ割り当ても機能します。</target>
        </trans-unit>
        <trans-unit id="8c16422cd5326d69a5eb84cd5f6aae392dfed484" translate="yes">
          <source>You can call the function &lt;code&gt;greet&lt;/code&gt; with a string to show a greeting to the user.</source>
          <target>関数&lt;code&gt;greet&lt;/code&gt;を文字列で呼び出して、ユーザに挨拶を示すことができます。</target>
        </trans-unit>
        <trans-unit id="1a7ff571453a3f2b2057590cf96aa4493691af9b" translate="yes">
          <source>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called &lt;em&gt;discriminated unions&lt;/em&gt;, also known as &lt;em&gt;tagged unions&lt;/em&gt; or &lt;em&gt;algebraic data types&lt;/em&gt;. Discriminated unions are useful in functional programming. Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</source>
          <target>シングルトン・タイプ、ユニオン・タイプ、タイプ・ガード、およびタイプ別名を組み合せて、&lt;em&gt;タグ付きユニオン&lt;/em&gt;または&lt;em&gt;代数データ型&lt;/em&gt;とも呼ばれる&lt;em&gt;discriminated union&lt;/em&gt;という高度なパターンを作成できます。 識別された共用体は、関数型プログラミングにおいて有用である。 一部の言語では自動的に共用体を区別しますが、TypeScriptは現在のJavaScriptパターンに基づいています。 材料は3種類</target>
        </trans-unit>
        <trans-unit id="6d357850b01dac1eeac6457b17d7ca5319c972ef" translate="yes">
          <source>You can construct a &lt;code&gt;Point&lt;/code&gt; by assigning an object literal. After the assignment, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can&amp;rsquo;t be changed.</source>
          <target>&lt;code&gt;Point&lt;/code&gt;は、オブジェクトリテラルを割り当てることで作成できます。 代入後、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;は変更できません。</target>
        </trans-unit>
        <trans-unit id="4fb6b2a81bd2b7aaa5985f5e53a25640c10196cd" translate="yes">
          <source>You can create a greeter by instantiating the &lt;code&gt;Greeter&lt;/code&gt; object, or create a customized greeter by extending from it.</source>
          <target>&lt;code&gt;Greeter&lt;/code&gt;オブジェクトをインスタンス化することによってgreeterを作成するか、それを拡張してカスタマイズされたgreeterを作成することができます。</target>
        </trans-unit>
        <trans-unit id="75665cb8837cc0487308ee22852413c93f1fc259" translate="yes">
          <source>You can create a variable for the remaining items in a list using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target>構文&lt;code&gt;.&lt;/code&gt;を使用して、リスト内の残りの項目の変数を作成できます。</target>
        </trans-unit>
        <trans-unit id="8460f1444f4aa17633ac5c787a8314796932f6a5" translate="yes">
          <source>You can create a variable for the remaining items in an object using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target>構文&lt;code&gt;.&lt;/code&gt;を使用して、オブジェクト内の残りのアイテムの変数を作成できます。</target>
        </trans-unit>
        <trans-unit id="671e7dc200d0c80a25936e430c7090352f3d72ae" translate="yes">
          <source>You can declare a type parameter that is constrained by another type parameter. For example, here we&amp;rsquo;d like to get a property from an object given its name. We&amp;rsquo;d like to ensure that we&amp;rsquo;re not accidentally grabbing a property that does not exist on the &lt;code&gt;obj&lt;/code&gt;, so we&amp;rsquo;ll place a constraint between the two types:</source>
          <target>別のタイプパラメータによって拘束されるタイプパラメータを宣言できます。 たとえば、ここでは、名前が指定されたオブジェクトからプロパティを取得します。 &lt;code&gt;obj&lt;/code&gt;に存在しないプロパティを誤って取得しないようにしたいので、2つのタイプの間に制約を設定します。</target>
        </trans-unit>
        <trans-unit id="f192a3654a48e7ea0a0cc0a370781ac7a446e607" translate="yes">
          <source>You can declare generic types with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target>&lt;code&gt;@template&lt;/code&gt;タグでジェネリック型を宣言できます。</target>
        </trans-unit>
        <trans-unit id="578813d014f5da6ccea41bacd872a0d259c87786" translate="yes">
          <source>You can find more documentation on baseUrl in &lt;a href="http://requirejs.org/docs/api.html#config-baseUrl"&gt;RequireJS&lt;/a&gt; and &lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl"&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target>baseUrlに関する詳細なドキュメントは、&lt;a href="http://requirejs.org/docs/api.html#config-baseUrl"&gt;RequireJS&lt;/a&gt;および&lt;a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl"&gt;SystemJS&lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0ba620983de41a7ef95236f421d1dc97955b1aa9" translate="yes">
          <source>You can find the full list of supported JSDoc patterns &lt;a href="#supported-jsdoc"&gt;below&lt;/a&gt;.</source>
          <target>サポートされているJSDocパターンの完全なリストは&lt;a href="#supported jsdoc"&gt;&lt;/a&gt;以下にあります。</target>
        </trans-unit>
        <trans-unit id="8f608f667f472aa22cebd5f33fb938554db51b9e" translate="yes">
          <source>You can fully understand how to make any shape of definition by understanding some key concepts of how TypeScript works.</source>
          <target>TypeScriptの動作に関するいくつかの重要な概念を理解することによって、どのような形の定義でも作成する方法を完全に理解することができます。</target>
        </trans-unit>
        <trans-unit id="ffbbf130c4a666890a749997011788aa15e53216" translate="yes">
          <source>You can have TypeScript raise errors when this happens via the compiler flag &lt;code&gt;strictFunctionTypes&lt;/code&gt;.</source>
          <target>コンパイラフラグ&lt;code&gt;strictFunctionTypes&lt;/code&gt;を使用すると、TypeScriptでエラーを発生させることができます。</target>
        </trans-unit>
        <trans-unit id="e7cf81fd3fe04126a6e45600ef8b2c4d2d493009" translate="yes">
          <source>You can install this library via npm:</source>
          <target>このライブラリーはnpmを介してインストールできます。</target>
        </trans-unit>
        <trans-unit id="947cee68bd128ad7579db636c222ec6f612e50a8" translate="yes">
          <source>You can learn more about &lt;code&gt;tsconfig.json&lt;/code&gt; files &lt;a href="tsconfig-json"&gt;here&lt;/a&gt;.</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;ファイルの詳細については、&lt;a href="tsconfig json"&gt;ここ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0002bbb784dd22adfca99735cd3bee016fc7bc2f" translate="yes">
          <source>You can learn more about configuring webpack &lt;a href="https://webpack.js.org/concepts"&gt;here&lt;/a&gt;.</source>
          <target>Web Packの構成の詳細については、&lt;a href="https://webpack.js.org/concepts"&gt;ここ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2acea5010ea541a31bcbc5992b38da22bdf966f2" translate="yes">
          <source>You can make properties readonly by using the &lt;code&gt;readonly&lt;/code&gt; keyword. Readonly properties must be initialized at their declaration or in the constructor.</source>
          <target>&lt;code&gt;readonly&lt;/code&gt;キーワードを使用すると、プロパティを読み取り専用にできます。読み取り専用プロパティは、宣言時またはコンストラクタで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="5ac33330400d5a0e5b89b577a3c10f0de7e4e12f" translate="yes">
          <source>You can now define an &lt;em&gt;alias&lt;/em&gt; for a type using the &lt;code&gt;type&lt;/code&gt; keyword:</source>
          <target>&lt;code&gt;type&lt;/code&gt;キーワードを使用して、タイプの&lt;em&gt;エイリアス&lt;/em&gt;を定義できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3e434657788b8ddc40cdc0edab54832db855ade3" translate="yes">
          <source>You can pass any of the three allowed strings, but any other string will give the error</source>
          <target>使用可能な3つの文字列のいずれかを渡すことができますが、他の文字列を渡すとエラーになります。</target>
        </trans-unit>
        <trans-unit id="d470740bd26919fb50f6301789d422e287938cf6" translate="yes">
          <source>You can provide &lt;code&gt;tsc -b&lt;/code&gt; with multiple config file paths (e.g. &lt;code&gt;tsc -b src test&lt;/code&gt;). Just like &lt;code&gt;tsc -p&lt;/code&gt;, specifying the config file name itself is unnecessary if it&amp;rsquo;s named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target>&lt;code&gt;tsc-b&lt;/code&gt;には、複数の構成ファイル・パスを指定できます(たとえば、&lt;code&gt;tsc-b src test&lt;/code&gt;)。 &lt;code&gt;tsc-p&lt;/code&gt;と同様に、&lt;code&gt;tsconfig.json&lt;/code&gt;という名前の構成ファイル名を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1f0c4b0cf188a255ee3afb8b2ea5e76910a20990" translate="yes">
          <source>You can read more about the process in Node.js documentation on &lt;a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders"&gt;loading modules from &lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target>このプロセスの詳細については、&lt;a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders"&gt;&lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;からのモジュールの読み込みに関するNode.jsのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="01c1237490875a34de9e3a6f34ec2e6bab8560cf" translate="yes">
          <source>You can read more about this in Node.js documentation on &lt;a href="https://nodejs.org/api/modules.html#modules_file_modules"&gt;file modules&lt;/a&gt; and &lt;a href="https://nodejs.org/api/modules.html#modules_folders_as_modules"&gt;folder modules&lt;/a&gt;.</source>
          <target>詳細については、&lt;a href="https://nodejs.org/api/modules.html#modules_file_modules"&gt;ファイルモジュール&lt;/a&gt;および&lt;a href="https://nodejs.org/api/modules.html#modules_folders_as_modules"&gt;フォルダモジュール&lt;/a&gt;のNode.jsマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="ecd3a208f74e578df2b2a2fa60c227e643c4ba88" translate="yes">
          <source>You can read the type of &lt;code&gt;loggingIdentity&lt;/code&gt; as &amp;ldquo;the generic function &lt;code&gt;loggingIdentity&lt;/code&gt; takes a type parameter &lt;code&gt;T&lt;/code&gt;, and an argument &lt;code&gt;arg&lt;/code&gt; which is an array of &lt;code&gt;T&lt;/code&gt;s, and returns an array of &lt;code&gt;T&lt;/code&gt;s.&amp;rdquo; If we passed in an array of numbers, we&amp;rsquo;d get an array of numbers back out, as &lt;code&gt;T&lt;/code&gt; would bind to &lt;code&gt;number&lt;/code&gt;. This allows us to use our generic type variable &lt;code&gt;T&lt;/code&gt; as part of the types we&amp;rsquo;re working with, rather than the whole type, giving us greater flexibility.</source>
          <target>&lt;code&gt;loggingIdentity&lt;/code&gt;の型を&amp;ldquo;一般関数&lt;code&gt;loggingIdentity&lt;/code&gt;は、型パラメータ&lt;code&gt;T&lt;/code&gt;と、&lt;code&gt;T&lt;/code&gt;の配列である引数&lt;code&gt;arg&lt;/code&gt;を受け取り、&lt;code&gt;T&lt;/code&gt;の配列を返します。&amp;rdquo; 数値の配列を渡すと、&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;number&lt;/code&gt;にバインドされるように、数値の配列が返されます。これにより、汎用型変数&lt;code&gt;T&lt;/code&gt;を、型全体ではなく型の一部として使用できるようになり、柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="4219455f5a7b401b488cbe6f3cc25db24a4f9204" translate="yes">
          <source>You can see an example of using Webpack in our &lt;a href="react-&amp;amp;-webpack"&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target>Webpackの使用例は、&lt;a href="react-&amp;amp;-webpack"&gt;チュートリアルのReact and Webpack&lt;/a&gt;でご覧いただけます。</target>
        </trans-unit>
        <trans-unit id="522afc6f6129110c8704aded05f62e148f7fcfe8" translate="yes">
          <source>You can see these patterns in the TypeScript repo - see &lt;code&gt;src/tsconfig_base.json&lt;/code&gt;, &lt;code&gt;src/tsconfig.json&lt;/code&gt;, and &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; as key examples.</source>
          <target>これらのパターンはTypeScriptリポジトリで見ることができる-キーの例として&lt;code&gt;src/tsconfig_base.json&lt;/code&gt;,&lt;code&gt;src/tsconfig.json&lt;/code&gt;,&lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt;を参照。</target>
        </trans-unit>
        <trans-unit id="342e97c124555c4631ae12805973e016d0bd72c0" translate="yes">
          <source>You can skip checking some files by adding &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line.</source>
          <target>&lt;code&gt;//@ts nocheck&lt;/code&gt;コメントを追加すると、一部のファイルのチェックをスキップできます。逆に、&lt;code&gt;--checkJs&lt;/code&gt;を設定せずに&lt;code&gt;//@ts check&lt;/code&gt;コメントを追加すると、少数の&lt;code&gt;.js&lt;/code&gt;ファイルだけをチェックできます。前の行に&lt;code&gt;//@ts ignore&lt;/code&gt;を追加すると、特定の行のエラーを無視することもできます。</target>
        </trans-unit>
        <trans-unit id="964c60dd8551d7582983d7537470492d6195db2c" translate="yes">
          <source>You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely, you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line. Note that if you have a &lt;code&gt;tsconfig.json&lt;/code&gt;, JS checking will respect strict flags like &lt;code&gt;noImplicitAny&lt;/code&gt;, &lt;code&gt;strictNullChecks&lt;/code&gt;, etc. However, because of the relative looseness of JS checking, combining strict flags with it may be surprising.</source>
          <target>&lt;code&gt;//@ts nocheck&lt;/code&gt;コメントを追加すると、一部のファイルのチェックを省略できます。逆に、&lt;code&gt;--checkJs&lt;/code&gt;を設定せずに&lt;code&gt;//@ts check&lt;/code&gt;コメントを追加すると、少数の&lt;code&gt;.js&lt;/code&gt;ファイルのみをチェックするように選択できます。前の行に&lt;code&gt;//@ts ignore&lt;/code&gt;を追加すると、特定の行のエラーを無視することもできます。 &lt;code&gt;tsconfig.json&lt;/code&gt;を持っている場合、JSチェックは&lt;code&gt;noImplicitAny&lt;/code&gt;や&lt;code&gt;strictNullChecks&lt;/code&gt;のような厳格なフラグを尊重することに注意してください。しかし、JSチェックは比較的緩やかなので、厳格なフラグを組み合わせて使うのは意外かもしれません。</target>
        </trans-unit>
        <trans-unit id="a94719f47d299841e6e51ceee5706dcecbbee79d" translate="yes">
          <source>You can specify any number of config files:</source>
          <target>設定ファイルはいくつでも指定できます。</target>
        </trans-unit>
        <trans-unit id="49e57a0ea093e19313c1e384f922d69417882b6c" translate="yes">
          <source>You can specify array types using a variety of syntaxes:</source>
          <target>さまざまな構文を使用して配列型を指定できます。</target>
        </trans-unit>
        <trans-unit id="34efcdea59af77ca626a5d378a5a510fc13373a4" translate="yes">
          <source>You can specify function types using either Typescript or Closure syntax:</source>
          <target>関数の型は、TypescriptまたはClosure構文を使用して指定できます:</target>
        </trans-unit>
        <trans-unit id="fa7d6f924eeeb484fecdc0bbd17378d7530144b6" translate="yes">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or Typescript syntax.</source>
          <target>標準のJSDoc構文またはTypescript構文を使用して、文字列と数値のインデックスシグネチャを使用して、マップ型および配列型のオブジェクトを指定できます。</target>
        </trans-unit>
        <trans-unit id="e5b4c27e6b170dfa095f022ece8aad3250bbb88a" translate="yes">
          <source>You can specify the type of &lt;em&gt;children&lt;/em&gt; like any other attribute. This will override the default type from, eg the &lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react"&gt;React typings&lt;/a&gt; if you use them.</source>
          <target>他の属性と同様に、&lt;em&gt;子&lt;/em&gt;のタイプを指定できます。 たとえば、&lt;a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react"&gt;React typings&lt;/a&gt;を使用する場合は、のデフォルトタイプを上書きします。</target>
        </trans-unit>
        <trans-unit id="e37fd121d8b3692df1ee3680ad29d96a4b8894ae" translate="yes">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option in your &lt;a href="tsconfig-json"&gt;tsconfig.json&lt;/a&gt; file.</source>
          <target>このモードは、&lt;code&gt;--jsx&lt;/code&gt;コマンドラインフラグまたは&lt;a href="tsconfig json"&gt;tsconfig.json&lt;/a&gt;ファイルの対応するオプションを使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="b65236d6747127a47949cb8a9fb216884384fd47" translate="yes">
          <source>You can think of this as TypeScript &amp;ldquo;toughening up&amp;rdquo; the weak guarantees of these types to catch what would otherwise be silent bugs.</source>
          <target>これは、TypeScript&amp;ldquo;toughening up&amp;rdquo;と考えることができます。これらの型の弱い保証が、そうでなければサイレントバグとなるものをキャッチします。</target>
        </trans-unit>
        <trans-unit id="5097622074f85132325f78b68e79fba79fe3f621" translate="yes">
          <source>You can think of this feature - the &lt;code&gt;??&lt;/code&gt; operator - as a way to &amp;ldquo;fall back&amp;rdquo; to a default value when dealing with &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. When we write code like</source>
          <target>この機能(&lt;code&gt;?&lt;/code&gt;演算子)は、&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;を処理するときにデフォルト値に戻す方法と考えることができます。</target>
        </trans-unit>
        <trans-unit id="e2b715cffb2277991c0db4c0b6b9e109955e0bcf" translate="yes">
          <source>You can use a type alias to make a shorthand for a type:</source>
          <target>型エイリアスを使用すると、型の短縮形を作成できます。</target>
        </trans-unit>
        <trans-unit id="391c1498a82ae1b3dc563cb57e6b7cbe9562f400" translate="yes">
          <source>You can use either &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt; on the first line.</source>
          <target>最初の行には、&lt;code&gt;object&lt;/code&gt;または&lt;code&gt;Object&lt;/code&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="446759c7e9287dd9b2744b78bd72e945161fa89b" translate="yes">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use any Typescript type, and most JSDoc types.</source>
          <target>&amp;ldquo;@type&amp;rdquo;タグを使用して、タイプ名(TypeScript宣言で定義されたプリミティブ、またはJSDoc&amp;ldquo;@typedef&amp;rdquo;タグ)を参照できます。 任意のTypescriptタイプ、およびほとんどのJSDocタイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="c6a45fbb2d4cb410ac9052a3f0018033b37e3130" translate="yes">
          <source>You can use this pattern with other parts of the type system to get type-safe lookups.</source>
          <target>このパターンを型システムの他の部分で使用すると、型セーフな参照を取得することができます。</target>
        </trans-unit>
        <trans-unit id="4df1f23ca2dd7c39f8e49a4cc5f4fc6278b9486d" translate="yes">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;ndash; just patches to existing declarations.</source>
          <target>拡張の&amp;ndash;では、既存の宣言に対するパッチのみで、新しいトップレベル宣言を宣言できません。</target>
        </trans-unit>
        <trans-unit id="61e3055df49675bbb87854f15fad0bf01e0d93c4" translate="yes">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is readonly.</source>
          <target>インデックスシグネチャが読み取り専用のため、&lt;code&gt;myArray[2]&lt;/code&gt;を設定できません。</target>
        </trans-unit>
        <trans-unit id="c7e14e65723450d9d571a4aeb121d26c5a7c7c1f" translate="yes">
          <source>You could also define the type of &lt;code&gt;options&lt;/code&gt; and add a type assertion on the object literal.</source>
          <target>&lt;code&gt;options&lt;/code&gt;の型を定義し、オブジェクトリテラルに型アサーションを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="10223649f26ed1ba254c71d5968c360f3987e66e" translate="yes">
          <source>You could argue that this program is correctly typed, since the &lt;code&gt;width&lt;/code&gt; properties are compatible, there&amp;rsquo;s no &lt;code&gt;color&lt;/code&gt; property present, and the extra &lt;code&gt;colour&lt;/code&gt; property is insignificant.</source>
          <target>&lt;code&gt;width&lt;/code&gt;プロパティは互換性があり、&lt;code&gt;color&lt;/code&gt;プロパティは存在せず、余分な&lt;code&gt;color&lt;/code&gt;プロパティは重要ではないため、このプログラムは正しく型指定されていると主張することができます。</target>
        </trans-unit>
        <trans-unit id="453e1d8a491394744db85218dccb0ae80c5b3442" translate="yes">
          <source>You could use multiple tsconfig files to solve &lt;em&gt;some&lt;/em&gt; of those problems, but new ones would appear:</source>
          <target>これらの問題の&lt;em&gt;一部&lt;/em&gt;を解決するには、複数のtsconfigファイルを使用できますが、新しいファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="783ca79e34aba59fadb024fdf75ec796a34f288d" translate="yes">
          <source>You may already be familiar with this style of type from other languages. In the next section, we&amp;rsquo;ll cover how you can create your own generic types like &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target>他の言語のこのタイプのスタイルについては、すでにご存知かもしれません。 次のセクションでは、&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;のような独自の総称型を作成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="0e224facb474f21f90e2b2be7d6c67fc9a0105ac" translate="yes">
          <source>You may be wondering why we allow &amp;lsquo;discarding&amp;rsquo; parameters like in the example &lt;code&gt;y = x&lt;/code&gt;. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, &lt;code&gt;Array#forEach&lt;/code&gt; provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it&amp;rsquo;s very useful to provide a callback that only uses the first parameter:</source>
          <target>&lt;code&gt;y=x&lt;/code&gt;の例のように&amp;lsquo;discarding&amp;rsquo;parameters;を許可する理由は、この割り当てが許可される理由は、JavaScriptでは余分な関数パラメータを無視することが実際には非常に一般的だからです。 たとえば、&lt;code&gt;Array#forEach&lt;/code&gt;は、配列要素、そのインデックス、およびそれを含む配列という3つのパラメータをコールバック関数に提供します。 ただし、最初のパラメータのみを使用するコールバックを提供すると便利です。</target>
        </trans-unit>
        <trans-unit id="6203b314b9679b4e6a450edc94780928a6921225" translate="yes">
          <source>You may need to restart VS for the red squiggly lines below &lt;code&gt;UseDefaultFiles&lt;/code&gt; and &lt;code&gt;UseStaticFiles&lt;/code&gt; to disappear.</source>
          <target>&lt;code&gt;UseDefaultFiles&lt;/code&gt;と&lt;code&gt;UseStaticFiles&lt;/code&gt;の下の赤い波線が消えるには、VSを再起動する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d0a6344f0b1a26e856b642628201bf4d2566c8e" translate="yes">
          <source>You may still mark a member &lt;code&gt;public&lt;/code&gt; explicitly. We could have written the &lt;code&gt;Animal&lt;/code&gt; class from the previous section in the following way:</source>
          <target>メンバ&lt;code&gt;public&lt;/code&gt;には明示的にマークを付けることができます。 前のセクションの&lt;code&gt;Animal&lt;/code&gt;クラスを次のように記述することもできます。</target>
        </trans-unit>
        <trans-unit id="ddc16c019974ce3ac91057cddfe1e72a32d707b7" translate="yes">
          <source>You may&amp;rsquo;ve noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword was introduced to JavaScript in ES2015 and is now considered the standard because it&amp;rsquo;s safer than &lt;code&gt;var&lt;/code&gt;. We&amp;rsquo;ll discuss the details later, but many common problems in JavaScript are alleviated by using &lt;code&gt;let&lt;/code&gt;, so you should use it instead of &lt;code&gt;var&lt;/code&gt; whenever possible.</source>
          <target>これまでは、JavaScriptの&lt;code&gt;var&lt;/code&gt;キーワードではなく&lt;code&gt;let&lt;/code&gt;キーワードを使用していました。 &lt;code&gt;let&lt;/code&gt;キーワードは、ES2015でJavaScriptに導入され、&lt;code&gt;var&lt;/code&gt;よりも安全であるため、標準と見なされています。詳細については後で説明しますが、JavaScriptでよく発生する問題の多くは、&lt;code&gt;let&lt;/code&gt;を使用することで軽減されるため、可能な限り&lt;code&gt;var&lt;/code&gt;の代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c6ca7fd5f06b5916404ff0286e5a8b87e56d87ec" translate="yes">
          <source>You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.</source>
          <target>また、Babelのような別のトランスパイルを使用するなど、JavaScriptで中間ステップを実行している場合もあります。 この場合、このようなフォルダ構造がすでに設定されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="77d12568f27dbc483de4e3aa9461fb0fdafcd3b7" translate="yes">
          <source>You might be tempted to use &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; to say that a value can have any property on it because &lt;code&gt;Object&lt;/code&gt; is, for most purposes, the most general type. However &lt;strong&gt;&lt;code&gt;any&lt;/code&gt; is actually the type you want to use&lt;/strong&gt; in those situations, since it&amp;rsquo;s the most &lt;em&gt;flexible&lt;/em&gt; type.</source>
          <target>ほとんどの場合、&lt;code&gt;Object&lt;/code&gt;が最も一般的な型であるため、&lt;code&gt;Object&lt;/code&gt;または&lt;code&gt;{}&lt;/code&gt;を使用して、値に任意のプロパティを含めることができると言いたくなるかもしれません。 ただし、&lt;strong&gt;&lt;code&gt;任意の&lt;/code&gt;は、実際には&lt;/strong&gt;使用するタイプです。これは、最も&lt;em&gt;柔軟な&lt;/em&gt;タイプであるためです。</target>
        </trans-unit>
        <trans-unit id="902577569221e3d57d91dd10a280916026992b82" translate="yes">
          <source>You might be wondering about that &lt;code&gt;externals&lt;/code&gt; field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn&amp;rsquo;t change.</source>
          <target>この&lt;code&gt;externals&lt;/code&gt;フィールドについて疑問に思うかもしれません。 すべてのReactを同じファイルにバンドルするのは避けたいと考えています。これによりコンパイル時間が長くなり、変更しない限りブラウザは通常ライブラリをキャッシュできるからです。</target>
        </trans-unit>
        <trans-unit id="3787c905bb80e813db582cc0b39b9469c3749297" translate="yes">
          <source>You might find yourself using &lt;code&gt;?.&lt;/code&gt; to replace a lot of code that performs repetitive nullish checks using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target>&lt;code&gt;.&lt;/code&gt;を使用して、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;演算子を使用して繰り返しヌリシチェックを実行する多数のコードを置き換えている場合があります。</target>
        </trans-unit>
        <trans-unit id="453b06c204a19fa2060d497fe42b9d6b893f9b0c" translate="yes">
          <source>You might have previously written that like so:</source>
          <target>以前に次のように書いたことがあるでしょう。</target>
        </trans-unit>
        <trans-unit id="79ec33e56a8b7eaeb4d65dc92383b5f0d769696d" translate="yes">
          <source>You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we&amp;rsquo;ll do our best to cover the gist of things.</source>
          <target>パイプラインにさらにいくつかのビルド・ステップがあるかもしれません。 それぞれのファイルに何かを連結するかもしれません。 それぞれのビルドツールは異なりますが、私たちは物事の要点をカバーするために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="4d2749eb8b0574a3a2922dc523ce38ed21997148" translate="yes">
          <source>You might see documentation like this:</source>
          <target>次のようなドキュメントが表示されます。</target>
        </trans-unit>
        <trans-unit id="9ebbdb79f43467b01f07e5bf9e813b83bf4b06f2" translate="yes">
          <source>You might start out getting a bunch of errors like &lt;code&gt;Cannot find name 'require'.&lt;/code&gt;, and &lt;code&gt;Cannot find name 'define'.&lt;/code&gt;. In these cases, it&amp;rsquo;s likely that you&amp;rsquo;re using modules. While you can just convince TypeScript that these exist by writing out</source>
          <target>&lt;code&gt;Cannot find name'require'.&lt;/code&gt;や&lt;code&gt;Cannot find name'define'.&lt;/code&gt;などのエラーが発生する可能性があります。このような場合、モジュールを使用している可能性があります。 TypeScriptにこれらが存在することを確かめるには、以下のように書く。</target>
        </trans-unit>
        <trans-unit id="a98f3b8ccf34fbf5eb87c6d57b621277a9a767e5" translate="yes">
          <source>You no longer need to either explicitly declare &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;extend React.Props&lt;/code&gt;</source>
          <target>&lt;code&gt;ref&lt;/code&gt;および&lt;code&gt;key&lt;/code&gt;または&lt;code&gt;extend React.Props&lt;/code&gt;を明示的に宣言する必要がなくなりました。</target>
        </trans-unit>
        <trans-unit id="5bcfb9bf7e9a5a70d6661bc4978c8808ff85beea" translate="yes">
          <source>You will mostly see intersection types used for mixins and other concepts that don&amp;rsquo;t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here&amp;rsquo;s a simple example that shows how to create a mixin:</source>
          <target>ミックスインに使用される交差型や、古典的なオブジェクト指向の型に適合しないその他の概念がほとんどです(JavaScriptにはこれらの多くがあります!)。 ここでは、ミックスインの作成方法を示す簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="d538693b1e7a8713fd015bc6f34e84e12105e70c" translate="yes">
          <source>You&amp;rsquo;ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use &lt;code&gt;./dist/main.js&lt;/code&gt;. You can always go back and change these in the &lt;code&gt;package.json&lt;/code&gt; file that&amp;rsquo;s been generated for you.</source>
          <target>一連のプロンプトが表示されます。 エントリポイント以外はデフォルトを使用できます。 エントリポイントには、&lt;code&gt;./dist/main.js&lt;/code&gt;を使用します。これらは、&amp;rsquo;sが生成された&lt;code&gt;package.json&lt;/code&gt;ファイルでいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="639d21bc62abc7441d41597c046101c12fe57e01" translate="yes">
          <source>You&amp;rsquo;ll notice that in the class when we refer to one of the members of the class we prepend &lt;code&gt;this.&lt;/code&gt;. This denotes that it&amp;rsquo;s a member access.</source>
          <target>クラスのメンバの1つを参照するときに、この.&lt;/code&gt;の前に&lt;code&gt;this.&lt;/code&gt;を付けます。これは、このクラスがメンバアクセスであることを示します。</target>
        </trans-unit>
        <trans-unit id="96310a35cd7703a91b61529ec989ae56b9f242ba" translate="yes">
          <source>You&amp;rsquo;ll see examples that look like this:</source>
          <target>次のような例が表示されます。</target>
        </trans-unit>
        <trans-unit id="82f270d2ae21cc7300335c3380e8b45bcd31b76c" translate="yes">
          <source>You&amp;rsquo;ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the &lt;code&gt;arguments&lt;/code&gt; object instead of writing out any parameters:</source>
          <target>引数の数が多すぎたり少なすぎたりすることがあります。 通常、これはバグですが、場合によっては、パラメータを書き出す代わりに&lt;code&gt;arguments&lt;/code&gt;オブジェクトを使用する関数を宣言していることがあります。</target>
        </trans-unit>
        <trans-unit id="20cb63d917861135d9d38ee4daf7eae6a3aead46" translate="yes">
          <source>You&amp;rsquo;ll typically see modular libraries include one of these lines in their documentation:</source>
          <target>通常、モジュールライブラリのドキュメントには次のいずれかの行が含まれています。</target>
        </trans-unit>
        <trans-unit id="c9d443a11ab3a7c14d4920d4c70eef21109fe48c" translate="yes">
          <source>You&amp;rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</source>
          <target>HTMLスクリプトタグでライブラリを使用する方法については、通常、グローバルライブラリのドキュメントに次のようなガイダンスがあります。</target>
        </trans-unit>
        <trans-unit id="3dffae8ffc86fe15706e64a3a387cd0d95f60fa7" translate="yes">
          <source>You&amp;rsquo;ll want to bring your TypeScript files together - both the code you&amp;rsquo;ll be writing as well as any necessary declaration files.</source>
          <target>作成するコードと必要な宣言ファイルの両方をTypeScriptファイルにまとめる必要があります。</target>
        </trans-unit>
        <trans-unit id="947d14a2174247c5b66d9b89b8d5cbb14d3c55b1" translate="yes">
          <source>Your declaration files should thus be</source>
          <target>したがって、宣言ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="440ddccd9fb08c957f616ff6766040aab7a385dd" translate="yes">
          <source>ZipCodeValidator.ts</source>
          <target>ZipCodeValidator.ts関数</target>
        </trans-unit>
        <trans-unit id="103388cf7ca274b241718ae87f010b3c451a1308" translate="yes">
          <source>a literal enum expression (basically a string literal or a numeric literal)</source>
          <target>リテラル列挙式(基本的には文字列リテラルまたは数値リテラル)</target>
        </trans-unit>
        <trans-unit id="2c353e97b94a39673f6777646c09f2fc9ba56cf1" translate="yes">
          <source>a parenthesized constant enum expression</source>
          <target>括弧で括られた定数enum式</target>
        </trans-unit>
        <trans-unit id="6f264047eeed3d46fe957e11ffb9269c2a50015e" translate="yes">
          <source>a reference to previously defined constant enum member (which can originate from a different enum)</source>
          <target>以前に定義された定数enumメンバへの参照(異なるenumから生成可能)</target>
        </trans-unit>
        <trans-unit id="c528b1c807d172a8f416db6731cf13e39f6f146c" translate="yes">
          <source>a unary minus applied to any numeric literal (e.g. &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-100&lt;/code&gt;)</source>
          <target>数値リテラルに適用される単項マイナス(例:&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;-100&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="442d3d9c923419455d4cda7f945720f15e70bc16" translate="yes">
          <source>amdModule.js</source>
          <target state="translated">amdModule.js</target>
        </trans-unit>
        <trans-unit id="bd7d452e38c7164a50e08e9fa4635c29c0daaa0b" translate="yes">
          <source>amdModule.ts</source>
          <target state="translated">amdModule.ts</target>
        </trans-unit>
        <trans-unit id="d28fdf8d5aa89ce199b0e06ebcd80f424c23a2d8" translate="yes">
          <source>an expression</source>
          <target>式</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes">
          <source>and</source>
          <target>および</target>
        </trans-unit>
        <trans-unit id="2f7e39bb1317b9d8b35bfd3478e54eeafbdfcc2b" translate="yes">
          <source>and as expected, this will print out</source>
          <target>予想通り</target>
        </trans-unit>
        <trans-unit id="5a1d8e9654b07127c7e5e0c08c9afa232068f17f" translate="yes">
          <source>and merge in options from the following into your &lt;code&gt;webpack.config.js&lt;/code&gt; file:</source>
          <target>次のオプションを&lt;code&gt;webpack.config.js&lt;/code&gt;ファイルにマージします。</target>
        </trans-unit>
        <trans-unit id="23fcd315817eba480bb49d04295a2aed7b06de1d" translate="yes">
          <source>and optionally returns a property descriptor to install on the target object</source>
          <target>オプションで、ターゲットオブジェクトにインストールするプロパティ記述子を返します。</target>
        </trans-unit>
        <trans-unit id="70d4ff6caac47a36ba7af0fb07acabf9735a878b" translate="yes">
          <source>and we can also access those same variables within other functions:</source>
          <target>他の関数内で同じ変数にアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="14539c18332daf6c00ef5a5fb87c44bcec15c080" translate="yes">
          <source>any numeric literal (e.g. &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;100&lt;/code&gt;)</source>
          <target>任意の数値リテラル(例:&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;100&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="d4fc9c2ab5d3af99646bec10e59c8eeb1d9814d0" translate="yes">
          <source>any string literal (e.g. &lt;code&gt;"foo"&lt;/code&gt;, &lt;code&gt;"bar&lt;/code&gt;, &lt;code&gt;"baz"&lt;/code&gt;)</source>
          <target>任意の文字列リテラル(例:&lt;code&gt;"foo"&lt;/code&gt;,&lt;code&gt;"bar&lt;/code&gt;,&lt;code&gt;"baz"&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="94012cbdbf0e0cf94a72971e951224b4fef1ce18" translate="yes">
          <source>app.ts</source>
          <target state="translated">app.ts</target>
        </trans-unit>
        <trans-unit id="90e0d93d8b273dfcd00bd87849d5d11bf6a1ff97" translate="yes">
          <source>array literals become &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target>配列リテラルは&lt;code&gt;readonly&lt;/code&gt;タプルになる</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes">
          <source>at compile time</source>
          <target>コンパイル時</target>
        </trans-unit>
        <trans-unit id="ea0880f5346592a44bf582fa485ad5c011fc5cda" translate="yes">
          <source>at runtime</source>
          <target>実行時</target>
        </trans-unit>
        <trans-unit id="864ec6413a2ca497c9c6969ef6b7506903f57beb" translate="yes">
          <source>awesome-typescript-loader</source>
          <target>すごいタイプスクリプトローダー</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="ba69ef3aa7bab274d4a266a6dcb623595c1d29fe" translate="yes">
          <source>bundling with your npm package, or</source>
          <target>npmパッケージにバンドルする</target>
        </trans-unit>
        <trans-unit id="231393efbaac44c960b4ab365234afea0360d138" translate="yes">
          <source>cache module resolution</source>
          <target>キャッシュモジュールの解決</target>
        </trans-unit>
        <trans-unit id="30fdfe9db20efa1fbadcfb48f8e2224b604a7625" translate="yes">
          <source>cache settings calculated from &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target>&lt;code&gt;tsconfig.json&lt;/code&gt;から計算されたキャッシュ設定</target>
        </trans-unit>
        <trans-unit id="fb02f65cfddd8df81baf783711476ad11f820af3" translate="yes">
          <source>can actually be passed around to functions</source>
          <target>関数に渡され</target>
        </trans-unit>
        <trans-unit id="1628f3e3fa5143b8a4026ed6fba31449a9455f0b" translate="yes">
          <source>can be rewritten as the following array literal</source>
          <target>は以下の配列リテラルとして書き換えられる</target>
        </trans-unit>
        <trans-unit id="f3d83e025c075f2d6dbf66e81628a8d397f050ac" translate="yes">
          <source>can finally be rewritten without helper interfaces.</source>
          <target>ヘルパーインタフェースなしで書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="e40f6b5c83d4e391396b982f962d9261185c5bc7" translate="yes">
          <source>const declarations</source>
          <target>const宣言</target>
        </trans-unit>
        <trans-unit id="6d43229f086c7e1519152492bb976fdefa4cd26f" translate="yes">
          <source>declarations.d.ts</source>
          <target state="translated">declarations.d.ts</target>
        </trans-unit>
        <trans-unit id="2c78b75bf2045753edca089f4a8b164e61897b5b" translate="yes">
          <source>default (no value specified)</source>
          <target>default(値が指定されていません)</target>
        </trans-unit>
        <trans-unit id="eaa6f0ed9db98407e1677119423605d0592c8193" translate="yes">
          <source>doesn&amp;rsquo;t stop the division or &lt;code&gt;someComputation()&lt;/code&gt; call from occurring. It&amp;rsquo;s equivalent to</source>
          <target>は、除算または&lt;code&gt;someComputation()&lt;/code&gt;呼び出しの発生を停止しません。 と同じ</target>
        </trans-unit>
        <trans-unit id="be65d27ae088a0e03fd8e1331d90b01649464cb6" translate="yes">
          <source>dom</source>
          <target state="translated">dom</target>
        </trans-unit>
        <trans-unit id="44b226e39304e9a0605138651ed370e25b549357" translate="yes">
          <source>dramaticWelcome.ts</source>
          <target>dramaticWelcome.ts</target>
        </trans-unit>
        <trans-unit id="c0c3d909b5b29bd46a7edf52931b97737d5d1ace" translate="yes">
          <source>emits as:</source>
          <target>は次のように出力します。</target>
        </trans-unit>
        <trans-unit id="3c5fff4d0016b644ab9720bf2113d69e16ee0db5" translate="yes">
          <source>es2015.collection</source>
          <target>es2015コレクション</target>
        </trans-unit>
        <trans-unit id="77452a908deffdbe4e25c0322f6fc17a39206ee1" translate="yes">
          <source>es2015.core</source>
          <target>es2015.core</target>
        </trans-unit>
        <trans-unit id="4860f22d1763b9179816b962767983a680787ab3" translate="yes">
          <source>es2015.generator</source>
          <target>es2015.ジェネレーター</target>
        </trans-unit>
        <trans-unit id="a55fcf72537ff6199c436b9f28cfe5f307a1cc8d" translate="yes">
          <source>es2015.iterable</source>
          <target>es2015.iterable</target>
        </trans-unit>
        <trans-unit id="455275f9b321b188ad0398ce86c78e923eb8b72b" translate="yes">
          <source>es2015.promise</source>
          <target>es2015プロミス</target>
        </trans-unit>
        <trans-unit id="ec95b856e9e47298430b5eb6799d9d8096bc4095" translate="yes">
          <source>es2015.proxy</source>
          <target>es2015.プロキシ</target>
        </trans-unit>
        <trans-unit id="e6a8c5db65e11ddb62cc5fade31b70004048dc2c" translate="yes">
          <source>es2015.reflect</source>
          <target>es2015リフレクト</target>
        </trans-unit>
        <trans-unit id="de3c65e6af009d778471d8136d3c826fe99099be" translate="yes">
          <source>es2015.symbol</source>
          <target>es2015.シンボル</target>
        </trans-unit>
        <trans-unit id="671a9cd26cd3ffb3ef770f5b5b32cdcb27809d42" translate="yes">
          <source>es2015.symbol.wellknown</source>
          <target>es2015.symbol.well-known(ES2015)</target>
        </trans-unit>
        <trans-unit id="139a6dc78bee16dab8bae5ac789d730b614b917b" translate="yes">
          <source>es2016</source>
          <target>es2016(英語)</target>
        </trans-unit>
        <trans-unit id="cd9583a356098ba3a4b81fc650ae36d83d670a5d" translate="yes">
          <source>es2016.array.include</source>
          <target>es2016.array.include</target>
        </trans-unit>
        <trans-unit id="911015d28bbfae967ffe9225bd0fbdb225773f33" translate="yes">
          <source>es2017</source>
          <target>es2017</target>
        </trans-unit>
        <trans-unit id="70890fd881ddc0e6b5672ad7751679f721fb15d1" translate="yes">
          <source>es2017.object</source>
          <target>es2017オブジェクト</target>
        </trans-unit>
        <trans-unit id="5c6dbbf6f5b69fd02229a5a287b71af3d57a3f79" translate="yes">
          <source>es2017.sharedmemory</source>
          <target>es2017.sharedmemory[CA.sharedmemory]</target>
        </trans-unit>
        <trans-unit id="04fd367a754d12acaf37607d62e169a42efc8e2f" translate="yes">
          <source>es5</source>
          <target>es5[es5]</target>
        </trans-unit>
        <trans-unit id="616df35d1ecf30f8712a0292c2c5a1d0030a5cf2" translate="yes">
          <source>es6 / es2015</source>
          <target>es6/es2015</target>
        </trans-unit>
        <trans-unit id="dfb1e3d26774a3a7d06095ec73fbb40447cd1e68" translate="yes">
          <source>export = and import = require()</source>
          <target>export=とimport=require()</target>
        </trans-unit>
        <trans-unit id="552fc8d9cfca0ff2b5ed367c413c5cc38420bb95" translate="yes">
          <source>folders whose combined content represent the structure of the project at runtime. See &lt;a href="module-resolution#virtual-directories-with-rootdirs"&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target>実行時にプロジェクトの構造を表すコンテンツを結合したフォルダ。 詳細については、&lt;a href="module resolution#virtual directories withロートディース"&gt;Module Resolution documentation&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c6111b4c03a562ccddbf99c1de8d5cfee0039f5a" translate="yes">
          <source>for...of statements</source>
          <target>for.ステートメント</target>
        </trans-unit>
        <trans-unit id="31f79b8f38a6b1aee4464af7bf6e58995fdcc55c" translate="yes">
          <source>for..of support</source>
          <target>サポート</target>
        </trans-unit>
        <trans-unit id="e777919351daf00b0d9ef805e8c06560be596a16" translate="yes">
          <source>from anywhere - even modules - using the new &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag.</source>
          <target>新しい&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt;フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="02e504f321a2bfc777ca2c589c79d3282bfcd3db" translate="yes">
          <source>global-modifying-module.d.ts</source>
          <target state="translated">global-modifying-module.d.ts</target>
        </trans-unit>
        <trans-unit id="1c82bf83ced9d75b8f0bbc6b62ddb9a6a3e330d2" translate="yes">
          <source>global-plugin.d.ts</source>
          <target state="translated">global-plugin.d.ts</target>
        </trans-unit>
        <trans-unit id="9e56f9776b89753df86ad753aa1b6340af717ac6" translate="yes">
          <source>global.d.ts</source>
          <target state="translated">global.d.ts</target>
        </trans-unit>
        <trans-unit id="5f34c3ce3807ecd43ae9b35d36315839a3e5594d" translate="yes">
          <source>has the effect of turning on all strict options &lt;em&gt;except&lt;/em&gt; the &lt;code&gt;--noImplicitThis&lt;/code&gt; option. Using this scheme it is possible to express configurations consisting of &lt;em&gt;all&lt;/em&gt; strict options except some explicitly listed options. In other words, it is now possible to default to the highest level of type safety but opt out of certain checks.</source>
          <target>には、&lt;code&gt;--noImplicitThis&lt;/code&gt;オプションを除くすべてのstrictオプションをオンにする効果があります。 このスキームを使用すると、明示的にリストされたオプションを除く&lt;em&gt;すべての&lt;/em&gt;strictオプションで構成される構成を表現できます。 言い換えれば、最高レベルの型安全性にデフォルト設定することができるが、特定のチェックを外すことができる。</target>
        </trans-unit>
        <trans-unit id="18591991497d2b68bd0eed89efdaf2451fa493b5" translate="yes">
          <source>hasInstance</source>
          <target>hasInstance</target>
        </trans-unit>
        <trans-unit id="afa300ec2e6f442ad1c924d6f087f775ceb41f89" translate="yes">
          <source>import &amp;lsquo;folder1/file2&amp;rsquo;:</source>
          <target>インポート&amp;lsquo;フォルダ1/ファイル2&amp;rsquo;:</target>
        </trans-unit>
        <trans-unit id="4125832cdf0f8431153bb560626b190459d5c951" translate="yes">
          <source>import &amp;lsquo;folder2/file3&amp;rsquo;:</source>
          <target>インポート&amp;lsquo;フォルダ2/file3&amp;rsquo;:</target>
        </trans-unit>
        <trans-unit id="e7269327a2c540547ce437cbdb0983490aab1d82" translate="yes">
          <source>import types can also be used in type alias declarations:</source>
          <target>import型は、型別名宣言でも使用できます。</target>
        </trans-unit>
        <trans-unit id="98a817954644dc1a42aab49b25d28ed9e711dcb1" translate="yes">
          <source>import types can be used to get the type of a value from a module if you don&amp;rsquo;t know the type, or if it has a large type that is annoying to type:</source>
          <target>タイプがわからない場合、またはタイプするのが面倒な大きなタイプがある場合は、インポートタイプを使用してモジュールから値のタイプを取得できます。</target>
        </trans-unit>
        <trans-unit id="35c8cb4be244289fb285290d143c9526ef63af36" translate="yes">
          <source>imports can also be renamed</source>
          <target>インポートの名前を変更することも可能</target>
        </trans-unit>
        <trans-unit id="6aea52bc45b38b909da565c5529f2a9c7f8db0a4" translate="yes">
          <source>in generated code will become</source>
          <target>生成されたコードは</target>
        </trans-unit>
        <trans-unit id="f47c6df49b203143e91cc678af85198bdcdaf295" translate="yes">
          <source>in that order.</source>
          <target>と入力します。</target>
        </trans-unit>
        <trans-unit id="84ce34d804a3c874e85689e05ad0b489ab140173" translate="yes">
          <source>inject helpers in &lt;em&gt;every&lt;/em&gt; file that needs them, or</source>
          <target>ヘルパーを必要とする&lt;em&gt;すべての&lt;/em&gt;ファイルにヘルパーを注入するか</target>
        </trans-unit>
        <trans-unit id="468d96f12443b97ac97eca3d629ee0a54fe0a6df" translate="yes">
          <source>instanceof type guards</source>
          <target>instanceof型ガード</target>
        </trans-unit>
        <trans-unit id="a92d74a79d6425b54c23f524c3bf077b2f9b9a03" translate="yes">
          <source>instead of needing to use</source>
          <target>使用する代わりに</target>
        </trans-unit>
        <trans-unit id="6b0d333fa91b7256720d61e3b723f862f3e9cd6a" translate="yes">
          <source>is compiled to:</source>
          <target>のコンパイル先:</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes">
          <source>is equivalent to:</source>
          <target>は次と同じです。</target>
        </trans-unit>
        <trans-unit id="5036323301c49fea1149a5e0032dddf37a7db574" translate="yes">
          <source>isConcatSpreadable</source>
          <target>isConcatSpreadable</target>
        </trans-unit>
        <trans-unit id="a565530bf0e070a5e111b87a562d444b5f4fc91c" translate="yes">
          <source>it&amp;rsquo;s better to get rid of those calls and use TypeScript syntax for imports.</source>
          <target>これらの呼び出しを削除し、インポートにTypeScript構文を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bef4aaaa11015ef79d88f3701f4c69ad690eb4c7" translate="yes">
          <source>iterator</source>
          <target>反復子</target>
        </trans-unit>
        <trans-unit id="e01628c208ee1a02b76e949e6aeeb32ef20336c1" translate="yes">
          <source>let declarations</source>
          <target>let宣言</target>
        </trans-unit>
        <trans-unit id="fe1ea68213afb7afeac6a8fbb4b87a0022fb14d9" translate="yes">
          <source>math-lib.d.ts</source>
          <target>mathlib.d.tsメソッド</target>
        </trans-unit>
        <trans-unit id="96975c0a90b39fef6b95655c8d4a16937cf164bb" translate="yes">
          <source>module-class.d.ts</source>
          <target>モジュールクラス.d.ts</target>
        </trans-unit>
        <trans-unit id="c2bc7a720a2efaefa00955db0d49e95c55f87036" translate="yes">
          <source>module-function.d.ts</source>
          <target>モジュールfunction.d.ts</target>
        </trans-unit>
        <trans-unit id="468f83c6a2befacff3854111aef39df278df3af2" translate="yes">
          <source>module-plugin.d.ts</source>
          <target>モジュールplugin.d.ts</target>
        </trans-unit>
        <trans-unit id="98c512330f2e92d9ee7c96f3f93fbc2bae3712f3" translate="yes">
          <source>module.d.ts</source>
          <target state="translated">module.d.ts</target>
        </trans-unit>
        <trans-unit id="07776d76368c781786ef37f37f876736d04e819a" translate="yes">
          <source>no helpers at all with &lt;code&gt;--noEmitHelpers&lt;/code&gt;.</source>
          <target>&lt;code&gt;--noEmitHelpers&lt;/code&gt;を持つヘルパーはありません。</target>
        </trans-unit>
        <trans-unit id="a16b029d0076e4fd3820aa4c6802762d030bf62a" translate="yes">
          <source>no literal types in that expression should be widened (e.g. no going from &lt;code&gt;"hello"&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;)</source>
          <target>式内のリテラル型を拡張しない(例えば、&lt;code&gt;"hello"&lt;/code&gt;から&lt;code&gt;string&lt;/code&gt;への移動がない)</target>
        </trans-unit>
        <trans-unit id="c1c065b723cc9c76bd65782fc2825c04eeea0d14" translate="yes">
          <source>node.d.ts (simplified excerpt)</source>
          <target>node.d.ts(抜粋)</target>
        </trans-unit>
        <trans-unit id="f6996c043b2b5e1cab7ecdea026dc230caadc8f0" translate="yes">
          <source>null, undefined, and empty array initializers are of type any or any[]</source>
          <target>NULL、未定義、空の配列初期化子の型はanyまたはany[]</target>
        </trans-unit>
        <trans-unit id="2aedd1e807766ef33fa75af2358a22cd131cb1b8" translate="yes">
          <source>object literals get &lt;code&gt;readonly&lt;/code&gt; properties</source>
          <target>オブジェクトリテラルget&lt;code&gt;readonly&lt;/code&gt;プロパティ</target>
        </trans-unit>
        <trans-unit id="0ebf848d70837166207cdc336c60ac98e13285c0" translate="yes">
          <source>one of the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; unary operators applied to constant enum expression</source>
          <target>定数enum式に適用される&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;単項演算子の1つ</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes">
          <source>or</source>
          <target>または</target>
        </trans-unit>
        <trans-unit id="c5e4a4a8dfa19245aa2006b23ea5c10fb66c04c5" translate="yes">
          <source>or if you&amp;rsquo;re not using modules, you can just use the global variable &lt;code&gt;_&lt;/code&gt;.</source>
          <target>モジュールを使用していない場合は、グローバル変数&lt;code&gt;_&lt;/code&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes">
          <source>or like this:</source>
          <target>こんな感じです</target>
        </trans-unit>
        <trans-unit id="7984dbe379bf690e91f1ee949c3912e39cb8fa5a" translate="yes">
          <source>or the following RequireJS/AMD code:</source>
          <target>または次のRequireJS/AMDコード:</target>
        </trans-unit>
        <trans-unit id="6bf95a9eb65b12b201e76e1107475e703367cc8f" translate="yes">
          <source>overriding an accessor in a derived class with a property declaration</source>
          <target>プロパティ宣言による派生クラスのアクセサのオーバーライド</target>
        </trans-unit>
        <trans-unit id="7030d0b2f71b999ff89a343de08c414af32fc93a" translate="yes">
          <source>package.json</source>
          <target state="translated">package.json</target>
        </trans-unit>
        <trans-unit id="c633d046a28eea1c30dc77a917920638149eff4b" translate="yes">
          <source>pattern &amp;lsquo;*&amp;rsquo; is matched and wildcard captures the whole module name</source>
          <target>pattern&amp;lsquo;*&amp;rsquo;がマッチし、ワイルドカードがモジュール名全体をキャプチャする</target>
        </trans-unit>
        <trans-unit id="e46d31b8d8def12ff7fd2aeb2cd33c6ff0c682de" translate="yes">
          <source>publishing to the &lt;a href="https://www.npmjs.com/~types"&gt;@types organization&lt;/a&gt; on npm.</source>
          <target>npmの&lt;a href="https://www.npmjs.com/~types"&gt;@types組織&lt;/a&gt;に発行する。</target>
        </trans-unit>
        <trans-unit id="e964e4b7b09edd9e4bc1f9f94275bbd20db64a86" translate="yes">
          <source>qualified name</source>
          <target>修飾名</target>
        </trans-unit>
        <trans-unit id="84cd3707c3c1a76a0deb0eb06b96bf43c03e7942" translate="yes">
          <source>re-declaring a property declaration with no initializer</source>
          <target>初期化子のないプロパティ宣言の再宣言</target>
        </trans-unit>
        <trans-unit id="3cacc7bfac0a382c669a884c953d0401a689785d" translate="yes">
          <source>replace</source>
          <target>取り替える</target>
        </trans-unit>
        <trans-unit id="0de436ef775b25d8c1ce125d994a572c0b2f2a2d" translate="yes">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/folder1/file2.ts&lt;/code&gt;.</source>
          <target>置換の結果は相対名ではありません。&lt;em&gt;baseUrl&lt;/em&gt;-&amp;gt;&lt;code&gt;projectRoot/folder1/file2.ts&lt;/code&gt;と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="0955b111882fc9165c9f9e7f313ec9ed19312361" translate="yes">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/folder2/file3.ts&lt;/code&gt;.</source>
          <target>置換の結果は相対名ではありません。&lt;em&gt;baseUrl&lt;/em&gt;-&amp;gt;&lt;code&gt;projectRoot/folder2/file3.ts&lt;/code&gt;と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="99a3fa984143a41fb76ddb33b09c3bebfb48dac5" translate="yes">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/generated/folder2/file3.ts&lt;/code&gt;.</source>
          <target>置換の結果は相対名ではありません。&lt;em&gt;baseUrl&lt;/em&gt;-&amp;gt;&lt;code&gt;projectRoot/generated/folder2/file3.ts&lt;/code&gt;と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="dc76e9f0c0006e8f919e0c515c66dbba3982f785" translate="yes">
          <source>root</source>
          <target state="translated">root</target>
        </trans-unit>
        <trans-unit id="4ea4a4256b62dc47fa7b744f94891091f4b0bc89" translate="yes">
          <source>scripthost</source>
          <target state="translated">scripthost</target>
        </trans-unit>
        <trans-unit id="3559d7accf00360971961ca18989adc0614089c0" translate="yes">
          <source>search</source>
          <target>捜索</target>
        </trans-unit>
        <trans-unit id="3f6125de305b05426b600528f29a8bd1bf5a7f90" translate="yes">
          <source>second substitution &amp;lsquo;generated/*&amp;rsquo; -&amp;gt; &lt;code&gt;generated/folder2/file3&lt;/code&gt;</source>
          <target>2番目の置換&amp;lsquo;generated/*&amp;rsquo;-&amp;gt;&lt;code&gt;generated/folder2/file3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf941d149e57be2f6cef984faf977e7b577e5a91" translate="yes">
          <source>share the same type &lt;code&gt;(firstName: string, lastName?: string) =&amp;gt; string&lt;/code&gt;. The default value of &lt;code&gt;lastName&lt;/code&gt; disappears in the type, only leaving behind the fact that the parameter is optional.</source>
          <target>同じ型&lt;code&gt;(firstName:string,lastName?:string)=&amp;gt;string&lt;/code&gt;を共有します。&lt;code&gt;lastName&lt;/code&gt;のデフォルト値は型から削除され、パラメータがオプションであるという事実だけが残されます。</target>
        </trans-unit>
        <trans-unit id="035294d01dde5efc18c757c726816c26af51f939" translate="yes">
          <source>species</source>
          <target state="translated">species</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="cc99c74e82294d1b43025090d9e1d0556327a660" translate="yes">
          <source>that evaluates to a function</source>
          <target>関数に評価される</target>
        </trans-unit>
        <trans-unit id="410790749f881beaeb38631c106e13750a965f34" translate="yes">
          <source>that takes the target, name, and property descriptor as arguments</source>
          <target>ターゲット、名前、およびプロパティー記述子を引数として取る</target>
        </trans-unit>
        <trans-unit id="0e856eda57d6466543d1e599198fd48d9b2d470f" translate="yes">
          <source>the checked value comes from an optional property</source>
          <target>チェックされた値はオプションのプロパティから取得されます。</target>
        </trans-unit>
        <trans-unit id="4320cad8649a09684716eeb91069e55dbef76092" translate="yes">
          <source>the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;</source>
          <target>関数は後で&lt;code&gt;if&lt;/code&gt;の本体内で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0eb972a2af54927fb29feb3fb4a88f8a08079e74" translate="yes">
          <source>the type of the function&amp;rsquo;s &lt;code&gt;prototype&lt;/code&gt; property if its type is not &lt;code&gt;any&lt;/code&gt;</source>
          <target>関数の&lt;code&gt;prototype&lt;/code&gt;プロパティのタイプ(タイプが&lt;code&gt;any&lt;/code&gt;でない場合)</target>
        </trans-unit>
        <trans-unit id="46fd581054ba0a939bf5545d6288d6fbc83e5bb7" translate="yes">
          <source>the union of types returned by that type&amp;rsquo;s construct signatures</source>
          <target>その型の構成体シグネチャによって返される型の集合</target>
        </trans-unit>
        <trans-unit id="73941296c536b59a9dbd4de92d48a59f407991b3" translate="yes">
          <source>then you would write the following TypeScript code:</source>
          <target>次のTypeScriptコードを記述します。</target>
        </trans-unit>
        <trans-unit id="a4bbbe8ef59f52f36231746a023fe1851d9d226c" translate="yes">
          <source>this and arrow functions</source>
          <target state="translated">この関数とアロー関数</target>
        </trans-unit>
        <trans-unit id="c3f72c68c2b9e85be2eb32e46ad8b4b8c7c65b47" translate="yes">
          <source>this is a new way to say that the value &lt;code&gt;foo&lt;/code&gt; will be used when it&amp;rsquo;s &amp;ldquo;present&amp;rdquo;; but when it&amp;rsquo;s &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, calculate &lt;code&gt;bar()&lt;/code&gt; in its place.</source>
          <target>これは、&amp;rsquo;s&amp;ldquo;present&amp;rdquo;;;が&amp;rsquo;s&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;の場合に値&lt;code&gt;foo&lt;/code&gt;が使用されるという新しい言い方です。</target>
        </trans-unit>
        <trans-unit id="d69f1db0e1ea5e4ca2dd4f8fc47cde3bcb24021d" translate="yes">
          <source>this is a way of saying that when &lt;code&gt;foo&lt;/code&gt; is defined, &lt;code&gt;foo.bar.baz()&lt;/code&gt; will be computed; but when &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, stop what we&amp;rsquo;re doing and just return &lt;code&gt;undefined&lt;/code&gt;.&amp;rdquo;</source>
          <target>これは、&lt;code&gt;foo&lt;/code&gt;が定義されている場合、&lt;code&gt;foo.bar.baz()&lt;/code&gt;が計算されますが、&lt;code&gt;foo&lt;/code&gt;が&lt;code&gt;null&lt;/code&gt;または&lt;code&gt;undefined&lt;/code&gt;である場合、我々が行っていることを停止し、&lt;code&gt;undefined&lt;/code&gt;を返すだけです。</target>
        </trans-unit>
        <trans-unit id="ee936e1581e97020e1f572b89ea32250a874ec97" translate="yes">
          <source>this parameters</source>
          <target>このパラメーター</target>
        </trans-unit>
        <trans-unit id="e12e5f0923f00b722f074d1422f64a9f845de377" translate="yes">
          <source>to your proj file. This will enable automatic incremental build as well as cleaning.</source>
          <target>プロジェクトファイルにコピーします。 これにより、自動インクリメンタルビルドとクリーニングが可能になります。</target>
        </trans-unit>
        <trans-unit id="7e5c6264588378e69d51645936191ab10add5e93" translate="yes">
          <source>toPrimitive</source>
          <target>toPrimitive</target>
        </trans-unit>
        <trans-unit id="e2762bc4a7de1aada1593ee4242bbf2686f8446e" translate="yes">
          <source>toStringTag</source>
          <target>toStringTag</target>
        </trans-unit>
        <trans-unit id="15903df5ef6a72c1c46835f09e09e97181bf4905" translate="yes">
          <source>took other generic functions as arguments, like so:</source>
          <target>以下のように、他の汎用関数を引数として取りました。</target>
        </trans-unit>
        <trans-unit id="30b826e9a560741abbb6ab6ebbd8adb6e7480e65" translate="yes">
          <source>try first substitution in the list: &amp;lsquo;*&amp;rsquo; -&amp;gt; &lt;code&gt;folder1/file2&lt;/code&gt;</source>
          <target>リスト内の最初の置換を実行:&amp;lsquo;*&amp;rsquo;-&amp;gt;&lt;code&gt;folder1/file2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8af6d2c2f91e249ac51918e9913c40c803abd33a" translate="yes">
          <source>try first substitution in the list: &amp;lsquo;*&amp;rsquo; -&amp;gt; &lt;code&gt;folder2/file3&lt;/code&gt;</source>
          <target>リスト内の最初の置換を試行:&amp;lsquo;*&amp;rsquo;-&amp;gt;&lt;code&gt;folder2/file3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62a9b1027af305cf651dc37867f95e2771be3b70" translate="yes">
          <source>tsc &amp;ndash;module system</source>
          <target>tsc&amp;ndash;モジュールシステム</target>
        </trans-unit>
        <trans-unit id="fff4bd3c7cb18ddafa0cf9c3cbe164beb57343e4" translate="yes">
          <source>tsc &amp;ndash;module umd</source>
          <target>&amp;tsc;モジュールumd</target>
        </trans-unit>
        <trans-unit id="61ebb9fd6e8cf9082658121d5d81e297791dacd0" translate="yes">
          <source>tsconfig.json</source>
          <target>tsconfig.jsonファイル</target>
        </trans-unit>
        <trans-unit id="276bd1a6a434b41b4d95db5e0d8549df1186c2c8" translate="yes">
          <source>tsconfig.json: @types, typeRoots and types</source>
          <target>tsconfig.json:@types,typeRoots,types</target>
        </trans-unit>
        <trans-unit id="a8998d2dc8a77e20af5c5a28175b6d8951a02cff" translate="yes">
          <source>tsconfig.json: Configuration inheritance with extends</source>
          <target>tsconfig.json:extendsによる設定の継承</target>
        </trans-unit>
        <trans-unit id="49e70783d507bff0c00f2e231d4cf0f0c8f532cc" translate="yes">
          <source>tsconfig.json: Details</source>
          <target>tsconfig.json:詳細</target>
        </trans-unit>
        <trans-unit id="6122fb987f7fd90d7dc18652ca78d161fe544643" translate="yes">
          <source>tsconfig.json: Schema</source>
          <target>tsconfig.json:スキーマ</target>
        </trans-unit>
        <trans-unit id="689bc8e3544a7ddf4369a2913de3f221a9332817" translate="yes">
          <source>tsconfig.json: Using tsconfig.json</source>
          <target>tsconfig.json:tsconfig.jsonの使用</target>
        </trans-unit>
        <trans-unit id="f0986fe288c02a83341b9817dadd43458c8e78a1" translate="yes">
          <source>tsconfig.json: compileOnSave</source>
          <target>tsconfig.json:compileOnSave</target>
        </trans-unit>
        <trans-unit id="76e7d2c9d6a40c98553f221e62c309f440e26de7" translate="yes">
          <source>typeof type guards</source>
          <target>タイプオブタイプガード</target>
        </trans-unit>
        <trans-unit id="7d000ae7bc64f9b26659458ead894e1de3ad1436" translate="yes">
          <source>unscopables</source>
          <target state="translated">unscopables</target>
        </trans-unit>
        <trans-unit id="eceda2b511cd73d8db8f6a944bf2fd8f597d29e5" translate="yes">
          <source>value of &lt;em&gt;baseUrl&lt;/em&gt; command line argument (if given path is relative, it is computed based on current directory)</source>
          <target>&lt;em&gt;baseUrl&lt;/em&gt;コマンドライン引数の値(指定されたパスが相対パスの場合、現在のディレクトリに基づいて計算される)</target>
        </trans-unit>
        <trans-unit id="5f30936558ce9791e34d7bc35fc21d5cfe35d104" translate="yes">
          <source>value of &lt;em&gt;baseUrl&lt;/em&gt; property in &amp;lsquo;tsconfig.json&amp;rsquo; (if given path is relative, it is computed based on the location of &amp;lsquo;tsconfig.json&amp;rsquo;)</source>
          <target>&amp;lsquo;tsconfig.json&amp;rsquo;の&lt;em&gt;baseUrl&lt;/em&gt;プロパティの値(パスが相対パスの場合、&amp;lsquo;tsconfig.json&amp;rsquo;の場所に基づいて計算されます)</target>
        </trans-unit>
        <trans-unit id="0839e97c8a1e4f4d897468c821b41e5eaa185529" translate="yes">
          <source>var declarations</source>
          <target>var宣言</target>
        </trans-unit>
        <trans-unit id="4499ccc1d0e0ade805a0533654e442fececc138f" translate="yes">
          <source>webworker</source>
          <target state="translated">webworker</target>
        </trans-unit>
        <trans-unit id="f3328fe3edbd69bd908391fb6014b6af5d608edf" translate="yes">
          <source>whereas in a vanilla browser environment you would write:</source>
          <target>これに対して、普通のブラウザ環境では次のように記述します。</target>
        </trans-unit>
        <trans-unit id="860bafefa2519ed66049a3ea261ac65589b10afe" translate="yes">
          <source>which is slightly different. &lt;code&gt;Array(5)&lt;/code&gt; produces an array with a length of 5, but with no defined property slots.</source>
          <target>少し違います。 &lt;code&gt;Array(5)&lt;/code&gt;は、長さ5の配列を生成しますが、プロパティスロットが定義されていません。</target>
        </trans-unit>
        <trans-unit id="a6c55dcf0293a1f122e26943ea0663055b97bae3" translate="yes">
          <source>will be emitted as</source>
          <target>として放出されます。</target>
        </trans-unit>
        <trans-unit id="f46edc0fbe0327e0efa900cc749f913bd1a80f9e" translate="yes">
          <source>will be emitted as:</source>
          <target>次のように出力されます。</target>
        </trans-unit>
        <trans-unit id="8e20f36a2661ddaf13f4755da40c2807ae79d25e" translate="yes">
          <source>will be generated as:</source>
          <target>は次のように生成されます。</target>
        </trans-unit>
        <trans-unit id="2771d3b1186a1a3778a1a5e3fbd8b308e69ea2be" translate="yes">
          <source>will be transformed into the following &lt;code&gt;.d.ts&lt;/code&gt; file:</source>
          <target>は、次の&lt;code&gt;.d.ts&lt;/code&gt;ファイルに変換されます。</target>
        </trans-unit>
        <trans-unit id="634d1e09320e1570c335f877722f67a9fdf91968" translate="yes">
          <source>with Mapped types, &lt;code&gt;PartialPerson&lt;/code&gt; can be written as a generalized transformation on the type &lt;code&gt;Person&lt;/code&gt; as:</source>
          <target>マップされた型では、&lt;code&gt;PartialPerson&lt;/code&gt;は&lt;code&gt;Person&lt;/code&gt;型の一般化された変換として次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="f36243ad4ea12acc4ebf39712e5d614768a0b9fa" translate="yes">
          <source>would be equivalent to a similar assignment within a constructor body.</source>
          <target>はコンストラクタ本体内の同様の代入に相当します。</target>
        </trans-unit>
        <trans-unit id="49471e5d2c6c36dd9d328715969ae37fb8083886" translate="yes">
          <source>you could write that out as the following:</source>
          <target>次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="f59273a98347ed94aa5e63df10048950733e7712" translate="yes">
          <source>► &lt;code&gt;"ES2016"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES2016"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a40de54cb8eb456071ddd614bd9f40c54327f41d" translate="yes">
          <source>► &lt;code&gt;"ES2017"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES2017"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f89cc3c29cb665fa25606f58e1f98ff9b626d8b6" translate="yes">
          <source>► &lt;code&gt;"ES2018"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES2018"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f30a1214ce2a0b2580cf271a08656b8e90d700a" translate="yes">
          <source>► &lt;code&gt;"ES2019"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES2019"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c62ac10a4e5b6c10f9f224b1e0c279b3da2b58" translate="yes">
          <source>► &lt;code&gt;"ES2020"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES2020"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fe0b45017dd07d79a42743156565f74166c803d" translate="yes">
          <source>► &lt;code&gt;"ES3"&lt;/code&gt; (default)</source>
          <target>►&lt;code&gt;"ES3"&lt;/code&gt;(デフォルト)</target>
        </trans-unit>
        <trans-unit id="4a34795d0f52d8627a7ec5625a55045ffb89d7b7" translate="yes">
          <source>► &lt;code&gt;"ES5"&lt;/code&gt;</source>
          <target>►&lt;コード&gt;"ES5"&lt;/コード&gt;</target>
        </trans-unit>
        <trans-unit id="a8353801bfcf5cd79ca98d4a774cf1525b9099cb" translate="yes">
          <source>► &lt;code&gt;"ES6"&lt;/code&gt; and &lt;code&gt;"ES2015"&lt;/code&gt; values may be used when targeting &lt;code&gt;"ES5"&lt;/code&gt; or lower.</source>
          <target>►&lt;code&gt;"ES6"&lt;/code&gt;および&lt;code&gt;"ES2015"&lt;/code&gt;の値は、&lt;code&gt;"ES5"&lt;/code&gt;以下をターゲットとする場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="22e296cadc43597f012d962e8f215881066d8d5a" translate="yes">
          <source>► &lt;code&gt;"ES6"&lt;/code&gt;/&lt;code&gt;"ES2015"&lt;/code&gt;</source>
          <target>►&lt;code&gt;"ES6"&lt;/code&gt;/&lt;code&gt;"ES2015"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="047dae9d8977c7474a051fab3035bb18cdee25a7" translate="yes">
          <source>► &lt;code&gt;"ESNext"&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;"ESNext"&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84c3e9b824cec124f9a334707c8a2b9f460359d7" translate="yes">
          <source>► &lt;code&gt;DOM.Iterable&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;DOM.Iterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5da450217b3988083f83848bce88ea3c0db00bfa" translate="yes">
          <source>► &lt;code&gt;DOM&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;DOM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71641a4e3e65d9565ae285bfe5db1b08f249d527" translate="yes">
          <source>► &lt;code&gt;ES2015.Collection&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Collection&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ccab9e33c3ac66ca1dd886021b7283638741de9" translate="yes">
          <source>► &lt;code&gt;ES2015.Core&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4486602759448f6e0380d9560516b0053176db8" translate="yes">
          <source>► &lt;code&gt;ES2015.Generator&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Generator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0385ae39bb3546c48e96e8f720a220fba48631ff" translate="yes">
          <source>► &lt;code&gt;ES2015.Iterable&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Iterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5171b5df1d691451f9abdc41d74e1bcf3c2cac9" translate="yes">
          <source>► &lt;code&gt;ES2015.Promise&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Promise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="496aa0d98970bebeb2de723fb450beee1791314d" translate="yes">
          <source>► &lt;code&gt;ES2015.Proxy&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Proxy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa0ee38b852f3bdb04109824a177f7e3d3d6386" translate="yes">
          <source>► &lt;code&gt;ES2015.Reflect&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Reflect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112847064b33c2ad0e58bd6929c57aa54e65b08f" translate="yes">
          <source>► &lt;code&gt;ES2015.Symbol.WellKnown&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Symbol.WellKnown&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8044dac1e33a7520ef3f7267ab13ffb018873f04" translate="yes">
          <source>► &lt;code&gt;ES2015.Symbol&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="debc8254100406c5b68cd5702db34e72209e2f8d" translate="yes">
          <source>► &lt;code&gt;ES2015&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78126259e0963688ebb08f36a73d6c799b073eec" translate="yes">
          <source>► &lt;code&gt;ES2016.Array.Include&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2016.Array.Include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e9a7ec10d0799c7a3562b7bbb313750b7a289db" translate="yes">
          <source>► &lt;code&gt;ES2016&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2016&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a665a55ca393bb2b96c73c5e204e2aef365467cd" translate="yes">
          <source>► &lt;code&gt;ES2017.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8eaaf2137eaa25170c70ba6286e2d33a38fed7b2" translate="yes">
          <source>► &lt;code&gt;ES2017.SharedMemory&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.SharedMemory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d17cc488545495baaa08dc61e669b6ddf908f5b7" translate="yes">
          <source>► &lt;code&gt;ES2017.String&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdb646c3bedbcc29d8be079d57fe5ac3a60ea079" translate="yes">
          <source>► &lt;code&gt;ES2017.TypedArrays&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.TypedArrays&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="218a64ec3941de7aa91db9c205e1758ec508c6dd" translate="yes">
          <source>► &lt;code&gt;ES2017.object&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12e6badb0024de3123266d40221edae5660ea99e" translate="yes">
          <source>► &lt;code&gt;ES2017&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3074fab26a5e8d10900ec2d6d1eac19c6549c9ac" translate="yes">
          <source>► &lt;code&gt;ES2018.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="844e0de281a761a5d92adac4e473d8eb93d6019e" translate="yes">
          <source>► &lt;code&gt;ES2018.Promise&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.Promise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0761ef5b4729a2ef5d15a9a058729752fea1133c" translate="yes">
          <source>► &lt;code&gt;ES2018.RegExp&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.RegExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f57fe015079a86ed931fe29d12ebca670336e37" translate="yes">
          <source>► &lt;code&gt;ES2018&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c53f2e0cec43a786e37978cbdeed0943a7737d81" translate="yes">
          <source>► &lt;code&gt;ES5&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3c9b000aa4d3de66e7fd3aa6b44859fdcd4f7a4" translate="yes">
          <source>► &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4c27add263135ed08f5caf37050bac935c7b692" translate="yes">
          <source>► &lt;code&gt;ES7&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d15b1612ad531e0a4b75b9e54f4adcd7c3c12c42" translate="yes">
          <source>► &lt;code&gt;ESNext.Array&lt;/code&gt;</source>
          <target>►&lt;code&gt;ESNext.Array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8dff6beee12a2b287f35eab806bdb12a6be847fa" translate="yes">
          <source>► &lt;code&gt;ESNext.AsyncIterable&lt;/code&gt;</source>
          <target>►&lt;code&gt;ESNext.AsyncIterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a5fa85e735a190cd054468ff644c46914ff3674" translate="yes">
          <source>► &lt;code&gt;ESNext.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df412653808d06029700eb4304fb7614577752bb" translate="yes">
          <source>► &lt;code&gt;ESNext.Symbol&lt;/code&gt;</source>
          <target>►&lt;code&gt;ESNext.シンボル&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1663a21aa10900239c2ae707fb3128d4eb2eb6c" translate="yes">
          <source>► &lt;code&gt;ESNext&lt;/code&gt;</source>
          <target>►&lt;code&gt;ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6584792a54e8be52a8f0764a167be7103b57f075" translate="yes">
          <source>► &lt;code&gt;ScriptHost&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e94b9e04cb8b1657f6c51540bd4e392f524e23ca" translate="yes">
          <source>► &lt;code&gt;WebWorker&lt;/code&gt;</source>
          <target>►&lt;code&gt;WebWorker&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="048dc6e23b9b641360a0028bca639bba6cc9378f" translate="yes">
          <source>► Czech: &lt;code&gt;cs&lt;/code&gt;</source>
          <target>►チェコ語:&lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71f77828941d25c5ac040a5a040581f80b6166b6" translate="yes">
          <source>► English (US): &lt;code&gt;en&lt;/code&gt;</source>
          <target>►英語(US):&lt;code&gt;en&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34d60307389f13e914979ca86d4c55fb798d063a" translate="yes">
          <source>► For &lt;code&gt;--target ES5&lt;/code&gt;: &lt;code&gt;DOM,ES5,ScriptHost&lt;/code&gt;</source>
          <target state="translated">►&lt;code&gt;--target ES5&lt;/code&gt;:&lt;code&gt;DOM,ES5,ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="705f262e39e23028473369800bface249c036bc4" translate="yes">
          <source>► For &lt;code&gt;--target ES6&lt;/code&gt;: &lt;code&gt;DOM,ES6,DOM.Iterable,ScriptHost&lt;/code&gt;</source>
          <target state="translated">►&lt;code&gt;--target ES6&lt;/code&gt;:&lt;code&gt;DOM,ES6,DOM.Iterable,ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9befa02c3588bb3adb57741308a907a417ffb48" translate="yes">
          <source>► French: &lt;code&gt;fr&lt;/code&gt;</source>
          <target>►フランス語:&lt;code&gt;fr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f363eac4c80ca485f6ef894da55b93819cc82a9" translate="yes">
          <source>► German: &lt;code&gt;de&lt;/code&gt;</source>
          <target>►ドイツ語:&lt;code&gt;de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07c1d6e417eec863289b4c3a383eed1cf747da60" translate="yes">
          <source>► Italian: &lt;code&gt;it&lt;/code&gt;</source>
          <target>►イタリア語:&lt;code&gt;it&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="953321065891c804824f20c999c4524003717550" translate="yes">
          <source>► Japanese: &lt;code&gt;ja&lt;/code&gt;</source>
          <target>►日本語:&lt;code&gt;ja&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f9c395abbce8017dc3cd8d4a435483e66ae7a69" translate="yes">
          <source>► Korean: &lt;code&gt;ko&lt;/code&gt;</source>
          <target>►韓国語:&lt;code&gt;ko&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f7879eed2ae7c8be2c64ee7adbfa4e2dc1475f8" translate="yes">
          <source>► Only &lt;code&gt;"AMD"&lt;/code&gt; and &lt;code&gt;"System"&lt;/code&gt; can be used in conjunction with &lt;code&gt;--outFile&lt;/code&gt;.</source>
          <target>►&lt;code&gt;--outFile&lt;/code&gt;と組み合わせて使用できるのは、&lt;code&gt;"AMD"&lt;/code&gt;および&lt;code&gt;"System"&lt;/code&gt;だけです。</target>
        </trans-unit>
        <trans-unit id="333d90759221353a8acd3bf17a36dac6afed796f" translate="yes">
          <source>► Polish: &lt;code&gt;pl&lt;/code&gt;</source>
          <target>►ポーランド語:&lt;code&gt;pl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51f366bfbd6e88e5b63d40f9a7d63a7487000fb5" translate="yes">
          <source>► Portuguese(Brazil): &lt;code&gt;pt-BR&lt;/code&gt;</source>
          <target>►ポルトガル語(ブラジル):&lt;code&gt;pt-BR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="449b0bf7aea26b130bc83417a80f42ebcb84e8aa" translate="yes">
          <source>► Russian: &lt;code&gt;ru&lt;/code&gt;</source>
          <target>►ロシア語:&lt;code&gt;ru&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d31f80bee83c17d3ffbb6a6553b8204f0de8c1f" translate="yes">
          <source>► Simplified Chinese: &lt;code&gt;zh-CN&lt;/code&gt;</source>
          <target>►簡体字中国語:&lt;code&gt;zh-CN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd8652669d33790313d668b077beb663ad641b2" translate="yes">
          <source>► Spanish: &lt;code&gt;es&lt;/code&gt;</source>
          <target>►スペイン語:&lt;code&gt;es&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78fa8f5dcdcac9d793bf90012a070be47765d3e0" translate="yes">
          <source>► Traditional Chinese: &lt;code&gt;zh-TW&lt;/code&gt;</source>
          <target>►繁体字中国語:&lt;code&gt;zh-TW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e808ba97d84c3ea43476d7234bfb3dd8344f418b" translate="yes">
          <source>► Turkish: &lt;code&gt;tr&lt;/code&gt;</source>
          <target>►トルコ語:&lt;code&gt;tr&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
