<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; の次の使用は機能することが想定されています（つまり、誤ったコンパイル時または実行時のクラッシュにつながりません）。</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">コンパイラーによって生成された派生インスタンスはボックス化されていないタプル構文を使用するため、以下は「無効なボックス化されていないタプル」エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の動作を変更したフォローアップディスカッションはここにアーカイブされています：&lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;提案：Data.Mapのガンフォールドを許可...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;C(..)&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; はクラス、名前のクラスである &lt;code&gt;C&lt;/code&gt; およびそのすべての方法&lt;em&gt;および関連するタイプ&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">フォーム &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; はクラス、名前クラスで &lt;code&gt;C&lt;/code&gt; 、および指定されたメソッド &lt;code&gt;mi&lt;/code&gt; と関連するタイプ &lt;code&gt;Tj&lt;/code&gt; を。タイプには、データコンストラクターと区別するためのキーワード「 &lt;code&gt;type&lt;/code&gt; 」が必要です。</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;T(..)&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; はデータファミリー名ファミリーである &lt;code&gt;T&lt;/code&gt; とのデータのインスタンスであるすべてのスコープ内のコンストラクタ（範囲における修飾または非修飾するかどうか） &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">&lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; の形式で、 &lt;code&gt;T&lt;/code&gt; はデータファミリーであり、通常のように &lt;code&gt;T&lt;/code&gt; と指定されたコンストラクター &lt;code&gt;ci&lt;/code&gt; およびフィールド &lt;code&gt;fj&lt;/code&gt; を指定します。コンストラクターとフィールド名は &lt;code&gt;T&lt;/code&gt; のデータインスタンスに属している必要がありますが、&lt;em&gt;同じ&lt;/em&gt;インスタンスに属している必要はありません。</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">&lt;a href=&quot;#gadt&quot;&gt;一般化代数データ型（GADT）&lt;/a&gt;で説明されている一般化代数データ型はこのフォームを使用してのみ宣言できるため、このフォームは「GADTスタイル宣言」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">先頭に型変数を持つフォームではこれが可能です。</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">フォーマット文字 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; が呼び出されました。この文字がタイプと一致しない限り、 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; は失敗します。単一のタイプに対して多くの異なるフォーマット文字を処理するのは通常のことです。</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">GHCがタイプチェックされたASTを現在格納している形式では、一部の式ノードのタイプを収集するのにコストがかかります。パフォーマンスのために、GHCは現在これらをスキップすることを選択しているため、すべての式ノードが型情報を持っているとは限りません。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;問題＃16233&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">ログファイルのフォーマットは、GHCに付属するヘッダー &lt;code&gt;EventLogFormat.h&lt;/code&gt; によって記述され、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;ライブラリを使用してHaskellで解析できます。 &lt;code&gt;.eventlog&lt;/code&gt; ファイルの内容をテキストとしてダンプするには、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;パッケージに付属の &lt;code&gt;ghc-events show&lt;/code&gt; ツールを使用します。</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">フォーマット文字列は、通常の文字と&lt;em&gt;変換指定&lt;/em&gt;で構成され、出力文字列で &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; の引数の1つをフォーマットする方法を指定します。フォーマット指定は &lt;code&gt;%&lt;/code&gt; 文字によって導入されます。この文字は、 &lt;code&gt;%%&lt;/code&gt; を使用してフォーマット文字列に自己エスケープできます。フォーマット指定は、値のフォーマット方法に関する主要な情報を提供する&lt;em&gt;フォーマット文字&lt;/em&gt;で終わります。残りの変換指定はオプションです。順番に、フラグ文字、幅指定子、精度指定子、および型固有の修飾子文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">前者の方がはるかに良いコードになります。</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">非表示や &lt;code&gt;as&lt;/code&gt; 句など、Haskellの完全なインポート構文がサポートされ &lt;code&gt;hiding&lt;/code&gt; ます。プロンプトを示し、現在インポートされたモジュールが、それは詳細について省略 &lt;code&gt;hiding&lt;/code&gt; 、 &lt;code&gt;as&lt;/code&gt; などを。全文を表示するには、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">警告オプションの完全なセットを以下に説明します。警告をオフにするには、コマンドラインで対応する &lt;code&gt;-Wno-...&lt;/code&gt; オプションを指定します。8.0より前のGHCバージョンとの下位互換性のために、これらの警告はすべて、 &lt;code&gt;-W(no-)*&lt;/code&gt; ではなく &lt;code&gt;-f(no-)warn-*&lt;/code&gt; で制御できます。</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">型が宣言されているモジュールの完全修飾名</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; に似ていますが、&lt;em&gt;例外の述語&lt;/em&gt;である追加の引数を受け取ります。これは、対象となる&lt;em&gt;例外の&lt;/em&gt;タイプを選択する関数です。</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; は複素数を取り、（大きさ、位相）のペアを正準形式で返します。大きさは負ではなく、範囲 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; の位相です。大きさがゼロの場合、位相も同様です。</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; が &lt;code&gt;(m,n)&lt;/code&gt; 生成する場合、 &lt;code&gt;x&lt;/code&gt; の値は &lt;code&gt;m*b^^n&lt;/code&gt; と等しく、ここで &lt;code&gt;b&lt;/code&gt; は浮動小数点の基数であり、さらに、 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の両方がゼロであるか、または &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; が &lt;code&gt;(m,n)&lt;/code&gt; 生成する場合、 &lt;code&gt;x&lt;/code&gt; の値は &lt;code&gt;m*b^^n&lt;/code&gt; と等しく、ここで &lt;code&gt;b&lt;/code&gt; は浮動小数点の基数であり、さらに、 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の両方がゼロであるか、または &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">関数 &lt;code&gt;coerce&lt;/code&gt; を使用すると、ランタイムオーバーヘッドなしで同じ表現を持つ型の値間で安全に変換できます。最も単純なケースでは、newtypeコンストラクターの代わりにそれを使用して、newtypeの具象型から抽象型に移動できます。しかし、より複雑な設定でも機能します。たとえば、newtypeのリストを具象型のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">関数 &lt;code&gt;f3&lt;/code&gt; にはランク3タイプがあります。関数矢印の左側にランク2タイプがあります。</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">以下の関数 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; に適用すると失敗するため、&lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;f&lt;/code&gt; には、より正確なタイプがあります。</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;fromList&lt;/code&gt; は、与えられた &lt;code&gt;Item l&lt;/code&gt; のリストから構造 &lt;code&gt;l&lt;/code&gt; を構築します。</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">関数 &lt;code&gt;fromListN&lt;/code&gt; は、入力リストの長さをヒントとして受け取ります。その動作は &lt;code&gt;fromList&lt;/code&gt; と同等でなければなりません。ヒントを使用すると、 &lt;code&gt;fromList&lt;/code&gt; と比較して、構造体 &lt;code&gt;l&lt;/code&gt; をより効率的に構築できます。指定されたヒントが入力リストの長さに等しくない場合、 &lt;code&gt;fromListN&lt;/code&gt; の動作は指定されません。</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;g&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の型が2つの引数の異なる型を持つことを許可していないため、期待通りに型エラーで拒否されます。次に、これは、あいまいさの問題なしに実際に非常にうまく機能する複数のパラメータークラスの例です。ただし、落とし穴があります。このバージョンの &lt;code&gt;Collects&lt;/code&gt; クラスは、元のクラスのように一般的ではありません。上記の &lt;code&gt;Collects&lt;/code&gt; の4つのインスタンスのうち1つだけがこのバージョンのCollectsで使用できます。型コンストラクター &lt;code&gt;c&lt;/code&gt; の &lt;code&gt;c e&lt;/code&gt; の形式で記述できるコレクション型、および要素型 &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;toList&lt;/code&gt; の逆でなければなりません &lt;code&gt;fromList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">関数 &lt;code&gt;unsafeCoerce#&lt;/code&gt; を使用すると、タイプチェッカーを完全に回避できます。つまり、任意の型を他の任意の型に強制変換できます。この関数を使用する場合は、正しく設定することをお勧めします。そうしないと、セグメンテーション違反が発生します。よく型付けされていることがわかっているプログラムを作成したいが、Haskellの型システムが十分に型付けされていることを証明するのに十分な表現力がない場合に、一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">この関数は、2つの新しいハンドルも返します。*イベントがシグナルされるI/O完了ポートハンドル。*実行中のプロセスをすべて終了させるために使用できるジョブハンドル。</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">関数 &lt;code&gt;infixr&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; は、固定度-1のinfixrです。</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">この関数は、ReadWrite モードで一時ファイルを作成します。作成されたファイルは自動的には削除されないので、手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">この関数はパスが存在するかどうかを検証しません。</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">この関数は、全体の順序を定義することを前提としています。</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">パーサを適用する関数は、モナド変換器を順番にアンラップしていく必要があります。</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">環境を修正する機能です。</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">関数型のコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">この関数は、対応する値を返します &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; キーがマップにない場合。</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は平等関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は等値関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">関数 &lt;code&gt;f2&lt;/code&gt; および &lt;code&gt;g2&lt;/code&gt; には、ランク2タイプがあります。 &lt;code&gt;forall&lt;/code&gt; 、関数矢印の左側にあります。 &lt;code&gt;g2&lt;/code&gt; に示すように、関数矢印の左側の多型のタイプは、オーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; の本体は同じですが、型シグネチャが与えられるのは &lt;code&gt;f&lt;/code&gt; だけです。GHCが可視型アプリケーションを処理する方法を理解するとき、インスタンス化する変数を知っている必要があります。したがって、関数の型の型変数に順序付けを提供できる必要があります。</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;g5&lt;/code&gt; と &lt;code&gt;g6&lt;/code&gt; はまったく同じ意味です。しかし、 &lt;code&gt;g7&lt;/code&gt; は &lt;code&gt;(f x)&lt;/code&gt; 評価し、 &lt;code&gt;y&lt;/code&gt; を結果にバインドしてから、 &lt;code&gt;body&lt;/code&gt; を評価します。</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">関数&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strictは&lt;/a&gt;、それらをインストールする前に値を強制的に注意を払っている &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;の関数は、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; にインストールする前に値を強制するように注意しています。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">このライブラリの関数は、以下の命名規則を使用しています。</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">このモジュールの関数は、ランタイムシステムのロケール、文字セットのエンコーディング、行末変換の設定に従います。</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">一般的な形式は &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; です。ここで、 &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">一般的なインターフェイス</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">一般的な原則はこれです。</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">アノテーションをサポートする一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">以下のために生成されたコード &lt;code&gt;Functor Wrong&lt;/code&gt; インスタンスはを除いて、まったく同じになります &lt;code&gt;Wrong&lt;/code&gt; のすべての出現置き換える &lt;code&gt;Right&lt;/code&gt; 。問題は、 &lt;code&gt;fmap&lt;/code&gt; が &lt;code&gt;Either a Int&lt;/code&gt; 型の値に再帰的に適用されていることです。これは、おそらく型の値を生成することができない &lt;code&gt;Either b Int&lt;/code&gt; 通り、 &lt;code&gt;fmap&lt;/code&gt; のみ最後の型パラメータを変更することができます！これにより、生成されたコードの型が不適切になります。</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">このGCの世代番号</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">ここでの目標は、にある &lt;code&gt;lift&lt;/code&gt; モナドから &lt;code&gt;m&lt;/code&gt; へ &lt;code&gt;t2 m&lt;/code&gt; 、その後、 &lt;code&gt;lift&lt;/code&gt; に再びこれを &lt;code&gt;t1 (t2 m)&lt;/code&gt; 。ただし、この2番目の &lt;code&gt;lift&lt;/code&gt; は、 &lt;code&gt;(t2 m)&lt;/code&gt; がモナドである場合にのみ受け入れることができ、この事実が普遍的に当てはまることを確立する方法はありません。</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">目標は、 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; よりもパスの意味を維持することです。</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">役割システムの目標は、2つのタイプが同じ基本的な表現を持っている場合を追跡することです。上記の例では、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; は同じ表現を持っています。ただし、 &lt;code&gt;bad&lt;/code&gt; の実装のタイプが異なるため、 &lt;code&gt;BadIdea&lt;/code&gt; の対応するインスタンスは同じ表現にはなり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">型付き穴の目的は、型システムを変更することではなく、Haskellのコードを書くのを助けることです。型付き穴は、型チェッカーから余分な情報を得るために使用することができます。通常、GHCiを使うと、ユーザはすべてのトップレベルバインディングの(推測される)型シグネチャを検査することができます。しかし、この方法はトップレベルで定義されていない用語や複雑な式の内部ではあまり便利ではありません。穴を使うと、ユーザーはこれから書こうとしている用語の型をチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">ゴリゴリのディテール。</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">文法はラムダ抽象、let式、条件式の範囲に関して曖昧です。この曖昧さは、これらの構文のそれぞれが可能な限り右に伸びるというメタルールによって解決されています。</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">すべての辺を反転させて得られるグラフ。</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">グラフ:キーによって一意に識別されるノードのリスト.アウトリストには,グラフのノードに対応しないキーが含まれている場合があり,そのようなエッジは無視されます.</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">グループデータベース</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">ハッシュ記号はセマンティクスをまったく変更しません。ボックス化されていない値または型（ &lt;code&gt;Int#&lt;/code&gt; など）には、「＃」で終わる変数名を使用する傾向がありますが、そうする必要はありません。それらは単なる普通の変数です。また、&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;拡張機能は何も対象外とします。たとえば、 &lt;code&gt;Int#&lt;/code&gt; をスコープに &lt;code&gt;GHC.Prim&lt;/code&gt; インポートする必要があります（&lt;a href=&quot;#primitives&quot;&gt;ボックス&lt;/a&gt;化されていない型とプリミティブ操作を参照）。&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; の&lt;/a&gt;拡張子は、あなたがすることができます&lt;em&gt;参照してください&lt;/em&gt;に &lt;code&gt;Int#&lt;/code&gt; スコープになりました。このオプションを使用すると、 &lt;code&gt;x#y = 0&lt;/code&gt; 意味が変更されることに注意してください。単一の引数を取る関数 &lt;code&gt;x#&lt;/code&gt; を定義します。 &lt;code&gt;y&lt;/code&gt; ; 演算子 &lt;code&gt;#&lt;/code&gt; を定義するには、スペースを入れます： &lt;code&gt;x # y = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">ヘッダー行の後には、(引用符で囲まれた)文字列リテラルとしてエンコードされた1つの補完候補を含む⟨l⟩行が続きます。ここでは、様々なケースを示すいくつかの呼び出し例を示します。</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">署名のヘッダーは、署名 &lt;code&gt;signature A where ...&lt;/code&gt; （通常の &lt;code&gt;module A where ...&lt;/code&gt; 代わり）です。</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">ヒーププロファイラーは、GHCのイベントログに出力を生成し、サンプルをプログラムのライフサイクルを通じて他のイベントログイベントと関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">ヒープオーバーフローメッセージ。</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">浮動小数点リテラルの16進数表記は、浮動小数点定数を正確に指定する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">履歴は&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; を&lt;/a&gt;使用する場合にのみ利用できます。これは、履歴の各ブレークポイントをログに記録すると、パフォーマンスが2倍以上低下することがわかったためです。</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">hpcコマンドにはいくつかのサブコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">hpcツールは、アプリケーションを構築した場所の最上位ディレクトリにいること、および &lt;code&gt;.tix&lt;/code&gt; ファイルが同じ最上位ディレクトリにあることを前提としています。フラグ &lt;code&gt;--srcdir&lt;/code&gt; を使用すると、他のディレクトリに &lt;code&gt;hpc&lt;/code&gt; を使用できます。また、 &lt;code&gt;--srcdir&lt;/code&gt; 複数回使用すると、パッケージで一般的なように、異なる場所からコンパイルされたプログラムを分析できます。</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">考えは、 &lt;code&gt;a&lt;/code&gt; は実際には表現的なパラメータであるべきだということですが、役割の推論はそれをファントムに割り当てます。これは感覚のいくつかのレベルを行いますへのポインタ &lt;code&gt;Int&lt;/code&gt; 本当にrepresentationallyへのポインタと同じである &lt;code&gt;Bool&lt;/code&gt; 。しかし、それは &lt;code&gt;Ptr&lt;/code&gt; を使用したい方法ではありません！だから、私たちは言うことができるようにしたいです</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">これで、2つのフィールド &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; で新しいデータ型 &lt;code&gt;MyPoint&lt;/code&gt; を定義した場合と同じように、 &lt;code&gt;Point&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">これは、 &lt;code&gt;RuntimeRep&lt;/code&gt; によってパラメーター化される新しい基本型定数 &lt;code&gt;TYPE&lt;/code&gt; があるという考え方です。したがって、 &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; および &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; ます。 &lt;code&gt;TYPE x&lt;/code&gt; の形式のタイプを持つものはすべて、関数矢印 &lt;code&gt;-&amp;gt;&lt;/code&gt; のどちらの側にも表示できます。したがって、 &lt;code&gt;-&amp;gt;&lt;/code&gt; の型は &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; ます。GHCではすべての機能が解除されるため、結果は常に解除されます。</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">すべての呼び出しはあいまいな制約を引き起こすため、 &lt;code&gt;f&lt;/code&gt; への正当な呼び出しはあり得ないという考えです。実際、あいまいさチェックの&lt;em&gt;唯一の&lt;/em&gt;目的は、呼び出すことができない可能性のある関数を報告することです。型のシグネチャのあいまいさチェックを完全に省略することができますが、呼び出しサイトへのあいまいさエラーを遅らせます。実際、言語拡張&lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt;は、あいまいさチェックをオフにします。</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">データ型宣言で実存的数量化を使用するという考えは、ペリーによって提案され、Hope +で実装されました（Nigel Perry、&lt;em&gt;実践的な関数型プログラミング言語の実装&lt;/em&gt;、博士論文、ロンドン大学、1991）。それは後にLauferとOdersky によって形式化されました（&lt;em&gt;ポリモーフィック型推論と抽象データ型&lt;/em&gt;、TOPLAS、16（5）、pp。1411-1430、1994）。これは数年前からLennart Augustssonの &lt;code&gt;hbc&lt;/code&gt; Haskellコンパイラにあり、非常に有用であることが証明されています。これがアイデアです。宣言を検討してください：</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">アロー表記で &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; の役割を果たすアイデンティティーアロー。</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">アイデンティティファンクタとモナド。</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">アイデンティティモナド変換器</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">アイデンティティモナド変換器。</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">実装はシステムコールをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">に基づいて実装されています。</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズのバランスのとれたマップ実装と比較すると、挿入と削除の速度が（はるかに）速いことを示しています（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズのバランスのとれたマップ実装と比較すると、挿入と削除の速度が（はるかに）速いことを示しています（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズのバランスのとれたマップ実装と比較すると、挿入と削除の速度が（はるかに）速いことを示しています（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたマップ実装（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）と比較すると、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較して、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較して、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">実装は、償却されたO(1)のenqueueとdequeue操作を得るために2つのリストを使用する伝統的な純粋に機能的なキュー表現に基づいています。</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">実装は、メモリ操作の並べ替えによってタイプが正しいコードが間違って実行されないようにするために必要です。特に、 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; から読み取られた値を検査する場合、その値を作成したメモリへの書き込みは、現在のスレッドの観点から発生している必要があります。</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; に渡された関数がその引数を検査する場合、結果のアクションは &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; メッセージの実装</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; メッセージの実装：新しいIORef QStateを作成し、それにRemoteRefを返します。</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">の 4.2 節で説明されているように、実装ではサイズでアノテーションされた 2-3 本のフィンガーツリーを使用しています。</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">実装はプロファイラーによって維持される呼び出しスタックシミュレーションを使用するため、プログラムが &lt;code&gt;-prof&lt;/code&gt; でコンパイルされ、適切なSCC注釈が含まれている場合（ &lt;code&gt;-fprof-auto&lt;/code&gt; を使用するなど）にのみ機能します。そうでない場合、返されるリストは空であるか、情報がない可能性があります。</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">入力 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; を使用して変換され、次に &lt;code&gt;encode'&lt;/code&gt; を使用して汎用インスタンスにディスパッチします。これを &lt;code&gt;encode&lt;/code&gt; のデフォルト定義として使用します。通常のHaskellのデフォルトメソッドでは追加のクラス制約を導入してはならないので、 &lt;code&gt;default encode&lt;/code&gt; シグネチャが必要ですが、一般的なデフォルトでは導入します。</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">インクリメンタル入力インターフェース</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">インクリメンタルインターフェイスは、厳密な &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を一度に消費し、それぞれが入力の合計量の一部です。デコーダーが終了するためにより多くの入力を必要とする場合、継続を伴う &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; を返します。これ以上入力がない場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を指定してください。</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">インクリメンタルインターフェースを使用すると、解析中に入力がどのように提供されるかをより制御することができます。これにより、例えばパースやI/Oをインターリーブすることができます。</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">情報は、タイプ &lt;code&gt;[(String, String)]&lt;/code&gt; として読み取れるようにフォーマットされます。現在、次のフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">初期カウンター値は、カウンターバランスするためにそれぞれの量の &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; 操作を必要とするリソース「借金」を示す負の値にすることができます。</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">カーソルの左右の初期値</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">初期化ルーチン &lt;code&gt;mylib_init&lt;/code&gt; は、通常どおり &lt;code&gt;hs_init()&lt;/code&gt; を呼び出してHaskellランタイムを初期化し、対応する非初期化関数 &lt;code&gt;mylib_end()&lt;/code&gt; は &lt;code&gt;hs_exit()&lt;/code&gt; を呼び出してランタイムをシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="74ecac49867880c39edcc9122f73fce73221a98f" translate="yes" xml:space="preserve">
          <source>The input file should end with .hsc (it should be plain Haskell source only; literate Haskell is not supported at the moment). Output files by default get names with the &lt;code&gt;.hsc&lt;/code&gt; suffix replaced:</source>
          <target state="translated">入力ファイルは.hscで終わる必要があります（これはプレーンなHaskellソースのみである必要があります。現時点では、読み書き可能なHaskellはサポートされていません）。デフォルトでは、出力ファイルは &lt;code&gt;.hsc&lt;/code&gt; サフィックスが置き換えられた名前を取得します。</target>
        </trans-unit>
        <trans-unit id="54a5800cd273f30522c8241f5237a75f5ea6ce1e" translate="yes" xml:space="preserve">
          <source>The input lines stored in the history (newest first)</source>
          <target state="translated">履歴に格納されている入力行(新しい順</target>
        </trans-unit>
        <trans-unit id="6c739498395288f23756ffacf049c5d728041bb8" translate="yes" xml:space="preserve">
          <source>The input prompt</source>
          <target state="translated">入力プロンプト</target>
        </trans-unit>
        <trans-unit id="57092b7ab7c2a987bc9c90336b0ad9cdf5249eb0" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーの原因となった入力値。入力の終わりに達したか、正確に識別できなかったためにエラーが発生した場合、この値は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="38d4405c8eebc2938893eeda1606e7e5691e0dd1" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;rdquo;.hs&amp;rdquo; and &amp;rdquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">Win32にGHCをインストールするインストーラーは、「。hs」および「.lhs」ファイルのファイル拡張子の関連付けも設定するため、それらをダブルクリックすると &lt;code&gt;ghci&lt;/code&gt; が起動します。</target>
        </trans-unit>
        <trans-unit id="aeaab7d9918fe1175bfdf3172a8ff60d6d574ffa" translate="yes" xml:space="preserve">
          <source>The instance axioms : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</source>
          <target state="translated">インスタンスの公理： &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d82e643d691468293fcd6f5135cfe7a24d9a1" translate="yes" xml:space="preserve">
          <source>The instance context is determined by the type signatures of the derived class&amp;rsquo;s methods. For instance, if the class is:</source>
          <target state="translated">インスタンスコンテキストは、派生クラスのメソッドの型シグネチャによって決定されます。たとえば、クラスが次の場合：</target>
        </trans-unit>
        <trans-unit id="ead7524ad446883d4bbd99873e64016bb63c69da" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;lsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s definition.</source>
          <target state="translated">インスタンス宣言は、タイプ &lt;code&gt;T&lt;/code&gt; が使用されている場合にのみ関連します。使用されている場合、GHCは &lt;code&gt;A&lt;/code&gt; のインターフェースファイルにアクセスして &lt;code&gt;T&lt;/code&gt; の定義を検索します。</target>
        </trans-unit>
        <trans-unit id="c7c21710f81c09d49133c941cdff45d1b58bd4f0" translate="yes" xml:space="preserve">
          <source>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">一つのプログラムで使用されるデータファミリのインスタンス宣言は、それらが関連付けられているかどうかに関係なく、全く重ならないことがあります。型クラスのインスタンスとは対照的に、これは一貫性の問題だけでなく、型の安全性の問題でもあります。</target>
        </trans-unit>
        <trans-unit id="8cc7dac373c8ecc1b365857145ddad40214eea96" translate="yes" xml:space="preserve">
          <source>The instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is slightly awkward (but also rarely used):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスは少し厄介です（ただし、ほとんど使用されません）。</target>
        </trans-unit>
        <trans-unit id="289b8b3ebc33cd2f4157166d16a368f79f089f26" translate="yes" xml:space="preserve">
          <source>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Associated type synonym defaults&lt;/a&gt;), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as &lt;code&gt;undefined&lt;/code&gt;, can assume the type.</source>
          <target state="translated">関連する型のインスタンスは、クラスインスタンスでは省略できます。その場合、デフォルトのインスタンスがない限り（&lt;a href=&quot;#assoc-decl-defs&quot;&gt;関連するタイプのシノニムのデフォルトを&lt;/a&gt;参照）、対応するインスタンスタイプは存在しません。つまり、 &lt;code&gt;undefined&lt;/code&gt; などの発散式のみが型を想定できます。</target>
        </trans-unit>
        <trans-unit id="59904cb0ab2fe8f19f68bd984f2b517b8091cc17" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Preludeで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="585199a1b65eac2628d79ac97b369b88ce05f950" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Preludeで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="1581053810276ec21d30df3978e3008a7ff9fc55" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Preludeで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="1a017b052435df19797d88fb110f1e8782d90594" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Preludeで&lt;/a&gt;定義されたリスト、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; のインスタンスは、これらの法律を満たしています。</target>
        </trans-unit>
        <trans-unit id="f9f0c8e6289e586cc5baeea5fcfbbbe115d5e7f6" translate="yes" xml:space="preserve">
          <source>The intention is for &lt;code&gt;IsLabel&lt;/code&gt; to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular &lt;code&gt;(-&amp;gt;)&lt;/code&gt;) in the future.</source>
          <target state="translated">意図は、 &lt;code&gt;IsLabel&lt;/code&gt; がオーバーロードされたレコードフィールドおよびおそらく匿名レコードをサポートするために使用されることです。したがって、将来、基本データ型（特に &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ）のインスタンスが与えられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="26b1329858bfddb7f19887db1797b6a20a449184" translate="yes" xml:space="preserve">
          <source>The interact function takes a function of type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">対話関数は、引数として &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; 型の関数を取ります。標準入力デバイスからの入力全体が引数としてこの関数に渡され、結果の文字列が標準出力デバイスに出力されます。</target>
        </trans-unit>
        <trans-unit id="28bb27e789e236bd63cc99925076154513d01eb7" translate="yes" xml:space="preserve">
          <source>The interactive classes (only relevant when &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; is in effect) are: any numeric class, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Traversable&lt;/code&gt;.</source>
          <target state="translated">対話型クラス（&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;が有効な場合にのみ関連）は、数値クラス、 &lt;code&gt;Show&lt;/code&gt; 、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Foldable&lt;/code&gt; または &lt;code&gt;Traversable&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0c15d5fb52d82aa70762f462a28f7dddcf408ca0" translate="yes" xml:space="preserve">
          <source>The interface file, which normally ends in a &lt;code&gt;.hi&lt;/code&gt; suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don&amp;rsquo;t try to read one; use the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option instead (see &lt;a href=&quot;#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">通常は &lt;code&gt;.hi&lt;/code&gt; サフィックスで終わるインターフェースファイルには、このモジュールに依存するモジュールをさらにコンパイルするためにGHCが必要とする情報が含まれています。エクスポートされた関数のタイプ、データタイプの定義などが含まれます。バイナリ形式で格納されているため、読み取らないでください。使用 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; オプションが（参照代わりに&lt;a href=&quot;#hi-options&quot;&gt;インタフェースファイルに関連するその他のオプションを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="01f926777c79e4e6d52fb1a2cf6afecc0a8b7f65" translate="yes" xml:space="preserve">
          <source>The interface output may be directed to another file &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; with the option &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (not recommended).</source>
          <target state="translated">インターフェース出力は、オプション &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; を &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; して別のファイルbar2 / Wurble.ifaceに送信できます（非推奨）。</target>
        </trans-unit>
        <trans-unit id="d422eff6b38b54b7b01cf3f23285761f3009b5be" translate="yes" xml:space="preserve">
          <source>The interface provides &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, a type representation which can be safely decomposed and composed. See &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; for an example of this.</source>
          <target state="translated">このインターフェースは &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; を提供します。これは、安全に分解および構成できる型表現です。この例については、&lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7525fed411a95f2aba1be67c722e982ae098165e" translate="yes" xml:space="preserve">
          <source>The interpreter can&amp;rsquo;t load modules with foreign export declarations!</source>
          <target state="translated">インタープリターは、モジュールを外部エクスポート宣言でロードできません！</target>
        </trans-unit>
        <trans-unit id="c6f1b29cc56478e029057e80fde7617996385c3a" translate="yes" xml:space="preserve">
          <source>The interpreter doesn&amp;rsquo;t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">インタープリターはボックス化されていないタプルをサポートしないため、GHCiはこれらのモジュールとそれらが依存するすべてのモジュールを、バイトコードではなくオブジェクトコードに自動的にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="bcc96915fbf058774c86b1ad6764191d649fe219" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="960baabb94ec6d41e7f419f3f0516ce7cfa51827" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="25e108698be586db7ffe3f616a94bfc73b7ee1a2" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year, the number of the Monday-starting week, and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt; の逆です。取得 &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 年与えられ、月曜から始まる週の数、および曜日を。最初の月曜日は週1の最初の日で、年のいずれかの早い日は週0です（として &lt;code&gt;%W&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2617db8ad5e573ea343c5794cabc4dfe2b8d32ba" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year and the number of the day of a Sunday-starting week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt; の逆です。年と日曜日から始まる週の日数を指定して、1 &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 取得します。最初の日曜日は、年のいずれかの早い日（として週0で週1の最初の日である &lt;code&gt;%U&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8e1d7169fde4f120c1aa4f3ece9ee57253f95f60" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; の逆、つまりIDを持っています</target>
        </trans-unit>
        <trans-unit id="085f4b1b3304279a7c72a59a48e1ceb8b934a83e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; の逆、つまりIDを持っています</target>
        </trans-unit>
        <trans-unit id="bdd2cce8158f1320bcd058983fb015f9d2fa4781" translate="yes" xml:space="preserve">
          <source>The key component of a typechecker plugin is a function of type &lt;code&gt;TcPluginSolver&lt;/code&gt;, like this:</source>
          <target state="translated">タイプ &lt;code&gt;TcPluginSolver&lt;/code&gt; プラグインの主要なコンポーネントは、次のようにTcPluginSolverタイプの関数です。</target>
        </trans-unit>
        <trans-unit id="50146b4ed40e4fdb3a0f98772092c373b41b7b82" translate="yes" xml:space="preserve">
          <source>The key difference here is that we abstract over the type constructor &lt;code&gt;c&lt;/code&gt; that is used to form the collection type &lt;code&gt;c e&lt;/code&gt;, and not over that collection type itself, represented by &lt;code&gt;ce&lt;/code&gt; in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt;, which is not ambiguous.</source>
          <target state="translated">ここでの主な違いは、元のクラス宣言で &lt;code&gt;ce&lt;/code&gt; によって表されるコレクション型自体ではなく、コレクション型 &lt;code&gt;c e&lt;/code&gt; を形成するために使用される型コンストラクタ &lt;code&gt;c&lt;/code&gt; を抽象化することです。これにより、上で述べた当面の問題が回避されます。空の型は &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt; であり、あいまいではありません。</target>
        </trans-unit>
        <trans-unit id="d931654af7b546e8d6ff7d64be51ee7d51eed95b" translate="yes" xml:space="preserve">
          <source>The key point about GADTs is that &lt;em&gt;pattern matching causes type refinement&lt;/em&gt;. For example, in the right hand side of the equation</source>
          <target state="translated">GADTの重要な点は、&lt;em&gt;パターンマッチングにより型が改良されること&lt;/em&gt;です。たとえば、方程式の右辺</target>
        </trans-unit>
        <trans-unit id="1c6ccf2ae2f2b690d9a1832c4814300edcd715a9" translate="yes" xml:space="preserve">
          <source>The key to defining your own datatype-generic functions is to understand how to represent datatypes using the given set of type constructors.</source>
          <target state="translated">独自のデータ型ジェネリック関数を定義する鍵は、指定された型コンストラクタのセットを使用してデータ型を表現する方法を理解することです。</target>
        </trans-unit>
        <trans-unit id="101f96a1728772ac592ac70565bf2d4fd3554ddc" translate="yes" xml:space="preserve">
          <source>The key tool to use in making your Haskell program run faster are GHC&amp;rsquo;s profiling facilities, described separately in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;. There is &lt;em&gt;no substitute&lt;/em&gt; for finding where your program&amp;rsquo;s time/space is &lt;em&gt;really&lt;/em&gt; going, as opposed to where you imagine it is going.</source>
          <target state="translated">Haskellプログラムをより高速に実行するために使用する主要なツールは、GHCのプロファイリング機能です。これについては、「&lt;a href=&quot;profiling#profiling&quot;&gt;プロファイリング」で&lt;/a&gt;個別に説明しています。プログラムの時間/空間が&lt;em&gt;実際に&lt;/em&gt;どこに向かっているのかを想像するのではなく、&lt;em&gt;実際に&lt;/em&gt;どこに向かっているの&lt;em&gt;か&lt;/em&gt;を見つけることに&lt;em&gt;代わるもの&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52cd9e5fb65950d32847b984e9879cffe2f00ec9" translate="yes" xml:space="preserve">
          <source>The keypad</source>
          <target state="translated">キーパッド</target>
        </trans-unit>
        <trans-unit id="89852fc3a3f80fb4cacd31fc13b712715ce5683a" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">種類 &lt;code&gt;Type&lt;/code&gt; （ &lt;code&gt;Data.Kind&lt;/code&gt; からインポート）は、通常の型を分類します。&lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;（現在はデフォルトでは有効）、 &lt;code&gt;*&lt;/code&gt; に脱糖される &lt;code&gt;Type&lt;/code&gt; が、このレガシー構文を使用して、との競合が原因推奨されていません&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;。これは、 &lt;code&gt;*&lt;/code&gt; の Unicode版である &lt;code&gt;★&lt;/code&gt; にも適用されます。</target>
        </trans-unit>
        <trans-unit id="0cd808c3a0aa47774f7ee55994f44b345c1912bc" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; のパラメータの種類は &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 、ただし &lt;code&gt;Proxy&lt;/code&gt; の種類は &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 、ここで &lt;code&gt;{k}&lt;/code&gt; は、ユーザーによって指定されていない種類変数 &lt;code&gt;k&lt;/code&gt; が推論されることを示します。 （推論された指定の区別の詳細については、&lt;a href=&quot;#visible-type-application&quot;&gt;Visibleタイプのアプリケーション&lt;/a&gt;を参照してください）。 GHCは &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 考慮しません。 k-&amp;gt;タイプと &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; は種類レベルで等しくなるため、 &lt;code&gt;Foo Proxy&lt;/code&gt; を不適切なものとして拒否します。</target>
        </trans-unit>
        <trans-unit id="d650258dfa554e9a0a612c8d7a0289cda5964e46" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Vec&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt;. This means that, e.g., &lt;code&gt;Vec Int Char&lt;/code&gt; is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</source>
          <target state="translated">一種 &lt;code&gt;Vec&lt;/code&gt; とは、ある &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 。これは、たとえば、長さインデックス付きのベクトルを定義するときに意図したものではありませんが、 &lt;code&gt;Vec Int Char&lt;/code&gt; は種類が適切であることを意味します。</target>
        </trans-unit>
        <trans-unit id="6bdcf0025de5c2355bf036fb20350561d0e1ffc4" translate="yes" xml:space="preserve">
          <source>The kind of constraints, like &lt;code&gt;Show a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Show a&lt;/code&gt; ような制約の種類</target>
        </trans-unit>
        <trans-unit id="3970d2a390e8339e6194fae0a800fd7ee383f1f3" translate="yes" xml:space="preserve">
          <source>The kind of types with values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">値を持つタイプの種類。たとえば、 &lt;code&gt;Int :: Type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0a2ff1eafaf2cf50aa099b7bed39cd8ce178efc2" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;.</source>
          <target state="translated">クラス宣言の種類ポリモーフィズムは、 &lt;code&gt;D1&lt;/code&gt; を種類ポリモーフィックにしますが、 &lt;code&gt;D2&lt;/code&gt; はそうしません。同様に &lt;code&gt;F1&lt;/code&gt; 、 &lt;code&gt;F1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="142a287b02ca78aabf16196f308cd74692a41234" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in module &lt;code&gt;GHC.TypeLits&lt;/code&gt;. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">この機能のリテラルの種類とその他のすべての低レベル操作は、モジュール &lt;code&gt;GHC.TypeLits&lt;/code&gt; で定義されています。このモジュールは、値レベルの対応物と衝突するタイプレベルの演算子をいくつか定義していることに注意してください（例 &lt;code&gt;(+)&lt;/code&gt; ）。これらの演算子を参照するインポートおよびエクスポート宣言には、明示的な名前空間注釈が必要です（&lt;a href=&quot;#explicit-namespaces&quot;&gt;import / exportの明示的な名前空間を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f14aa2c065169defb0f47595c9265ce4ba5857e8" translate="yes" xml:space="preserve">
          <source>The lag stage, which is the time between creation and the first use of the object,</source>
          <target state="translated">オブジェクトの作成から最初の使用までの時間であるラグステージ。</target>
        </trans-unit>
        <trans-unit id="67f729cc5793b907e6283b32042b3a6379b975b3" translate="yes" xml:space="preserve">
          <source>The language &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; changes this behaviour:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;言語はこの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="96eef94888750b6bf04df904c79af345e5cf88c6" translate="yes" xml:space="preserve">
          <source>The language definition for the Haskell language.</source>
          <target state="translated">Haskell言語の言語定義。</target>
        </trans-unit>
        <trans-unit id="f35e66eca43d1117d42cef793c6da9da1b53ea98" translate="yes" xml:space="preserve">
          <source>The language definition for the language Mondrian.</source>
          <target state="translated">モンドリアンという言葉の定義。</target>
        </trans-unit>
        <trans-unit id="c6db1b982530559c016310cc1374654d4e113cec" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; adds support for expressing integer literals in binary notation with the prefix &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;. For instance, the binary integer literal &lt;code&gt;0b11001001&lt;/code&gt; will be desugared into &lt;code&gt;fromInteger 201&lt;/code&gt; when &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;は、接頭辞 &lt;code&gt;0b&lt;/code&gt; または &lt;code&gt;0B&lt;/code&gt; を付けたバイナリ表記で整数リテラルを表現するためのサポートを追加します。たとえば、&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;が有効になっている場合、バイナリ整数リテラル &lt;code&gt;0b11001001&lt;/code&gt; は &lt;code&gt;fromInteger 201&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="2aa01e6792de69a814fc51631fa469117dc53520" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;#&lt;/code&gt; as a postfix modifier to identifiers. Thus, &lt;code&gt;x#&lt;/code&gt; is a valid variable, and &lt;code&gt;T#&lt;/code&gt; is a valid type constructor or data constructor.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;では、 &lt;code&gt;#&lt;/code&gt; を識別子の接尾修飾子として使用できます。したがって、 &lt;code&gt;x#&lt;/code&gt; は有効な変数であり、 &lt;code&gt;T#&lt;/code&gt; は有効な型コンストラクターまたはデータコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="482fac3caa33dc4889f02993b124d842b7fc23c8" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumDecimals&quot;&gt;&lt;code&gt;NumDecimals&lt;/code&gt;&lt;/a&gt; allows you to also use the floating literal syntax for instances of &lt;code&gt;Integral&lt;/code&gt;, and have values like &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-NumDecimals&quot;&gt; &lt;code&gt;NumDecimals&lt;/code&gt; を&lt;/a&gt;使用すると、 &lt;code&gt;Integral&lt;/code&gt; のインスタンスに浮動リテラル構文を使用することもでき、 &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt; ような値を持つことができます</target>
        </trans-unit>
        <trans-unit id="7301f20dd6642c45e1a8ac269b635e38af928e05" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue #14473&lt;/a&gt;.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;は、数値リテラルでアンダースコアを表現するためのサポートを追加します。たとえば、&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;が有効な場合、数値リテラル &lt;code&gt;1_000_000&lt;/code&gt; は &lt;code&gt;1000000&lt;/code&gt; に解析されます。つまり、&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;が有効な場合、数値リテラルのアンダースコアは無視されます。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue＃14473&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1df0d3ed5fc3e05e0b2f091352293e402f435759" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; adds a new syntactic form &lt;code&gt;static e&lt;/code&gt;, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;は、閉じた式「 &lt;code&gt;static e&lt;/code&gt; 」への参照を表す新しい構文形式static eを追加します。この参照は、おそらく異なるマシンの異なるプロセス全体で有効なままであるという意味で、安定して移植可能です。したがって、プロセスは参照を作成し、それを「e」に解決できる別のプロセスに送信できます。</target>
        </trans-unit>
        <trans-unit id="1164d109e3a8912c2bd8dbd337b1bd95e59931eb" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; allows much more flexible constraints in superclasses.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; を&lt;/a&gt;使用すると、スーパークラスではるかに柔軟な制約を設定できます。</target>
        </trans-unit>
        <trans-unit id="a23afb63a5225acfa62366c99fa9002b8bd272d4" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; を&lt;/a&gt;使用すると、Unicode文字を使用して特定のASCII文字シーケンスを表すことができます。以下の代替案が提供されています。</target>
        </trans-unit>
        <trans-unit id="0f020db4c2779c8a84447ac375908f8cf1851cd7" translate="yes" xml:space="preserve">
          <source>The language extensions control what variation of the language are permitted.</source>
          <target state="translated">言語拡張機能は、どのような言語のバリエーションが許可されているかを制御します。</target>
        </trans-unit>
        <trans-unit id="1e3e7e5b927ef3a07b1708c8234ccb8fab69c087" translate="yes" xml:space="preserve">
          <source>The language extensions known to GHC.</source>
          <target state="translated">GHCで知られている言語拡張。</target>
        </trans-unit>
        <trans-unit id="47f8be94c2ca864c563003d6cd62e96954c9f6b8" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; enables an alternative translation for the do-notation, which uses the operators &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, along with &lt;code&gt;join&lt;/code&gt; as far as possible. There are two main reasons for wanting to do this:</source>
          <target state="translated">言語オプション&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;を使用 &lt;code&gt;join&lt;/code&gt; と、可能な限り結合とともに演算子 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; を使用するdo表記の代替翻訳が可能になります。これを実行する主な理由は2つあります。</target>
        </trans-unit>
        <trans-unit id="6758c18bb77d5105f15261fc6f768c32b1ac1a54" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">言語オプション&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;を意味する）は、より上位の型を有効にします。つまり、関数の矢の中に &lt;code&gt;forall&lt;/code&gt; を任意にネストすることができます。たとえば、型クラスコンテキストを含むforall型（「型スキーム」とも呼ばれます）は有効です。</target>
        </trans-unit>
        <trans-unit id="e43581d03051421db388e53bc00c80ed362d21f6" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">与えられた比較関数に関して,空でない構造体の最大の要素.</target>
        </trans-unit>
        <trans-unit id="a09e69c04a0fae36b18bfad0cec44eb5b7dac599" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure.</source>
          <target state="translated">空ではない構造の最大の要素。</target>
        </trans-unit>
        <trans-unit id="1c3c62ef7c501b737425bd024e6b97dd8602a4d0" translate="yes" xml:space="preserve">
          <source>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</source>
          <target state="translated">最後の例では、やや複雑な左辺を持つruleが生成されるので(自分で試してみてください)、あまりうまく発火しないかもしれません。このような特殊化を使った場合、どの程度の効果があるのか教えてください。</target>
        </trans-unit>
        <trans-unit id="c09c37300640da9fa5a1e825531f7baf46e4a4a9" translate="yes" xml:space="preserve">
          <source>The last point means that, for example, this program:</source>
          <target state="translated">最後のポイントというのは、例えばこのプログラム。</target>
        </trans-unit>
        <trans-unit id="c7b0fe0f98d69788b12fc3fe8961316784922da5" translate="yes" xml:space="preserve">
          <source>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; falls back to a general &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; like lookup.</source>
          <target state="translated">最後の文字列パラメータは、スパンが古い場合、つまりファイルが変更され、コードが移動した場合に役立ちます。その場合、&lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt;は、ルックアップのような一般的な&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; に&lt;/a&gt;フォールバックします。</target>
        </trans-unit>
        <trans-unit id="74662c9c171e1f11f6d4c17936e04e8cfc73a0a4" translate="yes" xml:space="preserve">
          <source>The last time we looked, this bug still wasn&amp;rsquo;t fixed in the BFD codebase, and there wasn&amp;rsquo;t any noticeable interest in fixing it when we reported the bug back in 2001 or so.</source>
          <target state="translated">前回確認したとき、このバグはBFDコードベースではまだ修正されておらず、2001年頃にバグを報告したときに、修正することに目立った関心はありませんでした。</target>
        </trans-unit>
        <trans-unit id="cc178347052a701ca8893682ca3efb8b74c8a5b7" translate="yes" xml:space="preserve">
          <source>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</source>
          <target state="translated">後者の2つの拡張は、単に高性能なコードにバングパターンを散りばめて読みにくくするのを避けるためのものです。</target>
        </trans-unit>
        <trans-unit id="83ef67ff9e0acbd2b46b885ad1e2b9746fa12727" translate="yes" xml:space="preserve">
          <source>The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single &lt;code&gt;RULES&lt;/code&gt; pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</source>
          <target state="translated">レイアウト規則はプラグマに適用されます。現在、新しいインデントレベルは設定されていないため、単一の &lt;code&gt;RULES&lt;/code&gt; プラグマに複数のルールを配置し、レイアウトを使用してそれらを区切る場合は、開始を囲んでいる定義と同じ列に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="d2d17886ee9122e995c736b68557cda7950811bf" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">怠惰な &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; A &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; S @パラメータのいずれかであります</target>
        </trans-unit>
        <trans-unit id="cb5e3600ef521edc02534f8316cf1842086384c6" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">怠惰な &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; A &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; S @パラメータのいずれかであります</target>
        </trans-unit>
        <trans-unit id="40d868f620139062b248b76538a36b443a676fd8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds accumulation capabilities (such as declarations or document patches) to a given monad.</source>
          <target state="translated">レイジー &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; モナド変換子。指定されたモナドに累積機能（宣言やドキュメントパッチなど）を追加します。</target>
        </trans-unit>
        <trans-unit id="0148fab25056e7d25108af73020e1e1fd6b568bc" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">レイジー &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="460dbda305fa0fdf243ff4aaca3b36cbface9176" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">遅延 &lt;code&gt;ByteString&lt;/code&gt; タイプと表現</target>
        </trans-unit>
        <trans-unit id="cd66658dbdbc20cd277316b5f47a31d85a5a657d" translate="yes" xml:space="preserve">
          <source>The lazy ByteString that results from &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; can be written to disk, and read from disk using Data.ByteString.Lazy IO functions, such as hPutStr or writeFile:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 結果として生じる遅延ByteStringはディスクに書き込み、Data.ByteString.Lazy IO関数（hPutStrやwriteFileなど）を使用してディスクから読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="81b4ea9d6659ffec90b8a98fd916cb7519cdd284" translate="yes" xml:space="preserve">
          <source>The lazy input interface</source>
          <target state="translated">遅延入力インターフェース</target>
        </trans-unit>
        <trans-unit id="18194b6ea93e37e29c30dcb32e97e5e2850d4eab" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">遅延インターフェイスは、単一の遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を消費します。開始するのが最も簡単なインターフェイスですが、遅延I / Oが使用されない限り、インターリーブI / Oと解析はサポートされません。</target>
        </trans-unit>
        <trans-unit id="d0f94810b2d4d1d107dde9a11881d98fcdccae35" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">与えられた比較関数に関して、空ではない構造体の最小要素。</target>
        </trans-unit>
        <trans-unit id="07d9943e6fdf33ee01fbdf7cd0db14fb536c6243" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure.</source>
          <target state="translated">空でない構造体の最小要素。</target>
        </trans-unit>
        <trans-unit id="0e70192fc1725fb44e6261baa525bb34fe0d8271" translate="yes" xml:space="preserve">
          <source>The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is &lt;em&gt;not&lt;/em&gt; OK:</source>
          <target state="translated">ルールの左側は、任意の式に適用されるトップレベルの変数で構成されている必要があります。たとえば、これは&lt;em&gt;問題&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="9bbc16e1c3670ac6be9b561d2b10f00b7e4c905c" translate="yes" xml:space="preserve">
          <source>The length of a given month in the Gregorian or Julian calendars. First arg is leap year flag.</source>
          <target state="translated">グレゴリオ暦やユリウス暦の月の長さ。第一引数はうるう年フラグ。</target>
        </trans-unit>
        <trans-unit id="02862fec4929a80083ca47de3fabc777823d03ea" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reserved name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid identifier. A &lt;code&gt;reserved&lt;/code&gt; word is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">語彙素パーサーの &lt;code&gt;reserved name&lt;/code&gt; は &lt;code&gt;symbol name&lt;/code&gt; 名を解析しますが、 &lt;code&gt;name&lt;/code&gt; が有効な識別子の接頭辞でないことも確認します。 &lt;code&gt;reserved&lt;/code&gt; 語は使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12483176ac2649de2ec04abe4c197ebb522e5167" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reservedOp name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid operator. A &lt;code&gt;reservedOp&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">語彙素パーサー &lt;code&gt;reservedOp name&lt;/code&gt; は、 &lt;code&gt;symbol name&lt;/code&gt; nameを解析しますが、 &lt;code&gt;name&lt;/code&gt; が有効な演算子の接頭辞でないことも確認します。A &lt;code&gt;reservedOp&lt;/code&gt; を使用して、単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe325967df8e680315725cbc04cfb4a0cda946a" translate="yes" xml:space="preserve">
          <source>The libraries listed in &lt;code&gt;extra-libraries&lt;/code&gt; may be any libraries supported by your system&amp;rsquo;s linker, including dynamic libraries (&lt;code&gt;.so&lt;/code&gt; on Unix, &lt;code&gt;.DLL&lt;/code&gt; on Windows).</source>
          <target state="translated">&lt;code&gt;extra-libraries&lt;/code&gt; librariesにリストされているライブラリーは、動的ライブラリー（UNIXでは &lt;code&gt;.so&lt;/code&gt; 、Windows では &lt;code&gt;.DLL&lt;/code&gt; ）を含め、システムのリンカーによってサポートされているライブラリーのいずれかです。</target>
        </trans-unit>
        <trans-unit id="177074a86a1a2bfb7162db93da0c7658d94219a2" translate="yes" xml:space="preserve">
          <source>The lifetime of an event registration.</source>
          <target state="translated">イベント登録の寿命。</target>
        </trans-unit>
        <trans-unit id="abc2a96639fca06ac1cbe729983e770d28dcf330" translate="yes" xml:space="preserve">
          <source>The limitations here are listed in Haskell Report order (roughly).</source>
          <target state="translated">ここでの制限事項は、Haskellレポート順に(大まかに)記載しています。</target>
        </trans-unit>
        <trans-unit id="d2f24eb430e5f7113d1bb42457d3209f32c4782e" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overriden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">一部のシステムでは、 &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; 環境変数を使用して、リンカー標準ライブラリ検索をオーバーライドすることもできます。Windowsでの実装の詳細のため、 &lt;code&gt;LIBRARY_PATH&lt;/code&gt; を設定すると、見つかったライブラリのシステムローダーパスも拡張されます。したがって、多くの場合、 &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; を設定するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="35439bfe005709a8b0e917ffb02271e76a64cd30" translate="yes" xml:space="preserve">
          <source>The linker to use (default: &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">使用するリンカ（デフォルト： &lt;code&gt;gcc&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eeafbb95d04ce25f7a78da969fb894e2ec069b3e" translate="yes" xml:space="preserve">
          <source>The list is ordered by most recent call.</source>
          <target state="translated">リストは、最近の呼び出しが多い順に表示されます。</target>
        </trans-unit>
        <trans-unit id="1f523c49a9fa8705bc3372a7af5bd59d5259f47e" translate="yes" xml:space="preserve">
          <source>The list must be finite.</source>
          <target state="translated">リストは有限でなければならない。</target>
        </trans-unit>
        <trans-unit id="95bb9fda3d0750b05641de34c2d4bc742e5f26cc" translate="yes" xml:space="preserve">
          <source>The list of all possible separators.</source>
          <target state="translated">可能なすべての分離器のリストです。</target>
        </trans-unit>
        <trans-unit id="140110a0fe6147ee6523b90cc08f34ea3d3d7870" translate="yes" xml:space="preserve">
          <source>The list of associations of an array in index order.</source>
          <target state="translated">配列の関連付けのリストをインデックス順に表示します。</target>
        </trans-unit>
        <trans-unit id="4db5b3fb0ce028bd2eb08c3da0fe9c3bade145e2" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently enabled can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">現在有効になっているブレークポイントのリストは、&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;を使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="6840298fc1ff7b758a2385cba92227fe7cb9d802" translate="yes" xml:space="preserve">
          <source>The list of elements of an array in index order.</source>
          <target state="translated">配列の要素をインデックス順に並べたリスト。</target>
        </trans-unit>
        <trans-unit id="920d0464cfa124351a5c124482bb76f7bb005ea6" translate="yes" xml:space="preserve">
          <source>The list of indices of an array in ascending order.</source>
          <target state="translated">配列のインデックスの昇順のリスト。</target>
        </trans-unit>
        <trans-unit id="c272635afded4d839339a1be1f84abe89e36c500" translate="yes" xml:space="preserve">
          <source>The list of paths is split using &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt;, which on Windows is a semicolon.</source>
          <target state="translated">パスのリストは &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt; を使用して分割されます。これはWindowsではセミコロンです。</target>
        </trans-unit>
        <trans-unit id="dc809c8f4a7b8427301c5f620413f00381ab3112" translate="yes" xml:space="preserve">
          <source>The list of possible &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt;s in the API documentation is not exhaustive. The full list may vary by platform and/or evolve over time.</source>
          <target state="translated">APIドキュメントで考えられる &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; のリストは完全ではありません。完全なリストは、プラットフォームによって異なる場合や、時間の経過とともに変化する場合があります。</target>
        </trans-unit>
        <trans-unit id="c6f1b33fdad02db727e19018a482ecf607406289" translate="yes" xml:space="preserve">
          <source>The list of reserved identifiers.</source>
          <target state="translated">予約された識別子のリスト。</target>
        </trans-unit>
        <trans-unit id="91edba8a3a46eed84d044f0b039fdf7160f70fd8" translate="yes" xml:space="preserve">
          <source>The list of reserved operators.</source>
          <target state="translated">予約された演算子のリストです。</target>
        </trans-unit>
        <trans-unit id="c39f3749d7b0f0a59a29e12553ad09d0740f4541" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</source>
          <target state="translated">有効なホールフィットのリストは、スコープ内のどのバインディングがホールに収まるかを確認することで見つけられます。例として、以下のモジュールをGHCでコンパイルします。</target>
        </trans-unit>
        <trans-unit id="a1d5e76811a70379851fd0870f7be2601a8c80c1" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有効な穴あけのリストは、穴ごとに最大6つの穴あてを表示することにより制限されます。表示される穴ばめの数は、このフラグで設定できます。 &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; で制限をオフにすると、見つかったすべての穴あてが表示されます。</target>
        </trans-unit>
        <trans-unit id="d8490f70aa9b2cb5e8e7f8af8e97ea93b083ee94" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</source>
          <target state="translated">有効なリファインメントの穴フィットのリストは、追加の穴の量が変化する穴フィットを考慮して生成されます。絞り込みの穴の量は、このフラグで設定できます。フラグが0に設定されているか、まったく設定されていない場合は、有効な絞り込みホールフィットは提案されません。</target>
        </trans-unit>
        <trans-unit id="0e9c3cb541a9f4b1ef3a2b89a4f5da3c5f2f0b80" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有効な絞り込み穴あてのリストは、穴ごとに最大6つの穴あてを表示することにより制限されます。表示される穴ばめの数は、このフラグで設定できます。 &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; で制限をオフにすると、見つかったすべての穴あてが表示されます。</target>
        </trans-unit>
        <trans-unit id="b86a88a2e8b5e2bcc9593f30db6f5ffae5340c3d" translate="yes" xml:space="preserve">
          <source>The list of values in the subrange defined by a bounding pair.</source>
          <target state="translated">バウンディングペアで定義されたサブレンジ内の値のリスト。</target>
        </trans-unit>
        <trans-unit id="c06dff0a9cb5a38686c70f9512cbd43e5942e7dc" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; means that it is instead desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">リテラル &lt;code&gt;-123&lt;/code&gt; は、Haskell98およびHaskell 2010によると、 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; として（deserInger 123から）脱糖化されています。言語拡張&lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt;は、代わりに &lt;code&gt;fromInteger (-123)&lt;/code&gt; として脱糖化されることを意味します。</target>
        </trans-unit>
        <trans-unit id="0e4c18eaf2be8a9b015eed5cef929f88b0717761" translate="yes" xml:space="preserve">
          <source>The local axioms from the instance context : &lt;code&gt;B a&lt;/code&gt;, &lt;code&gt;D a&lt;/code&gt; and &lt;code&gt;E a&lt;/code&gt;</source>
          <target state="translated">インスタンスコンテキストからのローカル公理： &lt;code&gt;B a&lt;/code&gt; 、 &lt;code&gt;D a&lt;/code&gt; および &lt;code&gt;E a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ffc1a6bb0aa38dfc306316588a7559300ef95b" translate="yes" xml:space="preserve">
          <source>The location at which this computation is spliced.</source>
          <target state="translated">この計算が接続されている場所。</target>
        </trans-unit>
        <trans-unit id="eeb6dd18dd0c7cd9fc57a8f2ff6c2bb37bc4af79" translate="yes" xml:space="preserve">
          <source>The lowercase versions (&lt;em&gt;syntax operators&lt;/em&gt;) of these constructors are preferred to these constructors, since they compose better with quotations (&lt;code&gt;[| |]&lt;/code&gt;) and splices (&lt;code&gt;$( ... )&lt;/code&gt;)</source>
          <target state="translated">これらのコンストラクターの小文字バージョン（&lt;em&gt;構文演算子&lt;/em&gt;）は、引用符（ &lt;code&gt;[| |]&lt;/code&gt; ）とスプライス（ &lt;code&gt;$( ... )&lt;/code&gt; ）で構成するため、これらのコンストラクターよりも推奨されます。</target>
        </trans-unit>
        <trans-unit id="abe92315667ac8537af92643ee70ab06a908884e" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running.</source>
          <target state="translated">プログラムが実行されているマシンアーキテクチャ。</target>
        </trans-unit>
        <trans-unit id="32815c54d6aac2d0c3f3ab1768e3826958371ab4" translate="yes" xml:space="preserve">
          <source>The main advantages to using &lt;code&gt;ghc --make&lt;/code&gt; over traditional &lt;code&gt;Makefile&lt;/code&gt;s are:</source>
          <target state="translated">従来の &lt;code&gt;Makefile&lt;/code&gt; よりも &lt;code&gt;ghc --make&lt;/code&gt; を使用する主な利点は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8f8b11338657365b7972c69ff46bf6811e5d4123" translate="yes" xml:space="preserve">
          <source>The main idea is to add a single new production to the syntax of patterns:</source>
          <target state="translated">パターンの構文に新たに1つのプロダクションを追加するのが主な考え方です。</target>
        </trans-unit>
        <trans-unit id="fb265d0d99b20462c3bedd36be578770dd2b3955" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">使用する必要がある主なライブラリは&lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stmライブラリ&lt;/a&gt;です。サポートされている主な機能は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5e1d49c28d217785350db1f824835b79bff3fc25" translate="yes" xml:space="preserve">
          <source>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only &lt;em&gt;then&lt;/em&gt; specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</source>
          <target state="translated">専門に位相制御を使用する主な理由は、あなたが最適化を記述することができるということです早期コンパイルパイプラインでその火をルール、唯一&lt;em&gt;その後、&lt;/em&gt;関数の呼び出しを専門としています。専門化が早すぎると、最適化ルールが起動しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd99fbab8c2a96e5d1994f5a584841ebedd4fc5c" translate="yes" xml:space="preserve">
          <source>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</source>
          <target state="translated">ここでの主な要件は、Haskellコードを呼び出す前にランタイムを初期化する必要があることで、ライブラリはCまたはC++で実装された初期化と初期化解除のエントリポイントを提供する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a36b3b528156f09407c2aa49bd251573cb91ec76" translate="yes" xml:space="preserve">
          <source>The main thread principle also applies to calls to Haskell from outside, using &lt;code&gt;foreign export&lt;/code&gt;. When the &lt;code&gt;foreign export&lt;/code&gt;ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the &lt;code&gt;foreign export&lt;/code&gt;ed function has returned.</source>
          <target state="translated">メインスレッドの原則は、 &lt;code&gt;foreign export&lt;/code&gt; を使用した、外部からのHaskellの呼び出しにも適用されます。ときに &lt;code&gt;foreign export&lt;/code&gt; ED関数が呼び出され、それが新しいメインスレッドを開始し、それはときに、このメインスレッドの終了を返します。呼び出しによって新しいスレッドが分岐される場合、 &lt;code&gt;foreign export&lt;/code&gt; ed関数が返された後、それらはシステムに残っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="a8aa707c2a5513daf094974e7984d291b1194cb2" translate="yes" xml:space="preserve">
          <source>The maintainers are glad to accept patches for further standard encodings of standard Haskell values.</source>
          <target state="translated">メンテナは、Haskellの標準値をさらに標準的にエンコーディングするためのパッチを喜んで受け入れます。</target>
        </trans-unit>
        <trans-unit id="744ef2d7aabc6bab260fc29bb9d92f2367435b58" translate="yes" xml:space="preserve">
          <source>The major effect of an &lt;code&gt;INLINE&lt;/code&gt; pragma is to declare a function&amp;rsquo;s &amp;ldquo;cost&amp;rdquo; to be very low. The normal unfolding machinery will then be very keen to inline it. However, an &lt;code&gt;INLINE&lt;/code&gt; pragma for a function &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; has a number of other effects:</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; プラグマの主な効果は、関数の「コスト」を非常に低く宣言することです。通常の展開機械は、インライン化に非常に熱心です。ただし、関数「 &lt;code&gt;f&lt;/code&gt; 」の &lt;code&gt;INLINE&lt;/code&gt; プラグマには、他にも多くの効果があります。</target>
        </trans-unit>
        <trans-unit id="1159d0b17e1c60d7b892bb9301ccde55977e5feb" translate="yes" xml:space="preserve">
          <source>The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running &lt;strong&gt;windres&lt;/strong&gt;; to see exactly what GHC does to embed the manifest, use the &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; flag. A GHC installation comes with its own copy of &lt;code&gt;windres&lt;/code&gt; for this reason.</source>
          <target state="translated">WindowsでバイナリをリンクするときにGHCが生成するマニフェストファイルも、デフォルトでは実行可能ファイル自体に埋め込まれています。これは、マニフェストファイルを提供しなくてもバイナリを配布できることを意味します。埋め込みは、&lt;strong&gt;windres&lt;/strong&gt;を実行することによって行われます。マニフェストを埋め込むためにGHCが行うことを正確に確認するには、&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;フラグを使用します。このため、GHCのインストールには独自の &lt;code&gt;windres&lt;/code&gt; が付属しています。</target>
        </trans-unit>
        <trans-unit id="3378e6fba41b187d6615b43817c87aba7dfb73d6" translate="yes" xml:space="preserve">
          <source>The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale. As a consequence, no guarantees can be made about the relative length of a Haskell string and its corresponding C string, and therefore all the marshalling routines include memory allocation. The translation between Unicode and the encoding of the current locale may be lossy.</source>
          <target state="translated">マシャリングは、Unicodeコードポイントを表す各Haskell文字を、デフォルトでは現在のロケールによって決定される方法で、1バイト以上のバイトに変換します。その結果、Haskell 文字列とそれに対応する C 文字列の相対的な長さを保証することはできません。Unicodeと現在のロケールのエンコーディングとの間の変換は、損失を伴う可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce3ddf92b0204346524d60c5ce7d32e072cd0d54" translate="yes" xml:space="preserve">
          <source>The matching behaviour is also influenced by two module-level language extension flags: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</source>
          <target state="translated">マッチング動作は、2つのモジュールレベルの言語拡張フラグ、&lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; に&lt;/a&gt;も影響されます。これらの拡張機能は廃止され（GHC 7.10以降）、インスタンスごとの細かいプラグマに置き換えられました。</target>
        </trans-unit>
        <trans-unit id="e2ff7a2e018dbc48e22ad18efcef13edd8c486f6" translate="yes" xml:space="preserve">
          <source>The matrix of platforms that:</source>
          <target state="translated">そのプラットフォームのマトリクス。</target>
        </trans-unit>
        <trans-unit id="07015c741417849721502853df57df8b2fae7145" translate="yes" xml:space="preserve">
          <source>The maximal prefix of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that could be decoded from the given input.</source>
          <target state="translated">指定された入力からデコードできる &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; の最大プレフィックス。</target>
        </trans-unit>
        <trans-unit id="aa2a714293d353e1ff3212bd761cfba481644c07" translate="yes" xml:space="preserve">
          <source>The maximal size of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that is copied. &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; to guarantee that on average a chunk is of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コピーされる &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の最大サイズ。 &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 平均でチャンクがであることを保証する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d1640b5c03c6ca6aaac14f9e05c39afaa8e1c64" translate="yes" xml:space="preserve">
          <source>The maximum heap size also affects other garbage collection parameters: when the amount of live data in the heap exceeds a certain fraction of the maximum heap size, compacting collection will be automatically enabled for the oldest generation, and the &lt;code&gt;-F&lt;/code&gt; parameter will be reduced in order to avoid exceeding the maximum heap size.</source>
          <target state="translated">最大ヒープサイズは、他のガベージコレクションパラメータにも影響します。ヒープ内のライブデータの量が最大ヒープサイズの特定の割合を超えると、圧縮コレクションが最も古い世代に対して自動的に有効になり、 &lt;code&gt;-F&lt;/code&gt; パラメータが減少します。最大ヒープサイズを超えないようにするため。</target>
        </trans-unit>
        <trans-unit id="7deac0bbef1cce9de070bc6eff250887dc27e012" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">履歴に保存される最大行数。場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 、履歴記憶は無制限です。</target>
        </trans-unit>
        <trans-unit id="d734e50598efc9c9203e0509468ba84ba10e6429" translate="yes" xml:space="preserve">
          <source>The maximum number of of colors on the screen.</source>
          <target state="translated">画面に表示される最大の色数です。</target>
        </trans-unit>
        <trans-unit id="b7d459650a2ba9b1231e79e180aceb1bd015d81c" translate="yes" xml:space="preserve">
          <source>The maximum space actually used by your program is the &amp;ldquo;bytes maximum residency&amp;rdquo; figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.</source>
          <target state="translated">プログラムが実際に使用する最大スペースは、「バイトの最大常駐」の数値です。これは主要なガベージコレクション中にのみチェックされるため、概算にすぎません。サンプル数は、何回チェックされたかを示します。</target>
        </trans-unit>
        <trans-unit id="8b43db138dc3a233b97e08a96f2e5508bd7bc2ca" translate="yes" xml:space="preserve">
          <source>The maximum tuple size</source>
          <target state="translated">最大タプルサイズ</target>
        </trans-unit>
        <trans-unit id="3c1ae6c029d2317f8ba5fb3110e02abfdbf30bfa" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. (See &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for details.)</source>
          <target state="translated">短縮された&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;の意味は、プログラムがプロファイル用にコンパイルされたかどうかによって異なります。（詳細については&lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;、ヒーププロファイリングのRTSオプションを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="d87c8b0eb65b8cb788e02129482e2e2b711668c6" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. When compiled for profiling, &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;#rts-flag--hc&quot;&gt;&lt;code&gt;-hc&lt;/code&gt;&lt;/a&gt;, but otherwise is equivalent to &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">短縮された&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;の意味は、プログラムがプロファイル用にコンパイルされたかどうかによって異なります。プロファイリング用にコンパイルされた場合、&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#rts-flag--hc&quot;&gt; &lt;code&gt;-hc&lt;/code&gt; &lt;/a&gt;と同等ですが、それ以外は&lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt;と同等です（&lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;プロファイリングのRTSオプションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2c90c10f5a199858ea71a07e1f9c65a1b0281964" translate="yes" xml:space="preserve">
          <source>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt;, the cost centre &lt;code&gt;c&lt;/code&gt; is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</source>
          <target state="translated">メカニズムは単純です。プログラムがSCCアノテーション &lt;code&gt;{-# SCC c -#} E&lt;/code&gt; を使用して式を評価するたびに、コストセンター &lt;code&gt;c&lt;/code&gt; が現在のスタックにプッシュされ、このスタックのエントリカウントが1ずつ増加します。スタックも保存して復元する必要がある場合があります。特に、プログラムがサンクを作成する場合（レイジーサスペンション）、現在のコストセンタースタックはサンクに格納され、サンクが評価されるときに復元されます。このように、コスト中心スタックは、実行時にGHCが使用する実際の評価順序とは無関係です。</target>
        </trans-unit>
        <trans-unit id="f7c0a3feb5345a104be8d4a49924286ed63663fa" translate="yes" xml:space="preserve">
          <source>The member functions of this class facilitate writing values of primitive types to raw memory (which may have been allocated with the above mentioned routines) and reading values from blocks of raw memory. The class, furthermore, includes support for computing the storage requirements and alignment restrictions of storable types.</source>
          <target state="translated">このクラスのメンバ関数は、原始型の値を生メモリ(上述のルーチンで割り当てられている可能性がある)に書き込むことと、生メモリのブロックから値を読み出すことを容易にする。このクラスは,さらに,格納可能な型の格納要件と整列制限を計算するためのサポートを含む.</target>
        </trans-unit>
        <trans-unit id="cba31954fa26087a15e99fd14a2e8df87f705a4d" translate="yes" xml:space="preserve">
          <source>The members &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class map all values of &lt;code&gt;CT&lt;/code&gt; to the corresponding value of &lt;code&gt;t&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのメンバー &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;CT&lt;/code&gt; のすべての値を &lt;code&gt;t&lt;/code&gt; の対応する値に、またはその逆にマップします。</target>
        </trans-unit>
        <trans-unit id="723dfa6d14019cdcb7ea8b493daa172324f5d5cf" translate="yes" xml:space="preserve">
          <source>The memory is freed when &lt;code&gt;f&lt;/code&gt; terminates (either normally or via an exception), so the pointer passed to &lt;code&gt;f&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be used after this.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が（通常または例外を介して）終了すると、メモリは解放されるため、 &lt;code&gt;f&lt;/code&gt; に渡されたポインタは、この後に使用して&lt;em&gt;は&lt;/em&gt;なりませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="30cdd2b8067e97ef326db4b7a7649ae2a1d70b50" translate="yes" xml:space="preserve">
          <source>The memory management overhead. Currently this is tuned for GHC only.</source>
          <target state="translated">メモリ管理のオーバーヘッドです。現在はGHCのみにチューニングされています。</target>
        </trans-unit>
        <trans-unit id="296145d71ce1908abeb930aa215c007de95d6dac" translate="yes" xml:space="preserve">
          <source>The memory may be deallocated using &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">メモリは、不要になっ &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; ときに &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; またはfinalizerFreeを使用して割り当て解除できます。</target>
        </trans-unit>
        <trans-unit id="b7786c976f2ff7540d0a6e4b59833c22c599315f" translate="yes" xml:space="preserve">
          <source>The memory may freed at any point after the subcomputation terminates, so the pointer to the storage must *not* be used after this.</source>
          <target state="translated">メモリは、サブ計算が終了した後の任意の時点で解放される可能性があるので、この後にストレージへのポインタは*使用されてはなりません。</target>
        </trans-unit>
        <trans-unit id="51295ee3cd81001e8a30ec8543497b0e8c877217" translate="yes" xml:space="preserve">
          <source>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</source>
          <target state="translated">これのメリットは、GADTやその他のエキゾチックなデータ型のインスタンスを導出することができることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="09ce093d9b8936752c951269f1ca598cad553080" translate="yes" xml:space="preserve">
          <source>The message printed if &lt;code&gt;malloc&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; が失敗した場合に出力されるメッセージ。</target>
        </trans-unit>
        <trans-unit id="7c55c4a564eeb697e2553fd6d32d12eec12c5af2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2bb9dae247f1417713fe2e3ff89e568a58dd2064" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。ここで、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値は角括弧の代わりに二重引用符で示されます。</target>
        </trans-unit>
        <trans-unit id="9b206e34c8564a26770cfb63266e92dafdef2f00" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b9ba8a954c2ae61c20aa36e469332d7313c7d48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。ここで、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値は角括弧の代わりに二重引用符で示されます。</target>
        </trans-unit>
        <trans-unit id="332ed4acf796a389b61681f06e5d3b89101d146a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを解析する特殊な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスによって使用されます。この場合、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値には角括弧ではなく二重引用符を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1e8a0b574789d1de5cf8d746837c55989fd9ec8f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">メソッド &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; は、プログラマが値のリストを表示する特別な方法を提供できるようにするために提供されています。たとえば、これは &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 型の事前定義された &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスで使用されます。ここで、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 型の値は角括弧の代わりに二重引用符で示されます。</target>
        </trans-unit>
        <trans-unit id="a55e07264dbb157af3468bbfef9f673d9ed1c760" translate="yes" xml:space="preserve">
          <source>The method names refer to the monoid of lists under concatenation, but there are many other instances.</source>
          <target state="translated">メソッド名は連結下のリストのモノイドを参照していますが、他にもたくさんのインスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="14f5aff046cf43c34ac7e373b3ac53e710239001" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">モジュール&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt;は以下を定義します：</target>
        </trans-unit>
        <trans-unit id="6fe9f2287d708875ff918672eee840079c919130" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; provides operations to allocate and deallocate blocks of raw memory (i.e., unstructured chunks of memory outside of the area maintained by the Haskell storage manager). These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions.</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt;は、生メモリのブロック（つまり、Haskellストレージマネージャーによって維持される領域外の非構造化メモリチャンク）の割り当てと割り当て解除の操作を提供します。これらのメモリブロックは、複合データ構造を外部関数に渡すため、または外部関数から複合結果値が取得されるスペースを提供するために一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="0aaac35805022709131420c56844a405405859b9" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy (except for &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt;):</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;は、 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 階層内の他のモジュールを再エクスポートします（ &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt; を除く）。</target>
        </trans-unit>
        <trans-unit id="b1df10bb69bf2b89bf3830cfbd382b7d65aa4ba2" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy:</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;は、 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 階層内の他のモジュールを再エクスポートします。</target>
        </trans-unit>
        <trans-unit id="28a8a8e9077c7af6ee0166e9bad843be62034b8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface (FFI), and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">モジュール&lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt;は、マーシャリングの最も基本的なサポートを提供し、Foreign Function Interface（FFI）の言語に依存しない部分の一部であり、通常は&lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;モジュールを介してインポートされます。</target>
        </trans-unit>
        <trans-unit id="7b7c64247943d5ed0c07fe913e3a4cc1b0d102fc" translate="yes" xml:space="preserve">
          <source>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">モジュールヘッダ(エクスポートリストを含む)とインポート文は、Haskellと全く同じであり、スコープルールも同様です。したがって、Prelude以外の型やクラスを言及するには、それをインポートしなければなりません。</target>
        </trans-unit>
        <trans-unit id="4ce45cb81b574e7a52ecde45d4ee5f41764d49db" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">モジュールは&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrowを&lt;/a&gt;インポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="271abdd5800add2d2a429d3960db113d446e207f" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">モジュールは&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;でコンパイルされました</target>
        </trans-unit>
        <trans-unit id="61f9fc1e39c23939a82e428406225578b440fb61" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">モジュールは&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされました</target>
        </trans-unit>
        <trans-unit id="8638db98256357d4532755afc9c9f9aac9ff4038" translate="yes" xml:space="preserve">
          <source>The monad and its operations</source>
          <target state="translated">モナドとその運用</target>
        </trans-unit>
        <trans-unit id="da5e8905606683d3d0ad467ab40cd56a8717786c" translate="yes" xml:space="preserve">
          <source>The monoid of endomorphisms under composition.</source>
          <target state="translated">構成中の同形体のモノイド。</target>
        </trans-unit>
        <trans-unit id="e9ccf96ea16ca69c701719763f3afb8aa9f150cf" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; プラグマの最も一般的な使用法は、&lt;a href=&quot;#pattern-synonyms&quot;&gt;パターン同義語での使用&lt;/a&gt;です。それ自体、チェッカーは非常に単純であり、パターンの同義語を含むすべての一致が失敗すると想定しています。その結果、ユーザーがキャッチオールケースを追加しない限り、パターンシノニムでのパターンマッチは不完全と見なされます。</target>
        </trans-unit>
        <trans-unit id="063a9618d36844f08d6ef94989127397ea9b9b40" translate="yes" xml:space="preserve">
          <source>The most common way this can happen is when you&amp;rsquo;re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</source>
          <target state="translated">これが発生する最も一般的な方法は、CAF（メインなど）を評価し、ブレークポイントで停止し、プロンプトでCAFの値を再度要求する場合です。</target>
        </trans-unit>
        <trans-unit id="75340b8409f86aba60aed6656112aab745923bcd" translate="yes" xml:space="preserve">
          <source>The most commonly used ISO 8601 format for this type.</source>
          <target state="translated">このタイプで最も一般的に使用されているISO 8601フォーマット。</target>
        </trans-unit>
        <trans-unit id="bfe39e2ecd43cfd563f91e4eca3de1502694fa6f" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identityモナドでパーサーを実行する最も一般的な方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; パーサ実行 &lt;code&gt;p&lt;/code&gt; はトークンの入力リストに &lt;code&gt;input&lt;/code&gt; ソースから得られ、 &lt;code&gt;filePath&lt;/code&gt; に初期ユーザ状態と &lt;code&gt;st&lt;/code&gt; 。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="aeb3d7e2ffb679903cf3a78fe1e8a43f4f5df8ed" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identityモナドでパーサーを実行する最も一般的な方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; パーサ実行 &lt;code&gt;p&lt;/code&gt; はトークンの入力リストに &lt;code&gt;input&lt;/code&gt; ソースから得られ、 &lt;code&gt;filePath&lt;/code&gt; に初期ユーザ状態と &lt;code&gt;st&lt;/code&gt; 。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="2c5053914782286bf569d388ab06bfb0dd58462e" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">パーサーを実行する最も一般的な方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; は、トークンuser inputの入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を実行し &lt;code&gt;input&lt;/code&gt; 。これは、ソース &lt;code&gt;filePath&lt;/code&gt; から初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で取得されます。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返す、基礎となるモナド &lt;code&gt;m&lt;/code&gt; の計算を返します。</target>
        </trans-unit>
        <trans-unit id="0c6a5560b83d86896cc9662f87720adba5507322" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">パーサーを実行する最も一般的な方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; は、トークンuser inputの入力リストでパーサー &lt;code&gt;p&lt;/code&gt; を実行し &lt;code&gt;input&lt;/code&gt; 。これは、ソース &lt;code&gt;filePath&lt;/code&gt; から初期ユーザー状態 &lt;code&gt;st&lt;/code&gt; で取得されます。 &lt;code&gt;filePath&lt;/code&gt; には、エラーメッセージだけで使用され、空の文字列かもしれません。 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）またはタイプ &lt;code&gt;a&lt;/code&gt; の値（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）を返す、基礎となるモナド &lt;code&gt;m&lt;/code&gt; の計算を返します。</target>
        </trans-unit>
        <trans-unit id="b5be00a95c813a0dae9db110b897e76b924717d2" translate="yes" xml:space="preserve">
          <source>The motivation for the change is that it means &lt;code&gt;IO a&lt;/code&gt; actions default to &lt;code&gt;IO ()&lt;/code&gt;, which in turn means that ghci won&amp;rsquo;t try to print a result when running them. This is particularly important for &lt;code&gt;printf&lt;/code&gt;, which has an instance that returns &lt;code&gt;IO a&lt;/code&gt;. However, it is only able to return &lt;code&gt;undefined&lt;/code&gt; (the reason for the instance having this type is so that printf doesn&amp;rsquo;t require extensions to the class system), so if the type defaults to &lt;code&gt;Integer&lt;/code&gt; then ghci gives an error when running a printf.</source>
          <target state="translated">変更の動機は、それが &lt;code&gt;IO a&lt;/code&gt; アクションのデフォルトが &lt;code&gt;IO ()&lt;/code&gt; であることを意味します。これは、順番にghciが実行時に結果を出力しようとしないことを意味します。これは、 &lt;code&gt;IO a&lt;/code&gt; を返すインスタンスを持つ &lt;code&gt;printf&lt;/code&gt; にとって特に重要です。ただし、 &lt;code&gt;undefined&lt;/code&gt; を返すことしかできません（このタイプのインスタンスが存在する理由は、printfがクラスシステムへの拡張を必要としないためです）。そのため、タイプのデフォルトが &lt;code&gt;Integer&lt;/code&gt; である場合、printfの実行時にghciでエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="c736836da3c61a5b28a8e40cd26c58ac3671ca42" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">名前 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; は、との関係説明するために使用される &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; ：ここで、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; それだけで、その引数のトップレベルを評価するという意味で浅い &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; トラバースそれを完全に評価する全体のデータ構造。</target>
        </trans-unit>
        <trans-unit id="ecfeb2264bf3f2219dcf11640cc5f23d975957a1" translate="yes" xml:space="preserve">
          <source>The name of an executable with a list of arguments</source>
          <target state="translated">引数のリストを持つ実行可能ファイルの名前</target>
        </trans-unit>
        <trans-unit id="e05e238891a0e5d7a1ad5addb5acbfa1d828b57f" translate="yes" xml:space="preserve">
          <source>The name of the constructor</source>
          <target state="translated">コンストラクタの名前</target>
        </trans-unit>
        <trans-unit id="2372d4365121c955cf759525401a9a51abda2da3" translate="yes" xml:space="preserve">
          <source>The name of the datatype (unqualified)</source>
          <target state="translated">データ型の名前 (unqualified)</target>
        </trans-unit>
        <trans-unit id="4ad137cef439e5cbd9d31d951cbeeb39fa772cfe" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library on Windows systems (optional).</source>
          <target state="translated">Windows システム上の動的ライブラリの名前(オプション)。</target>
        </trans-unit>
        <trans-unit id="a75d937e0b98713b032f66a0d3ddc12a66577a2c" translate="yes" xml:space="preserve">
          <source>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (&lt;code&gt;.hi&lt;/code&gt; by default) instead of ⟨osuf⟩, and the relevant options are &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">インタフェースファイルの名前は接尾辞が⟨hisuf⟩（であることを除いて、同じルールを使用して導出される &lt;code&gt;.hi&lt;/code&gt; デフォルト）の代わりに、⟨osuf⟩、および関連するオプションがあり&lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;代わりに、&lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;それぞれ。</target>
        </trans-unit>
        <trans-unit id="6453686e83ae95972b7e17f3b926e084c57ab74f" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems. Note that we don&amp;rsquo;t support building dynamic libraries of Haskell code on Unix systems.</source>
          <target state="translated">UnixおよびWindows（mingw）システム上のライブラリーの名前。UnixシステムでのHaskellコードの動的ライブラリの構築はサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0f5dc8321c09ce84049b074ac570bfbec19828a" translate="yes" xml:space="preserve">
          <source>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the &lt;code&gt;-osuf&lt;/code&gt; option).</source>
          <target state="translated">GHCによって生成されるオブジェクトファイルの名前は、次の規則に従って派生します。ここで、「osuf」はオブジェクトファイルのサフィックスです（これは &lt;code&gt;-osuf&lt;/code&gt; オプションで変更できます）。</target>
        </trans-unit>
        <trans-unit id="6861c4770b27354d7d4cfab408a9a6ca379e4807" translate="yes" xml:space="preserve">
          <source>The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</source>
          <target state="translated">パターン同義語の名前は、適切なデータ・コンストラクタと同じ名前空間にあります。通常のデータコンストラクタと同様に、パターン同義語は、型コンストラクタとの関連付けによって、または独立してインポートおよびエクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="1be799bf296167235ebb2ca091eee552b142616f" translate="yes" xml:space="preserve">
          <source>The name of the program</source>
          <target state="translated">プログラム名</target>
        </trans-unit>
        <trans-unit id="39a42659e6043aff3532b0014c5b4fae37244931" translate="yes" xml:space="preserve">
          <source>The name of the selector</source>
          <target state="translated">セレクタの名前</target>
        </trans-unit>
        <trans-unit id="7c51ecee2db2e110dbf3d1d2d9420bc2a5044c61" translate="yes" xml:space="preserve">
          <source>The name of the zone, typically a three- or four-letter acronym.</source>
          <target state="translated">ゾーンの名前で、通常は3文字または4文字の頭文字をとったものです。</target>
        </trans-unit>
        <trans-unit id="4e49908da6a172e68a423a7eb23e95b552938d75" translate="yes" xml:space="preserve">
          <source>The name of this group (gr_name)</source>
          <target state="translated">このグループの名前 (gr_name)</target>
        </trans-unit>
        <trans-unit id="fae25b47526c2bd90bbb6d0b312e7136e668661b" translate="yes" xml:space="preserve">
          <source>The name of this operator is an allusion to &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt;. Note the similarities between their types:</source>
          <target state="translated">この演算子の名前は &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; の暗示です。それらのタイプの類似点に注意してください。</target>
        </trans-unit>
        <trans-unit id="3bffd90620f4f0f826e5aaf337b1fe1334e782e4" translate="yes" xml:space="preserve">
          <source>The name without its module prefix.</source>
          <target state="translated">モジュールの接頭辞を除いた名前。</target>
        </trans-unit>
        <trans-unit id="646f96f37bb735ef8278fbc57b542fce8c940d51" translate="yes" xml:space="preserve">
          <source>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt;. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</source>
          <target state="translated">名前付きワイルドカードは、引数と結果の型が同じになるように強制します。署名がなければ、GHCは &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt; を推測したでしょう。（Char、a）-&amp;gt;（Char、b）。名前付きワイルドカードは、型シグネチャのモノタイプ部分にも出現することを条件に、制約で言及できます。</target>
        </trans-unit>
        <trans-unit id="1eb6c48a77c3ff916d6d31d64741779306bc02b7" translate="yes" xml:space="preserve">
          <source>The names in this module resemble those in the &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; family of modules, but are shorter due to the assumption of qualified naming.</source>
          <target state="translated">このモジュールの名前は、モジュールの &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; ファミリの名前に似ていますが、修飾された名前を想定しているため、短くなっています。</target>
        </trans-unit>
        <trans-unit id="2a298a889af18ee73428f1b23010db1d461094d5" translate="yes" xml:space="preserve">
          <source>The namespaces are:</source>
          <target state="translated">名前空間は</target>
        </trans-unit>
        <trans-unit id="c41bfe70547efc280b4b232c6db8795351037886" translate="yes" xml:space="preserve">
          <source>The naming scheme may look a bit weird, but it has the purpose of allowing the co-existence of import libraries with ordinary static libraries (e.g., &lt;code&gt;libHSfoo.a&lt;/code&gt; and &lt;code&gt;libHSfoo.dll.a&lt;/code&gt;. Additionally, when the compiler driver is linking in non-static mode, it will rewrite occurrence of &lt;code&gt;-lHSfoo&lt;/code&gt; on the command line to &lt;code&gt;-lHSfoo.dll&lt;/code&gt;. By doing this for you, switching from non-static to static linking is simply a question of adding &lt;code&gt;-static&lt;/code&gt; to your command line.</source>
          <target state="translated">命名スキームは少し奇妙に見えるかもしれませんが、通常の静的ライブラリ（たとえば、 &lt;code&gt;libHSfoo.a&lt;/code&gt; および &lt;code&gt;libHSfoo.dll.a&lt;/code&gt; )とインポートライブラリの共存を許可する目的があります。さらに、コンパイラドライバが非-staticモード、それが発生書き換えます &lt;code&gt;-lHSfoo&lt;/code&gt; にコマンドラインで &lt;code&gt;-lHSfoo.dll&lt;/code&gt; を。静的リンクに非静的からの切り替え、あなたのためにこれを行うことにより、単純に追加の質問です &lt;code&gt;-static&lt;/code&gt; をコマンド・ラインに。</target>
        </trans-unit>
        <trans-unit id="a0044db577b12199ca68313af424ef55cbf96d30" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17286b53488467d11ce996bb67e9ac72d58ccc97" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78f21582e0027e530ef578f9b561481600ae0181" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">現在のプラットフォームのネイティブ改行表現：Unixシステムでは &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; 、Windows では &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38af79343aeda66e3c105c4d632b98dde240785" translate="yes" xml:space="preserve">
          <source>The natural generated &lt;code&gt;Eq&lt;/code&gt; code would result in these instance declarations:</source>
          <target state="translated">自然に生成された &lt;code&gt;Eq&lt;/code&gt; コードは、これらのインスタンス宣言になります。</target>
        </trans-unit>
        <trans-unit id="2aa75ff914d05468b9b141013cb484ac0d26b5d2" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はオリジナルのファイナライザを共有します。ファイナライズの観点からは、オリジナルへの別の参照を作成することと同等です。つまり、ファイナライザは、新しい &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が到達不能になる前に呼び出されることはなく、この呼び出しが原因でさらに呼び出されることもありません。また、ファイナライザは、この呼び出しが行われなかった場合と同じアドレスで呼び出されます。*新しいアドレスではありません*。</target>
        </trans-unit>
        <trans-unit id="d537ecc2a0a7273339bdcd281e6203980acce3cf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はオリジナルのファイナライザを共有します。ファイナライズの観点からは、オリジナルへの別の参照を作成することと同等です。つまり、ファイナライザは、新しい &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が到達不能になる前に呼び出されることはなく、この呼び出しが原因でさらに呼び出されることもありません。また、ファイナライザは、この呼び出しが行われなかった場合と同じアドレスで呼び出されます。*新しいアドレスではありません*。</target>
        </trans-unit>
        <trans-unit id="9565bf7af2fc32661af4296e391a5a4f73420f53" translate="yes" xml:space="preserve">
          <source>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</source>
          <target state="translated">新しいアルゴリズムは、コードレイアウトのために、最後のジャンプ命令のみではなく、基本ブロックのすべての出て行くエッジを考慮します。また、関数の制御フローグラフを構築し、ホットなコードパスを見つけて順次配置することで、キャッシュ利用率とパフォーマンスを向上させています。</target>
        </trans-unit>
        <trans-unit id="0e6b6e161e08547e4c2e84b69fc3ce69fd7fe2bd" translate="yes" xml:space="preserve">
          <source>The new prompt is &lt;code&gt;*Main&lt;/code&gt;, which indicates that we are typing expressions in the context of the top-level of the &lt;code&gt;Main&lt;/code&gt; module. Everything that is in scope at the top-level in the module &lt;code&gt;Main&lt;/code&gt; we just loaded is also in scope at the prompt (probably including &lt;code&gt;Prelude&lt;/code&gt;, as long as &lt;code&gt;Main&lt;/code&gt; doesn&amp;rsquo;t explicitly hide it).</source>
          <target state="translated">新しいプロンプトは &lt;code&gt;*Main&lt;/code&gt; &lt;code&gt;Main&lt;/code&gt; です。これは、メインモジュールのトップレベルのコンテキストで式を入力していることを示します。ロードしたばかりのモジュール &lt;code&gt;Main&lt;/code&gt; のトップレベルのスコープにあるすべてのものは、プロンプトでもスコープにあります（ &lt;code&gt;Main&lt;/code&gt; が明示的に非表示にしない限り、おそらく &lt;code&gt;Prelude&lt;/code&gt; を含みます）。</target>
        </trans-unit>
        <trans-unit id="53f5b2e47a4b9ae427e19c9dbf1f618026a18fe1" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新しいスレッドは、親の&lt;em&gt;マスクされた&lt;/em&gt;状態を継承します（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="8d318f738e712b9a7c49deddbf087cc0b4b1ac85" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新しいスレッドは、親の&lt;em&gt;マスクされた&lt;/em&gt;状態を継承します（ &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="f49ffa4a3cda912cfa43024b34a8d1f99a2d6f8d" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新しいスレッドは軽量の&lt;em&gt;バインドされていない&lt;/em&gt;スレッドになります。このスレッドによって行われる外部呼び出しは、特定のOSスレッドによって行われるとは限りません。特定のOSスレッドで外部呼び出しを行う必要がある場合は、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="d79262bf7af143e8fe77bde10bec763c9abf1332" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新しいスレッドは軽量の&lt;em&gt;バインドされていない&lt;/em&gt;スレッドになります。このスレッドによって行われる外部呼び出しは、特定のOSスレッドによって行われるとは限りません。特定のOSスレッドで外部呼び出しを行う必要がある場合は、代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="bc43222cc5f22f48444dca9a33addd84a41162b9" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">新しく作成されたスレッドには、例外 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; を破棄する例外ハンドラーがあり、その他すべての例外はキャッチされなかった例外ハンドラーに渡されます。</target>
        </trans-unit>
        <trans-unit id="06467093ec13b99be21e49f501d476baef2995e0" translate="yes" xml:space="preserve">
          <source>The next Sunday strictly after a given day.</source>
          <target state="translated">与えられた日の後の次の日曜日は厳密には</target>
        </trans-unit>
        <trans-unit id="00554018ca7c76296e2e972dcf6e4032903f571e" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">非コピー実装は、配列タイプの特定のペア間でのみサポートされています。1つの制約は、配列の型が同じ表現でなければならないということです。GHCでは、次の配列型のペアに &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt; の非コピーO（1）実装があります。最適化されたバージョンは特殊化によって有効になるため、最適化（-O）でコンパイルして取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="a17dd35e1a788245fc2675b10d198269467558f5" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">非コピー実装は、配列タイプの特定のペア間でのみサポートされています。1つの制約は、配列の型が同じ表現でなければならないということです。GHCでは、次の配列型のペアに &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt; の非コピーO（1）実装があります。最適化されたバージョンは特殊化によって有効になるため、最適化（-O）でコンパイルして取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="4065cd5ff81b5cc613fc73a9059855b99c8be0cc" translate="yes" xml:space="preserve">
          <source>The non-termination is reported like this:</source>
          <target state="translated">非解約はこのように報告されています。</target>
        </trans-unit>
        <trans-unit id="7d6d02244fcddd7ae83db06c2e068263589664bf" translate="yes" xml:space="preserve">
          <source>The nonnegative magnitude of a complex number.</source>
          <target state="translated">複素数の非負の大きさ。</target>
        </trans-unit>
        <trans-unit id="2ff00bf6c0c197af17057ab64282dcdcec685b3e" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">通常の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 関数は、左ではなく右の関連性を持ちます。</target>
        </trans-unit>
        <trans-unit id="e8ea10bfd840fdd3f1f9ba01648e552adcfe5390" translate="yes" xml:space="preserve">
          <source>The normal rule in Haskell is that your program must supply a &lt;code&gt;main&lt;/code&gt; function in module &lt;code&gt;Main&lt;/code&gt;. When testing, it is often convenient to change which function is the &amp;ldquo;main&amp;rdquo; one, and the &lt;code&gt;-main-is&lt;/code&gt; flag allows you to do so. The ⟨thing⟩ can be one of:</source>
          <target state="translated">Haskellの通常のルールは、プログラムがモジュール &lt;code&gt;Main&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; 関数を提供する必要があるということです。テストするとき、どの関数が「メイン」関数であるかを変更すると便利なことがよくあります。 &lt;code&gt;-main-is&lt;/code&gt; フラグを使用すると、そうすることができます。「もの」は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8565c7cc336e9d2bc02ea4c1cab0de9e55beac01" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;a -&amp;gt; b&lt;/code&gt; used here between the &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; symbols &amp;mdash; not to be confused with a function type &amp;mdash; indicates that the &lt;code&gt;a&lt;/code&gt; parameter uniquely determines the &lt;code&gt;b&lt;/code&gt; parameter, and might be read as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; determines &lt;code&gt;b&lt;/code&gt;.&amp;rdquo; Thus &lt;code&gt;D&lt;/code&gt; is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of &lt;code&gt;E&lt;/code&gt;, we can see that &lt;code&gt;E&lt;/code&gt; represents a (partial) one-to-one mapping between types.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; の間でここで使用されている表記a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; また &lt;code&gt;where&lt;/code&gt; 記号（関数タイプと混同しないでください）は、 &lt;code&gt;b&lt;/code&gt; パラメーターがbパラメーターを一意に決定 &lt;code&gt;a&lt;/code&gt; ことを示し、「 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; を決定する」と解釈される場合があります。したがって、 &lt;code&gt;D&lt;/code&gt; は単なる関係ではなく、実際には（部分的な）関数です。同様に、 &lt;code&gt;E&lt;/code&gt; の定義に含まれている2つの依存関係から、 &lt;code&gt;E&lt;/code&gt; がタイプ間の（部分的な）1対1のマッピングを表していることがわかります。</target>
        </trans-unit>
        <trans-unit id="65e0f3cb1cdca573b0a31816dea29f6e08943a92" translate="yes" xml:space="preserve">
          <source>The null address.</source>
          <target state="translated">ヌルアドレスです。</target>
        </trans-unit>
        <trans-unit id="6f24da5886263ef92cea0da538817aecc2d6f529" translate="yes" xml:space="preserve">
          <source>The number of bytes that must be consumed</source>
          <target state="translated">消費するバイト数</target>
        </trans-unit>
        <trans-unit id="ca0f126d79cabf7e2c5e95757d200444f569118d" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Gregorian calendar. First argument is year, second is month.</source>
          <target state="translated">プロレプティック・グレゴリオ暦による月の日数。第一引数は年、第二引数は月。</target>
        </trans-unit>
        <trans-unit id="9391d34aef57b18832247680a9bb961c2cb802e0" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Julian calendar. First argument is year, second is month.</source>
          <target state="translated">プロレプティック・ユリウス暦による月の日数。第一引数は年、第二引数は月。</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">配列の要素数。</target>
        </trans-unit>
        <trans-unit id="43d9d47c41193f72155e7e7c1d8d822460113e6b" translate="yes" xml:space="preserve">
          <source>The number of minutes offset from UTC. Positive means local time will be later in the day than UTC.</source>
          <target state="translated">UTCからのオフセット分数。正の値は、現地時間がUTCよりも遅くなることを意味します。</target>
        </trans-unit>
        <trans-unit id="69b816c0ec0e62c60a64cad0412b6307fc8984cc" translate="yes" xml:space="preserve">
          <source>The number of times this particular point in the call tree was entered.</source>
          <target state="translated">コールツリーのこの特定のポイントが入力された回数。</target>
        </trans-unit>
        <trans-unit id="d0ef27c2e92d99ce3709f3c8cd8149198afbb479" translate="yes" xml:space="preserve">
          <source>The numeric branch for this version. This reflects the fact that most software versions are tree-structured; there is a main trunk which is tagged with versions at various points (1,2,3...), and the first branch off the trunk after version 3 is 3.1, the second branch off the trunk after version 3 is 3.2, and so on. The tree can be branched arbitrarily, just by adding more digits.</source>
          <target state="translated">このバージョンの数字のブランチ。これは、ほとんどのソフトウェアのバージョンがツリー構造になっているという事実を反映しています。ツリーは桁数を増やすだけで、任意に分岐させることができます。</target>
        </trans-unit>
        <trans-unit id="4f31d4347cd14b9ff9a95c759d4f40a65f6f736b" translate="yes" xml:space="preserve">
          <source>The object file, which normally ends in a &lt;code&gt;.o&lt;/code&gt; suffix, contains the compiled code for the module.</source>
          <target state="translated">通常、 &lt;code&gt;.o&lt;/code&gt; サフィックスで終わるオブジェクトファイルには、モジュールのコンパイル済みコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="805b61067737cd38cfcd7f8a184e0af8d81d4642" translate="yes" xml:space="preserve">
          <source>The object files, &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Bar.o&lt;/code&gt;, and &lt;code&gt;Bumble.o&lt;/code&gt; would be put into a subdirectory named after the architecture of the executing machine (&lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;mips&lt;/code&gt;, etc).</source>
          <target state="translated">オブジェクトファイル、 &lt;code&gt;Foo.o&lt;/code&gt; 、 &lt;code&gt;Bar.o&lt;/code&gt; 、および &lt;code&gt;Bumble.o&lt;/code&gt; は、実行マシン（のアーキテクチャにちなんで名付けられたサブディレクトリに置かれる &lt;code&gt;x86&lt;/code&gt; 、 &lt;code&gt;mips&lt;/code&gt; 、など）。</target>
        </trans-unit>
        <trans-unit id="75f3688b610f29c49c2454cfe45bd0a8cb6e12b0" translate="yes" xml:space="preserve">
          <source>The object version of the library used by GHCi.</source>
          <target state="translated">GHCiが使用しているライブラリのオブジェクト版です。</target>
        </trans-unit>
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">廃止された言語オプションの &lt;code&gt;PolymorphicComponents&lt;/code&gt; と&lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; は&lt;/a&gt;同義語です&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;。彼らはかつてGHCがもはや行わないより細かい区別を指定していました。（非推奨の警告を実際に引き出す必要がありますが、ライブラリの作成者が古いフラグの仕様を変更する必要を完全に回避するために、警告は表示されません。）</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">古い、影付きのバージョンの &lt;code&gt;T&lt;/code&gt; は、単に &lt;code&gt;T&lt;/code&gt; として表示される新しい &lt;code&gt;T&lt;/code&gt; と区別するために、GHCiによって &lt;code&gt;main::Interactive.T&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">このルールの唯一の例外はある&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; を&lt;/a&gt;介してインスタンスを導出するため&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;単に任意のコンストラクタの使用を必要としない空のインスタンス宣言を生成します。詳細については、「&lt;a href=&quot;#derive-any-class&quot;&gt;クラス&lt;/a&gt;の派生」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">IOアクションで許可のみIOオペレーションは渡さ &lt;code&gt;unsafeLocalState&lt;/code&gt; ある（）は、ローカルの割り当てを（ &lt;code&gt;alloca&lt;/code&gt; を、 &lt;code&gt;allocaBytes&lt;/code&gt; そのように誘導された操作 &lt;code&gt;withArray&lt;/code&gt; と &lt;code&gt;withCString&lt;/code&gt; ）、および（b）ポインタ操作（ &lt;code&gt;Foreign.Storable&lt;/code&gt; と &lt;code&gt;Foreign.Ptr&lt;/code&gt; ポインタ上の）ローカル記憶域、および（c）ローカル関数にローカルに割り当てられたメモリの読み取りまたは書き込み、あるいはその両方を行うことが唯一の観察可能な効果である外部関数。これらのルールに従わないIO操作を渡すと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">2つのグループの唯一の違いは、2番目のグループでは &lt;code&gt;len_acc&lt;/code&gt; に型シグネチャが与えられていることです。前者の場合、 &lt;code&gt;len_acc1&lt;/code&gt; はそれ自体右側が単相であるため、暗黙的なパラメーター &lt;code&gt;?acc&lt;/code&gt; は再帰呼び出しに渡されません。後者の場合、 &lt;code&gt;len_acc2&lt;/code&gt; には型シグニチャーがあるため、 &lt;code&gt;?acc&lt;/code&gt; を暗黙的なパラメーターとして取る&lt;em&gt;多態性&lt;/em&gt;バージョンに対して再帰呼び出しが行われます。したがって、GHCiで次の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">このようなシグネチャの唯一の許容される実装は、正確に同じエンティティを再エキスポートするモジュールです。</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; パーサーを明示的に呼び出す必要がある唯一のポイントは、先頭の空白をスキップするためのメインパーサーの開始です。</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; パーサーを明示的に呼び出す必要がある唯一のポイントは、先頭の空白をスキップするためのメインパーサーの開始です。</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">定義済みのインスタンスだけが何もしない明らかなものです。</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">文字列を通常通りに動作させるためには、事前に定義されたインスタンスしかないのが自明です。</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">唯一の問題は、モジュールにインスタンス宣言が含まれており、GHCがモジュールを訪問する他の理由がない場合に発生します。例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">あとは、ユーザーに公開される「フロントエンド」クラスを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unused&lt;/code&gt; コンストラクターの唯一の用途は、型変数 &lt;code&gt;cxt&lt;/code&gt; の正しい種類を強制することでした。</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">プログラムが実行されているオペレーティングシステム。</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; は返す &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の引数のファイルが存在し、ディレクトリまたはディレクトリへのシンボリックリンク、およびいずれかの場合 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; そうでありません。</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">引数ファイルが存在し、ディレクトリではない場合、オペレーション &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作は &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">で操作に失敗することがあります。</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">文字列に対する操作は似ています。</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">演算子部分は未定義関数の関数適用のように扱われ、ラムダ形式は未定義関数の適用を含むWHNFにある。</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">この最適化は、辞書をバインドするGADTに対しても動作します。どのクラスの辞書が必要かを静的に知っていれば、実行時に渡された辞書を間接的に使うのではなく、直接解くことができます。</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt;は、GHCが未登録モードでビルドされている場合にのみ使用できます。詳細については、&lt;a href=&quot;codegens#unreg&quot;&gt;未登録コンパイル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt;は、コンパイラーの前処理パスのみを実行し、結果をファイルにダンプします。</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;は、実行時にパターンマッチが失敗する可能性がある場所について警告します。空でないリストに適用すると、以下の関数 &lt;code&gt;g&lt;/code&gt; が失敗するため、&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">オプション&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; は&lt;/a&gt;、不足しているコンストラクターを介してアクセスすると失敗する可能性があるレコードフィールドについて警告します。以下の関数 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; に適用すると失敗するため、&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはその定義で警告を発します。</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">オプション&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;を指定すると、評価が開始するとすぐに各サンクがブラックホール化されます。デフォルトは「レイジーブラックホール」で、サンクは、何らかの理由でスレッドが一時停止したときにのみ評価中としてマークされます。ほとんどのサンクをブラックホール化する必要がないため、通常、レイジーブラックホールはより効率的です（1〜2％程度）。ただし、熱心なブラックホール化は、並列プログラムでの計算の繰り返しを避けることができ、これは並列処理にとって重要であることがよくあります。</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">プロンプトで入力された式に特別なデフォルトルールを適用するために、オプション &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; が有効になっています（&lt;a href=&quot;#extended-default-rules&quot;&gt;GHCiでのデフォルトのタイプを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">オプションの説明（ &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">注文要件（ &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">元のディスカッションはここにアーカイブされてい&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;ます。Data.Text.TextのDataインスタンスを取得できますか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">元のプログラムは明らかに間違っています。ここに別の種類のエラーがあります</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の元のデータコンストラクターのセット</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">もう1つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 操作である &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; には、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; を使用して持ち上げるのに適したタイプがあります。</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">他のコンビネータは、効率化のためにオーバーライドされても良いような、賢明なデフォルト定義を持っています。</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">他のメソッドは以下のデフォルト定義を持っており、同等の特殊な実装で上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">ロールの注釈が必要になる可能性のあるもう1つの場所は、 &lt;code&gt;hs-boot&lt;/code&gt; ファイル（&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;相互再帰的なモジュールをコンパイルする方法&lt;/a&gt;）です。ここでは、定義の右側を省略できます。いつものように、 &lt;code&gt;hs-boot&lt;/code&gt; ファイルで宣言されたタイプ/クラスは、ロールまで含めて、 &lt;code&gt;hs&lt;/code&gt; ファイルの定義と一致する必要があります。データ型のデフォルトの役割は、一般的な使用例に対応する &lt;code&gt;hs-boot&lt;/code&gt; ファイルでの表現です。</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">以下の他の戦術は、特別な場合の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; の最適化または単純化です。最も重要なこと、</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">&lt;code&gt;ghc-pkg recache&lt;/code&gt; が役立つもう1つのケースは、パッケージを手動で登録する場合です。適切なファイルをパッケージデータベースディレクトリに配置し、 &lt;code&gt;ghc-pkg recache&lt;/code&gt; を呼び出してキャッシュを更新するだけで、パッケージを登録できます。パッケージを登録するこの方法は、自動化されたパッケージングシステムに便利です。</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">型の外側の型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 無効にしない限り、すべてのパターンマッチの最も外側のパターンは暗黙の強打になります。これは、ケース式、ラムダのパターン、do表記、リスト内包などに適用されます。例えば</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">出力 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; は、行の左半分の未使用部分を反転したものです。</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">出力には、プログラムで発生した各例外(プログラムは実行中にいくつかの例外を発生させたりキャッチしたりすることがあります)についてのレポートが含まれており、各レポートは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">出力は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に関連付けられたバッファを使用してバッファリングされます。このバッファーが小さすぎて、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; アクションの1ステップを実行できない場合は、十分な大きさのバッファーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">出力は「ファイル」に配置されます。「ファイル」を省略すると、出力は &lt;code&gt;stderr&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt;の出力は、スペースで区切られた3つのフィールドを含むヘッダー行で始まります。</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">&lt;code&gt;+RTS -s&lt;/code&gt; の出力は、プログラムの実行中に作成および実行された「スパーク」の数を示し&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;ます&lt;/a&gt;（ガベージコレクターを制御するためのRTSオプションを参照）。これにより、 &lt;code&gt;par&lt;/code&gt; アノテーションが適切に機能していることがわかります。</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">このプログラムの出力。</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">オーバーロードされた不変配列インタフェース</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">型が宣言されているモジュールのパッケージ名</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">パッケージ仕様は、まだインストールされていないパッケージでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; によって返されるペアは、 &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; と同じペアである必要があります。</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">ペーパー&lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantifiedクラス制約&lt;/a&gt;（Bottu、Karachalias、Schrijvers、Oliveira、Wadler、Haskell Symposium 2017）は、この機能を例とともに技術的詳細で説明しているため、この提案の主要な参照ソースです。</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">パラメタライズ可能な例外モナド。</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">パラメータ化可能な &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; モナド。任意のモナドをMaybeモナドで構成することによって取得されます。</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">パラメタライズ可能なリーダーモナド。</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">括弧は必須です。</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">パーサー &lt;code&gt;anyToken&lt;/code&gt; は、あらゆる種類のトークンを受け入れます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; の実装に使用されます。受け入れられたトークンを返します。</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; はパーサー &lt;code&gt;p&lt;/code&gt; として動作しますが、パーサー &lt;code&gt;p&lt;/code&gt; が&lt;em&gt;入力を消費せずに&lt;/em&gt;失敗すると、期待エラーメッセージが期待エラーメッセージ &lt;code&gt;msg&lt;/code&gt; に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">パーサー &lt;code&gt;permute perm&lt;/code&gt; は、 &lt;code&gt;perm&lt;/code&gt; で記述されたパーサーの順列を解析します。オプションの文字列：たとえば、私たちはの順列解析したいとの、文字 &lt;code&gt;b&lt;/code&gt; とオプションの &lt;code&gt;c&lt;/code&gt; 。これは次のように説明できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">パーサーは、指定された関数 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返す任意の文字について、 &lt;code&gt;satisfy f&lt;/code&gt; が成功することを満たします。実際に解析される文字を返します。</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; は、関数 &lt;code&gt;testTok t&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; xを返すときに、結果 &lt;code&gt;x&lt;/code&gt; のトークン &lt;code&gt;t&lt;/code&gt; を受け入れます。 &lt;code&gt;t&lt;/code&gt; のソース位置は &lt;code&gt;posFromTok t&lt;/code&gt; によって返され、トークンは &lt;code&gt;showTok t&lt;/code&gt; を使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">パーサー &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; は、関数 &lt;code&gt;testTok t&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; xを返すときに、結果 &lt;code&gt;x&lt;/code&gt; のトークン &lt;code&gt;t&lt;/code&gt; を受け入れます。トークンは &lt;code&gt;showTok t&lt;/code&gt; を使用して表示できます。&lt;em&gt;次の&lt;/em&gt;トークンの位置は、現在のソース位置 &lt;code&gt;pos&lt;/code&gt; 、現在のトークン &lt;code&gt;t&lt;/code&gt; 、および残りのトークン &lt;code&gt;toks&lt;/code&gt; 、 &lt;code&gt;nextPos pos t toks&lt;/code&gt; で &lt;code&gt;nextPos&lt;/code&gt; が呼び出されたときに返される必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">パーサー &lt;code&gt;try p&lt;/code&gt; は、エラーが発生したときに入力を消費していないふりをすることを除いて、パーサー &lt;code&gt;p&lt;/code&gt; と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">パーサ &lt;code&gt;unexpected msg&lt;/code&gt; 常に予期しないエラーメッセージで失敗し &lt;code&gt;msg&lt;/code&gt; 任意の入力を消費せず。</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">パーサー &lt;code&gt;p&lt;/code&gt; が入力を消費しなかった場合（つまり、先読みが1の場合）にのみ &lt;code&gt;q&lt;/code&gt; が試行されるため、パーサーは&lt;em&gt;予測&lt;/em&gt;と呼ばれます。この非バックトラッキング動作により、パーサーコンビネーターの効率的な実装と適切なエラーメッセージの生成の両方が可能になります。</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; し（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;unexpected&lt;/code&gt; エラーメッセージの生成に使用される3つのパーサーです。これらのうち、一般的に使用されるのは（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）だけです。 &lt;code&gt;unexpected&lt;/code&gt; の使用例については、 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; の定義を参照してください。</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">「 &lt;code&gt;=&amp;gt;&lt;/code&gt; 」の前の部分が&lt;em&gt;コンテキスト&lt;/em&gt;であり、「 &lt;code&gt;=&amp;gt;&lt;/code&gt; 」の後の部分がインスタンス宣言の&lt;em&gt;先頭&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">最後のバッファを部分的に埋めたものを結果と一緒に表示します。</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">このグループのパスワード (gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; によって返されるパスは、その &lt;code&gt;name&lt;/code&gt; が複数のセグメントを持つ相対パスではない場合、同じ文字列が渡されたときに（ &lt;code&gt;ShellCommand&lt;/code&gt; ではなく &lt;code&gt;RawCommand&lt;/code&gt; として） &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; によって実行されるプログラムに対応します。</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">作成したいディレクトリへのパス</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">パターン</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">パターン構文は用語構文を反映しています。</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">パターン型シグネチャは、式の右側で型変数を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">RTSがOSから割り当てたピークメモリ。</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">この呼び出しとそのすべてのサブコールによって行われたプログラムの総メモリ割り当て (プロファイリング・オーバーヘッドを除く)のパーセンテージ。</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">この呼び出しによって行われたプログラムの総メモリ割り当て (プロファイリング・オーバーヘッドを除く)の割合。</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">呼び出しツリーのこの時点で費やしたプログラムの総実行時間のパーセンテージ。</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">プログラムの総実行時間のうち、コールツリーのこのポイント以下に費やされた時間の割合。</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">&lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; 範囲の複素数の位相。振幅がゼロの場合、位相も同様です。</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">プロセス識別子のプラットフォーム固有の型。</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配列の内容へのポインタは &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; によって取得されます。この考え方は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （ここで内部的に使用）に似ています。ポインタは、 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; に引数として渡された関数によって返された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションの実行中にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配列の内容へのポインタは &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; によって取得されます。この考え方は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （ここで内部的に使用）に似ています。ポインタは、 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; に引数として渡された関数によって返された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションの実行中にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">このタイプの多相型は、いくつかの設定で使用することができます。例えば、存在しないインスタンスに対してより良いエラーメッセージを提供するなど、制約として使用することができます。</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">サブレンジ内の添え字の位置。</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">この違いの実際的な意味は、&lt;em&gt;不正確な例外&lt;/em&gt;セマンティクスのために、</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">プラグマは、インスタンス宣言の &lt;code&gt;where&lt;/code&gt; 部分の内部で発生する必要があります。</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">セクション&lt;a href=&quot;#instance-overlap&quot;&gt;重複インスタンスで&lt;/a&gt;説明されているように、プラグマ &lt;code&gt;OVERLAPPING&lt;/code&gt; 、 &lt;code&gt;OVERLAPPABLE&lt;/code&gt; 、 &lt;code&gt;OVERLAPS&lt;/code&gt; 、 &lt;code&gt;INCOHERENT&lt;/code&gt; を使用して、個々のインスタンスの重複動作を指定します。プラグマは、次のように、 &lt;code&gt;instance&lt;/code&gt; キーワードの直後に記述されます。</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">プリプロセッサは、HaskellコンパイラがHaskell入力を適切に処理する直前に実行されますが、リテラルマークアップが取り除かれた後、(おそらく)CプリプロセッサがHaskell入力を洗浄した後に実行されます。</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">正確な配色は、環境変数 &lt;code&gt;GHC_COLORS&lt;/code&gt; （または &lt;code&gt;GHC_COLOURS&lt;/code&gt; ）によって制御されます。これは、 &lt;code&gt;key=value&lt;/code&gt; ペアのコロンで区切られたリストに設定できます。これらはデフォルト設定です：</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">積分型の精度は、ゼロパッドによって達成されます。積分フィールドに精度とゼロパッドの両方が与えられた場合、ゼロパッドは無視されます。</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">述語は同値を定義することを前提としています。</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">接頭辞「 &lt;code&gt;generic&lt;/code&gt; 」は、&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;関数の一般化されたバージョンであるオーバーロードされた関数を示します。</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">プリプロセッサは他の Haskell 拡張機能には対応できません。これらは別のモジュールに入れなければなりません。</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">共有ライブラリを管理する上で一番難しいのは、プログラムが実行時に必要なライブラリを見つけられるように配置することです。これがどのように動作するかの詳細はプラットフォームによって異なり、特に3つの主要なシステムがあります。Unix ELFプラットフォーム、Windows、Mac OS Xです。</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">ただし、非同期例外の主な原因は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">原始的なパーサーの組み合わせ。</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">プリモップは、&lt;a href=&quot;#glasgow-unboxed&quot;&gt;ボックス化されていないタイプ&lt;/a&gt;と&lt;a href=&quot;#unboxed-tuples&quot;&gt;ボックス化されていないタプル&lt;/a&gt;を広範囲に使用します。</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">ここでの問題は、このインスタンスでは、 &lt;code&gt;[a]&lt;/code&gt; の特定の1つの選択肢を &lt;code&gt;b&lt;/code&gt; の複数の選択肢に関連付けることができるため、 &lt;code&gt;D&lt;/code&gt; の定義で指定された依存関係と矛盾することです。より一般的には、これは、フォームのどのインスタンスでも次のことを意味します。</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">問題は、一般的に外部呼び出しを安全に中断することができないことです。ただし、GHCはUnixとWindowsの両方のほとんどのシステムコールで機能するブロッキングシステムコールを中断する方法を提供します。とき &lt;code&gt;InterruptibleFFI&lt;/code&gt; の拡張機能が有効になっている、外国通話がで注釈を付けることができ &lt;code&gt;interruptible&lt;/code&gt; の代わりに、 &lt;code&gt;safe&lt;/code&gt; か &lt;code&gt;unsafe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; を使用してブロードキャストチャネルを作成する場合の問題は、書き込みのみが行われ、読み取られない場合、アイテムがメモリに蓄積されることです。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; を使用してブロードキャストチャネルを作成することにより、クライアントが見た後にアイテムをガベージコレクションすることができます。</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">モジュールが信頼できるかどうかを確認する手順は、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグが存在するかどうかによって異なります。このチェックはどちらの場合も似ていますが、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグを使用すると、信頼できるモジュールを信頼できると見なすための追加要件が有効になります。</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">そのプロセスには、操作を実行するための十分な権限がありません。</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">バインディングがポリモーフィックである場合、プロセスは少し複雑になります。例を使用してプロセスを示します。簡単にするために、よく知られている &lt;code&gt;map&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">プロセス信号マスク</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">プロファイルデータ自体は、次のプロパティを持つツリーのようなオブジェクト（ここでは「コストセンタースタック」と呼びます）を含む &lt;code&gt;profile&lt;/code&gt; フィールドによって記述されます。</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">プロファイルツリー自体</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">プログラム&lt;strong&gt;hp2ps&lt;/strong&gt;プログラムは、 &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; ランタイムオプションによって生成された &lt;code&gt;.hp&lt;/code&gt; ファイルをヒーププロファイルのPostScriptグラフに変換します。慣例により、 &lt;code&gt;.hp&lt;/code&gt; によって処理されるファイルには.hp拡張子が&lt;strong&gt;付い&lt;/strong&gt;ています。PostScript出力は &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; @ .psに書き込まれ&lt;em&gt;ます&lt;/em&gt;。場合は &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 完全に省略され、その後、プログラムはフィルタとして動作します。&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">プログラムテキスト自体、Cスタック、非ヒープデータ（外部ライブラリによって割り当てられたデータ、RTSによって割り当てられたデータなど）、および &lt;code&gt;mmap()&lt;/code&gt; のメモリは、ヒーププロファイルではカウントされません。</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">プログラムのヒープが限界に達しているので、プログラムが持っているライブデータの量を減らすための措置を取る必要があります。注意事項。</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">プログラマーは、ソースプログラムの一部として書き換えルールを指定することができます(pragmaで)。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">疑似オブジェクトファイル &lt;code&gt;A.o-boot&lt;/code&gt; は空です（リンクしないでください！）が、Makefileを使用する場合、 &lt;code&gt;A.hi-boot&lt;/code&gt; が最後に更新された日時を記録することは非常に便利です（&lt;a href=&quot;#using-make&quot;&gt;makeの使用を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">テンプレートHaskellの公開顔</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; の目的は、バッファーを介してデータを読み書きできるI / Oデバイスに共通のインターフェイスを提供することです。 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; を実装するデバイスには、通常のファイル、メモリマップファイル、およびバイト文字列が含まれます。 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を実装する基になるデバイスは、 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">インストール済みパッケージIDの目的は、パッケージに依存するパッケージを再コンパイルせずに、パッケージの再インストールによって引き起こされる問題を検出することです。両方のパッケージが同じコンパイラを使用して同じソースコードからビルドされた場合でも、新しくコンパイルされたパッケージは以前のバージョンとは異なるABI（アプリケーションバイナリインターフェース）を持つ可能性があるため、依存関係の再コンパイルが必要です。インストールされたパッケージIDを使用すると、再コンパイルされたパッケージには以前のバージョンとは異なるインストール済みパッケージIDが含まれるため、以前のバージョンに依存していたパッケージは孤立し、依存関係の1つが満たされなくなります。この方法で壊れたパッケージは、 &lt;code&gt;ghc-pkg list&lt;/code&gt; 赤（可能であれば）またはブレースで囲まれた出力。次の例では、 &lt;code&gt;filepath&lt;/code&gt; パッケージを再コンパイルして再インストールしました。これにより、 &lt;code&gt;Cabal&lt;/code&gt; を含むさまざまな依存関係が壊れました。</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">Builderプリミティブを使用する目的は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のパフォーマンスを向上させることです。これらの改善は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって実行される最も一般的な2つのステップをより効率的にすることから生じています。これら2つのステップを順に説明します。</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型シグネチャの数量化は明示的です。例えば：</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">引用された ⟨string⟩ は任意であり、改行を含む場合があります。</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">引用符で囲まれた &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 文字列」は、2文字のシーケンス「|]」が最初に出現したところで終了します。エスケープは絶対に行われません。その文字シーケンスを文字列に埋め込む場合は、独自のエスケープ規則を作成し（たとえば、文字列 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 使用するなど）、クォーター関数で &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; を &lt;code&gt;&quot;|]&quot;&lt;/code&gt; として解釈する必要があります。 ] &quot;。これを実装する1つの方法は、エスケープ変換を実行する前処理パスを使用して見積書を作成することです。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;問題＃5348の説明&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">このより保守的な戦略の理論的根拠はで与えられている&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;論文&lt;/a&gt;「レッツが一般化してはならない」と「地元の前提とモジュラー型推論」、および関連する&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;ブログ記事&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">このコストセンターに起因する時間「ティック」の生の数。これから、上記の &lt;code&gt;%time&lt;/code&gt; の数値が得られます。</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">与えられたモナドに読み取り専用の環境を追加するリーダーモナド変換器。</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; がこのトレース名をバックトレース出力に表示しない理由は、デバッグ情報の解釈が不忠実であるためです。これは、Cに保存されている不変条件を想定していますが、Haskellプログラムにはありません。残念ながら、この動作が上流で修正されるまで、手動でこれを回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">後者の制限の理由は、インスタンスのマッチングをチェックする方法がないからです。以下を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">&lt;code&gt;mergeQs&lt;/code&gt; の呼び出しが遅延しているのは、キューの最後の要素が最下部になり、完全にソートされたシーケンスを評価できないためです。</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">信頼をチェックする2つのモードがある理由は、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;によって有効にされる追加の要件により、Safe Haskellの設計が侵襲的になるためです。フラグが有効になっているときにSafe Haskellを使用するパッケージは、ユーザーのマシン上の信頼できるパッケージの状態に応じてコンパイルされる場合とコンパイルされない場合があります。これはどちらも壊れやすく、Safe Haskellが提供する保証のいずれかを使用しようとしていない場合でも、全員にコンパイルエラーを引き起こします。デフォルトで&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; を&lt;/a&gt;無効にしてフラグにすると、Safe Haskellは常時オンの機能ではなくオプトイン拡張機能になります。</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">再バインド可能な演算子には、上記の表にある「期待されるタイプ」が必要です。これらのタイプは驚くほど一般的です。たとえば、次のタイプのバインド演算子を使用できます</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">小さいパーツからByteStringをアセンブルするための推奨される方法は、Data.ByteString.Builderからのビルダーモノイドを使用すること&lt;a href=&quot;data-bytestring-builder&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">小さい部分から遅延ByteStringをアセンブルするための推奨される方法は、Data.ByteString.Builderからのビルダーモノイドを使用すること&lt;a href=&quot;data-bytestring-builder&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">推奨されるチャンクサイズ。現在は4kに設定されていますが、メモリ管理のオーバーヘッドが少なくなります。</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">レコードフィールド &lt;code&gt;f&lt;/code&gt; は、何らかの形でスコープ内にあります（修飾または非修飾のいずれか）。</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; を再帰的に使用すると、2番目の引数の種類が &lt;code&gt;Type&lt;/code&gt; になります。ただし、型推論の場合と同様に、 &lt;code&gt;T&lt;/code&gt; に&lt;em&gt;完全なユーザー指定の種類シグネチャ&lt;/em&gt;（またはCUSK）を与えることにより、ポリモーフィックな再帰を実現できます。CUSKは、推論を必要とせずに、すべての引数の種類と結果の種類がわかっている場合に存在します。例えば：</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">参照は呼び出し元のプロセスで作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">関連する&lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set操作&lt;/a&gt;は、 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; で次のように表現できます。</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">レンダリングモード。</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">表現 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; ほんの少し違うからである &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。もう一度例として &lt;code&gt;Tree&lt;/code&gt; を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typの表現は抽象的に保持されており、実装が派手な表現(例えば、共有を管理するためのハッシュ結合)を使用することを可能にします。ビューパターンがなければ、このシグネチャを使うのは少し不便です。</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">外部ファイルやストリームにおける改行の表現。</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; の種類を呼び出すためにGHCによって生成される表現。</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">表現は再利用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; （及びそれにより &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ）と同様 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。（この再利用性が、kind- &lt;code&gt;*&lt;/code&gt; -typesのダミーの型引数を引き継ぐ理由ですが、これらのそれぞれを複製することなく、すでに十分に異なる名前が含まれています。）</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">このモジュールで使用される表現は、高性能な使用や大量のデータのストリーミングに適しています。これは、コンテンツ全体がメモリに常駐していることを必要とせずに、大きなテキストを操作するための手段を提供します。</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">タイプの表現 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 、及び機能 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; の派生インスタンスによって使用さ &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 構築する &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">再スケジュールタイマーはデフォルトで20msの粒度で実行されますが、これは &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTSオプションを使用して変更できます。「ティック」を再スケジュールした後、実行中のスレッドはできるだけ早く横取りされます。</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">解像度 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;getCurrentTime&lt;/code&gt; 、 &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">このセクションの残りの部分では、GADTスタイルのデータ型宣言についてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このセクションの残りの部分では、GADTをサポートするGHCの拡張機能の概要を説明します。拡張機能は&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;で有効になります。&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; の&lt;/a&gt;延長も設定&lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">機能の依存関係（&lt;a href=&quot;#functional-dependencies&quot;&gt;機能の依存関係&lt;/a&gt;）の制限は特に厄介です。ヘッドに現れないコンテキストで型変数を導入するのは魅力的です。これは通常のルールでは除外されます。例えば：</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内包の結果式は &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;最後&lt;/em&gt;であり、NoBindSである必要があり &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内包の結果式は &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;最後&lt;/em&gt;であり、NoBindSである必要があり &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">その結果、ホールまたは変数は &lt;code&gt;undefined&lt;/code&gt; のように動作しますが、コンパイル時に警告を表示し、実行時に評価された場合に同じメッセージを表示するという追加の利点があります。この動作は、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;を意味する-fdefer-type-errorsオプションの動作に従います。&lt;a href=&quot;#defer-type-errors&quot;&gt;タイプエラーのランタイムへの遅延を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">結果の種類の注釈はオプションであり、省略した場合のデフォルトは（引数の種類と同様に） &lt;code&gt;Type&lt;/code&gt; です。種類別のタイプファミリーは、kindアノテーションのパラメータを使用して宣言できます。</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、スペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、スペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、スペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">最後の継続として &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を使用してCPS計算を実行した結果。</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">特定の最後の継続でCPS計算を実行した結果。（ &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; の逆）</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">特定の最後の継続でCPS計算を実行した結果。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; の逆）</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">ID を最終的な続きとして CPS 計算を実行した結果。</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は入力文字列よりも長くなる場合があり、 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字「ﬓ」（現在はU + FB13）は、「մ」（男性、U + 0574）の後に「ն」（現在はU + 0576）が続くシーケンスに大文字小文字変換され、ギリシャ語「&amp;micro;」（マイクロ記号、U + 00B5）は、それ自体の代わりに「&amp;mu;」（小文字のmu、U + 03BC）に大文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は入力文字列よりも長くなる場合があり、 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字の男性（U + FB13）はバイグラムの男性（U + 0574 U + 0576）に大文字で折りたたまれていますが、マイクロ記号（U + 00B5）はギリシャ語の小文字muに大文字になっています（U + 03BC）それ自体ではなく。</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は入力文字列よりも長くなる場合があり、 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字の男性（U + FB13）はバイグラムの男性（U + 0574 U + 0576）に大文字で折りたたまれていますが、マイクロ記号（U + 00B5）はギリシャ語の小文字muに大文字になっています（U + 03BC）それ自体ではなく。</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、ラテン語の小字合字ﬂ(U+FB02)は、ラテン語の大文字F(U+0046)の後にラテン語の小字l(U+006C)が続くシーケンスに変換される。</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、&quot; İ&quot; (ラテン語の大文字Iの上にドットがある、U+0130)は、&quot;i&quot; (ラテン語の小文字i、U+0069)の後に&quot;̇&quot;が続く配列に対応しています。(上のドットを組み合わせて、U+0307)。</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">結果の文字列は、入力文字列よりも長い場合があります。たとえば、ドイツ語の &quot;&amp;szlig;&quot;（eszett、U + 00DF）は、2文字のシーケンス &quot;SS&quot;にマップされます。</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">結果の文字列は入力文字列よりも長いかもしれません。例えば、ドイツ語の eszett (U+00DF)は 2 文字列の SS に対応しています。</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、上にドットがあるラテン語の大文字 I (U+0130)は、ラテン語の小文字 i (U+0069)に続いて上にドットを組み合わせたもの (U+0307)に対応しています。</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">結果の型は &lt;code&gt;Show&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">結果の型は &lt;code&gt;()&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">結果の型もまた、曖昧さがないものでなければなりません。通常、これは推測できますが、グループ内のすべてのパターン同義語がコンストラクタで多相性を持っている場合、ユーザーは型署名を提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">各データコンストラクターの結果の型は、定義されている型コンストラクターで始まる必要があります。すべてのコンストラクターの結果の型が &lt;code&gt;T a1 ... an&lt;/code&gt; 形式である場合、 &lt;code&gt;a1 ... an&lt;/code&gt; は特殊型変数であり、データ型は&lt;em&gt;通常&lt;/em&gt;です。それ以外の場合は、&lt;em&gt;一般化された&lt;/em&gt;データ型です（&lt;a href=&quot;#gadt&quot;&gt;一般化代数データ型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">結果は、バインディングの（場合によっては）再帰的なセットになり、左側の単純な変数のみがバインディングされます。（Haskellレポートのように、さらに一歩進んで、 &lt;code&gt;fix&lt;/code&gt; を使用して再帰的バインディングを非再帰的にすることもできますが、Coreではそうしていません。問題を難読化するだけなので、ここでは行いません。）</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">結果のブロックは、 &lt;code&gt;compactFixupPointers#&lt;/code&gt; が呼び出されるまでGCに認識されません。アドレスがエスケープされたり、メモリがリークしたりしないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻りコードおよび起こり得る障害は、 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻りコードおよび起こり得る障害は、 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; です（これは &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; である必要がありますが、Haskellの型システムではこれが難しくなっています）。</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; の戻り値は、ガベージコレクターが実行されるタイミングに依存するため、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあります。</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; の戻り値は、ガベージコレクターが実行されるタイミングに依存するため、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあります。</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">その逆は必ずしも当てはまりません。2つの安定した名前が等しくない場合でも、それらの名前が付けられているオブジェクトは同じである可能性があります。ことに特に注意 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; が異なる返してもよい &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; をオブジェクトが評価された後。</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">その逆は必ずしも当てはまりません。2つの安定した名前が等しくない場合でも、それらの名前が付けられているオブジェクトは同じである可能性があります。ことに特に注意 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; が異なる返してもよい &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; をオブジェクトが評価された後。</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">書き換えは、 &lt;code&gt;Control.Exception.assert&lt;/code&gt; のアプリケーションを検出した場合にのみコンパイラーによって実行されるため、必要に応じて独自のバージョンの &lt;code&gt;assert&lt;/code&gt; を定義して使用できます。そうでない場合は、 &lt;code&gt;Control.Exception&lt;/code&gt; をインポートして、コードで &lt;code&gt;assert&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">レコード更新のルールはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">経験則では、 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を使用して遅延値の例外を強制または処理します。一方、効率の理由のみで遅延値を強制し、例外を気にしない場合は、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 使用できます。x。</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">経験則では、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を使用して遅延値の例外を強制または処理します。一方、効率の理由のみで遅延値を強制し、例外を気にしない場合は、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 使用できます。x。</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">ルールはこれです。</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">エクスポートリストのルール（Haskellレポート&lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;セクション5.2&lt;/a&gt;）では、タイプファミリーの調整が必要です。</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">字句スコープ型変数についての規則は、（参照&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句は、型変数をスコープ&lt;/a&gt;）パターン同義語署名に適用されます。これらのルールで指定されているように、パターン同義語の定義に対する、構文的に可視の外部 &lt;code&gt;forall&lt;/code&gt; （ユニバーサル）スコープからの型変数のみ。内部のforallによってバインドされた実存はありません。例えば</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">Typeable` 制約を解くためのルールは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの制限された型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスを保持するルール（算術シーケンスを扱うHaskellレポートのセクションを参照）は、ここで定義されているさまざまな &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの制限された型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスを保持するルール（算術シーケンスを扱うHaskellレポートのセクションを参照）は、ここで定義されているさまざまな &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">ランタイムは、一連の仮想プロセッサを管理します。これらは&lt;em&gt;機能&lt;/em&gt;と呼ばれ、その数は &lt;code&gt;-N&lt;/code&gt; オプションによって決定されます。各機能は一度に1つのHaskellスレッドを実行できるため、機能の数は、物理的に並行して実行できるHaskellスレッドの数と同じです。機能は、1つ以上のOSスレッドによってアニメーション化されます。ランタイムは各機能のOSスレッドのプールを管理するため、Haskellスレッドが外部呼び出しを行う場合（&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;マルチスレッドとFFIを&lt;/a&gt;参照）、別のOSスレッドがその機能を引き継ぐことができます。</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">ランタイムは、利用可能なワーカーOSスレッドのいずれかを使用してHaskellスレッドを実行します。特定のHaskellスレッドを実行するために使用される特定のOSスレッドを制御する必要がある場合、おそらくOS-thread-local状態を使用する外部ライブラリを呼び出す必要があるため、バインドされたスレッドが必要です（&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrentを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">&lt;code&gt;-v2&lt;/code&gt; と同じですが、さらに、各コンパイルフェーズの完全なコマンドライン（該当する場合）も出力されます。</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">&lt;code&gt;-v3&lt;/code&gt; と同じですが、各コンパイル段階の後の中間プログラム表現も出力されます（前処理済みファイルとC /アセンブリファイルを除く）。</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字を追加します。</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; と同じですが、非IO計算用です。包むために使用される &lt;code&gt;foreign export&lt;/code&gt; と &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; これらは非IOタイプでHaskellの関数をエクスポートするために使用されている場合。</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字を追加します。</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字を追加します。</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; と同じですが、同じ名前のパッケージがすでにインストールされている場合は、新しいパッケージに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">通常のHaskellのペアと同じですが</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">「 &lt;code&gt;Variable out of scope&lt;/code&gt; 」エラーの場合と同じ動作で、デフォルトでコンパイルを終了します。このようなエラーは、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;フラグを使用して延期できます。このフラグは、スコープ外の変数によって生成されたエラーを実行時まで延期し、それらをコンパイル時の警告に変換します。これらの警告は、&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;によって完全に抑制できます。</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">ソースからモジュールをコンパイルした場合でも、GHCがまだバッチモードであると見なしているため、同じフラグが必要です。</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">同じファンクターですが、要素を逆の順序で処理する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; インスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">同じファンクターですが、逆の順序でアクションを実行する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; インスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">同じ内容をまとめてみました。</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">同じフェーズ番号制御が &lt;code&gt;RULE&lt;/code&gt; （&lt;a href=&quot;#rewrite-rules&quot;&gt;書き換えルール&lt;/a&gt;）で使用できます。</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">同じ洗練された依存関係分析により、相互再帰関数の型シグネチャに異なるコンテキストを設定することもできます。これはHaskell 98では違法です（セクション4.5.2、最後の文）。GHCは、&lt;em&gt;洗練された&lt;/em&gt;グループの型シグネチャが同一の型シグネチャを持つことを主張するだけです。実際には、これは、同じパターンバインディングによってバインドされた変数のみが同じコンテキストを持つ必要があることを意味します。たとえば、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">&lt;code&gt;deriving&lt;/code&gt; 句によって生成されたインスタンスにも同じ制限が適用されます。したがって、以下が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">ここでのシナリオは、完全なプログラムをリンクすることではなく、Cのライブラリをデプロイするのと同じ方法でデプロイできるHaskellコードからライブラリを作成することを除いて、&lt;a href=&quot;#using-own-main&quot;&gt;独自のmain（）を使用する&lt;/a&gt;場合とほぼ同じです。コード。</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">デフォルトでは、検索パスには単一のディレクトリ「」が含まれています &lt;code&gt;.&lt;/code&gt; 」（つまり、現在のディレクトリ）。次のオプションを使用して、検索パスのコンテンツを追加または変更できます。</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">ソースファイルを見つけるための検索パスは、GHCiコマンドラインの&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;オプションで次のように指定します。</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">2 番目の引数は通常、アプリケーションの名前です。これはパスに統合されるので、有効なパス文字でなければなりません。注意:第二引数が絶対パスの場合、第二引数を返すだけです。</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">2つ目の句はもう少し面白いです。それは、右辺が重なり合う領域で一致していれば、2つの重複する型ファミリーインスタンスが許されると書いています。ここではいくつかの例が役に立ちます。</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2番目のコンストラクターは2つのフィールドで構成されます。それぞれは、タイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; （Tree a）として表されるタイプ &lt;code&gt;Tree a&lt;/code&gt; aの再帰フィールドです。個々のフィールドの表現は、バイナリ型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; を使用して結合されます。</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; が実行する2番目に一般的な手順は、境界プリミティブを使用してバッファーを埋めることです。これは次のように機能します。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の十分なスペースがあるかどうかのチェックは、有界プリミティブを実行するために残しました。存在する場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; はバインドされたプリミティブを実行し、更新されたバッファーで次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を呼び出します。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は新しいバッファーが必要であることをドライバーに通知します。このバッファーは、少なくともプリミティブの境界と同じ大きさでなければなりません。境界プリミティブを使用して、連続する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; バッファフリーチェックを融合することにより、バッファフリーチェックの数を減らすことができます。s。境界プリミティブを使用して、最初に十分なスペースがあることを確認してから、特定の値をエンコードする方法を決定することで、バッファーがいっぱいであることを通知するための制御フローを簡略化することもできます。</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">これらのケースのうち2つ目は、型が型パラメータと不等式であるにもかかわらず型パラメータを含んでいる場合で、意外と厄介なことがあります。例えば、次の例はコンパイルされています。</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">2番目のオプションは、フラグ&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;を追加することです（&lt;a href=&quot;ghci#external-interpreter&quot;&gt;別のプロセスでインタープリター&lt;/a&gt;を実行するを参照）。これは、別のプロセスでインタープリターを実行し、プロファイルされたコードを直接ロードして実行できます。コードを2回コンパイルする必要はありません。&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;を追加するだけで機能します。（このオプションはGHC 8.0.xでは実験的ですが、将来のリリースではデフォルトになる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">ファイルの2番目の部分は、プログラムで最もコストのかかる関数のコストセンターごとの内訳です。この場合、プログラムには1つの重要な関数、つまり &lt;code&gt;fib&lt;/code&gt; のみがあり、プログラムの時間と割り当てコストの両方を100％担当していました。</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">このマニュアルの種類ポリモーフィズムに関するセクションでは、型宣言とクラス宣言&lt;a href=&quot;#inferring-variable-order&quot;&gt;の変数の順序付け&lt;/a&gt;について説明しています（型/クラス宣言の変数の順序の推測）。</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">環境に適用するセレクタ機能。</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">セレクタの厳密性アノテーション(あれば</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">セレクタのunpackednessアノテーション(あれば)。</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">この場合のセマンティクスは、必要なエンティティのセットはそのエクスポートによって排他的に定義されるということです。この機能の背後にある動機は、ライブラリの作者が誰かが使いたいと思うかもしれないすべての関数の型を含むオムニバス署名を提供することを可能にする一方で、クライアントが実際に必要とするものにエクスポートを絞り込むことができるようにすることです。例えば、文字列のシグネチャを継承していると仮定して、必要なエンティティだけをリストアップしたこの形式のローカルシグネチャを書くかもしれません。</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; のセマンティクスはかなり単純です。GHCが &lt;code&gt;rec&lt;/code&gt; グループを見つけると、バインドされた変数のセットを計算し、 &lt;code&gt;MonadFix&lt;/code&gt; クラスに属する基になるモナディック値再帰演算子 &lt;code&gt;mfix&lt;/code&gt; への適切な呼び出しを導入します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskellパターンマッチングのセマンティクスは、Haskellレポートの&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;セクション3.17.2&lt;/a&gt;で説明されています。この説明に、次のように1つのアイテム10を追加します。</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">パターンの意味論 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">サーバ側のHaskellテンプレートの状態。これは StartTH メッセージによって作成されます。GHCがタイプチェックするモジュールごとに新しいものが作成されます。</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">スタティックポインタテーブルのスタティックポインタの位置を特定するために使用されるキーのセットは、異なるプログラムバイナリに対して安定していることは保証されていません。言い換えれば、同じプログラムバイナリから起動されたプロセスのみが同じキーセットを使用することが保証されます。</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">既知のエンコーディングのセットはシステムに依存しますが、少なくとも含まれています。</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プロンプトで現在&lt;em&gt;スコープ内&lt;/em&gt;にあるモジュールのセット。このセットは &lt;code&gt;import&lt;/code&gt; と&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;によって変更され、上記のように&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; の&lt;/a&gt;後に自動的に変更されます。スコープ内のモジュールのセットは、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; で&lt;/a&gt;表示できます。</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在&lt;em&gt;ロードされ&lt;/em&gt;ているモジュールのセット。このセットは、&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;によって変更され、&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">シグネチャは、パターンバインディングではなく、関数バインディングやむき出しの変数バインディングの型を与えます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; デコーダーを実行するための最も単純なインターフェース。デコーダーでエラーが発生した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; を呼び出した場合、または入力が不足した場合は、error を呼び出し &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合のシーケンスの動作は未定義です。これはほとんどのアプリケーションで発生する可能性は低いですが、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; を特に繰り返し、特に &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; と組み合わせて使用する場合は、いくつかの注意が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる可能性があります。この場合、関連する値は &lt;code&gt;c&lt;/code&gt; を使用して結合されます。</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる可能性があります。この場合、関連する値は &lt;code&gt;c&lt;/code&gt; を使用して結合されます。2つの元のキーのうち大きい方の値が &lt;code&gt;c&lt;/code&gt; の最初の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる可能性があります。この場合、元のキーの最大値が保持されます。</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; によって生成されたバイトシーケンスのサイズ。</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">セットのサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">バウンディングペアで定義されたサブレンジのサイズ。</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">サイズ付き整数データ型、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">持っていくことができるハンマーは、 &lt;code&gt;INLINE&lt;/code&gt; プラグマです。</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">解決策としては、インスタンス固有の関数を自分で定義し、それが早くにインライン化されないようにpragmaを付けて、そのためのRULEを与えることです。</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">プログラムのソースファイルがすべて同じディレクトリにある必要はありません。&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;オプションは、（参照、検索パスにディレクトリを追加するために使用することができます&lt;a href=&quot;separate_compilation#search-path&quot;&gt;検索パスを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">ソースの場所</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特別な &lt;code&gt;family&lt;/code&gt; は、ファミリを標準のデータ宣言と区別します。結果の種類の注釈はオプションであり、通常、省略した場合のデフォルトは &lt;code&gt;Type&lt;/code&gt; です。例は</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特別な &lt;code&gt;family&lt;/code&gt; は、ファミリーを標準の型宣言と区別します。結果の種類の注釈はオプションであり、通常、省略した場合のデフォルトは &lt;code&gt;Type&lt;/code&gt; です。例は</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; は、ビルドされている現在のパッケージを参照するために使用できる特別なパッケージ名です。</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">仕様はフォーマット文字で終了します。</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">指定されたファイルは、Cプログラム、コンパイルされたHaskellファイル、およびCヘッダーに含まれます。 &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; は自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">用指定子 &lt;code&gt;DiffTime&lt;/code&gt; 、 &lt;code&gt;NominalDiffTime&lt;/code&gt; 、 &lt;code&gt;CalendarDiffDays&lt;/code&gt; 、及び &lt;code&gt;CalendarDiffTime&lt;/code&gt; は、他の種類の意味的に分離されています。負の時間差の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; は一般に負になります（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ではなくremと考えてください）。</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">スプライス &lt;code&gt;$(blah1)&lt;/code&gt; は関数を参照することができない &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; の後宣言基の一部、従って見えない、同様に、ある &lt;code&gt;$(blah1)&lt;/code&gt; の定義を見ることができない &lt;code&gt;h&lt;/code&gt; が同じ宣言グループの一部であるので（ &lt;code&gt;$(blah1)&lt;/code&gt; 。ただし、スプライス &lt;code&gt;$(blah1)&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; の定義を見ることができます（直前の宣言グループにあるため）。</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">スプライス &lt;code&gt;$(blah2)&lt;/code&gt; は、スプライス &lt;code&gt;$(th2 ...)&lt;/code&gt; と同じ定義を参照します（ただし、それによって作成されるバインディング&lt;em&gt;はありません&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">スプライス &lt;code&gt;$(th1 ...)&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; の定義を参照します-スプライスはトップレベルであるため、前の宣言グループ内のすべての定義が表示されます（つまり、モジュール内のすべての定義が含まれますスプライス自体）。</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">スプライス &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;は&lt;/em&gt; &lt;code&gt;D&lt;/code&gt; を参照&lt;em&gt;できません&lt;/em&gt; -同じ宣言グループにあります。</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">スプライス &lt;code&gt;$(th2 ...)&lt;/code&gt; の定義は見るであろう &lt;code&gt;f&lt;/code&gt; は、すべてで作成されたバインディング &lt;code&gt;$(th1 ...)&lt;/code&gt; 、の定義 &lt;code&gt;h&lt;/code&gt; とによって作成されたすべてのバインディング &lt;code&gt;[qq|blah|]&lt;/code&gt; 彼らはすべての前にあります宣言グループ）。</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">走るためのスプライス</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">デフォルトでは、スタックはヒーププロファイルでカウントされません。RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">スタックトレースは、多くの場合、 &lt;code&gt;GHC.List.CAF&lt;/code&gt; のような情報のないもので始まる場合があります。これはGHCのオプティマイザのアーティファクトであり、プロファイリングシステムがコストセンター「CAF」に割り当てる例外を最上位に引き上げます。ただし、 &lt;code&gt;+RTS -xc&lt;/code&gt; は、現在のスタックを出力するだけでなく、CAFが評価された時点でより深く見え、スタックを報告します。CAF以外のスタックが見つかるまで、さらにスタックを報告する場合があります。上記の例では、次のスタック（ &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 後）には、プログラムが &lt;code&gt;head []&lt;/code&gt; を評価したときに実行していたことに関する多くの情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">スタックオーバーフローメッセージ。</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">スタンドアロン構文は、通常の &lt;code&gt;deriving&lt;/code&gt; 句が一般化されるのとまったく同じ方法で&lt;a href=&quot;#newtype-deriving&quot;&gt;newtypesに対して一般化されます&lt;/a&gt;（newtypesの一般化された派生インスタンス）。例えば：</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">スタンドアロンの派生宣言は、データ型宣言と同じモジュールにある必要はありません。（ただし、孤立したインスタンス（孤立&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;モジュールとインスタンス宣言&lt;/a&gt;）の危険性に注意してください）。</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">標準のC99 &lt;code&gt;fenv.h&lt;/code&gt; ヘッダーは、浮動小数点ユニットの状態を検査および変更するための操作を提供します。特に、浮動小数点演算で使用される丸めモードを変更でき、例外フラグをテストできます。</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">標準のCPUTimeライブラリ。</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">標準のIOライブラリです。</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS Xの標準的な想定では、ビルド時に動的ライブラリに「インストール名」というスタンプが付けられます。これは、ライブラリファイルの最終的な完全インストールパスです。その後にリンクするライブラリまたは実行可能ファイル（まだインストールされていない場合でも）は、その実行時検索場所としてそのパスを選択します。 ghcで直接コンパイルする場合、インストール名はデフォルトで、ビルドされた場所に設定されます。これは、 &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; オプション（ &lt;code&gt;-install_name&lt;/code&gt; をAppleリンカーに渡す）でオーバーライドできます。 Cabalがこれを行います。動的ライブラリのインストール名を、最終的なインストール場所の絶対パスに自動的に設定します。</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">したがって、標準のデフォルトルールが拡張されています。デフォルトは、すべての未解決の制約が標準クラス&lt;em&gt;または&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; に関係する場合に適用されます。少なくとも1つは数値クラス&lt;em&gt;または&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">標準関数 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; は、安定したポインターテーブルをロックし、指定された安定したポインターを解放してから、安定したポインターテーブルを再度ロック解除します。多くの安定したポインタを一度に解放するときは、通常、テーブルのロックとロック解除を一度だけ行う方が効率的です。</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">テキストをエンコードおよびデコードするための標準関数は厳密です。つまり、無効な入力に対して例外をスローします。これは実際の入力では役に立たないことが多いため、無効な入力を処理するためのカスタムハンドラーを受け入れる代替関数が存在します。これらの &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; ハンドラーは通常のHaskell関数です。このモジュールで提供されている関数の1つを使用するか、独自のカスタムハンドラーを作成できます。</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; で使用される標準のイディオムは、継続に名前を付けるためのラムダ式を提供することです。次に、そのスコープ内の任意の場所で名前付き継続を呼び出すと、ネストされた計算内の多くの層である場合でも、計算から脱出します。</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">標準ライブラリはこのデバイスタイプを直接サポートしていませんが、ユーザーの実装では、ディレクトリ内のファイル名のリストを、 &lt;code&gt;&quot;.&quot;&lt;/code&gt; を除く &lt;code&gt;'\0'&lt;/code&gt; 文字で区切って、任意の順序で提供する必要があります。および &lt;code&gt;&quot;..&quot;&lt;/code&gt; 名前。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; も参照してください。シーク操作は、ディレクトリ（ゼロ位置以外）ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">システムローダーの標準ライブラリ検索パス。一部のシステムでは、 &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 環境変数を設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">実行スタックの状態</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">ステートメント &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; -return &lt;code&gt;return 42&lt;/code&gt; は、「 &lt;code&gt;IO&lt;/code&gt; モナドでreturn 42を実行し、結果を &lt;code&gt;x&lt;/code&gt; にバインドする」ことを意味します。その後、将来のステートメントで &lt;code&gt;x&lt;/code&gt; を使用できます。たとえば、上記のように出力します。</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">ステートメントはバインディングではないか、または1つの変数のみをバインドするモナディックバインディング（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">保存された値は、怠惰に計算される大きな仮想データ構造を表していません。</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">例外がスローされた時点から処理されるまでの間、バインド関数をバイパスして例外をスローできる計算を組み合わせる戦略。</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 型では、文字列全体が一度にメモリに収まる必要があります。レイジー &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; タイプは、小さなメモリフットプリントを使用して、メモリよりも大きい文字列をストリーミングできます。多くの場合、チャンクストリーミングのオーバーヘッドにより、レイジー &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; タイプが厳密なタイプよりも遅くなりますが、常にそうであるとは限りません。内部構造が異なるため、1つのモジュール内の関数の時間の複雑さが他のモジュールと異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">厳密性アナライザーは、関数内の引数と変数を「厳密に」処理できる場合を把握します（つまり、関数内のある時点で常に評価されます）。これにより、GHCは、遅延引数に適用されるとプログラムのセマンティクスを変更するために適用されないアンボックスなど、特定の最適化を適用できます。</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">ユーザーがソースコードで書いた通りのフィールドの厳しさ。例えば、以下のデータ型では</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">コンパイル中にGHCがフィールドを推測する厳密さ。 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; の 9つの異なる組み合わせがあるのに対し、GHCが決定する厳密性は、最終的に遅延、厳密、またはアンパックのいずれかになります。GHCが決定する内容は、ユーザーがソースコードに書き込んだ内容とGHCフラグの両方に影響されます。例として、次のデータ型について考えてみます。</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">コンパイラがセレクタに対して推論した厳しさは、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">このモジュールの文字列機能は、矢印キーやファンクションキーなどのユーザー入力に対応する文字列です。</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">パッケージ名の後の括弧内の文字列は、インストールされたパッケージIDです。通常、パッケージ名とバージョンで始まり、コンパイルされたパッケージから派生したハッシュ文字列で終わります。パッケージ間の依存関係は、パッケージとバージョンだけでなく、インストール済みのパッケージIDで表現されます。たとえば、 &lt;code&gt;haskell98&lt;/code&gt; パッケージの依存関係を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">有向グラフの強く接続された構成要素を逆トポロジカルにソートしたもの。</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">有向グラフの強く接続されたコンポーネント。トポロジカルにソートされています。この関数は、各ノードに関するすべての情報が保持される &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; を除いて、strongConnComp と同じです。このインターフェースは、 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; の結果（の一部）に &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; を適用する予定がある場合に使用されるため、依存関係情報を失いたくない。</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">グラフの強く接続された構成要素を、逆トポロジー順に並べたもの。</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">&lt;code&gt;n+k&lt;/code&gt; パターンでの減算演算、およびより大きいか等しいテストでは、スコープ内にある &lt;code&gt;(-)&lt;/code&gt; および &lt;code&gt;(&amp;gt;=)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">入力が不十分なためにデコードできなかった &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のサフィックス。</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; を一般化したアクションのコレクションの合計。</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">スーパークラスのインスタンスは以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">GHC で定義されているシンボルは以下の通りです。お使いのローカルのGHCのインストールでどのシンボルが定義されているかを確認するには、以下のトリックが便利です。</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が受け入れる構文は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が受け入れる構文は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">パターン同義語の構文とセマンティクスについては、次のサブセクションで詳しく説明します。&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;紙&lt;/a&gt;にはさらに多くの詳細があります。</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">最小限の完全定義の構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">プロンプト &lt;code&gt;*module&lt;/code&gt; の構文は、プロンプトで入力された式のスコープに寄与しているのが「モジュール」の完全な最上位スコープであることを示しています。なければ &lt;code&gt;*&lt;/code&gt; 、モジュールのちょうど輸出が表示されます。</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">構文は</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">構文は、（a）キーワード &lt;code&gt;deriving&lt;/code&gt; 、および（b） &lt;code&gt;where&lt;/code&gt; 部分がないことを除けば、通常のインスタンス宣言の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">構文は、選択肢の本体が式ではなくコマンドであることを除いて、 &lt;code&gt;case&lt;/code&gt; 式の場合と同じです。変換は &lt;code&gt;if&lt;/code&gt; コマンドの変換に似ています。</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">式のコストセンターアノテーションの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCiプロンプトで受け入れられるステートメントの構文は、Haskell &lt;code&gt;do&lt;/code&gt; 式のステートメントの構文とまったく同じです。ただし、ここではモナドのオーバーロードはありません。プロンプトで入力するステートメントは &lt;code&gt;IO&lt;/code&gt; モナドにある必要があります。</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">値の構文はフィールドによって異なります。様々なフィールドタイプがあります。</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">以下の表は、各種類のパターンシノニムが使用できる場所をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">テンプレートファイル(下記参照)。</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">一時記憶域は、サブ計算が終了すると（通常または例外を介して）解放されるため、この関数が戻った後&lt;em&gt;は&lt;/em&gt;、一時記憶域へのポインターを使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">「未登録」という用語は、実際には「バニラC経由でコンパイル」を意味し、GHCがプログラムを高速化するために通常使用するプラットフォーム固有のトリックの一部を無効にします。未登録でコンパイルする場合、GHCは単にgccを介してコンパイルされるCファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">用語レベルの構文も同様です。先行および先行バー（ &lt;code&gt;|&lt;/code&gt; ）は、それがどの代替案かを示します。上記のタイプの2つの用語を次に示します。</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">ファイルの3番目と最後のセクションでは、コスト中心スタックごとのプロファイルの内訳を示しています。これは、プログラムの呼び出しツリーのプロファイルです。上記の例では、 &lt;code&gt;fib&lt;/code&gt; へのコストのかかる呼び出しが &lt;code&gt;main&lt;/code&gt; からのものであることは明らかです。</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">第三のインスタンス宣言はカバレッジ条件に従わない。</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">3番目の種類のインスタンスは、すべての &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; 存在し、2つのバリアントがあります。</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">3番目の種類のワイルドカードは、&lt;em&gt;追加制約ワイルドカード&lt;/em&gt;です。追加の制約ワイルドカードの存在は、型チェック中に任意の数の追加の制約が推測され、型シグネチャに追加されることを示しています。以下の例では、extra-constraintsワイルドカードを使用して、3つの追加の制約を推測しています。</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">スレッドは &lt;code&gt;MVar&lt;/code&gt; でブロックされていますが、 &lt;code&gt;MVar&lt;/code&gt; への他の参照がないため、続行できません。</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">スレッドはSTMトランザクションの再試行を待機していますが、 &lt;code&gt;TVar&lt;/code&gt; への参照が他にないため、続行できません。</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">外部呼び出しを行うスレッドには、 &lt;code&gt;pthread_kill()&lt;/code&gt; を使用して &lt;code&gt;SIGPIPE&lt;/code&gt; シグナルが送信されます。これは通常、ブロッキングシステムコールを &lt;code&gt;EINTR&lt;/code&gt; で返すのに十分です（GHCはデフォルトで &lt;code&gt;SIGPIPE&lt;/code&gt; の空のシグナルハンドラーをインストールし、プロセスをすぐに終了するというデフォルトの動作をオーバーライドします）。</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">スレッドランタイムシステムは、以下のようなメリットを提供します。</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">プログラムの特定の部分で発生した時間と割り当ては、このコストセンタースタックのみでカバーされるコードによって発生するコストである「個別」と、すべてで発生するコストを含む「継承」の2つの方法で表示されます。このノードの子。</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">GC中の経過時間</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">GC前の同期中の経過時間</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">時間ロケール。</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">時間値、または指定された形式を使用して入力を解析できなかった場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">時間値です。</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">プログラムが実行全体に渡って割り当てたバイト数の合計。</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">実行されたゴミ収集の総数。</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">秒単位でのプログラム実行の合計ウォールタイム。</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IOの実行時に、トランザクションがメモリの一貫性のないビューを表示した可能性があります。トランザクションの実装方法が原因で、プログラム全体で真であると予想される不変条件は、トランザクション内では真にならない場合があります。通常、これはプログラマーには見えませんが、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を使用すると公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IOの実行時に、トランザクションがメモリの一貫性のないビューを表示した可能性があります。トランザクションの実装方法が原因で、プログラム全体で真であると予想される不変条件は、トランザクション内では真にならない場合があります。通常、これはプログラマーには見えませんが、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を使用すると公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">この翻訳は、再帰的バインディングや多相バインディング、また単純な非再帰的バインディングのために、バングパターンを意味のあるものにするために慎重に作られています。</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">このようなフォームの変換では &lt;code&gt;loop&lt;/code&gt; コンビ &lt;code&gt;ArrowLoop&lt;/code&gt; 使用されるため、関係する矢印はArrowLoopクラスに属している必要があります。</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">モナドを等価なモナドにマッピングするトリビアルモナド変換器。</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">孤立オブジェクトの問題は、インスタンスまたはルールが役割を果たす場合に備えて、GHCがすべての孤立モジュールのインターフェイスファイルを事前に読み取る必要があることです。詳細については、&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立モジュールとインスタンス宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">後者は型変数をスコープに入れる可能性があることを除いて、同じように扱われます（&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句的にスコープされた型変数を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">2つのコンストラクターには、期待するタイプがあります。</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">2つの関数 &lt;code&gt;comp1&lt;/code&gt; と &lt;code&gt;comp2&lt;/code&gt; 同じ意味を持っていますが、 &lt;code&gt;comp1&lt;/code&gt; に適用した場合にインライン化される&lt;em&gt;2つの&lt;/em&gt;引数ながら、 &lt;code&gt;comp2&lt;/code&gt; 必要となる&lt;em&gt;3つ&lt;/em&gt;。あなたが言うなら、これは大きな違いをもたらすかもしれません</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">2つのオプションセットは、次のように初期化されます。最初に、両方のオプションセットが、&lt;a href=&quot;#ghci-dot-files&quot;&gt;.ghciおよび.haskelineファイルで&lt;/a&gt;説明されているように初期化されます。次に、インタラクティブオプションが次のように変更されます。</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">オプションの2つのセットは、引数なしで、それぞれ&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;コマンドを使用して検査できます。たとえば、クリーンなGHCiセッションでは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のいずれかである値のタイプです。 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクタはのみで使用することができます &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; sの、そして &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクタにのみに使用することができます &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （S）</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内に、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内に、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内に、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のいずれかである値のタイプです。 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクタはのみで使用することができます &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; sの、そして &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクタにのみに使用することができます &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （S）</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 型には、ロールを表すためのパラメーターがあり、これは一般的に最も一般的なケースです。 &lt;code&gt;Simple Age&lt;/code&gt; は &lt;code&gt;Simple Int&lt;/code&gt; と同じ表現になります。一方、 &lt;code&gt;Complex&lt;/code&gt; 型は、Complexの役割とわずかな役割でパラメーターを持っています。&lt;em&gt;これ&lt;/em&gt;は、 &lt;code&gt;Complex Age&lt;/code&gt; と &lt;code&gt;Complex Int&lt;/code&gt; が同じでは&lt;em&gt;ない&lt;/em&gt;ためです。最後に、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Bool&lt;/code&gt; は無関係ですが、 &lt;code&gt;Phant Age&lt;/code&gt; と &lt;code&gt;Phant Bool&lt;/code&gt; 表現は同じです。</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">タイプ &lt;code&gt;StreamPermParser s st a&lt;/code&gt; は順列パーサーを示し、 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 関数によって変換されると、ユーザー状態 &lt;code&gt;st&lt;/code&gt; で &lt;code&gt;s&lt;/code&gt; ストリームを解析し、成功 &lt;code&gt;a&lt;/code&gt; とタイプaの値を返します。</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;a&lt;/code&gt; は、マーシャリング操作を提供する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのインスタンスになることがよくあります。ただし、これは必須ではなく、ポインタにアクセスするための独自の操作を提供できます。たとえば、C &lt;code&gt;struct&lt;/code&gt; フィールドを取得または設定する小さな外部関数を書くことができます。</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;a&lt;/code&gt; は、マーシャリング操作を提供する &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのインスタンスになることがよくあります。ただし、これは必須ではなく、ポインタにアクセスするための独自の操作を提供できます。たとえば、C &lt;code&gt;struct&lt;/code&gt; フィールドを取得または設定する小さな外部関数を書くことができます。</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">型 &lt;code&gt;t&lt;/code&gt; は任意の型です。</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">型チェッカーは、エラーメッセージに型環境のフラグメントを表示することがありますが、このフラグによって設定される最大数までしかありません。 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; でオフにすると、数に制限はありません。構文的には最上位のバインディングも通常は除外されます（それらは多数になる可能性があるため）が、 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; にも含まれています。</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; は、リフトされた型を安全に強制的に型変換できる型です。より具体的には、リフトタイプ &lt;code&gt;t&lt;/code&gt; および値 &lt;code&gt;x :: t&lt;/code&gt; 場合、 &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; のバリアントです。</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">型コンストラクタ &lt;code&gt;Proxy#&lt;/code&gt; は、いくつかの型変数を監視するために使用されます。モデリングタイプのアプリケーションなどを実行するためにプロキシ値を渡す場合に使用します。 &lt;code&gt;Proxy#&lt;/code&gt; 唯一のアンボクシングではない、それはまた、多型の種類があり、何の実行時表現を持っていない、完全に無料であること。</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; はすべて &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; のバリアントです。</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">タイプ関数 &lt;code&gt;Item&lt;/code&gt; は、構造体 &lt;code&gt;l&lt;/code&gt; のアイテムのタイプを返します。</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">内型 &lt;code&gt;SPECIALIZE&lt;/code&gt; のプラグマは、元の関数の種類未満の多型である任意のタイプであってもよいです。具体的には、元の関数が &lt;code&gt;f&lt;/code&gt; の場合、プラグマ</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">もちろん、型にはクラスのコンテキストも含まれています。</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; のタイプは頭痛の種ですが、操作上はリストフォールドの単純な一般化です。</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; の型はHaskell 98では不正です。これは、クラス型変数（この場合は &lt;code&gt;a&lt;/code&gt; ）のみを制約する制約 &lt;code&gt;Eq a&lt;/code&gt; が含まれているためです。この場合 &lt;code&gt;a&lt;/code&gt; ）。より正確には、クラスメソッドシグネチャの制約は、次の場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">いずれかに記載の任意の自由変数の型の &lt;code&gt;case&lt;/code&gt; 代替案は、硬質でなければなりません。</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; にインデックス、 &lt;code&gt;e&lt;/code&gt; に要素を持つ不変の非厳密（ボックス化）配列のタイプ。</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">空でないストリームの種類</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; メソッドのタイプは &lt;code&gt;[a]&lt;/code&gt; であり、これはデフォルトのメソッドのタイプでもあります。拡張機能&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;を使用して、この制限を解除し、デフォルトのメソッドに別のタイプを与えることができます。あなたはクラスで列挙の一般的な実装を書かれている場合たとえば、 &lt;code&gt;GEnum&lt;/code&gt; 方法と &lt;code&gt;genum&lt;/code&gt; の面で &lt;code&gt;GHC.Generics&lt;/code&gt; 、あなたは用途一般的な実装ということを、デフォルトの方法を指定することができます。</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">&lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; が示すように、引数のタイプは通常どおり、必要なタイプよりも一般的です。（ &lt;code&gt;reverse&lt;/code&gt; は &lt;code&gt;Ord&lt;/code&gt; 制約を必要としません。）</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 式全体の型は厳密でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">更新される式の型は推論されず、制約解決も行われないので、以下は曖昧なものとして却下されます。</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">オブジェクトのタイプは &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; のインスタンスである必要があります。これにより、単相型のオブジェクトのみが &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; に変換されることが保証されます。ポリモーフィックオブジェクトを &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; に変換するには、モノモーフィックな型シグネチャを与えます。例えば：</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">モナド &lt;code&gt;m&lt;/code&gt; 上で状態 &lt;code&gt;u&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; ストリームを処理する字句パーサーを保持するレコードのタイプ。</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">司法書士の種類は厳格なものでなければならない。</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">型パラメーター &lt;code&gt;c_m&lt;/code&gt; は、 &lt;code&gt;T1&lt;/code&gt; から &lt;code&gt;Tk&lt;/code&gt; の型変数のそれぞれに1回出現します。この条件が満たされないクラスを想像してみてください。例えば：</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">typeパラメータは &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; のインスタンスである必要があります。</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">もちろん、型パラメータはすべて型変数でなければなりませんが、そのうちのいくつか(すべてとは限りませんが)はクラスパラメータになります。各クラスのパラメータは,関連する型ごとに最大一度しか使用できませんが,いくつかは省略してもよいし,クラスの先頭以外の順番で使用してもよいでしょう.したがって、以下のような工夫された例が認められます。</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">このペアの型パターンは、 &lt;code&gt;x&lt;/code&gt; がリストの無限の入れ子に置き換えられた場合に等しくなります。これらのインスタンスを拒否することは、型の健全性のために必要です。</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型シグネチャは、明示的な &lt;code&gt;forall&lt;/code&gt; （&lt;a href=&quot;#decl-type-sigs&quot;&gt;宣言型シグネチャ&lt;/a&gt;）のため、型変数 &lt;code&gt;a&lt;/code&gt; をスコープに入れます。付随する値宣言の定義全体で &lt;code&gt;forall&lt;/code&gt; スコープによってバインドされた型変数。この例では、タイプ変数 &lt;code&gt;a&lt;/code&gt; は、 &lt;code&gt;ys&lt;/code&gt; のタイプシグネチャを含む、 &lt;code&gt;f&lt;/code&gt; の定義全体にスコープします。 Haskell 98では、 &lt;code&gt;ys&lt;/code&gt; の型を宣言することはできません。スコープ型変数の主な利点は、そうすることが可能になることです。</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">型クラスのデフォルトメソッドの型シグネチャは、対応するメインメソッドの型シグネチャと同じ形式にする必要があります。それ以外の場合、タイプチェッカーはそのクラスの定義を拒否します。「同じ形式をとる」とは、デフォルトの型シグネチャがメインの型シグネチャとはコンテキストが異なるだけであることを意味します。したがって、メソッド &lt;code&gt;bar&lt;/code&gt; がある場合：</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">インスタンス宣言の型シグネチャは、インスタンス型でインスタンス化されたクラス宣言の型シグネチャよりも(または同じ)多相性が高くなければなりません。例えば、これで構いません。</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">型シグネチャには、結果の型には現れない型変数が定量化されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; の型シグネチャは、その正しさが証明されていない推測に依存することをユーザーに通知します。この機能を使用する場合、ユーザーは依存関係を次のように確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">各コンストラクターの型シグニチャーは独立しており、通常どおり暗黙的に普遍的に数量化されます。特に、「 &lt;code&gt;data T a where&lt;/code&gt; 」ヘッダーの型変数にはスコープがなく、コンストラクターごとにユニバーサルに数量化された型変数が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">サイズとサイズの境界に使用されるタイプ。</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">タイプ変数 &lt;code&gt;a&lt;/code&gt; は他の制約に現れません</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">ここで使用されるタイプ変数 &lt;code&gt;e&lt;/code&gt; は要素タイプを表し、 &lt;code&gt;ce&lt;/code&gt; はコンテナー自体のタイプです。このフレームワーク内で、リストまたは特性関数（どちらも任意の等値型のコレクションを表すために使用できる）、ビットセット（文字のコレクションを表すために使用できる）、またはハッシュに対してこのクラスのインスタンスを定義することができます。テーブル（要素がハッシュ関数を持つ任意のコレクションを表すために使用できます）。標準の実装の詳細を省略すると、次の宣言になります。</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">型変数は、型シグネチャの &lt;code&gt;forall&lt;/code&gt; の最も外側にある、構文的に見える単一の要素によって数量化されます。たとえば、GHCは次の例をすべて拒否します。</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">型変数（指定されている場合）は明示的に分類される可能性があるため、次のように &lt;code&gt;Foo&lt;/code&gt; のヘッダーを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">型変数 &lt;code&gt;vk+1...vn&lt;/code&gt; は、型 &lt;code&gt;t&lt;/code&gt; 、 &lt;code&gt;s1..sk&lt;/code&gt; 、または &lt;code&gt;t1..tj&lt;/code&gt; では発生しません。</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; の先頭にある型変数、または &lt;code&gt;where&lt;/code&gt; 部分で定義されたメソッドの &lt;code&gt;instance&lt;/code&gt; 宣言スコープ。明示的な &lt;code&gt;forall&lt;/code&gt; は必要ありません（ &lt;code&gt;instance&lt;/code&gt; 宣言で明示的な &lt;code&gt;forall&lt;/code&gt; が許可されています。&lt;a href=&quot;#explicit-foralls&quot;&gt;明示的なユニバーサル数量化（forall）を&lt;/a&gt;参照）。例えば：</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">型ファミリー方程式の右辺の型変数は、いつものように、左辺によって明示的に束縛されなければなりません。ただし、右側には暗黙的にバインドされている種類の変数について言及できるため、この制限は&lt;em&gt;種類の&lt;/em&gt;変数に対しては緩和されています。たとえば、これらは正当です。</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">タイプ変数： &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプレベルの &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">タイプセーフキャスト動作</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 、クラス &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 、およびWord32とFloat、およびWord64とDouble間のキャスト。</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; は、やはりタイプレベルのプロキシであり、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; のいくつかのバリアントを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 、およびクラス &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">種類だけではこれらの法律を施行していないので、自分で確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">リファインメントホールフィットの追加のホールのタイプが出力に表示されます。たとえば、 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; はホールのリファインメント &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; です。このフラグがオフに切り替えられている場合、出力には &lt;code&gt;foldl1 _&lt;/code&gt; のみが表示されます。これは、 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; を必要とせずに、穴の直接の置き換えとして使用できます。</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">ボックス化されていないタプルの一般的な使用法は、単純に複数の値を返し、それらの複数の結果を &lt;code&gt;case&lt;/code&gt; 式にバインドすることです。</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">マップのリストの結合操作による結合。</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">組み合わせ操作でマップのリストの和集合、：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">組み合わせ操作でマップのリストの和集合、：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">地図のリストの結合。</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">マップのリストの結合：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">マップのリストの結合：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">セットのリストの和。</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Foldable構造内のセットの和集合：（ &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">このグループの一意の数値 ID (gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">ユニットのタイプ &lt;code&gt;()&lt;/code&gt; とリストタイプ &lt;code&gt;[]&lt;/code&gt; は、タイプデフォルトを行うときに試行されるタイプの標準リストの先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">ユーザーがソースコードで書いた通りのフィールドの展開度。例えば、以下のデータ型では</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">この結果、外部呼び出しでブロックされているHaskellスレッドがある場合、呼び出しが戻るまで &lt;code&gt;hs_exit()&lt;/code&gt; がハング（またはビジー待機）する可能性があります。したがって、 &lt;code&gt;hs_exit()&lt;/code&gt; を呼び出すときは、システムにそのようなスレッドがないことを確認することをお勧めします。これには、I / Oを実行するすべてのスレッドが含まれます。これは、I / Oが、外部呼び出しのブロックを使用して実装される場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">&lt;code&gt;Danger&lt;/code&gt; をコンパイルするために&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;を使用すると、使用できるHaskellの機能が&lt;a href=&quot;#safe-language&quot;&gt;安全なサブセットに&lt;/a&gt;制限されます。これには、 &lt;code&gt;unsafePerformIO&lt;/code&gt; 、テンプレートHaskell、純粋なFFI関数、RULESの禁止、および重複するインスタンスの操作の制限が含まれます。また、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;フラグは、 &lt;code&gt;Danger&lt;/code&gt; がインポートできるモジュールを、信頼できると見なされるモジュールのみに制限します。信頼できるモジュールは&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;でコンパイルされたモジュールであり、GHCはコードが安全であることを機械的に保証します。または、モジュールの作成者がモジュールが安全であると主張する&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされたモジュール。</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">存在するタイプの種類を示す &lt;code&gt;*&lt;/code&gt; の使用は、&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;拡張機能に依存しています。これは、将来のリリースではデフォルトでオフになり、削除される可能性があります。この理由と廃止予定は&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">使用 &lt;code&gt;?x&lt;/code&gt; の結合のために &lt;code&gt;?y&lt;/code&gt; バインディング「を参照してください」しません &lt;code&gt;?x&lt;/code&gt; の種類ので、 &lt;code&gt;f&lt;/code&gt; があります</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数の使用はかなり様式化されています。 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; な言語定義をインポートし、結果のGenTokenParserから必要な字句パーサーを選択します。</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数の使用はかなり様式化されています。 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; な言語定義をインポートし、結果のGenTokenParserから必要な字句パーサーを選択します。</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">コストセンター・スタックの有用性は、例を少し修正することでよりよく示されます。</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">ユーザーは、特にコンパイラーが&lt;a href=&quot;#default-deriving-strategy&quot;&gt;デフォルトで&lt;/a&gt;間違ったものを選択する場合は特に、必要な&lt;a href=&quot;#deriving-stragies&quot;&gt;派生戦略を&lt;/a&gt;オプションで宣言できます。</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">ユーザーデータベース</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">通常の出力ストリームは &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; です。（stderrがない）Windows GUIアプリケーションの場合、出力はWindowsデバッグコンソールに送信されます。これらの関数の実装によっては、出力されている文字列を修飾して、トレースしていることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">配列の指定されたインデックスの値。</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">メジャーリリース &lt;code&gt;x.y.z&lt;/code&gt; の &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; （「&lt;a href=&quot;phases#c-pre-processor&quot;&gt;Cプリプロセッサに影響するオプション」を&lt;/a&gt;参照）の値は整数「xyy」です（「y」が1桁の場合、先頭に0が追加されます。たとえば、バージョン6.8.2の場合）。 GHCの場合、 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">スナップショットリリースの &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; の値は整数「xyy」です。ただし、この値をテストする条件付きコードは決して記述しないでください。インターフェイスは日々変化し、 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; の値に細かい粒度がないため、条件付きでコンパイルするのは、テストを行う述語のみです。 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; が特定のメジャーリリースに等しいか、それよりも後か、またはそれより前か。</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">&lt;code&gt;seq a b&lt;/code&gt; の値は、 &lt;code&gt;a&lt;/code&gt; がボトムの場合はボトム、それ以外の場合は &lt;code&gt;b&lt;/code&gt; と等しくなります。つまり、最初の引数 &lt;code&gt;a&lt;/code&gt; を弱頭標準形（WHNF）として評価します。 &lt;code&gt;seq&lt;/code&gt; は通常、不要な遅延を回避してパフォーマンスを向上させるために導入されます。</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">コンパイル/リンク時のGHCフラグ &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; の値。</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">変数の型は多態的ではなく、 &lt;code&gt;()&lt;/code&gt; ではなく、 &lt;code&gt;Show&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">定義の左側の変数は、右側のパターンに拘束されます。双方向パターン同義語の場合、右辺のすべての変数は左辺にも発生しなければならず、また、ワイルドカードパターンやビューパターンも許されない。一方向性と明示的に双方向性のパターン同義語の場合、右側のパターンには制限はありません。</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">ランタイムのバリアント（「ウェイ」）。最も一般的な値は、 &lt;code&gt;rts_v&lt;/code&gt; （バニラ）、 &lt;code&gt;rts_thr&lt;/code&gt; （スレッド化されたランタイム、つまり&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;オプションを使用してリンクされている）および &lt;code&gt;rts_p&lt;/code&gt; （プロファイリングランタイム、つまり&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;オプションを使用してリンクされている）です。その他のバリアントには、 &lt;code&gt;debug&lt;/code&gt; （&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;を使用してリンク）と &lt;code&gt;dyn&lt;/code&gt; （RTSは、実行可能ファイル自体に静的にリンクされるのではなく、動的にリンクされます（つまり、共有ライブラリ）。これらは組み合わせることができます。たとえば、 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">さまざまな通信プロセスは、スタティックポインタテーブルの値を参照するために使用されるキーについて 合意する必要があるが、そうしないとルックアップが失敗する。同じプログラムバイナリから起動されたプロセスのみが、同じキーセットを使用することが保証される。</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">GHCのコピーのバージョン番号は呼び出すことによって見つけることができる &lt;code&gt;ghc&lt;/code&gt; して &lt;code&gt;--version&lt;/code&gt; する（参照フラグ&lt;a href=&quot;using#options-help&quot;&gt;冗長性オプションを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">プログラムのコンパイルに使用された、または解釈されている &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">このプログラムのコンパイルに使用したGHCのバージョン。</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">強く連結された構成要素のリストの頂点。</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">強く連結された構成要素の頂点。</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">関連するファミリインスタンスの右側にあるクラスパラメータの可視性は、ファミリのパラメータに&lt;em&gt;のみ&lt;/em&gt;依存します。例として、単純なクラス宣言を考えます</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; は&lt;/a&gt;、デフォルトではオフですが、&lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt;に含まれていますが、インポートしたモジュールがエクスポートしないものを非表示にすると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">アンダースコアで始まる名前の場合、警告は抑制されます。例えば</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">フィールド名がアンダースコアで始まる場合、警告は抑制されます。</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">警告は、重複した &lt;code&gt;Eq a&lt;/code&gt; 制約を示します。</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">警告は冗長な &lt;code&gt;Eq a&lt;/code&gt; 制約を示します：： &lt;code&gt;f&lt;/code&gt; の定義では使用されません。）</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">警告は、冗長な &lt;code&gt;Eq a&lt;/code&gt; 制約を示します。これは、 &lt;code&gt;Ord a&lt;/code&gt; 制約によって包含されます。</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">予測可能な動作を取得する方法は使用することです&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; の&lt;/a&gt;上で、プラグマ、またはインライン[⟨phase⟩]プラグマを &lt;code&gt;f&lt;/code&gt; 、そのルールが火にチャンスがあったまでそれがインライン化されていないことを保証するために、。警告フラグ&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（「&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告と&lt;/a&gt;正常性チェック」を参照）は、この状況について警告します。</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">このような状況を特定する方法は、データ型、クラス、および型の同義語の型変数に&lt;em&gt;役割を&lt;/em&gt;割り当てることです。</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">このライブラリのウィークポインタは、&lt;em&gt;ファイナライズ&lt;/em&gt;と呼ばれる別のアプローチをサポートしています。ウィークポインターによって参照されるキーが無効になると、ストレージマネージャーはプログラマー指定のファイナライザーを実行するように準備します。たとえば、メモテーブルの場合、ファイナライザはメモテーブルからキーと値のペアを削除できます。</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">回避策は、パッケージを構成する.oファイルを、 &lt;code&gt;base&lt;/code&gt; パッケージが行う方法に従って、2つ以上の.oに分割することです。</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">ワーキングディルクトリー</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">ラッパーと一般的なデフォルト</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">ジップ： &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">「クォータ」は「 &lt;code&gt;e&lt;/code&gt; 」、「 &lt;code&gt;t&lt;/code&gt; 」、「 &lt;code&gt;d&lt;/code&gt; 」、または「 &lt;code&gt;p&lt;/code&gt; 」にすることはできません。これらはテンプレートハスケルの引用と重複するためです。</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩は、インポートされたクォータの名前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">次に、 &lt;code&gt;Foo_stub.h&lt;/code&gt; には次のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">次に、 &lt;code&gt;Parser&lt;/code&gt; は &lt;code&gt;MonadPlus&lt;/code&gt; のインスタンスです。モナディックシーケンスは、パーサーの連結を実装し、 &lt;code&gt;mplus&lt;/code&gt; は選択肢を提供します。パーサーを使用するには、入力文字列に対して構築されたパーサーを実行するためのプリミティブが必要です。</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">次に、 &lt;code&gt;bar&lt;/code&gt; のデフォルトのメソッドは次の形式を取る必要があります。</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;stdout2&lt;/code&gt; を使用して標準出力に書き込むことができますが、 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; はそうではありません。</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">そして、アプリカティブデシュガーリングは、それを</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">次に、ユーザーが作成した変数が暗黙的に型変数の種類のスコープに組み込まれます。</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">その後、再びそれをコンパイル&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;、さらに使い &lt;code&gt;-osuf p_o&lt;/code&gt; 異なったオブジェクト・ファイルに名前を付けます（ここでは通常のオブジェクトのサフィックスではありません任意のサフィックスを選択することができます）。GHCは、スプライス式を実行するときに、最初のステップで構築されたオブジェクトファイルを自動的にロードします。あなたは省略した場合 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; を構築する際にフラグを&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;とテンプレートHaskellは使用され、GHCはエラーメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">その後、いくつかのインポートモジュール &lt;code&gt;M&lt;/code&gt; 、制約 &lt;code&gt;(E a Int)&lt;/code&gt; 設定することにより、「改善」されなければならない &lt;code&gt;a = T&lt;/code&gt; 、&lt;em&gt;明示的な言及がないにもかかわらず&lt;/em&gt;の &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;M&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">その後、 &lt;code&gt;HigherEq Option&lt;/code&gt; インスタンスを派生させることが可能になります。唯一の違いは、 &lt;code&gt;(==#)&lt;/code&gt; のデフォルト以外の型シグネチャが &lt;code&gt;Eq a&lt;/code&gt; 制約をもたらすことです。デフォルト以外のタイプシグネチャからの制約は、派生インスタンスコンテキスト自体には表示されませんが、デフォルトのタイプシグネチャによって要求される義務を解放するために使用できます。上記の例では、デフォルトのタイプシグネチャは &lt;code&gt;Eq a&lt;/code&gt; インスタンスを要求し、デフォルト以外のシグネチャはその要求を満たすことができたため、派生インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">すると、その旨のエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">次に、派生した &lt;code&gt;Foo&lt;/code&gt; インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">すると、派生インスタンス宣言は次のような形式になります。</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">次に、パーサーは実行する &lt;code&gt;tick&lt;/code&gt; 追跡します。</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">その後、プログラムの残りの部分は、構築されたフラグのリストを使用して動作を決定します。</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">次に、 &lt;code&gt;args.txt&lt;/code&gt; を使用して &lt;code&gt;foo&lt;/code&gt; を呼び出した結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">そうすると、こんな感じでプログラムを実行することができます。</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">次に、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; プリミティブの上に、 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 独自のバージョンを実装できます。</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">あり&lt;em&gt;、多くの&lt;/em&gt; GHCにより生成されたコードの品質に影響するオプションが。ほとんどの人は、「すばやくコンパイルする」や「プログラムを油を塗ったように実行する」などの一般的な目標しか持っていません。以下の最適化（またはその欠如）の「パッケージ」で十分です。</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将来的に削除されると期待されるいくつかの警告があります。このオプションは現在Windowsでは実装されておらず（何もしない）、外部インタープリターはGHCiデバッガーをサポートしていないため、ブレークポイントとシングルステップドン&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;と一緒に使用しないでください。</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">タイプされた穴に表示されるコンテキスト情報の量を制御するためのフラグがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">他にもいくつかのプロファイリング関連のコンパイルオプションがあります。&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt;に加えて&lt;/em&gt;使用します。これらは、プログラムのすべてのモジュールで一貫して使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">ここで注意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">次のような &lt;code&gt;case&lt;/code&gt; コマンドもあります</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">現在、有効な穴あけをソートするには2つの方法があります。ソートは &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; で切り替えることができます</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">オブジェクトコードへのコンパイルには欠点があります。たとえば、オブジェクトコードモジュールにブレークポイントを設定することはできません。解釈されたモジュールのようにすべてのトップレベルのバインディングではなく、オブジェクトコードモジュールのエクスポートのみがGHCiに表示されます。</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">（既存の）キーワードによって導入理解予選の5つの新しいフォーム、すべてがあり &lt;code&gt;then&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">RTSのオプションを設定するには4つの方法があります。</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">パラメータである位置と再帰的呼び出しである位置を区別しないデータ型汎用関数が多数存在します。また、データ型やコンストラクタの名前を全く気にしないデータ型汎用関数も数多く存在します。このような状況で汎用関数で考慮すべきケースの数を最小限に抑えるために、上で紹介した型コンストラクタの多くは実際には同義語であり、より小さなコンストラクタのセットの亜種であると定義されていることが判明しました。</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">生成できるプロファイルには、さまざまな RTS オプションで選択された多くの種類があります。この章の残りの部分では、様々な種類のプロファイルについて説明します。いくつかのプロファイルは、プログラムを実行した後、追加のツールを使用してさらに処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">このクラスの定義済みインスタンスはありません。デフォルトではスコープ内にありませんが、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;をインポートすることでスコープに含めることができます。異なり &lt;code&gt;IsString&lt;/code&gt; 、のための特別な不履行ルールはありません &lt;code&gt;IsLabel&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">実行可能なスレッドがないため、プログラムはデッドロックしています。 &lt;code&gt;Deadlock&lt;/code&gt; 例外は、メインスレッドだけで育てられています。</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; による&lt;/a&gt;構文の変更はありません。ソースレベルで表示される唯一の方法は、 &lt;code&gt;Monad&lt;/code&gt; 制約を必要としない &lt;code&gt;do&lt;/code&gt; 式を使用できることです。たとえば、GHCiの場合：</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">渡すタイプ &lt;code&gt;V1 p&lt;/code&gt; の値がないため（未定義を除く）、これは実際には不可能です。この場合、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスを定義することがなぜ有用なのかを尋ねることができますか？まあ、空の型は空ではない型の引数として使用でき、それでも結果の型をエンコードしたいかもしれません。少し不自然な例として、空の型ではなく、空のリストのみが含まれる &lt;code&gt;[Empty]&lt;/code&gt; を考えてみます。 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスは、私たちは、このようなタイプに汎用関数を呼び出すことができることを保証します。</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">何らかの例外をキャッチする必要がある場合があります。ただし、ほとんどの場合、これはクリーンアップを実行できるようにするためのものです。あなたは実際には例外自体に興味がありません。たとえば、ファイルを開いた場合、ファイルの処理が正常に実行されるか、例外がスローされるかに関係なく、ファイルを再度閉じます。ただし、これらのケースでは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; などの関数を使用できます。これらは実際には例外を渡しませんが、適切なポイントでクリーンアップ関数を呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">表現にアクセスするプラグインを定義するために使用できるいくつかの異なるアクセスポイントがあります。これらのすべてのフィールドは、 &lt;code&gt;-fplugin-opt&lt;/code&gt; フラグを使用してコンパイラに渡される &lt;code&gt;CommandLineOption&lt;/code&gt; 文字列のリストを受け取ります。</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">生成されるヒーププロファイルにはいくつかの異なる種類があります。すべての異なるプロファイルタイプは、時間に対するライブヒープのグラフを生成しますが、ライブヒープをバンドに分解する方法が異なります。以下の RTS オプションは、使用するブレークダウンを選択します。</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">例外をキャッチして調べるための関数がいくつかあります。これらはすべて、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内からのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">ガベージコレクションを正確に制御するためのオプションがいくつかあります。うまくいけば、通常の操作ではこれらは必要ありませんが、最大のパフォーマンスを得るために微調整できるものがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; が提供する他のいくつかのHaskellおよびGHC関連のメーリングリストがあります。完全なリストについては、&lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http：&lt;/a&gt; //www.haskell.org/mailman/listinfo/にアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">ここで注意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">実在的に数値化されたコンストラクタを使用する方法には、いくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; インスタンスを派生させることができるデータ型には、他にもいくつかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスがコンパイルに失敗するシナリオは他にもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">プリミティブ型の使用にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">アンボックス化されたタプルの使用にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">ヒーププロファイリングに関連するオプションは、さらに3つあります。</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">3つの新しいキーワードがあります： &lt;code&gt;group&lt;/code&gt; 、 &lt;code&gt;by&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 。（関数 &lt;code&gt;sortWith&lt;/code&gt; および &lt;code&gt;groupWith&lt;/code&gt; はキーワードではありません。これらは &lt;code&gt;GHC.Exts&lt;/code&gt; によってエクスポートされる通常の関数です。）</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">現在のコールスタックにアクセスするには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">特殊構文には2つのクラスがあります。</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLLを使用する方法には、2つの異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">このルールには2つの例外があります。</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">このデコーダを実行するには、遅延入力方式と増分入力方式の2種類の方法があります。ここでは遅延入力方式を使用します。</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">シーケンスとリストの違いは大きく分けて2つあります。</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">このカウンターでできることは2つあります。</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">browseコマンドには2つのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">これらのプラグマの使い方には2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">複数のプロセッサでプログラムを実行するには、プログラムから&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;を呼び出すか、RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;オプションを使用する2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">ファイルヘッダープラグマは好きなだけあり、コメントの前にも後にもつけることができます。</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">関連付けられた型のシノニムには、最大1つのデフォルト宣言があります。</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; への複数の呼び出しが存在する可能性がありますが、各呼び出しは &lt;code&gt;hs_exit()&lt;/code&gt; への1つ（そして1つだけ）の呼び出しと一致する必要があります。最も外側の &lt;code&gt;hs_exit()&lt;/code&gt; は、実際にはシステムを初期化解除します。現在、GHCのランタイムは、これが発生した後に確実に再初期化できないことに注意してください。&lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;外部関数インターフェイスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">「内訳」オプションは1つしかありません（例：上記の例では&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;）。ただし、適用できる追加の制限の数に制限はありません。1つの例外を除いて、すべてのオプションを組み合わせることが&lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt;ます&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;は現在、-hrオプションと-hbオプションの混在をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">タイプ &lt;code&gt;RtsConfig&lt;/code&gt; の変数を初期化するために使用する必要があるデフォルト値 &lt;code&gt;defaultRtsConfig&lt;/code&gt; があります。間違いなく将来的にはさらに多くのフィールドが &lt;code&gt;RtsConfig&lt;/code&gt; に追加されるので、コードを前方互換にするためには、上記のコードサンプルのように、 &lt;code&gt;defaultRtsConfig&lt;/code&gt; で初期化してから必要なフィールドを変更するのが最善です。</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;には、コンパイルの安全性に関連する問題といくつかの潜在的な解決策の詳細な議論があります。</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;control-monad#v:return&quot;&gt;返すことの&lt;/a&gt; 間には微妙な違いがあります！ xは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; の違いに似ています。遅延値 &lt;code&gt;x&lt;/code&gt; が例外をスローした場合、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;返し&lt;/a&gt; ます。 xは &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを返すことに失敗し、代わりに例外をスローします。一方、 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-exception#v:evaluate&quot;&gt;評価&lt;/a&gt;すると、常に &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが生成されます。そのアクションは、 &lt;code&gt;x&lt;/code&gt; が&lt;em&gt;評価&lt;/em&gt;時に例外をスローする場合に限り、&lt;em&gt;実行&lt;/em&gt;時に例外をスローします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;control-monad#v:return&quot;&gt;返すことの&lt;/a&gt; 間には微妙な違いがあります！ xは、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; の違いに似ています。遅延値 &lt;code&gt;x&lt;/code&gt; が例外をスローした場合、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;返し&lt;/a&gt; ます。 xは &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを返すことに失敗し、代わりに例外をスローします。一方、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;評価&lt;/a&gt;すると、常に &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが生成されます。そのアクションは、 &lt;code&gt;x&lt;/code&gt; が&lt;em&gt;評価&lt;/em&gt;時に例外をスローする場合に限り、&lt;em&gt;実行&lt;/em&gt;時に例外をスローします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デッドロック検出とファイナライザの間には微妙な相互作用があります（ &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; または&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;の関数によって作成されます）。ファイナライザの実行を待機しているスレッドがブロックされている場合、スレッドはデッドロックと見なされ、例外が送信されます。できればこれを行わないでください。ただし、代替手段がない場合は、 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; を指すようにすることで、スレッドがデッドロックと見なされるのを防ぐことができます。後で &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; を解放することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">不正な文字がどのように処理されるかを指定するための追加の記法があります (GNU iconv からの借用)。</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;スマートコンストラクターの&lt;/a&gt;広範なHaskellフォークアートがあります。本質的には、コンストラクターの周りに検証をラップし、その表現を公開しないようにする関数です。欠点は、基になるコンストラクターをマッチャーとして使用できないことです。パターン同義語は、検証とマッチングの両方で、本当にスマートなコンストラクターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">プロファイリング自体のオーバーヘッドがあり、それはプロファイラによって居住者の数値から差し引かれます。このオーバーヘッドは、プロファイリングをサポートしないでコンパイルすれば、もちろんなくなります。スペースのオーバーヘッドは、現在のところ、ヒープオブジェクトごとに2つの余分なワードがあり、おそらく30%程度のオーバーヘッドになります。</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">現在、「スタックトレース」の取得はサポートされていませんが、トレースおよび履歴機能は、エラーのコンテキストを確立するのに十分な2番目に優れた有用な2番目の機能を提供します。たとえば、コンパイルされたコード内から例外がスローされた場合でも、例外がスローされたときに自動的にブレークすることができます（&lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;例外のデバッグを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; の値は1つだけなので、それをエンコードするための知識は必要なく、ゼロビットを使用できます。</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; インスタンスはありません。現地時間を比較する場合は、 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; を使用します。絶対時間を比較する場合は、 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">&lt;code&gt;deRefStableName&lt;/code&gt; オペレーションはありません。安定した名前から元のHaskellオブジェクトに戻すことはできません。この理由は、オブジェクトの安定した名前の存在は、オブジェクト自体の存在を保証するものではないためです。それでもガベージコレクションは可能です。</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">何もありません &lt;code&gt;freeStableName&lt;/code&gt; の操作は異なり、&lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;秒。安定した名前は、不要になったときにランタイムシステムによって再利用されます。</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{-# UNPACK #-}&lt;/code&gt; は{-＃UNPACK＃-}または &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; アノテーションがないため、 &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; でタグ付けされています。</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">読み取りの前にクライアントは常に &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; を呼び出すため、読み取りバッファーに対応する操作はありません。</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">既存の型の名前を変更するだけのnewtypesには何の影響もありません。例えば</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">評価の順序に関する保証はありません。実装は、構造のコンポーネントを任意の順序または並列で評価できます。評価に実際の順序を課すには、 &lt;code&gt;parallel&lt;/code&gt; パッケージの&lt;a href=&quot;control-parallel&quot;&gt;Control.Parallelの&lt;/a&gt; &lt;code&gt;pseq&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;セーフポイント&lt;/em&gt;に到達したときにのみ例外が発生します。セーフポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;セーフポイント&lt;/em&gt;に到達したときにのみ例外が発生します。セーフポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;セーフポイント&lt;/em&gt;に到達したときにのみ例外が発生します。セーフポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;セーフポイント&lt;/em&gt;に到達したときにのみ例外が発生します。セーフポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">遅延の期限が切れたときにスレッドがすぐに再スケジュールされる保証はありませんが、スレッドは指定され&lt;em&gt;た&lt;/em&gt;よりも&lt;em&gt;早く&lt;/em&gt;実行され続けることは決してありません。</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">すべてのソースファイルを &lt;code&gt;ghc -M&lt;/code&gt; コマンドの引数としてリストする必要はありません。 &lt;code&gt;ghc&lt;/code&gt; は、 &lt;code&gt;ghc --make&lt;/code&gt; （GHC 6.4の新機能）と同様に、依存関係をトレースします。</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">ソースには &lt;code&gt;'NoSourceStrictness&lt;/code&gt; （ &lt;code&gt;!&lt;/code&gt; ）またはlaziness（ &lt;code&gt;~&lt;/code&gt; ）アノテーションがないため、'NoSourceStrictnessでタグ付けされています。</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">&lt;code&gt;Danger&lt;/code&gt; がインポートできるモジュールを制限する方法はありません。これにより、 &lt;code&gt;Danger&lt;/code&gt; の作者は非常に大きな攻撃対象となります。基本的に、現在システムにインストールされているパッケージです。これらのパッケージのいずれかに脆弱性がある場合、 &lt;code&gt;Danger&lt;/code&gt; モジュールがそれを悪用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">初期データ以外の入力を増やす方法はありません。より多くのデータをインクリメンタルに与えることができるようにするには、インクリメンタル入力インターフェースを参照してください。</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">現在、インポートリストとエクスポートリストにいくつかの潜在的なあいまいさが存在します。たとえば、 &lt;code&gt;import M( (+) )&lt;/code&gt; と書いた場合、&lt;em&gt;関数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; または&lt;em&gt;タイプコンストラクター&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; を意味しますか？デフォルトは前者ですが、&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（これは&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;によって暗示されます）を使用すると、GHCはキーワード &lt;code&gt;type&lt;/code&gt; を前に付けることで後者を指定できます。</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">一方のエッジケースがあります： &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 現在、常に空のリスト（何に関係なく生成 &lt;code&gt;tys&lt;/code&gt; 与えられているが）。</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">この一般的な規則には1つの例外があります&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;でプログラムをロードするとき、または &lt;code&gt;ghci&lt;/code&gt; を呼び出すときにそれを指定するときは、モジュール名ではなくファイル名を指定できます。このファイル名が存在する場合は読み込まれ、好きなモジュールを含めることができます。これは、同じディレクトリにいくつかの &lt;code&gt;Main&lt;/code&gt; モジュールがあり、それらをすべて &lt;code&gt;Main.hs&lt;/code&gt; と呼ぶことができない場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">特にトリッキーなケースがあるので説明しておきます。</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">統語的な曖昧さには一つの問題があります。考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つしかありません。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つしかありません。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つしかありません。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCiがプレリュードライブラリと標準ライブラリをロードしている間に短い一時停止が発生する場合があり、その後プロンプトが表示されます。バナーのとおり、次のように入力できます&lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;使用可能なコマンドのリストと、それぞれの半行の説明を表示します。これらのコマンドのほとんどについては、&lt;a href=&quot;#ghci-commands&quot;&gt;順を追って説明します。GHCiコマンドの&lt;/a&gt;すべてのコマンドの完全なドキュメントがあります。</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">同じキーで複数の弱いポインターが存在する場合があります。この場合、これらの弱ポインターのそれぞれのファイナライザは、キーが死んだときに、任意の順序で、あるいはおそらく同時に実行されます。プログラマが、オブジェクトへの唯一の参照を持つと仮定してファイナライザを指定した場合 (例えば、閉じたいファイルなど)、プログラマはそのようなファイナライザが 1 つだけであることを保証しなければなりません。</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">セミコロンで区切られた&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;プラグマには、0個以上のルールが存在する場合があります（レイアウトルールによって生成される場合があります）。</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">トークンにスペースを入れてはいけません &lt;code&gt;[quoter|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">値の宣言はあってはなりませんが、値の型のシグネチャを定義することはできます。例えば、シグネチャを定義することができます。</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">値の宣言はあってはなりませんが、値の型署名はあってもかまいません。例えば</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">曖昧な書き換えシステムを定義しないように、型族の方程式には何らかの制限が必要です。したがって,オープンな型族の方程式は互換性があるように制限されている.2つの型パターンは以下の場合に互換性がある.</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">以前は &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; の別のバリアント（つまり、 &lt;code&gt;Par0&lt;/code&gt; ）がありましたが、それ以降非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;並列&lt;/em&gt;&lt;em&gt;処理&lt;/em&gt;と&lt;em&gt;並列&lt;/em&gt;処理には細かい違いがあります。並列処理とは、複数のプロセッサを同時に使用してプログラムを&lt;em&gt;より高速に&lt;/em&gt;実行することです。一方、並行性は抽象化の手段です。これは、複数の非同期イベントに応答する必要があるプログラムを構築する便利な方法です。</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">作成するための特別な機能があります &lt;code&gt;StablePtr&lt;/code&gt; を： &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; は RTSが必要なため、 &lt;code&gt;StablePtr&lt;/code&gt; をプリミティブに &lt;code&gt;MVar#&lt;/code&gt; オブジェクト、そして我々は直接それを作成することはできません。ん&lt;em&gt;ではない&lt;/em&gt;だけに使用 &lt;code&gt;newStablePtr&lt;/code&gt; を上 &lt;code&gt;MVar&lt;/code&gt; ：あなたのプログラムがクラッシュします。</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">例外があります &lt;code&gt;CYGWIN&lt;/code&gt; 環境変数に &lt;code&gt;tty&lt;/code&gt; が含まれてい&lt;em&gt;ない&lt;/em&gt;場合は、Cygwinシェルを使用できます。このモードでは、CygwinシェルはWindowsコンソールシェルのように動作し、コンソールイベントは子プロセスに伝達されます。Cygwinシェルを開始する&lt;em&gt;前に&lt;/em&gt;、 &lt;code&gt;CYGWIN&lt;/code&gt; 環境変数を設定&lt;em&gt;する&lt;/em&gt;必要があることに注意してください。後で変更しても、シェルには影響しません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">外部ライブラリを使用する際に一つの他の落とし穴は心の中でクマにあります：ライブラリが含まれている場合は &lt;code&gt;main()&lt;/code&gt; 関数を、そしてこれはGHC自身とのリンクの競合になります &lt;code&gt;main()&lt;/code&gt; （機能など。 &lt;code&gt;libf2c&lt;/code&gt; と &lt;code&gt;libl&lt;/code&gt; 、自分の持っている &lt;code&gt;main()&lt;/code&gt; 秒）。</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">関数の &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ファミリの1つへの呼び出しでは、すべての例外ハンドラの周囲に暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; があります。これは、たいていの場合それが望ましいためです。例外ハンドラがすぐに到着した場合、スタックに別の例外を処理する例外ハンドラがない可能性があるため、例外ハンドラを開始する際の一般的な競合状態が解消されます。ただし、ハンドラに入るときに非同期例外がマスクされている場合は、中断される前に新しい例外ハンドラをインストールする時間があります。これがデフォルトでない場合、次のように書く必要があります</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">これらの &lt;code&gt;Names&lt;/code&gt; は、テンプレートHaskellの式、パターン、宣言などを構築するために使用できます &lt;code&gt;reify&lt;/code&gt; 関数の引数として指定することもできます。</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">これらのRTSオプションは、（a）GHCバグを回避するため、（b）「実際に何が起こっているか」を確認するため、または（c）好みに応じて使用できます。日常の使用にはお勧めしません！</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">これらと他の多くの例は、Hongwei XiとTim Sheardによる論文に記載されています。&lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;wikiには&lt;/a&gt;より長い紹介があり、Ralf Hinzeの&lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom typesに&lt;/a&gt;も多くの例があります。論文では、GHCで実装されている表記とは異なる表記が使用される場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">これらは、それぞれ &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">これらは、から入手できます&lt;em&gt;信頼できる&lt;/em&gt;モジュール&lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;だけでなく、</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">これらは、データコンストラクターが多態的な引数型を持つ &lt;code&gt;data&lt;/code&gt; と &lt;code&gt;newtype&lt;/code&gt; 宣言の例です。</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">これらは、プログラムを実行するためにコンパイルされたプラットフォームです。</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">これらはGHC自体がコンパイルされたプラットフォームです。ここでも通常はビルドプラットフォームとターゲットプラットフォームと同じです。</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">プログラムが構築されたプラットフォームです。(つまり、GHC自体のターゲットプラットフォームです。)通常はターゲットプラットフォームと同じです。(クロスコンパイルの場合は異なる可能性があります)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">これらの属性は、すべてのプロパティがオフになっています。</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">これらは、バグやパフォーマンスの問題の調査に役立ちます。量産コードでは使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">これらの機能は、 &lt;code&gt;cub&lt;/code&gt; 、 &lt;code&gt;cud&lt;/code&gt; 、 &lt;code&gt;cub1&lt;/code&gt; 、 &lt;code&gt;cud1&lt;/code&gt; などに直接対応します。</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">これらの文字とは、任意の空白文字、単一引用符、二重引用符、およびバックスラッシュ文字です。バックスラッシュ文字は常に後続の文字をエスケープします(すなわち、それ以上考慮せずに通過します)。文字は、ブロック内で引用符で囲むことでエスケープすることもできます(すなわち、ブロックを、それ自体がエスケープされていないシングルクォートかダブルクォートのいずれかのマッチするペアで囲むこと)。</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで、「レター」とは何かを定義します。</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントは、「マーク」とは何かを定義します。</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで、「数値」とは何かを定義します。</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントは、「句読点」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで、「セパレータ」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで「記号」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">これらのクラスは、ポータブルHaskellのトランスフォーマーの引数に対する制約を表現するために必要です。したがって、新しいトランスフォーマー &lt;code&gt;T&lt;/code&gt; の場合、次のようなインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">これらの考察から、オーファンモジュールの定義は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">これらはパラメトリックであることを保証します。</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">これらのイベントは&lt;em&gt;常に&lt;/em&gt; GHCシステムのバグです。報告してください。</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">これらのフラグにより​​、モジュールに「孤立した」インスタンス宣言または書き換えルールが含まれている場合は常に警告が発行されます。インスタンス宣言は、インスタンス化されるクラスもタイプも同じモジュールで宣言されていないモジュールに現れる場合、孤立します。別のモジュールで宣言された関数のルールである場合、そのルールは孤立しています。オーファンを含むモジュールは、オーファンモジュールと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">これらのフラグは、他のバックエンドから様々なビット情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">これらのフラグは、GHCのフロントエンドからさまざまな情報をダンプします。これには、パーサーとインターフェイスファイルリーダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">これらのフラグは、GHCのタイプチェッカーとリネーマーからさまざまな情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">これらのフラグは、GHCのC-\-パイプラインのさまざまなフェーズをダンプします。</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">これらのフラグは、GHCのコア間パイプラインのさまざまなフェーズをダンプします。これはdesugarerから始まり、単純化、ワーカーラッパー変換、ルールエンジン、スペシャライザ、厳密性/出現分析、および共通の部分式除去パスが含まれます。</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">これらのフラグは、GHCのSTGパイプラインのさまざまなフェーズをダンプします。</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">これらのフラグは、C-\-で始まりネイティブアセンブラを生成するネイティブ&lt;a href=&quot;codegens#native-code-gen&quot;&gt;コードジェネレータの&lt;/a&gt;パイプラインのさまざまなステージをダンプします。</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">これらのフラグは、個々の最適化をオンまたはオフにします。デフォルトでオンとマークされているフラグは &lt;code&gt;-O&lt;/code&gt; によって有効になるため、明示的に設定する必要はありません。フラグ &lt;code&gt;-fwombat&lt;/code&gt; は、 &lt;code&gt;-fno-wombat&lt;/code&gt; と言って無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">標準タイプのこれらのフォーマッターは、新しいタイプ固有のフォーマッターを作成する際の便宜のために提供されています。一般的なパターンは、 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; にスローして、新しいタイプのほとんどのフォーマット処理を行うことです。</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">これらの4つのプロパティは、安全な言語では型を信頼し、モジュールのエクスポートリストが尊重されていることを信頼し、コンパイルに成功したコードが通常と同じ意味を持つことを信頼できることを保証します。</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;によってもエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">これらの関数は、常にASCIIを想定するのではなく、現在のロケールによって決定されるエンコーディングを使用するという点で、対応する &lt;code&gt;CAString&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">これらの関数は、インスタンス化された型によって異なる結果を返す必要があるため、オーバーロードされています。</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">これらの関数は、シフト量がマシンInt#のビット数よりも大きい場合には定義されません。</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">これらの関数は内部的に様々なエラーを発生させるために使用され、新しい型固有のフォーマッタで使用するためにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">これらの関数を使用して、新しい代数型の &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスをアセンブルできます。たとえば、次の定義があるとします。</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">これらの関数はlevityポリモーフィック変数をバインドしないので、受け入れられます。これらのポリモーフィズムにより、ユーザはこれらの関数を便利に使用して、箱から出していない型を返す関数をスタブアウトすることができます。</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">これらの関数は、ファイナライザーとして任意の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを許可することにより、移植可能な&lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt;モジュールでその名前を一般化します。これらのファイナライザは、必然的に別のスレッドで実行されます。&lt;em&gt;デストラクタ、ファイナライザ、同期化&lt;/em&gt;、Hans Boehm、&lt;em&gt;POPL&lt;/em&gt;、2003年。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">これらの関数は,シーケンスの左端または右端から順次検索を行い,一致する要素のインデックスを返します.</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">これらの関数は、はるかに柔軟な &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; よりも前に作成されています。</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">これらの関数は、リスト &lt;code&gt;xs&lt;/code&gt; を0から &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; までの範囲のインデックスを持つインデックス付きコレクションとして扱います。</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">これらの関数は、リスト &lt;code&gt;xs&lt;/code&gt; を0から &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; までの範囲のインデックスを持つインデックス付きコレクションとして扱います。</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">これらのインスタンスは、暗黙的なkindパラメーターが異なるため互換性があります。1つ目は &lt;code&gt;Type&lt;/code&gt; を使用し、2つ目は &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">これらのマクロはGHC 7.10.1から利用可能です。</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">これらのマクロは、 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; で提供されるよりも細かい粒度を提供するために提供されています。ほとんどのAPIはパッチレベルのリリース間で安定していることが予想されるため、通常、これは必要ではありませんが、バグを修正するために内部APIの変更が必要になる場合があります。また、パッチレベルでの条件付きコンパイルは、古いリリースのバグを回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">これらのマクロは、Haskellモジュールから生成されたCソース（つまり、 &lt;code&gt;.hs&lt;/code&gt; 、 &lt;code&gt;.lhs&lt;/code&gt; 、 &lt;code&gt;.c&lt;/code&gt; 、および &lt;code&gt;.hc&lt;/code&gt; ファイル）を含む、HaskellソースとCソースの両方を前処理するときに設定されます。</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">これらのモジュールは、Prelude の関数との名前の衝突を避けるために、修飾された状態でインポートされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">これらの操作は、 &lt;code&gt;False&lt;/code&gt; および &lt;code&gt;True&lt;/code&gt; ではなく、それぞれ &lt;code&gt;0#&lt;/code&gt; および &lt;code&gt;1#&lt;/code&gt; を返します。詳細については、&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wikiページ&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">これらのオプションについては、&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：プラットフォームに依存しないフラグで&lt;/a&gt;詳しく説明しています。フラグが &lt;code&gt;-O&lt;/code&gt; によって暗示される場合、フラグの説明は &lt;code&gt;-O2&lt;/code&gt; によっても暗示されます（フラグの説明で明示的に別の指示がない限り）。フラグが &lt;code&gt;-O0&lt;/code&gt; によってのみ暗示される場合、フラグは &lt;code&gt;-O&lt;/code&gt; および &lt;code&gt;-O2&lt;/code&gt; によって暗示されません。</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">これらのオプションについては、「&lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;最適化（コードの改善）」で&lt;/a&gt;詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">これらのオプションは、どの警告が致命的とみなされ、コンパイルを中止させるかを制御します。</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">これらのオプションは、プログラムの実行とガベージコレクターでの消費時間、割り当てられたメモリの量、ヒープの最大サイズなど、ランタイムシステムの統計を生成します。 3つのバリアントは、さまざまな詳細レベルを提供します。 &lt;code&gt;-T&lt;/code&gt; はデータを収集しますが、出力は生成しません。- &lt;code&gt;-t&lt;/code&gt; は、GHCの &lt;code&gt;-Rghc-timing&lt;/code&gt; オプションと同じ形式で1行の出力を生成します。- &lt;code&gt;-s&lt;/code&gt; は、プログラム、および &lt;code&gt;-S&lt;/code&gt; はさらに、すべてのガベージコレクションに関する情報を生成します。合格- &lt;code&gt;--internal-counters&lt;/code&gt; スレッド化されたランタイムには、実行中に累積されたさまざまな内部カウントを含む詳細なサマリーが生成されます。これらは指定されておらず、リリース間で変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;ByteString&lt;/code&gt; が別のコンストラクターにアンパックされると、これらのオーバーヘッドはすべて1ワード（4または8バイト）削減できます。</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">アローに関するこれらの論文および詳細情報は、&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http：//www.haskell.org/arrows/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらのパターンはGHCバージョン8.0以降でのみ利用可能であり、バージョン8.2はそれらでよりうまく機能します。GHCのように最近のバージョンのために書くとき、パターンの代わりに使用することができ &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">これらは重複する可能性がありますが、GHCはフラグの設定に関係なく、インスタンス宣言自体について不満を言うことはありません。後で制約 &lt;code&gt;(C Int Char)&lt;/code&gt; を解決しようとすると、最初のインスタンスのみが一致し、すべてが順調です。同様に &lt;code&gt;(C Bool Bool)&lt;/code&gt; を使用します。しかし、 &lt;code&gt;(C Int Bool)&lt;/code&gt; を解決しようとすると、両方のインスタンスが一致し、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">これらのプラグマは、関数定義のインライン化を制御します。</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">これらの制限は簡単に検証され、型推論の終了を保証します。ただし、タイプ変数の再帰的な発生がファミリーアプリケーションの下にあり &lt;code&gt;a ~ [F a]&lt;/code&gt; などのいわゆる「ループ状の等式」が存在する場合、それらはタイプ推論の完全性を保証するのに十分ではありません。データコンストラクターアプリケーション-詳細については、上記のペーパーを参照してください。</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">これらの制限により、インスタンスの解決が確実に終了します。削減ステップごとに、少なくとも1つのコンストラクターによって問題が小さくなります。これらの制限の理由に関する多くの背景資料は、&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;「制約処理規則による機能の依存関係の理解」&lt;/a&gt;のペーパーにあります。</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">これらのルールは、レコードのワイルドカードを、ユーザーが拡張版を書くことができた状況に限定しています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">これらのタイプは、 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; への引数の処理変数の実装に必要です。それらの実装は、このモジュールから意図的に見えません。適切なクラスのインスタンスではない型の引数を &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; に渡そうとすると、コンパイラーはそれを &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; の欠落インスタンスとして報告します。 （すべての &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; インスタンスは &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; インスタンスです。）</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">これらの型は、HaskellのCライブラリインターフェイスにアクセスするために、C関数プロトタイプを正確に表すために必要です。 Haskellシステムでは、Cとまったく同じようにこれらの型を表す必要はありませんが、C型 &lt;code&gt;t&lt;/code&gt; を表すHaskell型 &lt;code&gt;CT&lt;/code&gt; については、次の保証が提供されます。</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">これらのタイプは、 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;newtype&lt;/code&gt; として表され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; のインスタンスです。つまり、 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; の（それぞれ &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; の） &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; のインスタンス &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; （それぞれ &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ）と同じように動作が悪い。</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの型は、基本的な外部型の &lt;code&gt;newtype&lt;/code&gt; として表され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの型は、&lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;および&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;で型の &lt;code&gt;newtype&lt;/code&gt; として表され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">上記の関数のこれらのバリエーションは、Unicodeを知らないCライブラリで使用するためのものです。これらの関数は、情報が失われる可能性があるので、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">上記の関数のこれらのバリアントは、システムに依存する方法でCの &lt;code&gt;wchar_t&lt;/code&gt; タイプを使用してUnicodeをエンコードするCライブラリで使用するためのものです。サポートされている唯一のエンコーディングは</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">彼らは、 &lt;code&gt;Foo.o&lt;/code&gt; 、 &lt;code&gt;Foo.hc&lt;/code&gt; 、または &lt;code&gt;Foo.s&lt;/code&gt; のいずれかにBaz.hiより前の変更日がある &lt;code&gt;Baz.hi&lt;/code&gt; 、古くなったファイルを最新にする必要があると &lt;code&gt;make&lt;/code&gt; に伝えています。それを最新のものに &lt;code&gt;make&lt;/code&gt; は、そうするためのルールを探します。前述のサフィックスルールの1つがうまく機能します。これらの依存関係は &lt;code&gt;ghc&lt;/code&gt; によって自動的に生成できます。&lt;a href=&quot;#makefile-dependencies&quot;&gt;依存関係の生成を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">それらはSimon Peyton Jones、Andrew Gordon、Sigbjorn Finneによる論文&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;「Concurrent Haskell」で&lt;/a&gt;紹介されましたが、その後、実装の詳細が一部変更されました（特に、完全な &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用するとエラーになりましたが、現在は単なるブロックになっています）。 ）</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">意識しておきたいこと。</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">この「機能」は表面的には &lt;code&gt;unsafePerformIO&lt;/code&gt; と類似していますが、実際には混乱の悪意のあるエージェントです。現実の継ぎ目（および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド）を展開して、通常のルールが適用されないようにします。それはあなたがそれが妥当であると考えるようにあなたを落ち着かせます、しかしあなたがそれを見ていないとき、それはあなたを後ろに突き刺し、あなたのすべての可変バッファをエイリアスします。多くの熟練したHaskellプログラマーの死体は、その足元にばらまかれています。</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">この「機能」は直観に反する場合があります &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; は、中間のCコードをファイル &lt;code&gt;foo.o&lt;/code&gt; に配置しますが、名前は異なります。</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 等価述語は、文字列に対してパターンマッチをデガガリングするときに使用されます。</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、Windows以外のプラットフォームでコマンドライン引数と環境変数をデコードおよびエンコードするために使用されます。</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、Windows以外のプラットフォームでコマンドライン引数と環境変数をデコードおよびエンコードするために使用されます。</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、デフォルトで提供されているもの以外のフォーマットタイプに拡張できます。これは、インスタンス化することによって行われ &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; をして提供する &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; をタイプするために。タイプ固有の修飾子を処理するために &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; を提供することは可能ですが、通常はデフォルトのインスタンスが最適です。</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">この略語により、トップレベルの宣言スライスはより静かで威圧感のないものになります。</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">この抽象データ型は、パースエラーメッセージを表します。メッセージには4種類あります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
