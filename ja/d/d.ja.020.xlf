<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">アイデンティティ割り当ての過負荷</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">アイデンティティ表現</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">イデオグラフィックの説明文字</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std.experimental.allocator&lt;/code&gt; の慣用的な使用</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">もし !がnullの場合、elements[]は疎にすることができ、&quot;デフォルト &quot;の要素値にはbasisが使用されます。言い換えれば、nullでないelements[i]はこの'basis'値を上書きします。</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">e' がカンマの木である場合、木からそれを取り除いて一番右の式を返します。ツリーに残った部分は e0 を介して返されます。それ以外の場合は 'e' が直接返され、e0 は NULL に設定されます。</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ！Rが浮動小数点型であり、 &lt;code&gt;R&lt;/code&gt; が長さとスライスを持つ&lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;ランダムアクセス範囲&lt;/a&gt;である場合、 &lt;code&gt;sum&lt;/code&gt; は&lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;ペアワイズ合計&lt;/a&gt;アルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">&lt;code&gt;!!value&lt;/code&gt; がtrueの場合、 &lt;code&gt;value&lt;/code&gt; が返されます。 それ以外の場合は、 &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; がスローされます。 &lt;code&gt;WindowsException&lt;/code&gt; は、最後の操作で &lt;code&gt;GetLastError()&lt;/code&gt; が適切に設定されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;!isInfinite!Source&lt;/code&gt; および &lt;code&gt;source.walkLength&lt;/code&gt; が &lt;code&gt;chunkSize&lt;/code&gt; で割り切れない場合、この範囲の後方要素には、 &lt;code&gt;chunkSize&lt;/code&gt; 要素よりも少ない要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;!value&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;value&lt;/code&gt; が返されます。 それ以外の場合は、 &lt;code&gt;new E(msg, file, line)&lt;/code&gt; がスローされます。 または、 &lt;code&gt;E&lt;/code&gt; がメッセージを取得せず、 &lt;code&gt;new E(file, line)&lt;/code&gt; で構築できる場合、 &lt;code&gt;new E(file, line)&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に状態がない場合、結果のオブジェクトは静的共有ストレージに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に状態があり、コピー可能である場合、結果は&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;されたアロケーター &lt;code&gt;A a&lt;/code&gt; 内部でstd.algorithm.mutation.moveします。 結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に状態があり、コピー可能でない場合、結果は渡された引数を結果に移動します。 結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に状態がある場合、結果は&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;されたアロケーター &lt;code&gt;A a&lt;/code&gt; を内部にstd.algorithm.mutation.moveします。 結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; が &lt;code&gt;owns&lt;/code&gt; を実装している場合は 、それに転送します。 それ以外の場合は、 &lt;code&gt;Ternary.unknown&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">&lt;code&gt;BookkeepingAllocator&lt;/code&gt; が &lt;code&gt;NullAllocator&lt;/code&gt; でない場合、 &lt;code&gt;bkalloc&lt;/code&gt; が定義され、アクセス可能です。</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;ElementType!R&lt;/code&gt; が浮動小数点型で、 &lt;code&gt;R&lt;/code&gt; が有限の入力範囲（ただし、スライス付きのランダムアクセス範囲ではない）の場合、 &lt;code&gt;sum&lt;/code&gt; は&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan加算&lt;/a&gt;アルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; が &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; でインスタンス化されている場合、 &lt;code&gt;max&lt;/code&gt; プロパティは書き込み可能です。 設定は、割り当ての前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; が &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; でインスタンス化されている場合、 &lt;code&gt;min&lt;/code&gt; プロパティは書き込み可能です。 設定は、割り当ての前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpOpAssign&lt;/code&gt; を定義している場合、 &lt;code&gt;opOpAssign&lt;/code&gt; は &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; に転送します。ここで、 &lt;code&gt;payload&lt;/code&gt; は内部で保持されているデータへの参照であり、フックによって変更できます。</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpBinary&lt;/code&gt; を定義していないがonOverflowを定義している場合、オーバーフローが発生した場合、 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; に転送します。</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpUnary&lt;/code&gt; を定義していないがonOverflowを定義している場合、オーバーフローが発生した場合、 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; に転送します。 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 場合、ペイロードは、 &lt;code&gt;onOverflow&lt;/code&gt; への呼び出しの結果から割り当てられます。</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; が状態を保持している場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;KRRegion&lt;/code&gt; タイプのパブリックメンバーです。 それ以外の場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;ParentAllocator.instance&lt;/code&gt; の &lt;code&gt;alias&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; が&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;data&lt;/code&gt; を取得するコンストラクターのみが定義され、必要に応じてユーザーが &lt;code&gt;data&lt;/code&gt; を解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; がNullAllocatorと異なる場合、 &lt;code&gt;Region&lt;/code&gt; は破棄中にメモリのチャンクの割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; がステートフルの場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; へのアクセスを提供するプロパティです 。 それ以外の場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">&lt;code&gt;Prefix&lt;/code&gt; が &lt;code&gt;void&lt;/code&gt; の場合、配置は親の配置になります。 それ以外の場合、配置は &lt;code&gt;Prefix&lt;/code&gt; の配置と同じです。</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Prefix&lt;/code&gt; が &lt;code&gt;void&lt;/code&gt; でない場合、 &lt;code&gt;Allocator&lt;/code&gt; は少なくとも &lt;code&gt;Prefix.alignof&lt;/code&gt; と同じ大きさの配置を保証する必要があります 。</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; がデストラクタを定義する場合、 &lt;code&gt;opAssign&lt;/code&gt; に対して生成されるコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; にポストブリットまたはデストラクタはないが、 &lt;code&gt;opAssign&lt;/code&gt; 関数（無効ではない）を定義するフィールドが少なくとも1つ含まれている場合、本体はメンバーごとの割り当てを行います。</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; に無効なデストラクタがあるか、無効な &lt;code&gt;opAssign&lt;/code&gt; を持つフィールドが少なくとも1つある場合、 &lt;code&gt;S.opAssign&lt;/code&gt; が生成されますが、 &lt;code&gt;@disable&lt;/code&gt; マークされます</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; が &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; に構造的に準拠している場合、wrapは、 &lt;code&gt;Targets&lt;/code&gt; を継承して &lt;code&gt;src&lt;/code&gt; オブジェクトをラップする内部ラッパークラスを作成し、それを返します。</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; が前方範囲の場合、結果の範囲も前方範囲になります。 それ以外の場合、結果のチャンクは同じ入力を使用する入力範囲になります &lt;code&gt;popFront&lt;/code&gt; を反復するとチャンクが縮小され、 &lt;code&gt;front&lt;/code&gt; の以降の呼び出しで完全なチャンクが返されなくなり、外側の範囲でpopFrontを呼び出すと、以前の値への残留参照が無効になります。 &lt;code&gt;front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">&lt;code&gt;StopWatch.init&lt;/code&gt; が使用されている場合、構築されたStopWatchは実行されていません（コンストラクターが実行されていないため、実行できません）。</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">&lt;code&gt;Store&lt;/code&gt; が範囲の場合、 &lt;code&gt;BinaryHeap&lt;/code&gt; はその範囲のサイズを超えることはできません。 &lt;code&gt;Store&lt;/code&gt; が &lt;code&gt;insertBack&lt;/code&gt; をサポートするコンテナーである場合、 &lt;code&gt;BinaryHeap&lt;/code&gt; は、コンテナーに要素を追加することによって拡張できます。</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がクラス型の場合、作成された &lt;code&gt;T&lt;/code&gt; オブジェクトへの参照を返します。 それ以外の場合は、作成されたオブジェクトを指す &lt;code&gt;T*&lt;/code&gt; 返します。 すべての場合において、割り当てが失敗した場合は &lt;code&gt;null&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がネストされた構造体の場合、 &lt;code&gt;T.init&lt;/code&gt; のコンテキストポインターは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;@disable this();&lt;/code&gt; を持つ構造体の場合 、 &lt;code&gt;T.init&lt;/code&gt; は論理的に正しくないオブジェクトを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がデストラクタまたはポストブリットが定義された構造体である場合、ソースはターゲットに移動された後、 &lt;code&gt;.init&lt;/code&gt; 値にリセットされます。それ以外の場合、ソースは変更されません。</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が値型の場合、 &lt;code&gt;Unique!T&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; への参照として実装されます。</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;outer&lt;/code&gt; クラスを使用して外側のクラスのインスタンスにアクセスできる内部クラスである場合、 &lt;code&gt;Args&lt;/code&gt; は空であってはならず、その最初のメンバーはその &lt;code&gt;outer&lt;/code&gt; フィールドの有効な初期化子でなければなりません。 このフィールドを正しく初期化することは、 &lt;code&gt;T&lt;/code&gt; メソッド内の外部クラスのメンバーにアクセスするために不可欠です。</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のコンストラクターがスローした場合、割り当てられたメモリの割り当てを解除し、例外を伝播します。</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; が &lt;code&gt;Checked&lt;/code&gt; のインスタンスでもある場合、メソッド &lt;code&gt;hookOpCmp&lt;/code&gt; に対して両方のフック（左側と右側）がイントロスペクトされます。 両方で定義した場合、左側が優先されます。</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; が &lt;code&gt;Checked&lt;/code&gt; のインスタンスでもある場合、メソッド &lt;code&gt;hookOpEquals&lt;/code&gt; に対して両方のフック（左側と右側）がイントロスペクトされます。 両方で定義した場合、左側が優先されます。</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">&lt;code&gt;Yes.checkDns&lt;/code&gt; の場合、MXレコードのDNSチェックが行われます</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Yes.pipeOnPop&lt;/code&gt; の場合、 frontを呼び出さずに単に範囲を反復するだけで、 &lt;code&gt;tee&lt;/code&gt; ミラー要素を &lt;code&gt;outputRange&lt;/code&gt; （またはそれぞれ &lt;code&gt;fun&lt;/code&gt; ）に設定できます。 &lt;code&gt;No.pipeOnPop&lt;/code&gt; の場合、 &lt;code&gt;front&lt;/code&gt; が呼び出される要素のみが &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; にも送信されます 。</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; 場合、 &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; を返し &lt;code&gt;a&lt;/code&gt; 変更しないままにしますが、 &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; を &lt;code&gt;&quot;de&quot;&lt;/code&gt; に進め、 &lt;code&gt;true&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; およびb = [ &lt;code&gt;bringToFront(a, b)&lt;/code&gt; ]の場合、 bringToFront（a、b）は &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; 4、5、6 ]およびb = [ 7、1、2、3 ]を残します &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 場合、 &lt;code&gt;reverse(a)&lt;/code&gt; は &lt;code&gt;[3, 2, 1]&lt;/code&gt; 3、2、1 ]に変更します。</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = [double.init, double.init]&lt;/code&gt; &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; 場合、 &lt;code&gt;initializeAll(a)&lt;/code&gt; はa = [double.init、double.init]を残します 。</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">&lt;code&gt;b = [40, 6, 15]&lt;/code&gt; &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; およびb = [40、6、15]の場合、 &lt;code&gt;completeSort(a, b)&lt;/code&gt; はa = [6、10、15 ]およびb = [20、30、40]を残します。 範囲 &lt;code&gt;a&lt;/code&gt; は呼び出しの前にソートする必要があり、その結果、組み合わせ &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; がソートされます。</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">&lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; &lt;code&gt;partialSort(a, 3)&lt;/code&gt; ]の場合、 partialSort（a、3）は &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; 残します 。 &lt;code&gt;a&lt;/code&gt; の他の要素は、不特定の順序で残されます。</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">&lt;code&gt;allowDuplicates&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合 、同じ要素を複数回挿入すると、要素が追加され続けます。 &lt;code&gt;false&lt;/code&gt; の場合、重複した要素は挿入時に無視されます。 重複が許可されている場合、既存のすべての重複要素の後に新しい要素が挿入されます。</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; 場合、何もせずに &lt;code&gt;false&lt;/code&gt; を返します 。 それ以外の場合は、配列の最後の &lt;code&gt;arr.length - delta&lt;/code&gt; 要素を破棄してから、配列のバッファーを再割り当てします。 再割り当てが失敗した場合、配列をデフォルトで初期化されたデータで埋めます。</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; 場合、何もせずに &lt;code&gt;false&lt;/code&gt; を返します 。 それ以外の場合は、最後の &lt;code&gt;array.length - delta&lt;/code&gt; 配列のデルタ要素を破棄してから、配列のバッファーを再割り当てします。 再割り当てが失敗した場合、配列をデフォルトで初期化されたデータで埋めます。</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">&lt;code&gt;b is null&lt;/code&gt; 場合、何もせずに &lt;code&gt;true&lt;/code&gt; を返します 。 それ以外の場合は、このアロケータで以前に割り当てられたメモリの割り当てを解除し、成功した場合は &lt;code&gt;true&lt;/code&gt; 、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します 。 割り当て解除をサポートしない実装（つまり、常に &lt;code&gt;false&lt;/code&gt; を返す）では、このプリミティブをまったく定義しないでください。</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">&lt;code&gt;ba&lt;/code&gt; がゼロ（デフォルト）の場合、既存のメモリーの属性が割り当てに使用されます。 &lt;code&gt;ba&lt;/code&gt; がゼロでなく、新しいメモリが割り当てられていない場合、 baのビットが現在のメモリブロックのビットを置き換えます。</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;block.length&lt;/code&gt; が &lt;code&gt;[min, max]&lt;/code&gt; 内にある場合、またはフリーリストがチェックされていない場合（ &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ）、ブロックをフリーリストの先頭に挿入します。 他のすべての場合、 &lt;code&gt;Parent.deallocate&lt;/code&gt; が定義されている場合は、 parent.deallocateに転送します。</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">&lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; 場合、 &lt;code&gt;BitmappedBlock&lt;/code&gt; は読み取り/書き込みプロパティ &lt;code&gt;blockSize&lt;/code&gt; を提供します 。 アロケータを使用する前に設定する必要があります。 それ以外の場合（つまり、 &lt;code&gt;theBlockSize&lt;/code&gt; は正当な定数です）、 &lt;code&gt;blockSize&lt;/code&gt; は &lt;code&gt;theBlockSize&lt;/code&gt; のエイリアスです。 定数でも変数でも、 &lt;code&gt;alignment&lt;/code&gt; の倍数でなければなりません。 この制約は、静的および動的に &lt;code&gt;assert&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">&lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; 場合、 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; は読み取り/書き込みプロパティ &lt;code&gt;blockSize&lt;/code&gt; を提供します 。 アロケータを使用する前に設定する必要があります。 それ以外の場合（つまり、 &lt;code&gt;theBlockSize&lt;/code&gt; は正当な定数です）、 &lt;code&gt;blockSize&lt;/code&gt; は &lt;code&gt;theBlockSize&lt;/code&gt; のエイリアスです。 定数でも変数でも、 &lt;code&gt;alignment&lt;/code&gt; の倍数でなければなりません。 この制約は、静的および動的に &lt;code&gt;assert&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; がUnicodeの小文字の場合、対応する大文字が返されます。 それ以外の場合は &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; がUnicodeの大文字の場合、対応する小文字が返されます。 それ以外の場合は &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">&lt;code&gt;dir == Direction.fwd&lt;/code&gt; 場合、範囲は時間的に前方に反復しますが、 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 場合、時間的に後方に反復します。 したがって、 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 場合は、 &lt;code&gt;front == interval.begin&lt;/code&gt; ですが、 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 場合は、 &lt;code&gt;front == interval.end&lt;/code&gt; です。 &lt;code&gt;func&lt;/code&gt; は、適切な反復方向に向かう時点を生成する必要があります。そうしないと、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。 したがって、時間を先に反復するには、 &lt;code&gt;func&lt;/code&gt; が生成する時点は、渡された時点よりも遅い必要があります。 同一またはそれ以前の場合、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。 逆方向に反復するには、生成された時点は、渡された時点より前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;filler&lt;/code&gt; が空の場合。</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; が &lt;code&gt;string&lt;/code&gt; 場合、新しい単一パラメータ関数 &lt;code&gt;fun&lt;/code&gt; が &lt;code&gt;string&lt;/code&gt; でない場合、 funのエイリアス。</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; が文字列でない場合、 &lt;code&gt;binaryFun&lt;/code&gt; は自分自身を &lt;code&gt;fun&lt;/code&gt; にエイリアスします 。</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">&lt;code&gt;hasLength!Range&lt;/code&gt; の場合、 &lt;code&gt;range.length&lt;/code&gt; をチェックせずにrange.lengthを返します（指定されている場合）。</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; がランダムアクセス範囲の場合、タプルの3つのコンポーネントはすべて &lt;code&gt;haystack&lt;/code&gt; と同じタイプになります。 それ以外の場合、 &lt;code&gt;haystack&lt;/code&gt; は&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前方の範囲で&lt;/a&gt;なければならず、 &lt;code&gt;result[0]&lt;/code&gt; および &lt;code&gt;result[1]&lt;/code&gt; のタイプは&lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt;と同じです 。</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.alignedAllocate&lt;/code&gt; が存在する場合は、それを呼び出して結果を返します。 それ以外の場合は、常に &lt;code&gt;null&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">&lt;code&gt;impl.deallocate&lt;/code&gt; が定義されていない場合は、 &lt;code&gt;false&lt;/code&gt; を返します 。 それ以外の場合は、コールを転送します。</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; が&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前進範囲の&lt;/a&gt;場合、 &lt;code&gt;needle&lt;/code&gt; も前進範囲にすることができます。 この場合、 &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; は各評価で評価されます。</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">&lt;code&gt;less&lt;/code&gt; がless-than演算子（デフォルトのオプション）の場合、 &lt;code&gt;BinaryHeap&lt;/code&gt; は、いわゆるmax-heapを定義して、</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; で演算子がオーバーフローしない場合、関数は組み込み演算子と同じ結果を返します。 その他の場合はすべて、 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">&lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; 場合、 double.initを返します。 それ以外の場合、デフォルトの比較と同じセマンティクスを持ちます。</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; と &lt;code&gt;rhs&lt;/code&gt; が同じインスタンスを参照する場合、何も行われません。</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; 型が &lt;code&gt;char[]&lt;/code&gt; 、 &lt;code&gt;wchar[]&lt;/code&gt; 、 &lt;code&gt;dchar[]&lt;/code&gt; 場合、行の内容は読み取り全体で再利用（上書き）されます。</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; タイプが &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; の場合、動作はケース（1）と同様ですが、入力時にUTFチェックが試行されない点が異なります。</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; のタイプが &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;wstring&lt;/code&gt; 、または &lt;code&gt;dstring&lt;/code&gt; の場合、読み取りごとにそれぞれのタイプの新しいストリングが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; のタイプが &lt;code&gt;ubyte[]&lt;/code&gt; 場合、入力時にUTFチェックが試行されないことを除いて、動作はケース（2）と同様です。</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; またはスレッドが正常に戻る（例外をスローしない）場合、静的デストラクタがスレッドの終了時に呼び出される関数のリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;maxSize == unbounded&lt;/code&gt; 場合、 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; を返します。 それ以外の場合は、間隔 &lt;code&gt;[min, max]&lt;/code&gt; サイズの &lt;code&gt;max&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; 場合、アルゴリズムは効果がなく、 &lt;code&gt;r[0 .. r.length]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; がフリーリストの対象である場合は、 &lt;code&gt;max&lt;/code&gt; を返します。 それ以外の場合は、 &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が定義されていない場合、スライシングを伴う無限のランダムアクセス範囲。 &lt;code&gt;n&lt;/code&gt; が定義されている場合、スライス付きのランダムアクセス範囲。</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">構造体に対して &lt;code&gt;opCall&lt;/code&gt; がオーバーライドされ、構造体が異なるタイプの値で初期化されると、 &lt;code&gt;opCall&lt;/code&gt; 演算子が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">引数を1つだけ指定して &lt;code&gt;opIndex&lt;/code&gt; を宣言する場合、 opDollarへのコンパイル時引数を省略できます。 この場合、複数の引数を持つ配列インデックス式内で &lt;code&gt;$&lt;/code&gt; を使用することは違法です。</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; がこのアロケータで割り当てられたブロック内のどこかのポインタである場合、 &lt;code&gt;result&lt;/code&gt; は割り当てられたブロックの先頭へのポインタを保持し、 &lt;code&gt;Ternary.yes&lt;/code&gt; を返します。 それ以外の場合、 &lt;code&gt;result&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; を保持し、 &lt;code&gt;Ternary.no&lt;/code&gt; を返します。 ポインターが割り当てられたブロックの直後を指している場合、結果は実装定義です。</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が相対ディレクトリの場合、変更せずに返します。</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; がすでに絶対パスの場合は、それを返します。</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が空の場合は &lt;code&gt;null&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; （UNCパス）の形式の場合、 &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;が適用されます</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\.\&lt;/code&gt; （Win32デバイス名前空間）で始まる場合、この関数は &lt;code&gt;false&lt;/code&gt; を返します 。 このようなパスは、このモジュールの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\?\&lt;/code&gt; （長いUNCパス）で始まる場合、残りの文字列の唯一の要件は、ヌル文字を含まないことです。</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">&lt;code&gt;postData&lt;/code&gt; がnull以外の場合、メソッドはHTTPリクエストを送信するように設定されます。</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; がfalseの場合、空白は生成されません。 &lt;code&gt;pretty&lt;/code&gt; がtrueの場合、シリアル化された文字列は人間が読めるようにフォーマットされます。 &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; &lt;/a&gt;フラグを設定して、NaN / Infinityを文字列としてエンコードする &lt;code&gt;options&lt;/code&gt; を設定します 。</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;primary&lt;/code&gt; が &lt;code&gt;b&lt;/code&gt; を所有していない場合は、 &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; が試行されます。 それが失敗した場合、割り当てを &lt;code&gt;fallback&lt;/code&gt; から &lt;code&gt;primary&lt;/code&gt; に移動する試みが行われます。</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; スタイルのロギングが必要な場合は、 &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; などの&lt;b&gt;f&lt;/b&gt;をロギング呼び出しに追加します。 または &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; 。 関数名に追加された&lt;b&gt;f&lt;/b&gt;は、明示的な &lt;code&gt;LogLevel&lt;/code&gt; と条件付きロギング関数およびメソッドのすべての組み合わせに対して、 &lt;code&gt;printf&lt;/code&gt; スタイルのロギングを有効にします。</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; に同等の要素が含まれている場合、 rの複数の置換はこれらの制約を満たします。 このような場合、 &lt;code&gt;pivotPartition&lt;/code&gt; は、 &lt;code&gt;k&lt;/code&gt; が &lt;code&gt;r.length / 2&lt;/code&gt; 近くに留まるように、同等の要素を &lt;code&gt;k&lt;/code&gt; の左側と右側に均等に分散しようとします。</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; に長さがある場合、これは&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）です。 それ以外の場合は、&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; がUnicode文字を含む文字列の場合、 &lt;code&gt;padLeft&lt;/code&gt; は文字列の長さに関するDの規則に従います。これは、文字数や書記素ではなく、エンコーディングユニットの数です。 各書記素を1つのエンコーディングユニットとしてのみ扱う場合は、この関数を呼び出す前に&lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; が自動デコード可能な文字列（つまり、ナロー文字列または暗黙的に文字列型に変換されるユーザー定義型）でない場合、 &lt;code&gt;r&lt;/code&gt; が返されます。 それ以外の場合、 &lt;code&gt;r&lt;/code&gt; は対応する文字列型に変換され（まだ文字列でない場合）、ランダムアクセス範囲にラップされます。ランダムアクセス範囲では、文字列の要素エンコードタイプ（コード単位）が範囲の要素タイプであり、その範囲戻ってきた。 範囲にはスライスがあります。 &lt;code&gt;r&lt;/code&gt; が、それ自体が文字の入力範囲である構造体またはクラスになるのに十分風変わりである場合（つまり、メンバー関数として入力範囲APIを持っている場合）、</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 長さがなく、 &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; ときにpopFrontが呼び出される場合、インデックスはオーバーフローし、 &lt;code&gt;Enumerator.min&lt;/code&gt; から継続します 。</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; に長さがある場合、 &lt;code&gt;start + range.length&lt;/code&gt; が &lt;code&gt;Enumerator.max&lt;/code&gt; より大きくなるようにstartに値を渡すとエラーが発生し、オーバーフローが発生しないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; で演算子がオーバーフローしない場合、関数は組み込み演算子と同じ結果を返します。 その他の場合はすべて、 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; が &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; の場合、 WithNaN.defaultValue！Lhsを返します。 それ以外の場合は、 &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">&lt;code&gt;s == 0&lt;/code&gt; 場合、呼び出しは空のスライス（ &lt;code&gt;null&lt;/code&gt; を含む）を返す可能性があります 。 それ以外の場合、呼び出しは &lt;code&gt;s&lt;/code&gt; バイトのメモリを割り当て、割り当てられたブロックを返すか、要求が満たされない場合は &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">&lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; 場合、要素は範囲の終わりからスロットに移動して、埋められます。 この場合、移動の絶対最小値が実行されます。</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が関数テンプレート、つまりテンプレートの唯一のメンバーであり、そのメンバーが関数である場合、そのテンプレートを返します。</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が &lt;code&gt;delimiter&lt;/code&gt; で終わっている場合、 &lt;code&gt;str&lt;/code&gt; はその終わりに &lt;code&gt;delimiter&lt;/code&gt; なしで返されます。 それが &lt;code&gt;str&lt;/code&gt; の場合</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が &lt;code&gt;delimiter&lt;/code&gt; で始まる場合、 区切り &lt;code&gt;str&lt;/code&gt; 続くstrの部分が返されます。 &lt;code&gt;str&lt;/code&gt; が行う場合</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">&lt;code&gt;sz&lt;/code&gt; がゼロの場合、pが参照するメモリは、 &lt;code&gt;free&lt;/code&gt; の呼び出しのように割り当て解除されます。 &lt;code&gt;p&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、新しいメモリは &lt;code&gt;malloc&lt;/code&gt; を介して割り当てられます。 &lt;code&gt;p&lt;/code&gt; がGCから割り当てられていないメモリまたは割り当てられたメモリブロックの内部を指している場合、操作は実行されず、nullが返されます。</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">&lt;code&gt;ticksPerSec&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合、 TickDurationは現在のシステムの &lt;code&gt;ticksPerSec&lt;/code&gt; の値を取得できず、 &lt;code&gt;TickDuration&lt;/code&gt; は機能しません。 それは非常に異常です。</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">&lt;code&gt;timeval.tv_sec&lt;/code&gt; がintであり、結果がintに収まらない場合、32ビットで保持できる最も近い値が &lt;code&gt;tv_sec&lt;/code&gt; に使用されます。 （そのため、 &lt;code&gt;int.max&lt;/code&gt; ばint.maxになり、 &lt;code&gt;int.min&lt;/code&gt; とint.minになります）。</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;opEquals&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;toHash&lt;/code&gt; は常に同じ値でなければなりません。 つまり、等しいと見なされる2つのオブジェクトは、常に同じハッシュ値を持つ必要があります。 そうしないと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;opEquals&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;toHash&lt;/code&gt; は常に同じ値でなければなりません。 つまり、等しいと見なされる2つの構造体は常に同じハッシュ値を持つ必要があります。 そうしないと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">BからAへの変換が、オフセットの調整を必要とする畳み込み式である場合、すべてのリターン文は、A型のリターン式に調整されるべきである。</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">JSON値がnullの場合、オペレーターはそれをオブジェクトで初期化し、 &lt;code&gt;value&lt;/code&gt; を設定します 。</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Sourceが &lt;code&gt;struct&lt;/code&gt; 場合、ラップ/アンラップはコピーを作成します。 ラッパーを介して元の &lt;code&gt;struct&lt;/code&gt; に影響を与えることはできません。</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">ステートメント</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Targetsにエントリが1つしかなく、Sourceがそれを明示的に実装するクラスである場合、wrapは単純にsrcを &lt;code&gt;Targets[0]&lt;/code&gt; アップキャストして返します。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt;が指定されている場合、フィールドは&lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt;構文によって初期化されます。</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">aとbが両方ともクラスオブジェクトであれば、式は次のように書き換えられます。</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">浮動小数点型へのキャストが要求され、 &lt;code&gt;Hook&lt;/code&gt; &lt;code&gt;onBadCast&lt;/code&gt; を定義している場合 、そのキャストは &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; 確認することによって検証されます。 それが &lt;code&gt;true&lt;/code&gt; でない場合 、 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">整数型へのキャストが要求され、 &lt;code&gt;Hook&lt;/code&gt; &lt;code&gt;onBadCast&lt;/code&gt; を定義する場合 、 &lt;code&gt;get&lt;/code&gt; と &lt;code&gt;cast(U) get&lt;/code&gt; が同じ算術数であることを確認することにより、キャストが検証されます。 （ &lt;code&gt;int(-1)&lt;/code&gt; と &lt;code&gt;uint(1)&lt;/code&gt; は、同じビットごとの表現を持ち、言語規則によって等しいと比較されますが、算術的に異なる値であることに注意してください。）数値が算術的に等しくない場合、 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; が返されます。 。</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">選択肢の戻り値の型が void の場合、すべての選択肢が void でない限り、選択肢は例外を投げなければなりません。その場合、castSwitch 自体は void を返します。</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">コンストラクタのコードにデリゲート コンストラクタの呼び出しが含まれている場合、コンストラクタを介して実行可能なすべてのパスは、正確に 1 回のデリゲート コンストラクタ呼び出しを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">コピーコンストラクタが定義されている場合、以下のような状況では、それに対する暗黙の呼び出しが挿入されます。</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">宣言の後に文書化された単体テストが続く場合、単体テストのコードが宣言の&lt;b&gt;サンプル&lt;/b&gt;セクションに挿入されます。</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">宣言が</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">デリゲートが渡された場合、この関数の安全性と純度は &lt;code&gt;Dg&lt;/code&gt; の安全性と純度から推測されます。</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt;を受け入れるデリゲートが &lt;code&gt;receive&lt;/code&gt; の最後の引数として含まれている場合、それは、以前のデリゲートによって一致しなかったすべてのメッセージと一致します。 複数の引数が送信される場合、 &lt;code&gt;Variant&lt;/code&gt; は送信されたすべての値の&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">委譲コンストラクタが呼び出されない場合は、基底クラスのデフォルトコンストラクタへの呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">派生クラスが異なる&lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;で基本クラスのメンバー関数をオーバーライドする場合、欠落している属性はコンパイラーによって自動的に補正されます。</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">宣言のドキュメンテーションコメントが識別子 &lt;code&gt;ditto&lt;/code&gt; のみで構成されている場合、同じ宣言スコープの前の宣言のドキュメンテーションコメントがこの宣言にも適用されます。</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">フィールドの型がデフォルトの構築を無効にしている場合は、コンストラクタで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">浮動リテラルに&lt;b&gt;。&lt;/b&gt; 型の接尾辞。少なくとも1桁はその間にある必要があります。</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">浮動リテラルの後に&lt;b&gt;i&lt;/b&gt;が続く場合、それは</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">関数がこれらの属性について自身をテストしようとした場合、関数はこれらの属性を持っていないと推論されます。</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">関数呼び出しが明示的な引数を渡さない場合、つまり構文的に &lt;code&gt;()&lt;/code&gt; を使用する場合、 &lt;a href=&quot;#property-functions&quot;&gt;プロパティ関数の&lt;/a&gt;ゲッター呼び出しと同様に、これらの括弧を省略できます。</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">派生クラスの関数がそのスーパークラスの関数をオーバーライドする場合、関数とその基本関数の &lt;code&gt;in&lt;/code&gt; コントラクトの1つのみが満たされる必要があります。 関数をオーバーライドすると、</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">関数がデリゲートや関数ポインタを返す場合、返された値が呼び出される場合には、そのparanthesesが必要になります。</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">型指定されていないパラメータを持つ関数が指定された場合、そのバリアントに他の関数と一致しない型が含まれている場合に、この関数が呼び出されます。これは、複数の可能な型にまたがって同じ関数を適用するために使用することができます。汎用関数は1つだけ許可されています。</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">パラメータなしの関数が指定されている場合、この関数は、 &lt;code&gt;variant&lt;/code&gt; が値を保持していないときに呼び出されます。 パラメータなしの関数を1つだけ使用できます。</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">レガシーのブール値を返すカスタムハンドラーを使用する場合、 &lt;code&gt;false&lt;/code&gt; は &lt;code&gt;UnitTestResult.fail&lt;/code&gt; に、 &lt;code&gt;true&lt;/code&gt; は &lt;code&gt;UnitTestResult.pass&lt;/code&gt; にマップします 。 これは、単体テストシステムの元の動作でした。</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">ライブラリルーチンがTypedefタイプを処理できない場合は、 &lt;code&gt;TypedefType&lt;/code&gt; テンプレートを使用して、Typedefがラップするタイプを抽出できます。</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">ミキシンが</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">モジュールCがモジュールAとモジュールBをインポートした場合、Bへの変更はAに依存しているCのコードを黙って変更することはありません。</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">ネストされたクラスに &lt;code&gt;static&lt;/code&gt; 属性がある場合、スタックに対してローカルであるか、 &lt;code&gt;this&lt;/code&gt; を必要とする、囲んでいるスコープの変数にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">オプションが必要な場合、それを渡さないとエラーになります。</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">パラメータなしの関数が指定されている場合、 &lt;code&gt;variant&lt;/code&gt; が値を保持していないか、訪問関数によって処理されない型を保持しているときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">ポインタに</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">パラメータを持たないプロパティ関数は、ゲッターとして動作します。パラメータが1つしかない場合は、セッターとして動作します。</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">プロトコル名を省略した場合は、任意のプロトコルがマッチします。</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; または &lt;code&gt;asyncBuf&lt;/code&gt; によって返された範囲がmapへの入力として使用される場合、最適化として、最初の範囲の出力バッファーから2番目の範囲の入力バッファーへのコピーは、 &lt;code&gt;map&lt;/code&gt; および &lt;code&gt;asyncBuf&lt;/code&gt; によって返された範囲であっても省略されます 。非ランダムアクセス範囲です。 つまり、現在の &lt;code&gt;map&lt;/code&gt; の呼び出しに渡された &lt;code&gt;bufSize&lt;/code&gt; パラメータは無視され、バッファのサイズは &lt;code&gt;source&lt;/code&gt; のバッファサイズになります 。</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">代入式の左辺としてスライス演算子が出現し、右辺の型が左辺の要素型と同じであれば、左辺の配列内容は右辺に設定されます。</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">強く純粋な関数が例外やエラーを投げた場合、メモリ化や参照に関連する仮定は投げられた例外には適用されません。</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">式のサブ式が例外を投げる場合、そのサブ式の評価までに作成されたすべてのテンポラリは上記の規則に従って破棄されます。まだ構築されていないテンポラリに対しては、デストラクタ呼び出しは発行されません。</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">テンプレート引数が特殊なテンプレートパラメータと一致する場合、引数はプレフィックス&lt;b&gt;Hで&lt;/b&gt;マングルされます。</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">テンプレートがテンプレート識別子と同じ名前のメンバを含み、これらのメンバの型またはパラメータ型が少なくともすべてのテンプレートパラメータを含む場合、これらのメンバはテンプレートのインスタンス化で参照されると仮定されます。</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">テンプレートが正確に1つのメンバを宣言しており、そのメンバがテンプレートと同じ名前のクラスである場合。</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">テンプレートがメンバーを1つだけ宣言し、そのメンバーがテンプレートと同じ名前の関数である場合、それは関数テンプレート宣言です。 または、関数テンプレート宣言は、 &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parametersの&lt;/i&gt;&lt;/a&gt;直前に&lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;がある関数宣言です。</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">&lt;a href=&quot;#aliasparameters&quot;&gt;テンプレートにテンプレートエイリアスパラメータ&lt;/a&gt;があり、ローカルシンボルでインスタンス化されている場合、インスタンス化された関数は、指定されたローカルシンボルのランタイムデータにアクセスするために暗黙的にネストされます。</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">テンプレートが集約スコープまたは関数ローカルスコープで宣言されている場合、インスタンス化された関数は暗黙的にスコープのコンテキストを捕捉します。</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">変数にスコープデストラクタの呼び出しがある場合は、その呼び出しを返します。そうでなければ、NULLを返します。</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">すべての型引数を調べた結果,型が割り当てられていない型パラメータが残っていた場合は,テンプレート引数に対応する型が</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">同じオブジェクトまたは両方にエイリアスされている場合null =&amp;gt;等しい</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 型がタイプとして使用される場合、ランダム変量は列挙 &lt;code&gt;E&lt;/code&gt; の可能な値のいずれかから等しい確率で描画されます。</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">集約宣言で &lt;code&gt;opCmp&lt;/code&gt; または &lt;code&gt;opEquals&lt;/code&gt; メソッドが定義されている場合、エイリアスされたthisメンバーの宣言よりも優先されます。 &lt;code&gt;opCmp&lt;/code&gt; メソッドとは異なり、ユーザー定義のものが提供されていない場合、 &lt;code&gt;struct&lt;/code&gt; 宣言に対して &lt;code&gt;opEquals&lt;/code&gt; メソッドが暗黙的に定義されることに注意してください。 つまり、エイリアスされたこのメンバー &lt;code&gt;opEquals&lt;/code&gt; が優先される場合は、明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">アペンドが拡張の可能性なしにスライスを再割り当てする必要がある場合、 &lt;code&gt;0&lt;/code&gt; が返されます。 これは、スライスが静的配列を参照する場合、または別のスライスが現在のスライスの終わりを超えた要素を参照する場合に発生します。</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">アプリケーションが &lt;code&gt;getopt&lt;/code&gt; が理解できなかった引数の独自の処理を行う必要がある場合は、 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; ディレクティブを &lt;code&gt;getopt&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">列挙型が左列の型のいずれかをベースにしている場合は、右列の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">プログラムのコンパイル中にエラーが発生した場合は、関連するクラスでオーバーロードやオーバーライドの使用を再検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">で例外が発生した場合</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">例外がスローされても、メッセージが空の場合、 &lt;code&gt;emptyExceptionMsg&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">typeと同じ型が &lt;code&gt;type.stringtable&lt;/code&gt; にある場合は、後者を返します。 それ以外の場合は、 &lt;code&gt;type.stringtable&lt;/code&gt; に追加します 。 一部のタイプはマージされず、そのまま返されます。</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">ID割り当てオーバーロードが必要で、存在しない場合は、 &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; 型のID割り当てオーバーロード関数が自動的に生成されます。</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">暗黙的な変換がテーブルで許可されていない場合、次の場合に&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が変換されることがあります。</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opIndexAssign&lt;/code&gt; または &lt;code&gt;opIndexOpAssign&lt;/code&gt; を使用してインデックス式を書き換えることができる場合、これらはopIndexよりも優先され &lt;code&gt;opIndex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">インターフェースに &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;immutable&lt;/code&gt; ストレージクラスがある場合、インターフェースのすべてのメンバーは &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;immutable&lt;/code&gt; です。 このストレージクラスは継承されません。</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプ シ ョ ンが数値型に結合 さ れてい る 場合は、 次のオプ シ ョ ン と し て数値が、 またはオプシ ョ ンの右端に &quot;=&quot; 記号で区切られたオプシ ョ ンが期待 さ れます。</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプションが文字列にバインドされている場合は、文字列が次のオプションとして期待されるか、オプションの右端に &quot;=&quot; 記号で区切られたオプションが期待されます。</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">オプションが配列にバインドされている場合は、オプションが発生するたびに新しい要素が配列に追加されます。</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプションが連想配列にバインドされている場合は、次のオプションとして &quot;name=value&quot; の形式の文字列を指定するか、 あるいはオプションの右端に &quot;=&quot; で区切って指定します。</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプシ ョ ンが enum に結合 さ れてい る 場合は、 文字列 と し ての enum シンボルが次のオプシ ョ ン と し て、 ま たはオプシ ョ ン内の右端に &quot;=&quot; 記号で区切られてい る こ と が予想 さ れます。</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">オプション名の接尾辞が「+」で、数値型にバインドされている場合、そのオプションの値は、そのオプションがコマンドライン上で何回発生したかを追跡します。</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">オプション文字列の後に別の文字列が続く場合、この文字列はこのオプションの説明として機能します。 &lt;code&gt;getopt&lt;/code&gt; 関数は、 &lt;code&gt;GetoptResult&lt;/code&gt; 型の構造体を返します。 この戻り値には、渡されたすべてのオプションに関する情報と、これらのオプションに関する情報が要求されたかどうかを示す &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; フラグが含まれています。 &lt;code&gt;getopt&lt;/code&gt; 関数は常に &lt;code&gt;--help|-h&lt;/code&gt; オプションを追加して、オプションがコマンドラインに表示される場合にフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">デーモンスレッド以外の &lt;code&gt;TaskPool&lt;/code&gt; がアクティブな場合は、プログラムを終了する前に、 &lt;code&gt;stop&lt;/code&gt; または &lt;code&gt;finish&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">デフォルト構築を無効にしているフィールドがある場合、構造体のデフォルト構築も無効になります。</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">&lt;code&gt;lead&lt;/code&gt; と &lt;code&gt;vowel&lt;/code&gt; いずれかがそれぞれの&lt;a href=&quot;#Character&quot;&gt;文字&lt;/a&gt;クラスの有効なハングルジャモでない場合、dchar.initを返します。</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;の引数のいずれかが</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">いずれかのチェックに失敗するとコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">のキーまたは値のいずれかが</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">上記のルールを適用しても、各テンプレートパラメータに対して正確に1つの型にならない場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">アサーションが有効で &lt;code&gt;toRange&lt;/code&gt; が呼び出されている場合、このWorkerLocalStorageインスタンスはワーカーローカルではなくなり、このメソッドを呼び出すとアサーションエラーが発生します。 これは、パフォーマンス上の理由でアサーションが無効になっている場合はチェックされません。</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">範囲の少なくとも1つがマルチセットである場合、重複する要素のすべての出現が考慮されます。 結果は、すべての入力範囲をマージし、最も高い &lt;code&gt;tgt.length&lt;/code&gt; の重みベースのランキング要素を選択するのと同じです。</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">認証やリダイレクトが行われた場合は、最後に受信したレスポンスのステータスとなります。</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">ブロッキング引数がtrueの場合、戻る前にすべてのワーカースレッドが終了するのを待ちます。 このオプションは、タスクの結果が消費されないアプリケーションで使用される場合があります。たとえば、戻り値以外の手段で通信するタスクの基本的なスケジューラとして &lt;code&gt;TaskPool&lt;/code&gt; が使用されている場合などです。</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Primary&lt;/code&gt; と &lt;code&gt;Fallback&lt;/code&gt; の両方がステートレスである場合、 &lt;code&gt;FallbackAllocator&lt;/code&gt; はinstanceという静的インスタンスを定義し &lt;code&gt;instance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方が整数である場合（定数で折りたたまれている場合があります）、スライス式は静的配列型 &lt;code&gt;T[b - a]&lt;/code&gt; 変換できます。</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">シーケンスパラメータを持つテンプレートとシーケンスパラメータを持たないテンプレートの両方がテンプレートのインスタンス化に完全に一致する場合、そのテンプレートは</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">両方のアロケーターが &lt;code&gt;shared&lt;/code&gt; 場合、 &lt;code&gt;Segregator&lt;/code&gt; は &lt;code&gt;shared&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">両方とも符号付き、または両方とも符号なしの場合は、小さい方の型が大きい方に変換されます。</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">両方が同じ型であれば、それ以上の変換は行われません。</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">両方の引数が同じタイプのL値の範囲である場合、 &lt;code&gt;SetSymmetricDifference&lt;/code&gt; もそのタイプのL値の範囲になります。</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">両方のオペランドが整数型であり、計算でオーバーフローまたはアンダーフローが発生した場合、ラップが発生します。 つまり、 &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; および &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">両方のオペランドがポインターであり、演算子が &lt;code&gt;+&lt;/code&gt; である場合、それは不正です。</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">両方のオペランドがポインターであり、演算子が &lt;code&gt;-&lt;/code&gt; である場合、ポインターが減算され、結果はオペランドが指す型のサイズで除算されます。 この計算では、 &lt;code&gt;void&lt;/code&gt; の想定サイズは1バイトです。 ポインターが異なる型を指している場合はエラーになります。 結果のタイプは &lt;code&gt;ptrdiff_t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">両方の範囲が有限である場合、一方は（少なくとも） &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前方範囲&lt;/a&gt;でなければならず、もう一方は&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;入力範囲&lt;/a&gt;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">両方の範囲が無限大であれば、両方とも順方向の範囲でなければなりません。</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">両方の範囲が（重複する要素のない）セットである場合、結果の範囲はセットになります。 範囲の少なくとも1つがマルチセットである場合、結果の範囲の要素 &lt;code&gt;x&lt;/code&gt; の出現数は &lt;code&gt;abs(a-b)&lt;/code&gt; ここで、 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;r1&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; の出現数、 bは &lt;code&gt;r2&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; の出現数です。 、および &lt;code&gt;abs&lt;/code&gt; は絶対値です。</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">両方の範囲に長さメンバーがある場合、この関数は&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）です。 それ以外の場合、この関数は&amp;Omicron;（ &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">x と n の両方が 0 の場合、結果は 1 になります。 n が負の場合、x の値に関係なく、実行時に整数除算エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">ブレークの後に</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">クラス不変検査をオンにすると、コンストラクタの最後にクラス不変が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">コードが「メモリ不足」などのエラーを検出すると、「メモリ不足」というメッセージとともにエラーがスローされます。 関数呼び出しスタックは巻き戻され、エラーのハンドラーを探します。 &lt;a href=&quot;statement#TryStatement&quot;&gt;最後に&lt;/a&gt; 、スタックがほどかれるときにブロックが実行されます。 エラーハンドラが見つかると、そこで実行が再開されます。 そうでない場合は、デフォルトのエラーハンドラが実行され、メッセージが表示されてプログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">continue の後に</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">定義されていて、 &lt;code&gt;hookOpCast&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; がペイロードのデフォルトの初期化子として使用されます。</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.max!T&lt;/code&gt; がペイロードの最大値として使用されます。</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.min!T&lt;/code&gt; がペイロードの最小値として使用されます。</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号で &lt;code&gt;rhs&lt;/code&gt; は右側のオペランドです）は、二項演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;^^&lt;/code&gt; に対して無条件に転送されます &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号、 &lt;code&gt;lhs&lt;/code&gt; は左側のオペランドです）は、二項演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;^^&lt;/code&gt; 、に無条件に転送されます &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、ペイロードがタイプ &lt;code&gt;U&lt;/code&gt; にキャストされるときに、 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; が無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; は、ペイロードが整数型、浮動小数点型、またはブール型の値 &lt;code&gt;rhs&lt;/code&gt; に対する順序付けと比較されるときに無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; は、ペイロードが整数型、浮動小数点型、またはブール型の値 &lt;code&gt;rhs&lt;/code&gt; と等しいかどうか比較されるときに無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号で &lt;code&gt;rhs&lt;/code&gt; は右側のオペランドです）は、二項演算子 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; に対して無条件に転送されます= 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; 、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号）が単項演算子 &lt;code&gt;-&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; 転送されます。 さらに、単項演算子 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 場合、 &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; が呼び出されます。ここで、 &lt;code&gt;payload&lt;/code&gt; は、 &lt;code&gt;Checked&lt;/code&gt; によってラップされた値への参照であるため、フックで変更できます。</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; （ &lt;code&gt;payload&lt;/code&gt; はCheckedによってラップされた値への参照です）は、Checkedタイプで &lt;code&gt;toHash&lt;/code&gt; が呼び出されたときに転送されます。 カスタムハッシュは &lt;code&gt;Hook&lt;/code&gt; で実装できます。それ以外の場合は、組み込みハッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、二項演算子の結果 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; のときに、 &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; （ &lt;code&gt;value&lt;/code&gt; は割り当てられる値）に転送されます、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; で表現可能な最小値よりも小さい。</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; は、 &lt;code&gt;hookOpUnary&lt;/code&gt; が定義されていない場合にのみ、オーバーフローする単項演算子に転送されます。 単項 &lt;code&gt;~&lt;/code&gt; はオーバーフローしません。 単項 &lt;code&gt;-&lt;/code&gt; 符号付き型の最も負の値が否定され、フック呼び出しの結果が返された場合にのみオーバーフローします。 インクリメントまたはデクリメント演算子がオーバーフローすると、ペイロードに &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; の結果が割り当てられます。 2項演算子がオーバーフローすると、 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; が返されますが、これは &lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpBinary&lt;/code&gt; を定義していない場合に限られます。</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; （ &lt;code&gt;value&lt;/code&gt; は割り当てられている値です）は、二項演算子の結果 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; に転送されます、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; で表現可能な最大値よりも大きいです。</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">eがSliceExpならば、それを定数で折りたたむ。</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">e1がプロパティ関数(テンプレート)の場合は、それを解決します。</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">どちらかがnullの場合=&amp;gt;等しくない</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">どちらかのオペランドが &lt;code&gt;real&lt;/code&gt; 場合、もう一方のオペランドは実数に変換されます。</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">どちらかのオペランドが浮動小数点型の場合、もう一方は暗黙的に浮動小数点に変換され、 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換を&lt;/a&gt;介して共通の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">2番目または3番目の式が &lt;code&gt;void&lt;/code&gt; 型の場合、結果の型は &lt;code&gt;void&lt;/code&gt; になります 。 それ以外の場合、2番目と3番目の式は暗黙的に共通の型に変換され、条件式の結果の型になります。</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">式が真か偽かをテストできる場合は、変更された式を返します。そうでない場合は ErrorExp を返します。</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">式が共有されている場合は、それにアクセスできるかどうかを確認します。共有されていない場合はエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">フラグ &lt;code&gt;KeepTerminator&lt;/code&gt; がKeepTerminator.yesに設定されている &lt;code&gt;KeepTerminator.yes&lt;/code&gt; 、返される文字列には区切り文字が含まれます。</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">見つかった場合は、それがあるリストエントリを返し、そうでない場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">funcが範囲の現在の &lt;code&gt;front&lt;/code&gt; 以上の時点を生成した場合、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">funcが範囲の現在の &lt;code&gt;front&lt;/code&gt; 以上の時点を生成した場合、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。 funcが間隔の &lt;code&gt;begin&lt;/code&gt; 以下の時点を生成すると、範囲は空になり、反復は完了します。</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">funcが範囲の現在の &lt;code&gt;front&lt;/code&gt; 以下の時点を生成する場合、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">funcが範囲の現在の &lt;code&gt;front&lt;/code&gt; 以下の時点を生成する場合、 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。 funcが間隔の &lt;code&gt;end&lt;/code&gt; 以上の時点を生成すると、範囲は空になり、反復は完了します。</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">funcが呼び出されたときに変化する状態を保持している場合、範囲の &lt;code&gt;save&lt;/code&gt; が実際に範囲の状態を保存できなかったため、一部のアルゴリズムは正しく機能しません。 このようなバグを回避するには、論理的に純粋ではないデリゲートを &lt;code&gt;fwdRange&lt;/code&gt; に渡さないでください 。 funcに2つの異なる呼び出しで同じ時点が指定されている場合、両方の時点で同じ結果を返す必要があります。 もちろん、このモジュールのどの関数にもこの問題はありません。そのため、カスタムデリゲートにのみ関係があります。</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">funcが呼び出されたときに変化する状態を保持している場合、範囲の &lt;code&gt;save&lt;/code&gt; が実際に範囲の状態を保存できなかったため、一部のアルゴリズムは正しく機能しません。 このようなバグを回避するには、論理的に純粋ではないデリゲートを &lt;code&gt;fwdRange&lt;/code&gt; に渡さないでください 。 funcに2つの異なる呼び出しで同じ時点が指定されている場合、両方の時点で同じ結果を返す必要があります。 もちろん、このモジュールのどの関数にもこの問題はありません。そのため、カスタムデリゲートを作成する場合にのみ関係があります。</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">基底クラス内の関数であれば、その基底クラスを返します。</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">引用符で囲まれたフィールドの中で、フィールドの最後ではなく、それ自体が引用符で囲まれている場合、そのフィールドの処理は終了します。</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">&lt;code&gt;No.multiblock&lt;/code&gt; でインスタンス化されている場合、ビットマップの最初のゼロビットの検索を実行して設定します。</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">isNested()が true を返した場合、関数がデュアルコンテキストポインタを必要としない限り、isThis()は false を返すべきです。</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; の場合、3番目の式が評価され、その結果は条件式の結果になります。</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; の場合、2番目の式が評価され、その結果は条件式の結果になります。</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">&lt;code&gt;Unique!T&lt;/code&gt; を元のスコープ外に永続化することが望ましい場合は、転送できます。 転送は、 &lt;code&gt;release&lt;/code&gt; を呼び出すことによって明示的に行うことも、関数からUniqueを返すときに暗黙的に行うこともできます。 リソース &lt;code&gt;T&lt;/code&gt; は、ポリモーフィッククラスオブジェクトまたはインターフェイスのインスタンスにすることができます。その場合、Uniqueもポリモーフィックに動作します。</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">ちょうど型Tが与えられていて変数vが与えられていない場合、キャッチ句はまだ実行されています。</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">同じテンプレートが複数ある場合</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; が指定されていない場合は、末尾に1つの &lt;code&gt;'\r'&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; 、 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 、 &lt;code&gt;'\f'&lt;/code&gt; 、 &lt;code&gt;'\v'&lt;/code&gt; 、 &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; 、または&lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;str&lt;/code&gt; の末尾から削除されます 。 &lt;code&gt;str&lt;/code&gt; がこれらの文字のいずれでも終わっていない場合は、そのまま返されます。</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; が提供されない場合、 &lt;code&gt;pred(haystack.front)&lt;/code&gt; は入力範囲の各要素で評価されます。</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; または &lt;code&gt;super&lt;/code&gt; を介したコンストラクターの呼び出しがコンストラクターに表示されず、基本クラスにコンストラクターがある場合、 &lt;code&gt;super()&lt;/code&gt; の呼び出しがコンストラクターの先頭に挿入されます。</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">エラーに対するキャッチハンドラが存在しない場合、プログラムは適切なメッセージを表示してデフォルトのエラーハンドラを介して優雅に終了します。</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">サイクルが見つからない場合、ctorsとtlsctorsは、古い不正確な順序付けの動作を維持するために、このアルゴリズムによって生成されたもので置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">利用可能なデータがなく、メインスレッドがその範囲にアクセスする場合、データが利用可能になるまでブロックされます。 これの例外は、 &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;wait(Duration)&lt;/code&gt; メソッドです 。 このメソッドは、指定された期間最大で待機し、データが利用可能な場合はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">データが利用できず、メインスレッドが範囲にアクセスする場合、データが利用可能になるまでメインスレッドはブロックします。 これの例外は、 &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;wait(Duration)&lt;/code&gt; メソッドです 。 このメソッドは、指定された期間最大で待機し、データが利用可能な場合はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">明示的なシードが提供されていない場合、各作業単位の最初の要素がシードとして使用されます。最終的な削減では,最初の作業単位の結果がシードとして使用されます.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">呼び出す関数が指定されていない場合、 &lt;code&gt;each&lt;/code&gt; 関数はデフォルトで何もせず、範囲全体を消費します。 &lt;code&gt;r.front&lt;/code&gt; が評価されますが、 &lt;code&gt;lazy&lt;/code&gt; パラメーターでラムダを指定することで回避できます。</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">針が提供されない場合、 &lt;code&gt;pred&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; と評価される限り、 &lt;code&gt;haystack&lt;/code&gt; は進みます 。 同様に、haystackは、 &lt;code&gt;pred&lt;/code&gt; がhaystack.frontに対して &lt;code&gt;false&lt;/code&gt; と評価されるように配置されています 。</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">&lt;code&gt;randomCover&lt;/code&gt; に乱数ジェネレータが渡されない場合、スレッドグローバルRNG rndGenが内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">セパレータが渡されない場合、述語 &lt;code&gt;isTerminator&lt;/code&gt; は &lt;code&gt;r&lt;/code&gt; の要素を受け入れるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">unittestカスタムハンドラーが登録されていない場合は、次のアルゴリズムが実行されます（動作は、以下の &lt;code&gt;--DRT-testmode&lt;/code&gt; スイッチの影響を受ける可能性があります）。 失敗したそれぞれについて、スタックトレースを出力して続行します。 2.失敗がない場合は、要約フラグをfalseに設定し、runMainフラグをtrueに設定します。 3.エラーがある場合は、summaryフラグをtrueに、runMainフラグをfalseに設定します。</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">0 以外の場合は、結果の先頭に 0x (0X)を付けます。</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">大文字小文字の表現がどれも一致せず、デフォルト文がある場合は、デフォルト文が転送されます。</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">&lt;code&gt;SwitchError&lt;/code&gt; 選択肢も一致しない場合、 SwitchErrorがスローされます。 すべての選択肢がvoidではなく、何もスローせずにvoidの選択肢が実行された場合も、 &lt;code&gt;SwitchError&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">指定されていない場合は</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">一方が他方よりも優れている場合や、一方がコンパイルされていて他方がコンパイルされていない場合は、最初の方が選択されます。</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">引数の片方がNaNの場合、もう片方が返されます。</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">数値の一方が整数で他方が浮動小数点数の場合、 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; は、整数を浮動小数点数に（近似なしで）正確に変換できる場合にのみ &lt;code&gt;true&lt;/code&gt; を返します 。 これは、等価性の推移性を維持するためです &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; と &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 場合、 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; が整数と浮動小数点数の混合の場合。</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">一方の数値が整数で他方が浮動小数点数の場合、 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; は、 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 場合は &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;x == y&lt;/code&gt; 場合は &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;x &amp;gt; y&lt;/code&gt; =の場合は1である浮動小数点数を返します。 y 、および浮動小数点数が &lt;code&gt;NaN&lt;/code&gt; の場合はNaN 。</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">一方のオペランドがenumで、他方のオペランドがそのenumの基底型である場合、結果は基底型となります。</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">上記の変換を行った後、オペランド型の片方または両方がenumである場合、結果の型は次のようになります。</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">片方または両方のオペランドが浮動小数点の場合、浮動小数点比較が実行されます。</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">一方の範囲が無限で他方の範囲が有限であれば、有限の範囲は順方向の範囲でなければならず、無限の範囲は入力範囲であってもよい。</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">&lt;code&gt;Chain&lt;/code&gt; または &lt;code&gt;chain&lt;/code&gt; に1つの範囲のみが提供されている場合、 &lt;code&gt;Chain&lt;/code&gt; タイプは、その範囲のタイプに直接エイリアスすることにより、画像を終了します。</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">1つのタイプのみが渡される場合、そのタイプの配列。 それ以外の場合は、 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;の配列。</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">オペランドが積分型の場合</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">オーバーラップが必要な場合は、 &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; を&lt;/a&gt;使用します 。</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">クラスの &lt;code&gt;Object.opEquals()&lt;/code&gt; をオーバーライドする場合、クラスメンバー関数のシグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">クラスの &lt;code&gt;Object.opCmp()&lt;/code&gt; をオーバーライドする場合、クラスメンバー関数のシグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">pがnullの場合、操作は行われません。</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">paramsymがnullの場合は、新しいScopeDsymbolがparamsymの代わりに使われます。</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">コードポイントの範囲で渡された場合、同等の能力を持つ範囲を返します。</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">D のガベージコレクタに割り当てられたメモリへのポインタが C 関数に渡される場合、C 関数がそれを処理する前に、そのメモリがガベージコレクタによって収集されないことを確実にすることが重要です。これは次のようにして達成されます。</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">D ガベージコレクタヒープに割り当てられたメモリへのポインタが C++関数に渡される場合、C++関数がそれを処理する前に、参照されたメモリが D ガベージコレクタによって収集されないようにすることが重要です。これは次のようにして達成されます。</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">可能であれば、配列の初期化子を連想配列の初期化子に変換します。</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">存在する場合は</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">rangeがバイトの範囲の場合、対応するBase64エンコーディングのバイトを反復する &lt;code&gt;Encoder&lt;/code&gt; 。 rangeがバイトの範囲の範囲である場合、範囲の各要素のBase64エンコードされた文字列を反復する &lt;code&gt;Encoder&lt;/code&gt; 。 どちらの場合も、指定された &lt;code&gt;range&lt;/code&gt; が少なくとも前方範囲である場合、返される &lt;code&gt;Encoder&lt;/code&gt; は前方範囲になります。それ以外の場合は、入力範囲のみになります。</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">rangeが文字の範囲の場合、対応するBase64デコードのバイトを反復する &lt;code&gt;Decoder&lt;/code&gt; 。 rangeが文字の範囲の範囲である場合、範囲の各要素に対応するデコードされた文字列を反復する &lt;code&gt;Decoder&lt;/code&gt; 。 この場合、各部分範囲の長さは4の倍数でなければなりません。 返されたデコーダーは、サブレンジ境界を越えてBase64デコード状態を追跡しません。 どちらの場合も、指定された &lt;code&gt;range&lt;/code&gt; が少なくとも前方範囲である場合、返される &lt;code&gt;Decoder&lt;/code&gt; は前方範囲になります。それ以外の場合は、入力範囲のみになります。 入力データに現在のBase64エンコードスキームのベースアルファベットにない文字が含まれている場合、返される範囲は &lt;code&gt;Base64Exception&lt;/code&gt; をスローすることがあります 。</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">同じ型の場合=&amp;gt;メソッドopEqualsの1回の呼び出し</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">実行時に設定する場合、 &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; または最大値 、あるいはその両方を適切に初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">実行時に設定する場合、 &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; または最大値 、あるいはその両方を適切に初期化する必要があります。 ブロックはこのフリーリストで割り当てられている必要があり、 &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; と最大値の動的な変更は、割り当てと割り当て解除の間に発生することはできません。</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">&lt;code&gt;AllowDayOverflow.no&lt;/code&gt; に設定すると、日のオーバーフローは許可されません。</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; に設定した場合、StopWatchは構築時に開始されません。</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; に設定されている場合、ストップウォッチは構築時に開始されません。</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">&lt;code&gt;CheckDns.no&lt;/code&gt; に設定すると 、isEmailはDNSチェックを実行しません。</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">&lt;code&gt;OpenRight.yes&lt;/code&gt; に設定した場合、間隔は右側に開かれます（最後の要素は含まれません）。</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">&lt;code&gt;PopFirst.no&lt;/code&gt; に設定すると、範囲を返す前にpopFrontは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">&lt;code&gt;SortOutput.no&lt;/code&gt; に設定した場合、出力はソートされません。</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">設定されている場合、0が唯一許可されている&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;IEEE754非正規化&lt;/a&gt;数です。 allowDenormとstoreNormalizedが必要です。</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">設定されている場合は、max_exp = 1となるような指数バイアスを選択します。つまり、最大値が1.0以上2.0未満になるようにします。 指数バイアスが手動で指定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">設定されている場合、符号なしカスタムフロートは負の値とみなされます。</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">サイズの依存関係が避けられない場合は、コードに &lt;code&gt;static assert&lt;/code&gt; を挿入して確認します。</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">これらのフィールドの一部がNULLでない場合は、b_dataへのポインタとなります。</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">ソースがそれ自身を指す内部ポインタを持ち、opPostMove を定義していない場合、それを移動することはできず、アサーション失敗のトリガーとなります。</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">ソースがそれ自身を指す内部ポインタを持っている場合、それを移動することはできず、アサーション失敗のトリガーとなります。</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">空白とトークン圧縮で文字列を分割する必要がある場合は、セパレータを指定せずに &lt;code&gt;splitter&lt;/code&gt; を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">データ転送の分割が有効な場合、このコールバックは個々のチャンクのダウンロードが完了した後に呼び出されます。注意! このコールバックが設定された後は、全てのチャンクに対してコールされなければなりません。CHUNK_BGN_FUNC でこのチャンクのダウンロードがスキップされた場合でも、コールバックはすべてのチャンクに対してコールされなければなりません。これが、このコールバックで &quot;transfer_info &quot;パラメータを必要としない理由であり、&quot;resources &quot;パラメータにも興味がありません。</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Ifステートメントは、ステートメントの単純な条件付き実行を提供します。</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">構造体コンストラクターに &lt;code&gt;@disable&lt;/code&gt; アノテーションが付けられ、空の&lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterListがある&lt;/i&gt;&lt;/a&gt;場合、構造体はデフォルトの構築を無効にします。 構築できる唯一の方法は、空でない別のコンストラクターを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">構造体不変検査をオンにすると、コンストラクタの最後に構造体不変が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">構造体が &lt;code&gt;opCmp&lt;/code&gt; メンバー関数を宣言する場合は、次の形式にする必要があります。</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">構造体がID比較のために &lt;code&gt;opEquals&lt;/code&gt; メンバー関数を宣言する場合、次のようないくつかの形式が考えられます。</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">このような一致が発生した場合、inoutは一致した修飾子の共通修飾子とみなされます。2つ以上のパラメータが存在する場合、共通修飾子の計算は再帰的に適用されます。</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">もしそのような</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">テンプレート型のパラメータが関数引数のリテラル式と一致する場合、推論型はそれらの変換を絞り込むことを検討してもよい。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">.d ソースファイルが文字列 &quot;Ddoc&quot; で始まる場合、それは D コードのソースファイルとしてではなく、汎用ドキュメントとして扱われます。文字列 &quot;Ddoc &quot;の直後からファイルの最後まで、あるいは &quot;Macros:&quot;セクションがドキュメントを形成しています。そのテキストには、---行で区切られた行間に埋め込まれたDコードのハイライト以外の自動ハイライトは行われません。マクロ処理のみが行われます。</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">&lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;条件&lt;/i&gt;&lt;/a&gt;が満たされると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">&lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt;フラグが &lt;code&gt;config&lt;/code&gt; に設定されている場合、子プロセスは</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">&lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt;が1つのトークンの長さである場合、括弧は省略できます。</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">&lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;が空の場合、構造体インスタンスはデフォルトで初期化されます。</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">&lt;code&gt;BitmappedBlock&lt;/code&gt; オブジェクトが空の場合（アクティブな割り当てがない場合）は、内部のすべてのメモリを割り当て、それにスライスを返します。 それ以外の場合は、 &lt;code&gt;null&lt;/code&gt; を返します （つまり、利用可能な最大のブロックを割り当てる試みは行われません）。</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; がログを記録する &lt;code&gt;File&lt;/code&gt; 管理している場合、このメソッドはこのファイルへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; がファイル名で作成された場合、このメソッドはこのファイル名を返します。 それ以外の場合は、空の &lt;code&gt;string&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">&lt;code&gt;SharedBitmappedBlock&lt;/code&gt; オブジェクトが空の場合（アクティブな割り当てがない場合）は、内部のすべてのメモリを割り当て、そこにスライスを返します。 それ以外の場合は、 &lt;code&gt;null&lt;/code&gt; を返します （つまり、利用可能な最大のブロックを割り当てる試みは行われません）。</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; がまだ開始されていない場合は、現在のスレッドで実行してください。 完了したら、戻り値があればそれを返します。 進行中の場合は、完了するまでビジースピンしてから、戻り値を返します。 例外をスローした場合は、その例外を再スローします。</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; がまだ開始されていない場合は、現在のスレッドで実行してください。 完了したら、戻り値があればそれを返します。 進行中の場合は、条件変数を待ちます。 例外をスローした場合は、その例外を再スローします。</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; に（連想）配列が含まれている場合、その配列の長さを返します。 それ以外の場合は、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; に配列が含まれる場合、 &lt;code&gt;dg&lt;/code&gt; を配列の各要素に順番に適用します。 それ以外の場合は、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; オブジェクトが</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">&lt;code&gt;[ ]&lt;/code&gt; 形式が使用されている場合、スライスは配列全体のスライスです。</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">CURLOPT_INFILE が使用されている場合、これは送信されるファイルが実際にどのくらいの大きさなのかを libcurl に通知するために使用することができます。これにより、より良いエラーチェックが可能になり、アップロードが成功したことをより良く確認することができます。-1 は不明なサイズを意味します。</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">UDA が型である場合、シンボル上の同じ型の UDA はすべて一致します。UDA が型のテンプレートである場合、そのテンプレートのインスタンスである UDA はすべて一致します。また、UDAが値であれば、その値に等しいシンボル上のUDAはすべて一致します。</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">[EBP]を省略すると、ローカル変数と見なされます。 &lt;code&gt;naked&lt;/code&gt; を使用すると、これはもはや成立しません。</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">集約式がシーケンスである場合、宣言された反復記号は1つまたは2つであることができます。1つであれば、そのシンボルは</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">集約式が &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;wchar&lt;/code&gt; 、または &lt;code&gt;dchar&lt;/code&gt; の静的または動的配列である場合、</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">集計式が構造体またはクラスオブジェクトであるが、 &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt; または &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; が存在しない場合、構造体およびクラスオブジェクトの反復は範囲プリミティブで実行できます。 &lt;code&gt;foreach&lt;/code&gt; の場合、これは次のプロパティとメソッドを定義する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">集計式が構造体またはクラスオブジェクトの場合、 &lt;code&gt;foreach&lt;/code&gt; は特別な&lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt;メンバー関数によって定義され、 &lt;code&gt;foreach_reverse&lt;/code&gt; の動作は特別な&lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt;メンバー関数によって定義されます。 これらの関数には次のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">集約式が連想配列である場合、変数は1つまたは2つ宣言することができます。一つであれば、その変数は</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">集約体が静的配列または動的配列である場合、1つまたは2つの変数を宣言することができます。1つであれば、その変数は</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">引数がCommaExpの場合、非推奨メッセージを防ぐためのフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">引数を省略した場合は、スカラ型のデフォルト構築を意味します。</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">引数がすべて抽象クラスの型、または抽象クラスとして型指定された式のいずれかである場合、 &lt;code&gt;true&lt;/code&gt; が返されます。 それ以外の場合は、 &lt;code&gt;false&lt;/code&gt; が返されます。 引数がない場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">引数がすべて算術型の型、または算術型として型指定された式の場合、 &lt;code&gt;true&lt;/code&gt; が返されます。 それ以外の場合は、 &lt;code&gt;false&lt;/code&gt; が返されます。 引数がない場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">割り当てられた値の型がAA要素の型と同等で&lt;b&gt;ない&lt;/b&gt;場合、式は通常のインデックスアクセスで演算子のオーバーロードを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">割り当てられた値の型がAA要素の型と同等である場合。</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; または &lt;code&gt;@trusted&lt;/code&gt; コードの境界チェックが無効になっている場合でも、コードの正確さはコード作成者によって保証されている必要があります。</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">コールバックが引数を取らない場合は、オプションを見るたびにコールバックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">コールバックが文字列の引数を 1 つ取った場合は、オプション文字列 (先頭のダッシュを除いたもの)がコールバックに渡されます。その後、オプション文字列は処理されたものとみなされ、オプション配列から削除されます。</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">コールバックが2つの文字列引数を取る場合、オプションの文字列は1つの引数を持つオプションとして扱われ、それに応じて解析されます。オプションとその値はコールバックに渡されます。その後、コールバックに渡されたものはすべて処理されたものとみなされ、リストから削除されます。</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">呼び出し元がFiberであり、Generatorではない場合、この関数は適切にscheduler.yield()またはFiber.yield()を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">呼び出し元がスケジュールされたファイバーである場合、これは別のスケジュールされたファイバーへの実行をもたらします。</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">容量が増加した場合、要素へのイテレータはすべて無効になると仮定すべきである。</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">管理するメモリのチャンクが大きい場合は、最初から管理をフリーリストに切り替えることが望ましい場合があります。 このように、メモリは領域モードよりもコンパクトな方法で使用できます。 フリーリストモードを強制するには、構築後すぐに、または適切と見なされたときに、 &lt;code&gt;switchToFreeList&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">接続の進行が早すぎる場合は、それを遅くする必要があります。</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">コンストラクターが一意のオブジェクトを作成できる場合（たとえば、オブジェクトが &lt;code&gt;pure&lt;/code&gt; の場合）、オブジェクトは暗黙的に任意の修飾子に変換できます。</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">コンストラクターが一意のオブジェクトを作成できる場合（つまり、オブジェクトが &lt;code&gt;pure&lt;/code&gt; の場合）、オブジェクトは暗黙的に任意の修飾子に変換できます。</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">現在のカウントがゼロの場合は、リターンします。そうでなければ、アトミックにカウントを 1 つ減らして true を返します。</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">宣言が無効になっているが無効な関数内にある場合、 &lt;code&gt;true&lt;/code&gt; を返しますが、エラーメッセージは発行しません。</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">パラメータにデフォルト値が与えられている場合、それに続くすべてのパラメータにもデフォルト値が与えられている必要があります。</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">区切り文字が識別子の場合は、識別子の直後に改行を入れなければならず、一致する区切り文字は行頭から始まる同じ識別子となります。</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">コンテナーのメンバー関数のドキュメントが &lt;code&gt;Range&lt;/code&gt; 型のパラメーターを取る場合、それはこのコンテナーの主要な範囲型を参照します。 多くの場合、 &lt;code&gt;Take!Range&lt;/code&gt; が使用されます。この場合、範囲はコンテナ内の要素のスパンを参照します。 これらのパラメーターの引数は、操作対象のインスタンスと同じコンテナーインスタンスから取得する&lt;b&gt;必要&lt;/b&gt;が&lt;b&gt;あり&lt;/b&gt;ます。 多くの一般的な範囲アルゴリズムは、入力範囲と同じ範囲タイプを返すことに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">低速時間」の数秒の間に、ダウンロードが「低速制限」以下のバイト秒数を受信した場合、操作は中断されます。かなり高速な接続をしている場合は、20秒の間に2000bytessec以下であればアボートすることができます。</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">メールアドレスが有効かどうか</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">もし、列挙された</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">式が&lt;a href=&quot;function#property-functions&quot;&gt;プロパティ関数の&lt;/a&gt;場合、 &lt;code&gt;typeof&lt;/code&gt; は戻り値の型を示します。</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">拡張ユニテストハンドラが登録されている場合、そのハンドラの結果を直接返します。</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張子が空の場合、この関数は&lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt;と同等です 。</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">フィールドが1つのパスで初期化されている場合は、すべてのパスで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">フィールドタイプに&lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt;メソッドがある場合、初期化には使用されません。</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">フィールド型が mutable でない場合、複数回の初期化は拒否されます。</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">ファイルが開かれていない場合は、 &lt;code&gt;true&lt;/code&gt; を返します 。 それ以外の場合は、ファイルハンドルの&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">ファイルが開かれていない場合は、そのまま成功します。 それ以外の場合は、ファイルハンドルの&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">モジュールのファイル名が無効なモジュール名（例： &lt;code&gt;foo-bar.d&lt;/code&gt; ）の場合、モジュール宣言を使用して有効なモジュール名を設定できます。</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">ファイルが開かれていない場合は、空っぽに成功します。 それ以外の場合は、（ &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;を呼び出して）ファイルを閉じ、エラーをスローします。 例外がスローされても、その後 &lt;code&gt;File&lt;/code&gt; オブジェクトは空になります。 これは &lt;code&gt;detach&lt;/code&gt; とは異なり、常にファイルを閉じます。 結果として、同じハンドルを参照する他のすべての &lt;code&gt;File&lt;/code&gt; オブジェクトは、閉じられたファイルを今後参照します。</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">ファイル名にすでに拡張子が付いている場合は、置き換えられます。 そうでない場合、拡張子はファイル名に単に追加されます。 &lt;code&gt;ext&lt;/code&gt; に先行ドットを含めることはオプションです。</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">もし、最初の</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">最初の行が &quot;#!&quot;で始まる場合は、その行は無視されます。</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">最初の検索が成功しなかった場合、インポートで2番目の検索が実行されます。 2番目のルックアップフェーズでは、継承されたスコープは無視されます。 これには、基本クラスとインターフェースのスコープ（この例では、 &lt;code&gt;BaseClass&lt;/code&gt; のインポートは無視されます）と、混合 &lt;code&gt;template&lt;/code&gt; インポートが含まれます。</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">関数内で浮動小数点丸めモードが変更された場合、関数が終了する前に元に戻す必要があります。この規則に違反した場合(例えば、インラインasmの使用など)、その後の計算に使用される丸めモードは未定義となります。</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">フォーマット文字列が固定されている場合、テンプレートパラメータとして渡すことで、コンパイル時にパラメータの型の正しさがチェックされます。これはパフォーマンスを向上させることにもつながります。</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">xの端数部分がちょうど0.5の場合、戻り値は0から四捨五入されます。</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">関数が文字列形式で渡される場合、状態の名前は &lt;code&gt;&quot;a&quot;&lt;/code&gt; で、繰り返しの0から始まるインデックスの名前は &lt;code&gt;&quot;n&quot;&lt;/code&gt; です。 指定された文字列は &lt;code&gt;a[n - 1]&lt;/code&gt; 、 &lt;code&gt;a[n - 2]&lt;/code&gt; 、 &lt;code&gt;a[n - 3]&lt;/code&gt; 、...、 &lt;code&gt;a[n - stateSize]&lt;/code&gt; 指定され &lt;code&gt;a[n]&lt;/code&gt; 必要な値を返す必要があります。 状態サイズは、 &lt;code&gt;recurrence&lt;/code&gt; の呼び出しに渡される引数の数によって決まります。 &lt;code&gt;Recurrence&lt;/code&gt; 構造体は、繰り返しの状態を管理し、それを適切にシフトします。</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">関数が &lt;code&gt;void&lt;/code&gt; を返し、最初のパラメーターが &lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;out&lt;/code&gt; である場合、後続のすべての &lt;code&gt;return ref&lt;/code&gt; パラメーターは、有効期間チェックのために最初のパラメーターに割り当てられていると見なされます。 構造体の非静的メンバー関数への &lt;code&gt;this&lt;/code&gt; 参照パラメーターは、最初のパラメーターと見なされます。</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">生成されたコピーコンストラクターが型チェックに失敗した場合、 &lt;code&gt;@disable&lt;/code&gt; 属性を受け取ります。</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">生成された時点が範囲の端を適切な方向に通過した場合、代わりにその範囲の端が使用されます。 したがって、前方に反復し、生成された時点が間隔の &lt;code&gt;end&lt;/code&gt; を過ぎている場合、 &lt;code&gt;front&lt;/code&gt; は &lt;code&gt;end&lt;/code&gt; になります。 逆方向に反復し、生成された時点が &lt;code&gt;begin&lt;/code&gt; の前である場合、 &lt;code&gt;front&lt;/code&gt; が &lt;code&gt;begin&lt;/code&gt; になります 。 どちらの場合も、範囲は空になります。</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">与えられたファイルがシンボリックリンクである場合、これはそれが指すファイルではなく、シンボリックリンク自体の属性を返します。与えられたファイルが</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">与えられたヘッダが入力に見当たらない列を含んでいる場合は、それらは無視されます。</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">与えられたヘッダが入力の順序と一致しない場合は、内容は入力で見つかった通りに返されます。</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">ヒープに拡張の余地がある場合、ストアに &lt;code&gt;value&lt;/code&gt; を挿入し、 &lt;code&gt;true&lt;/code&gt; を返します 。 それ以外の場合、 &lt;code&gt;less(value, front)&lt;/code&gt; &lt;code&gt;replaceFront(value)&lt;/code&gt; を呼び出して、再度 &lt;code&gt;true&lt;/code&gt; を返します 。 それ以外の場合は、ヒープに影響を与えずに &lt;code&gt;false&lt;/code&gt; を返します 。 この方法は、候補のセットの最小の &lt;code&gt;k&lt;/code&gt; 要素を収集する必要があるシナリオで役立ちます。</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">既にAAにインデックスキーが存在する場合は、通常の代入を実行します。</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">インデックスキーがAAにまだ存在しない場合、新しいAAエントリが割り当てられ、割り当てられた値で初期化されます。</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">無限精度の結果が結果の型に収まる場合は、それを返し、 &lt;code&gt;overflow&lt;/code&gt; 触れないでください</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">イニシャライザが存在しない場合は、対応するコンストラクタから不変体を初期化することができます。</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">入力配列が既に有効な場合,この関数は元の配列を返します.そうでない場合は,不正な配列をすべてエンコーディング方式の置換シーケンスで置き換えて新しい配列を作成します.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">入力文字列がすでに有効な場合には元の文字列を返し、そうでない場合には、不正なコード単位のシーケンスをすべてエンコーディングの置換文字に置き換えて新しい文字列を作成します。</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">インスタンス &lt;code&gt;toString&lt;/code&gt; が &lt;code&gt;Object.toString&lt;/code&gt; をオーバーライドした場合、それが使用されます。</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">不変量が保持されない場合、プログラムは無効な状態になります。</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">の最後のテンプレートパラメータが</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">最後のテンプレートパラメータが &lt;code&gt;No.multiblock&lt;/code&gt; に設定されている場合、アロケータは最大で &lt;code&gt;theBlockSize&lt;/code&gt; を必要とする割り当てのみを処理します。 &lt;code&gt;BitmappedBlock&lt;/code&gt; には、単一ブロック割り当て用の特別な実装があり、一度に複数のブロックを割り当てることができないという犠牲を払って、より高いパフォーマンスを可能にします。</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">左と右のオペランドが同じ構造体タイプで、構造体タイプに&lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;がある場合、コピー操作は&lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblitで&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">の左側が</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">割り当ての左側が構造体またはクラスインスタンスのスライス操作である場合は、 &lt;code&gt;opSlice&lt;/code&gt; 関数の戻り値をパラメーターとして取る &lt;code&gt;opIndexAssign&lt;/code&gt; メンバー関数を実装することにより、オーバーロードできます。 &lt;code&gt;a[&lt;/code&gt; の形の表現</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">割り当ての左側が構造体またはクラスインスタンスのインデックス操作である場合、 &lt;code&gt;opIndexAssign&lt;/code&gt; メンバー関数を提供することでオーバーロードできます。 &lt;code&gt;a[&lt;/code&gt; の形の表現</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;false&lt;/code&gt; の場合、右側のオペランドが評価されます。 の結果タイプが</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;true&lt;/code&gt; の場合、右側のオペランドが評価されます。 の結果タイプが</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;bool&lt;/code&gt; 型に変換され、評価されて &lt;code&gt;false&lt;/code&gt; になる場合、右側のオペランドは評価されません。 の結果タイプが</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;bool&lt;/code&gt; 型に変換されて &lt;code&gt;true&lt;/code&gt; と評価された場合 、右側のオペランドは評価されません。 の結果タイプが</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">ロックが他の呼び出し元によって保持されている場合、メソッドは戻ります。そうでなければ、ロックがまだ保持されていない場合はロックを取得し、内部カウンタを 1 つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">左辺値が静的配列またはスライスである場合、動作は「 &lt;a href=&quot;array#array-copying&quot;&gt;配列のコピー&lt;/a&gt;と&lt;a href=&quot;array#array-setting&quot;&gt;配列の設定」で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">左辺値がユーザー定義のプロパティである場合、動作は&lt;a href=&quot;function#property-functions&quot;&gt;プロパティ関数で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">lvalueが動的配列の &lt;code&gt;.length&lt;/code&gt; プロパティである場合 、動作は&lt;a href=&quot;array#resize&quot;&gt;動的配列の長さの設定で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">メンバがクラスまたは構造体の場合、未定義のルックアップは</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">修飾子 &lt;code&gt;'d'&lt;/code&gt; が存在 &lt;code&gt;to&lt;/code&gt; 場合、 toの文字数は &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; のみです。 修飾子 &lt;code&gt;'d'&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">範囲内の一部の要素を削除する必要があるが、残りの要素の順序を維持する必要がない場合は、 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; を渡してremoveを実行することができます。</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">新しい配列の長さが長くなると、残りはデフォルトのイニシャライザで塗りつぶされます。</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">オブジェクトへの唯一のポインタがこれらの領域の外に保持されている場合、コレクターはそれを見逃してメモリを解放します。</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">オペランドが整数値である場合は、 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;が適用され、比較前に共通の型に変換されます。 同等性は、一般的なタイプのビットパターンが完全に一致することとして定義されます。</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">オペランドが整数型の場合は、 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;を受け、その後、 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;を使用して共通の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">オペランドがポインタである場合、オペランドのビットパターンが完全に一致していることが等しく定義されます。</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">オペランドが同じ型であれば、結果はその型になります。</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">連想演算子+または*のオペランドが浮動小数点値の場合、式の並び替えは行われません。</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">操作によってオーバーフローまたはアンダーフローが発生する場合、この関数は &lt;code&gt;0&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">演算子が &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; で、最初のオペランドがポインターで、2番目が整数型の場合、結果の型は最初のオペランドの型であり、結果の値はポインターに2番目のオペランドをプラス（またはマイナス）したものです。第1オペランドが指す型のサイズを掛けたもの。</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">演算子が &lt;code&gt;=&lt;/code&gt; の場合、それは単純な代入です。 右のオペランドは、暗黙的に左のオペランドの型に変換されて割り当てられます。</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">オプションの2番目の</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">親アロケータである &lt;code&gt;Allocator&lt;/code&gt; がステートフルの場合、そのインスタンスはメンバーとして格納されます。 それ以外の場合、 &lt;code&gt;AffixAllocator&lt;/code&gt; はAllocator.instanceを使用します。 どちらの場合も、名前 &lt;code&gt;_parent&lt;/code&gt; は、親アロケーターへのアクセスに一律に使用されます。</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">渡されたバッファが最後の割り当てではない場合、 &lt;code&gt;delta&lt;/code&gt; は最大で最後のページに残っているバイト数になります。 それ以外の場合は、仮想アドレス範囲の終わりまで最後の割り当てを拡張できます。</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; に関連付けられたプロセスがすでに終了している場合、 &lt;code&gt;tryWait&lt;/code&gt; は &lt;code&gt;wait&lt;/code&gt; とまったく同じ効果があります。 この場合、 &lt;code&gt;terminated&lt;/code&gt; フィールドが &lt;code&gt;true&lt;/code&gt; に設定され、 &lt;code&gt;status&lt;/code&gt; フィールドの &lt;code&gt;wait&lt;/code&gt; 戻り値と同じ解釈を持つタプルを返します。</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">プロセスが</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">プロセスがすでに終了している場合、この関数は直接戻ります。 終了コードはキャッシュされるため、同じ&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;でwait（）が複数回呼び出された場合、常に同じ値が返されます。</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">プロセスがシグナルによって終了した場合、戻り値の &lt;code&gt;status&lt;/code&gt; フィールドには、絶対値がシグナル番号である負の数が含まれます。 （詳細については、 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">プロセスがシグナルによって終了された場合、この関数は絶対値がシグナル番号である負の数を返します。 POSIXは通常の終了コードを0〜255の範囲に制限しているため、負の戻り値は常にシグナルによる終了を示します。 シグナルコードは、 &lt;code&gt;core.sys.posix.signal&lt;/code&gt; モジュール（ &lt;code&gt;signal.h&lt;/code&gt; POSIXヘッダーに対応）で定義されています。</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">範囲が既に辞書的に最大の偶数並べ替えである場合、その範囲は最小の偶数並べ替えに戻され、falseが返されます。そうでない場合はtrueが返され、その範囲は辞書的に次の偶数並べ替えになるように変更されます。</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">現在、範囲が辞書式に最大の順列である場合、最小順列に戻され、falseが返されます。 それ以外の場合は、trueが返されます。 したがって、 &lt;code&gt;less&lt;/code&gt; に従ってソートして範囲のすべての順列を生成できます。これにより、辞書順で最小の順列が生成され、falseが返されるまでnextPermutationが呼び出されます。 これにより、範囲のすべての異なる順列が1回だけ生成されることが保証されます。 ある場合</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 要素の前に範囲がなくなると、 &lt;code&gt;take&lt;/code&gt; は単に範囲全体を返します（ &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt;とは異なり、範囲が途中で終了するとアサーションエラーが発生します）。</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">範囲が文字列の場合、 &lt;code&gt;cmp&lt;/code&gt; はUTFデコードを適切に実行し、一度に1つのコードポイントで範囲を比較します。</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">上記の制約を満たす場合、以下のようなコピーコンストラクタが生成されます。</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">戻り値の型がintであり、結果がintに収まらない場合、32ビットで保持できる最も近い値が使用されます（そのため、 &lt;code&gt;int.max&lt;/code&gt; が上回れば &lt;code&gt;int.min&lt;/code&gt; が下回ると） 。 ただし、戻り値の型が長い場合、整数オーバーフローの処理は行われません。</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">戻り値が x と等しくない場合、FE_INEXACT 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">右側がチェックされているが、フックや下のタイプが異なる場合は、このチェックのフックや下のタイプが優先されます。</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">第二引数の長さがインデックス化された範囲の長さよりも小さい場合は例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; の2番目の文字がコロン（ &lt;code&gt;':'&lt;/code&gt; ）の場合、最初の文字はドライブ文字として解釈され、AZ（大文字と小文字を区別しない）の範囲内である必要があります。</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">2番目のオペランドがポインターで、最初のオペランドが整数型で、演算子が &lt;code&gt;+&lt;/code&gt; の場合、オペランドは逆になり、先ほど説明したポインター演算が適用されます。</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; で終わるシーケンスが整形式のコードポイントを表していない場合、 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;がスローされることがあります。 &lt;code&gt;cs&lt;/code&gt; は、比較で大文字と小文字が区別されるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">シーケンスが</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; で始まるシーケンスが整形式のコードポイントを表していない場合、 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;がスローされることがあります。</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">符号ビットがセットされている場合(つまり、「負」である場合)、NANはどの数値よりも小さく、符号ビットがセットされていない場合(「正」である場合)、NANはどの数値よりも大きくなります。</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">符号付き型が符号なし型よりも大きい場合、符号なし型は符号付き型に変換されます。</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">コンパイル時にスライスの境界を知ることができる場合、スライス式は暗黙のうちに静的配列のl値に変換されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">ソースファイルが BOM で始まらない場合は、最初の文字は U+0000007F 以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">文字列データがUTF-8で直接アクセス可能な場合は、そのポインタを返す。終端0を想定してはいけません。</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">文字列にアンパサンドが含まれていない場合は、元の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">文字列が正当なIPv4アドレスでない場合、 &lt;code&gt;ADDR_NONE&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">文字列が変更されていない場合は、元の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">構造体が&lt;b&gt;toString（）&lt;/b&gt;メソッドを定義する場合、結果はこの関数から返される文字列です。 それ以外の場合、結果はStructName（field &lt;sub&gt;0&lt;/sub&gt; 、field &lt;sub&gt;1&lt;/sub&gt; 、...）になります。ここで、field &lt;sub&gt;n&lt;/sub&gt;はデフォルトのフォーマットでフォーマットされたn番目の要素です。</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">スイッチ&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が列挙型である場合、すべての列挙メンバーが&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatementに含ま&lt;/i&gt;&lt;/a&gt;れている必要があります。</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">スイッチ &lt;code&gt;--DRT-testmode&lt;/code&gt; が実行可能ファイルに渡された場合、3つの値のいずれかになります。1.「run-main」：ユニットテストが実行された場合でも（すべて合格）、mainは実行されます。 これが現在のデフォルトです。 2.「test-or-main」：ユニットテストがあると、プログラムは結果を要約し、結果に関係なく終了します。 これは2.080のデフォルトになります。 3.「テストのみ」の場合、ランタイムは常に要約され、テストが存在しない場合でもメインは実行されません。</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">スレッドがまだ開始されていない場合は、 &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; を返します。 それ以外の場合は、Windowsでは &lt;code&gt;GetCurrentThreadId&lt;/code&gt; 、POSIXでは &lt;code&gt;pthread_self&lt;/code&gt; の結果を返します。 値は現在のプロセスに固有です。</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">タイムゾーンが &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; （または仕様のセクション4.3で &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; と同等と見なされる）の場合、 &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;ではなく、utcオフセットが &lt;code&gt;0&lt;/code&gt; の std.datetime.timezone.SimpleTimeZoneが使用され&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; 、 &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; 」はstd.datetime.timezone.UTCを使用します 。</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">2つの引数が両方ともラムダ関数(またはラムダ関数のエイリアス)である場合、それらは等しくなるように比較されます。比較が正しく計算されるためには、両方のラムダ関数について以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">2つの引数が同じ値に評価されるリテラルまたは列挙型の式である場合、trueが返されます。</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">2つのオペランドが異なるenumである場合、結果は両方に共通する最も近い基底型になります。基底型が近いということは、元の型から基底型への変換が短いことを意味します。</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">型がクラスまたは構造体の場合はそのシンボルを返し、そうでない場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">関数リテラルの型がコンテキストから一意に決定できる場合、パラメータの型推論が可能です。</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">型の特殊化が型パラメータに依存している場合は、その型パラメータの型が型引数の対応する部分に設定されます。</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">共用体が&lt;b&gt;toString（）&lt;/b&gt;メソッドを定義する場合、結果はこの関数から返される文字列です。 それ以外の場合、結果はその内容を含まないユニオンの名前になります。</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">ユニオンが最初のフィールドよりも大きい場合、残りのビットは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">ユニオンが初期化されたフィールドよりも大きい場合、残りのビットは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">ユーザー指定のサイズがゼロであるか、ユーザー指定のバッファーが空の場合、 &lt;code&gt;Exception&lt;/code&gt; をスローします 。 I / Oエラーの場合は &lt;code&gt;StdioException&lt;/code&gt; をスローします 。</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">変数が存在しない場合は作成されます。既に存在する場合は上書きされます。</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">変数が環境にない場合、この関数は何もせずに正常に戻ります。</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">variadic パラメータが、パラメータを持たないデリゲートの配列である場合。</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">で与えられる引数の数が少ない場合は</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">が複数ある場合</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">複数の &lt;code&gt;return ref&lt;/code&gt; パラメーターがある場合、戻り値の存続期間は、対応する引数の最小存続期間です。</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">宣言のスコープ内に複数のUDAがある場合、それらは連結されます。</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">関数内に複数のpragmaのインラインがある場合、辞書的に最後のものが有効になります。</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">引数がない場合、結果は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">シンボルに対するユーザー定義の属性がない場合は、空のタプルが返されます。式タプルは操作可能なタプルに変えることができます。</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">2つのシンボルが宣言されている場合、1つ目は</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">&lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; がある場合、それらの引数は、サイズ引数の後にクラスまたは構造体固有の&lt;a href=&quot;class#allocators&quot;&gt;アロケーター関数&lt;/a&gt;に渡されます。</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">クラスに定義されているコンストラクタがある場合、引数リストに一致するコンストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">構造体に対してコンストラクタが定義されている場合、引数リストに一致するコンストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;がある場合、それはObjectまたはのインスタンスのいずれかに評価する必要があります</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">出力事後条件がある場合（「 &lt;a href=&quot;contracts&quot;&gt;契約プログラミング&lt;/a&gt; 」を参照）、その事後条件は、 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が評価された後、関数が実際に戻る前に実行されます。</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">同じ時点でスコープ外に出る &lt;code&gt;scope&lt;/code&gt; 変数が複数ある場合は、変数が作成されたときとは逆の順序でデストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;がなく、それが最初ではない場合</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">クラスのコンストラクタが存在せず、基底クラスのコンストラクタが存在する場合、デフォルトのコンストラクタが暗黙のうちにフォームで生成されます。</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">デフォルトの戻り式がなく、述語がどのテスト式でもtrueにならない場合 &lt;code&gt;SwitchError&lt;/code&gt; がスローされます。 &lt;code&gt;SwitchError&lt;/code&gt; は、何もスローせずにvoid戻り式が実行された場合にもスローされます。</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">宣言に対するドキュメントコメントがない場合、その宣言は出力に表示されないかもしれません。出力に表示されるようにするには、空の宣言コメントを付けてください。</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">文字列にタイムゾーンがない場合、 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;が使用されます。 タイムゾーンが「Z」の場合、 &lt;code&gt;UTC&lt;/code&gt; が使用されます。 それ以外の場合は、UTCからの特定のオフセットに対応する&lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;が使用されます。 返される&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;が特定のタイムゾーンになるようにするには、そのタイムゾーンを渡すと、返される&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;がそのタイムゾーンに変換されます（ただし、文字列内のタイムゾーンとして読み込まれます）。</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">パラメータに型の特化がない場合は、パラメータの型がテンプレート引数に設定されます。</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">匿名列挙のメンバーが1つしかない場合は、 &lt;code&gt;{ }&lt;/code&gt; を省略できます。 &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;文法的に&lt;/i&gt;&lt;/a&gt;は、これは&lt;i&gt;AutoDeclaration&lt;/i&gt;です。</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">特定のエラーに対するハンドラがない場合、ランタイムライブラリのデフォルトハンドラで処理されます。エラーが無視される場合、プログラマーがエラーを無視するためにコードを追加したためです。</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">これらの制約が満たされない場合、関数は比較 &lt;code&gt;isSame&lt;/code&gt; と見なされ 、 isSameは &lt;code&gt;false&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">両方ともnullであれば、それらは等しくなります。片方がヌルでもう片方がヌルでない場合、それらは等しくありません。両方ともnullではない場合、それらの値が等しい場合、それらは等しい。</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">それらが等しい場合は 0 を返し、そうでない場合は fp によって返された値を返します。</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">範囲インターフェイスを持っている場合は、入力範囲としてフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">同じptrを持つ場合は1を返し、そうでない場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;のタイムゾーンが&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;である場合、TZは空です。 タイムゾーンが &lt;code&gt;UTC&lt;/code&gt; の場合、「Z」です。 それ以外の場合は、UTCからのオフセットです（例：+0100または-0700）。 UTCからのオフセットは</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;のタイムゾーンが&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;である場合、TZは空です。 タイムゾーンが &lt;code&gt;UTC&lt;/code&gt; の場合、「Z」です。 それ以外の場合は、UTCからのオフセットです（例：+01：00または-07：00）。 UTCからのオフセットは</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;Nullable&lt;/code&gt; がすでにnull値（ポインタなど）を持っている型をラップしていて、そのnull値が &lt;code&gt;nullValue&lt;/code&gt; に指定されていない場合、この &lt;code&gt;Nullable&lt;/code&gt; へのnull値の割り当ては、型 &lt;code&gt;T&lt;/code&gt; の他の値を割り当てることと同じです。結果のコードは非常に奇妙に見えます。 &lt;code&gt;nullValue&lt;/code&gt; に &lt;code&gt;T&lt;/code&gt; の「組み込み」のnull値を使用して、これを回避することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">この &lt;code&gt;Nullable&lt;/code&gt; がすでにnull値（ポインタなど）を持っている型をラップしている場合、このNullableへのnull値の割り当ては、型 &lt;code&gt;T&lt;/code&gt; の他の値を割り当てることと同じであり、結果のコードは非常に奇妙に見えます。 これは、追加の &lt;code&gt;nullValue&lt;/code&gt; テンプレート引数を取る &lt;code&gt;Nullable&lt;/code&gt; のバージョンを使用することで回避することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">この &lt;code&gt;Task&lt;/code&gt; がまだ開始されていない場合は、現在のスレッドで実行してください。 終了した場合は、結果を返します。 進行中の場合は、この &lt;code&gt;Task&lt;/code&gt; が完了するまで、このタスクが送信された &lt;code&gt;TaskPool&lt;/code&gt; インスタンスから他の &lt;code&gt;Task&lt;/code&gt; を実行します。 例外をスローした場合は、その例外を再スローします。 他に利用可能なタスクがない場合、またはこの &lt;code&gt;Task&lt;/code&gt; が &lt;code&gt;executeInNewThread&lt;/code&gt; を使用して実行された場合は、条件変数で待機します。</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">この宣言が特定の規格に準拠している場合、その説明はここに記載されています。</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">これが参照であれば、参照を解除してください。</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">これが他のタイプの周りのシェルであれば、その他のタイプを取得します。</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">これが何かの型であれば、その何かを返します。</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">これが静的配列の型であれば、その基底要素の型を返します。</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">このロックが発呼側で既に保持されていない場合は、ロックを取得し、内部カウンタを1インクリメントする。</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">このステートメントに、現在のスコープの最後にある finally 節で実行する必要のあるコードがある場合は、そのコードをステートメントの形で返します。</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">このシンボルが本当に別のシンボルの別名である場合は、その別のシンボルを返します。必要に応じて、前方参照の解決のために semantic()が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">2つの &lt;code&gt;Checked&lt;/code&gt; インスタンスがバイナリ操作に関与し、両方が &lt;code&gt;hookOpBinary&lt;/code&gt; を定義している場合、左側のフックが優先されます。 両方で &lt;code&gt;onOverflow&lt;/code&gt; を定義すると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">2つの異なるmixinを同じスコープに入れて、それぞれが同じ名前の宣言を定義すると、宣言が参照されるときに曖昧さのエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">2つ以上の関数の一致レベルが同じ場合は</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">単体テストが有効になっていない場合、実装で&lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;を構文的または意味的に正しいかどうかを確認する必要はありません。 これは、より大きな単体テストセクションのコンパイル時間への影響を減らすためです。 トークンはまだ有効である必要があり、実装は &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; トークンをカウントするだけで&lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTestのBlockStatement&lt;/i&gt;&lt;/a&gt;の終わりを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">変数に const 型の初期化子がある場合は、その初期化子を返します。</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">変数に定数式のイニシャライザがあれば、それを取得します。そうでなければ、nullを返します。</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">ベクトル拡張が実装されている場合、 &lt;a href=&quot;version#PredefinedVersions&quot;&gt;バージョン識別子&lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">この式の値が欲しいが、その上でデストラクタを呼び出したくない場合。</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">xが特別な値でない場合、結果は &lt;code&gt;cast(int) logb(x)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">xが亜正規の場合、正規化されているかのように扱われます。正で有限なxの場合</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">y&amp;gt; xの場合、結果は次に大きい浮動小数点値になります。 y &amp;lt;xの場合、結果は次に小さい値になります。 x == yの場合、結果はyです。</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">バッファが小さい場合は、直接&lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; を省略した場合、 &lt;code&gt;isAssignable&lt;/code&gt; はLhsに割り当て可能なIDをチェックします。</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">上記のオプションを使用して、ガベージコレクターとして &lt;code&gt;precise&lt;/code&gt; を選択した場合、タイプ情報は、ヒープに割り当てられたデータオブジェクト内の実際または可能なポインターまたは参照を識別するために使用されます。 非ポインタデータは、他のメモリへの参照として「誤ったポインタ」として解釈されません。 メモリースロットにポインターまたは整数値の両方を含めることができる場合、コレクターは悲観的な仮定を行う必要がありますが、それでもスキャンされます（例： &lt;code&gt;union&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">&lt;code&gt;core.memory&lt;/code&gt; の GCメモリ関数を使用し、ポインターと非ポインターデータが混在するデータに使用する場合は、割り当てられた構造体、クラス、または型のTypeInfoをオプションのパラメーターとして渡す必要があります。 デフォルトの &lt;code&gt;null&lt;/code&gt; は、どこにでもポインタを含む可能性のあるメモリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">C-style D-style variadic 引数を無視します。</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">画像の形式は参照リンクまたはインラインリンクと同じですが、感嘆符を追加します &lt;code&gt;!&lt;/code&gt; 最初の角括弧の前。 通常のリンクのリンクテキストが画像の代替テキストとして使用されます。</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">範囲引数の直後に、オプションの作業単位サイズ引数を指定できます。 &lt;code&gt;amap&lt;/code&gt; で使用される作業単位は、並列foreachで定義されたものと同じです。 ワークユニットサイズが指定されていない場合は、デフォルトのワークユニットサイズが使用されます。</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">すべての接続を直ちにドロップし、ソケットリソースを解放します。 &lt;code&gt;Socket&lt;/code&gt; オブジェクトは、 &lt;code&gt;close&lt;/code&gt; 後に使用できなくなります。 接続指向のソケットでは、 &lt;code&gt;close&lt;/code&gt; 前に &lt;code&gt;shutdown&lt;/code&gt; 呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">不変性はtransitiveであり、不変型から参照できるものに適用されることを意味します。</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">不変メンバー関数</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">不変記憶クラス</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">不変型</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">不変の連想配列が望ましい場合がよくありますが、実行時に初期化を行う必要がある場合があります。 これは、コンストラクター（スコープに応じた静的コンストラクター）、バッファーの連想配列、 &lt;code&gt;assumeUnique&lt;/code&gt; を使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">不変宣言はl値として現れることができます。</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">不変のメンバー関数は、オブジェクトと &lt;code&gt;this&lt;/code&gt; 参照によって参照されるものはすべて不変であることを保証します。 それらは次のように宣言されます。</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">ストレージクラスとして使用されるimmutableは、宣言の型全体の型の修飾子としてimmutableを使用することと同等です。</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">インペリアルアラム語</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">Impl * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; （const TypeInfo_AssociativeArray ti、void [] keys、void [] vals）;</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">実装ヘルパー</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">実装上の注意:多くのベクトル演算は、ターゲットコンピュータで利用可能なベクトル演算命令を利用することが期待されています。</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">&lt;code&gt;IAllocator&lt;/code&gt; を使用したIAllocatorの実装。 これにより、静的に構築されたアロケーター型が、テンプレート化されていないコードで直接使用できる &lt;code&gt;IAllocator&lt;/code&gt; に適合します。</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">&lt;code&gt;ISharedAllocator&lt;/code&gt; を使用したISharedAllocatorの実装。 これは、静的に構築され、スレッド間で共有可能なアロケーター型を、テンプレート化されていないコードで直接使用できる &lt;code&gt;ISharedAllocator&lt;/code&gt; に適合させます。</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendT&lt;/code&gt; および &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendcTX&lt;/code&gt; および &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraycatnTX&lt;/code&gt; および &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraysetlengthT&lt;/code&gt; および &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;赤黒木&lt;/a&gt;コンテナの実装。</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">alloca()標準の C ルーチンの実装。</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">配列代入支援ルーチンの実装。</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">配列コピーサポートルーチンの実装</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">連想配列の実装。</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">コードカバレッジアナライザの実装。</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">動的配列プロパティサポートルーチンの実装</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">Win32用の例外処理サポートルーチンの実装。</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">例外処理支援ルーチンの実装</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">不変サポートルーチンの実装</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">標準的なBase64エンコーディングの実装。</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">同期化されたブロックのサポートルーチンの実装。</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">実装は、GC ポインタがワード境界にのみ格納されていることを自由に仮定することができます。整列していないポインタは完全に無視されます。</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">実装はいつでも自由にコレクションを実行することができます。しかし、割り当ての試みが発生し、利用可能なメモリが不足している場合にのみ実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">実装は非ルートヒープを正確な方法で自由にスキャンできるため、 &lt;code&gt;float&lt;/code&gt; のような型のフィールドはヒープをスキャンするときに関連するとは見なされません。 したがって、GCポインタを整数型（たとえば、 &lt;code&gt;size_t&lt;/code&gt; ）にキャストし、GCヒープ内のその型のフィールドに格納すると、メモリブロックが正確な型情報または &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; 割り当てられた場合に認識されない可能性があります。 BlkAttr。 &lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">実装では、ディレクトリトラバーサルのセキュリティ脆弱性を回避するために、ファイル名を制限することができます。可能な制限としては、ファイル名に含まれるパスの構成要素を禁止することが考えられます。</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">実装では、未認識のエラーを診断しなければなりません。</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">実装は内部ポインタをサポートする必要があります。 つまり、GCで管理されたメモリブロックへの唯一の参照が先頭ではなくブロックの中央を指している場合（たとえば）、GCはメモリブロックがライブであると見なす必要があります。 このルールの例外は、メモリブロックが &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; 割り当てられる場合です。 &lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;属性。 これらのメモリブロックがライブと見なされる必要がある場合に、それらへの適切なポインタがあることを確認するのはユーザーの責任です。</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">しかし、異なるアーキテクチャ上でのDの実装は、メモリモデル、関数のコールリターン規約、引数渡し規約などを自由に変更することができます。</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">Posixでは &lt;code&gt;pthread_mutex&lt;/code&gt; および &lt;code&gt;pthread_condition&lt;/code&gt; 、Windowsでは &lt;code&gt;CreateEvent&lt;/code&gt; および &lt;code&gt;SetEvent&lt;/code&gt; を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">Posixでは &lt;code&gt;pthread_mutex&lt;/code&gt; を、Windowsでは &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; を使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">スケジューラを実装することで、このモジュールで使用される同時実行メカニズムを様々なニーズに応じてカスタマイズすることができます。デフォルトでは、spawn への呼び出しは、供給されたルーチンを実行し、終了時に終了する新しいカーネルスレッドを作成します。しかし、スレッドを再利用するスケジューラを作成したり、1 つのスレッドにまたがって ファイバー (コアーチン)を多重化したり、その他のアプローチをとることは可能です。スケジューラの選択をユーザーレベルのオプションにすることで、この動作が事前に定義されている場合よりも、はるかに多くのタイプのアプリケーションに std.concurrency を使用することができます。</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; と &lt;code&gt;BigInt&lt;/code&gt; または組み込み整数を含むBigIntの 3者間比較を実装します。</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">他の &lt;code&gt;BigInt&lt;/code&gt; および組み込みの整数型との &lt;code&gt;BigInt&lt;/code&gt; 等価テストを実装します。</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 単項演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">「T」スタイルのパイプを実装し、入力範囲をラップして、範囲の要素を繰り返し処理し&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; 、指定された関数またはOutputRangeに渡すことができるようにします。 これは、範囲コードの長いチェーンで中間値を出力したり、 &lt;code&gt;front&lt;/code&gt; または &lt;code&gt;popFront&lt;/code&gt; を呼び出すたびに副作用のある操作を実行したり、範囲の要素を補助&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt;範囲に転用したりするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">特定のランダムアクセス範囲タイプ（通常は &lt;code&gt;T[]&lt;/code&gt; ）またはランダムアクセスコンテナータイプ（通常は &lt;code&gt;Array!T&lt;/code&gt; ）の上に&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;バイナリヒープ&lt;/a&gt;コンテナーを実装します 。 &lt;code&gt;BinaryHeap&lt;/code&gt; のドキュメントでは、基になる範囲またはコンテナを</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">二重リンクリストを実装します。</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">整数型を組み込んだ絞り込み剰余演算を実装します。</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">範囲に対して並列foreachループを実装します。 これは、ワーカースレッドごとに1つの &lt;code&gt;Task&lt;/code&gt; を暗黙的に作成して &lt;code&gt;TaskPool&lt;/code&gt; に送信することで機能します。 ワークユニットは、他のスレッドとの通信の間にワーカースレッドによって処理される一連の連続する要素のセットです。 作業単位ごとに処理される要素の数は、 &lt;code&gt;workUnitSize&lt;/code&gt; パラメーターによって制御されます。 作業単位が小さいほど、負荷分散が向上しますが、作業単位が大きいほど、他のスレッドと頻繁に通信して次の作業単位をフェッチするオーバーヘッドが回避されます。 大規模な作業単位は、範囲が変更されている場合の誤った共有も回避します。 ループの1回の反復にかかる時間が &lt;code&gt;workUnitSize&lt;/code&gt; ほど、 workUnitSizeは大きくなります。 非常に高価なループ本体の場合、 &lt;code&gt;workUnitSize&lt;/code&gt; は1にする必要があります。デフォルトの作業単位サイズを選択するオーバーロードも使用できます。</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">シンプルで高速なシングルリンクリストを実装します。スタックとして使うことができます。</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">配列にデータを追加する出力範囲を実装します。 これは、多くの要素を追加 &lt;code&gt;array ~= data&lt;/code&gt; ときに、 配列〜=データよりも効率的であるため推奨されます。 &lt;code&gt;Appender&lt;/code&gt; は独自の配列メタデータをローカルに維持するため、 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;がゼロ以外の各アペンドのグローバルロックを回避できます。</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= integer&lt;/code&gt; 形式の組み込み整数からの代入演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= BigInt&lt;/code&gt; 形式の代入演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; と組み込み整数の間の2項演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 間に2項演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; へのキャストを実装します。</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">整数型へのキャストをインプリメントします。</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">修飾された &lt;code&gt;BigInt&lt;/code&gt; とのキャストを実装します。</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">StaticForeachDeclarationとStaticForeachStatementの共通機能を実装します。これにより、必要な下げが行われてから、mdd.statementsem.makeTupleForeachを使用して、対応する &lt;code&gt;static foreach&lt;/code&gt; 宣言またはステートメントを展開できます。</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dchar&lt;/code&gt; の &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;入力範囲&lt;/a&gt;からカンマ区切り値とそのバリアントを読み取る機能を実装します。</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">伐採施設を実装します。</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">低レベルの時間プリミティブをインプリメントします。</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">ミキシングタイプをインプリメントします。</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">左側に組み込み整数、右側に &lt;code&gt;BigInt&lt;/code&gt; を持つ演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">例外に関連するルーチンを実装します。</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; （単項および二項）、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;^^&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; の飽和を実装します。 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">演算子 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; 、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; の飽和を実装します。 このフックは、バイナリ演算の結果が &lt;code&gt;Lhs&lt;/code&gt; に適合せず、情報の損失や符号の変更がない場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">IEEE CRC32 の '共通' バリアント (LSB-first order,初期値 uint.max,補数結果)を実装します。</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">点 &lt;code&gt;[xn_1, x_n]&lt;/code&gt; （理想的にはルートに近い）から始まる関数 &lt;code&gt;fun&lt;/code&gt; のルートを見つけるための&lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;割線メソッド&lt;/a&gt;を実装します。 &lt;code&gt;Num&lt;/code&gt; は、 &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、または &lt;code&gt;real&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">すべてのタイプEの &lt;code&gt;OutputRange&lt;/code&gt; インターフェースを実装し、各タイプ &lt;code&gt;E&lt;/code&gt; の &lt;code&gt;put&lt;/code&gt; メソッドを仮想関数にラップします。</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">MurmurHash3関数を実装します。 ハッシュの &lt;code&gt;size&lt;/code&gt; をビット単位で指定できます。 128ビットハッシュの場合、32ビットアーキテクチャと64ビットアーキテクチャのどちらを最適化するかを指定できます。 &lt;code&gt;opt&lt;/code&gt; 値を指定しない場合、ホストプラットフォームの最高速バージョンが選択されます。</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">json配列のforeach &lt;code&gt;opApply&lt;/code&gt; インターフェースを実装します。</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">jsonオブジェクトのforeach &lt;code&gt;opApply&lt;/code&gt; インターフェースを実装します。</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">高次フィルター機能を実装します。 述語は&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;に渡され、文字列、または &lt;code&gt;pred(element)&lt;/code&gt; を介して実行できる任意の呼び出し可能オブジェクトを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">関数型のさまざまなプログラミング言語に存在する同音異義語関数（ &lt;code&gt;accumulate&lt;/code&gt; 、 &lt;code&gt;compress&lt;/code&gt; 、 &lt;code&gt;inject&lt;/code&gt; 、または &lt;code&gt;foldl&lt;/code&gt; とも呼ばれます）を実装します。</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">関数型のさまざまなプログラミング言語に存在する同音異義語関数（ &lt;code&gt;accumulate&lt;/code&gt; 、 &lt;code&gt;compress&lt;/code&gt; 、 &lt;code&gt;inject&lt;/code&gt; 、または &lt;code&gt;foldl&lt;/code&gt; とも呼ばれます）を実装します。 &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; 呼び出すと、最初に &lt;code&gt;seed&lt;/code&gt; が内部変数 &lt;code&gt;result&lt;/code&gt; に割り当てられます。これはアキュムレータとも呼ばれます。 次に、 &lt;code&gt;range&lt;/code&gt; の各要素 &lt;code&gt;x&lt;/code&gt; について、 &lt;code&gt;result = fun(result, x)&lt;/code&gt; が評価されます。 最後に、 &lt;code&gt;result&lt;/code&gt; が返されます。 引数が1つのバージョンの &lt;code&gt;fold!(fun)(range)&lt;/code&gt; も同様に機能しますが、範囲の最初の要素をシードとして使用します（範囲は空でない必要があります）。</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">関数型のさまざまなプログラミング言語に存在する同音異義語関数（ &lt;code&gt;accumulate&lt;/code&gt; 、 &lt;code&gt;compress&lt;/code&gt; 、 &lt;code&gt;inject&lt;/code&gt; 、または &lt;code&gt;foldl&lt;/code&gt; とも呼ばれます）を実装します。 同じことをしますが、パラメーターの順序が逆の&lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;もあります。 &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; 呼び出すと、最初に &lt;code&gt;seed&lt;/code&gt; が内部変数 &lt;code&gt;result&lt;/code&gt; に割り当てられます。これはアキュムレータとも呼ばれます。 次に、 &lt;code&gt;range&lt;/code&gt; の各要素 &lt;code&gt;x&lt;/code&gt; について、 &lt;code&gt;result = fun(result, x)&lt;/code&gt; が評価されます。 最後に、 &lt;code&gt;result&lt;/code&gt; が返されます。 引数が1つのバージョンの &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; も同様に機能しますが、範囲の最初の要素をシードとして使用します（範囲は空でない必要があります）。</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">関数フレーバーの多くの言語に存在する同音異義語関数（ &lt;code&gt;transform&lt;/code&gt; とも呼ばれる）を実装します。 &lt;code&gt;map!(fun)(range)&lt;/code&gt; の呼び出しは、範囲内のすべての要素 &lt;code&gt;a&lt;/code&gt; に対して &lt;code&gt;fun(a)&lt;/code&gt; を左から右に適用することによって取得される要素の範囲を返します。 元の範囲は変更されません。 評価は怠惰に行われます。</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; が使用する最も派生したインターフェースを実装し、関連するすべての範囲プリミティブを仮想関数にラップします。 &lt;code&gt;R&lt;/code&gt; がすでに &lt;code&gt;InputRange&lt;/code&gt; インターフェースから派生している場合は、それ自体を別名にします。</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">組み込み配列の範囲インターフェイスプリミティブを実装します。 非 &lt;code&gt;array.back&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 array.backは &lt;code&gt;back(array)&lt;/code&gt; と同等です。 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;狭い文字列の&lt;/a&gt;場合、 &lt;code&gt;back&lt;/code&gt; は最後の&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;コードポイント&lt;/a&gt;を &lt;code&gt;dchar&lt;/code&gt; として自動的に返します。</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt;プロパティに従う型および狭い文字列に対して &lt;code&gt;empty&lt;/code&gt; の範囲インターフェースプリミティブを実装します。 非 &lt;code&gt;a.empty&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 a.emptyは &lt;code&gt;empty(a)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">組み込み配列の範囲インターフェースプリミティブ &lt;code&gt;front&lt;/code&gt; を実装します。 非 &lt;code&gt;array.front&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 array.frontは &lt;code&gt;front(array)&lt;/code&gt; と同等です。 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;狭い文字列の&lt;/a&gt;場合、 &lt;code&gt;front&lt;/code&gt; は最初の&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;コードポイント&lt;/a&gt;を &lt;code&gt;dchar&lt;/code&gt; として自動的に返します。</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">組み込み配列の範囲インターフェースプリミティブ &lt;code&gt;popBack&lt;/code&gt; を実装します。 非 &lt;code&gt;array.popBack&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 array.popBackは &lt;code&gt;popBack(array)&lt;/code&gt; と同等です。 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;狭い文字列の&lt;/a&gt;場合、 &lt;code&gt;popFront&lt;/code&gt; は最後の&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;コードポイントを&lt;/a&gt;自動的に削除します 。</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">組み込み配列の範囲インターフェースプリミティブ &lt;code&gt;popFront&lt;/code&gt; を実装します。 非 &lt;code&gt;array.popFront&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 array.popFrontは &lt;code&gt;popFront(array)&lt;/code&gt; と同等です。 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;狭い文字列の&lt;/a&gt;場合、 &lt;code&gt;popFront&lt;/code&gt; は自動的に次のコードポイントに進みます。</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">組み込み配列の範囲インターフェイスプリミティブの &lt;code&gt;save&lt;/code&gt; を実装します。 非 &lt;code&gt;array.save&lt;/code&gt; はドット表記を使用して最初の引数で呼び出すことができるという事実により、 array.saveは &lt;code&gt;save(array)&lt;/code&gt; と同等です。 関数は配列の内容を複製せず、単に引数を返します。</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">参照型の暗黙の変換</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">暗黙の変換</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">暗黙のネスティング</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">暗黙の修飾子変換</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">暗黙の型推論</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">暗黙の変換は、必要に応じて自動的に型を変換するために使用されます。</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; のように、このJSONValueで暗黙的に &lt;code&gt;toJSON&lt;/code&gt; を呼び出しますが、</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">このJSONValueで暗黙的に &lt;code&gt;toJSON&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">輸入宣言</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">式のインポート</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">インポート宣言は、任意のスコープで使用することができます。例えば</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; や &lt;code&gt;FreeTree&lt;/code&gt; など、割り当てサイズに敏感なアロケータの動作を改善します。 割り当て要求を切り上げると、空きメモリ（内部の断片化）を犠牲にして、空きリスト/ツリーが小さくなります。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">Cでは、関数のプロトタイプが配列であると言っていても、配列はポインタとして関数に渡されます。Dでは、静的配列は参照ではなく値で渡されます。したがって、関数プロトタイプは C の期待するものに合わせて調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">式の中で</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">WindowsのDLLでは、この関数がDllMain経由でDLL_PROCESS_DETACHを引数にして呼ばれた場合、適切なクリーンアップを行わずにスレッドが強制的に終了してしまいます。</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">コンストラクター本体では、デリゲートコンストラクターが呼び出された場合、すべてのフィールド割り当ては割り当てと見なされます。 それ以外の場合、フィールド割り当ての最初のインスタンスはその初期化であり、 &lt;code&gt;field = expression&lt;/code&gt; の形式の割り当ては &lt;code&gt;typeof(field)(expression)&lt;/code&gt; と同等に扱われます。 フィールドの値は、初期化またはデリゲートコンストラクターでの構築の前に読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">コンストラクタ本体では、フィールド代入の最初のインスタンスはその初期化です。</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">複数のシンボルを宣言する宣言では、すべての宣言は同じ型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">一般的なアプリケーションでは、ブロッキングしているソケットにタイムアウトを設定するのではなく、ノンブロッキングのソケットを使用することも検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; &lt;/a&gt;に加えて、このモジュールは&lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt;型コンストラクタも定義します。 &lt;code&gt;Variant&lt;/code&gt; とは異なり、 &lt;code&gt;Algebraic&lt;/code&gt; はインスタンス化で指定された型の有限セットのみを許可します（たとえば、 &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; または &lt;code&gt;string&lt;/code&gt; しか保持できません）。</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">利便性に加えて、これらの関数は、これらの関数が戻る前に Fft オブジェクトが決定論的に破棄されるので、一回の使用のために Fft オブジェクトを手動で作成するよりもわずかに効率的です。</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">乱数発生器に加えて、このモジュールは分布を特徴としています。これは、様々な方法で発生器の出力統計分布を歪ませます。これまでのところ、整数と実数の一様分布が実装されています。</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">さらに、--DRT-gcopt=helpを実行すると、オプションの一覧と現在の設定が表示されます。</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">さらに、データ &lt;code&gt;callerSize&lt;/code&gt; 、 &lt;code&gt;callerModule&lt;/code&gt; 、 &lt;code&gt;callerFile&lt;/code&gt; 、 &lt;code&gt;callerLine&lt;/code&gt; 、および &lt;code&gt;callerTime&lt;/code&gt; は、それぞれの特定の割り当てに関連付けられています。 このデータは、各割り当ての前に付けられます。</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">アルゴリズムで範囲を2つに分割する場合、分割点の左側のみに要素の相対的な順序を保持します。</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">すべての場合において、関数は &lt;code&gt;lhs == rhs&lt;/code&gt; 組み込み結果を返します。</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">すべての場合において、2つのシンボルのバージョンも受け入れられます。その場合、最初のシンボル（整数型、たとえば、 &lt;code&gt;ulong&lt;/code&gt; または &lt;code&gt;uint&lt;/code&gt; ）は、現在の行のゼロベースの番号を追跡します。</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">すべての場合において、 &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; -1：lhs&amp;gt; rhs 。 誤った比較の場合、結果は自動修正されません。</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">すべての場合において、返された範囲の連結は &lt;code&gt;haystack&lt;/code&gt; 全体に及びます。</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">それ以外の場合は、単純な要素ごとの足し算を行います。</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">それ以外の場合は、組み込みの動作を行います。</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">他のすべての点で、この関数は &lt;code&gt;spawnProcess&lt;/code&gt; と同じように機能します。 他の関数パラメーター、戻り値、スローされる可能性のある例外の説明については、 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">すべての文字列リテラル形式では、 &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;は単一の &lt;code&gt;\n&lt;/code&gt; 文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">他のすべての点で、これらのメソッドは他のメソッドと同じです。これらのメソッドは静的であったり、異なるリンケージを持っていたり、アドレスを持っていたりすることができます。</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">C ++とDの両方で、構造体にフィールドがない場合でも、構造体のサイズは1バイトです。 ただし、C ++では、フィールドがゼロの構造体がベース構造体として使用されている場合、そのサイズはゼロです（ &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;空のベース最適化&lt;/a&gt;と呼ばれます）。 Dでこの動作をエミュレートするには2つの方法があります。1つ目は、関数への参照を転送して、ベースへの偽の参照を返します。</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">&lt;code&gt; &quot;%(&quot;&lt;/code&gt; で始まり &lt;code&gt;&quot;%)&quot;&lt;/code&gt; で終わる複合形式指定子の場合、 &lt;code&gt;_nested&lt;/code&gt; には2つの区切り文字内に含まれる文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">複合形式指定子の場合、 &lt;code&gt;_sep&lt;/code&gt; には &lt;code&gt;&quot;%|&quot;&lt;/code&gt; の後に文字列の位置が含まれます 。 &lt;code&gt;sep is null&lt;/code&gt; 、区切り記号が &lt;code&gt;sep.empty&lt;/code&gt; ことを意味します。それ以外の場合、 sep.emptyは、長さ0の区切り記号を意味します。</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">&lt;code&gt;LogLevel.fatal&lt;/code&gt; を含むログメッセージの場合、何も起こりません。</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">I / Oエラーの場合、 &lt;code&gt;StdioException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">I / Oエラーの場合は、 &lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; を&lt;/a&gt;スローします 。</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">I / Oエラーの場合は、 &lt;code&gt;StdioException&lt;/code&gt; をスローします 。</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">一部のパラメーターについてのみバンドリングを有効にする場合は、 &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; を使用してバンドリングをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">置換の生成が最終的な目標である場合、 &lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt;は、置換の場合でも割り当てを回避する関数として役立ちます。</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">のようにオペランドのサイズが曖昧な場合。</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">問題の文字列が既に正規化されている場合は、変更されずに返され、メモリ割り当ては発生しません。</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">詳細には、 &lt;code&gt;__delete(x)&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合は何もせずに戻ります 。 それ以外の場合は、次のアクションを順番に実行します。</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">実際には、 &lt;code&gt;takeOne(r)&lt;/code&gt; は &lt;code&gt;take(r, 1)&lt;/code&gt; ）といくらか同等ですが、特定のインターフェイスでは、範囲に含めることができる要素は多くても1つだけであることを静的に知ることが重要です。</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">どちらの場合でも、バッファーの内容は呼び出し間で再利用されます。 つまり、 &lt;code&gt;popFront&lt;/code&gt; はpopFrontが呼び出された後は保持されないため、保持が必要な場合、呼び出し元は（たとえば、 &lt;code&gt;buffer.dup&lt;/code&gt; を呼び出して）その内容をコピーする必要があります。 上記の例では、最後の反復を除いて、すべての反復で &lt;code&gt;buffer.length&lt;/code&gt; は4096です。この場合、 &lt;code&gt;buffer.length&lt;/code&gt; は4096未満になる可能性があります（ただし常にゼロより大きい）。 前述の制限により、 &lt;code&gt;byChunk&lt;/code&gt; は入力範囲と互換性のある任意のアルゴリズムで機能します。</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">フリーリストモードでは、 &lt;code&gt;KRRegion&lt;/code&gt; はメモリのチャンクにフリーブロックリストを埋め込みます。 フリーリストは循環的で、結合され、常にアドレスでソートされています。 割り当てと割り当て解除には、以前に割り当て解除されたブロックの数に比例して時間がかかります。 （実際には、コストが低くなる可能性があります。たとえば、メモリが割り当てと逆の順序で割り当て解除されると、すべての操作に一定の時間がかかります。）メモリ使用率は良好です（制御構造が小さく、割り当てごとのオーバーヘッドがありません）。 フリーリストモードの短所は、断片化しやすいこと、2ワードの最小割り当てサイズ、線形の最悪の場合の割り当て時間と割り当て解除時間です。</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">関数スコープでは、インポートされたシンボルは、インポート宣言が関数本体に語彙的に現れた後にのみ表示されます。つまり、関数スコープでインポートされたシンボルは前方参照できません。</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">関数型プログラミング言語では、これは通常、 &lt;code&gt;scan&lt;/code&gt; 、 &lt;code&gt;scanl&lt;/code&gt; 、 &lt;code&gt;scanLeft&lt;/code&gt; または &lt;code&gt;reductions&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">一般に、プロセスがデタッチとして生成された（ &lt;code&gt;Config.detached&lt;/code&gt; フラグで生成された）プロセスでない限り、親プロセスを終了する前に子プロセスが終了するのを常に待つ必要があります。 そうしないと、それらは「 &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;ゾンビ&lt;/a&gt; 」になる可能性があります。つまり、機能していなくても、OSプロセステーブルのスロットを占有しているプロセスです。 デタッチされたプロセスを所有していないので、それらを待つべきではありません。</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">一般に、PRNGを定期的に「再シード」しても品質は向上せず、場合によっては害を及ぼす可能性があります。 極端な例として、メルセンヌツイスターには &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; 異なる状態がありますが、 &lt;code&gt;seed(uint)&lt;/code&gt; が呼び出された後は、エントロピーのソースがどれほど優れているかに関係なく、 &lt;code&gt;2 ^^ 32&lt;/code&gt; の異なる状態のいずれかにしかなりません。</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">一般に、このモジュールの関数は、入力パスが整形式であることを前提としています。 （つまり、無効な文字を含めたり、ファイルシステムのパス形式に従う必要があります。）不正な形式のパスで関数を呼び出した結果は未定義です。 パスまたはファイル名が無効である可能性がある場合（たとえば、ユーザーによって入力された場合）、これを確認するために&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt;関数を使用することが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">多くの場合、クロスコンパイルがサポートされており、ターゲットサイズではなくホストサイズを使用することになるため、データ型のサイズを取得するために sizeof()を直接使用することはできません。</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">入れ子になった</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">古いバージョンのフォボスでは、以前は書けるようになっていました。</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、 &lt;code&gt;Logger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; がグローバル &lt;code&gt;LogLevel&lt;/code&gt; 以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、 &lt;code&gt;sharedLog&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;defaultLogLevel&lt;/code&gt; 以上である必要があり、渡される条件が &lt;code&gt;true&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、 &lt;code&gt;sharedLog&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;defaultLogLevel&lt;/code&gt; 以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;sharedLog&lt;/code&gt; および &lt;code&gt;defaultLogLevel&lt;/code&gt; の LogLevel以上である必要があり、さらに渡される条件が &lt;code&gt;true&lt;/code&gt; である必要があります 。</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が、 &lt;code&gt;sharedLog&lt;/code&gt; および &lt;code&gt;defaultLogLevel&lt;/code&gt; の LogLevel以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;sharedLog&lt;/code&gt; の LogLevel以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;defaultLogLevel&lt;/code&gt; 以上である必要があり、さらに渡される条件が &lt;code&gt;true&lt;/code&gt; である必要があります 。</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;defaultLogLevel&lt;/code&gt; 以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">データを処理するには、ログ呼び出しの &lt;code&gt;LogLevel&lt;/code&gt; が、 &lt;code&gt;sharedLog&lt;/code&gt; および &lt;code&gt;defaultLogLevel&lt;/code&gt; の LogLevel以上である必要があります。 さらに、渡される条件は &lt;code&gt;true&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;sharedLog&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上で、グローバルLogLevel以上である必要があります。 さらに、 &lt;code&gt;LogLevel&lt;/code&gt; は &lt;code&gt;stdSharedLogger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が &lt;code&gt;stdThreadLocalLog&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上であり、グローバルLogLevel以上である必要があります。 さらに、 &lt;code&gt;LogLevel&lt;/code&gt; は &lt;code&gt;stdSharedLogger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上でなければなりません。 条件が指定されている &lt;code&gt;true&lt;/code&gt; は、 trueに評価される必要があります 。</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が使用されている &lt;code&gt;Logger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上で、グローバルLogLevel以上である必要があり &lt;code&gt;true&lt;/code&gt; 。さらに、渡される条件がtrueである必要があります 。</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が使用されている &lt;code&gt;Logger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上で、グローバルLogLevel以上である必要があり &lt;code&gt;true&lt;/code&gt; 。さらに、渡された条件がtrueである必要があります 。</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が使用されている &lt;code&gt;Logger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上で、グローバルLogLevel以上でなければならず、条件が &lt;code&gt;true&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、 &lt;code&gt;LogLevel&lt;/code&gt; が使用されている &lt;code&gt;Logger&lt;/code&gt; の &lt;code&gt;LogLevel&lt;/code&gt; 以上であり、グローバルLogLevel以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、使用される &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; がグローバル &lt;code&gt;LogLevel&lt;/code&gt; 以上で、条件が &lt;code&gt;true&lt;/code&gt; である必要があります 。</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">結果のログメッセージがログに記録されるためには、使用される &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; がグローバル &lt;code&gt;LogLevel&lt;/code&gt; 以上である必要があります。</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">アロケータとして使用できるようにするには、型は次のメソッドをそれぞれのセマンティクスで実装する必要があります。 &lt;code&gt;alignment&lt;/code&gt; と &lt;code&gt;allocate&lt;/code&gt; のみが必要です。 他のメソッドのいずれかが欠落している場合、アロケータはその機能を持たないと見なされます（たとえば、一部のアロケータはメモリの手動割り当て解除を提供しません）。 アロケータは、常に失敗するようにサポートされていないメソッドを実装するべきではありません。 たとえば、 &lt;code&gt;alignedAllocate&lt;/code&gt; を実装する機能がないアロケータは、（常に &lt;code&gt;null&lt;/code&gt; を返すか、例外をスローするように定義するのではなく）まったく定義しないでください。 不足している実装は、アロケータの機能について他のコンポーネントに静的に通知し、それに応じて設計上の決定を行えるようにします。</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">オブジェクト &lt;code&gt;o&lt;/code&gt; がクラス &lt;code&gt;B&lt;/code&gt; のインスタンスであるかどうかを判別するには、キャストを使用します。</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">コンパイル時にロギングを無効にするには、プログラムコードをコンパイルするときに、 &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; をバージョン引数として &lt;code&gt;D&lt;/code&gt; コンパイラに渡します。 これにより、すべてのログ機能が無効になります。 特定の &lt;code&gt;LogLevel&lt;/code&gt; は、コンパイル時に無効にすることもできます。 &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; でロギングを無効にするには、バージョンとして &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; を渡します。 次の表は、どのバージョンステートメントがどの &lt;code&gt;LogLevel&lt;/code&gt; を無効にするかを示しています。</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">ブロックの長さを先頭に配置するためには、ブロックを適切に整列させる必要がある場合に備えて、16バイトのバッファスペースを確保しなければなりません。x86では、特定のSSE命令はデータが16バイトアラインメントされている場合にのみ動作します。さらに、次のブロックへの誤ったポインタを防ぐためにセンチネルバイトが必要です。余分なオーバーヘッドがあるため、ブロックサイズと比較してオーバーヘッドが最小となるページサイズ以上の場合にのみ、この処理を行います。</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">機能するために、 &lt;code&gt;FallbackAllocator&lt;/code&gt; は &lt;code&gt;Primary&lt;/code&gt; が &lt;code&gt;owns&lt;/code&gt; メソッドを定義することを要求します。 これは、特定の割り当てを担当したアロケータを決定するために必要です。</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">つまり、リテラル式をキャストするとリテラルの型が変わります。</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">以前のバージョンのPhobosでは、これは &lt;code&gt;TypeTuple&lt;/code&gt; と呼ばれていました 。</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">原則として、このクラスから派生したスローされたオブジェクトのみが、 &lt;code&gt;catch&lt;/code&gt; ブロック内で安全にキャッチできます。 Exceptionから派生していないスローされたオブジェクトは、特定のランタイム保証が保持されない可能性があり、プログラムの実行を継続することが危険になるため、キャッチしてはならないランタイムエラーを表します。</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">原則として、これはローカルタイムゾーンの名前です。 ただし、これは常に空の文字列を返します。 これは、OSが指定する属性（ &lt;code&gt;stdName&lt;/code&gt; や &lt;code&gt;dstName&lt;/code&gt; など ）によってタイムゾーンを一意に識別できず、PosixシステムもWindowsシステムもローカルタイムゾーンのTZデータベース名を簡単に取得できないためです。</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">In single line mode matches any character.そうでなければ、'It matches any character except 'ann' and '\r' 以外の文字にマッチする。</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">いくつかの日付計算では、月や年を追加すると、その月の日付が有効ではない日になってしまうことがあります (例:2001年2月29日や2000年6月31日)。オーバーフローが許可されている場合(デフォルトでは)、その月はそれに応じてインクリメントされます(例えば、2001年2月29日は2001年3月1日になり、2000年6月31日は2000年7月1日になります)。オーバーフローが許可されていない場合は、その月の最後の有効な日に調整されます(したがって、2001年2月29日は2001年2月28日になり、2000年6月31日は2000年6月30日になります)。</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">std.datetimeでは、時間点に対する様々な算術演算の結果としても使用されます。</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">上記の状況では、エラーは生成されたコードに関するものなので、エラーには行番号が含まれていません。</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">上記の場合、スロット &lt;code&gt;1&lt;/code&gt; の要素は削除されますが、範囲の最後の要素に置き換えられます。 安定性要件の緩和を利用して、移動する要素を、 &lt;code&gt;remove&lt;/code&gt; するスロットの上のアレイの端から削除します。 これにより、実行するデータ移動が少なくなり、関数の実行時間が改善されます。</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">マルチセットの場合、要素 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;r1&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt; 回出現し、 &lt;code&gt;r2&lt;/code&gt; で出現することを考えると、結果の範囲での &lt;code&gt;a&lt;/code&gt; の出現回数は、x&amp;gt; yの場合は &lt;code&gt;x-y&lt;/code&gt; 、それ以外の場合は0になります。</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">多重集合の場合,与えられた要素の出現数が最小となる範囲は,その要素の出現数を結果として得られる範囲に伝播させます.</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">単調な時間の場合、 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;はClockTypeでテンプレート化され &lt;code&gt;ClockType&lt;/code&gt; 、 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; では、ランタイム引数です。単調な時間の場合、時計のタイプが&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;オブジェクトの解像度に影響するためです。一方、 &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt;では、時刻のソースに関係なく、その解像度は常にヘクトナノ秒です。</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">対応するDコードでは、 &lt;code&gt;foo&lt;/code&gt; はC ++リンケージおよび関数呼び出し規則を持つものとして宣言されています。</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">現在の関数では、'this'関数を呼び出しています。1.現在の関数が'this'関数を呼べるかどうかを確認し、呼べない場合はエラーを出す。2.2.現在の関数がこの関数の親でない場合は、現在の関数をこの関数の兄弟リストに追加する。3.3.現在の関数がリテラルで、上位レベルのスコープにアクセスしている場合は、その関数をデリゲートとしてマークします。エラーが発生した場合は真を返します。</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">上記の例では、「-foo」と「--bar」は認識されますが、「-Foo」、「-Bar」、「-FOo」、「-bAr」などは拒否されます。 ディレクティブは、 &lt;code&gt;getopt&lt;/code&gt; の終わりまで、または逆のディレクティブ &lt;code&gt;caseInsensitive&lt;/code&gt; が検出されるまでアクティブです。</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">上のグラフでは、有向パスは正当な暗黙の変換です。 示されているもの以外の修飾子の組み合わせは無効です。 修飾子の2つのセットの間に有向パスが存在する場合、このように修飾された型は&lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;と呼ばれます。 同じ情報を以下の表形式で示します。</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">2番目のステップでは、 &lt;code&gt;filenameCmp!cs&lt;/code&gt; を使用してパスコンポーネントを比較します &lt;code&gt;cs&lt;/code&gt; は、比較で大文字と小文字を区別するかどうかを決定するオプションのテンプレートパラメーターです。 詳細については、 &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">単一の関数のみが提供される特殊なケース（ &lt;code&gt;F.length == 1&lt;/code&gt; ）では、単一の渡された関数（ &lt;code&gt;F[0]&lt;/code&gt; ）に単にエイリアスを追加します。</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">次の表では、 &lt;b&gt;正確なエイリアス&lt;/b&gt; esは、指定されたビット数とまったく同じ型です。 &lt;b&gt;少なくともエイリアス&lt;/b&gt; esは、少なくとも指定されたビット数であり、大きくすることができます。 &lt;b&gt;高速エイリアス&lt;/b&gt; esは、プロセッサでサポートされる最も高速な整数型であり、少なくとも指定されたビット数と同じ幅です。</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">この場合、 &lt;code&gt;myAllocator&lt;/code&gt; は &lt;code&gt;IAllocator&lt;/code&gt; インターフェースには従いませんが、そのプリミティブを実装しているため、ダックタイピングによって &lt;code&gt;makeArray&lt;/code&gt; を操作できます。 このセットアップについて注意すべき重要な点の1つは、静的に型指定されたアセンブルされたアロケーターは、 &lt;code&gt;IAllocator&lt;/code&gt; を通過するアロケーターよりもほとんど常に高速であることです 。 重要な経験則は、「最初にアロケーターを &lt;code&gt;IAllocator&lt;/code&gt; 、その後にIAllocatorに適応する」です。 優れたアロケータは、テンプレートアセンブリを使用して複雑なロジックを実装し、クライアントレベルで &lt;code&gt;IAllocator&lt;/code&gt; （通常は&lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; を使用&lt;/a&gt; ）で1回だけラップされます。</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">この場合、位置1、3、4、9のスロットはアレイから削除される。</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">この実装では、両方の引数は正でなければなりません。積分は、a と x の相対値に応じて、累乗級数または連続分数展開によって評価されます。</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">この状況では、割り当て要素は実際の割り当て式です（定義されている場合は &lt;code&gt;opAssign&lt;/code&gt; が使用されます）。</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">この表の「doPut」は、正しいプリミティブを使用して &lt;code&gt;e&lt;/code&gt; を &lt;code&gt;r&lt;/code&gt; に配置するメソッドです &lt;code&gt;R&lt;/code&gt; &lt;code&gt;put&lt;/code&gt; を定義している場合は &lt;code&gt;r.put(e)&lt;/code&gt; 、 &lt;code&gt;r&lt;/code&gt; が入力範囲の場合は &lt;code&gt;r.front = e&lt;/code&gt; （その後に &lt;code&gt;r.popFront()&lt;/code&gt; が続く） ）、それ以外の場合は &lt;code&gt;r(e)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">このようにして、構造体やクラスオブジェクトはあたかも関数であるかのように振る舞うことができます。</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">このようにして、構造体やクラスオブジェクトはあたかも配列であるかのように振る舞うことができます。</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">ユーザーコードの中では。このクラスは、グローバル(クロスモジュール)識別子のリストにバージョン識別子を追加する手段も提供します。</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">インとアウトと相続</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">インオーダーPentium(Pentium1、PMMX、Atom</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt;オプションをすべて含めます。</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">上記のオプションのいずれも含めない。</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; （ ヘクトナノ秒（100 ns））、 &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; （マイクロ秒）、 &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; （ミリ秒）、 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;hours&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;months&quot;&lt;/code&gt; 」を含みます&quot; 、および &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">文字 a,b,c,...,z を含む。</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">不完全ベータ積分</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">不完全ガンマ積分とその補数</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">&lt;code&gt;element_count&lt;/code&gt; を組み込み、ハッシュをファイナライズします。</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">このインターフェイスを実装した具象クラスの参照数を増やします。</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">インクリメンタルオプション。</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numOwns&lt;/code&gt; をインクリメントし（インスタンスごとおよび呼び出しごとに）、 &lt;code&gt; parent.owns(b)&lt;/code&gt; に転送します。</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">パラメータに関係なく、このロガーはメッセージを記録しません。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">インデックス代入演算子のオーバーロード</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">インデックス式</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">インデックス名 NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">インデックス名 テーブル名</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">指定された名前のパラメータのインデックス</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">インデックス Op 割当演算子オーバーロード</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">インデックス演算子のオーバーロード</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置パラメーターの引数のインデックス &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;ubyte.max&lt;/code&gt; まで 。 （ &lt;code&gt;0&lt;/code&gt; は未使用を意味します）。</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置パラメーター範囲の最後の引数のインデックス（ &lt;code&gt;ubyte.max&lt;/code&gt; 。 （ &lt;code&gt;0&lt;/code&gt; は未使用を意味します）。</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">範囲の最大要素のインデックス。 &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">範囲の最小要素のインデックス。 &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">Indexed！（Source、Indices） &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt; （Source、Indices）（Source source、Indices indices）;</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">インデックス作成とスライスの操作。 &lt;code&gt;hasSlicing!Source&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ提供されます 。</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">インデックス演算子は、指定されたインデックスの値を生成または修正します。</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">インデックス作成、スライス、双方向操作および範囲プリミティブ。 &lt;code&gt;hasSlicing!Source&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ提供されます 。</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">時間の方向を示します。 使用例の1つは、 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt;関数で、これを使用して、間隔を後方（過去に）、前方（未来）、またはその両方に拡張する必要があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">入れ子になった集約が関数のインライン化を防ぐかどうかを示します。これはコストを計算するために使用されますが、インライナーが処理を行う間、集約体のコピーを避けるためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">空いている物理メモリをオペレーティング・システムに返すことで、管理されているメモリ空間を最小化することを示します。返される空きメモリの量は、アロケータの設計とプログラムの動作に依存します。</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">各種契約書のチェック状態を表示します。</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thread_scanAllType&lt;/code&gt; によって実行されているスキャンの種類を示します。</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONValue&lt;/code&gt; のタイプを示します。</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がファイルハンドルかどうか、つまり、型が暗黙的に&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; に&lt;/a&gt;変換可能か、または&lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; &lt;/a&gt;へのポインターかを示します。</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">アドレスが GC 2011 によってマークされているかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">比較が大文字と小文字を区別するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">どの契約にチェックを入れるか、入れないかを示します。</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">個々の文字（ &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`）は、 &lt;code&gt;%s&lt;/code&gt; を含むUnicode文字として、および整数固有の形式仕様を持つ整数としてフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">個々の文字は &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; を使用して比較されます &lt;code&gt;cs&lt;/code&gt; は、比較で大文字と小文字を区別するかどうかを決定するオプションのテンプレートパラメータです。</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">個々の文字は &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; を使用して比較されます &lt;code&gt;cs&lt;/code&gt; は、比較で大文字と小文字を区別するかどうかを決定するオプションのテンプレートパラメータです。 詳細については、 &lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">Ctor内の個別フィールドで、その呼び出し音と位置に関する情報を持つ。</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">個々のテストは、 &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;を使用した単体テストで指定されます。 とは異なり</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">不等式とは、平等の論理否定と定義されています。</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">パラメータ &lt;code&gt;upTo&lt;/code&gt; が指定されている場合、無限範囲は互換性があります。その場合、実装は単にupToを返します。</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">スライシングをサポートする無限範囲は、特定の下限と上限でスライスされたときに&lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; の&lt;/a&gt;インスタンスを返す必要があります（ &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; を&lt;/a&gt;参照）。 &lt;code&gt;handle&lt;/code&gt; は、ハンドラー関数の戻り値から0を &lt;code&gt;take&lt;/code&gt; し、例外がキャッチされたときにそれを返すことで、これを処理します。</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">ラップされた範囲の無限性は伝搬されません。ランダムでないアクセス範囲の場合、長さは伝搬されません。</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">ファイルの情報、Posixシステムのstatから取得するものに似ています。</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">インターフェースに関する情報。オブジェクトがインターフェースを介してアクセスされると、インターフェース*はそのvtblの最初のエントリとして表示されます。</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">オプションについての情報です。</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">エラーに関する情報は、このレベルで記録する必要があります。</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">クラスの動的型に関する情報</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">エラーについての情報です。</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">対象となるOS、環境、CPUに関する情報です。</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">外部定義されたテンプレートのメンバ関数、メンバデータ、メンバクラスについて収集された情報。</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">入れ子になったクラスの友達に関する情報を集めました。</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">ネストされた明示的な特殊化について収集された情報。</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">一次メンバーのテンプレート明示的な特殊化について収集された情報。</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">割り当てられたメモリブロックに関する情報、またはエラー時のBlkInfo.init。</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">エラー時にpまたはBlkInfo.initによって参照されるメモリブロックに関する情報。</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">初期値</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">初期化フック、各スレッドから呼び出される。モジュールの初期化状態についての仮定はしてはいけません。</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite ライブラリの初期化</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">TOK.cantExpression Expressionを初期化します。</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">設定変数を初期化します。</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">druntimeを初期化します。CプログラムがDコードを呼び出したい場合で、D main()がない場合は、rt_init()とrt_term()を呼び出さなければなりません。</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">この関数の属性を推論するための初期化を行います。</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">リストパッケージを初期化します。</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">Cの文字列を使ってObjective-Cの文字列を初期化します。</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">ターゲットの初期化</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">デュアルコンテキスト配列をコンテキストポインタで初期化します。</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">隠れた集計メンバ vthis をコンテキストポインタで初期化します。</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">作業用のカール ハンドルを作成してインスタンスを初期化します。</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">メモリアロケータの初期化</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">メッセージとエラーコードで初期化します。</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">初期化子 &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">初期化子&lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt; （初期化子init、スコープ* sc）;</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">&lt;strong id=&quot;initializerSemantic&quot;&gt;イニシャライザinitializerSemantic&lt;/strong&gt; （ &lt;strong id=&quot;initializerSemantic&quot;&gt;イニシャライザ&lt;/strong&gt; init、Scope * sc、タイプt、NeedInterpret needInterpret）;</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt; （Initializer inx）;</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">イニシャライザASTノード</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">コピーするイニシャライザAST</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; を使用して &lt;code&gt;RefCounted&lt;/code&gt; を初期化します。 &lt;code&gt;RefCounted&lt;/code&gt; のテンプレートパラメータ &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;val&lt;/code&gt; から推定されます。 この関数は、コピー不可能な値をヒープに移動するために使用できます。 また、 &lt;code&gt;RefCounted&lt;/code&gt; の &lt;code&gt;autoInit&lt;/code&gt; オプションを無効にします。</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">制限されたサイズのグループでスレッドを解放するバリアオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">与えられたミューテックスオブジェクトに関連付けられた条件オブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">動的D関数に関連付けられたファイバーオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">静的な D 関数に関連付けられたファイバーオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">動的D関数に関連付けられたジェネレータオブジェクトを初期化します。この関数は、反復のための範囲を準備するために一度だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">静的なD関数に関連付けられたジェネレーターオブジェクトを初期化します。この関数は、反復のための範囲を準備するために一度だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">mutexオブジェクトを初期化し、それを &lt;code&gt;obj&lt;/code&gt; のモニターとして設定します。</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">ミューテックスオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">指定されたポリシーでリードライトミューテックスオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">リードライト・ミューテックス・リーダ・プロキシ・オブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">リードライト・ミューテックス・ライター・プロキシ・オブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">指定された初期カウントでセマフォオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">動的D関数に関連付けられたスレッドオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">静的なD関数に関連付けられたスレッドオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; すべての要素を &lt;code&gt;.init&lt;/code&gt; 値で初期化します。 範囲の要素が初期化されていないと仮定します。</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">イベントオブジェクトを初期化します。イベントが既に初期化されている場合は何もしません。</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 各要素を &lt;code&gt;value&lt;/code&gt; で初期化します 。 範囲の要素が初期化されていないと仮定します。 これは、コピーコンストラクターを定義する構造体にとって重要です（他のすべての型の場合、 &lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;とuninitializedFillは同等です）。</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">シンボルsを例外ハンドラテーブルの内容で初期化します。</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">ダイジェストを初期化します。</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ランタイムを初期化します。 この呼び出しは、標準のプログラム初期化プロセスが実行されない場合に使用されます。 これは、ほとんどの場合、共有ライブラリまたはCプログラムにリンクされたライブラリにあります。 ランタイムが既に正常に初期化されている場合、これはtrueを返します。 initializeの各呼び出しは、 &lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; の&lt;/a&gt;呼び出しとペアにする必要があります 。</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">スレッドモジュールを初期化します。この関数は、起動時にガベージコレクタによって呼び出され、他のスレッドルーチンが呼び出される前に呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">このオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">スレッドセーフな方法で遅延 init 値で var を初期化します。</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">複数回フィールドを初期化するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">最初、 &lt;code&gt;KRRegion&lt;/code&gt; は「リージョン」モードで起動します。割り当ては、メモリチャンクからリージョン形式で提供されます。 したがって、十分なメモリが残っている限り、 &lt;code&gt;KRRegion.allocate&lt;/code&gt; には領域アロケーターのパフォーマンスプロファイルがあります。 割り当て解除は、解放されたブロックを（&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）時間で）非構造化フリーリストに挿入します。これは、リージョンモードでは読み取られません。</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">指定された &lt;code&gt;input&lt;/code&gt; でパターン &lt;code&gt;re&lt;/code&gt; とのすべての重複しない一致の検索を開始します 。 結果は、左から右への入力で遭遇するときに生成される遅延範囲の一致です。</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">シャットダウンを開始する</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">インラインアセンブラ</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">インラインコード</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">インラインリンク</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">インラインステータス</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">インラインアセンブラを使用してハードウェアに直接アクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">DMD用のインラインアセンブラの実装。</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">インラインアセンブラはasm文でサポートされています。</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">インラインコードは、GitHub、Reddit、Stack Overflow、その他のウェブサイトで使われている構文と同様に、バックティック文字 (`)の間に書くことができます。この動作を行うには、開始文字と終了文字 ` の両方が同じ行に現れなければなりません。</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">インラインスタイルのリンクは、リンクテキストを角括弧で、リンクURLを括弧で囲みます。参照リンクのように、URLの後には、一重引用符や二重引用符で囲まれたタイトルテキストや、括弧で囲まれたタイトルテキストを付けることができます。</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">インアウト機能</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">Inout型は暗黙のうちにconstまたはinout constに変換できますが、それ以外の型には変換できません。その他の型は、暗黙のうちに inout に変換することはできません。安全な関数では、inoutへのキャストやinoutからのキャストは許可されていません。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">入力配列。</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">入力範囲プリミティブ。</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">入力範囲プリミティブ。常に存在します。</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">InputRange haystack</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; （エイリアスpred = &quot;a == b&quot;、InputRange、Element）（InputRange haystack、scope Element needle）</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; （エイリアスpred、InputRange）（InputRange haystack）</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt; （エイリアスpred = &quot;a == b&quot;、InputRange、ForwardRange）（InputRange seq、ForwardRange choices）</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt; （InputRange1、InputRange2）（InputRange1 src、InputRange2 tgt）</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject！R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt; （R）（R range）</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">碑文のパフラビ</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">碑文パルティア</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">バックスティックを挿入</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">ドル記号を挿入する</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">左括弧を挿入</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">改行(改行)を挿入する</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">コンテナに要素の範囲を挿入します。これは、現在コンテナを反復処理している範囲を無効にしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">右括弧を挿入</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">コンテナに単一の要素を挿入します。これは、現在コンテナを反復処理している範囲を無効にしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">ソースからターゲットに現在のアイテムを挿入します。</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">tryブロックの内側から外側へのgotoを行う際に、最終的なブロック呼び出しを挿入します。ブロックが生成された後に行われます。なぜなら、グラフのすべてのエッジがわかるからですが、Bpredが計算される前にブロックが生成されます。EH_DWARF例外のアンワインド時のみ。</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">トライブロックの内側から外側へのリターンやゴトーを行う際に、最終的なブロックにゴトーを挿入します。ブロックが生成された後に行われます。なぜならば、グラフのすべてのエッジがわかるからですが、Bpredが計算される前にブロックが生成されます。例外処理のない関数の場合に限ります。insertFinallyBlockCalls()と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">n 番目の位置にリストに項目を挿入します。</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">無効な UTF シーケンスの代わりに挿入されます。</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">存在しない場合は挿入</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">データベースが一杯なので挿入に失敗しました。</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">実行時の配列境界チェックコードの挿入は、コンパイラスイッチ&lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; で&lt;/a&gt;オフにできます。</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">実行時の配列境界チェックコードの挿入は、コンパイル時のスイッチでオン/オフを切り替える必要があります。</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; &lt;code&gt;pos&lt;/code&gt; の位置にもの（入力範囲または任意の数の暗黙的に変換可能なアイテムでなければなりませ &lt;code&gt;stuff&lt;/code&gt; ）を挿入します。</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">範囲 &lt;code&gt;r&lt;/code&gt; の後に &lt;code&gt;stuff&lt;/code&gt; を挿入します。これは、このコンテナから以前に抽出された空でない範囲でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">範囲 &lt;code&gt;r&lt;/code&gt; の後に &lt;code&gt;stuff&lt;/code&gt; を挿入します。これは、このコンテナから以前に抽出された範囲でなければなりません。 リストのすべての範囲がリストの最後で終わるとすると、この関数は基本的にリストに追加し、リストの最後のノードに到達するための高速な方法として &lt;code&gt;r&lt;/code&gt; を使用します。 理想的には、 &lt;code&gt;r&lt;/code&gt; はリストの最後の要素の近くまたは最後に配置されます。</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">範囲 &lt;code&gt;r&lt;/code&gt; の前、後、または代わりに何かを挿入します。範囲rは 、この配列から以前に抽出された有効な範囲でなければなりません。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; に変換可能な値または &lt;code&gt;T&lt;/code&gt; に変換可能なオブジェクトの範囲です。 安定バージョンと非安定バージョンの両方が同じように動作し、配列を反復する範囲が無効化されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">範囲 &lt;code&gt;r&lt;/code&gt; の前、後、または代わりに何かを挿入します。範囲rは 、この配列から以前に抽出された有効な範囲でなければなりません。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;bool&lt;/code&gt; に変換可能な値、または &lt;code&gt;bool&lt;/code&gt; に変換可能なオブジェクトの範囲です。 安定バージョンと非安定バージョンの両方が同じように動作し、配列を反復する範囲が無効化されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">コンテナの前面に &lt;code&gt;stuff&lt;/code&gt; を挿入します。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; に変換可能な値または &lt;code&gt;T&lt;/code&gt; に変換可能なオブジェクトの範囲です。 安定版は同じように動作しますが、コンテナを反復する範囲が無効化されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">コンテナの前面/背面に &lt;code&gt;stuff&lt;/code&gt; を挿入します。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; に変換可能な値または &lt;code&gt;T&lt;/code&gt; に変換可能なオブジェクトの範囲です。 安定版は同じように動作しますが、コンテナを反復する範囲が無効化されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の後ろに &lt;code&gt;v&lt;/code&gt; を挿入します 。</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の前に &lt;code&gt;v&lt;/code&gt; を挿入します 。</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">ストアに &lt;code&gt;value&lt;/code&gt; を挿入します 。 基本となるストアが範囲かつ &lt;code&gt;length == capacity&lt;/code&gt; 場合、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; によって選択された1つまたは複数の位置にcに &lt;code&gt;x&lt;/code&gt; を挿入し &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">空行を挿入します。</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">出力にコメントを挿入します。</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">完全なロードストアメモリフェンスを挿入します(必要なプラットフォームでは)。これにより、この関数を呼び出す前のすべてのロードとストアが、 呼び出し後のすべてのロードとストアよりも先に実行されることを保証します。</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">与えられた名前のオーバーロードの間に区切り文字を挿入します。</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">インラインコードを挿入します。</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">指定した位置で既存の配列に挿入します.</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">区切り記号 ',' を挿入します。</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">配列の後ろに指定された要素を挿入します。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; に変換可能な値または &lt;code&gt;T&lt;/code&gt; に変換可能なオブジェクトの範囲です。</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">配列の後ろに指定された要素を挿入します。 &lt;code&gt;stuff&lt;/code&gt; は、 &lt;code&gt;bool&lt;/code&gt; に変換可能な値、または &lt;code&gt;bool&lt;/code&gt; に変換可能なオブジェクトの範囲です。</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">複合形式指定子の内部では、文字列と文字は自動的にエスケープされます。 この動作を回避するには、 &lt;b&gt;「-」&lt;/b&gt;フラグを &lt;code&gt;&quot;%(&quot;&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">インスタンス変数</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">すべての呼び出し元で共有されるインスタンス。</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">クラスオブジェクトのインスタンスは、 &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpressionを使用し&lt;/i&gt;&lt;/a&gt;て作成されます。</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">このオブジェクトのインスタンスは、 &lt;code&gt;regex&lt;/code&gt; の呼び出しを介して構築されます。 これは、頻繁に使用される正規表現をキャッシュおよび保存するためのフォームです。</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;DebugCondition&lt;/code&gt; をインスタンス化する</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;VersionCondition&lt;/code&gt; をインスタンス化する</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">与えられたパラメータで与えられたテンプレートをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">インスタンス化スコープ</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">インスタンス情報</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">新しい関数呼び出し式をインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">タイムアウトを使用している場合でも、シグナルアラームハンドラを使用しないように libcurl に指示します。このオプションは、マルチスレッド アプリケーションに便利です。詳細は libcurl-the-guide を参照してください。</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">より小さい受信バッファを使用するように libcurl に指示します。</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">スレッドモジュールが初期化されたときに、スレッドの中断と再開のために SIGUSR1 と SIGUSR2 以外のシグナルを使用するように指示します。この関数は thread_init()の前に一度だけ呼び出す必要があります。この関数は Posix 専用です。</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">プログラムのセマンティクスを実装するために、ターゲット・アーキテクチャから命令が選択されます。典型的な結果は、リンカへの入力に適したオブジェクトファイルになります。</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt; （式e）;</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">整数リテラル</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">整数プロモーション</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">整数プロモーションは、以下のタイプのコンバージョンです。</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">'-']digit(s)[U (byte、ubyte、short、ushort、int、uint、long、ulong)['+'</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">整数比較演算子</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">整数比較</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">整数の比較は、両方のオペランドが積分型の場合に発生します。</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">整数値は、積分昇格後に整数ビットパターンを表すことができない別の型に暗黙的に変換することはできません。例えば</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;リテラル&lt;/strong&gt; （int v）（）;</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">整数(定数倍になる可能性があります)。</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">整数や浮動小数点値は、暗黙のうちに等価なベクトルに変換することができます。</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">整数の直後に「L」、「u」、「U」のいずれか、または両方を続けることができます。 'l'サフィックスがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">整数は10進数、2進数、16進数で指定できます。</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">整数には「_」文字を埋め込むことができますが、無視されます。</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">積分演算子は固定幅の型で動作します。固定幅では表現できない結果は、黙って切り捨てられてフィットします。このモジュールは、同じ結果を生成する積分演算プリミティブを提供しますが、そのような切り捨てが発生した場合には「オーバーフロー」フラグを設定します。この設定はスティッキーで、多数の演算をカスケードして、最後にフラグをチェックするだけで済むことを意味します。演算が符号付きか符号なしかは、それぞれ's'または'u'という接尾辞で示されます。これは、型の符号付き度をオーバーロードすることで、このようなサフィックスを付けなくても実現できますが、サフィックスを付けることで、型を調べなくてもどちらの操作が行われているかを明確にすることができます。</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">積分範囲</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">インテグラル型は32ビットコードと64ビットコードの間で同じサイズのままです。</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">積分は、 &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; の&lt;/a&gt;ようにフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">Intel Atom 230330(ファミリー6、モデル0x1C)は受注生産品のコア。</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">Intel NetBurst(Pentium 4、Pentium D)。</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">Intel P6(PentiumPro、PII、PIII、PM、Core、Core2)。</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">インテルとAMDの32ビットプロセッサ</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">インテルとAMDの64ビットプロセッサ</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt;ユーティリティと同等の範囲を意図しています。 &lt;code&gt;range&lt;/code&gt; の長さが &lt;code&gt;_n&lt;/code&gt; 以下の場合、 &lt;code&gt;range&lt;/code&gt; はそのまま返されます。</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の双方向範囲のインターフェース。</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の有限ランダムアクセス範囲のインターフェイス。</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の前方範囲のインターフェース。</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の無限ランダムアクセス範囲のインターフェイス。</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の出力範囲のインターフェース。 使用法は、 &lt;code&gt;InputRange&lt;/code&gt; インターフェースと子孫に似ています。</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">診断レポートのためのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">インターフェース・メンバ関数は、その関数のボディがなくてもコントラクトを持つことができます。契約は、そのインターフェース・メンバ関数を実装しているクラス・メンバ関数に継承されます。</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">C++へのインターフェース</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">ODBC C ライブラリへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">アラインメントの指定をサポートするOS固有のアロケーターへのインターフェイス：Posixでは&lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; 、Windowsでは&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">SQLite C ライブラリへのインターフェース。</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">libcurl C ライブラリのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">Cリンクされたリスト型へのインターフェイスです。</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">zlib C ライブラリへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">Interface [] &lt;strong id=&quot;interfaces&quot;&gt;インターフェース&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">インターフェースを継承したり、関数をオーバーライドしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">インターフェースは派生クラスで再実装することができます。</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">インターフェイスは、メンバーに関数テンプレートを持つことができます。 すべてのインスタンス化された関数は暗黙的に &lt;code&gt;final&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">インターフェースはクラスから派生することはできません。クラスは 1 つのインターフェイスから複数回派生することはできません。</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">インターフェースは、インターフェースを継承するクラスが実装しなければならない関数のリストを記述します。インターフェースを実装したクラスは、そのインターフェースへの参照に変換することができます。</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">FTS5を拡張するためのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">契約書とのインターフェース</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">ガベージ収集されたオブジェクトと外部コードのインターフェイス</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
