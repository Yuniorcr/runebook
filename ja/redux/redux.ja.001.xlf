<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="30d4829117610e90feb15aaa2afa4a03b8acf085" translate="yes" xml:space="preserve">
          <source>#1024: Proposal: Declarative reducers</source>
          <target state="translated">#1024:提案。宣言的減速機</target>
        </trans-unit>
        <trans-unit id="4b615433f4ff0d26c5fa5b193e0e7d0cc3e80d05" translate="yes" xml:space="preserve">
          <source>#1051: Shortcomings of the current applyMiddleware and composing createStore</source>
          <target state="translated">#1051:現在のapplyMiddlewareとcreateStoreを構成する際の欠点</target>
        </trans-unit>
        <trans-unit id="03e1f9116a8ad70c48d717384dff4c3d9ed0b8d4" translate="yes" xml:space="preserve">
          <source>#1057: subscribe listener can get action param?</source>
          <target state="translated">#1057:subscribeリスナーはアクションパラメータを取得できますか?</target>
        </trans-unit>
        <trans-unit id="4bc2d46618e57ca5f5cd58ca24a444b2e3962cbd" translate="yes" xml:space="preserve">
          <source>#1098: Using Redux in reusable React component</source>
          <target state="translated">#1098:再利用可能なReactコンポーネントでReduxを使用する</target>
        </trans-unit>
        <trans-unit id="1172766c55389d23293c28bd580351638a8b05bb" translate="yes" xml:space="preserve">
          <source>#1139: An alternative side effect model based on generators and sagas</source>
          <target state="translated">#1139号:発電機とサガに基づく代替的な副作用モデル</target>
        </trans-unit>
        <trans-unit id="277db1c86685b6e2ab3da794c5499c7fdcf8c74e" translate="yes" xml:space="preserve">
          <source>#1165: Where to put business logic / validation?</source>
          <target state="translated">#1165:ビジネスロジック/バリデーションをどこに置くか?</target>
        </trans-unit>
        <trans-unit id="05a3cbd838b24d5f189d009b179a62c97ae2d04c" translate="yes" xml:space="preserve">
          <source>#1167: Reducer without switch</source>
          <target state="translated">#1167:スイッチなしの減速機</target>
        </trans-unit>
        <trans-unit id="f13afaff66dc7b23e3b11883862fef5f53054aed" translate="yes" xml:space="preserve">
          <source>#1171: Recommendations for best practices regarding action-creators, reducers, and selectors</source>
          <target state="translated">#1171:アクションクリエーター、レデューサー、セレクターに関するベストプラクティスの提案</target>
        </trans-unit>
        <trans-unit id="66dd37b1d3975be52ce9c12bd63d02993da859c1" translate="yes" xml:space="preserve">
          <source>#1176: Redux+React with only stateless components</source>
          <target state="translated">#1176:ステートレスコンポーネントのみを使用したRedux+React</target>
        </trans-unit>
        <trans-unit id="2ed8de88174cb4015a9a40feb1eb36d44bdfc115" translate="yes" xml:space="preserve">
          <source>#1185: Question: Should I use immutable data structures?</source>
          <target state="translated">#1185:質問です。不変のデータ構造を使うべきですか?</target>
        </trans-unit>
        <trans-unit id="36502c2af1991f87b5ec953b1ce29619a393fcb7" translate="yes" xml:space="preserve">
          <source>#1248: Is it ok and possible to store a react component in a reducer?</source>
          <target state="translated">#1248:リデューサにリアクターコンポーネントを格納するのは大丈夫で可能ですか?</target>
        </trans-unit>
        <trans-unit id="882566f27d0e15811a3d2222e5b3e7be9f37c3e6" translate="yes" xml:space="preserve">
          <source>#1255: Normalizr usage with nested objects in React/Redux</source>
          <target state="translated">#1255:React/Redux での入れ子になったオブジェクトでの Normalizr の使用法</target>
        </trans-unit>
        <trans-unit id="df2442136b9e5a150b1df77be37dfaf76f081455" translate="yes" xml:space="preserve">
          <source>#125: Strategy for avoiding cascading renders</source>
          <target state="translated">#第125回:カスケードレンダリングを回避するための戦略</target>
        </trans-unit>
        <trans-unit id="d37bec3c108aab23faa29d1d3ccc744b38e02030" translate="yes" xml:space="preserve">
          <source>#1262: Immutable data + bad performance</source>
          <target state="translated">#1262位:不変のデータ+パフォーマンスの悪さ</target>
        </trans-unit>
        <trans-unit id="9be52b6008b5e36ca13d546156068f2e0681de57" translate="yes" xml:space="preserve">
          <source>#1269: Add tree view example</source>
          <target state="translated">#1269:ツリービューの例を追加</target>
        </trans-unit>
        <trans-unit id="9fbe916b0a42eeb4f1b8b1ce74cfca5a8c904167" translate="yes" xml:space="preserve">
          <source>#1279: Have any suggestions for where to put a Map Component in Flux?</source>
          <target state="translated">#1279:Fluxのマップコンポーネントをどこに置くか、何か提案はありますか?</target>
        </trans-unit>
        <trans-unit id="bbdbf83cd3a993497d417bb7aaf52383244a21b5" translate="yes" xml:space="preserve">
          <source>#1287: How to choose between Redux's store and React's state?</source>
          <target state="translated">#1287:ReduxのストアとReactのステートを選択するには?</target>
        </trans-unit>
        <trans-unit id="e852f115018d5807316e922246599c080b0e9503" translate="yes" xml:space="preserve">
          <source>#1300: Redux is great but major feature is missing</source>
          <target state="translated">#1300:Reduxは素晴らしいが、主要な機能が不足している</target>
        </trans-unit>
        <trans-unit id="679eeec344129ad16e78231797b18b81de9a1726" translate="yes" xml:space="preserve">
          <source>#1303: Redux Performance with Large Store and frequent updates</source>
          <target state="translated">#1303:大規模ストアと頻繁なアップデートによるReduxのパフォーマンス</target>
        </trans-unit>
        <trans-unit id="e40ad0efcf8cdfb74359b9dcaaf30ad0e5d65061" translate="yes" xml:space="preserve">
          <source>#1346: Is it bad practice to just have a 'stores' directory?</source>
          <target state="translated">#1346:ストア」ディレクトリだけを持つのは悪いことなのでしょうか?</target>
        </trans-unit>
        <trans-unit id="076aa3253e92bf9223eb24af002f0bbe44e75f44" translate="yes" xml:space="preserve">
          <source>#1385: What are the disadvantages of storing all your state in a single immutable atom?</source>
          <target state="translated">#1385:自分の全ての状態を一つの不変原子に格納することのデメリットは何ですか?</target>
        </trans-unit>
        <trans-unit id="fd76865437e3ee0e6eaa04e445cee157feda0101" translate="yes" xml:space="preserve">
          <source>#1390: Component Loading</source>
          <target state="translated">#1390:コンポーネントの読み込み</target>
        </trans-unit>
        <trans-unit id="926fcdba9fb2889fc5ab58719f3a2fe43b8cefa6" translate="yes" xml:space="preserve">
          <source>#1400: Is passing top-level state object to branch reducer an anti-pattern?</source>
          <target state="translated">#1400:トップレベルのステートオブジェクトをブランチレデューサに渡すのはアンチパターン?</target>
        </trans-unit>
        <trans-unit id="aec86494988d387006d280e6de7e36c662cc84df" translate="yes" xml:space="preserve">
          <source>#1407: Just sharing a great base class</source>
          <target state="translated">#1407位:ただただ素晴らしいベースクラスを共有する</target>
        </trans-unit>
        <trans-unit id="e34f2137559dfc202961ddb79fca5d33772da57e" translate="yes" xml:space="preserve">
          <source>#159: Investigate using Redux for pseudo-local component state</source>
          <target state="translated">#159:コンポーネントの状態を擬似的にローカルにするためのReduxの使用を検討する</target>
        </trans-unit>
        <trans-unit id="533d7a7280b4ebb1710db8562d8d14ac793fb437" translate="yes" xml:space="preserve">
          <source>#1751: Performance issues with large collections</source>
          <target state="translated">#1751:大規模なコレクションでのパフォーマンスの問題</target>
        </trans-unit>
        <trans-unit id="6f36989dd4b17b3997aaf72ac822de75218cc1ba" translate="yes" xml:space="preserve">
          <source>#1793: React Elements in Redux State</source>
          <target state="translated">#1793:React要素をRedux状態にする</target>
        </trans-unit>
        <trans-unit id="e0ded754edd99b8eb3c5dbc5f56be7e245c5cfff" translate="yes" xml:space="preserve">
          <source>#1813: Use a loop to support dispatching arrays</source>
          <target state="translated">#1813:配列のディスパッチをサポートするためにループを使用する</target>
        </trans-unit>
        <trans-unit id="6cbd9dbf9bd45f23169fcf1b9cac28e3ed46577e" translate="yes" xml:space="preserve">
          <source>#1816: Component connected to state with &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">＃1816： &lt;code&gt;mapStateToProps&lt;/code&gt; で状態に接続されたコンポーネント</target>
        </trans-unit>
        <trans-unit id="1f4db3c5c28aaed5936c26bc809377a941220207" translate="yes" xml:space="preserve">
          <source>#1824: Normalising state and garbage collection</source>
          <target state="translated">#1824:状態の正規化とガベージコレクション</target>
        </trans-unit>
        <trans-unit id="a295c20bf7be400de7f0b760d0ab71f013297048" translate="yes" xml:space="preserve">
          <source>#1948: Is getMappedItems an anti-pattern in mapStateToProps?</source>
          <target state="translated">#1948:getMappedItems は mapStateToProps のアンチパターンですか?</target>
        </trans-unit>
        <trans-unit id="bd83ae1e93d8c72cc8d0d72bed074df91fdb5711" translate="yes" xml:space="preserve">
          <source>#291: Trying to put API calls in the right place</source>
          <target state="translated">#291:APIコールを適切な場所に配置しようとする</target>
        </trans-unit>
        <trans-unit id="13e0c71a2076886c367dfe6a54f48c62f34d629f" translate="yes" xml:space="preserve">
          <source>#300: Potential connect() optimization</source>
          <target state="translated">#300:connect()の最適化の可能性</target>
        </trans-unit>
        <trans-unit id="5cca150f0353618d865ab736549a024eaf25e9b6" translate="yes" xml:space="preserve">
          <source>#303: subscribe API with state as an argument</source>
          <target state="translated">#303:ステートを引数に持つ subscribe API</target>
        </trans-unit>
        <trans-unit id="347d6847f32071d342aaec6151006d6975576724" translate="yes" xml:space="preserve">
          <source>#310: Who uses Redux?</source>
          <target state="translated">#310:Reduxを使っている人は?</target>
        </trans-unit>
        <trans-unit id="7a857746379c5bd1fd15069f90a6730fd9d8c03f" translate="yes" xml:space="preserve">
          <source>#316: How to create nested reducers?</source>
          <target state="translated">#316:入れ子になったレデューサーを作成するには?</target>
        </trans-unit>
        <trans-unit id="241aa7e523baa3daf169c16235be0831a07cca24" translate="yes" xml:space="preserve">
          <source>#384: Recommend that Action constants be named in the past tense</source>
          <target state="translated">#384:アクション定数の名前を過去形にすることを勧める</target>
        </trans-unit>
        <trans-unit id="1b1eee56ce67b7a61408324df972292a71042952" translate="yes" xml:space="preserve">
          <source>#419: Recommended usage of connect</source>
          <target state="translated">#419位:connectのおすすめの使い方</target>
        </trans-unit>
        <trans-unit id="2935aef53d71adace83e50c33214eaca426a95e9" translate="yes" xml:space="preserve">
          <source>#454: Handling big states in reducer</source>
          <target state="translated">#第454回:レデューサでの大きな状態の処理</target>
        </trans-unit>
        <trans-unit id="b0699a6d49cd70e922b35198761a2a07c83e5a3d" translate="yes" xml:space="preserve">
          <source>#455: Modeling side effects</source>
          <target state="translated">#455位:モデリングの副作用</target>
        </trans-unit>
        <trans-unit id="772964529153c4d154180791f6cbd68a862db7bc" translate="yes" xml:space="preserve">
          <source>#533: Simpler introduction to async action creators</source>
          <target state="translated">#第533回:非同期アクション作成者へのシンプルなイントロダクション</target>
        </trans-unit>
        <trans-unit id="ebec8f05fa20d12e79e8cd586923a111d387212c" translate="yes" xml:space="preserve">
          <source>#542: Idea: batching actions</source>
          <target state="translated">#第542回:アイデア:アクションのバッチ処理</target>
        </trans-unit>
        <trans-unit id="83c9c3ac3d68aab87e326de2f2c865ef2276a101" translate="yes" xml:space="preserve">
          <source>#569: Proposal: API for explicit side effects</source>
          <target state="translated">#569:提案。明示的な副作用のためのAPI</target>
        </trans-unit>
        <trans-unit id="d9d6fe14a99ccdaf8dc393654376b48c92963a25" translate="yes" xml:space="preserve">
          <source>#580: Is it possible to get action and state in store.subscribe?</source>
          <target state="translated">#580:store.subscribeでアクションとステートを取得することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="cd9c0a060e7d71bfba68ba623da0d23c2d2537f5" translate="yes" xml:space="preserve">
          <source>#597: Valid to dispatch multiple actions from an event handler?</source>
          <target state="translated">#597:イベントハンドラから複数のアクションをディスパッチするのは有効か?</target>
        </trans-unit>
        <trans-unit id="995165a4900367cea544bc6a5f22ed8ee0144461" translate="yes" xml:space="preserve">
          <source>#601: A concern on combineReducers, when an action is related to multiple reducers</source>
          <target state="translated">#601:アクションが複数のレデューサに関連している場合のcombineReducersでの懸念事項</target>
        </trans-unit>
        <trans-unit id="c91700ab890c5f08a2647bb350f68184b32a47f9" translate="yes" xml:space="preserve">
          <source>#628: Solution for simple action creation with less boilerplate</source>
          <target state="translated">#628位:ボイラープレートの少ないシンプルなアクション作成のためのソリューション</target>
        </trans-unit>
        <trans-unit id="be6cef416c1c4ce452dcbd4fff0470556c4b9881" translate="yes" xml:space="preserve">
          <source>#756: container vs component?</source>
          <target state="translated">#756位:コンテナ vs コンポーネント?</target>
        </trans-unit>
        <trans-unit id="21340ba20a259634064d57cf626624fa2d15391a" translate="yes" xml:space="preserve">
          <source>#758: Why can't state be mutated?</source>
          <target state="translated">#758位:なぜ状態が突然変異してはいけないのか?</target>
        </trans-unit>
        <trans-unit id="69c184b8b56c254a2d2a7ccf4adc774a774fe33d" translate="yes" xml:space="preserve">
          <source>#815: Working with Data Structures</source>
          <target state="translated">#815:データ構造体を使った作業</target>
        </trans-unit>
        <trans-unit id="44ded1489a6f088808483a04ff55a1208ffe9541" translate="yes" xml:space="preserve">
          <source>#839: Emphasize defining selectors alongside reducers</source>
          <target state="translated">#839:セレクタをレデューサと一緒に定義することを強調する</target>
        </trans-unit>
        <trans-unit id="20452e871be0ef029dee99c519ace41f4725804e" translate="yes" xml:space="preserve">
          <source>#883: take away the huge switch block</source>
          <target state="translated">#883位:巨大なスイッチブロックを奪う</target>
        </trans-unit>
        <trans-unit id="2f094ae5359226b707fd44e5f2a280f7467e4726" translate="yes" xml:space="preserve">
          <source>#911: Batching actions</source>
          <target state="translated">#911:バッチ処理</target>
        </trans-unit>
        <trans-unit id="a26f477aae1edf0347eb6f7ffa53f8db84ef966f" translate="yes" xml:space="preserve">
          <source>#912: Proposal: action filter utility</source>
          <target state="translated">#912:提案:アクションフィルタユーティリティ</target>
        </trans-unit>
        <trans-unit id="37e67540fe79d19b36724130f44d7607e8859b33" translate="yes" xml:space="preserve">
          <source>#922: Proposal: add subscribe to middleware API</source>
          <target state="translated">#922:提案:ミドルウェアAPIへのサブスクライブの追加</target>
        </trans-unit>
        <trans-unit id="5501fbbcf1d607aa36fc7ed852657153c5e12ddf" translate="yes" xml:space="preserve">
          <source>#943: Reducer querying</source>
          <target state="translated">#943:レジューサーの問い合わせ</target>
        </trans-unit>
        <trans-unit id="680e2a0ba15353fa00a6904ce08286dab08d5d1e" translate="yes" xml:space="preserve">
          <source>#946: Best way to update related state fields with split reducers?</source>
          <target state="translated">#946:スプリットレデューサーで関連するステートフィールドを更新する最良の方法は?</target>
        </trans-unit>
        <trans-unit id="578d4af46b83796b576f50939eeddbe2b86f09a5" translate="yes" xml:space="preserve">
          <source>#959: Multiple actions one dispatch?</source>
          <target state="translated">#959:1回の派遣で複数の行動?</target>
        </trans-unit>
        <trans-unit id="7d53170003985aba57c3cbb54042a1048dbe5904" translate="yes" xml:space="preserve">
          <source>#994: How to cut the boilerplate when updating nested entities?</source>
          <target state="translated">#第994回:ネストされたエンティティを更新する際のボイラープレートをカットするには?</target>
        </trans-unit>
        <trans-unit id="bf535818991eda0fe486afd20e7daa2d14518b95" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2017 Dan Abramov</source>
          <target state="translated">&amp;copy;2015&amp;ndash;2017 Dan Abramov</target>
        </trans-unit>
        <trans-unit id="ed6b7f639f884be7fcd9fb980e496b6c33d5d3e1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Come for the name hype. Stay for the rock solid fundamentals. (Thanks, and great job @dan_abramov and @eggheadio!)&amp;rdquo;</source>
          <target state="translated">「誇大広告のために来てください。堅実な基礎に留まります。（ありがとう、そして素晴らしい仕事@dan_abramovと@eggheadio！）」</target>
        </trans-unit>
        <trans-unit id="df384f33284e21430b07f18596d262ec19ba170f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Ducks&amp;rdquo;: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file</source>
          <target state="translated">「ダック」：ドメインスタイルに似ていますが、アクションとリデューサーを明示的に結び付けます。多くの場合、それらは同じファイルで定義します。</target>
        </trans-unit>
        <trans-unit id="5150dc5211c6d06fcaf7e065f841bb023696c70e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Great course on egghead.io by @dan_abramov - instead of just showing you how to use #redux, it also shows how and why redux was built!&amp;rdquo;</source>
          <target state="translated">「@dan_abramovによるegghead.ioの素晴らしいコース-#reduxの使用方法を示すだけでなく、reduxがどのように、そしてなぜ構築されたかを示します！</target>
        </trans-unit>
        <trans-unit id="0e3d7e088d7386301b6520d1c80203336070f21a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.&amp;rdquo;</source>
          <target state="translated">「FBの内部JSディスカッショングループでReduxについてコメントを求めましたが、それは広く賞賛されました。本当に素晴らしい仕事です。」</target>
        </trans-unit>
        <trans-unit id="805734d014075effe4c9f9a252eb9def2a6db8e5" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;It's cool that you are inventing a better Flux by not doing Flux at all.&amp;rdquo;</source>
          <target state="translated">「Fluxをまったく実行しないことで、より良いFluxを発明しているのは素晴らしいことです。」</target>
        </trans-unit>
        <trans-unit id="d3596109d016ac6d1e24cf6ef8b5eb8a444a3f3a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Love what you're doing with Redux&amp;rdquo;</source>
          <target state="translated">「あなたがReduxでやっていることを愛する」</target>
        </trans-unit>
        <trans-unit id="938ed1352f0e24ad85ff59d880eeac5332693aad" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Plowing through @dan_abramov 'Getting Started with Redux' - its amazing how much simpler concepts get with video.&amp;rdquo;</source>
          <target state="translated">「@dan_abramov 'Getting Started with Redux'を駆け抜け-驚くほどシンプルなコンセプトがビデオで実現します。」</target>
        </trans-unit>
        <trans-unit id="aa28d7323e70567c92735260eea7a08b3567882e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This series of videos on Redux by @dan_abramov is repeatedly blowing my mind - gunna do some serious refactoring&amp;rdquo;</source>
          <target state="translated">「@dan_abramovによるReduxのこの一連のビデオは繰り返し私の心を吹き飛ばしています-グンナはいくつかの深刻なリファクタリングを行います」</target>
        </trans-unit>
        <trans-unit id="9bbdab09b1bad7d1411229e6706b9074b9acbc26" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This video series on Redux by @dan_abramov on @eggheadio is spectacular!&amp;rdquo;</source>
          <target state="translated">「@eggheadioの@dan_abramovによるReduxのこのビデオシリーズは壮観です！」</target>
        </trans-unit>
        <trans-unit id="28f716d4a6d6d1dd6c2816b0a3468596f9af7981" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;store&quot;&gt;&lt;em&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;): An object that holds the complete state of your app. The only way to change its state is by &lt;a href=&quot;store#dispatch&quot;&gt;dispatching actions&lt;/a&gt;. You may also &lt;a href=&quot;store#subscribe&quot;&gt;subscribe&lt;/a&gt; to the changes to its state to update the UI.</source>
          <target state="translated">（&lt;a href=&quot;store&quot;&gt;&lt;em&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;）：アプリの完全な状態を保持するオブジェクト。状態を変更する唯一の方法は、&lt;a href=&quot;store#dispatch&quot;&gt;アクション&lt;/a&gt;をディスパッチすることです。状態の変更を&lt;a href=&quot;store#subscribe&quot;&gt;サブスクライブ&lt;/a&gt;して、UIを更新することもできます。</target>
        </trans-unit>
        <trans-unit id="ecee604ad68b289f8d3c800340d2c2c4d94ec4db" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as &lt;code&gt;actionCreators&lt;/code&gt;, the return value will also be a single function.</source>
          <target state="translated">（&lt;em&gt;関数&lt;/em&gt;または&lt;em&gt;オブジェクト&lt;/em&gt;）：元のオブジェクトを模倣したオブジェクトですが、各関数は対応するアクション作成者から返されたアクションをすぐにディスパッチします。関数を &lt;code&gt;actionCreators&lt;/code&gt; として渡した場合、戻り値も単一の関数になります。</target>
        </trans-unit>
        <trans-unit id="0fb3da3936f993327ba39a8dd43015351fe83823" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;) A store enhancer that applies the given middleware. The store enhancer signature is &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; but the easiest way to apply it is to pass it to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; as the last &lt;code&gt;enhancer&lt;/code&gt; argument.</source>
          <target state="translated">（&lt;em&gt;機能&lt;/em&gt;）指定されたミドルウェアを適用するストアエンハンサー。ストアエンハンサーの署名は &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; が、それを適用する最も簡単な方法は、それを&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;に最後の &lt;code&gt;enhancer&lt;/code&gt; 引数として渡すことです。</target>
        </trans-unit>
        <trans-unit id="7f6b6bfc4538002cddbd1fd5e4e370dff6c9c1be" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A function that unsubscribes the change listener.</source>
          <target state="translated">（&lt;em&gt;関数&lt;/em&gt;）：変更リスナーの登録を解除する関数。</target>
        </trans-unit>
        <trans-unit id="e6c10b5a4481c57b2d2f9edfc1c63be79f798472" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A reducer that invokes every reducer inside the &lt;code&gt;reducers&lt;/code&gt; object, and constructs a state object with the same shape.</source>
          <target state="translated">（&lt;em&gt;関数&lt;/em&gt;）： &lt;code&gt;reducers&lt;/code&gt; オブジェクト内のすべてのレデューサーを呼び出し、同じ形状の状態オブジェクトを構築するレデューサー。</target>
        </trans-unit>
        <trans-unit id="389d55a260500f16717ac0d3a94350b27cba66e0" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): The final function obtained by composing the given functions from right to left.</source>
          <target state="translated">（&lt;em&gt;関数&lt;/em&gt;）：与えられた関数を右から左に合成して得られる最終的な関数。</target>
        </trans-unit>
        <trans-unit id="b6cbf2c01213c134b40ec8c3596771ac0fe718c7" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;arguments&lt;/em&gt;): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</source>
          <target state="translated">（&lt;em&gt;引数&lt;/em&gt;）：作成する関数。各関数は、単一のパラメーターを受け入れることが期待されています。その戻り値は、左側にある関数への引数として提供されます。例外は、複数のパラメーターを受け入れることができる右端の引数です。これは、結果の合成関数の署名を提供するためです。</target>
        </trans-unit>
        <trans-unit id="5016311decd476dac1c440e0e52c02e0e3d85575" translate="yes" xml:space="preserve">
          <source>(Don't worry, &lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux creators&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;approve of it&lt;/a&gt;, if that's all you wanted to know.)</source>
          <target state="translated">（心配しないでください&lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;。Fluxの作成者&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;は、それが&lt;/a&gt;あなたが知りたかったすべての場合にそれを承認します。）</target>
        </trans-unit>
        <trans-unit id="d324236cbf7b2c5b411e6901ceaf0426c57a961e" translate="yes" xml:space="preserve">
          <source>(If you're looking for a WordPress framework, check out &lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework&lt;/a&gt;.)</source>
          <target state="translated">（WordPressフレームワークを探している場合は、&lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Frameworkを&lt;/a&gt;チェックしてください。）</target>
        </trans-unit>
        <trans-unit id="edae0b5981e0002b30818364c8a1389176fcb0ee" translate="yes" xml:space="preserve">
          <source>(Object&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): The dispatched action (see notes).</source>
          <target state="translated">（オブジェクト&lt;sup&gt;&amp;dagger;&lt;/sup&gt;）：ディスパッチされたアクション（注を参照）。</target>
        </trans-unit>
        <trans-unit id="b0be13084aba8adc3d7b205aaf4e927e25fa0408" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#middleware&quot;&gt;Middleware&lt;/a&gt; wraps the base dispatch function. It allows the dispatch function to handle &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; in addition to actions. Middleware may transform, delay, ignore, or otherwise interpret actions or async actions before passing them to the next middleware. See below for more information.</source>
          <target state="translated">&lt;a href=&quot;#middleware&quot;&gt;ミドルウェア&lt;/a&gt;は、基本ディスパッチ機能をラップします。これにより、ディスパッチ関数は&lt;a href=&quot;#async-action&quot;&gt;アクション&lt;/a&gt;に加えて非同期アクションを処理できます。ミドルウェアは、アクションまたは非同期アクションを次のミドルウェアに渡す前に、変換、遅延、無視、またはその他の方法で解釈する場合があります。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="107b3ce80a3c02523b93e5b4d695a60fd20c2f63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#middleware&quot;&gt;Middleware&lt;/a&gt; lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</source>
          <target state="translated">&lt;a href=&quot;../glossary#middleware&quot;&gt;ミドルウェアを&lt;/a&gt;使用すると、ディスパッチされる前にすべてのアクションオブジェクトを解釈するカスタムロジックを挿入できます。非同期アクションは、ミドルウェアの最も一般的な使用例です。</target>
        </trans-unit>
        <trans-unit id="fd07de91063da45b75bbcacd8cd309f14a69d740" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#reducer&quot;&gt;Reducers&lt;/a&gt; capture &amp;ldquo;the essence&amp;rdquo; of Flux Stores, so it's possible to gradually migrate an existing Flux project towards Redux, whether you are using &lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;, &lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;traditional Flux&lt;/a&gt;, or any other Flux library.</source>
          <target state="translated">&lt;a href=&quot;../glossary#reducer&quot;&gt;レデューサー&lt;/a&gt;はFluxストアの「本質」を捉えるため、&lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;、&lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;、&lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;従来のFlux&lt;/a&gt;、またはその他のFluxライブラリのいずれを使用していても、既存のFluxプロジェクトをReduxに徐々に移行することができます。</target>
        </trans-unit>
        <trans-unit id="2bb64b4bed7a97c418523d4ffdb6288fb015adc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt; describe the fact that &lt;em&gt;something happened&lt;/em&gt;, but don't specify how the application's state changes in response. This is the job of reducers.</source>
          <target state="translated">&lt;a href=&quot;actions&quot;&gt;アクション&lt;/a&gt;は、&lt;em&gt;何かが発生し&lt;/em&gt;たという事実を記述しますが、アプリケーションの状態が応答でどのように変化するかを指定しません。これが減速機の仕事です。</target>
        </trans-unit>
        <trans-unit id="a8dfe31e2797d17be898c68c93f8a46cba6d9313" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;Async action creators&lt;/a&gt; such as &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; have access to the entire state through &lt;code&gt;getState()&lt;/code&gt;. An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.</source>
          <target state="translated">&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;などの非同期アクションの作成者は、 &lt;code&gt;getState()&lt;/code&gt; を通じて状態全体にアクセスできます。アクション作成者は状態から追加のデータを取得してアクションに入れることができるため、各レデューサーは自身の状態スライスを更新するのに十分な情報を持っています。</target>
        </trans-unit>
        <trans-unit id="3b5742965a8a7e105526f64e826619bea7901c44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; is the base dispatch function described above.</source>
          <target state="translated">&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;は、上記の基本的なディスパッチ関数です。</target>
        </trans-unit>
        <trans-unit id="a233ff3ae6a630832e9d6e12074eca1e882d9857" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; returns the current state of the store.</source>
          <target state="translated">&lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;は、ストアの現在の状態を返します。</target>
        </trans-unit>
        <trans-unit id="dc71ff1690cdf43dbe0920fa906f24d0396f18eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#replaceReducer&quot;&gt;&lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt;&lt;/a&gt; can be used to implement hot reloading and code splitting. Most likely you won't use it.</source>
          <target state="translated">&lt;a href=&quot;api/store#replaceReducer&quot;&gt; &lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt; &lt;/a&gt;を使用して、ホットリロードとコード分割を実装できます。おそらくあなたはそれを使わないでしょう。</target>
        </trans-unit>
        <trans-unit id="3233aa220cb3c100f9d6ac87a89259afc4cae6e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt; registers a function to be called on state changes.</source>
          <target state="translated">&lt;a href=&quot;api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;は、状態変更時に呼び出される関数を登録します。</target>
        </trans-unit>
        <trans-unit id="67aa063cda369295b907b7e537689d94e06b2f62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;examples&quot;&gt;Official Examples&lt;/a&gt; &amp;mdash; A few official examples covering different Redux techniques</source>
          <target state="translated">&lt;a href=&quot;examples&quot;&gt;公式の例&lt;/a&gt; &amp;mdash;さまざまなReduxテクニックをカバーするいくつかの公式の例</target>
        </trans-unit>
        <trans-unit id="2181ce81664ba928672afb23b8a32ab80e213e8a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;: Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;：EnzymeはReactのJavaScriptテストユーティリティであり、Reactコンポーネントの出力のアサート、操作、およびトラバースを容易にします。</target>
        </trans-unit>
        <trans-unit id="326058ae349999870d6aced66c0de2b764c93797" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow rendering&lt;/a&gt;: Shallow rendering lets you instantiate a component and effectively get the result of its &lt;code&gt;render&lt;/code&gt; method just a single level deep instead of rendering components recursively to a DOM. Shallow rendering is useful for unit tests, where you test a particular component only, and importantly not its children. This also means that changing a child component won't affect the tests for the parent component. Testing a component and all its children can be accomplished with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme's &lt;code&gt;mount()&lt;/code&gt; method&lt;/a&gt;, aka full DOM rendering.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;浅いレンダリング&lt;/a&gt;：浅いレンダリングでは、コンポーネントをインスタンス化し、コンポーネントをDOMに再帰的にレンダリングするのではなく、1レベル下のレベルで &lt;code&gt;render&lt;/code&gt; メソッドの結果を効果的に取得できます。浅いレンダリングは、特定のコンポーネントのみをテストし、重要なことにその子をテストしない単体テストに役立ちます。これは、子コンポーネントを変更しても、親コンポーネントのテストには影響しないことも意味します。コンポーネントとそのすべての子のテストは、&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzymeの &lt;code&gt;mount()&lt;/code&gt; メソッド&lt;/a&gt;（別名、完全なDOMレンダリング）を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="61241f2e9ceb67ae4dfccf7cc9ca1f400093495e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文档&lt;/a&gt; &amp;mdash; Chinese</source>
          <target state="translated">&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文庫&lt;/a&gt; -中国語</target>
        </trans-unit>
        <trans-unit id="77565bb24c563c6df104040d230310edcfb00145" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; is a functional programming language inspired by Haskell and created by &lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;. It enforces &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;a &amp;ldquo;model view update&amp;rdquo; architecture&lt;/a&gt;, where the update has the following signature: &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt;. Elm &amp;ldquo;updaters&amp;rdquo; serve the same purpose as reducers in Redux.</source>
          <target state="translated">&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt;は、Haskellに触発され、&lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;によって作成された関数型プログラミング言語です。これは強制&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;「モデルビュー更新」アーキテクチャ&lt;/a&gt;：更新は、次のシグネチャを有し、 &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt; 。Elmの「アップデーター」は、Reduxのレデューサーと同じ目的を果たします。</target>
        </trans-unit>
        <trans-unit id="23d2c2107aca181c46e778f07e56614a8133b8c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux en Espa&amp;ntilde;ol&lt;/a&gt; - Spanish</source>
          <target state="translated">&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux enEspa&amp;ntilde;ol-&lt;/a&gt;スペイン語</target>
        </trans-unit>
        <trans-unit id="ff86a93740e76f0a9a588dfc7edd94627d0b6065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;: Test Utilities for React. Used by Enzyme.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;：Reactのテストユーティリティ。酵素によって使用されます。</target>
        </trans-unit>
        <trans-unit id="fa318edcedf300020034617867e41d3d7d461c6b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; An action logger with time travel UI, hot reloading and error handling for the reducers, &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;first demoed at React Europe&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;React Europe&lt;/a&gt;で最初にデモされた、タイムトラベルUI、ホットリロード、リデューサーのエラー処理を備えたアクションロガー</target>
        </trans-unit>
        <trans-unit id="8169d6309556697be51098425caaa8733bba177f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash; The easiest way to write async action creators</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash;非同期アクションクリエーターを作成する最も簡単な方法</target>
        </trans-unit>
        <trans-unit id="f27a8933220f7b51407b0697067eeebc832de481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;Turning the database inside-out&lt;/a&gt; for blowing my mind;</source>
          <target state="translated">&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;&lt;/a&gt;私の心を吹き飛ばすためにデータベースを裏返しにしています。</target>
        </trans-unit>
        <trans-unit id="32b2722ca06d7e3809116a97bf38d37832bcb0ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React: Hot Reloading and Time Travel&lt;/a&gt; &amp;mdash; See how constraints enforced by Redux make hot reloading with time travel easy</source>
          <target state="translated">&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React：ホットリロードとタイムトラベル&lt;/a&gt; &amp;mdash; Reduxによって強制される制約が、タイムトラベルによるホットリロードをどのように簡単にするかをご覧ください</target>
        </trans-unit>
        <trans-unit id="5bc316623c9deb9e9034f7d23637072db15a0f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; is a part of ES6, but is not implemented by most browsers yet. You'll need to either use a polyfill, a &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt;Babel plugin&lt;/a&gt;, or a helper from another library like &lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt;&lt;code&gt;_.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;はES6の一部ですが、ほとんどのブラウザではまだ実装されていません。ポリフィル、&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt;バベルプラグイン&lt;/a&gt;、または&lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt; &lt;code&gt;_.assign()&lt;/code&gt; &lt;/a&gt;などの別のライブラリのヘルパーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="32bee8f422e4c2ab236c312da17a9c38cac75683" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt; is a video course consisting of 30 videos narrated by Dan Abramov, author of Redux. It is designed to complement the &amp;ldquo;Basics&amp;rdquo; part of the docs while bringing additional insights about immutability, testing, Redux best practices, and using Redux with React. &lt;strong&gt;This course is free and will always be.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;は、Reduxの作者であるDan Abramovがナレーションした30本のビデオで構成されるビデオコースです。不変性、テスト、Reduxのベストプラクティス、およびReactでのReduxの使用に関する追加の洞察をもたらしながら、ドキュメントの「基本」の部分を補完するように設計されています。&lt;strong&gt;このコースは無料で、いつでも無料です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2950e131e272fe84d311faa920bbd6acbf06f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt; is a JavaScript library implementing persistent data structures. It is performant and has an idiomatic JavaScript API.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;不変&lt;/a&gt;は、永続的なデータ構造を実装するJavaScriptライブラリです。パフォーマンスが高く、慣用的なJavaScript APIを備えています。</target>
        </trans-unit>
        <trans-unit id="d5833afba76ada5ae020425be0bb3df43c4f7430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash; Optimistically apply actions that can be later committed or reverted</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash;後でコミットまたは元に戻すことができるアクションを最適に適用します</target>
        </trans-unit>
        <trans-unit id="246e34aae7982e56bc50e3cae1f0ce328818b50c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; is a superb way to manage the complexity of asynchronous apps. In fact &lt;a href=&quot;http://cycle.js.org&quot;&gt;there is an effort to create a library that models human-computer interaction as interdependent observables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;は、非同期アプリの複雑さを管理するための優れた方法です。実際&lt;a href=&quot;http://cycle.js.org&quot;&gt;、人間とコンピュータの相互作用を相互依存するオブザーバブルとしてモデル化するライブラリを作成する取り組みがあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc1628bafccfa550b14477fdcb8a2880af27d670" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt; is another popular library implementing immutable API for updating plain JavaScript objects. While you can use it with Redux, there is little benefit in using them together.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt;は、プレーンなJavaScriptオブジェクトを更新するための不変のAPIを実装するもう1つの人気のあるライブラリです。Reduxで使用することはできますが、それらを一緒に使用するメリットはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="ca68c66f6b4c6a980738b0b474b7797724c475ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; for teaching me to approach Flux without boilerplate or singletons;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummoxは&lt;/a&gt;、ボイラープレートやシングルトンなしでFluxにアプローチするように教えてくれました。</target>
        </trans-unit>
        <trans-unit id="462c24fee4dc0ea20edf2fb2bcab21199e928183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; &amp;mdash; A human-friendly standard for Flux action objects</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux標準アクション&lt;/a&gt; &amp;mdash; Fluxアクションオブジェクトの人に優しい標準</target>
        </trans-unit>
        <trans-unit id="d6681847f5ac1aebff1682d6668c0423aa44ef28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash; Reduces the boilerplate in writing reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash;レデューサーとアクションクリエーターを書く際の定型文を減らします</target>
        </trans-unit>
        <trans-unit id="e21d89989e6407db8130754d1c8cc4ea48c320c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;-compliant promise middleware</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;準拠のpromiseミドルウェア</target>
        </trans-unit>
        <trans-unit id="adc32c5ec0e57af144b709327c464173a6558f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Transducer utilities for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Reduxのトランスデューサーユーティリティ</target>
        </trans-unit>
        <trans-unit id="635f1546df5dc27cea670f0285cbf50019b2608f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools that lets you filter actions, inspect diffs, and pin deep paths in the state to observe their changes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; Redux DevToolsのカスタムモニター。アクションをフィルターし、diffを検査し、状態の深いパスをピン留めして、それらの変化を観察します。</target>
        </trans-unit>
        <trans-unit id="5392440f66a0b62817730b32d7e87386d20ed41e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; A SoundCloud client built with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; Reduxで構築されたSoundCloudクライアント</target>
        </trans-unit>
        <trans-unit id="671366abacb074ef67f4cf3094e172cad3c7de19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; A simple caching client for any GraphQL server and UI framework built on top of Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; Reduxの上に構築されたあらゆるGraphQLサーバーとUIフレームワーク用のシンプルなキャッシングクライアント</target>
        </trans-unit>
        <trans-unit id="9e948c295aecd2de19653c56dd37e6164bc205c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash; Mock redux store for testing your app</source>
          <target state="translated">&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash;アプリをテストするための模擬reduxストア</target>
        </trans-unit>
        <trans-unit id="7a572eea1e304e2b4d1765dc1dd8e7e6d040fb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;Filterable Log Monitor&lt;/a&gt; &amp;mdash; Filterable tree view monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;フィルター可能なログモニター&lt;/a&gt; &amp;mdash; Redux DevTools用のフィルター可能なツリービューモニター</target>
        </trans-unit>
        <trans-unit id="738b91de5b474d6632d5e4c6ca13f26cbbbfe538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;Slider Monitor&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools to replay recorded Redux actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;スライダーモニター&lt;/a&gt; &amp;mdash; Redux DevToolsが記録されたReduxアクションを再生するためのカスタムモニター</target>
        </trans-unit>
        <trans-unit id="a6b82050d15ff636cab86ab964babce485a0a59e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Composable Cerebral-style signals for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Reduxの構成可能な脳型信号</target>
        </trans-unit>
        <trans-unit id="c3cb45ad1ce1a52403984ab13791a016bacbef87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁體中文文件&lt;/a&gt; &amp;mdash; Traditional Chinese</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;&lt;/a&gt;繁體中文文 -繁体字中国語</target>
        </trans-unit>
        <trans-unit id="7237f437351893c36e43e30f1a66cf47ac72460d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Handle Redux async actions using Cycle.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Cycle.jsを使用してRedux非同期アクションを処理する</target>
        </trans-unit>
        <trans-unit id="4d850aef967058fa2b6d38c9b44bb6100d7ef473" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;Cycle&lt;/a&gt; for showing how often a function is the best tool;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;&lt;/a&gt;関数が最良のツールである頻度を示すためのサイクル。</target>
        </trans-unit>
        <trans-unit id="b646bb52b5ada7949ead74ceb015522a73c82f52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; Create forms easily in React with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; ReuxとのReactでフォームを簡単に作成する</target>
        </trans-unit>
        <trans-unit id="9b485a9343cd81ce214624d7ee75dd8b5f957f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Assertions for Redux actions testing</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Reduxアクションテストのアサーション</target>
        </trans-unit>
        <trans-unit id="33d0704f90d9fc9bec2f6289de5455def009259f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</target>
        </trans-unit>
        <trans-unit id="b7052bc5ca61cda06f2e818249aab92d0c11f8df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;Ducks: Redux Reducer Bundles&lt;/a&gt; &amp;mdash; A proposal for bundling reducers, action types and actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;アヒル：Reduxレデューサーバンドル&lt;/a&gt; &amp;mdash;レデューサー、アクションタイプ、アクションをバンドルするための提案</target>
        </trans-unit>
        <trans-unit id="5ad64f1b1acf59b7989610892266e94fa9a6e64b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Keep React form state in Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Reuxフォームの状態をReduxに保持する</target>
        </trans-unit>
        <trans-unit id="e0a49ddf7651bd6d746fee97f180340c5c22b41b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;The Elm Architecture&lt;/a&gt; for a great intro to modeling state updates with reducers;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;Elmアーキテクチャ&lt;/a&gt;は、レデューサーを使用した状態更新のモデリングの優れた入門用です。</target>
        </trans-unit>
        <trans-unit id="be4545fd7b6adf364efdbb91002ae394c5e58615" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; Efficient derived data selectors inspired by NuclearJS</source>
          <target state="translated">&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; NuclearJSから着想を得た効率的な派生データセレクター</target>
        </trans-unit>
        <trans-unit id="7708a46f9be2f564980d4e5bda78b4c5d35dc9de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt; for the pragmatic innovation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;反応&lt;/a&gt;実用的な技術革新のために。</target>
        </trans-unit>
        <trans-unit id="5a476b863690c612db3b916dce5198f075291ef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash; Log every Redux action and the next state</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash;すべてのReduxアクションと次の状態をログに記録します</target>
        </trans-unit>
        <trans-unit id="2168fa4ca440f276c71b288e63a7bd560f0d0edb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash; React</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash;反応</target>
        </trans-unit>
        <trans-unit id="49be928336c3ea70b586e1e0221f5209809256da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;Dock Monitor&lt;/a&gt; &amp;mdash; A resizable and movable dock for Redux DevTools monitors</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;ドックモニター&lt;/a&gt; &amp;mdash; Redux DevToolsモニター用のサイズ変更および移動可能なドック</target>
        </trans-unit>
        <trans-unit id="77e5d33e4cdf47037c30e1ca512f37cfeb999700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;Log Monitor&lt;/a&gt; &amp;mdash; The default monitor for Redux DevTools with a tree view</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;ログモニター&lt;/a&gt; &amp;mdash;ツリービューを備えたRedux DevToolsのデフォルトモニター</target>
        </trans-unit>
        <trans-unit id="c54d5349a1205ea2a9b173fd0057e9c134ab4d2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Thunk middleware&lt;/a&gt; isn't the only way to orchestrate asynchronous actions in Redux:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;サンクミドルウェア&lt;/a&gt;は、Reduxで非同期アクションを調整する唯一の方法ではありません。</target>
        </trans-unit>
        <trans-unit id="7a086cebb6f586cfe6a594cda767089a867b08af" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;Canonical Reducer Composition&lt;/a&gt; &amp;mdash; An opinionated standard for nested reducer composition</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;標準的なレデューサー構成&lt;/a&gt; &amp;mdash;入れ子になったレデューサー構成のための独断的な標準</target>
        </trans-unit>
        <trans-unit id="e745d89480c38f6937d9c622112c47d79aaa31e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; Used to create an equivalent function of Redux &lt;code&gt;combineReducers&lt;/code&gt; that works with &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; state.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;状態で動作するRedux &lt;code&gt;combineReducers&lt;/code&gt; と同等の関数を作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2c52fcd9623ac00993923a629ce837ba45e51c0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Immutable and type-checked state and actions for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Reduxの不変で型チェックされた状態とアクション</target>
        </trans-unit>
        <trans-unit id="af81282584d63bf8638d0e9e5cc4817051b43838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash; History transitions based on arbitrary actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash;任意のアクションに基づく履歴遷移</target>
        </trans-unit>
        <trans-unit id="4ec6e8ad705f1aceaf230c55020882fad996b178" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash; Warns about state mutations in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash;開発中の状態変異について警告します</target>
        </trans-unit>
        <trans-unit id="7905dff698bee7543c15da2228433d7b1d6a338f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;redial&lt;/a&gt; &amp;mdash; Universal data fetching and route lifecycle management for React that works great with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;redial&lt;/a&gt; &amp;mdash; Reduxとうまく機能するReactのユニバーサルデータフェッチおよびルートライフサイクル管理</target>
        </trans-unit>
        <trans-unit id="b9e9eaeab55b0c8cd498c9f208fca819c29ea328" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Analytics middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Redux用の分析ミドルウェア</target>
        </trans-unit>
        <trans-unit id="76bd67d8f88905517eed83dafa3047921d206f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt; is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt;は、React、Redux、ES6などの高品質な記事、チュートリアル、および関連コンテンツの精選されたリストです。</target>
        </trans-unit>
        <trans-unit id="7458fee6ef27b6ea44de14b58a088b3d484787c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; is a categorized collection of Redux-related libraries, addons, and utilities.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Reduxエコシステムリンク&lt;/a&gt;は、Redux関連のライブラリ、アドオン、ユーティリティの分類されたコレクションです。</target>
        </trans-unit>
        <trans-unit id="5c521f74e329344dfada627572d0439c5ce27980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash; A reducer enhancer to enable type-agnostic optimistic updates</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash;タイプにとらわれない楽観的な更新を可能にするリデューサーエンハンサー</target>
        </trans-unit>
        <trans-unit id="09a22d71db7bc4a31e59f65f17a1c4390b8be913" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; Create graffiti on your GitHub contributions wall</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; GitHub コントリビューションウォールに落書きを作成する</target>
        </trans-unit>
        <trans-unit id="fcdd90fbe1bce5cda821db0cbb40e37a05bb4838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; for popularizing the idea of a single state atom;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;&lt;/a&gt;単一の状態アトムのアイデアを普及させるためのOm ;</target>
        </trans-unit>
        <trans-unit id="126f6dcd5981219780c79f04dab128927a0c526e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash; Ignore redux actions by array or filter function</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash;配列またはフィルター関数によってreduxアクションを無視する</target>
        </trans-unit>
        <trans-unit id="522c27cd295aa2f0b11343353b70bfe170950f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash; Reset the redux state on certain actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash;特定のアクションでredux状態をリセットする</target>
        </trans-unit>
        <trans-unit id="6e04e334289a63c7eb319c457b7a701b7a18d175" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; Effortless undo/redo and action history for your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash;リデューサーのための簡単な元に戻す/やり直しとアクション履歴</target>
        </trans-unit>
        <trans-unit id="1b6afe4d71b345b389ea720ccf3e22bb58ff5fe1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;NuclearJS&lt;/a&gt; for proving this architecture can be performant;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;&lt;/a&gt;このアーキテクチャを証明するためのNuclearJSはパフォーマンスが高くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="55a0eceb1b164ebfa98d862358a8699dd0e2f1b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash; Normalize nested API responses for easier consumption by the reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash;入れ子になったAPI応答を正規化して、レデューサーによる消費を容易にします</target>
        </trans-unit>
        <trans-unit id="65f9399982e1960cfde9ce2d4776f97eff213665" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash; An opinionated library for making reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash;レデューサーとアクションクリエーターを作成するための独断的なライブラリ</target>
        </trans-unit>
        <trans-unit id="e142b1d7524dc9418bc9105b107102a2fd757747" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash; How to plug into React, one block at a time.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash;一度に1ブロックずつ、Reactに接続する方法。</target>
        </trans-unit>
        <trans-unit id="1a7170877b7e65113318685e20beab1c145c3d9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash; Sequence effects purely and naturally by returning them from your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash;レデューサーからエフェクトを返すことにより、エフェクトを純粋かつ自然にシーケンスします</target>
        </trans-unit>
        <trans-unit id="61e82f58dea0ceacdd0d73fa2c46474f99faa32f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;Redux in Russian&lt;/a&gt; &amp;mdash; Russian</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;ロシア語でRedux&lt;/a&gt; &amp;mdash;ロシア語</target>
        </trans-unit>
        <trans-unit id="911ae2c57d05e9d855f2f55ff67275735c340d15" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React bindings&lt;/a&gt; are not included in Redux by default. You need to install them explicitly:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;Reactバインディング&lt;/a&gt;は、デフォルトではReduxに含まれていません。それらを明示的にインストールする必要があります：</target>
        </trans-unit>
        <trans-unit id="668aa71ef061f4bf5fb388597bd4ba6608d4c54b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; Ruthlessly simple bindings to keep React Router and Redux in sync</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; ReactルーターとReduxの同期を維持するための容赦ないほど単純なバインディング</target>
        </trans-unit>
        <trans-unit id="27c27d0e05c340bb3f9aef884df7dc33cd70121a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; is a simple library for creating memoized, composable &lt;strong&gt;selector&lt;/strong&gt; functions. Reselect selectors can be used to efficiently compute derived data from the Redux store.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;は、メモ化された構成可能な&lt;strong&gt;セレクター&lt;/strong&gt;関数を作成するための単純なライブラリーです。Reselectセレクターを使用して、Reduxストアからの派生データを効率的に計算できます。</target>
        </trans-unit>
        <trans-unit id="7ba8f921a9c78cafaacaa6ee8c5f98b20c97a3b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; &amp;mdash; Backbone</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; &amp;mdash;バックボーン</target>
        </trans-unit>
        <trans-unit id="b77488ca5a784aa384877c247d815112efb36766" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash; RxJS middleware for action side effects using &quot;Epics&quot;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash;「Epics」を使用したアクションの副作用のためのRxJSミドルウェア</target>
        </trans-unit>
        <trans-unit id="828ba846080beeaf8593a911bc08a82eae111e4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Bootstrapping function for Redux applications</source>
          <target state="translated">&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Reduxアプリケーションのブートストラップ機能</target>
        </trans-unit>
        <trans-unit id="6b7feaf455447814c0b1409ee14b19a53959a4aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;Chart Monitor&lt;/a&gt; &amp;mdash; A chart monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;チャートモニター&lt;/a&gt; &amp;mdash; Redux DevToolsのチャートモニター</target>
        </trans-unit>
        <trans-unit id="60a2a8fab7f2253f7754f7fddd44616ca6818b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash; Utilize Generators for declarative yielding of side effects from your pure reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash;ジェネレーターを使用して、純粋なレデューサーからの副作用を宣言的に生成します</target>
        </trans-unit>
        <trans-unit id="7ff5b0a547b627bfa68c17e7844cedfb2ed89258" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; Store enhancers that synchronize Redux stores across Electron processes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; Electronプロセス全体でReduxストアを同期するストアエンハンサー</target>
        </trans-unit>
        <trans-unit id="ead5dd38514e378fce4086ebe8dd69902a5b98c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash; Warns about actions that produced no state changes in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash;開発で状態の変化を引き起こさなかったアクションについて警告します</target>
        </trans-unit>
        <trans-unit id="bf95415084cc2980fc6fc410238771c666d7e934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; Redux middleware for fetching data with axios HTTP client</source>
          <target state="translated">&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; axios HTTPクライアントでデータを取得するためのReduxミドルウェア</target>
        </trans-unit>
        <trans-unit id="488dc9a66e0ee669bd6c2836ade49d817496c75f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash; Customize batching and debouncing calls to the store subscribers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash;ストアサブスクライバーへの呼び出しのバッチ処理とデバウンスをカスタマイズします</target>
        </trans-unit>
        <trans-unit id="d62d13ae7d772ba57c13adb46a8d192d8b354469" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;disto&lt;/a&gt; for a proof of concept of hot reloadable Stores;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;&lt;/a&gt;ホットなリロード可能なストアの概念実証のためのdisto。</target>
        </trans-unit>
        <trans-unit id="912430794c537f9a04fb5544fe58c82ee48c26e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; - Ember.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; -Ember.js</target>
        </trans-unit>
        <trans-unit id="c2212eb90d319aca256b12839bd5d9dcd2540c5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; Automatically index resources in a web worker and search them without blocking</source>
          <target state="translated">&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; Webワーカーのリソースに自動的にインデックスを付け、ブロックせずに検索します</target>
        </trans-unit>
        <trans-unit id="3e82c33a3fc3f5c23b3991ac9deca81f6412a661" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; Deku</source>
          <target state="translated">&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; Deku</target>
        </trans-unit>
        <trans-unit id="99aa71b3cf414c2d077d231fe32a1a8b772e1744" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash; Dispatch several actions with a single subscriber notification</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash;単一のサブスクライバー通知で複数のアクションをディスパッチします</target>
        </trans-unit>
        <trans-unit id="8d1f69116287116136f16831edea2d4b75387cad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;polymer-redux&lt;/a&gt; - Polymer</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;&lt;/a&gt;Polymer -redux-ポリマー</target>
        </trans-unit>
        <trans-unit id="f9e8533e56143915a47d6d3230814c97d167fc30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash; Angular</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash;角度</target>
        </trans-unit>
        <trans-unit id="1adb84ec0d3fedd9d8140dcfd21cfdaba981e57e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</target>
        </trans-unit>
        <trans-unit id="dd42afd688fd3993d131ac58c470db0ca64d0ed6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Generator middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Redux用のジェネレーターミドルウェア</target>
        </trans-unit>
        <trans-unit id="cebbfc649b40e0fa8771d195a93b9007758c40f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diff Monitor&lt;/a&gt; &amp;mdash; A monitor for Redux Devtools that diffs the Redux store mutations between actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diffモニター&lt;/a&gt; &amp;mdash; Redux Devtoolsのモニターで、アクション間のReduxストアの変更を比較します</target>
        </trans-unit>
        <trans-unit id="884a589c3e5de51191487d1c59f1e5b7ee3a0166" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; is an extensive list of Redux-related repositories.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;は、Redux関連のリポジトリの広範なリストです。</target>
        </trans-unit>
        <trans-unit id="fce41d2fa6e7a2ae377463a862099fc7ee043817" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; An alternative side effect model for Redux apps</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; Reduxアプリの代替副作用モデル</target>
        </trans-unit>
        <trans-unit id="542f399508a2cf17f958319802f4280895a81ac0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools Extension&lt;/a&gt; &amp;mdash; A Chrome extension wrapping Redux DevTools and providing additional functionality</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools拡張機能&lt;/a&gt; &amp;mdash; Redux DevToolsをラップして追加機能を提供するChrome拡張機能</target>
        </trans-unit>
        <trans-unit id="bff1493331d9a72ee214aa8584a7e46f854bd6c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;Filter Actions&lt;/a&gt; &amp;mdash; Redux DevTools composable monitor with the ability to filter actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;フィルターアクション&lt;/a&gt; &amp;mdash; アクションをフィルターする機能を備えたRedux DevTools構成可能モニター</target>
        </trans-unit>
        <trans-unit id="610aadc45610fd3178ec1a4d0f1659f86c3a4382" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;Yes&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;no&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;はい&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;いいえ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="281d252a27e2a0e50333c0c16988433e3ea99926" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Webpack&lt;/a&gt; for Hot Module Replacement;</source>
          <target state="translated">&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;&lt;/a&gt;ホットモジュール交換用のWebpack。</target>
        </trans-unit>
        <trans-unit id="d362f1adc4636a71a99777bb9d42676751de79ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;How to Scale React Applications&lt;/a&gt; (accompanying talk: &lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;Scaling React Applications&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;Reactアプリケーションを&lt;/a&gt;&lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;スケーリングする&lt;/a&gt;方法（付随する講演：Reactアプリケーションのスケーリング）</target>
        </trans-unit>
        <trans-unit id="8f14c153057f3e5ff2c682e211890c3c01452d71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;Developing ClojureScript with Figwheel&lt;/a&gt; for convincing me that re-evaluation should &amp;ldquo;just work&amp;rdquo;;</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;Figwheelを使用&lt;/a&gt;してClojureScriptを開発し、再評価は「うまくいく」べきだと私に納得させました。</target>
        </trans-unit>
        <trans-unit id="06d62e70b9137a15eb36c4bfaf278d14decfd6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux: Simplifying Application State&lt;/a&gt; &amp;mdash; An intro to Redux architecture</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux：アプリケーション状態の簡素化&lt;/a&gt; &amp;mdash; Reduxアーキテクチャの紹介</target>
        </trans-unit>
        <trans-unit id="ad10d1cb466100f8a4ae95925886bfea9a5588ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;Cleaning the Tar: Using React within the Firefox Developer Tools&lt;/a&gt; &amp;mdash; Learn how to gradually migrate existing MVC applications to Redux</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;タールのクリーニング：Firefox開発ツール内でのReactの使用&lt;/a&gt; &amp;mdash;既存のMVCアプリケーションをReduxに徐々に移行する方法を学びます</target>
        </trans-unit>
        <trans-unit id="1b737ab7c1094f632e450d8432a9c9e16474bd23" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#async&quot;&gt;Async&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#async&quot;&gt;非同期&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="34453405ef6fc18e6e87655693ec2a2bb89f30b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter&quot;&gt;Counter&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter&quot;&gt;カウンター&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="42b547e4f69fe31aac6b4dafd6e1ff2c05b103e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;カウンターバニラ&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;ソース&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="59a364d666ad866f057b55528bf8003b6e7a3980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#real-world&quot;&gt;Real World&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#real-world&quot;&gt;実世界&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="96efe2982c4c1669ba1a120bc8297246cc6203f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;ショッピングカート&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8eca3dbaee744d35d31909fa899561a59637eca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="57e7c6464db15c19011138bab173c2e287d2a6fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos&quot;&gt;Todos&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos&quot;&gt;Todos&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1ed13dde4ab11bda58a26439a12403c10a6ca595" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;元に戻す&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;サンドボックス&lt;/a&gt;）によるTodo</target>
        </trans-unit>
        <trans-unit id="99bbfebce7fe9d012028712df4b3acc2554bdba1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;Tree View&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;ツリービュー&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;ソース&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;サンドボックス&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="87f056bfcb955f7740e3c0f64a948b832302b714" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#universal&quot;&gt;Universal&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#universal&quot;&gt;ユニバーサル&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;ソース&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7c38888890f5f4205fd2f24afd87133d7819484f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;patrons&quot;&gt;See the full list of Redux patrons.&lt;/a&gt;, as well as the always-growing list of &lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;people and companies that use Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;patrons&quot;&gt;Redux常連客の全リストを参照してください。&lt;/a&gt;、および常に増え続ける&lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;Reduxを使用している人々や企業の&lt;/a&gt;リスト。</target>
        </trans-unit>
        <trans-unit id="8e873131fc93496281859118adf805655ac8f12d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...middleware&lt;/code&gt; (&lt;em&gt;arguments&lt;/em&gt;): Functions that conform to the Redux &lt;em&gt;middleware API&lt;/em&gt;. Each middleware receives &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;store#getState&quot;&gt;&lt;code&gt;getState&lt;/code&gt;&lt;/a&gt; functions as named arguments, and returns a function. That function will be given the &lt;code&gt;next&lt;/code&gt; middleware's dispatch method, and is expected to return a function of &lt;code&gt;action&lt;/code&gt; calling &lt;code&gt;next(action)&lt;/code&gt; with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method as the &lt;code&gt;next&lt;/code&gt; parameter, thus ending the chain. So, the middleware signature is &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;...middleware&lt;/code&gt; （&lt;em&gt;引数&lt;/em&gt;）：Redux &lt;em&gt;ミドルウェアAPIに&lt;/em&gt;準拠する関数。各ミドルウェアは&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;store#getState&quot;&gt; &lt;code&gt;getState&lt;/code&gt; &lt;/a&gt;関数を名前付き引数として受け取り、関数を返します。その関数には、 &lt;code&gt;next&lt;/code&gt; ミドルウェアのdispatchメソッドが与えられ、潜在的に異なる引数で、または異なるときに、 &lt;code&gt;next(action)&lt;/code&gt; を呼び出す &lt;code&gt;action&lt;/code&gt; 関数を返すか、まったく呼び出さないことが予想されます。チェーンの最後のミドルウェアは、実際のストアの&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;メソッドを &lt;code&gt;next&lt;/code&gt; のように受け取ります。パラメータ、つまりチェーンを終了します。したがって、ミドルウェアの署名は &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a14c94077eedb0b2bbe472c3d6a0d0b3e627f008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;action&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable. Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; （&lt;em&gt;オブジェクト&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;）：アプリケーションにとって意味のある変更を説明するプレーンオブジェクト。アクションはデータをストアに取得する唯一の方法であるため、UIイベント、ネットワークコールバック、またはWebSocketsなどの他のソースからのデータは、最終的にアクションとしてディスパッチする必要があります。アクションには、実行されるアクションのタイプを示す &lt;code&gt;type&lt;/code&gt; フィールドが必要です。タイプは定数として定義でき、別のモジュールからインポートできます。文字列はシリアル化可能であるため、&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbol&lt;/a&gt;よりも &lt;code&gt;type&lt;/code&gt; は文字列を使用することをお勧めします。 &lt;code&gt;type&lt;/code&gt; 以外は、アクションオブジェクトの構造は実際にあなた次第です。興味があれば、&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Actionを&lt;/a&gt;チェックしてください。 アクションの構築方法に関する推奨事項。</target>
        </trans-unit>
        <trans-unit id="1f9170163c0ef5281c7dbedc853c03ad10d33e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;actionCreators&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;, or an object whose values are action creators.</source>
          <target state="translated">&lt;code&gt;actionCreators&lt;/code&gt; （&lt;em&gt;関数&lt;/em&gt;または&lt;em&gt;オブジェクト&lt;/em&gt;）：&lt;a href=&quot;../glossary#action-creator&quot;&gt;アクションクリエーター&lt;/a&gt;、または値がアクションクリエーターであるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="3bd26650aa014fa2c77d3b47529964816520f847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; iterates through each of these key/value pairs. For each iteration, it:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; は、これらの各キー/値ペアを反復処理します。各反復について、それは：</target>
        </trans-unit>
        <trans-unit id="c4c91341660edf136591696dc683b24608c892dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; makes working with this style of structure easier by taking a &lt;code&gt;reducers&lt;/code&gt; argument that&amp;rsquo;s defined as a hash table comprising a set of key/value pairs, where each key is the name of a state slice, and the corresponding value is the reducer function that will act on it.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; は、キーと値のペアのセットで構成されるハッシュテーブルとして定義された &lt;code&gt;reducers&lt;/code&gt; 引数を取ることで、このスタイルの構造での作業を容易にします。各キーは状態スライスの名前であり、対応する値はレデューサー関数です。それに基づいて行動します。</target>
        </trans-unit>
        <trans-unit id="4cb7dfb9552a2aace784e7bb958b5e547adeb025" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; takes an object full of slice reducer functions, and creates a function that outputs a corresponding state object with the same keys. This means that if no preloaded state is provided to &lt;code&gt;createStore&lt;/code&gt;, the naming of the keys in the input slice reducer object will define the naming of the keys in the output state object. The correlation between these names is not always apparent, especially when using ES6 features such as default module exports and object literal shorthands.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; は、スライスレデューサー関数でいっぱいのオブジェクトを取得し、同じキーを持つ対応する状態オブジェクトを出力する関数を作成します。これは、プリロード状態が &lt;code&gt;createStore&lt;/code&gt; に提供されていない場合、入力スライスレデューサーオブジェクトのキーの名前が出力状態オブジェクトのキーの名前を定義することを意味します。特にデフォルトのモジュールエクスポートやオブジェクトリテラルの省略形などのES6機能を使用する場合は、これらの名前の相関関係が常に明らかであるとは限りません。</target>
        </trans-unit>
        <trans-unit id="1afff2e083a32e71d2b99b63e31beee97a7bf5a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; will then return this new root state object to the store. The new object will have the same values as the current root state object, but because it's a different object, it will cause the store to be updated, which will ultimately cause all connected components to be re-rendered unnecessarily.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; は、この新しいルート状態オブジェクトをストアに返します。新しいオブジェクトは現在のルート状態オブジェクトと同じ値になりますが、別のオブジェクトであるため、ストアが更新され、最終的にすべての接続されたコンポーネントが不必要に再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="3d31c37d476a705be9d16ab99876f6f29a2911bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completed: boolean&lt;/code&gt; is whether todo should appear crossed out.</source>
          <target state="translated">&lt;code&gt;completed: boolean&lt;/code&gt; は、ToDoに取り消し線を引いて表示するかどうかです。</target>
        </trans-unit>
        <trans-unit id="f87ab9b4028e9a3e848f1e21390753d01e0de961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dispatch&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): A &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function available on the &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; （&lt;em&gt;関数&lt;/em&gt;）：&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;インスタンスで使用可能な&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;関数。</target>
        </trans-unit>
        <trans-unit id="a6065950184dca89f8adacb36f987e88b944855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter: string&lt;/code&gt; is the visibility filter it represents.</source>
          <target state="translated">&lt;code&gt;filter: string&lt;/code&gt; は、それが表す可視性フィルターです。</target>
        </trans-unit>
        <trans-unit id="9c642488e3cbd80e5e05acd841612af9ec636679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listener&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; inside this callback to read the current state tree. It is reasonable to expect that the store's reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</source>
          <target state="translated">&lt;code&gt;listener&lt;/code&gt; （&lt;em&gt;関数&lt;/em&gt;）：アクションがディスパッチされ、状態ツリーが変更されたときに呼び出されるコールバック。このコールバック内で&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; を&lt;/a&gt;呼び出して、現在の状態ツリーを読み取ることができます。ストアのレデューサーが純粋な関数であることを期待するのは理にかなっているので、状態ツリーの深いパスへの参照を比較して、値が変更されたかどうかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="60274854b8fc4c1adc45a0ccb85c9a471e84a06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; は、todoがクリックされたときに呼び出すコールバックです。</target>
        </trans-unit>
        <trans-unit id="3cabc66d0691eba5e97140d97c5af0c9e8160ca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when link is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; は、リンクがクリックされたときに呼び出すコールバックです。</target>
        </trans-unit>
        <trans-unit id="041c016fc6813b17f1192148484f830acd43af01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; は、todoがクリックされたときに呼び出すコールバックです。</target>
        </trans-unit>
        <trans-unit id="fbcbab3611a4b8e613b2b4cd09f9c1e9fb3baffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; property is an object with every param specified in the url. &lt;em&gt;e.g: &lt;code&gt;params&lt;/code&gt; will be equal to &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; if we are navigating to &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt;. We can now read the URL from &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; プロパティは、すべてのparamがURLで指定されたオブジェクトです。&lt;em&gt;例： &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt; に移動している場合、 &lt;code&gt;params&lt;/code&gt; は &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; と等しくなります。これで、 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; からURLを読み取ることができます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57c2d7b03d06140fe6460c00b3e6ecceb3671905" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; can be passed to &lt;code&gt;getVisibleTodos&lt;/code&gt; from &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; に渡すことができる &lt;code&gt;getVisibleTodos&lt;/code&gt; から &lt;code&gt;mapStateToProps&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="10c4b65f91bd45a4fc2fd57806ac6f36f1219c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; is available on npm . This guides assumes you are using &lt;code&gt;react-router@^2.7.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; はnpmで利用できます。このガイドでは、 &lt;code&gt;react-router@^2.7.0&lt;/code&gt; を使用していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="a1634dcd7c4b99901d4395c7f2e41abeb6383d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;) The next reducer for the store to use.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; （&lt;em&gt;Function&lt;/em&gt;）ストアが使用する次のレデューサー。</target>
        </trans-unit>
        <trans-unit id="7c54c07a7b5f3ced1e0ad2afedb5ec66a8340b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt;&lt;em&gt;(Function)&lt;/em&gt;: A &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; that returns the next &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt;, given the current state tree and an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; to handle.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; &lt;em&gt;（関数）&lt;/em&gt;：現在の状態ツリーと処理する&lt;a href=&quot;../glossary#action&quot;&gt;アクション&lt;/a&gt;を指定して、次の&lt;a href=&quot;../glossary#state&quot;&gt;状態ツリー&lt;/a&gt;を返す&lt;a href=&quot;../glossary#reducer&quot;&gt;削減関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d247728fbc49f91b9cff3325a75f4fc504af79e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducers&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</source>
          <target state="translated">&lt;code&gt;reducers&lt;/code&gt; （&lt;em&gt;Object&lt;/em&gt;）：組み合わせる必要のあるさまざまな還元関数に対応する値を持つオブジェクト。渡されたすべてのレデューサーが従う必要があるいくつかのルールについては、以下の注を参照してください。</target>
        </trans-unit>
        <trans-unit id="071297430dead4ef02608be9950bc0295007dab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text: string&lt;/code&gt; is the text to show.</source>
          <target state="translated">&lt;code&gt;text: string&lt;/code&gt; は表示するテキストです。</target>
        </trans-unit>
        <trans-unit id="6601fc4649e95805e9085e851baecfbd9ca422e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toJS()&lt;/code&gt; is an expensive function and negates the purpose of using Immutable.JS. Avoid its use.</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; は高価な関数であり、Immutable.JSを使用する目的を無効にします。その使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="dd5ee50dffe4060b939c67419ae23402ff2acb67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todos: Array&lt;/code&gt; is an array of todo items with &lt;code&gt;{ id, text, completed }&lt;/code&gt; shape.</source>
          <target state="translated">&lt;code&gt;todos: Array&lt;/code&gt; は、 &lt;code&gt;{ id, text, completed }&lt;/code&gt; 形状のtodoアイテムの配列です。</target>
        </trans-unit>
        <trans-unit id="52137cb27c8b0fda0f705acc5c2ab7d8fc83ac69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(any)&lt;/em&gt;: The current state tree of your application.</source>
          <target state="translated">&lt;em&gt;（任意）&lt;/em&gt;：アプリケーションの現在の状態ツリー。</target>
        </trans-unit>
        <trans-unit id="546eefda4ace04ce1c70ef03ebe11baee59caa52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;App state&lt;/em&gt;: data that is specific to the application's behavior (such as &quot;Todo #5 is currently selected&quot;, or &quot;there is a request in progress to fetch Todos&quot;)</source>
          <target state="translated">&lt;em&gt;アプリの状態&lt;/em&gt;：アプリケーションの動作に固有のデータ（「Todo＃5が現在選択されている」、「Todoを取得するためのリクエストが進行中」など）</target>
        </trans-unit>
        <trans-unit id="c8b84d5c7e9792f8e68b0e853bd33475fc3cf76b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do not put API calls into reducers.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;API呼び出しをレデューサーに入れないでください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b7c7ebbf9d9f5dafd8f0eb2d9dee6e376c7e325" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Domain data&lt;/em&gt;: data that the application needs to show, use, or modify (such as &quot;all of the Todos retrieved from the server&quot;)</source>
          <target state="translated">&lt;em&gt;ドメインデータ&lt;/em&gt;：アプリケーションが表示、使用、または変更する必要のあるデータ（「サーバーから取得したすべてのTodo」など）</target>
        </trans-unit>
        <trans-unit id="103bdb5aaf028813664904c0a9712c441ff4dc83" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In addition, using &lt;code&gt;toJS&lt;/code&gt; in a Higher Order Component should not cause much, if any, performance degradation, as the component will only be called when the connected component&amp;rsquo;s props change. As with any performance issue, conduct performance checks first before deciding what to optimise.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;さらに、高次コンポーネントで &lt;code&gt;toJS&lt;/code&gt; を使用しても、接続されたコンポーネントのプロパティが変更されたときにのみコンポーネントが呼び出されるため、パフォーマンスの低下はほとんどありません。パフォーマンスの問題と同様に、最適化するものを決定する前に、まずパフォーマンスチェックを実施します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29f56da89fe63f5b0fdf50e9b3857e6d4e807205" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Reducers whose initial state is populated using &lt;code&gt;preloadedState&lt;/code&gt; will &lt;strong&gt;still need to provide a default value&lt;/strong&gt; to handle when passed a &lt;code&gt;state&lt;/code&gt; of &lt;code&gt;undefined&lt;/code&gt;. All reducers are passed &lt;code&gt;undefined&lt;/code&gt; on initialization, so they should be written such that when given &lt;code&gt;undefined&lt;/code&gt;, some value should be returned. This can be any non-&lt;code&gt;undefined&lt;/code&gt; value; there's no need to duplicate the section of &lt;code&gt;preloadedState&lt;/code&gt; here as the default.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：preloadedStateを使用して初期状態が設定 &lt;code&gt;preloadedState&lt;/code&gt; ているリデューサーは、 &lt;code&gt;undefined&lt;/code&gt; の &lt;code&gt;state&lt;/code&gt; が渡されたときに処理&lt;strong&gt;するデフォルト値&lt;/strong&gt;を&lt;strong&gt;提供する必要があります&lt;/strong&gt;。すべての減速が渡される &lt;code&gt;undefined&lt;/code&gt; 彼らが与えられたときになるように記述する必要がありますので、初期化時に &lt;code&gt;undefined&lt;/code&gt; 、いくつかの値が返されるべきです。これは、 &lt;code&gt;undefined&lt;/code&gt; 任意の値にすることができます。ここで &lt;code&gt;preloadedState&lt;/code&gt; のセクションをデフォルトとして複製する必要はありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ccd8f599d654d3c1988dcb7203039733cc9621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if your app requires high performance, you may need to avoid &lt;code&gt;toJS()&lt;/code&gt; altogether, and so will have to use Immutable.JS in your dumb components. However, for most apps this will not be the case, and the benefits of keeping Immutable.JS out of your dumb components (maintainability, portability and easier testing) will far outweigh any perceived performance improvements of keeping it in.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：アプリで高いパフォーマンスが必要な場合は、 &lt;code&gt;toJS()&lt;/code&gt; を完全に回避する必要がある場合があるため、ダムコンポーネントでImmutable.JSを使用する必要があります。ただし、ほとんどのアプリではこれは当てはまりません。Immutable.JSをダムコンポーネントの外に置くことの利点（保守性、移植性、テストの容易さ）は、それを維持することで認識されるパフォーマンスの向上をはるかに上回ります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5abce7fc4fc891211f9c2137610c7e67cd852170" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;React Router Redux&lt;/em&gt; creates a binding between your redux app and react-router and it keeps them in sync. Without this binding, you will not be able to rewind the actions with Time Travel. Unless you need this, React Router and Redux can operate completely apart.</source>
          <target state="translated">&lt;em&gt;React Router Redux&lt;/em&gt;はreduxアプリとreact-routerの間にバインディングを作成し、それらを同期させます。このバインディングがないと、タイムトラベルでアクションを巻き戻すことができません。これが必要でない限り、React RouterとReduxは完全に分離して動作できます。</target>
        </trans-unit>
        <trans-unit id="db05ad144fe5ebf42ad286bef8f68f32d9f005f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Redux Router&lt;/em&gt; is an experimental library, it lets you keep entirely the state of your URL inside your redux store. It has the same API with React Router API but has a smaller community support than react-router.</source>
          <target state="translated">&lt;em&gt;Reduxルーター&lt;/em&gt;は実験的なライブラリであり、URLの状態をreduxストア内に完全に保持できます。React Router APIと同じAPIを備えていますが、react-routerよりもコミュニティのサポートが少ないです。</target>
        </trans-unit>
        <trans-unit id="f76be52041957c10fa3ece1ff9a6500b8a7f3130" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;State&lt;/em&gt; (also called the &lt;em&gt;state tree&lt;/em&gt;) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by &lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;. It represents the entire state of a Redux application, which is often a deeply nested object.</source>
          <target state="translated">&lt;em&gt;状態&lt;/em&gt;（&lt;em&gt;状態ツリー&lt;/em&gt;とも呼ばれる）は広義の用語ですが、Redux APIでは通常、ストアによって管理され、&lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;によって返される単一の状態値を指します。これは、多くの場合深くネストされたオブジェクトであるReduxアプリケーションの状態全体を表します。</target>
        </trans-unit>
        <trans-unit id="85e8d43be73f1edbce45221c84c8c093b0749d2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UI state&lt;/em&gt;: data that represents how the UI is currently displayed (such as &quot;The EditTodo modal dialog is currently open&quot;)</source>
          <target state="translated">&lt;em&gt;UI状態&lt;/em&gt;：UIの現在の表示方法を表すデータ（「EditTodoモーダルダイアログが現在開いている」など）</target>
        </trans-unit>
        <trans-unit id="3bf81a4c713219d00d15e705d738b32facd1c3ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9845432ee2811761e6bcff4526db436968becae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;Part 2: Building React Applications with Idiomatic Redux&lt;/a&gt; (27 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;パート2：Idiomatic Reduxを使用したReactアプリケーションの構築&lt;/a&gt;（27の無料ビデオ）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dfdd52a88d7f6ae78b01e354f352bfb2f0dff656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Learn the basics of Redux directly from its creator (30 free videos)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Redux入門&lt;/a&gt;&lt;/strong&gt; &amp;mdash;作成者から直接Reduxの基本を学ぶ（30の無料ビデオ）</target>
        </trans-unit>
        <trans-unit id="1235adb50ceb12211d0e304f950e2cb2539aca3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Part 1: Getting Started with Redux&lt;/a&gt; (30 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;パート1：Redux入門&lt;/a&gt;（30本の無料動画）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65008044925d251beee2e760bdbf7d352cad495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Learn Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Build a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Reduxを学ぶ&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Redux、React Router、およびReact.jsの背後にあるコアアイデアを簡素化するシンプルな写真アプリを作成します</target>
        </trans-unit>
        <trans-unit id="7f4ac2e2def8c3f5a536a05b0329a56f22f7adbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;You Might Not Need Redux&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;Reduxは必要ないかもしれません&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d385341a00466471baf6bf0402c35cb513b738" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;AddTodo&lt;/code&gt;&lt;/strong&gt; is an input field with an &amp;ldquo;Add&amp;rdquo; button</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;AddTodo&lt;/code&gt; &lt;/strong&gt;は、「追加」ボタンのある入力フィールドです。</target>
        </trans-unit>
        <trans-unit id="628abe199572c722710292d70c1925abc91676dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;App&lt;/code&gt;&lt;/strong&gt; is the root component that renders everything else.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;App&lt;/code&gt; &lt;/strong&gt;は、その他すべてをレンダリングするルートコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="0d7b3701bac16523885d284f75957faf7ea4389c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterLink&lt;/code&gt;&lt;/strong&gt; gets the current visibility filter and renders a &lt;code&gt;Link&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FilterLink&lt;/code&gt; &lt;/strong&gt;は現在の可視性フィルターを取得し、 &lt;code&gt;Link&lt;/code&gt; をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="a71acf6c031a4f24eed213eed02c5416da7ab1dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Footer&lt;/code&gt;&lt;/strong&gt; is where we let the user change currently visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Footer&lt;/code&gt; &lt;/strong&gt;は、ユーザーに現在表示されているタスクを変更させる場所です。</target>
        </trans-unit>
        <trans-unit id="5e4d8ed2a6c4ce299050d24a32e6f7c64862715e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/strong&gt; is a link with a callback.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/strong&gt;はコールバック付きの&lt;strong&gt;リンク&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="c81649898f991e4665328250d8eea26cc2edbc98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Todo&lt;/code&gt;&lt;/strong&gt; is a single todo item.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Todo&lt;/code&gt; &lt;/strong&gt;は単一のToDoアイテムです。</target>
        </trans-unit>
        <trans-unit id="e2f96f74e7301539bacf1f9c6bd718980a2d9daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;TodoList&lt;/code&gt;&lt;/strong&gt; is a list showing visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;TodoList&lt;/code&gt; &lt;/strong&gt;は、表示される&lt;strong&gt; ToDo&lt;/strong&gt;を示すリストです。</target>
        </trans-unit>
        <trans-unit id="72ec9d638aa6d81f7ef6d2682f120d0fd13ab2a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;VisibleTodoList&lt;/code&gt;&lt;/strong&gt; filters the todos according to the current visibility filter and renders a &lt;code&gt;TodoList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;VisibleTodoList&lt;/code&gt; &lt;/strong&gt;は、現在の可視性フィルターに従って&lt;strong&gt; todoを&lt;/strong&gt;フィルタリングし、 &lt;code&gt;TodoList&lt;/code&gt; をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="b7d0712239a704041ee112eaeba6a14ab513b61e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Using local component state is fine&lt;/em&gt;&lt;/strong&gt;. As a developer, it is &lt;em&gt;your&lt;/em&gt; job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ローカルコンポーネントの状態の使用は問題ありません&lt;/em&gt;&lt;/strong&gt;。開発者は、アプリケーションを構成する状態の種類と、各状態をどこに置くかを決定するのが&lt;em&gt;あなたの&lt;/em&gt;仕事です。あなたのために働くバランスを見つけて、それで行きます。</target>
        </trans-unit>
        <trans-unit id="5889d668f635907ed9dfa122cde5a199a20be785" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;case function&lt;/em&gt;&lt;/strong&gt;: a function that is being used to handle the update logic for a specific action. This may actually be a reducer function, or it may require other parameters to do its work properly.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ケース関数&lt;/em&gt;&lt;/strong&gt;：特定のアクションの更新ロジックを処理するために使用されている関数。これは実際にはリデューサー関数である場合もあれば、正しく機能するために他のパラメーターが必要な場合もあります。</target>
        </trans-unit>
        <trans-unit id="e6e0dfdc33c924359812aab966fcb011eaef8e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;higher-order reducer&lt;/em&gt;&lt;/strong&gt;: a function that takes a reducer function as an argument, and/or returns a new reducer function as a result (such as &lt;code&gt;combineReducers&lt;/code&gt;, or &lt;code&gt;redux-undo&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;高次レデューサー&lt;/em&gt;&lt;/strong&gt;：引数としてレデューサー関数を使用する関数、および/または結果として新しいリデューサー関数を返す関数（例えば、 &lt;code&gt;combineReducers&lt;/code&gt; 、 &lt;code&gt;redux-undo&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="401ed42d073adeb6ecd950168ad981e271a2b5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt;: any function with the signature &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; (ie, any function that &lt;em&gt;could&lt;/em&gt; be used as an argument to &lt;code&gt;Array.prototype.reduce&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt;：シグニチャー &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; 持つすべての関数 -&amp;gt; newState（つまり、 &lt;code&gt;Array.prototype.reduce&lt;/code&gt; の引数として使用&lt;em&gt;できる&lt;/em&gt;すべての関数）</target>
        </trans-unit>
        <trans-unit id="f9b0e566a3672de250a1434def164d63af6cba98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;root reducer&lt;/em&gt;&lt;/strong&gt;: the reducer function that is actually passed as the first argument to &lt;code&gt;createStore&lt;/code&gt;. This is the only part of the reducer logic that &lt;em&gt;must&lt;/em&gt; have the &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; signature.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ルートリデューサー&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;createStore&lt;/code&gt; の最初の引数として実際に渡されるリデューサー関数。これは、減速機ロジックの一部のみである&lt;em&gt;必要があります&lt;/em&gt;持っている &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; 署名。</target>
        </trans-unit>
        <trans-unit id="0a64e360c4d5878942159990e891828399749146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;slice reducer&lt;/em&gt;&lt;/strong&gt;: a reducer that is being used to handle updates to one specific slice of the state tree, usually done by passing it to &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;スライスレデューサー&lt;/em&gt;&lt;/strong&gt;：状態ツリーの特定の1つのスライスへの更新を処理するために使用されている&lt;strong&gt;&lt;em&gt;レデューサー&lt;/em&gt;&lt;/strong&gt;。通常、 &lt;code&gt;combineReducers&lt;/code&gt; 渡すことで行われます</target>
        </trans-unit>
        <trans-unit id="2551e86cf6417db6bf5798c49bdf5292397b5d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Action creators&lt;/strong&gt; are exactly that&amp;mdash;functions that create actions. It's easy to conflate the terms &amp;ldquo;action&amp;rdquo; and &amp;ldquo;action creator,&amp;rdquo; so do your best to use the proper term.</source>
          <target state="translated">&lt;strong&gt;アクションの作成者&lt;/strong&gt;は、まさにそれ、つまり&lt;strong&gt;アクション&lt;/strong&gt;を作成する関数です。「アクション」と「アクションクリエーター」という用語を混同するのは簡単なので、適切な用語を使用するように最善を尽くしてください。</target>
        </trans-unit>
        <trans-unit id="1da8e22fc9c738da2f9e48212ed18a6dba30b50c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d9668859b20c765c85260461deb4090e7c90c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt; are payloads of information that send data from your application to your store. They are the &lt;em&gt;only&lt;/em&gt; source of information for the store. You send them to the store using &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;アクション&lt;/strong&gt;は、アプリケーションからストアにデータを送信する情報のペイロードです。それらはストアの&lt;em&gt;唯一&lt;/em&gt;の情報源です。それらを&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt;を使用してストアに送信します。</target>
        </trans-unit>
        <trans-unit id="ec2a8e7b602c9f54e206267bc8541a8f186454fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also read:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;また読む：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39113b04f672edb3817c5d406408774e2e082af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request began.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;リクエストが開始されたことをレデューサーに通知するアクション。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="994001ceb8ce97cddf25a8c05987ea9c83e99a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request failed.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;リクエストが失敗したことをレデューサーに通知するアクション。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7648023b0f97bbd162694c4bb9ebb7f2898c3bca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request finished successfully.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;リクエストが正常に終了したことをレデューサーに通知するアクション。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d6bce9d1a24f59b9efaf18dc81a2290c580f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Articles&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Articles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e169e5d7d50b4c65d5eb45d17d2193a3d3fe48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But there is a problem!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;しかし問題がある！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69b54c7910d861b8a3eca842a30a66fd0932de39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chrome Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Chrome拡張機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cf8bc624de85df678b42470029fc4d69f07a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;コード構造&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3318cdef256aecde044aa8d93fc255bf75f49a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41fc516c487bc5c3b496e3bd45dc251647980f5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a56caeef5914fb0e23b98d65cf00abd25d9b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Documentation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Documentation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c28df48234b0e1020c84b073dd49644f35f59ab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally, you can write your own middleware.&lt;/strong&gt; Let's say you want to generalize the pattern above and describe your async action creators like this instead:</source>
          <target state="translated">&lt;strong&gt;最後に、独自のミドルウェアを作成できます。&lt;/strong&gt;上記のパターンを一般化し、代わりに次のような非同期アクションの作成者について説明するとします。</target>
        </trans-unit>
        <trans-unit id="e850b9ecbb25492de24c73963c25bba203a9b8f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;General&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a426959f751e24e2f5918ae148f99e35ec8ec248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Gists&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gists&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b835ddfaad1c3b1909f0f1f8838c00992cdebd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the &lt;code&gt;mapStateToProps&lt;/code&gt; argument supplied to &lt;code&gt;connect&lt;/code&gt; returns a function instead of an object, it will be used to create an individual &lt;code&gt;mapStateToProps&lt;/code&gt; function for each instance of the container.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;場合 &lt;code&gt;mapStateToProps&lt;/code&gt; 引数が供給 &lt;code&gt;connect&lt;/code&gt; オブジェクトの代わりに返す関数を、個々の作成に使用される &lt;code&gt;mapStateToProps&lt;/code&gt; が容器の各インスタンスのために機能します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3529f38f1732dd9f8dde4fa1c2954e730482cd3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immutable Data&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不変データ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f813b4dc0b9eb9217d5b61ec52b5ac9f1ef177d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In general, &lt;code&gt;preloadedState&lt;/code&gt; wins over the state specified by the reducer. This lets reducers specify initial data that makes sense &lt;em&gt;to them&lt;/em&gt; as default arguments, but also allows loading existing data (fully or partially) when you're hydrating the store from some persistent storage or the server.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一般に、 &lt;code&gt;preloadedState&lt;/code&gt; は、レデューサーによって指定された状態を優先します。これは、レデューサーは理にかなっている初期データを指定することができます&lt;em&gt;彼らに&lt;/em&gt;デフォルト引数として、だけでなく、あなたには、いくつかの永続ストレージやサーバーからのストアを水和しているときに（完全または部分的に）ロード既存のデータを可能にします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630d2928116ed006d43b0e103005e502467a2bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;主要な概念&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="177d318924b7fa70e3cefd19afe9a19a2e28bd31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;重要な概念&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="af40680dea48a4f1aadecc6d0a580f293be76302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learn Redux from its creator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;作成者からReduxを学ぶ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24d8f44e0ff187836ea30a46af3fa4eae82a5814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Libraries&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f69f52a2524079b625a242912cdd7403598e0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Middleware lets us write more expressive, potentially async action creators.&lt;/strong&gt; It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can &amp;ldquo;catch&amp;rdquo; dispatched Promises and turn them into a pair of request and success/failure actions.</source>
          <target state="translated">&lt;strong&gt;ミドルウェアを使用すると、より表現力があり、非同期の可能性があるアクションクリエーターを作成できます。&lt;/strong&gt;プレーンオブジェクト以外のものをディスパッチし、値を解釈します。たとえば、ミドルウェアはディスパッチされたPromiseを「キャッチ」して、要求と成功/失敗のアクションのペアに変換できます。</target>
        </trans-unit>
        <trans-unit id="8714d9061814fc6644471ebf65e80673c74fbf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Miscellaneous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Miscellaneous&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aba37422ce93d442e229cdf88aefd1289e7a0ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that each of these reducers is managing its own part of the global state. The &lt;code&gt;state&lt;/code&gt; parameter is different for every reducer, and corresponds to the part of the state it manages.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これらのレデューサーのそれぞれがグローバル状態の独自の部分を管理していることに注意してください。 &lt;code&gt;state&lt;/code&gt; パラメータは、すべての減速のために異なっており、それが管理状態の部分に相当します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="428baf6d60cd9f08dad452710b2d0853a0611819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this example is deliberately written in a verbose style in order to illustrate the concepts and the process of refactoring, rather than perfectly concise code.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：この例は、完全に簡潔なコードではなく、概念とリファクタリングのプロセスを説明するために、意図的に詳細スタイルで記述されています。</target>
        </trans-unit>
        <trans-unit id="5cbd86caa1de0f5ed851d50bc59d467e542c9b43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Organizing State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;組織状態&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5467c8d8afabc0b3e1dae4c2485529c53412f57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;React Redux&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a646a6010d9b1f0d5fd5b00988f7164e7d8f806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading List&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;読書リスト&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="f87ea91cacfbae403f6d54b8d0956ef3fc4100f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading list&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;読書リスト&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="026e47e10ea129bc5e718a865b1c71228f70d1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reducers&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="463c2d07ea9bf2ad77b66d873753301b6924a007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redux doesn't care &lt;em&gt;how&lt;/em&gt; you store the state&amp;mdash;it can be a plain object, an Immutable object, or anything else.&lt;/strong&gt; You'll probably want a (de)serialization mechanism for writing universal apps and hydrating their state from the server, but other than that, you can use any data storage library &lt;em&gt;as long as it supports immutability&lt;/em&gt;. For example, it doesn't make sense to use Backbone for Redux state, because Backbone models are mutable.</source>
          <target state="translated">&lt;strong&gt;Reduxは&lt;em&gt;どのように&lt;/em&gt;状態を保存する&lt;em&gt;か&lt;/em&gt;を気にしません&amp;mdash;プレーンオブジェクト、不変オブジェクト、またはその他の何でもかまいません。&lt;/strong&gt;おそらく、ユニバーサルアプリを作成し、その状態をサーバーからハイドレートするための（逆）シリアル化メカニズムが必要ですが、それ以外は、&lt;em&gt;不変性をサポートしている限り、&lt;/em&gt;任意のデータストレージライブラリ&lt;em&gt;を&lt;/em&gt;使用できます。たとえば、Backboneモデルは変更可能であるため、Reduxの状態にBackboneを使用しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f99c682875e5330991bcf2249db3e897d5de6b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Store Setup&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;店舗設定&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6adf27317bc0760c4fef5a11f3e4243d9c2dea6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt; of your whole application is stored in an object tree within a single &lt;a href=&quot;../glossary#store&quot;&gt;store&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプリケーション全体の&lt;a href=&quot;../glossary#state&quot;&gt;状態&lt;/a&gt;は、単一の&lt;a href=&quot;../glossary#store&quot;&gt;ストア&lt;/a&gt;内のオブジェクトツリーに格納されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4155b94bfe17bf25fe0157204c773ff981821e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store calls the reducer function you gave it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reduxストアは、指定したリデューサー関数を呼び出します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3830df7c81157ba8c707d873fd73f6f0cdb0f81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store saves the complete state tree returned by the root reducer.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reduxストアは、ルートリデューサーによって返された完全な状態ツリーを保存します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7aa48ecb73dff1c83c59ee1b15f802da34287b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only way to change the state is to emit an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt;, an object describing what happened.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;状態を変更する唯一の方法は、何が起こったかを説明するオブジェクトである&lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt;を発行することです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c9a991ab2ae928e8e00868d0eba489d79e40a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The root reducer may combine the output of multiple reducers into a single state tree.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ルートレデューサーは、複数のレデューサーの出力を単一の状態ツリーに結合できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e49059d9b4193d453aca3973e78f45f15c2c3d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is exactly what Redux middleware looks like.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これはまさにReduxミドルウェアがどのように見えるかです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76be9cf756727c3afc31669a1734af0a6b6997c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To specify how the state tree is transformed by actions, you write pure &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アクションによる状態ツリーの変換方法を指定するには、純粋な&lt;a href=&quot;../glossary#reducer&quot;&gt;レデューサー&lt;/a&gt;を記述します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef565370cf3245efa7f66d5b780fcb67eebf3a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using Immutable.JS with Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ReduxでのImmutable.JSの使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581be5c9a50c413f04d51268170098e3b7d44abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Video&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Video&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7086101439d0140de8af057ae87cdfb81255c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We don't mutate the &lt;code&gt;state&lt;/code&gt;.&lt;/strong&gt; We create a copy with &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; is also wrong: it will mutate the first argument. You &lt;strong&gt;must&lt;/strong&gt; supply an empty object as the first parameter. You can also enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; to write &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; は変更しません。&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; で&lt;/a&gt;コピーを作成します。 &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; も間違っています。最初の引数が変更されます。空のオブジェクトを最初のパラメーターとして指定する&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;オブジェクト展開演算子の提案&lt;/a&gt;を有効にして、代わりに &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; を書き込むこともできます。</target>
        </trans-unit>
        <trans-unit id="3ee5f2fe633882a55b56c42023653a1999e34048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We return the previous &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;default&lt;/code&gt; case.&lt;/strong&gt; It's important to return the previous &lt;code&gt;state&lt;/code&gt; for any unknown action.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;default&lt;/code&gt; ケースでは、以前の &lt;code&gt;state&lt;/code&gt; を返します。&lt;/strong&gt;不明なアクションについては、以前の &lt;code&gt;state&lt;/code&gt; に戻すことが重要です。</target>
        </trans-unit>
        <trans-unit id="e435f9e093dd6f82c9230b9232861cf3d23f3321" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You call&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; を&lt;/a&gt;&lt;strong&gt;呼び出します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3f4e7a77e49b844e6d09e31eed53faed808efc94" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&amp;dagger;&lt;/sup&gt; The &amp;ldquo;vanilla&amp;rdquo; store implementation you get by calling &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; only supports plain object actions and hands them immediately to the reducer.</source>
          <target state="translated">&lt;sup&gt;&amp;dagger; &lt;/sup&gt;&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;を呼び出すことで得られる「バニラ」ストア実装は、プレーンオブジェクトアクションのみをサポートし、それらをただちにリデューサーに渡します。</target>
        </trans-unit>
        <trans-unit id="70c279ff6853909cda37bddfb350ceef56e21365" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dispatching function&lt;/em&gt; (or simply &lt;em&gt;dispatch function&lt;/em&gt;) is a function that accepts an action or an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt;; it then may or may not dispatch one or more actions to the store.</source>
          <target state="translated">&lt;em&gt;ディスパッチ機能&lt;/em&gt;（または単に&lt;em&gt;ディスパッチ機能は&lt;/em&gt;）アクションまたは受け付ける機能である&lt;a href=&quot;#async-action&quot;&gt;非同期アクションを&lt;/a&gt;、次に、1つ以上のアクションをストアにディスパッチする場合とディスパッチしない場合があります。</target>
        </trans-unit>
        <trans-unit id="0ec526b8fa830efd01fb591e76b77adf20e29497" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer enhancer&lt;/em&gt; (or a &lt;em&gt;higher order reducer&lt;/em&gt;) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn't understand. This isn't a new pattern&amp;mdash;technically, &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is also a reducer enhancer because it takes reducers and returns a new reducer.</source>
          <target state="translated">&lt;em&gt;減速エンハンサー&lt;/em&gt;（または&lt;em&gt;より高次の減速は&lt;/em&gt;）減速をとる関数であり、新たなアクションを処理する、またはそれ以上の状態を保持することができる新たな減速を返し、そうでないアクションの内部減速に制御を委譲します理解する。これは新しいパターンではありません。技術的には、&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;はリデューサーを受け取り、新しいリデューサーを返すため、リデューサーエンハンサーでもあります。</target>
        </trans-unit>
        <trans-unit id="54f6e31c957bc32bf7205d27b105533b64b11e59" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer&lt;/em&gt; (also called a &lt;em&gt;reducing function&lt;/em&gt;) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.</source>
          <target state="translated">&lt;em&gt;減速&lt;/em&gt;（別名&lt;em&gt;低減機能が&lt;/em&gt;）蓄積および値を受け取り、新たな蓄積を返す関数です。値のコレクションを1つの値に減らすために使用されます。</target>
        </trans-unit>
        <trans-unit id="9eba9d63a46e1040299343c1cba8ee39cab099e4" translate="yes" xml:space="preserve">
          <source>A Better File Structure for React/Redux Applications</source>
          <target state="translated">React/Redux アプリケーションのためのより良いファイル構造</target>
        </trans-unit>
        <trans-unit id="bd0db97b3caad08800e67bceba3655a16a4f42cb" translate="yes" xml:space="preserve">
          <source>A Case for setState</source>
          <target state="translated">setStateの場合</target>
        </trans-unit>
        <trans-unit id="58c12a94fc1ee1fe47d7abe792ff5a9b7def031d" translate="yes" xml:space="preserve">
          <source>A Deep Dive into React Perf Debugging</source>
          <target state="translated">React Perf デバッグへの深堀り</target>
        </trans-unit>
        <trans-unit id="0c5b0d4140e816f05523e9bb1e2dcd4ec9a913dc" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users</source>
          <target state="translated">Fluxユーザーへの注意事項</target>
        </trans-unit>
        <trans-unit id="779923a9da175253b9122887cfa0972c4cb74e6e" translate="yes" xml:space="preserve">
          <source>A Note on Mixing ES6 Modules and CommonJS</source>
          <target state="translated">ES6モジュールとCommonJSを混在させる際の注意点</target>
        </trans-unit>
        <trans-unit id="db41c4cd245302803e94359aaa69cba0b0f06284" translate="yes" xml:space="preserve">
          <source>A Redux state usually has a plain Javascript object as the top of the state tree. (It is certainly possible to have another type of data instead, such as a single number, an array, or a specialized data structure, but most libraries assume that the top-level value is a plain object.) The most common way to organize data within that top-level object is to further divide data into sub-trees, where each top-level key represents some &quot;domain&quot; or &quot;slice&quot; of related data. For example, a basic Todo app's state might look like:</source>
          <target state="translated">Reduxのステートは通常、プレーンなJavascriptオブジェクトをステートツリーの先頭に持っています(単一の数値、配列、特殊なデータ構造など、別のタイプのデータを持つことも可能ですが、ほとんどのライブラリはトップレベルの値がプレーンなオブジェクトであることを前提としています)。そのトップレベルのオブジェクト内でデータを整理する最も一般的な方法は、データをさらにサブツリーに分割することです。例えば、基本的なTodoアプリの状態は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c95746f061e18147c8c2a55d13555d7725bb143b" translate="yes" xml:space="preserve">
          <source>A better usage might look like:</source>
          <target state="translated">より良い使い方をするとこんな感じになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b48f874d11bc5b272adec4dc58721d09af5d10c0" translate="yes" xml:space="preserve">
          <source>A cartoon intro to Redux</source>
          <target state="translated">アニメで紹介されているRedux</target>
        </trans-unit>
        <trans-unit id="e9bf7de4be37a17f5d19505f713bd1be6f33e3ac" translate="yes" xml:space="preserve">
          <source>A deep dive into Clojure&amp;rsquo;s data structures</source>
          <target state="translated">Clojureのデータ構造の詳細</target>
        </trans-unit>
        <trans-unit id="0451b576bd71ffbe13c32dc53912051fc439260e" translate="yes" xml:space="preserve">
          <source>A different useful transformation that comes to my mind is reporting JavaScript errors in production. The global &lt;code&gt;window.onerror&lt;/code&gt; event is not reliable because it doesn't provide stack information in some older browsers, which is crucial to understand why an error is happening.</source>
          <target state="translated">私の頭に浮かぶ別の便利な変換は、本番環境でのJavaScriptエラーの報告です。グローバル &lt;code&gt;window.onerror&lt;/code&gt; イベントは、一部の古いブラウザではスタック情報を提供しないため、信頼性がありません。これは、エラーが発生している理由を理解するために重要です。</target>
        </trans-unit>
        <trans-unit id="1e4484c12f25bb46be91193117c01544958d6300" translate="yes" xml:space="preserve">
          <source>A good first step might be to break out a utility function to return a new object with updated fields. There's also a repeated pattern with trying to update a specific item in an array that we could extract to a function:</source>
          <target state="translated">最初の良いステップは、更新されたフィールドを持つ新しいオブジェクトを返すためのユーティリティ関数を開発することかもしれません。また、配列の中の特定の項目を更新しようとすると、関数に抽出することができる繰り返しのパターンがあります。</target>
        </trans-unit>
        <trans-unit id="e9a086635bdf1493f65c3720a831f2e56113ebce" translate="yes" xml:space="preserve">
          <source>A list of many immutable update utilities can be found in the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data#Immutable Update Utilities&lt;/a&gt; section of the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;.</source>
          <target state="translated">多くの不変更新ユーティリティのリストは、&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;の&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data＃Immutable Update Utilities&lt;/a&gt;セクションにあります。</target>
        </trans-unit>
        <trans-unit id="3c5180d4d6c3b37f40d01a33af1b0f3baa180c07" translate="yes" xml:space="preserve">
          <source>A memoized selector can itself be an input-selector to another memoized selector. Here is &lt;code&gt;getVisibleTodos&lt;/code&gt; being used as an input-selector to a selector that further filters the todos by keyword:</source>
          <target state="translated">メモ化されたセレクター自体を、別のメモ化されたセレクターへの入力セレクターにすることができます。 &lt;code&gt;getVisibleTodos&lt;/code&gt; は、todoをさらにキーワードでフィルターするセレクターへの入力セレクターとして使用されています。</target>
        </trans-unit>
        <trans-unit id="1715344fa5f33e240f9d1d585beffe859e05b0df" translate="yes" xml:space="preserve">
          <source>A middleware is a higher-order function that composes a &lt;a href=&quot;#dispatching-function&quot;&gt;dispatch function&lt;/a&gt; to return a new dispatch function. It often turns &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; into actions.</source>
          <target state="translated">ミドルウェアは、&lt;a href=&quot;#dispatching-function&quot;&gt;ディスパッチ関数&lt;/a&gt;を構成して新しいディスパッチ関数を返す高次関数です。多くの場合、&lt;a href=&quot;#async-action&quot;&gt;非同期アクション&lt;/a&gt;をアクションに変換します。</target>
        </trans-unit>
        <trans-unit id="81b81652bf02ff7bf772129a812fc4e04bf51ded" translate="yes" xml:space="preserve">
          <source>A nice thing about React components is that they are usually small and only rely on their props. That makes them easy to test.</source>
          <target state="translated">React コンポーネントの良いところは、通常は小さく、小道具だけに頼っていることです。そのため、テストが簡単です。</target>
        </trans-unit>
        <trans-unit id="66c5775c8d40ff721fc8d112637246b185d62e5b" translate="yes" xml:space="preserve">
          <source>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt;. This is equivalent to writing &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt;.</source>
          <target state="translated">一般的な規則は、レデューサーが管理する状態スライスに &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt; に名前を付けることです。そのため、ES6プロパティの省略表記を使用できます。これは、 &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt; と書くのと同じです。</target>
        </trans-unit>
        <trans-unit id="6142fea1802b9d891098496555324f048dfc4ab1" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that combines other reducers might look like this:</source>
          <target state="translated">他のレデューサを組み合わせたレデューサエンハンサは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="85855b61915007bb41ecf73529b533adae4a769a" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that doesn't do anything looks like this:</source>
          <target state="translated">何もしないレデューサーエンハンサーはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="4e2848c8d31433a5257b89be2c33d6bbc13ce44e" translate="yes" xml:space="preserve">
          <source>A reducer should return the new state after applying the action to the previous state, and that's the behavior tested below.</source>
          <target state="translated">減力剤は、前の状態にアクションを適用した後に新しい状態を返すべきであり、それが以下でテストされる動作です。</target>
        </trans-unit>
        <trans-unit id="ce6bc5c6b208bc72c706a97b8ea7f4de3a455d2c" translate="yes" xml:space="preserve">
          <source>A selector created with &lt;code&gt;createSelector&lt;/code&gt; only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt;, the shared selector will alternate between receiving &lt;code&gt;{listId: 1}&lt;/code&gt; and &lt;code&gt;{listId: 2}&lt;/code&gt; as its &lt;code&gt;props&lt;/code&gt; argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We'll see how to overcome this limitation in the next section.</source>
          <target state="translated">&lt;code&gt;createSelector&lt;/code&gt; で作成されたセレクターは、引数のセットが以前の引数のセットと同じである場合にのみ、キャッシュされた値を返します。 &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt; のレンダリングを交互に行う場合、共有セレクターは、 &lt;code&gt;props&lt;/code&gt; 引数として &lt;code&gt;{listId: 1}&lt;/code&gt; と &lt;code&gt;{listId: 2}&lt;/code&gt; 受け取りを交互に行います。これにより、呼び出しごとに引数が異なるため、セレクターはキャッシュされた値を返す代わりに、常に再計算します。この制限を克服する方法については、次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="d7fdd19e31d4aa5c08f59368d084b0cdd3afe5c5" translate="yes" xml:space="preserve">
          <source>A shallow equality check is therefore as simple (and as fast) as &lt;code&gt;a === b&lt;/code&gt;, whereas a deep equality check involves a recursive traversal through the properties of two objects, comparing the value of each property at each step.</source>
          <target state="translated">したがって、浅い等値チェックは &lt;code&gt;a === b&lt;/code&gt; と同じくらい簡単（かつ高速）ですが、深い等値チェックは、2つのオブジェクトのプロパティを再帰的に走査して、各ステップで各プロパティの値を比較します。</target>
        </trans-unit>
        <trans-unit id="8bba7fd75614daa0e3f257e0f35cbfa400838a5b" translate="yes" xml:space="preserve">
          <source>A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, &lt;a href=&quot;api/createstore&quot;&gt;&lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt;&lt;/a&gt; exported from the Redux package, from store creators that are returned from the store enhancers.</source>
          <target state="translated">ストアクリエーターは、R​​eduxストアを作成する関数です。ディスパッチ機能の場合と同様に、Reduxパッケージからエクスポートされたベースストア作成者&lt;a href=&quot;api/createstore&quot;&gt; &lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt; &lt;/a&gt;を、ストアエンハンサーから返されたストア作成者と区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="0498b8c765baf0d793d01093c2d3938c7acad2d2" translate="yes" xml:space="preserve">
          <source>A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.</source>
          <target state="translated">ストア・エンハンサーは、ストア・クリエータを合成して、新しく強化されたストア・クリエータを返す高次関数です。これは、ストア・インターフェースを構成可能な方法で変更できるという点で、ミドルウェアに似ています。</target>
        </trans-unit>
        <trans-unit id="80ff26cb12d9ecc5ea599ca905718232908db10a" translate="yes" xml:space="preserve">
          <source>A store holds the whole &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt; of your application.</source>
          <target state="translated">ストアは、アプリケーションの&lt;a href=&quot;../glossary#state&quot;&gt;状態ツリー&lt;/a&gt;全体を保持します。</target>
        </trans-unit>
        <trans-unit id="db90563ef06aad2359ba2b820d66958cfae253aa" translate="yes" xml:space="preserve">
          <source>A store is an object that holds the application's state tree.</source>
          <target state="translated">ストアは、アプリケーションのステートツリーを保持するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="8139366b65a6efd49fd2de96e65c9cf4f80822d2" translate="yes" xml:space="preserve">
          <source>A store is not a class. It's just an object with a few methods on it.</source>
          <target state="translated">ストアはクラスではありません。ただのオブジェクトで、その上にいくつかのメソッドがあるだけです。</target>
        </trans-unit>
        <trans-unit id="1dd2226f91b259d8b3ba9075e912f9f1b756eb73" translate="yes" xml:space="preserve">
          <source>A third approach would be to use the reducer generated by &lt;code&gt;combineReducers&lt;/code&gt; to handle the &quot;simple&quot; cases where each slice reducer can update itself independently, but also use another reducer to handle the &quot;special&quot; cases where data needs to be shared across slices. Then, a wrapping function could call both of those reducers in turn to generate the final result:</source>
          <target state="translated">3番目のアプローチは、 &lt;code&gt;combineReducers&lt;/code&gt; によって生成されたレデューサーを使用して、各スライスレデューサーが独立して更新できる「単純な」ケースを処理するだけでなく、別のレデューサーを使用して、スライス間でデータを共有する必要がある「特別な」ケースを処理することです。次に、ラッピング関数はこれらのリデューサーの両方を順番に呼び出して、最終的な結果を生成します。</target>
        </trans-unit>
        <trans-unit id="3a29a2d5178bbb1dcd22edfd2b4d56832e62a760" translate="yes" xml:space="preserve">
          <source>A typical app's state shape might look roughly like:</source>
          <target state="translated">一般的なアプリの状態の形は、だいたいこんな感じかもしれません。</target>
        </trans-unit>
        <trans-unit id="dd7f5eb9f1f3f2372ac3b7d3fc72f9fa655d209b" translate="yes" xml:space="preserve">
          <source>A typical application will likely have a mixture of relational data and non-relational data. While there is no single rule for exactly how those different types of data should be organized, one common pattern is to put the relational &quot;tables&quot; under a common parent key, such as &quot;entities&quot;. A state structure using this approach might look like:</source>
          <target state="translated">典型的なアプリケーションでは、リレーショナルデータと非リレーショナルデータが混在している可能性が高いでしょう。これらの異なるタイプのデータがどのように編成されるべきかについては、単一のルールはありませんが、一般的なパターンとしては、リレーショナルな「テーブル」を「エンティティ」のような共通の親キーの下に置くというものがあります。このアプローチを使用した状態構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API リファレンス</target>
        </trans-unit>
        <trans-unit id="f0682f7888392082612529e79e90a8568fdf278b" translate="yes" xml:space="preserve">
          <source>API: React-Redux&amp;rsquo;s connect function and &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">API：React-Reduxの接続関数と &lt;code&gt;mapStateToProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b79cd36dd33f71f26f84428e7993c489d7d7b4" translate="yes" xml:space="preserve">
          <source>API: Store</source>
          <target state="translated">APIを使用しています。ストア</target>
        </trans-unit>
        <trans-unit id="e0c9492b063857505209dc57c11cd7626823a1e5" translate="yes" xml:space="preserve">
          <source>API: applyMiddleware</source>
          <target state="translated">API:applyMiddleware</target>
        </trans-unit>
        <trans-unit id="933d49b5bdf3528c648138b4bc997b3bd1ee051d" translate="yes" xml:space="preserve">
          <source>API: combineReducers</source>
          <target state="translated">API:combineReducers</target>
        </trans-unit>
        <trans-unit id="3e2257d3cbebe55ab5120cd90126477209348170" translate="yes" xml:space="preserve">
          <source>Accessing React Props in Selectors</source>
          <target state="translated">セレクタでReact Propsにアクセスする</target>
        </trans-unit>
        <trans-unit id="7b3702d1af5b6f51067a97e15b727d6bb1e395e0" translate="yes" xml:space="preserve">
          <source>Accidental Object Mutation</source>
          <target state="translated">偶発的物体の突然変異</target>
        </trans-unit>
        <trans-unit id="a3bcac5b1b8316670488ac51d4cfe888b1904b8d" translate="yes" xml:space="preserve">
          <source>Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state &amp;ldquo;immutably&amp;rdquo;, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and if all references are the same, returns &lt;code&gt;false&lt;/code&gt; to skip actually updating your original component.</source>
          <target state="translated">誤って状態を直接変更または変更することは、アクションがディスパッチされた後にコンポーネントが再レンダリングされない最も一般的な理由です。 Reduxは、レデューサーが状態を「不変に」更新することを期待しています。これは事実上、常にデータのコピーを作成し、コピーに変更を適用することを意味します。レデューサーから同じオブジェクトを返す場合、Reduxは、内容に変更を加えても、何も変更されていないと見なします。同様に、React Reduxは、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; で着信プロップの浅い等価参照チェックを実行してパフォーマンスを改善しようとします。すべての参照が同じ場合は、 &lt;code&gt;false&lt;/code&gt; を返し、元のコンポーネントの実際の更新をスキップします。</target>
        </trans-unit>
        <trans-unit id="ededef69001678f2e3f055f1fda34f301acb3bdc" translate="yes" xml:space="preserve">
          <source>Accordingly, &lt;code&gt;combineReducers&lt;/code&gt; will not set its &lt;code&gt;hasChanged&lt;/code&gt; flag, even though the state has changed. If none of the other reducers return a new, updated state slice, the &lt;code&gt;hasChanged&lt;/code&gt; flag will remain set to false, causing &lt;code&gt;combineReducers&lt;/code&gt; to return the &lt;em&gt;existing&lt;/em&gt; root state object.</source>
          <target state="translated">したがって、 &lt;code&gt;combineReducers&lt;/code&gt; は、状態が変化しても、 &lt;code&gt;hasChanged&lt;/code&gt; フラグを設定しません。他のどのレデューサーも新しい更新された状態スライスを返さない場合、 &lt;code&gt;hasChanged&lt;/code&gt; フラグはfalseに設定されたままになり、 &lt;code&gt;combineReducers&lt;/code&gt; は&lt;em&gt;既存の&lt;/em&gt;ルート状態オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="4a9938fccff603464933303296454dffcb6d16f1" translate="yes" xml:space="preserve">
          <source>Accordingly, calling &lt;code&gt;toJS()&lt;/code&gt; twice, for example, and assigning the result to two different variables will cause an equality check on those two variables to fail, even though the object values themselves haven&amp;rsquo;t changed.</source>
          <target state="translated">したがって、 &lt;code&gt;toJS()&lt;/code&gt; 2回呼び出し、その結果を2つの異なる変数に割り当てると、オブジェクトの値自体は変更されていなくても、これら2つの変数の等価性チェックは失敗します。</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="240f485623391e5c1075e5725ad30c67ed287ffe" translate="yes" xml:space="preserve">
          <source>Action Creator</source>
          <target state="translated">アクションクリエーター</target>
        </trans-unit>
        <trans-unit id="41b6c7e08efa20fb3393d8ac535f3d3c740a070d" translate="yes" xml:space="preserve">
          <source>Action Creators</source>
          <target state="translated">アクションクリエイター</target>
        </trans-unit>
        <trans-unit id="0ec85940f13d4f2b78e391b686bbb091564ba03e" translate="yes" xml:space="preserve">
          <source>Action Creators and Constants</source>
          <target state="translated">アクション クリエイターと定数</target>
        </trans-unit>
        <trans-unit id="a119c0a9e7c1a3dda7791541c11f9924b37c7992" translate="yes" xml:space="preserve">
          <source>Action creators can also be asynchronous and have side-effects. You can read about &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle AJAX responses and compose action creators into async control flow. Don't skip ahead to async actions until you've completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions.</source>
          <target state="translated">アクションクリエーターは非同期であり、副作用がある場合もあります。&lt;a href=&quot;../advanced/index&quot;&gt;高度なチュートリアル&lt;/a&gt;で&lt;a href=&quot;../advanced/asyncactions&quot;&gt;非同期アクション&lt;/a&gt;について読んで、AJAX応答を処理し、アクション作成者を非同期制御フローに構成する方法を学ぶことができます。基本チュートリアルが完了するまで、非同期アクションにスキップしないでください。高度なチュートリアルと非同期アクションの前提条件となる他の重要な概念について説明しています。</target>
        </trans-unit>
        <trans-unit id="38b2a78d2a362985ab2383462db85f699d11a8bc" translate="yes" xml:space="preserve">
          <source>Action creators have often been criticized as boilerplate. Well, you don't have to write them! &lt;strong&gt;You can use object literals if you feel this better suits your project.&lt;/strong&gt; There are, however, some benefits for writing action creators you should know about.</source>
          <target state="translated">アクションクリエーターは定型句として批判されることがよくあります。まあ、あなたはそれらを書く必要はありません！&lt;strong&gt;プロジェクトに適していると思われる場合は、オブジェクトリテラルを使用できます。&lt;/strong&gt;ただし、知っておくべきアクションクリエーターを作成することにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="e8ae9384ae9248e5ddbc032e08b2557629723918" translate="yes" xml:space="preserve">
          <source>Actions are plain JavaScript objects. Actions must have a &lt;code&gt;type&lt;/code&gt; property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.</source>
          <target state="translated">アクションは単純なJavaScriptオブジェクトです。アクションには、実行されるアクションのタイプを示す &lt;code&gt;type&lt;/code&gt; プロパティが必要です。タイプは通常、文字列定数として定義する必要があります。アプリが十分な大きさになったら、それらを別のモジュールに移動することができます。</target>
        </trans-unit>
        <trans-unit id="29c6835b1a6b3824f0c14c55211c697ec783ced1" translate="yes" xml:space="preserve">
          <source>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that &lt;strong&gt;actions being objects you have to dispatch is not boilerplate, but one of the &lt;a href=&quot;../introduction/threeprinciples&quot;&gt;fundamental design choices&lt;/a&gt; of Redux&lt;/strong&gt;.</source>
          <target state="translated">アクションは、アプリで発生したことを説明するプレーンオブジェクトであり、データを変更する意図を説明する唯一の方法として機能します。&lt;strong&gt;ディスパッチする必要のあるオブジェクトで&lt;a href=&quot;../introduction/threeprinciples&quot;&gt;&lt;/a&gt;&lt;/strong&gt;ある&lt;strong&gt;アクションが定型的ではなく&lt;/strong&gt;&lt;strong&gt;、Reduxの&lt;/strong&gt;&lt;strong&gt;基本的な設計選択の&lt;/strong&gt;&lt;strong&gt; 1つであることが&lt;/strong&gt;重要です。</target>
        </trans-unit>
        <trans-unit id="7d61d75382f4f34d26d503abba6068279c8ea603" translate="yes" xml:space="preserve">
          <source>Actions look like this:</source>
          <target state="translated">アクションはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="59ec7f0f4e16258c3a0d1d14cd731f00efda02b1" translate="yes" xml:space="preserve">
          <source>Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable.</source>
          <target state="translated">アクションには、実行されるアクションのタイプを示す &lt;code&gt;type&lt;/code&gt; フィールドが必要です。タイプは定数として定義でき、別のモジュールからインポートできます。文字列はシリアル化可能であるため、&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt;よりも &lt;code&gt;type&lt;/code&gt; は文字列を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="88de3a2870fc9eb038ea75c3422acc4a151defa3" translate="yes" xml:space="preserve">
          <source>Adding the Buttons</source>
          <target state="translated">ボタンの追加</target>
        </trans-unit>
        <trans-unit id="c737672ab2cc3d4caaa793fa73dc88d6e8d45119" translate="yes" xml:space="preserve">
          <source>Additionally, as we are using ES6 and JSX syntax, we will need to compile with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; (see &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;this example of a Node Server with Babel&lt;/a&gt;) and the &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React preset&lt;/a&gt;.</source>
          <target state="translated">さらに、ES6およびJSX構文を使用しているため、&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;（&lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;この&lt;/a&gt;Babel を使用したNode Serverの例を参照）および&lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;Reactプリセット&lt;/a&gt;を使用してコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="18596de4375fc946c5b097f81e74982a60e9c894" translate="yes" xml:space="preserve">
          <source>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; to read the current state tree inside the callback.</source>
          <target state="translated">変更リスナーを追加します。アクションがディスパッチされるたびに呼び出され、状態ツリーの一部が変更された可能性があります。次に、&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;を呼び出して、コールバック内の現在の状態ツリーを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="16857f7bab141f13aed36aec58498499bddb6833" translate="yes" xml:space="preserve">
          <source>Advanced: Async Actions</source>
          <target state="translated">上級者向け。非同期アクション</target>
        </trans-unit>
        <trans-unit id="025dce227eca0ed35e21358aac9e6536fedf70ed" translate="yes" xml:space="preserve">
          <source>Advanced: Async Flow</source>
          <target state="translated">上級者向け。非同期フロー</target>
        </trans-unit>
        <trans-unit id="35f20532e3af1b93336b6e71dbaacd3a2435abd0" translate="yes" xml:space="preserve">
          <source>Advanced: Middleware</source>
          <target state="translated">上級者向け。ミドルウェア</target>
        </trans-unit>
        <trans-unit id="25069391f8b74b286f02804c1347be029afe7715" translate="yes" xml:space="preserve">
          <source>After passing it once to &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt;, you can write all your API-calling action creators the same way:</source>
          <target state="translated">&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt;に1回渡した後、すべてのAPI呼び出しアクションクリエーターを同じ方法で記述できます。</target>
        </trans-unit>
        <trans-unit id="53e43e635db37f09dab8f6423d79953c28e59e8e" translate="yes" xml:space="preserve">
          <source>After the iterations have completed, &lt;code&gt;combineReducers&lt;/code&gt; will check the state of the &lt;code&gt;hasChanged&lt;/code&gt; flag. If it&amp;rsquo;s true, the newly-constructed state object will be returned. If it&amp;rsquo;s false, the &lt;em&gt;current&lt;/em&gt; state object is returned.</source>
          <target state="translated">反復が完了した後、 &lt;code&gt;combineReducers&lt;/code&gt; は &lt;code&gt;hasChanged&lt;/code&gt; フラグの状態をチェックします。trueの場合、新しく作成された状態オブジェクトが返されます。falseの場合、&lt;em&gt;現在の&lt;/em&gt;状態オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="fc595812793ab6bb9b28c25bb6e33f011754ef4a" translate="yes" xml:space="preserve">
          <source>Again, it's important to understand that Redux reducers are &lt;em&gt;just&lt;/em&gt; functions. While &lt;code&gt;combineReducers&lt;/code&gt; is useful, it's just one tool in the toolbox. Functions can contain conditional logic other than switch statements, functions can be composed to wrap each other, and functions can call other functions. Maybe you need one of your slice reducers to be able to reset its state, and to only respond to specific actions overall. You could do:</source>
          <target state="translated">繰り返しますが、Reduxのレデューサーは&lt;em&gt;単なる&lt;/em&gt;関数であることを理解することが重要です。一方で &lt;code&gt;combineReducers&lt;/code&gt; は便利ですが、それはツールボックスのひとつのツールです。関数には、switchステートメント以外の条件付きロジックを含めることができます。関数は、互いにラップするように構成でき、関数は他の関数を呼び出すことができます。状態をリセットし、全体的に特定のアクションにのみ応答できるようにするには、スライスレデューサーの1つが必要な場合があります。あなたがすることができます：</target>
        </trans-unit>
        <trans-unit id="b948d24fd1c5855cef6418255f90cedfe918ce37" translate="yes" xml:space="preserve">
          <source>Again, this is just a mock API, so we use &lt;code&gt;setTimeout&lt;/code&gt; to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you're using a Promise-based API client, then you would issue this callback in your &lt;code&gt;then&lt;/code&gt; handler.</source>
          <target state="translated">繰り返しになりますが、これは単なるモックAPIなので、 &lt;code&gt;setTimeout&lt;/code&gt; を使用して、応答に500ミリ秒かかるネットワークリクエストをシミュレートします（実際のAPIの方がはるかに高速です）。乱数を非同期で返すコールバックを渡します。PromiseベースのAPIクライアントを使用している場合は、 &lt;code&gt;then&lt;/code&gt; ハンドラーでこのコールバックを発行します。</target>
        </trans-unit>
        <trans-unit id="79aa101c36a75c4f0aa52bd08ce3b2d8cdc7f9d8" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; does is generate a function that calls your reducers &lt;strong&gt;with the slices of state selected according to their keys&lt;/strong&gt;, and combining their results into a single object again. &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;It's not magic.&lt;/a&gt; And like other reducers, &lt;code&gt;combineReducers()&lt;/code&gt; does not create a new object if all of the reducers provided to it do not change state.</source>
          <target state="translated">すべての&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;は&lt;strong&gt;、キーに従って選択された状態のスライスを使用し&lt;/strong&gt;てレデューサー&lt;strong&gt;を&lt;/strong&gt;呼び出し、その結果を再び単一のオブジェクトに結合する関数を生成します。&lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;それは魔法ではありません。&lt;/a&gt;また、他の &lt;code&gt;combineReducers()&lt;/code&gt; と同様に、combinedReducers（）は、提供されたすべてのリデューサーが状態を変更しない場合、新しいオブジェクトを作成しません。</target>
        </trans-unit>
        <trans-unit id="cbeeac1b96757e9c7e7b9ce98e03b49b2143629c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;compose&lt;/code&gt; does is let you write deeply nested function transformations without the rightward drift of the code. Don't give it too much credit!</source>
          <target state="translated">すべての &lt;code&gt;compose&lt;/code&gt; ありませんあなたは、コードの右方向にドリフトすることなく、深くネストされた関数変換を書いてみましょうです。あまり信用しないでください！</target>
        </trans-unit>
        <trans-unit id="9352846dec2290d9ee10aeb06144a932791349b8" translate="yes" xml:space="preserve">
          <source>All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire &lt;code&gt;store&lt;/code&gt; even through presentational components just because they happen to render a container deep in the component tree.</source>
          <target state="translated">すべてのコンテナーコンポーネントは、サブスクライブできるようにReduxストアにアクセスする必要があります。1つのオプションは、それを小道具としてすべてのコンテナーコンポーネントに渡すことです。ただし、コンポーネントがコンポーネントツリーの深いところにコンテナをレンダリングするだけで、プレゼンテーションコンポーネントを介して &lt;code&gt;store&lt;/code&gt; をワイヤリングする必要があるため、これは面倒です。</target>
        </trans-unit>
        <trans-unit id="4ff23711ae579d38170f51f062fe9549d4a371f8" translate="yes" xml:space="preserve">
          <source>Allows access to state via &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; による&lt;/a&gt;状態へのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="9a12034e563003a9eca9331500b3b60b340ce34f" translate="yes" xml:space="preserve">
          <source>Allows state to be updated via &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; を&lt;/a&gt;介して状態を更新できるようにします。</target>
        </trans-unit>
        <trans-unit id="0fc5484ef3a628ddd51e1319c03088024b0016ab" translate="yes" xml:space="preserve">
          <source>Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online.</source>
          <target state="translated">ほとんどすべての例に対応する CodeSandbox サンドボックスがあります。これは、オンラインで遊べるコードのインタラクティブなバージョンです。</target>
        </trans-unit>
        <trans-unit id="65a555920679381ca5e42f41dbd1af93c1e69228" translate="yes" xml:space="preserve">
          <source>Along this chapter, we will be using the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example. We recommend you to clone it while reading this chapter.</source>
          <target state="translated">この章では、&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todosの&lt;/a&gt;例を使用します。この章を読みながら、クローンを作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9166c2a546b7eba6781eda1ddb48ac422e9c9900" translate="yes" xml:space="preserve">
          <source>Also keep an eye out for nested state objects that need to be deeply copied. Both &lt;code&gt;_.extend&lt;/code&gt; and &lt;code&gt;Object.assign&lt;/code&gt; make a shallow copy of the state. See &lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;Updating Nested Objects&lt;/a&gt; for suggestions on how to deal with nested state objects.</source>
          <target state="translated">また、深くコピーする必要のあるネストされた状態オブジェクトにも注意してください。 &lt;code&gt;_.extend&lt;/code&gt; と &lt;code&gt;Object.assign&lt;/code&gt; はどちらも、状態の浅いコピーを作成します。ネストされた状態オブジェクトの処理方法に関する提案については、&lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;ネストされたオブジェクトの更新を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d280006e11c722e08ab0ef3901f105ba1f89c495" translate="yes" xml:space="preserve">
          <source>Also, the resulting names are a bit odd. It's generally not a good practice to actually include words like &quot;reducer&quot; in your state key names - the keys should simply reflect the domain or type of data they hold. This means we should either explicitly specify the names of the keys in the slice reducer object to define the keys in the output state object, or carefully rename the variables for the imported slice reducers to set up the keys when using the shorthand object literal syntax.</source>
          <target state="translated">また、結果として得られる名前は少し奇妙なものになります。一般的に、状態キー名に &quot;reducer &quot;のような単語を含めることは良い習慣ではありません-キーは単に保持しているデータのドメインやタイプを反映する必要があります。つまり、出力ステートオブジェクトのキーを定義するために、スライスレデューサオブジェクトのキー名を明示的に指定するか、インポートされたスライスレデューサの変数の名前を慎重に変更して、短縮オブジェクトリテラル構文を使用する際にキーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a92743996305e4fee546be1bf5a260da6bb485c9" translate="yes" xml:space="preserve">
          <source>Also, while &lt;code&gt;combineReducers&lt;/code&gt; is the one reducer utility function that's built into Redux, there's a wide variety of third-party reducer utilities that have published for reuse. The &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt; lists many of the third-party utilities that are available. Or, if none of the published utilities solve your use case, you can always write a function yourself that does just exactly what you need.</source>
          <target state="translated">また、 &lt;code&gt;combineReducers&lt;/code&gt; はReduxに組み込まれている1つのリデューサーユーティリティ関数ですが、再利用のために公開されているさまざまなサードパーティのリデューサーユーティリティがあります。&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Reduxのアドオンカタログの&lt;/a&gt;利用可能なサードパーティ製のユーティリティの多くのリスト。または、公開されたユーティリティのいずれもユースケースを解決しない場合は、必要な機能を正確に実行する関数をいつでも自分で作成できます。</target>
        </trans-unit>
        <trans-unit id="cf8b3627c269aa139cc46adb58b39f1f40a3959a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a &lt;strong&gt;bound action creator&lt;/strong&gt; that automatically dispatches:</source>
          <target state="translated">または、自動的にディスパッチする&lt;strong&gt;バインドアクションクリエーター&lt;/strong&gt;を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="6d168d8850f955b7e9e3d0a064ebea1d8ecaae72" translate="yes" xml:space="preserve">
          <source>Although powerful, Immutable.JS needs to be used carefully, as it comes with issues of its own. Note, however, that all of these issues can be overcome quite easily with careful coding.</source>
          <target state="translated">パワフルではありますが、Immutable.JS はそれ自体に問題があるため、慎重に使用する必要があります。しかし、これらの問題は、慎重にコーディングすれば簡単に解決できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4d209720249965a438eaa6d74c36ac6d53a3230a" translate="yes" xml:space="preserve">
          <source>Although the final result in this example is noticeably longer than the original version, this is primarily due to the extraction of the utility functions, the addition of comments, and some deliberate verbosity for the sake of clarity, such as separate return statements. Looking at each function individually, the amount of responsibility is now smaller, and the intent is hopefully clearer. Also, in a real application, these functions would probably then be split into separate files such as &lt;code&gt;reducerUtilities.js&lt;/code&gt;, &lt;code&gt;visibilityReducer.js&lt;/code&gt;, &lt;code&gt;todosReducer.js&lt;/code&gt;, and &lt;code&gt;rootReducer.js&lt;/code&gt;.</source>
          <target state="translated">この例の最終結果は元のバージョンよりも著しく長くなっていますが、これは主に、ユーティリティ関数の抽出、コメントの追加、および明確にするための明確な冗長性（個別のreturnステートメントなど）によるものです。各機能を個別に見ると、責任の量が少なくなり、意図が明確になれば幸いです。また、実際のアプリケーションでは、これらの関数はおそらく &lt;code&gt;reducerUtilities.js&lt;/code&gt; 、 &lt;code&gt;visibilityReducer.js&lt;/code&gt; 、 &lt;code&gt;todosReducer.js&lt;/code&gt; 、および &lt;code&gt;rootReducer.js&lt;/code&gt; などの個別のファイルに分割されます。</target>
        </trans-unit>
        <trans-unit id="11420cf980650fbffa2655206c7e7f0d6f693730" translate="yes" xml:space="preserve">
          <source>Always.</source>
          <target state="translated">Always.</target>
        </trans-unit>
        <trans-unit id="ae42e396c07650791a08d3bbeb56dcf9d4f16480" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;actions&quot;&gt;action&lt;/a&gt; is a plain object describing &lt;em&gt;what happened&lt;/em&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;actions&quot;&gt;アクションが&lt;/a&gt;記述したプレーンなオブジェクトで&lt;em&gt;何が起こったのか&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="e3348883e6b709273b1588a140f0ad640ffa7901" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action creator&lt;/em&gt; is, quite simply, a function that creates an action. Do not confuse the two terms&amp;mdash;again, an action is a payload of information, and an action creator is a factory that creates an action.</source>
          <target state="translated">&lt;em&gt;アクションの作成者は&lt;/em&gt;、非常に単純に、アクションを作成する機能です。2つの用語を混同しないでください。ここでも、アクションは情報のペイロードであり、アクションクリエーターはアクションを作成するファクトリです。</target>
        </trans-unit>
        <trans-unit id="7dbd2dc1e57dbf1a690c626bcf14369d4d0f24ee" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action&lt;/em&gt; is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.</source>
          <target state="translated">&lt;em&gt;アクションは&lt;/em&gt;状態を変更する意図を表し平野オブジェクトです。アクションは、データをストアに取り込む唯一の方法です。UIイベント、ネットワークコールバック、またはWebSocketなどの他のソースからのデータは、最終的にアクションとしてディスパッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="5753c579ec0c6f7a4e01deb683ed860b056f3db7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async action&lt;/em&gt; is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by &lt;a href=&quot;#middleware&quot;&gt;middleware&lt;/a&gt; into an action (or a series of actions) before being sent to the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.</source>
          <target state="translated">&lt;em&gt;非同期アクションが&lt;/em&gt;ディスパッチ関数に送信された値であるが、まだ減速による消費のために準備ができていません。&lt;a href=&quot;#middleware&quot;&gt;ミドルウェア&lt;/a&gt;によってアクション（または一連のアクション）に変換されてから、基本の&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;関数に送信されます。非同期アクションは、使用するミドルウェアに応じて、さまざまなタイプを持つ場合があります。多くの場合、Promiseやサンクなどの非同期プリミティブであり、レデューサーにすぐには渡されませんが、操作が完了するとアクションディスパッチをトリガーします。</target>
        </trans-unit>
        <trans-unit id="7059ea52b9fe7cd64e9c1eb12fbae0e27f1fbf10" translate="yes" xml:space="preserve">
          <source>An Introduction to Reasonably Pure Functional Programming</source>
          <target state="translated">合理的に純粋な関数型プログラミング入門</target>
        </trans-unit>
        <trans-unit id="027aa8fd687cde00ad56b360989176d53d8f5088" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; proposed for the next versions of JavaScript which lets you use the spread (&lt;code&gt;...&lt;/code&gt;) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;array spread operator&lt;/a&gt;. We can simplify the &lt;code&gt;todoApp&lt;/code&gt; example above by using the object spread syntax:</source>
          <target state="translated">別のアプローチは、JavaScriptの次のバージョンで提案されている&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;オブジェクトスプレッド構文&lt;/a&gt;を使用することです。これにより、spread（ &lt;code&gt;...&lt;/code&gt; ）演算子を使用して、列挙可能なプロパティをより簡潔な方法でオブジェクト間でコピーできます。オブジェクト拡散演算子は、概念的にはES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;配列拡散演算子に&lt;/a&gt;似ています。上記の &lt;code&gt;todoApp&lt;/code&gt; の例は、オブジェクトスプレッド構文を使用して簡略化できます。</target>
        </trans-unit>
        <trans-unit id="9140efa7e4fd077860c74984e025f41073161a33" translate="yes" xml:space="preserve">
          <source>An example of a normalized state structure for the blog example above might look like:</source>
          <target state="translated">上のブログの例の正規化された状態構造の例は、次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f5f4aca90e751fb4943bf0f75cdcb58b3045de7" translate="yes" xml:space="preserve">
          <source>And further yet:</source>
          <target state="translated">そしてさらに、さらに。</target>
        </trans-unit>
        <trans-unit id="042ece2a59b966fa0a3746efb8c09215e767bd18" translate="yes" xml:space="preserve">
          <source>And if you need both:</source>
          <target state="translated">両方必要な場合も</target>
        </trans-unit>
        <trans-unit id="b9796d47a0c430111a17f97990051bc1f0bd25b7" translate="yes" xml:space="preserve">
          <source>And many, many more! The Redux Addons Catalog has &lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;a list of Redux-based applications and examples&lt;/a&gt;&lt;/strong&gt; that points to a variety of actual applications, large and small.</source>
          <target state="translated">そして、もっとたくさん！Redux Addons Catalogには&lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;、Reduxベースのアプリケーションのリスト&lt;/a&gt;&lt;/strong&gt;と、大小さまざまな実際のアプリケーションのさまざまな&lt;strong&gt;例&lt;/strong&gt;を&lt;strong&gt;示した例&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="38147ba676724ae6f61a0d7f338d7350e8929314" translate="yes" xml:space="preserve">
          <source>And that's it! That is all we need to do to implement server side rendering.</source>
          <target state="translated">そして、これで完成です。サーバーサイドレンダリングの実装は以上です。</target>
        </trans-unit>
        <trans-unit id="0f36f5dbc061dc0b41ff32b3fcf5454dd4737242" translate="yes" xml:space="preserve">
          <source>And this is how you would use it in your Smart Component:</source>
          <target state="translated">そして、スマートコンポではこのように使用します。</target>
        </trans-unit>
        <trans-unit id="7821f53eb6540ced1a441c7c8a5afc57915f7472" translate="yes" xml:space="preserve">
          <source>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</source>
          <target state="translated">そして、対応する状態キーに対してこれら2つのレデューサを呼び出すことで、アプリの完全な状態を管理する別のレデューサを書きます。</target>
        </trans-unit>
        <trans-unit id="035d8336ff091d8317b65369c8f7a5fba5c1e1a6" translate="yes" xml:space="preserve">
          <source>Andr&amp;eacute; Staltz, creator of Cycle</source>
          <target state="translated">アンドレ・シュタルツ、サイクルの作成者</target>
        </trans-unit>
        <trans-unit id="e87d12fc4df56487f9cea8c793885037c6bb50fc" translate="yes" xml:space="preserve">
          <source>Angular 2 &amp;mdash; Introduction to Redux</source>
          <target state="translated">Angular 2 &amp;mdash; Reduxの概要</target>
        </trans-unit>
        <trans-unit id="bc3e9743695c2147abea82ed6210c9b8769e1aff" translate="yes" xml:space="preserve">
          <source>Another alternative to the &quot;shared-slice updates&quot; issue would be to simply put more data into the action. This is easily accomplished using thunk functions or a similar approach, per this example:</source>
          <target state="translated">shared-slice updates &quot;問題のもう一つの代替案は、単により多くのデータをアクションに入れることです。これは、この例のようにThunk関数や類似のアプローチを使用することで簡単に実現できます。</target>
        </trans-unit>
        <trans-unit id="54508f8783d239a03fbfc708d7eb0721cdb09e88" translate="yes" xml:space="preserve">
          <source>Another common version of this error looks like this:</source>
          <target state="translated">このエラーのもう一つの一般的なバージョンは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ab7d294fca6f772f407a0c0a76df3b9678dec13a" translate="yes" xml:space="preserve">
          <source>Another important difference from Flux is that &lt;strong&gt;Redux assumes you never mutate your data&lt;/strong&gt;. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object, which is easy with the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;, or with a library like &lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;.</source>
          <target state="translated">Fluxと&lt;strong&gt;のもう&lt;/strong&gt; 1つの重要な違いは、&lt;strong&gt;Reduxがデータを変更しないことを前提としていること&lt;/strong&gt;です。状態にはプレーンオブジェクトと配列を問題なく使用できますが、レデューサー内でそれらを変更することは強くお勧めしません。常に新しいオブジェクトを返す必要があります。これは、&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;オブジェクトスプレッドオペレーターの提案&lt;/a&gt;や、&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;などのライブラリを使用すると簡単です。</target>
        </trans-unit>
        <trans-unit id="327dd80631e264f16ad2cae2c1d1c364a6353cd0" translate="yes" xml:space="preserve">
          <source>Another variation on this is to use Redux-ORM as an abstraction layer within a single case reducer:</source>
          <target state="translated">これのもう一つのバリエーションは、Redux-ORMを単一のケースリデューサ内の抽象化レイヤとして使用することです。</target>
        </trans-unit>
        <trans-unit id="6dca810c72389e39d7ae3adc87f949b161cb67aa" translate="yes" xml:space="preserve">
          <source>Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&amp;ldquo;side effects&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">意味のあるWebアプリはすべて、複雑なロジックを実行する必要があります。通常、AJAXリクエストの作成などの非同期作業が含まれます。そのコードはもはや純粋にその入力の関数ではなく、外界との相互作用は&lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;「副作用」&lt;/a&gt;として知られています</target>
        </trans-unit>
        <trans-unit id="17a95b9c7d131a13dd7681ee829c7309078b3577" translate="yes" xml:space="preserve">
          <source>Any reducer passed to &lt;code&gt;combineReducers&lt;/code&gt; must satisfy these rules:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 渡されるすべてのレデューサーは、次のルールを満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="6fdbb15360b3088d82f5dfe1a14a15d468cb58cd" translate="yes" xml:space="preserve">
          <source>Any references to individual items should be done by storing the item's ID.</source>
          <target state="translated">個々のアイテムへの参照は、アイテムのIDを格納することで行う必要があります。</target>
        </trans-unit>
        <trans-unit id="206a7715eef6f00c93aebc49d2e9182d87517249" translate="yes" xml:space="preserve">
          <source>Apollo Client: GraphQL with React and Redux</source>
          <target state="translated">Apollo クライアント。GraphQL with React and Redux</target>
        </trans-unit>
        <trans-unit id="9005318bff4ea7c0d752cddae4ff458b6e1a0913" translate="yes" xml:space="preserve">
          <source>Are there any larger, &amp;ldquo;real&amp;rdquo; Redux projects?</source>
          <target state="translated">より大きな「実際の」Reduxプロジェクトはありますか？</target>
        </trans-unit>
        <trans-unit id="cc44e7f8ef0dbd0f0399aed6b078549d32a1bc08" translate="yes" xml:space="preserve">
          <source>Are written</source>
          <target state="translated">書かれている</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="49daae7bc3193b4ffbf057d1ce571f648d334335" translate="yes" xml:space="preserve">
          <source>Arrays of IDs should be used to indicate ordering.</source>
          <target state="translated">ID の配列は、順序を示すために使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="678560a52b48d8df9cc01483f2c09d287f1730ed" translate="yes" xml:space="preserve">
          <source>As an application grows, common patterns in reducer logic will start to emerge. You may find several parts of your reducer logic doing the same kinds of work for different types of data, and want to reduce duplication by reusing the same common logic for each data type. Or, you may want to have multiple &quot;instances&quot; of a certain type of data being handled in the store. However, the global structure of a Redux store comes with some trade-offs: it makes it easy to track the overall state of an application, but can also make it harder to &quot;target&quot; actions that need to update a specific piece of state, particularly if you are using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">アプリケーションが成長するにつれて、レデューサーロジックの一般的なパターンが出現し始めます。異なるタイプのデータに対して同じ種類の作業を実行しているレデューサーロジックのいくつかの部分があり、各データタイプに対して同じ共通ロジックを再利用することで重複を削減したい場合があります。または、ストアで処理されている特定のタイプのデータの複数の「インスタンス」が必要になる場合があります。ただし、Reduxストアのグローバル構造にはいくつかのトレードオフが伴います。これにより、アプリケーションの全体的な状態を簡単に追跡できるようになりますが、特定の状態を更新する必要があるアクションを「対象とする」ことが難しくなります。特に、 &lt;code&gt;combineReducers&lt;/code&gt; を使用している場合。</target>
        </trans-unit>
        <trans-unit id="7b8dfe1588c786f88cd39b5e2f752576b7bb0f10" translate="yes" xml:space="preserve">
          <source>As an example, let's say that we want to track multiple counters in our application, named A, B, and C. We define our initial &lt;code&gt;counter&lt;/code&gt; reducer, and we use &lt;code&gt;combineReducers&lt;/code&gt; to set up our state:</source>
          <target state="translated">例として、アプリケーション内のA、B、Cという名前の複数のカウンターを追跡するとします。最初の &lt;code&gt;counter&lt;/code&gt; レデューサーを定義し、 &lt;code&gt;combineReducers&lt;/code&gt; を使用して状態を設定します。</target>
        </trans-unit>
        <trans-unit id="709fd50216cd72e5e5a781b80b45c62c308c61de" translate="yes" xml:space="preserve">
          <source>As defined in &lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic&lt;/a&gt;, a &lt;em&gt;higher-order reducer&lt;/em&gt; is a function that takes a reducer function as an argument, and/or returns a new reducer function as a result. It can also be viewed as a &quot;reducer factory&quot;. &lt;code&gt;combineReducers&lt;/code&gt; is one example of a higher-order reducer. We can use this pattern to create specialized versions of our own reducer functions, with each version only responding to specific actions.</source>
          <target state="translated">&lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic&lt;/a&gt;で定義されているように、&lt;em&gt;高次のレデューサー&lt;/em&gt;は、レデューサー関数を引数として取る関数、または結果として新しいレデューサー関数を返す関数です。「還元剤工場」と見ることもできます。 &lt;code&gt;combineReducers&lt;/code&gt; は、高次レデューサーの一例です。このパターンを使用して、各バージョンが特定のアクションにのみ応答する、独自のレデューサー関数の特殊なバージョンを作成できます。</target>
        </trans-unit>
        <trans-unit id="fef475fd072b3bead2a85a3d7e365ffb13bfaca5" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, a Redux reducer function:</source>
          <target state="translated">で説明したように&lt;a href=&quot;../../basics/reducers&quot;&gt;レデューサー&lt;/a&gt;、Reduxのリデューサ機能：</target>
        </trans-unit>
        <trans-unit id="ef35726a994739e304113b383deb26575f5ff1ba" translate="yes" xml:space="preserve">
          <source>As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:</source>
          <target state="translated">アーキテクチャに関しては、Reduxは様々なプロジェクトやチームの規模に合わせてうまく機能するという逸話的な証拠があります。Reduxは現在、何百もの企業と何千もの開発者に利用されており、NPMから毎月数十万のインストールが行われています。ある開発者が報告しています。</target>
        </trans-unit>
        <trans-unit id="e814716838438ec84d1615becea35368a2e66458" translate="yes" xml:space="preserve">
          <source>As if this wasn't bad enough, consider the &lt;strong&gt;new requirements becoming common in front-end product development&lt;/strong&gt;. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;is it time to give up?&lt;/a&gt; The answer is &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">これで十分ではなかったかのように、&lt;strong&gt;新しい要件がフロントエンド製品開発で一般的になることを&lt;/strong&gt;考慮してください。開発者は、楽観的な更新、サーバー側のレンダリング、ルート遷移を実行する前のデータのフェッチなどを処理することが期待されています。私たちは、これまでに対処する必要がなかった複雑さを管理しようとしていることに気づき、必然的に質問&lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;をします。&lt;/a&gt;答えは&lt;em&gt;ノー&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="fbb977642e09fe68de908d000ae815bd23c6664f" translate="yes" xml:space="preserve">
          <source>As it continues through the iterations, &lt;code&gt;combineReducers&lt;/code&gt; will construct a new state object with the state slices returned from each reducer. This new state object may or may not be different from the current state object. It is here that &lt;code&gt;combineReducers&lt;/code&gt; uses shallow equality checking to determine whether the state has changed.</source>
          <target state="translated">反復処理を &lt;code&gt;combineReducers&lt;/code&gt; と、combineReducersは各レデューサーから返された状態スライスで新しい状態オブジェクトを構築します。この新しい状態オブジェクトは、現在の状態オブジェクトと異なる場合と異なる場合があります。ここでは、 &lt;code&gt;combineReducers&lt;/code&gt; が浅い等価チェックを使用して、状態が変化したかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="c31c6475cbfd62456b208b3c6e1e67d8fcfdab31" translate="yes" xml:space="preserve">
          <source>As it turns out, there's a useful utility called &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; that can make that process easier. It simply takes multiple reducers and runs &lt;code&gt;reduce()&lt;/code&gt; on them, passing the intermediate state values to the next reducer in line:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;結局のところ&lt;/a&gt;、そのプロセスをより簡単にすることができるreduce-reducersと呼ばれる便利なユーティリティがあります。単純に複数のレデューサーを受け取り、 &lt;code&gt;reduce()&lt;/code&gt; を実行して、中間の状態値を次のレデューサーに渡します。</target>
        </trans-unit>
        <trans-unit id="7abf8ce0941afdd199232022cabbf076e6057848" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;normalizingstateshape&quot;&gt;Normalizing State Shape&lt;/a&gt;, the Normalizr library is frequently used to transform nested response data into a normalized shape suitable for integration into the store. However, that doesn't address the issue of executing further updates to that normalized data as it's being used elsewhere in the application. There are a variety of different approaches that you can use, based on your own preference. We'll use the example of adding a new Comment to a Post.</source>
          <target state="translated">&lt;a href=&quot;normalizingstateshape&quot;&gt;状態の形状の正規化で説明した&lt;/a&gt;ように、Normalizrライブラリは、ネストされた応答データをストアへの統合に適した正規化された形状に変換するために頻繁に使用されます。ただし、それは、アプリケーションの他の場所で使用されているため、正規化されたデータに対してさらに更新を実行する問題には対処していません。自分の好みに応じて、さまざまな方法を使用できます。投稿に新しいコメントを追加する例を使用します。</target>
        </trans-unit>
        <trans-unit id="e4b60f1e31e4c57161fb7758305113397c7a5c3a" translate="yes" xml:space="preserve">
          <source>As our last step, we can now use Redux's built-in &lt;code&gt;combineReducers&lt;/code&gt; utility to handle the &quot;slice-of-state&quot; logic for our top-level app reducer. Here's the final result:</source>
          <target state="translated">最後のステップとして、Reduxの組み込み &lt;code&gt;combineReducers&lt;/code&gt; ユーティリティを使用して、最上位のアプリレデューサーの「状態のスライス」ロジックを処理できます。これが最終結果です：</target>
        </trans-unit>
        <trans-unit id="dc4496173ef998c4da8d0db366e9bb7a00db7fcd" translate="yes" xml:space="preserve">
          <source>As such, a shallow equality check of the props object returned from repeated calls to &lt;code&gt;mapStateToProps&lt;/code&gt; would always fail, as a new object would be returned each time.</source>
          <target state="translated">そのため、 &lt;code&gt;mapStateToProps&lt;/code&gt; の繰り返し呼び出しから返されるpropsオブジェクトの浅い等価性チェックは、毎回新しいオブジェクトが返されるため、常に失敗します。</target>
        </trans-unit>
        <trans-unit id="1cf23dc07f110dd0af0f0a020f2623e1f59b9566" translate="yes" xml:space="preserve">
          <source>As such, even though the values of that new object have not changed, the wrapped component will always be re-rendered,</source>
          <target state="translated">このように、新しいオブジェクトの値が変更されていなくても、ラップされたコンポーネントは常に再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="a041a5b277767ea9c2a31b986eec75aca67d859c" translate="yes" xml:space="preserve">
          <source>As the requirements for JavaScript single-page applications have become increasingly complicated, &lt;strong&gt;our code must manage more state than ever before&lt;/strong&gt;. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.</source>
          <target state="translated">JavaScriptシングルページアプリケーションの要件がますます複雑になるにつれて、&lt;strong&gt;コードでこれまで以上に多くの状態を管理する必要があり&lt;/strong&gt;ます。この状態には、サーバーの応答とキャッシュされたデータ、およびサーバーにまだ永続化されていないローカルで作成されたデータが含まれます。アクティブなルート、選択されたタブ、スピナー、ページネーションコントロールなどを管理する必要があるため、UI状態も複雑さを増しています。</target>
        </trans-unit>
        <trans-unit id="a14d76fefd06040ae416dab582f026209ce57474" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;ve seen, the values in the mutable object returned by the selector function may have changed, but the object itself has not, and shallow equality checking only compares the objects themselves, not their values.</source>
          <target state="translated">これまで見てきたように、selector関数によって返される変更可能なオブジェクトの値は変更されている可能性がありますが、オブジェクト自体は変更されておらず、浅い等価チェックではオブジェクト自体のみが比較され、値は比較されません。</target>
        </trans-unit>
        <trans-unit id="81dc352109a60e2a91dd724ab47b76ebe7decc71" translate="yes" xml:space="preserve">
          <source>As with several other questions, it is &lt;em&gt;possible&lt;/em&gt; to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.</source>
          <target state="translated">他のいくつかの質問と同様に、ページ内に複数の異なるReduxストアを作成することは&lt;em&gt;可能です&lt;/em&gt;が、意図されたパターンは1つのストアのみを持つことです。ストアを1つにすると、Redux DevToolsを使用できるようになり、データの永続化と再水和が簡単になり、サブスクリプションロジックが簡略化されます。</target>
        </trans-unit>
        <trans-unit id="c02308c61548a99934707da188eb85ef748a5cb4" translate="yes" xml:space="preserve">
          <source>As with state, serializable actions enable several of Redux's defining features, such as time travel debugging, and recording and replaying actions. Using something like a &lt;code&gt;Symbol&lt;/code&gt; for the &lt;code&gt;type&lt;/code&gt; value or using &lt;code&gt;instanceof&lt;/code&gt; checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it &lt;em&gt;is&lt;/em&gt; okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.</source>
          <target state="translated">状態と同様に、シリアライズ可能なアクションは、タイムトラベルデバッグ、アクションの記録と再生など、Reduxの定義機能のいくつかを有効にします。何か使い方 &lt;code&gt;Symbol&lt;/code&gt; 用 &lt;code&gt;type&lt;/code&gt; 値または使用して &lt;code&gt;instanceof&lt;/code&gt; は自分自身がそれを破るアクションのチェックを。文字列はシリアライズ可能で、簡単に自己記述的であるため、より良い選択です。アクションがミドルウェアでの使用を目的としている場合、アクションでシンボル、プロミス、またはその他のシリアル化不可能な値を使用して&lt;em&gt;も&lt;/em&gt;問題ないことに注意してください。アクションは、実際にストアに到達し、レデューサーに渡されるまでにシリアライズ可能である必要があります。</target>
        </trans-unit>
        <trans-unit id="25d90438423a5d564145ee745315cbd04ef8f5d9" translate="yes" xml:space="preserve">
          <source>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</source>
          <target state="translated">Storesを書き換えていくうちに、APIをStore内で取得したり、Store内でアクションをトリガーしたりするような、特定のFluxアンチパターンを避ける必要があることに気づくでしょう。レデューサーをベースにしたコードに移植することで、あなたのFluxコードはより簡単になります。</target>
        </trans-unit>
        <trans-unit id="42a2c484c73d6daa09647c6197ccf515d0e0786e" translate="yes" xml:space="preserve">
          <source>As your app grows more complex, you'll want to split your &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; into separate functions, each managing independent parts of the &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt;.</source>
          <target state="translated">アプリがより複雑になるにつれて、&lt;a href=&quot;../glossary#reducer&quot;&gt;削減関数&lt;/a&gt;を個別の関数に分割し、それぞれが&lt;a href=&quot;../glossary#state&quot;&gt;状態の&lt;/a&gt;独立した部分を管理するようにします。</target>
        </trans-unit>
        <trans-unit id="1cff388be99f52b685be17cb7f6b80f2a1084bc0" translate="yes" xml:space="preserve">
          <source>Ask around on the &lt;strong&gt;#redux&lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord channel, or &lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;create an issue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;#redux &lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discordチャネルで質問するか&lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;、問題を作成してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd90ea9965306b973ad750889f0a4b9e3769518a" translate="yes" xml:space="preserve">
          <source>Associating items in relationships</source>
          <target state="translated">関係性のある項目の連想</target>
        </trans-unit>
        <trans-unit id="f243e92a1117cab31114a44424d26658eeb2d079" translate="yes" xml:space="preserve">
          <source>Assuming actual changes need to occur, it needs to create new objects and arrays with the updated data and return those</source>
          <target state="translated">実際に変更が必要になった場合、更新されたデータで新しいオブジェクトと配列を作成し、それらを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="db37f55867798c63094a75db06886660e91436bf" translate="yes" xml:space="preserve">
          <source>Async</source>
          <target state="translated">Async</target>
        </trans-unit>
        <trans-unit id="90722b7f9d2e813acdd905ce6a728ce981a33ec4" translate="yes" xml:space="preserve">
          <source>Async Action</source>
          <target state="translated">非同期動作</target>
        </trans-unit>
        <trans-unit id="167b050aac66ff4723e2e1e409f28704074758c3" translate="yes" xml:space="preserve">
          <source>Async Action Creators</source>
          <target state="translated">非同期アクション クリエイター</target>
        </trans-unit>
        <trans-unit id="91eebc38df11fd82beeb837efd263578c88fd532" translate="yes" xml:space="preserve">
          <source>Async Actions</source>
          <target state="translated">非同期アクション</target>
        </trans-unit>
        <trans-unit id="27f1c859609130246bfcce156061b4ffce4ac287" translate="yes" xml:space="preserve">
          <source>Async Flow</source>
          <target state="translated">非同期フロー</target>
        </trans-unit>
        <trans-unit id="19c040239385214a8e17389f47ba7d20d7ef489c" translate="yes" xml:space="preserve">
          <source>Async State Fetching</source>
          <target state="translated">非同期状態フェッチ</target>
        </trans-unit>
        <trans-unit id="886ac17e24bc12f98154c913a55fad29ab13e686" translate="yes" xml:space="preserve">
          <source>Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.</source>
          <target state="translated">非同期アクション クリエイターは、サーバー レンダリングに特に便利です。ストアを作成し、アプリのセクション全体のデータを取得するために他の非同期アクション クリエイターをディスパッチする単一の非同期アクション クリエイターをディスパッチし、それが返すプロミスが完了した後にのみレンダリングすることができます。そうすれば、ストアはレンダリング前に必要な状態ですでに潤っています。</target>
        </trans-unit>
        <trans-unit id="b1b1c578f34b8d9eb909781b58a2f94d6f371c68" translate="yes" xml:space="preserve">
          <source>Asynchronous middleware like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; wraps the store's &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in the chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;や&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;などの非同期ミドルウェアは、ストアの&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;メソッドをラップし、関数やPromiseなどのアクション以外のものをディスパッチできるようにします。使用するミドルウェアは、ディスパッチしたものを解釈し、チェーン内の次のミドルウェアにアクションを渡すことができます。たとえば、Promiseミドルウェアは、Promiseをインターセプトし、各Promiseに応じて非同期で開始/終了アクションのペアをディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="2eb0dcef5fba599c316c78c309f567d83281170d" translate="yes" xml:space="preserve">
          <source>At its core, Redux is really a fairly simple design pattern: all your &quot;write&quot; logic goes into a single function, and the only way to run that logic is to give Redux a plain object that describes something that has happened. The Redux store calls that write logic function and passes in the current state tree and the descriptive object, the write logic function returns some new state tree, and the Redux store notifies any subscribers that the state tree has changed.</source>
          <target state="translated">その核心部分では、Redux は非常にシンプルな設計パターンです。「書き込み」ロジックはすべて単一の関数に格納され、そのロジックを実行する唯一の方法は、何かが起こったことを記述したプレーンオブジェクトを Redux に渡すことです。Redux ストアはその書き込みロジック関数を呼び出し、現在のステートツリーと記述オブジェクトを渡し、書き込みロジック関数は新しいステートツリーを返し、Redux ストアはステートツリーが変更されたことをサブスクライバに通知します。</target>
        </trans-unit>
        <trans-unit id="30c55c70af3e1a8f861110d1c7eecd86c69c1d55" translate="yes" xml:space="preserve">
          <source>Attempt #1: Logging Manually</source>
          <target state="translated">試み1:手動でログを取る</target>
        </trans-unit>
        <trans-unit id="cf041cf27718908810ead0d2f91d0171d49b9b85" translate="yes" xml:space="preserve">
          <source>Attempt #2: Wrapping Dispatch</source>
          <target state="translated">試み2:ラッピング派遣</target>
        </trans-unit>
        <trans-unit id="77db9a04efffdb3012b23e3322da962156c4a860" translate="yes" xml:space="preserve">
          <source>Attempt #3: Monkeypatching Dispatch</source>
          <target state="translated">試み3:モンキー派遣</target>
        </trans-unit>
        <trans-unit id="2f2148510a51d59cf3a8e564eed4a0c3c1d86f5f" translate="yes" xml:space="preserve">
          <source>Attempt #4: Hiding Monkeypatching</source>
          <target state="translated">試みその4:モンキーパッチを隠す</target>
        </trans-unit>
        <trans-unit id="ca2cc7378629716a29578d9874dd2b25fc5a8c9d" translate="yes" xml:space="preserve">
          <source>Attempt #5: Removing Monkeypatching</source>
          <target state="translated">試み#5。モンキーパッチの除去</target>
        </trans-unit>
        <trans-unit id="73546da71df70edaa82a5330e2ce70fd8845ff54" translate="yes" xml:space="preserve">
          <source>Attempt #6: Na&amp;iuml;vely Applying the Middleware</source>
          <target state="translated">試行＃6：ミドルウェアの単純な適用</target>
        </trans-unit>
        <trans-unit id="5678d8ff8964be781758624218ca67e6eccfdd1b" translate="yes" xml:space="preserve">
          <source>Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:</source>
          <target state="translated">認証は、実際のアプリケーションには不可欠です。認証を行う際には、アプリケーションをどのように編成しても何も変わらないことを心に留めておかなければなりません。これは比較的簡単なことです。</target>
        </trans-unit>
        <trans-unit id="9566fa2885d46ca757c9af88ac84f85bb1d56e51" translate="yes" xml:space="preserve">
          <source>Authentication with JWT by Auth0</source>
          <target state="translated">Auth0によるJWTによる認証</target>
        </trans-unit>
        <trans-unit id="122e59e628a93b853a47af4cfa8433a11386c564" translate="yes" xml:space="preserve">
          <source>Avoiding Accidental Complexity When Structuring Your App State</source>
          <target state="translated">アプリの状態を構造化する際の偶発的な複雑さの回避</target>
        </trans-unit>
        <trans-unit id="3e81d3aaff1562199dada2cff7c06a38e4c2294f" translate="yes" xml:space="preserve">
          <source>Avoiding functions and statements that mutate state</source>
          <target state="translated">状態を変異させる関数やステートメントの回避</target>
        </trans-unit>
        <trans-unit id="9aae17642d53cdbcf10d6748c5122f8d3443a256" translate="yes" xml:space="preserve">
          <source>Aware of Redux</source>
          <target state="translated">Reduxを意識して</target>
        </trans-unit>
        <trans-unit id="9410a51d85ad489b23f91e3413ee16c00a3aada5" translate="yes" xml:space="preserve">
          <source>Backbone's model layer is quite different from Redux, so we don't suggest mixing them. If possible, it is best that you rewrite your app's model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use &lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</source>
          <target state="translated">バックボーンのモデルレイヤーはReduxとはかなり異なるため、それらを混合することはお勧めしません。可能であれば、BackboneをReduxに接続するのではなく、アプリのモデルレイヤーを最初から書き直すことをお勧めします。ただし、書き換えが実行できない場合は、&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt;を使用して段階的に移行し、Reduxストアをバックボーンモデルおよびコレクションと同期させることができます。</target>
        </trans-unit>
        <trans-unit id="ed27f94322cfd2585f69fd4faaf883777c565fb1" translate="yes" xml:space="preserve">
          <source>Baobab</source>
          <target state="translated">Baobab</target>
        </trans-unit>
        <trans-unit id="22e42af3c93af18697862c91d897419ff315b287" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure</source>
          <target state="translated">基本的な減速機の構造</target>
        </trans-unit>
        <trans-unit id="9f6c9bee78e234130cb00e796115605ccb9c9356" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure and State Shape</source>
          <target state="translated">基本的な減速機の構造と状態の形状</target>
        </trans-unit>
        <trans-unit id="48ecb36ff00519ea4d9111bf2ac2c38ce3e8ee19" translate="yes" xml:space="preserve">
          <source>Basic State Shape</source>
          <target state="translated">基本状態の形状</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="67b560207b812ce235458b82ba3b3eea9cb85612" translate="yes" xml:space="preserve">
          <source>Basics: Reducers</source>
          <target state="translated">基本的なこと。レジューサー</target>
        </trans-unit>
        <trans-unit id="a2961743fb82ac508ead6cd89af32cac336e899e" translate="yes" xml:space="preserve">
          <source>Basics: Store</source>
          <target state="translated">基本的なこと。ストア</target>
        </trans-unit>
        <trans-unit id="ea6b5a053fcc90c8ddd2441e52e91ec4ca304fa6" translate="yes" xml:space="preserve">
          <source>Basics: Usage with React</source>
          <target state="translated">基本的なこと。Reactでの使い方</target>
        </trans-unit>
        <trans-unit id="ef57ae03011c7a88309c71ac3de4cd66803fca0f" translate="yes" xml:space="preserve">
          <source>Be aware that any &lt;code&gt;fetch&lt;/code&gt; polyfill assumes a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel's ES6 polyfill in your entry point before any other code runs:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; ポリフィルは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;ポリフィルがすでに存在していることを前提としています。Promiseポリフィルがあることを確認する最も簡単な方法は、他のコードを実行する前に、エントリポイントでBabelのES6ポリフィルを有効にすることです。</target>
        </trans-unit>
        <trans-unit id="8836be1ed6d14271d3616086c1165b69f0c93f5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;combineReducers&lt;/code&gt; expects an object, we can put all top-level reducers into a separate file, &lt;code&gt;export&lt;/code&gt; each reducer function, and use &lt;code&gt;import * as reducers&lt;/code&gt; to get them as an object with their names as the keys:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; はオブジェクトを想定しているため、トップレベルのすべてのレデューサーを個別のファイルに入れ、各レデューサー関数を &lt;code&gt;export&lt;/code&gt; し、reduces &lt;code&gt;import * as reducers&lt;/code&gt; 使用して、名前としてキーを持つオブジェクトとして取得できます。</target>
        </trans-unit>
        <trans-unit id="e147dcc69ce5b11254e20a3d4069c3882333d6b2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;import *&lt;/code&gt; is still new syntax, we don't use it anymore in the documentation to avoid &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;confusion&lt;/a&gt;, but you may encounter it in some community examples.</source>
          <target state="translated">ので &lt;code&gt;import *&lt;/code&gt; まだ新しい構文では、我々は避けるために、ドキュメントにもうそれを使用しない&lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;混乱を&lt;/a&gt;していますが、いくつかのコミュニティの例では、それが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="aaded217a4fa5a0be4aafbaa6515cc015511e79a" translate="yes" xml:space="preserve">
          <source>Because APIs frequently send back data in a nested form, that data needs to be transformed into a normalized shape before it can be included in the state tree. The &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr&lt;/a&gt; library is usually used for this task. You can define schema types and relations, feed the schema and the response data to Normalizr, and it will output a normalized transformation of the response. That output can then be included in an action and used to update the store. See the Normalizr documentation for more details on its usage.</source>
          <target state="translated">APIはネストされた形式でデータを頻繁に送り返すため、そのデータを状態ツリーに含める前に、正規化された形状に変換する必要があります。&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizrの&lt;/a&gt;ライブラリーは、通常、この作業のために使用されています。スキーマのタイプと関係を定義し、スキーマと応答データをNormalizrにフィードすると、応答の正規化された変換が出力されます。次に、その出力をアクションに含め、ストアを更新するために使用できます。使用法の詳細については、Normalizrのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="36a6dc2449dbb96d53ee9fa9e5275f29a7f8733e" translate="yes" xml:space="preserve">
          <source>Because React-Redux performs a shallow check on the root state object to determine if its wrapped components need re-rendering or not, it will not be able to detect the state mutation, and so will not trigger a re-rendering.</source>
          <target state="translated">React-Redux は、そのラップされたコンポーネントが再レンダリングが必要かどうかを判断するために、ルートステートオブジェクトに対して浅いチェックを行うため、ステートの変異を検出することができず、再レンダリングのトリガーにはなりません。</target>
        </trans-unit>
        <trans-unit id="3b4a1ac2348c56cde050b358a3589a1c8f14e121" translate="yes" xml:space="preserve">
          <source>Because a store is not an instance, but rather a plain-object collection of functions, copies can be easily created and modified without mutating the original store. There is an example in &lt;a href=&quot;api/compose&quot;&gt;&lt;code&gt;compose&lt;/code&gt;&lt;/a&gt; documentation demonstrating that.</source>
          <target state="translated">ストアはインスタンスではなく、関数のプレーンオブジェクトコレクションなので、元のストアを変更することなく、コピーを簡単に作成および変更できます。それを示す&lt;a href=&quot;api/compose&quot;&gt; &lt;code&gt;compose&lt;/code&gt; &lt;/a&gt;ドキュメントに例があります。</target>
        </trans-unit>
        <trans-unit id="efed700df65d7fe9ccdceab1e7043b1b623a8ecf" translate="yes" xml:space="preserve">
          <source>Because each item is only defined in one place, we don't have to try to make changes in multiple places if that item is updated.</source>
          <target state="translated">各項目は一箇所でしか定義されていないので、その項目が更新された場合に複数箇所で変更を試みる必要がありません。</target>
        </trans-unit>
        <trans-unit id="a5b2b72f48655aebb62d18b4c1e639b210169092" translate="yes" xml:space="preserve">
          <source>Because it is cumbersome to apply functions to &lt;code&gt;createStore()&lt;/code&gt; before using it, &lt;code&gt;createStore()&lt;/code&gt; accepts an optional last argument to specify such functions.</source>
          <target state="translated">関数を使用する前に &lt;code&gt;createStore()&lt;/code&gt; に関数を適用するのは面倒なので、 &lt;code&gt;createStore()&lt;/code&gt; はオプションの最後の引数を受け入れて、そのような関数を指定します。</target>
        </trans-unit>
        <trans-unit id="7374d49a3a0384818d249cff5d9279f55237ab50" translate="yes" xml:space="preserve">
          <source>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking.</source>
          <target state="translated">Reduxのコードはほとんどが関数であり、純粋なものが多いので、モックしなくてもテストしやすいです。</target>
        </trans-unit>
        <trans-unit id="f2db4769be19da76af1b03eaa76cbae8155e656b" translate="yes" xml:space="preserve">
          <source>Because of these rules, it's important that the following core concepts are fully understood before moving on to other specific techniques for organizing Redux reducers:</source>
          <target state="translated">これらの規則があるため、Redux レデューサを整理するための他の具体的なテクニックに移る前に、以下のコアコンセプトを十分に理解しておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="1a3e08abcf6f4447aa880f7591ce54acac1d67d8" translate="yes" xml:space="preserve">
          <source>Because of this, the recommended approach to managing relational or nested data in a Redux store is to treat a portion of your store as if it were a database, and keep that data in a &lt;em&gt;normalized&lt;/em&gt; form.</source>
          <target state="translated">このため、Reduxストアでリレーショナルデータまたはネストされたデータを管理するための推奨されるアプローチは、ストアの一部をデータベースのように扱い、そのデータを&lt;em&gt;正規化された&lt;/em&gt;形式で保持することです。</target>
        </trans-unit>
        <trans-unit id="2f6e614f93198c638fa57d23714abc7c8a4c5fe3" translate="yes" xml:space="preserve">
          <source>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</source>
          <target state="translated">クライアント側では進行中のコードを実行するため、空の初期状態から開始し、必要な状態を必要に応じて時間をかけて取得することができます。サーバー側では、レンダリングは同期的に行われ、ビューをレンダリングするのは1回だけです。リクエスト中に初期状態をコンパイルできる必要があり、入力に反応して外部の状態(APIやデータベースからの状態など)を取得しなければなりません。</target>
        </trans-unit>
        <trans-unit id="4dad2f7397c12d16dc5080663b0fb4ff158a875b" translate="yes" xml:space="preserve">
          <source>Because the data from B's slice is already in the action, the parent reducer doesn't have to do anything special to make that data available to &lt;code&gt;sliceReducerA&lt;/code&gt;.</source>
          <target state="translated">Bのスライスからのデータはすでにアクションにあるため、親のレデューサーは、そのデータを &lt;code&gt;sliceReducerA&lt;/code&gt; で利用できるようにするために特別なことを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="800eb8a2fa295362af6cbe9bc4b63ea94371aa6a" translate="yes" xml:space="preserve">
          <source>Because the store represents the core of your application, you should &lt;strong&gt;define your state shape in terms of your domain data and app state, not your UI component tree&lt;/strong&gt;. As an example, a shape of &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; would be a bad idea, because the idea of &quot;todos&quot; is central to the whole application, not just a single part of the UI. The &lt;code&gt;todos&lt;/code&gt; slice should be at the top of the state tree instead.</source>
          <target state="translated">ストアはアプリケーションの中核を表すため、&lt;strong&gt;UIコンポーネントツリーではなく、ドメインデータとアプリの状態の観点から状態の形&lt;/strong&gt;を&lt;strong&gt;定義する&lt;/strong&gt;必要が&lt;strong&gt;あります&lt;/strong&gt;。例として、 &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; の形状は、「todos」の概念がUIの単一の部分だけではなく、アプリケーション全体の中心であるため、悪い考えです。 &lt;code&gt;todos&lt;/code&gt; スライスではなく、状態ツリーの最上部にあるべきです。</target>
        </trans-unit>
        <trans-unit id="67eccbeca2c6be1c80e66072cbdb7d5d3d171333" translate="yes" xml:space="preserve">
          <source>Because this pattern is so common, Redux provides the &lt;code&gt;combineReducers&lt;/code&gt; utility to implement that behavior. It is an example of a &lt;em&gt;higher-order reducer&lt;/em&gt;, which takes an object full of slice reducer functions, and returns a new reducer function.</source>
          <target state="translated">このパターンは非常に一般的であるため、Reduxはその動作を実装するための &lt;code&gt;combineReducers&lt;/code&gt; ユーティリティを提供しています。これは、&lt;em&gt;高次レデューサーの&lt;/em&gt;例で、スライスレデューサー関数でいっぱいのオブジェクトを取得し、新しいレデューサー関数を返します。</target>
        </trans-unit>
        <trans-unit id="18cc4aaf99d902742f5080c22e4e5772ca05908e" translate="yes" xml:space="preserve">
          <source>Because we call &lt;code&gt;res.send()&lt;/code&gt; inside of the callback, the server will hold open the connection and won't send any data until that callback executes. You'll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</source>
          <target state="translated">コールバック内で &lt;code&gt;res.send()&lt;/code&gt; を呼び出すため、サーバーは接続を開いたままにし、そのコールバックが実行されるまでデータを送信しません。新しいAPI呼び出しの結果として、各サーバー要求に500ミリ秒の遅延が追加されていることがわかります。より高度な使用法では、不適切な応答やタイムアウトなど、APIのエラーを適切に処理します。</target>
        </trans-unit>
        <trans-unit id="caa8ca1f396e8cbad0408af4d219889981520bc2" translate="yes" xml:space="preserve">
          <source>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</source>
          <target state="translated">ユーザー生成コンテンツ (UGC)と入力に依存するコードをより多く導入したため、アプリケーションの攻撃範囲が広がりました。クロスサイトスクリプティング(XSS)攻撃やコードインジェクションのようなものを防ぐために、入力が適切にサニタイズされていることを確認することは、どのようなアプリケーションにとっても重要です。</target>
        </trans-unit>
        <trans-unit id="89b5658d0d258fae8a0f70dae9f8f133bd91b874" translate="yes" xml:space="preserve">
          <source>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it's a good idea to use a helper like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;, &lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt;, or even a library like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; that has native support for deep updates. Just remember to never assign to anything inside the &lt;code&gt;state&lt;/code&gt; unless you clone it first.</source>
          <target state="translated">変更に頼らずに配列内の特定の項目を更新したいので、インデックスの項目を除いて同じ項目で新しい配列を作成する必要があります。このような操作を頻繁に記述している場合は、&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;、&lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt;などのヘルパー、またはディープアップデートをネイティブでサポートする&lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;などのライブラリを使用することをお勧めします。最初にクローンを作成する場合を除き、 &lt;code&gt;state&lt;/code&gt; 内部には何も割り当てないでください。</target>
        </trans-unit>
        <trans-unit id="455e818de94ba32708285358e0d09ee9d740229c" translate="yes" xml:space="preserve">
          <source>Because we're treating a portion of our Redux store as a &quot;database&quot;, many of the principles of database design also apply here as well. For example, if we have a many-to-many relationship, we can model that using an intermediate table that stores the IDs of the corresponding items (often known as a &quot;join table&quot; or an &quot;associative table&quot;). For consistency, we would probably also want to use the same &lt;code&gt;byId&lt;/code&gt; and &lt;code&gt;allIds&lt;/code&gt; approach that we used for the actual item tables, like this:</source>
          <target state="translated">Reduxストアの一部を「データベース」として扱っているため、データベース設計の原則の多くがここでも適用されます。たとえば、多対多の関係がある場合は、対応するアイテムのIDを格納する中間テーブル（「結合テーブル」または「連想テーブル」と呼ばれることが多い）を使用してモデル化できます。一貫性を &lt;code&gt;allIds&lt;/code&gt; ために、次のように、実際のアイテムテーブルに使用したのと同じ &lt;code&gt;byId&lt;/code&gt; およびallIdsアプローチも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d1304b4245c2ff85f0675fea297cb7677812a916" translate="yes" xml:space="preserve">
          <source>Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;, take string paths for commands:</source>
          <target state="translated">不変の更新コードを作成するのは面倒になる可能性があるため、プロセスを抽象化しようとするユーティリティライブラリが多数あります。これらのライブラリは、APIと使用法は異なりますが、これらはすべて、これらの更新をより短く簡潔な方法で作成しようとします。&lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutableの&lt;/a&gt;ように、コマンドに文字列パスを使用するものもあります。</target>
        </trans-unit>
        <trans-unit id="9d3e7f54e625439ca3447fdc7a9117ae5fab1524" translate="yes" xml:space="preserve">
          <source>Because you must access your data via Immutable.JS&amp;rsquo;s own &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;getIn()&lt;/code&gt; methods, you can no longer use JavaScript&amp;rsquo;s destructuring operator (or the proposed Object spread operator), making your code more verbose.</source>
          <target state="translated">Immutable.JSの独自の &lt;code&gt;get()&lt;/code&gt; および &lt;code&gt;getIn()&lt;/code&gt; メソッドを介してデータにアクセスする必要があるため、JavaScriptの非構造化演算子（または提案されたオブジェクトスプレッド演算子）を使用できなくなり、コードがより冗長になります。</target>
        </trans-unit>
        <trans-unit id="1437822723995215deb0d2e2fac29d0d0f12fcf2" translate="yes" xml:space="preserve">
          <source>Before Proceeding Further</source>
          <target state="translated">さらに進む前に</target>
        </trans-unit>
        <trans-unit id="8d6d48764a855d1815031363486f3cea75e828c9" translate="yes" xml:space="preserve">
          <source>Before creating a UI for our todo app, we will take a detour to see &lt;a href=&quot;dataflow&quot;&gt;how the data flows in a Redux application&lt;/a&gt;.</source>
          <target state="translated">todoアプリのUIを作成する前に、迂回し&lt;a href=&quot;dataflow&quot;&gt;て、Reduxアプリケーションでのデータの流れ&lt;/a&gt;を確認します。</target>
        </trans-unit>
        <trans-unit id="4e97a45859979361b3d87b280bcc08eee9084a8f" translate="yes" xml:space="preserve">
          <source>Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.</source>
          <target state="translated">ネットワークリクエストと一緒にアクションをディスパッチする詳細に入る前に、上で定義したアクションのためのレデューサを書きます。</target>
        </trans-unit>
        <trans-unit id="89cb49f87c14fc3ef664ffd5fd8fb507d546a513" translate="yes" xml:space="preserve">
          <source>Before integrating React Router, we need to configure our development server. Indeed, our development server may be unaware of the declared routes in React Router configuration. For example, if you access &lt;code&gt;/todos&lt;/code&gt; and refresh, your development server needs to be instructed to serve &lt;code&gt;index.html&lt;/code&gt; because it is a single-page app. Here's how to enable this with popular development servers.</source>
          <target state="translated">React Routerを統合する前に、開発サーバーを構成する必要があります。実際、開発サーバーは、React Router構成で宣言されたルートを認識していない場合があります。たとえば、 &lt;code&gt;/todos&lt;/code&gt; にアクセスして更新する場合、開発サーバーは単一ページアプリであるため、 &lt;code&gt;index.html&lt;/code&gt; を提供するように指示する必要があります。一般的な開発サーバーでこれを有効にする方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f29fca44a9a66689242d9b6ac45e9273f69c5781" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure you have worked through the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt; and understand &lt;a href=&quot;../basics/reducers&quot;&gt;reducer composition&lt;/a&gt; well. This recipe will build on top of the example described in the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">先に進む前に、&lt;a href=&quot;../basics/index&quot;&gt;基本的なチュートリアルに&lt;/a&gt;取り組み、&lt;a href=&quot;../basics/reducers&quot;&gt;レデューサーの構成を&lt;/a&gt;よく理解していることを確認してください。このレシピは、&lt;a href=&quot;../basics/index&quot;&gt;基本チュートリアルで&lt;/a&gt;説明されている例の上に構築されます。</target>
        </trans-unit>
        <trans-unit id="f7d28bda5a65bfffaaaaaeb2efbace54d5ae5ed7" translate="yes" xml:space="preserve">
          <source>Below is a sub-app's root connected component. As usual, it can render more components, connected or not, as children. Usually we'd render it in &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; and be done with it.</source>
          <target state="translated">以下は、サブアプリのルート接続コンポーネントです。通常のように、接続されているかどうかに関係なく、子としてより多くのコンポーネントをレンダリングできます。通常は &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; でレンダリングし、それで終わります。</target>
        </trans-unit>
        <trans-unit id="2e9f60bf8e76871398ccbe5dae2fb65d17f44468" translate="yes" xml:space="preserve">
          <source>Below our imports, let's use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt; to declare &lt;code&gt;SHOW_ALL&lt;/code&gt;:</source>
          <target state="translated">インポートの下で、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt;を使用して &lt;code&gt;SHOW_ALL&lt;/code&gt; を宣言しましょう。</target>
        </trans-unit>
        <trans-unit id="f1091ed2655d47790d04e490d5a912d61726fb58" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 超えて</target>
        </trans-unit>
        <trans-unit id="6b9a230925015b13c4b708f594107fd333941631" translate="yes" xml:space="preserve">
          <source>Beyond combineReducers</source>
          <target state="translated">コンバインを超えて</target>
        </trans-unit>
        <trans-unit id="edb5455f2581d21229bb831350698f3307569b49" translate="yes" xml:space="preserve">
          <source>Beyond that, Redux does not really care how you actually structure your logic inside that reducer function, as long as it obeys those basic rules. This is both a source of freedom and a source of confusion. However, there are a number of common patterns that are widely used when writing reducers, as well as a number of related topics and concepts to be aware of. As an application grows, these patterns play a crucial role in managing reducer code complexity, handling real-world data, and optimizing UI performance.</source>
          <target state="translated">それ以上に、Reduxは、reducer関数の中で実際にどのようにロジックを構造化するかは、基本的なルールに従う限り、あまり気にしません。これは、自由の源であると同時に、混乱の源でもあります。しかし、レデューサを書く際に広く使われている共通のパターンがいくつかあり、関連するトピックや概念にも注意が必要です。アプリケーションが成長するにつれて、これらのパターンは、レデューサーのコードの複雑さを管理したり、実世界のデータを処理したり、UIのパフォーマンスを最適化したりする上で重要な役割を果たします。</target>
        </trans-unit>
        <trans-unit id="71ce0037a118cd7c3ccf4f303af279bf29aedd37" translate="yes" xml:space="preserve">
          <source>Bill Fisher, author of Flux documentation</source>
          <target state="translated">ビル・フィッシャー、FLUXドキュメンテーションの著者</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="5d13d6793ab60c41828ba3fe82788c57381b56b3" translate="yes" xml:space="preserve">
          <source>Both Redux and React-Redux employ &lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;shallow equality checking&lt;/a&gt;. In particular:</source>
          <target state="translated">ReduxとReact-Reduxはどちらも、&lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;浅い等価チェックを&lt;/a&gt;採用しています。特に：</target>
        </trans-unit>
        <trans-unit id="58fcb9748d292f2d6edabc1dd2871e078a69f72c" translate="yes" xml:space="preserve">
          <source>Breaking down a complex process into smaller, more understandable parts is usually described with the term &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;functional decomposition&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;. This term and concept can be applied generically to any code. However, in Redux it is &lt;em&gt;very&lt;/em&gt; common to structure reducer logic using approach #3, where update logic is delegated to other functions based on slice of state. Redux refers to this concept as &lt;strong&gt;&lt;em&gt;reducer composition&lt;/em&gt;&lt;/strong&gt;, and it is by far the most widely-used approach to structuring reducer logic. In fact, it's so common that Redux includes a utility function called &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, which specifically abstracts the process of delegating work to other reducer functions based on slices of state. However, it's important to note that it is not the &lt;em&gt;only&lt;/em&gt; pattern that can be used. In fact, it's entirely possible to use all three approaches for splitting up logic into functions, and usually a good idea as well. The &lt;a href=&quot;refactoringreducersexample&quot;&gt;Refactoring Reducers&lt;/a&gt; section shows some examples of this in action.</source>
          <target state="translated">複雑なプロセスをより小さく理解しやすい部分に&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;分解すること&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;は、通常、&lt;strong&gt;&lt;em&gt;機能分解&lt;/em&gt;&lt;/strong&gt;という用語で説明されます。この用語と概念は、あらゆるコードに一般的に適用できます。ただし、Reduxでは、アプローチ＃3を使用してレデューサーロジックを構造化することは&lt;em&gt;非常に&lt;/em&gt;一般的です。アプローチ3では、更新ロジックが状態のスライスに基づいて他の関数に委任されます。 Reduxはこの概念を&lt;strong&gt;&lt;em&gt;レデューサーコンポジション&lt;/em&gt;&lt;/strong&gt;と呼び、レデューサーロジックを構築するためにこれまでで最も広く使用されているアプローチです。実際、Reduxに&lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;と呼ばれるユーティリティ関数が含まれていることは非常に一般的です。ただし、それは&lt;em&gt;&lt;/em&gt;使用できるパターン&lt;em&gt;のみ&lt;/em&gt;。実際、ロジックを関数に分割するために3つのアプローチすべてを使用することは完全に可能であり、通常は同様に良いアイデアです。&lt;a href=&quot;refactoringreducersexample&quot;&gt;リファクタリングレデューサー&lt;/a&gt;セクションでは、この動作のいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="d1a2bc21cb4d822c367054d8beedc9e473cb922f" translate="yes" xml:space="preserve">
          <source>Breaks object references, causing poor performance</source>
          <target state="translated">オブジェクト参照が壊れてパフォーマンスが低下する</target>
        </trans-unit>
        <trans-unit id="2ef955a1c06a7555c0b9124c858d0b7015c595f2" translate="yes" xml:space="preserve">
          <source>Build an Image Gallery Using Redux Saga</source>
          <target state="translated">Redux Sagaを使った画像ギャラリーの構築</target>
        </trans-unit>
        <trans-unit id="044820df0cc9603893652b00eab09f2633843854" translate="yes" xml:space="preserve">
          <source>Building Efficient UI with React and Redux</source>
          <target state="translated">ReactとReduxで効率的なUIを構築する</target>
        </trans-unit>
        <trans-unit id="52676a6b3cadf32f94e36a184ab697e39fb7e4cf" translate="yes" xml:space="preserve">
          <source>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</source>
          <target state="translated">アプリにUndoとRedo機能を組み込むには、従来から開発者の意識的な努力が必要でした。関連するすべてのモデルを複製することで、すべての過去の状態を追跡する必要があるため、古典的な MVC フレームワークでは簡単な問題ではありません。加えて、ユーザーによる変更は元に戻せるようにしなければならないため、アンドゥスタックに注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="5216ed259778329413571d3d5d7a100b3609532a" translate="yes" xml:space="preserve">
          <source>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</source>
          <target state="translated">しかし、結果はかなりバニラです。これは基本的に動的なコードから静的なビューをレンダリングします。次に必要なのは、レンダリングされたビューを動的にできるようにするために、動的に初期状態を構築することです。</target>
        </trans-unit>
        <trans-unit id="c6630c4ba113b66e638acb13afa2a0da5838bc4c" translate="yes" xml:space="preserve">
          <source>But there's also a different way to enable chaining. The middleware could accept the &lt;code&gt;next()&lt;/code&gt; dispatch function as a parameter instead of reading it from the &lt;code&gt;store&lt;/code&gt; instance.</source>
          <target state="translated">ただし、連鎖を有効にする別の方法もあります。ミドルウェアは、 &lt;code&gt;store&lt;/code&gt; インスタンスから読み取る代わりに、 &lt;code&gt;next()&lt;/code&gt; ディスパッチ関数をパラメーターとして受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="1dee896ae234e12cac8b3cbc6f4a57f568f7c5f7" translate="yes" xml:space="preserve">
          <source>By assuming the wrapped component is pure, it need only check whether the root state object or the values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; have changed. If they haven&amp;rsquo;t, the wrapped component does not need re-rendering.</source>
          <target state="translated">ラップされたコンポーネントが純粋であると想定すると、ルート状態オブジェクトまたは &lt;code&gt;mapStateToProps&lt;/code&gt; から返された値が変更されたかどうかを確認するだけで済みます。そうでない場合、ラップされたコンポーネントは再レンダリングする必要がありません。</target>
        </trans-unit>
        <trans-unit id="c04d1941187625b0fce5ba887317fb2d3821a0a2" translate="yes" xml:space="preserve">
          <source>By convention, the top-level state is an object or some other key-value collection like a Map, but technically it can be any type. Still, you should do your best to keep the state serializable. Don't put anything inside it that you can't easily turn into JSON.</source>
          <target state="translated">慣例では、トップレベルの状態はオブジェクトや Map のようなキー値コレクションですが、技術的にはどのような型でも構いません。しかし、技術的にはどのような型であっても構いません。簡単にJSONに変換できないようなものを内部に置かないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="ee52434982b2c6a75c2a9dc316e303887dd2c213" translate="yes" xml:space="preserve">
          <source>By converting Immutable.JS objects to plain JavaScript values within a HOC, we achieve Dumb Component portability, but without the performance hits of using &lt;code&gt;toJS()&lt;/code&gt; in the Smart Component.</source>
          <target state="translated">HOC内でImmutable.JSオブジェクトをプレーンJavaScript値に変換することで、ダムコンポーネントの移植性を実現しますが、スマートコンポーネントで &lt;code&gt;toJS()&lt;/code&gt; を使用することによるパフォーマンスへの影響はありません。</target>
        </trans-unit>
        <trans-unit id="14c208d300198acc2bee9f79ece564c973b4032d" translate="yes" xml:space="preserve">
          <source>By hand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678ffdd0e7329a441eacb0cada63caaeb00de544" translate="yes" xml:space="preserve">
          <source>Call non-pure functions, e.g. &lt;code&gt;Date.now()&lt;/code&gt; or &lt;code&gt;Math.random()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Date.now()&lt;/code&gt; や &lt;code&gt;Math.random()&lt;/code&gt; などの純粋でない関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="514ecbbb081ae5bb804b5d148470b70893486e4e" translate="yes" xml:space="preserve">
          <source>Calling an action creator only produces an action, but does not dispatch it. You need to call the store's &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function to actually cause the mutation. Sometimes we say &lt;em&gt;bound action creators&lt;/em&gt; to mean functions that call an action creator and immediately dispatch its result to a specific store instance.</source>
          <target state="translated">アクションクリエーターを呼び出すと、アクションが生成されるだけで、ディスパッチされません。変更を実際に発生させるには、ストアの&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;関数を呼び出す必要があります。時々 、私たちは言う&lt;em&gt;バウンドアクションクリエイターを&lt;/em&gt;アクションの作成者を呼び出し、すぐに特定のストアインスタンスにその結果を派遣平均関数に。</target>
        </trans-unit>
        <trans-unit id="cc88550e4ec686048f4441cff525112f12fef17b" translate="yes" xml:space="preserve">
          <source>Can I put functions, promises, or other non-serializable items in my store state?</source>
          <target state="translated">ストアの状態で、関数やプロミスなど、シリアライズできないものを入れることはできますか?</target>
        </trans-unit>
        <trans-unit id="bc9efb799599b448719604b39fc5d1dd267fac1f" translate="yes" xml:space="preserve">
          <source>Can Redux be considered a &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; implementation?</source>
          <target state="translated">Reduxは&lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;実装と見なすことができますか？</target>
        </trans-unit>
        <trans-unit id="3c8f18450288bb51e46e5292d22da2305a2ead78" translate="yes" xml:space="preserve">
          <source>Can Redux only be used with React?</source>
          <target state="translated">ReduxはReactでしか使えないの?</target>
        </trans-unit>
        <trans-unit id="ac9b06faebbc4bb435ce5bb7eca38ff4df6ae262" translate="yes" xml:space="preserve">
          <source>Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</source>
          <target state="translated">複数のストアを作成することはできますか?ストアを直接インポートして、自分でコンポーネントで使用することはできますか?</target>
        </trans-unit>
        <trans-unit id="afc46e42066f8c38a155fdc1d793218fd0742077" translate="yes" xml:space="preserve">
          <source>Certain immutable operations, such as an Array filter, will always return a new object, even if the values themselves have not changed.</source>
          <target state="translated">配列フィルタのような特定の不変操作は、値自体が変更されていなくても常に新しいオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="9c74fb571984d7f3e781ea8b013e5f74bcd16389" translate="yes" xml:space="preserve">
          <source>Change Log</source>
          <target state="translated">変更ログ</target>
        </trans-unit>
        <trans-unit id="77d62200bb4808e2c757f43ffc9e34e38db2f83c" translate="yes" xml:space="preserve">
          <source>Changes are made with pure functions</source>
          <target state="translated">変更は純粋な機能で行う</target>
        </trans-unit>
        <trans-unit id="a7e5e5888a0251d8e42a2303b77a969291cfff57" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - single connection vs many connections</source>
          <target state="translated">チャットログ。React/Redux のパフォーマンス-シングル接続と多数の接続の比較</target>
        </trans-unit>
        <trans-unit id="02882aae8c97d845e545938dbe2741732079d319" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - updating a 10K-item Todo list</source>
          <target state="translated">チャットログ。React/Redux perf-10K項目のTodoリストを更新する</target>
        </trans-unit>
        <trans-unit id="590f1d62228e7b6962e715956c59522b152fc9a5" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;exampleredditapi&quot;&gt;the full source code for the async example&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exampleredditapi&quot;&gt;非同期の例については、完全なソースコードをご覧&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="1ca51c480d481c131ddccd6e3c2ee749821089b7" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;official documentation&lt;/a&gt; of Reselect as well as its &lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQ&lt;/a&gt;. Most Redux projects start using Reselect when they have performance problems because of too many derived computations and wasted re-renders, so make sure you are familiar with it before you build something big. It can also be useful to study &lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;its source code&lt;/a&gt; so you don't think it's magic.</source>
          <target state="translated">Reselect の&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;公式ドキュメント&lt;/a&gt;とその&lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQを&lt;/a&gt;確認してください。ほとんどのReduxプロジェクトは、派生した計算が多すぎて再レンダリングが無駄になるためにパフォーマンスの問題が発生した場合にReselectを使用し始めます。また、魔法のように思わないように&lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;、ソースコード&lt;/a&gt;を調べることも役立ちます。</target>
        </trans-unit>
        <trans-unit id="7064940db7a1d0a8ad078f4933ca03bdf4384538" translate="yes" xml:space="preserve">
          <source>Choosing whether to use a single action type with flags, or multiple action types, is up to you. It's a convention you need to decide with your team. Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;.</source>
          <target state="translated">フラグ付きの単一のアクションタイプを使用するか、複数のアクションタイプを使用するかは、あなた次第です。それはあなたがあなたのチームと決める必要がある慣習です。複数のタイプを使用すると、ミスの余地が少なくなりますが、&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;などのヘルパーライブラリを使用してアクションクリエーターとリデューサーを生成する場合、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="a35b138959cf52724c7ecc764f2581e2505e1033" translate="yes" xml:space="preserve">
          <source>Chris Dhanaraj</source>
          <target state="translated">クリス・ダナラジ</target>
        </trans-unit>
        <trans-unit id="4da30b8b6589341c1c5097e2b6d732339256659a" translate="yes" xml:space="preserve">
          <source>Clear the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; クリアします。</target>
        </trans-unit>
        <trans-unit id="794ceaaa1771a4243afa4d673ab5434968292b2a" translate="yes" xml:space="preserve">
          <source>Cloning Objects in JavaScript</source>
          <target state="translated">JavaScriptでオブジェクトを複製する</target>
        </trans-unit>
        <trans-unit id="9d6b5f970ace9ba53ad9e45c0384561f1183fe5b" translate="yes" xml:space="preserve">
          <source>Code Structure</source>
          <target state="translated">コード構造</target>
        </trans-unit>
        <trans-unit id="7a44af612fdee0de4619ce06d349d983c763c717" translate="yes" xml:space="preserve">
          <source>Combined Reducers</source>
          <target state="translated">複合減速機</target>
        </trans-unit>
        <trans-unit id="138eb4fb8cbab09f3102a4bdc497d150d119b26b" translate="yes" xml:space="preserve">
          <source>Combining Reducers by Slice</source>
          <target state="translated">スライスによるレデューサーの組み合わせ</target>
        </trans-unit>
        <trans-unit id="58fca950b17f3d83e4dea581789d811359b5f26a" translate="yes" xml:space="preserve">
          <source>Common Mistake #1: New variables that point to the same objects</source>
          <target state="translated">よくある間違い1:同じオブジェクトを指す新しい変数</target>
        </trans-unit>
        <trans-unit id="9bac9c6f37df3c3c4497667d13578b5087f6d70e" translate="yes" xml:space="preserve">
          <source>Common Mistake #2: Only making a shallow copy of one level</source>
          <target state="translated">よくある間違い2:1レベルの浅いコピーしかできない</target>
        </trans-unit>
        <trans-unit id="5f3d6c44bf5df710ea25006914bb1e40d2ecbb97" translate="yes" xml:space="preserve">
          <source>Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!</source>
          <target state="translated">Reduxのよくある誤解:ステートを深くクローンする必要がある。現実:内部の何かが変化しない場合、その参照は同じままにしておきましょう!</target>
        </trans-unit>
        <trans-unit id="1b43008657b57fe78508382a4b9fb02fb7841e4e" translate="yes" xml:space="preserve">
          <source>Community Conventions</source>
          <target state="translated">コミュニティ大会</target>
        </trans-unit>
        <trans-unit id="6ba5570bcfc57cb0bf4fe0a9702c06fc5228b4ab" translate="yes" xml:space="preserve">
          <source>Complementary Packages</source>
          <target state="translated">補完パッケージ</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="32506a4d4827f751f805be2f6a54fe8754849b64" translate="yes" xml:space="preserve">
          <source>Components will both re-render when they shouldn&amp;rsquo;t, and refuse to render when they should, and tracking down the bug causing the rendering issue is hard, as the component rendering incorrectly is not necessarily the one whose properties are being accidentally mutated.</source>
          <target state="translated">コンポーネントは、必要のないときに再レンダリングし、必要なときにレンダリングを拒否します。また、コンポーネントのレンダリングが正しくないため、コンポーネントが誤って変更されているとは限らないため、レンダリングの問題の原因となっているバグを追跡することは困難です。</target>
        </trans-unit>
        <trans-unit id="837b57a8ec5e9af95ffd6545daebb1d24962188f" translate="yes" xml:space="preserve">
          <source>Composes functions from right to left.</source>
          <target state="translated">右から左へ関数を構成します。</target>
        </trans-unit>
        <trans-unit id="8e0c107b8e98df1c854ed1c7dcb3a98dc7c2ca76" translate="yes" xml:space="preserve">
          <source>Composing Selectors</source>
          <target state="translated">セレクタの構成</target>
        </trans-unit>
        <trans-unit id="f0d42401ef57fab1331c6965711b20a87c5ddbf4" translate="yes" xml:space="preserve">
          <source>Computing Derived Data</source>
          <target state="translated">派生データの計算</target>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="translated">エクスプレスの設定</target>
        </trans-unit>
        <trans-unit id="67a9e1acb14192d9b8d0b21f21976859dd578df3" translate="yes" xml:space="preserve">
          <source>Configuring WebpackDevServer</source>
          <target state="translated">WebpackDevServerを設定する</target>
        </trans-unit>
        <trans-unit id="fde5035ac1fcc8de232b7bed3503337cd6eb9f66" translate="yes" xml:space="preserve">
          <source>Configuring the Fallback URL</source>
          <target state="translated">フォールバックURLの設定</target>
        </trans-unit>
        <trans-unit id="87a9853dc1b73b96e2f86ff4c803e9204d6d4b12" translate="yes" xml:space="preserve">
          <source>Connected Components</source>
          <target state="translated">接続部品</target>
        </trans-unit>
        <trans-unit id="8e80b5ae124a108d4cae25b4b8f529572912388e" translate="yes" xml:space="preserve">
          <source>Connecting React Router with Redux App</source>
          <target state="translated">ReactルータをReduxアプリで接続する</target>
        </trans-unit>
        <trans-unit id="a6a0e3b241efd3e93742236b45d8493d0e6fee30" translate="yes" xml:space="preserve">
          <source>Connecting a Selector to the Redux Store</source>
          <target state="translated">セレクタをReduxストアに接続する</target>
        </trans-unit>
        <trans-unit id="87209e0d1e9b53b5fe4772baab86c7a792f26231" translate="yes" xml:space="preserve">
          <source>Connecting to UI</source>
          <target state="translated">UIへの接続</target>
        </trans-unit>
        <trans-unit id="9a52a37a64378cb1a98da0406ef6404fd0218774" translate="yes" xml:space="preserve">
          <source>Consequently, the state object will look like this:</source>
          <target state="translated">その結果、ステートオブジェクトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b825bc561f6b5b1f75c29d0f875286a593d7b365" translate="yes" xml:space="preserve">
          <source>Consider the case of a &amp;ldquo;big&amp;rdquo; app (contained in a &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; component) that embeds smaller &amp;ldquo;sub-apps&amp;rdquo; (contained in &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; components):</source>
          <target state="translated">小さい「 &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; 」（&amp;lt;SubApp&amp;gt;コンポーネントに含まれる）を埋め込む「ビッグ」アプリ（ &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; コンポーネントに含まれる）の場合を考えてみます。</target>
        </trans-unit>
        <trans-unit id="66b9b7c93fb54ebed199da9fee98590876d2817b" translate="yes" xml:space="preserve">
          <source>Consider the code above rewritten with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;:</source>
          <target state="translated">上記のコードを&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunkで&lt;/a&gt;書き換えた場合を考えます。</target>
        </trans-unit>
        <trans-unit id="2ca273c094d939aa568e917155d75b414ea13292" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">次の &lt;code&gt;App&lt;/code&gt; コンポーネントについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="70e99e62d50531f0a2f738cbf8aa0173b646e44a" translate="yes" xml:space="preserve">
          <source>Consider this Flux store:</source>
          <target state="translated">このFLUXのお店を考えてみてください。</target>
        </trans-unit>
        <trans-unit id="4f9f7bad9d1734680439f0676a170b5a673dfd79" translate="yes" xml:space="preserve">
          <source>Container Components</source>
          <target state="translated">コンテナコンポーネント</target>
        </trans-unit>
        <trans-unit id="d0dfb089b89fb29b825328110a2e11b4f94fb034" translate="yes" xml:space="preserve">
          <source>Conversely, in this next example (below), the component will &lt;em&gt;always&lt;/em&gt; re-render, as the value of &lt;code&gt;todos&lt;/code&gt; is always a new object, regardless of whether or not its values change:</source>
          <target state="translated">逆に、この次の例（下記）では、値が変更されたかどうかに関係なく、 &lt;code&gt;todos&lt;/code&gt; の値は常に新しいオブジェクトであるため、コンポーネントは&lt;em&gt;常に&lt;/em&gt;再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="29636c1eb55c51788d0bfe80405463c52281956d" translate="yes" xml:space="preserve">
          <source>Converting an Immutable.JS object to a JavaScript object using &lt;code&gt;toJS()&lt;/code&gt; will return a new object every time. If you do this in &lt;code&gt;mapStateToProps&lt;/code&gt;, you will cause the component to believe that the object has changed every time the state tree changes, and so trigger an unnecessary re-render.</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; を使用してImmutable.JSオブジェクトをJavaScriptオブジェクトに変換すると、毎回新しいオブジェクトが返されます。これを &lt;code&gt;mapStateToProps&lt;/code&gt; で行うと、状態ツリーが変更されるたびにオブジェクトが変更されたとコンポーネントに信じ込ませ、不要な再レンダリングをトリガーします。</target>
        </trans-unit>
        <trans-unit id="93a1d53292581775a7aefd7eb2070e8afcd74765" translate="yes" xml:space="preserve">
          <source>Copying objects using functions like &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;, and array functions such as &lt;code&gt;slice()&lt;/code&gt; and &lt;code&gt;concat()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.assign()&lt;/code&gt; や &lt;code&gt;_.extend()&lt;/code&gt; などの関数、および &lt;code&gt;slice()&lt;/code&gt; や &lt;code&gt;concat()&lt;/code&gt; などの配列関数を使用したオブジェクトのコピー</target>
        </trans-unit>
        <trans-unit id="c872753511d558c4ce512746cf585786dd025a3c" translate="yes" xml:space="preserve">
          <source>Core Concepts</source>
          <target state="translated">コアコンセプト</target>
        </trans-unit>
        <trans-unit id="ef8e6e4e0586b33e3404668e2c83565be91e5463" translate="yes" xml:space="preserve">
          <source>Correct Approach: Copying All Levels of Nested Data</source>
          <target state="translated">正しいアプローチ。入れ子になったデータのすべてのレベルをコピーする</target>
        </trans-unit>
        <trans-unit id="f4018045cfb458b2734d2b09cf762c2567878c41" translate="yes" xml:space="preserve">
          <source>Counter</source>
          <target state="translated">Counter</target>
        </trans-unit>
        <trans-unit id="ee249667a9d59781bd41e030d27e2c1188c37ed0" translate="yes" xml:space="preserve">
          <source>Counter Vanilla</source>
          <target state="translated">カウンターバニラ</target>
        </trans-unit>
        <trans-unit id="626a2643ba405040e97390410d4230e265e4259f" translate="yes" xml:space="preserve">
          <source>Create a function called &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;) implementation from Redux. Its dispatch handler should just call the &lt;code&gt;reducer&lt;/code&gt; for any action, store the next state, and emit change.</source>
          <target state="translated">レデューサー関数から既存のアプリと互換性のあるFluxストアを作成する &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; という関数を作成します。内部的には、Reduxの&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;）実装に似ている可能性があります。そのディスパッチハンドラは、アクションの &lt;code&gt;reducer&lt;/code&gt; を呼び出し、次の状態を保存し、変更を送信するだけです。</target>
        </trans-unit>
        <trans-unit id="f00d5c6bc58d02ae5cd2c0877a6310c7f5c5ba39" translate="yes" xml:space="preserve">
          <source>Create a reducer that returns the next state for each possible authentication case (&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc).</source>
          <target state="translated">考えられる各認証ケース（ &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; 、 &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; など）の次の状態を返すリデューサーを作成します。</target>
        </trans-unit>
        <trans-unit id="8eda9a696d062cf8392d53f7f2f71e67915d36d6" translate="yes" xml:space="preserve">
          <source>Create action constants for &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; 、 &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; などのアクション定数を作成します。</target>
        </trans-unit>
        <trans-unit id="324a3f11e3a6b0488c13a615c4cc2fb9250a827e" translate="yes" xml:space="preserve">
          <source>Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.</source>
          <target state="translated">資格情報、認証に成功したかどうかを示すフラグ、トークン、またはエラーメッセージをペイロードとして取り込むアクション・クリエータを作成します。</target>
        </trans-unit>
        <trans-unit id="f4da47671463db87fe5e42276d8cdd320a2a393a" translate="yes" xml:space="preserve">
          <source>Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.</source>
          <target state="translated">Redux Thunkミドルウェアやその他のミドルウェアを使用して非同期アクションクリエーターを作成し、認証情報が有効であればトークンを返すAPIへのネットワークリクエストを実行します。そして、トークンをローカルストレージに保存するか、失敗した場合はユーザーにレスポンスを表示します。前のステップで書いたアクション作成者から、これらの副作用を実行することができます。</target>
        </trans-unit>
        <trans-unit id="5e918651270b4a8e2572409f93c5b24f05fb8646" translate="yes" xml:space="preserve">
          <source>Create the tree using Immutable.JS&amp;rsquo;s &lt;code&gt;fromJS()&lt;/code&gt; function.</source>
          <target state="translated">Immutable.JSの &lt;code&gt;fromJS()&lt;/code&gt; 関数を使用してツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="f9f8eb3701e2ecf3db6a0a48de0c67b288bcb04f" translate="yes" xml:space="preserve">
          <source>Creates a Redux &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; that holds the complete state tree of your app.</source>
          <target state="translated">アプリの完全な状態ツリーを保持するRedux &lt;a href=&quot;store&quot;&gt;ストア&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="e2d02ebd7a04879d6977b29605f7193c5cf5707d" translate="yes" xml:space="preserve">
          <source>Creating a Memoized Selector</source>
          <target state="translated">メモ付きセレクタの作成</target>
        </trans-unit>
        <trans-unit id="d2bc225ae0a45426787680231ada8a6f564133c3" translate="yes" xml:space="preserve">
          <source>Currently, the todo list is not filtered even after the URL changed. This is because we are filtering from &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;'s &lt;code&gt;mapStateToProps()&lt;/code&gt; is still bound to the &lt;code&gt;state&lt;/code&gt; and not to the URL. &lt;code&gt;mapStateToProps&lt;/code&gt; has an optional second argument &lt;code&gt;ownProps&lt;/code&gt; that is an object with every props passed to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;</source>
          <target state="translated">現在、URLが変更された後でも、todoリストはフィルタリングされません。これは、 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; のフィルタリングを行っているためです &lt;code&gt;mapStateToProps()&lt;/code&gt; は、URLではなく &lt;code&gt;state&lt;/code&gt; バインドされています。 &lt;code&gt;mapStateToProps&lt;/code&gt; には、オプションの2番目の引数 &lt;code&gt;ownProps&lt;/code&gt; があります。これは、すべての小道具が &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; に渡されるオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="3c61307a6709c8c66ca641e98184dcc9259bd594" translate="yes" xml:space="preserve">
          <source>Customizing Behavior with Higher-Order Reducers</source>
          <target state="translated">高次減速機を使った行動のカスタマイズ</target>
        </trans-unit>
        <trans-unit id="60b543bfaaf4e1677077510d003f94bafdf0c999" translate="yes" xml:space="preserve">
          <source>Dan</source>
          <target state="translated">Dan</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="translated">データの流れ</target>
        </trans-unit>
        <trans-unit id="bb55896eb93bcb68cbc23ed6fae3b63100404b9f" translate="yes" xml:space="preserve">
          <source>Data encapsulated in an Immutable.JS object is never mutated. A new copy is always returned. This contrasts with JavaScript, in which some operations do not mutate your data (e.g. some Array methods, including map, filter, concat, forEach, etc.), but some do (Array&amp;rsquo;s pop, push, splice, etc.).</source>
          <target state="translated">Immutable.JSオブジェクトにカプセル化されたデータは変更されません。常に新しいコピーが返されます。これはJavaScriptとは対照的です。JavaScriptでは、一部の操作ではデータが変化しません（たとえば、map、filter、concat、forEachなどの一部のArrayメソッド）が、一部は変化します（Arrayのpop、push、spliceなど）。</target>
        </trans-unit>
        <trans-unit id="7593569c991b58f5d6a41f860519f79c89ac7d64" translate="yes" xml:space="preserve">
          <source>Data with IDs, nesting, or relationships should generally be stored in a &amp;ldquo;normalized&amp;rdquo; fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual &amp;ldquo;tables&amp;rdquo; per item type. Libraries such as &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; and &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt; can provide help and abstractions in managing normalized data.</source>
          <target state="translated">ID、入れ子、または関係のあるデータは、通常「正規化された」方法で保存する必要があります。各オブジェクトは一度に保存し、IDをキーにして、オブジェクトを参照する他のオブジェクトはオブジェクト全体のコピーではなくIDのみを保存する必要があります。ストアの一部をデータベースとして考えると、アイテムタイプごとに個別の「テーブル」があると便利です。&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt;や&lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt;などのライブラリは、正規化されたデータの管理に役立つ情報や抽象化を提供します。</target>
        </trans-unit>
        <trans-unit id="65fce8bd8c421447a1dd474490698e1a12d0c27c" translate="yes" xml:space="preserve">
          <source>Database Design: Many-to-Many</source>
          <target state="translated">データベースの設計。多対多</target>
        </trans-unit>
        <trans-unit id="1fa63f66a3e39dbf462410620328fa6a5c9da175" translate="yes" xml:space="preserve">
          <source>Database Normalization in Simple English</source>
          <target state="translated">簡単な英語でのデータベース正規化</target>
        </trans-unit>
        <trans-unit id="32877593ffc83fe4317187fc6ecc5223533036b1" translate="yes" xml:space="preserve">
          <source>Database structure and organization</source>
          <target state="translated">データベースの構造と組織</target>
        </trans-unit>
        <trans-unit id="6e6caf1f8d03433b6b3dbc198392d72cd0763d04" translate="yes" xml:space="preserve">
          <source>Defining State Shape</source>
          <target state="translated">状態の形状の定義</target>
        </trans-unit>
        <trans-unit id="49314fcc5d1e120d1d0902f4474a5db8b799f9b6" translate="yes" xml:space="preserve">
          <source>Defining a new variable does &lt;em&gt;not&lt;/em&gt; create a new actual object - it only creates another reference to the same object. An example of this error would be:</source>
          <target state="translated">新しい変数を定義して&lt;em&gt;も&lt;/em&gt;、新しい実際のオブジェクト&lt;em&gt;は&lt;/em&gt;作成されませ&lt;em&gt;ん&lt;/em&gt;。同じオブジェクトへの別の参照が作成されるだけです。このエラーの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bd4da65ee5f20805d0bb44ddd368a4514e6d0453" translate="yes" xml:space="preserve">
          <source>Defining reducer initial state</source>
          <target state="translated">レデューサの初期状態の定義</target>
        </trans-unit>
        <trans-unit id="9f78359ef1da5a7d707b4be19086cd7ea706ec2f" translate="yes" xml:space="preserve">
          <source>Delegating update responsibility by slice of state (&lt;em&gt;reducer composition&lt;/em&gt;)</source>
          <target state="translated">状態のスライス（&lt;em&gt;レデューサー構成&lt;/em&gt;）による更新責任の委任</target>
        </trans-unit>
        <trans-unit id="1296d584b1abd6003d9e6416a0989753f553b128" translate="yes" xml:space="preserve">
          <source>Designing Component Hierarchy</source>
          <target state="translated">コンポーネント階層の設計</target>
        </trans-unit>
        <trans-unit id="e6f93012b13a7122f93f6b433f36e83f1b2dfb67" translate="yes" xml:space="preserve">
          <source>Designing Container Components</source>
          <target state="translated">コンテナコンポーネントの設計</target>
        </trans-unit>
        <trans-unit id="7810471483b121e68f2ab23125107a8e8d67064c" translate="yes" xml:space="preserve">
          <source>Designing Other Components</source>
          <target state="translated">その他の部品の設計</target>
        </trans-unit>
        <trans-unit id="095ba0b64724cee5424170abe9d2369a1356993a" translate="yes" xml:space="preserve">
          <source>Designing Presentational Components</source>
          <target state="translated">プレゼン用のコンポーネントをデザインする</target>
        </trans-unit>
        <trans-unit id="f307d5da7a84124c96764da2d65924d5f68585cd" translate="yes" xml:space="preserve">
          <source>Designing a Normalized State</source>
          <target state="translated">正規化状態の設計</target>
        </trans-unit>
        <trans-unit id="99b64b8cd5e20eb2ba80ed64b203752e415148ae" translate="yes" xml:space="preserve">
          <source>Designing the Algorithm</source>
          <target state="translated">アルゴリズムの設計</target>
        </trans-unit>
        <trans-unit id="b35f6f1ba63bafce6306862fed8e4ab702901f90" translate="yes" xml:space="preserve">
          <source>Designing the State Shape</source>
          <target state="translated">状態の形状を設計する</target>
        </trans-unit>
        <trans-unit id="c6c55bbe367ca8fb0838485f031ff1f37f152f0b" translate="yes" xml:space="preserve">
          <source>DevTools</source>
          <target state="translated">DevTools</target>
        </trans-unit>
        <trans-unit id="f2384c55c1021ace4ef6037926b470b0095b309e" translate="yes" xml:space="preserve">
          <source>DevTools Monitors</source>
          <target state="translated">DevToolsモニター</target>
        </trans-unit>
        <trans-unit id="4ed5637154269fe9a6be1732f927c29a0887441d" translate="yes" xml:space="preserve">
          <source>Developer Experience</source>
          <target state="translated">開発者の経験</target>
        </trans-unit>
        <trans-unit id="1972dacb696b8fcf81bb0f74e9d8f176d7b71600" translate="yes" xml:space="preserve">
          <source>Difficult to Debug</source>
          <target state="translated">デバッグが難しい</target>
        </trans-unit>
        <trans-unit id="8d5353aaf7c5188baebbcacaf0df24469e5eb208" translate="yes" xml:space="preserve">
          <source>Difficult to interoperate with</source>
          <target state="translated">相互運用が難しい</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="ba63f5884c366cac612c111e65bfbc1bb0d9c688" translate="yes" xml:space="preserve">
          <source>Dispatch Redux actions</source>
          <target state="translated">ディスパッチ Redux アクション</target>
        </trans-unit>
        <trans-unit id="6a79a9e77ebead14cffe5188d0410f1e586d1501" translate="yes" xml:space="preserve">
          <source>Dispatches an action. This is the only way to trigger a state change.</source>
          <target state="translated">アクションをディスパッチします。状態変化をトリガーする唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">派遣行為</target>
        </trans-unit>
        <trans-unit id="ee258d3de8054840d9dbb2c1e3c54e55b09089fd" translate="yes" xml:space="preserve">
          <source>Dispatching Function</source>
          <target state="translated">派遣機能</target>
        </trans-unit>
        <trans-unit id="2940c23366cfc9866cf0dedabc5e7de427363110" translate="yes" xml:space="preserve">
          <source>Dispatching async actions is no different from dispatching synchronous actions, so we won't discuss this in detail. See &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt; for an introduction into using Redux from React components. See &lt;a href=&quot;exampleredditapi&quot;&gt;Example: Reddit API&lt;/a&gt; for the complete source code discussed in this example.</source>
          <target state="translated">非同期アクションのディスパッチは同期アクションのディスパッチと同じなので、これについては詳しく説明しません。ReactコンポーネントからのReduxの&lt;a href=&quot;../basics/usagewithreact&quot;&gt;使用の概要&lt;/a&gt;については、Reactでの使用を参照してください。この例で説明されている完全なソースコードについては、&lt;a href=&quot;exampleredditapi&quot;&gt;例：Reddit API&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="d068c8a57b05988a99ec9db89530ed96daebd1f4" translate="yes" xml:space="preserve">
          <source>Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?</source>
          <target state="translated">自分の状態をレデューサーでディープクローンする必要がありますか?自分の状態をコピーするのは遅くないですか?</target>
        </trans-unit>
        <trans-unit id="caa79d0829b0d4f0c975b203f736245e67eda1ac" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's &lt;code&gt;setState()&lt;/code&gt;?</source>
          <target state="translated">すべての状態をReduxに入れる必要がありますか？Reactの &lt;code&gt;setState()&lt;/code&gt; を使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="3636bc59ec04bd17d42ee7274e5e3eb724ddb4f2" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's setState()?</source>
          <target state="translated">すべてのステートをReduxに入れなければならないのか?ReactのsetState()を使うべきか?</target>
        </trans-unit>
        <trans-unit id="7486a68c2117f403c3ca95e7a147f4be8fdc9437" translate="yes" xml:space="preserve">
          <source>Do I have to use Immutable.JS?</source>
          <target state="translated">Immutable.JSを使用する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="4e019a0f0b682311d1ef5e7b44aa30ef9a7eb403" translate="yes" xml:space="preserve">
          <source>Do I have to use the &lt;code&gt;switch&lt;/code&gt; statement to handle actions?</source>
          <target state="translated">アクションを処理するために &lt;code&gt;switch&lt;/code&gt; ステートメントを使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="5b739025b617dfa813fa405e23c0277f969c273f" translate="yes" xml:space="preserve">
          <source>Do I have to use the switch statement to handle actions?</source>
          <target state="translated">アクションを処理するためにswitch文を使用する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="04dfaeca86278099773342d666073f6978321758" translate="yes" xml:space="preserve">
          <source>Do I need to have a particular build tool to use Redux?</source>
          <target state="translated">Reduxを使うには、特定のビルドツールが必要ですか?</target>
        </trans-unit>
        <trans-unit id="9b60ee4844578949ccecf13536855592c60fe12e" translate="yes" xml:space="preserve">
          <source>Do not, however, use Immutable.JS in your dumb components.</source>
          <target state="translated">ただし、Immutable.JSをおぼろげなコンポーネントで使用しないでください。</target>
        </trans-unit>
        <trans-unit id="4a8b5e6217f9ee788c8250a9d130537eb4c43e5f" translate="yes" xml:space="preserve">
          <source>Do other parts of the application care about this data?</source>
          <target state="translated">アプリケーションの他の部分は、このデータを気にしているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="88c60268b9a702d1f66d359ec783eeff4c903f73" translate="yes" xml:space="preserve">
          <source>Do you need to be able to create further derived data based on this original data?</source>
          <target state="translated">この元データを元に、さらに派生したデータを作成できるようにする必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4a7b10f54d6c1236b3c9f64a98cb069e05bfcec5" translate="yes" xml:space="preserve">
          <source>Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?</source>
          <target state="translated">データをキャッシュしたいのですか (つまり、再要求するのではなく、既にあるものを使用したいのです)?</target>
        </trans-unit>
        <trans-unit id="5cfcf7555c4a87f604bf343228e431e941928a19" translate="yes" xml:space="preserve">
          <source>Docs: Async Actions</source>
          <target state="translated">Docs.非同期アクション</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="8181fac4ec0bea3cecb41f787698bf543db5208d" translate="yes" xml:space="preserve">
          <source>Does it make sense to use Redux together with RxJS? Sure! They work great together. For example, it is easy to expose a Redux store as an observable:</source>
          <target state="translated">ReduxをRxJSと一緒に使うのは意味があるのでしょうか?もちろんです。両者は相性が良いです。例えば、Reduxストアをオブザーバブルとして公開するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="e1305d9a919be6e6f9ecdeed5c7f2f2e478ed670" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;call non-pure functions&lt;/em&gt; (like &lt;code&gt;Date.now&lt;/code&gt; or &lt;code&gt;Math.random&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;純粋で&lt;/em&gt;ない&lt;em&gt;関数&lt;/em&gt;（ &lt;code&gt;Date.now&lt;/code&gt; や &lt;code&gt;Math.random&lt;/code&gt; など）を呼び出さない。</target>
        </trans-unit>
        <trans-unit id="308816fda77ecb92fa0de1e1d751c4e3693e8be6" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;mutate&lt;/em&gt; its arguments. If the reducer updates state, it should not &lt;em&gt;modify&lt;/em&gt; the &lt;strong&gt;existing&lt;/strong&gt; state object in-place. Instead, it should generate a &lt;strong&gt;new&lt;/strong&gt; object containing the necessary changes. The same approach should be used for any sub-objects within state that the reducer updates.</source>
          <target state="translated">しない&lt;em&gt;変異し&lt;/em&gt;、その引数を。レデューサーが状態を更新&lt;em&gt;する場合&lt;/em&gt;、&lt;strong&gt;既存の&lt;/strong&gt;状態オブジェクトをインプレースで&lt;em&gt;変更&lt;/em&gt;しないでください。代わりに、必要な変更を含む&lt;strong&gt;新しい&lt;/strong&gt;オブジェクトを生成する必要があります。同じ方法を、レデューサーが更新する状態内のすべてのサブオブジェクトに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e22b1d9946b43200b9db286efe37087e730da043" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;perform side effects&lt;/em&gt; (such as calling API's or modifying non-local objects or variables).</source>
          <target state="translated">&lt;em&gt;副作用&lt;/em&gt;（APIの呼び出し、非ローカルオブジェクトまたは変数の変更など）を&lt;em&gt;実行&lt;/em&gt;しません。</target>
        </trans-unit>
        <trans-unit id="901adbd801774ee77110f7fe930f88786af2ec3e" translate="yes" xml:space="preserve">
          <source>Does shallow equality checking with a mutable object cause problems with Redux?</source>
          <target state="translated">変形可能なオブジェクトでの浅い平等性チェックは Redux で問題を起こすのか?</target>
        </trans-unit>
        <trans-unit id="acbce74552f0dc7776acd620559f6ae39660da73" translate="yes" xml:space="preserve">
          <source>Doing a shallow copy of the top level is &lt;em&gt;not&lt;/em&gt; sufficient - the &lt;code&gt;nestedState&lt;/code&gt; object should be copied as well.</source>
          <target state="translated">トップレベルの浅いコピーを行うことはあり&lt;em&gt;ません&lt;/em&gt;十分な- &lt;code&gt;nestedState&lt;/code&gt; オブジェクトはよくとしてコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="dd72a551e03c242c187b72b86ec827595d6e90b6" translate="yes" xml:space="preserve">
          <source>Domain-style: separate folders per feature or domain, possibly with sub-folders per file type</source>
          <target state="translated">ドメインスタイル:機能またはドメインごとにフォルダを分け、ファイルタイプごとにサブフォルダがある場合もあります。</target>
        </trans-unit>
        <trans-unit id="2b32a297d0fa3a03eb8b498f0629572a9c1acda3" translate="yes" xml:space="preserve">
          <source>Don't be fooled by all the fancy talk about reducers, middleware, store enhancers&amp;mdash;Redux is incredibly simple. If you've ever built a Flux application, you will feel right at home. If you're new to Flux, it's easy too!</source>
          <target state="translated">レデューサー、ミドルウェア、ストアエンハンサーについての派手な話にだまされないでください。Reduxは信じられないほど簡単です。Fluxアプリケーションを構築したことがあれば、自宅にいるように感じるでしょう。Fluxが初めての場合も簡単です。</target>
        </trans-unit>
        <trans-unit id="e60dca1e1c4e8a1060f3f909eb0e179e31b4080d" translate="yes" xml:space="preserve">
          <source>Don't create more than one store in an application! Instead, use &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to create a single root reducer out of many.</source>
          <target state="translated">1つのアプリケーションで複数のストアを作成しないでください。代わりに、&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;を使用して、多数のルートリデューサーから1つを作成します。</target>
        </trans-unit>
        <trans-unit id="dffae83d98e05f1f4c0b98f460a952b65b10e233" translate="yes" xml:space="preserve">
          <source>Don't forget to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;を呼び出すことを忘れないでください</target>
        </trans-unit>
        <trans-unit id="495284d10f80785f137d2b0ebaf638b1a961c65d" translate="yes" xml:space="preserve">
          <source>ES5 (CommonJS)</source>
          <target state="translated">ES5 (CommonJS)</target>
        </trans-unit>
        <trans-unit id="745ddb845c45ed0aef6da5a7c40b9250b9a325e0" translate="yes" xml:space="preserve">
          <source>ES5 (UMD build)</source>
          <target state="translated">ES5(UMDビルド</target>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="ce35c00a38ecfe2f4b7ca71185bfb3dae5d5f370" translate="yes" xml:space="preserve">
          <source>Each &quot;data table&quot; should store the individual items in an object, with the IDs of the items as keys and the items themselves as the values.</source>
          <target state="translated">各「データテーブル」は、アイテムのIDをキー、アイテム自体を値として、オブジェクト内の個々のアイテムを格納する必要があります。</target>
        </trans-unit>
        <trans-unit id="789740bc75be7ca6e2b1e0c1d3adb891edb730c5" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;VisibleTodoList&lt;/code&gt; container should select a different slice of the state depending on the value of the &lt;code&gt;listId&lt;/code&gt; prop, so let's modify &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; to accept a props argument:</source>
          <target state="translated">各 &lt;code&gt;VisibleTodoList&lt;/code&gt; コンテナは、 &lt;code&gt;listId&lt;/code&gt; プロップの値に応じて状態の異なるスライスを選択する必要があるため、 &lt;code&gt;getVisibilityFilter&lt;/code&gt; および &lt;code&gt;getTodos&lt;/code&gt; を変更して、props引数を受け入れます。</target>
        </trans-unit>
        <trans-unit id="ca9118903269eef24fd5dbfa80396b4917cc79e2" translate="yes" xml:space="preserve">
          <source>Each function below is a valid Redux middleware. They are not equally useful, but at least they are equally fun.</source>
          <target state="translated">以下の各関数は、有効な Redux ミドルウェアです。これらは同じように使えるわけではありませんが、少なくとも同じように楽しいものです。</target>
        </trans-unit>
        <trans-unit id="2aef125e7da3027756ffee796bf82b1ad655ceee" translate="yes" xml:space="preserve">
          <source>Each of these two moments usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you'll want to dispatch at least three different kinds of actions:</source>
          <target state="translated">これら2つの瞬間のそれぞれは、通常、アプリケーションの状態の変化を必要とします。そのためには、レデューサによって同期的に処理される通常のアクションをディスパッチする必要があります。通常、どのようなAPIリクエストに対しても、少なくとも3種類のアクションをディスパッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="b94061bea8551ce9cef03e7d29d9b7bc74bb6280" translate="yes" xml:space="preserve">
          <source>Each time React-Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function is called, it will perform a shallow equality check on its stored reference to the root state object, and the current root state object passed to it from the store. If the check passes, the root state object has not been updated, and so there is no need to re-render the component, or even call &lt;code&gt;mapStateToProps&lt;/code&gt;.</source>
          <target state="translated">React-Reduxの &lt;code&gt;connect&lt;/code&gt; 関数が呼び出されるたびに、ルート状態オブジェクトへの格納された参照とストアから渡された現在のルート状態オブジェクトに対して浅い等価性チェックが実行されます。チェックに合格した場合、ルート状態オブジェクトは更新されていないため、コンポーネントを再レンダリングしたり、 &lt;code&gt;mapStateToProps&lt;/code&gt; を呼び出したりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="8ac62ddd16da80245d0cc537482a69476b215083" translate="yes" xml:space="preserve">
          <source>Each type of data gets its own &quot;table&quot; in the state.</source>
          <target state="translated">データの種類ごとに、状態に応じた「テーブル」を取得します。</target>
        </trans-unit>
        <trans-unit id="73f0d5e4c1ae9f4f2cda609ae918e95f2ac644be" translate="yes" xml:space="preserve">
          <source>Earlier documentation suggested the use of the ES6 &lt;code&gt;import * as reducers&lt;/code&gt; syntax to obtain the reducers object. This was the source of a lot of confusion, which is why we now recommend exporting a single reducer obtained using &lt;code&gt;combineReducers()&lt;/code&gt; from &lt;code&gt;reducers/index.js&lt;/code&gt; instead. An example is included below.</source>
          <target state="translated">以前のドキュメントでは、レデューサーオブジェクトを取得するためのレデューサー構文 &lt;code&gt;import * as reducers&lt;/code&gt; ES6 インポート*を使用することを提案していました。これは多くの混乱の原因でした。そのため、代わりにreducer &lt;code&gt;reducers/index.js&lt;/code&gt; から &lt;code&gt;combineReducers()&lt;/code&gt; を使用して取得した単一のレデューサーをエクスポートすることをお勧めします。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="67ebf8c054640eac7707617ac6e4bacc793e0e77" translate="yes" xml:space="preserve">
          <source>Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that that generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.</source>
          <target state="translated">初期の Redux のドキュメントでは、コンポーネントツリーの一番上の近くに、接続されたコンポーネントを数個だけ持つべきだとアドバイスされていました。しかし、時間と経験から、これは一般的にいくつかのコンポーネントが子孫のデータ要件を知りすぎて、混乱を招くような数の小道具を渡すことを余儀なくされることがわかっています。</target>
        </trans-unit>
        <trans-unit id="9f12cdfc5423f3f8f4b141824700661516b50d41" translate="yes" xml:space="preserve">
          <source>Ecosystem</source>
          <target state="translated">Ecosystem</target>
        </trans-unit>
        <trans-unit id="80499668424a593b571c96afb7bfa53680db9225" translate="yes" xml:space="preserve">
          <source>Eddie Zaneski</source>
          <target state="translated">エディ・ザネスキー</target>
        </trans-unit>
        <trans-unit id="c78c0f2575bc2cbbd58e1c8e6bfbabc097fdacf8" translate="yes" xml:space="preserve">
          <source>Egghead.io: Redux: Implementing combineReducers() from Scratch</source>
          <target state="translated">Egghead.io.Redux:スクラッチからcombineReducers()を実装する</target>
        </trans-unit>
        <trans-unit id="a5bfc7a7b3d59e7e7fc34f2665c9e5ecf3f615b6" translate="yes" xml:space="preserve">
          <source>Elm</source>
          <target state="translated">Elm</target>
        </trans-unit>
        <trans-unit id="b0e68be5c4150141a8b181ac2f45237a837582b3" translate="yes" xml:space="preserve">
          <source>Emphasizing &amp;ldquo;one container component at the top&amp;rdquo; in Redux examples was a mistake. Don't take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it's convenient. Whenever you feel like you're duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about &amp;ldquo;personal&amp;rdquo; data or actions of its children, time to extract a container.</source>
          <target state="translated">Reduxの例で「上部に1つのコンテナコンポーネント」を強調するのは誤りでした。これを格言としてとらないでください。プレゼンテーションコンポーネントを分離するようにしてください。コンテナコンポーネントは、必要に応じて接続して作成します。同じ種類の子にデータを提供するために親コンポーネントのコードを複製しているように思われるときはいつでも、コンテナーを抽出する時間です。一般に、親が「個人的な」データまたはその子のアクションについて知りすぎたら、コンテナを抽出する時間です。</target>
        </trans-unit>
        <trans-unit id="7c1a0998563346ad2e48c38b39741bb352b08e65" translate="yes" xml:space="preserve">
          <source>Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each &lt;code&gt;type&lt;/code&gt; value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;check your &lt;code&gt;import&lt;/code&gt; statements against typos&lt;/a&gt; so you can't accidentally use the wrong string.</source>
          <target state="translated">一般的に使用されるコードをカプセル化して一元化することは、プログラミングの重要な概念です。どこでも手動でアクションオブジェクトを作成し、各 &lt;code&gt;type&lt;/code&gt; 値を手動で書き込むことは確かに可能ですが、再利用可能な定数を定義すると、コードの保守が容易になります。定数を別のファイルに配置&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;すると、 &lt;code&gt;import&lt;/code&gt; 文をタイプミスと照合して&lt;/a&gt;、誤った文字列を誤って使用することがなくなります。</target>
        </trans-unit>
        <trans-unit id="5b2f465254c1894a55c4eae9816aef0a576c3b88" translate="yes" xml:space="preserve">
          <source>Encapsulating the Redux State Tree</source>
          <target state="translated">Reduxステートツリーのカプセル化</target>
        </trans-unit>
        <trans-unit id="fd530f3fb4530f659965d7db1794f6c9a3831280" translate="yes" xml:space="preserve">
          <source>Enforcing that every change is described as an action lets us have a clear understanding of what&amp;rsquo;s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it&amp;mdash;it&amp;rsquo;s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</source>
          <target state="translated">すべての変更がアクションとして記述されていることを強制することで、アプリで何が起こっているのかを明確に理解することができます。何かが変わった場合、その理由がわかります。アクションは、起こったことのパンくずのようなものです。最後に、状態とアクションを結び付けるために、レデューサーと呼ばれる関数を記述します。繰り返しになりますが、それについて不思議なことは何もありません。状態とアクションを引数として取り、アプリの次の状態を返す関数にすぎません。大きなアプリに対してそのような関数を書くのは難しいので、状態の一部を管理する小さな関数を書きます。</target>
        </trans-unit>
        <trans-unit id="465e88db20c49fa14df715ad3c0631b26ca590c4" translate="yes" xml:space="preserve">
          <source>Enhancers</source>
          <target state="translated">Enhancers</target>
        </trans-unit>
        <trans-unit id="a88e7a573b0a77f73eb1f2a5e5b8de48275a7af8" translate="yes" xml:space="preserve">
          <source>Entry Point</source>
          <target state="translated">エントリーポイント</target>
        </trans-unit>
        <trans-unit id="1552f36ee13c5c4910ec207795eb05b9e58ae679" translate="yes" xml:space="preserve">
          <source>Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.</source>
          <target state="translated">配列には毎回全く同じオブジェクト参照が含まれているかもしれませんが、配列自体は別の参照なので、浅い平等性チェックは失敗し、React Reduxはラップされたコンポーネントを再レンダリングしてしまいます。</target>
        </trans-unit>
        <trans-unit id="b6a853804467e62df08fd20ca2def253cd121c2e" translate="yes" xml:space="preserve">
          <source>Ever wondered what &lt;code&gt;applyMiddleware&lt;/code&gt; itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, &lt;code&gt;applyMiddleware&lt;/code&gt; is an example of the most powerful Redux extension mechanism called &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt;. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;. Middleware is less powerful than a store enhancer, but it is easier to write.</source>
          <target state="translated">&lt;code&gt;applyMiddleware&lt;/code&gt; 自体が何か疑問に思ったことはありませんか？ミドルウェア自体よりも強力な拡張メカニズムであるべきです。実際、 &lt;code&gt;applyMiddleware&lt;/code&gt; は、&lt;a href=&quot;../glossary#store-enhancer&quot;&gt;ストアエンハンサー&lt;/a&gt;と呼ばれる最も強力なRedux拡張メカニズムの例です。自分でストアエンハンサーを作成することはほとんどありません。ストアエンハンサーのもう1つの例は&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;です。ミドルウェアはストアエンハンサーほど強力ではありませんが、記述は簡単です。</target>
        </trans-unit>
        <trans-unit id="fc61f5aead67e5d9613283a1a13842ab6b6cf6dd" translate="yes" xml:space="preserve">
          <source>Every function described above is a top-level export. You can import any of them like this:</source>
          <target state="translated">上で説明した関数はすべてトップレベルのエクスポートです。このようにインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="f5ee7559d25a08d85f86a3eafc206977946b6a08" translate="yes" xml:space="preserve">
          <source>Every release, along with the migration instructions, is documented on the Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">すべてのリリースは、移行手順とともに、Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;リリース&lt;/a&gt;ページに記載されています。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="e3199316bf69a183958e485b0e3d61bc9694e2fb" translate="yes" xml:space="preserve">
          <source>Example Apps</source>
          <target state="translated">アプリ例</target>
        </trans-unit>
        <trans-unit id="29f523dd5956d4673cb690577c1f546426cc73cb" translate="yes" xml:space="preserve">
          <source>Example: Custom Logger Middleware</source>
          <target state="translated">例。カスタム ロガー ミドルウェア</target>
        </trans-unit>
        <trans-unit id="2624afd8c460d6518734431bfb5d77b64cd9d60b" translate="yes" xml:space="preserve">
          <source>Example: Reddit API</source>
          <target state="translated">例。Reddit API</target>
        </trans-unit>
        <trans-unit id="cfa9b551b74932054b2efb6c627693e8d27f541a" translate="yes" xml:space="preserve">
          <source>Example: Todo List</source>
          <target state="translated">例.Todoリスト</target>
        </trans-unit>
        <trans-unit id="76a4c17cabc25fb419d3b53e5dbaa4dd4a5664bd" translate="yes" xml:space="preserve">
          <source>Example: Using Thunk Middleware for Async Actions</source>
          <target state="translated">例。Thunkミドルウェアの非同期アクションへの使用</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5f96798ae5ca58a4c6c508043f2d289c9f41fbff" translate="yes" xml:space="preserve">
          <source>Examples: Real World example</source>
          <target state="translated">実例を紹介します。実世界の例</target>
        </trans-unit>
        <trans-unit id="4a0cf0d774ed2b3b87b2898557f897bfef233151" translate="yes" xml:space="preserve">
          <source>Examples: Tree View</source>
          <target state="translated">例 ツリービュー</target>
        </trans-unit>
        <trans-unit id="032263383a22a1454a019ce94b7dce90ebcad1e2" translate="yes" xml:space="preserve">
          <source>Exploring Redux Middleware</source>
          <target state="translated">Redux ミドルウェアを探る</target>
        </trans-unit>
        <trans-unit id="b171f7143f21268e520b74f4f5ead4fcb82ce831" translate="yes" xml:space="preserve">
          <source>Extracting Case Reducers</source>
          <target state="translated">ケース減速機の抽出</target>
        </trans-unit>
        <trans-unit id="1be76799495bdf5c930a8ddd44f5e9d6d64c47cb" translate="yes" xml:space="preserve">
          <source>Extracting Utility Functions</source>
          <target state="translated">ユーティリティ関数の抽出</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="e38e4017ee383168752e8a33c5d6022a9a406df4" translate="yes" xml:space="preserve">
          <source>FAQ: Actions - &quot;1:1 mapping between reducers and actions?&quot;</source>
          <target state="translated">よくある質問 アクション-&quot;レデューサーとアクションの間に1:1のマッピングは?&quot;</target>
        </trans-unit>
        <trans-unit id="df7e17066220bc43c820094351b4e2c42bbba769" translate="yes" xml:space="preserve">
          <source>FAQ: Immutable Data</source>
          <target state="translated">よくある質問 不変データ</target>
        </trans-unit>
        <trans-unit id="7a41b860bf1ee467edbac48fd846ae33b759b787" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Reducing Update Events</source>
          <target state="translated">よくある質問 パフォーマンス-更新イベントの削減</target>
        </trans-unit>
        <trans-unit id="ee0854a17ba3e0b5e9e9e1c578ac31d5ab4c9027" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Scaling</source>
          <target state="translated">よくある質問 パフォーマンス-スケーリング</target>
        </trans-unit>
        <trans-unit id="a3ab661908a8748685e7811083bdaf66ba18c68b" translate="yes" xml:space="preserve">
          <source>Finally, Redux provides a utility called &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; that does the same boilerplate logic that the &lt;code&gt;todoApp&lt;/code&gt; above currently does. With its help, we can rewrite &lt;code&gt;todoApp&lt;/code&gt; like this:</source>
          <target state="translated">最後に、Reduxは、上記の &lt;code&gt;todoApp&lt;/code&gt; が現在行っているのと同じボイラープレートロジックを実行するCombineReducers &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;と呼ばれるユーティリティを提供します。その助けを借りて、 &lt;code&gt;todoApp&lt;/code&gt; を次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="0d847a6b9dee3deeeb8620787402b3a6277cb077" translate="yes" xml:space="preserve">
          <source>Finally, how do we use the synchronous action creators we &lt;a href=&quot;#synchronous-action-creators&quot;&gt;defined earlier&lt;/a&gt; together with network requests? The standard way to do it with Redux is to use the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk middleware&lt;/a&gt;. It comes in a separate package called &lt;code&gt;redux-thunk&lt;/code&gt;. We'll explain how middleware works in general &lt;a href=&quot;middleware&quot;&gt;later&lt;/a&gt;; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a &lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;thunk&lt;/a&gt;.</source>
          <target state="translated">最後に、&lt;a href=&quot;#synchronous-action-creators&quot;&gt;先ほど定義し&lt;/a&gt;た同期アクションクリエーターとネットワークリクエストをどのように使用しますか？Reduxでこれを行う標準的な方法は、&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunkミドルウェア&lt;/a&gt;を使用することです。これは &lt;code&gt;redux-thunk&lt;/code&gt; と呼ばれる別のパッケージで提供されます。私たちは、ミドルウェアは、一般的にどのように動作するかを説明しましょう&lt;a href=&quot;middleware&quot;&gt;、後で&lt;/a&gt;。今のところ、知っておくべき重要なことが1つだけあります。この特定のミドルウェアを使用することで、アクション作成者はアクションオブジェクトの代わりに関数を返すことができます。このようにして、アクション作成者は&lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;サンクになり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="efe6ba28d43370e1a707260f9b15d1702f3f2d3e" translate="yes" xml:space="preserve">
          <source>Finally, if the user performs an action (e.g. decrement the counter) while we're in the middle of the undo stack, we're going to discard the existing future:</source>
          <target state="translated">最後に、アンドゥスタックの途中でユーザーがアクション(例えばカウンタのデクリメント)を行った場合、既存の未来を破棄することになります。</target>
        </trans-unit>
        <trans-unit id="11194f10e6abbfaba6e4a214b87b681a0b877527" translate="yes" xml:space="preserve">
          <source>Finally, the implementation of the &lt;code&gt;TOGGLE_TODO&lt;/code&gt; handler shouldn't come as a complete surprise:</source>
          <target state="translated">最後に、 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; ハンドラーの実装は、完全な驚きではありません。</target>
        </trans-unit>
        <trans-unit id="d36e5836f13cd173c594e9d1ae569e82cd4fcdf5" translate="yes" xml:space="preserve">
          <source>Finally, to update objects, you'll need something like &lt;code&gt;_.extend&lt;/code&gt; from Underscore, or better, an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; polyfill.</source>
          <target state="translated">最後に、オブジェクトを更新するには、アンダースコアの &lt;code&gt;_.extend&lt;/code&gt; 、またはより良いのは&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt; polyfillのようなものが必要です。</target>
        </trans-unit>
        <trans-unit id="199eca41911960b98af69aa50c0333310e9f9b48" translate="yes" xml:space="preserve">
          <source>Finally, we create the &lt;code&gt;VisibleTodoList&lt;/code&gt; by calling &lt;code&gt;connect()&lt;/code&gt; and passing these two functions:</source>
          <target state="translated">最後に、 &lt;code&gt;connect()&lt;/code&gt; を呼び出して次の2つの関数を渡すことにより、 &lt;code&gt;VisibleTodoList&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="ca381bfbf08ee78348d1eccdc53ec800366da008" translate="yes" xml:space="preserve">
          <source>Finally, we'll add one more action type for changing the currently visible todos.</source>
          <target state="translated">最後に、現在表示されているToDoを変更するためのアクションタイプを1つ追加します。</target>
        </trans-unit>
        <trans-unit id="905199d1f6693b173b187362217e8ceaf7447b9d" translate="yes" xml:space="preserve">
          <source>Finally, when the network request comes through, we will dispatch &lt;code&gt;RECEIVE_POSTS&lt;/code&gt;:</source>
          <target state="translated">最後に、ネットワークリクエストが到着すると、 &lt;code&gt;RECEIVE_POSTS&lt;/code&gt; をディスパッチします。</target>
        </trans-unit>
        <trans-unit id="0d68b76ad804092f57e99c9239a27fd692ed5c9b" translate="yes" xml:space="preserve">
          <source>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</source>
          <target state="translated">最後に、非同期コードをさらにシンプルにするために、ミドルウェアのようなReduxのイディオムを使い始めるのもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="909dbfd3043edaf382cc7e5528d1f59884ba5ee8" translate="yes" xml:space="preserve">
          <source>Find the balance between these two extremes, and you will master Redux.</source>
          <target state="translated">この両極端のバランスを見つけて、Reduxをマスターしましょう。</target>
        </trans-unit>
        <trans-unit id="6f07a78d30b7ff474926fd0dc8957f55aa822b17" translate="yes" xml:space="preserve">
          <source>Find the rest of the container components defined below:</source>
          <target state="translated">以下に定義されているコンテナコンポーネントの残りの部分を探します。</target>
        </trans-unit>
        <trans-unit id="4f6506477b8650e1de1bd943b9bd705e36a074e2" translate="yes" xml:space="preserve">
          <source>Finding &lt;code&gt;state&lt;/code&gt;'s place with React and Redux</source>
          <target state="translated">ReactとReduxで &lt;code&gt;state&lt;/code&gt; の場所を見つける</target>
        </trans-unit>
        <trans-unit id="73d1849effa55d228df19c7e131b0d22e859600d" translate="yes" xml:space="preserve">
          <source>Finished reading the article? Let's recount their differences:</source>
          <target state="translated">記事を読み終えましたか?彼らの違いを再確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="083f5d4f5390de8b339a7e0d1bcbede9836be5c8" translate="yes" xml:space="preserve">
          <source>Firefox's new debugger</source>
          <target state="translated">Firefox の新しいデバッガ</target>
        </trans-unit>
        <trans-unit id="bac6033d8edd65bf451fde639fbb2062cd288167" translate="yes" xml:space="preserve">
          <source>First Attempt: Writing a Reducer</source>
          <target state="translated">最初の試み。レッサーを書く</target>
        </trans-unit>
        <trans-unit id="a63efbd7ad3629ab9570dc20eea84696652d1fe6" translate="yes" xml:space="preserve">
          <source>First and foremost, &lt;code&gt;combineReducers&lt;/code&gt; is simply &lt;strong&gt;a utility function to simplify the most common use case when writing Redux reducers&lt;/strong&gt;. You are &lt;em&gt;not&lt;/em&gt; required to use it in your own application, and it does &lt;em&gt;not&lt;/em&gt; handle every possible scenario. It is entirely possible to write reducer logic without using it, and it is quite common to need to write custom reducer logic for cases that &lt;code&gt;combineReducer&lt;/code&gt; does not handle. (See &lt;a href=&quot;beyondcombinereducers&quot;&gt;Beyond &lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for examples and suggestions.)</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; もまず、combinReducersは&lt;strong&gt;、Reduxのレデューサーを作成する際の最も一般的な使用例を単純化するユーティリティ関数&lt;/strong&gt;です。あなたはされて&lt;em&gt;いない&lt;/em&gt;独自のアプリケーションでそれを使用するために必要な、それはない&lt;em&gt;ではない&lt;/em&gt;、すべての可能なシナリオを扱います。それを使用せずにレデューサーロジックを作成することは完全に可能であり、 &lt;code&gt;combineReducer&lt;/code&gt; が処理しない場合のためにカスタムレデューサーロジックを作成する必要があることは非常に一般的です。 （例と提案については、&lt;a href=&quot;beyondcombinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;を超えてを参照してください。）</target>
        </trans-unit>
        <trans-unit id="928aade909ab97ef47ad692458ac7b1733155f4f" translate="yes" xml:space="preserve">
          <source>First and foremost, it's important to understand that your entire application really only has &lt;strong&gt;one single reducer function&lt;/strong&gt;: the function that you've passed into &lt;code&gt;createStore&lt;/code&gt; as the first argument. That one single reducer function ultimately needs to do several things:</source>
          <target state="translated">何よりもまず、アプリケーション全体には、&lt;strong&gt;1つのレデューサー関数（&lt;/strong&gt;最初の引数として &lt;code&gt;createStore&lt;/code&gt; に渡した関数）が&lt;strong&gt;1つ&lt;/strong&gt;しかないことを理解することが重要です。その1つのレデューサー関数は、最終的にいくつかのことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="2b3ce87bff6a9cf7a60a80fd1b3760fbe7caf2c7" translate="yes" xml:space="preserve">
          <source>First let's consider a case where you have a single reducer. Say you don't use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">最初に、レデューサーが1つある場合を考えてみましょう。 &lt;code&gt;combineReducers()&lt;/code&gt; 使用しないとします。</target>
        </trans-unit>
        <trans-unit id="7060a8772c7ed50446a754b52b327f7921592892" translate="yes" xml:space="preserve">
          <source>First of all, you need to run</source>
          <target state="translated">まず最初に</target>
        </trans-unit>
        <trans-unit id="fced756f7f0c570facc991f413283a69b01ef80e" translate="yes" xml:space="preserve">
          <source>First we will need to import &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; from React Router. Here's how to do it:</source>
          <target state="translated">まず、React Routerから &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; をインポートする必要があります。方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="928541190af20f02ef3132ea1dc14770650e0586" translate="yes" xml:space="preserve">
          <source>First, create a new container component called &lt;code&gt;UndoRedo&lt;/code&gt; for these buttons. We won't bother to split the presentational part into a separate file because it is very small:</source>
          <target state="translated">まず、これらのボタン用の &lt;code&gt;UndoRedo&lt;/code&gt; という新しいコンテナーコンポーネントを作成します。プレゼンテーションの部分は非常に小さいので、別のファイルに分割する必要はありません。</target>
        </trans-unit>
        <trans-unit id="066e50b38844dd1b5b820eb86ad656704f58e5eb" translate="yes" xml:space="preserve">
          <source>First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat &lt;em&gt;less&lt;/em&gt; memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.</source>
          <target state="translated">まず、生のメモリ使用量に関して、Reduxは他のJavaScriptライブラリと何の違いもありません。唯一の違いは、バックボーンなどのさまざまな独立したモデルインスタンスに保存されるのではなく、さまざまなオブジェクト参照がすべて1つのツリーにネストされることです。次に、典型的なReduxアプリは、同等のバックボーンアプリよりもメモリ使用量がやや&lt;em&gt;少なくなり&lt;/em&gt;ます。これは、Reduxがモデルとコレクションのインスタンスを作成するのではなく、プレーンなJavaScriptオブジェクトと配列の使用を推奨するためです。最後に、Reduxは一度に1つの状態ツリー参照のみを保持します。そのツリーで参照されなくなったオブジェクトは、通常どおりガベージコレクションされます。</target>
        </trans-unit>
        <trans-unit id="147db38719fb360e8ff8a98d1999647a14de68aa" translate="yes" xml:space="preserve">
          <source>First, let's define some actions.</source>
          <target state="translated">まず、いくつかのアクションを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="d50b1a37307b503b16d51ae5983d1f25a15405ee" translate="yes" xml:space="preserve">
          <source>First, we will install &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;. Enzyme uses the &lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities&lt;/a&gt; underneath, but is more convenient, readable, and powerful.</source>
          <target state="translated">まず、&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;酵素&lt;/a&gt;をインストールします。Enzymeは、下にある&lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Testユーティリティを&lt;/a&gt;使用しますが、より便利で、読みやすく、強力です。</target>
        </trans-unit>
        <trans-unit id="b752ccff5aae9d198427fafe188894e7b4c4185f" translate="yes" xml:space="preserve">
          <source>First, we'll need a middleware function. This is similar to the real &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt;.</source>
          <target state="translated">まず、ミドルウェア機能が必要です。これは実際の&lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunkに&lt;/a&gt;似ています。</target>
        </trans-unit>
        <trans-unit id="889e1c2f5289eea716835fde0adffaefad64d56f" translate="yes" xml:space="preserve">
          <source>Flux</source>
          <target state="translated">Flux</target>
        </trans-unit>
        <trans-unit id="2a436f0a330413dcad542ab5cfe9f14d15c70a1e" translate="yes" xml:space="preserve">
          <source>Following in the steps of &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;, and &lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;Event Sourcing&lt;/a&gt;, &lt;strong&gt;Redux attempts to make state mutations predictable&lt;/strong&gt; by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the &lt;a href=&quot;threeprinciples&quot;&gt;three principles&lt;/a&gt; of Redux.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;、&lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;、および&lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;イベントソーシング&lt;/a&gt;の手順に従って、&lt;strong&gt;Reduxは&lt;/strong&gt;、更新が発生する方法とタイミングに特定の制限を課すことにより&lt;strong&gt;、状態の変化を予測可能にしよう&lt;/strong&gt;とします。これらの制限は、Redux の&lt;a href=&quot;threeprinciples&quot;&gt;3つの原則&lt;/a&gt;に反映されています。</target>
        </trans-unit>
        <trans-unit id="cac52571ae4d35859cbf2d2ebb033839ab2f50f8" translate="yes" xml:space="preserve">
          <source>For Offline docs, please see: &lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;</source>
          <target state="translated">オフラインドキュメントについては、&lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="3da99abcd0c1ecdf884964d566bca5697a74e01e" translate="yes" xml:space="preserve">
          <source>For PDF, ePub, and MOBI exports for offline reading, and instructions on how to create them, please see: &lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel/redux-offline-docs&lt;/a&gt;.</source>
          <target state="translated">オフラインで読むためのPDF、ePub、MOBIエクスポート、およびそれらの作成方法については、&lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel / redux-offline-docs&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="1569bd4eacec55d8eceb1c2595d3b535c8d3d3cf" translate="yes" xml:space="preserve">
          <source>For React Redux, &lt;code&gt;connect&lt;/code&gt; checks to see if the props returned from a &lt;code&gt;mapStateToProps&lt;/code&gt; function have changed in order to determine if a component needs to update. To improve performance, &lt;code&gt;connect&lt;/code&gt; takes some shortcuts that rely on the state being immutable, and uses shallow reference equality checks to detect changes. This means that &lt;strong&gt;changes made to objects and arrays by direct mutation will not be detected, and components will not re-render&lt;/strong&gt;.</source>
          <target state="translated">React Reduxの場合、 &lt;code&gt;connect&lt;/code&gt; は、コンポーネントを更新する必要があるかどうかを判断するために、 &lt;code&gt;mapStateToProps&lt;/code&gt; 関数から返された小道具が変更されているかどうかを確認します。パフォーマンスを向上させるために、 &lt;code&gt;connect&lt;/code&gt; は状態が不変であることに依存するいくつかのショートカットを採用し、浅い参照等価チェックを使用して変更を検出します。つまり、&lt;strong&gt;直接ミューテーションによってオブジェクトと配列に加え&lt;/strong&gt;られた&lt;strong&gt;変更は検出されず、コンポーネントは再レンダリングされません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3c36a66a555508cc950b3f16c937117a95df81ef" translate="yes" xml:space="preserve">
          <source>For a Redux app, your entire state tree should be an Immutable.JS object, with no plain JavaScript objects used at all.</source>
          <target state="translated">Reduxアプリでは、ステートツリー全体がImmutable.JSオブジェクトとなり、プレーンなJavaScriptオブジェクトは一切使用されません。</target>
        </trans-unit>
        <trans-unit id="373c63c01af4767c75ccf47739d4a3ed95ce0716" translate="yes" xml:space="preserve">
          <source>For an extensive list of everything related to Redux, we recommend &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;. It contains examples, boilerplates, middleware, utility libraries, and more. &lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React/Redux Links&lt;/a&gt; contains tutorials and other useful resources for anyone learning React or Redux, and &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; lists many Redux-related libraries and addons.</source>
          <target state="translated">Reduxに関連するすべての詳細なリストについては、&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;をお勧めします。例、ボイラープレート、ミドルウェア、ユーティリティライブラリなどが含まれています。&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React / Reduxリンクに&lt;/a&gt;は、ReactまたはReduxを学ぶ人のためのチュートリアルやその他の役立つリソースが含まれています。また、&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Reduxエコシステムリンクに&lt;/a&gt;は、多くのRedux関連のライブラリとアドオンがリストされています。</target>
        </trans-unit>
        <trans-unit id="8b99470d4a1567b0670d5920564c85b87e32721b" translate="yes" xml:space="preserve">
          <source>For any action that is not recognized, it must return the &lt;code&gt;state&lt;/code&gt; given to it as the first argument.</source>
          <target state="translated">認識されないアクションについては、最初の引数として指定された &lt;code&gt;state&lt;/code&gt; 返す必要があります。</target>
        </trans-unit>
        <trans-unit id="28c64b95d623e1af01c5fa554a02283a92526e40" translate="yes" xml:space="preserve">
          <source>For any meaningful application, putting &lt;em&gt;all&lt;/em&gt; your update logic into a single reducer function is quickly going to become unmaintainable. While there's no single rule for how long a function should be, it's generally agreed that functions should be relatively short and ideally only do one specific thing. Because of this, it's good programming practice to take pieces of code that are very long or do many different things, and break them into smaller pieces that are easier to understand.</source>
          <target state="translated">意味のあるアプリケーションの場合、&lt;em&gt;すべて&lt;/em&gt;の更新ロジックを単一のレデューサー関数に入れると、すぐに保守できなくなります。関数の長さについて単一の規則はありませんが、関数は比較的短く、理想的には1つの特定のことだけを行うべきであると一般に合意されています。このため、非常に長いコードやさまざまなことを行うコードの一部を取り出して、理解しやすい小さな断片に分割することは、優れたプログラミング方法です。</target>
        </trans-unit>
        <trans-unit id="2ce91fabee949d5ba66d92e41ee08124438c9737" translate="yes" xml:space="preserve">
          <source>For async action creators using &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; or other middleware, it's best to completely mock the Redux store for tests. You can apply the middleware to a mock store using &lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;. You can also use &lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt; to mock the HTTP requests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Reduxサンク&lt;/a&gt;またはその他のミドルウェアを使用する非同期アクションの作成者は、テストのためにReduxストアを完全に模擬するのが最善です。&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;を使用して、ミドルウェアをモックストアに適用できます。&lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt;を使用してHTTPリクエストをモックすることもできます。</target>
        </trans-unit>
        <trans-unit id="3fd7c213802a3dd8c216e494ed4fd0e167b08890" translate="yes" xml:space="preserve">
          <source>For clarity, these terms will be used to distinguish between different types of functions and different use cases:</source>
          <target state="translated">明確にするために、これらの用語は、異なるタイプの機能と異なるユースケースを区別するために使用されます。</target>
        </trans-unit>
        <trans-unit id="264e5e569126bec0eceb43b84e1205a13c4b6e76" translate="yes" xml:space="preserve">
          <source>For convenience, you can also pass a single function as the first argument, and get a function in return.</source>
          <target state="translated">便利なように、第1引数に1つの関数を渡して、その戻り値で関数を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="a90bf7f5a9bb0b7bee51eca7178498d0496d1d7b" translate="yes" xml:space="preserve">
          <source>For copying very large objects, &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;plain JavaScript can be over 100 times slower&lt;/a&gt; than an optimized immutable library.</source>
          <target state="translated">非常に大きなオブジェクトをコピーする場合、&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;プレーンJavaScriptは&lt;/a&gt;最適化された不変のライブラリよりも100倍以上遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7525b69cd07a6f2ad0ac830aafa7a477337193ed" translate="yes" xml:space="preserve">
          <source>For every list of items, you'll want to store &lt;code&gt;isFetching&lt;/code&gt; to show a spinner, &lt;code&gt;didInvalidate&lt;/code&gt; so you can later toggle it when the data is stale, &lt;code&gt;lastUpdated&lt;/code&gt; so you know when it was fetched the last time, and the &lt;code&gt;items&lt;/code&gt; themselves. In a real app, you'll also want to store pagination state like &lt;code&gt;fetchedPageCount&lt;/code&gt; and &lt;code&gt;nextPageUrl&lt;/code&gt;.</source>
          <target state="translated">アイテムのすべてのリストについて、スピナー、 &lt;code&gt;isFetching&lt;/code&gt; を表示するために &lt;code&gt;didInvalidate&lt;/code&gt; て、後でデータが古くなったときに切り替えることができるようにし、 &lt;code&gt;lastUpdated&lt;/code&gt; を使用して、最後にいつフェッチされたか、および &lt;code&gt;items&lt;/code&gt; 自体を確認します。実際のアプリでは、 &lt;code&gt;fetchedPageCount&lt;/code&gt; や &lt;code&gt;nextPageUrl&lt;/code&gt; などのページネーションの状態も保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="cd5da791bf1d292d4b08f432961ce1f7ce752416" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; lets the action creators invert control by dispatching functions. They would receive &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; as an argument and may call it asynchronously. Such functions are called &lt;em&gt;thunks&lt;/em&gt;. Another example of middleware is &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;. It lets you dispatch a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; async action, and dispatches a normal action when the Promise resolves.</source>
          <target state="translated">たとえば、&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunkを&lt;/a&gt;使用すると、アクション作成者は関数をディスパッチして制御を反転できます。それらは引数として&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;を受け取り、非同期にそれを呼び出すかもしれません。このような関数は&lt;em&gt;サンク&lt;/em&gt;と呼ばれます。ミドルウェアのもう1つの例は&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;です。それはあなたが派遣することができます&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;約束の&lt;/a&gt;非同期アクションを、そしてときプロミス解決さ正常なアクションをディスパッチします。</target>
        </trans-unit>
        <trans-unit id="c10a32bf34bb234c4f4d4ea0c462233658b63285" translate="yes" xml:space="preserve">
          <source>For example, a reducer like this is wrong because it mutates the state:</source>
          <target state="translated">例えば、このような減速機は状態を変異させるので間違っています。</target>
        </trans-unit>
        <trans-unit id="bc9e2d4355c30145cce077b91c60d63448e5aed4" translate="yes" xml:space="preserve">
          <source>For example, instead of &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt;, you would use &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt; の代わりに、 &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="8910597d94358b44fab63079f57037fc6eedac16" translate="yes" xml:space="preserve">
          <source>For example, instead of calling &lt;code&gt;dispatch&lt;/code&gt; with an object literal:</source>
          <target state="translated">たとえば、オブジェクトリテラルで &lt;code&gt;dispatch&lt;/code&gt; を呼び出す代わりに、</target>
        </trans-unit>
        <trans-unit id="36409b0b5da0fd93351cad56b27c2cc459ec9cbc" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;mapStateToProps&lt;/code&gt; function will never trigger a re-render:</source>
          <target state="translated">たとえば、次の &lt;code&gt;mapStateToProps&lt;/code&gt; 関数は再レンダリングをトリガーしません。</target>
        </trans-unit>
        <trans-unit id="405aef87040b2f5fe3183ef8ee7aaa8b9e2f3921" translate="yes" xml:space="preserve">
          <source>For example, the following will always trigger a re-render:</source>
          <target state="translated">例えば、以下のようにすると、必ずリレンダーが発生します。</target>
        </trans-unit>
        <trans-unit id="43b08550f3233d89fd265c7a809fdb23fce5207d" translate="yes" xml:space="preserve">
          <source>For example, the state shape of a counter app might look like this:</source>
          <target state="translated">例えば、カウンターアプリの状態の形はこんな感じになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="4676e5ae615d02cd767e41c0d9c575c5c5363047" translate="yes" xml:space="preserve">
          <source>For example, you will no longer be able to reference an object&amp;rsquo;s properties through standard JavaScript dot or bracket notation. Instead, you must reference them via Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; methods, which use an awkward syntax that accesses properties via an array of strings, each of which represents a property key.</source>
          <target state="translated">たとえば、標準のJavaScriptドットまたはブラケット表記を使用してオブジェクトのプロパティを参照することはできなくなります。代わりに、Immutable.JSの &lt;code&gt;get()&lt;/code&gt; または &lt;code&gt;getIn()&lt;/code&gt; メソッドを介してそれらを参照する必要があります。これらのメソッドは、それぞれがプロパティキーを表す文字列の配列を介してプロパティにアクセスする厄介な構文を使用します。</target>
        </trans-unit>
        <trans-unit id="12b6ef57734c544f1e210f261517935088c63d17" translate="yes" xml:space="preserve">
          <source>For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt;. That creates a new function reference every time the parent re-renders. It's generally good practice to only bind callbacks once in the parent component's constructor.</source>
          <target state="translated">接続されていないコンポーネントの場合、どの小道具が渡されているかを確認したい場合があります。一般的な問題は、 &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt; 、親コンポーネントがレンダリング関数内でコールバックを再バインドすることです。} /&amp;gt;。これにより、親が再レンダリングするたびに新しい関数参照が作成されます。通常は、親コンポーネントのコンストラクターでコールバックを1回だけバインドすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f37294e7b86a5fec1ad730201ca1b51e170da12c" translate="yes" xml:space="preserve">
          <source>For our example, we'll imagine there is an external datastore that contains the counter's initial value (Counter As A Service, or CaaS). We'll make a mock call over to them and build our initial state from the result. We'll start by building out our API call:</source>
          <target state="translated">この例では、カウンタの初期値を格納する外部データストア(Counter As A Service、または CaaS)があるとします。そこでモックコールを行い、その結果から初期状態を構築します。まず、APIコールを構築することから始めます。</target>
        </trans-unit>
        <trans-unit id="995f52d4ef9a4c2e7bfadd425b73b546c07eadfc" translate="yes" xml:space="preserve">
          <source>For our simplistic example, coercing our input into a number is sufficiently secure. If you're handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as &lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt;.</source>
          <target state="translated">この単純な例では、入力を数値に強制変換することで十分に安全です。フリーフォームテキストなどのより複雑な入力を処理している場合は、その入力を&lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt;などの適切なサニタイズ関数で実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="7396dc033a9d17308dac01b1e6d7aa01bc7866e7" translate="yes" xml:space="preserve">
          <source>For our todo app, we want to store two different things:</source>
          <target state="translated">todoアプリでは、2つの異なるものを保存したいと考えています。</target>
        </trans-unit>
        <trans-unit id="b88fefd81c01717012ff82bfc5ac24328d967a87" translate="yes" xml:space="preserve">
          <source>For this example, we'll be using &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</source>
          <target state="translated">この例では、シンプルなWebサーバーとして&lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;を使用します。また、デフォルトではReduxに含まれていないため、Redux用のReactバインディングをインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="f714199c4cde247b055dd1036923fa69c491b814" translate="yes" xml:space="preserve">
          <source>For time traveling, the Redux DevTools expect that replaying recorded actions would output a state value, but not change anything else. &lt;strong&gt;Side effects like mutation or asynchronous behavior will cause time travel to alter behavior between steps, breaking the application&lt;/strong&gt;.</source>
          <target state="translated">時間旅行の場合、Redux DevToolsは記録されたアクションを再生すると状態値が出力され、それ以外は何も変更されないことを期待します。&lt;strong&gt;ミューテーションや非同期動作などの副作用により、タイムトラベルがステップ間の動作を変更し、アプリケーションを破壊します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5d1154ea57349682fcc3f891e405a8a167837c09" translate="yes" xml:space="preserve">
          <source>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</source>
          <target state="translated">サーバー上で実行されるユニバーサル アプリの場合、リクエストごとにストア インスタンスを作成して分離します。ストア インスタンスにいくつかのデータ フェッチ アクションをディスパッチし、サーバー上でアプリをレンダリングする前にそれらが完了するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="92c80d0eb6a19f502dd39ce9e0007f6cec7683d4" translate="yes" xml:space="preserve">
          <source>Four Strategies for Organizing Code</source>
          <target state="translated">コードを整理するための4つの戦略</target>
        </trans-unit>
        <trans-unit id="76682a747378edf323eb6fca480334e44800121b" translate="yes" xml:space="preserve">
          <source>Frequently, yes. There are various tradeoffs and opinions to consider, but there are many good reasons to use Immutable.JS. Do not underestimate the difficulty of trying to track down a property of your state tree that has been inadvertently mutated.</source>
          <target state="translated">頻繁に、はい。考慮すべきトレードオフや意見は様々ですが、Immutable.JS を使用する理由はたくさんあります。不注意で突然変異してしまったステートツリーのプロパティを追跡しようとすることの難しさを過小評価しないでください。</target>
        </trans-unit>
        <trans-unit id="46dc46fc099af2967e7cb377eb917390bbe8d91f" translate="yes" xml:space="preserve">
          <source>From Backbone</source>
          <target state="translated">バックボーンから</target>
        </trans-unit>
        <trans-unit id="3f765f89e7e86977403237359a10b70b8245b636" translate="yes" xml:space="preserve">
          <source>From Flux</source>
          <target state="translated">フラックスから</target>
        </trans-unit>
        <trans-unit id="bfbacf3ec560ee96572c8e953a6aff0a1a3667b3" translate="yes" xml:space="preserve">
          <source>From Flux to Redux: Async Actions the easy way</source>
          <target state="translated">Flux から Redux へ:Async アクションの簡単な方法</target>
        </trans-unit>
        <trans-unit id="75482a47184505a4b6fae82571885f1d4ef06ba7" translate="yes" xml:space="preserve">
          <source>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</source>
          <target state="translated">冒頭から、ReduxはReactとは無関係であることを強調しておく必要があります。React、Angular、Ember、jQuery、バニラJavaScriptでReduxアプリを書くことができます。</target>
        </trans-unit>
        <trans-unit id="224f84dc1c16ed87eb23acbffde43619f014060d" translate="yes" xml:space="preserve">
          <source>Full-Stack Redux Tutorial</source>
          <target state="translated">フルスタックReduxチュートリアル</target>
        </trans-unit>
        <trans-unit id="3823c3e33f7c5c6aab3e4cafa98d3b53883fbcdd" translate="yes" xml:space="preserve">
          <source>Functions for handling a specific update case, which often need parameters other than the typical &lt;code&gt;(state, action)&lt;/code&gt; pair</source>
          <target state="translated">一般的な &lt;code&gt;(state, action)&lt;/code&gt; ペア以外のパラメーターが必要になることが多い特定の更新ケースを処理するための関数</target>
        </trans-unit>
        <trans-unit id="881a7f4ab6d6cdbe058390dcfebb91eedae46fb5" translate="yes" xml:space="preserve">
          <source>Functions which handle &lt;em&gt;all&lt;/em&gt; updates for a given slice of state. These functions do generally have the typical &lt;code&gt;(state, action)&lt;/code&gt; parameter signature</source>
          <target state="translated">指定された状態のスライスの&lt;em&gt;すべての&lt;/em&gt;更新を処理&lt;em&gt;する&lt;/em&gt;関数。これらの関数には通常、典型的な &lt;code&gt;(state, action)&lt;/code&gt; パラメータシグネチャがあります</target>
        </trans-unit>
        <trans-unit id="669174087b9bbb07e556f8eda6679016d67b42c9" translate="yes" xml:space="preserve">
          <source>Further Information</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="285d7a1408b289b80750e52c797a605ffba295ee" translate="yes" xml:space="preserve">
          <source>Further Suggestions</source>
          <target state="translated">さらなる提案</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">その他の情報</target>
        </trans-unit>
        <trans-unit id="7d69e595b386dcd4b71cc9ff73b11b2154e10dd8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can add additional layers of security by sanitizing your state output. &lt;code&gt;JSON.stringify&lt;/code&gt; can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt;, or via more sophisticated libraries such as &lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt;.</source>
          <target state="translated">さらに、状態の出力をサニタイズすることにより、セキュリティの層を追加できます。 &lt;code&gt;JSON.stringify&lt;/code&gt; はスクリプトインジェクションの影響を受ける可能性があります。これに対抗するには、HTMLタグやその他の危険な文字のJSON文字列をスクラブできます。これは、 &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt; などの文字列の単純なテキスト置換、または&lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt;などのより高度なライブラリを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c4692b39bf633417d53521cb512f44dbc259440a" translate="yes" xml:space="preserve">
          <source>Generating Action Creators</source>
          <target state="translated">アクション クリエイターの生成</target>
        </trans-unit>
        <trans-unit id="179c9a970856be2ac8a72de045cb7b6d6b4b6c90" translate="yes" xml:space="preserve">
          <source>Generating Reducers</source>
          <target state="translated">レデューサーの生成</target>
        </trans-unit>
        <trans-unit id="46c1ccf8c4dcce798c8264f04e642d8a0159063d" translate="yes" xml:space="preserve">
          <source>Getting Started with React, Redux, and Immutable</source>
          <target state="translated">React,Redux,および Immutable を使い始めよう</target>
        </trans-unit>
        <trans-unit id="3185ff60f7a746675039a0e069131de1e5f61876" translate="yes" xml:space="preserve">
          <source>Gist: Breaking out of Redux paradigm to isolate apps</source>
          <target state="translated">要点:Reduxのパラダイムから脱却してアプリを分離する</target>
        </trans-unit>
        <trans-unit id="10ae5196eb35af7600e4766e0ded323420cfe70a" translate="yes" xml:space="preserve">
          <source>Gist: Redux-Thunk examples</source>
          <target state="translated">要点:Redux-Thunk の例</target>
        </trans-unit>
        <trans-unit id="244ed27647275ec13c3db28bb136d4743fa6b213" translate="yes" xml:space="preserve">
          <source>Gist: state mutations</source>
          <target state="translated">概要:状態の突然変異</target>
        </trans-unit>
        <trans-unit id="8f8269375bc0d8516c14e2645a941c5fefb4b9c0" translate="yes" xml:space="preserve">
          <source>Given this middleware we just wrote:</source>
          <target state="translated">このミドルウェアを考えると、先ほど書いたように</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="6236cf415b3887e7fa20a5499f765aa16f7720ff" translate="yes" xml:space="preserve">
          <source>Guaranteed immutability</source>
          <target state="translated">不変性を保証</target>
        </trans-unit>
        <trans-unit id="229bbdd56d74f7206cf36e6c06a296b111d18641" translate="yes" xml:space="preserve">
          <source>HN: Is there any huge web application built using Redux?</source>
          <target state="translated">HN:Reduxを使って構築された巨大なWebアプリケーションはありますか?</target>
        </trans-unit>
        <trans-unit id="74133e32e5bca2a26d927cd61a1825ca6cda78f2" translate="yes" xml:space="preserve">
          <source>Handcrafting an Isomorphic Redux Application (With Love)</source>
          <target state="translated">アイソモーフィックReduxアプリケーションを手作りする(愛を込めて</target>
        </trans-unit>
        <trans-unit id="cc392181cc37736073babefa3f6b0cbb53acb816" translate="yes" xml:space="preserve">
          <source>Handles unregistering of listeners via the function returned by &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;によって返される関数を介してリスナーの登録解除を処理します。</target>
        </trans-unit>
        <trans-unit id="c7d811048186a91e33bc9331b69a6d594a01ea8e" translate="yes" xml:space="preserve">
          <source>Handling Actions</source>
          <target state="translated">アクションの取り扱い</target>
        </trans-unit>
        <trans-unit id="3b7e8e8b24ce8d7679b9a35675bb0a5a7fc840b3" translate="yes" xml:space="preserve">
          <source>Handling More Actions</source>
          <target state="translated">より多くのアクションを処理する</target>
        </trans-unit>
        <trans-unit id="953d7b032c3bd0ac312412488e804519480a1aca" translate="yes" xml:space="preserve">
          <source>Handling Other Actions</source>
          <target state="translated">その他のアクションの取り扱い</target>
        </trans-unit>
        <trans-unit id="b97703fb2d2356eb6114659a0c343d14449211c9" translate="yes" xml:space="preserve">
          <source>Handling Redo</source>
          <target state="translated">処理のやり直し</target>
        </trans-unit>
        <trans-unit id="f326b5a21b8a49169e4839d3f63669543242d741" translate="yes" xml:space="preserve">
          <source>Handling Undo</source>
          <target state="translated">元に戻す操作</target>
        </trans-unit>
        <trans-unit id="988ce2e99df35e16eb481b727e182b8b8087a2b5" translate="yes" xml:space="preserve">
          <source>Handling the Request</source>
          <target state="translated">リクエストの処理</target>
        </trans-unit>
        <trans-unit id="2e05fe2ae332d92f70e77aaf42eb727d3dd91277" translate="yes" xml:space="preserve">
          <source>Here is an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;VisibleTodoList&lt;/code&gt; components, each of which has a &lt;code&gt;listId&lt;/code&gt; prop:</source>
          <target state="translated">ここで &lt;code&gt;App&lt;/code&gt; 3つのレンダリングコンポーネント &lt;code&gt;VisibleTodoList&lt;/code&gt; をそれぞれ有する成分、 &lt;code&gt;listId&lt;/code&gt; の小道具は：</target>
        </trans-unit>
        <trans-unit id="23ae030423c3a4339c6c0b04d05978042792f95c" translate="yes" xml:space="preserve">
          <source>Here is an example of such a HOC:</source>
          <target state="translated">そんなHOCの一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8446f01d6be3b14bffe6480fb53ea4f664e0a65d" translate="yes" xml:space="preserve">
          <source>Here is our code so far. It is rather verbose:</source>
          <target state="translated">これまでのコードは以下の通りです。かなり冗長です。</target>
        </trans-unit>
        <trans-unit id="01a60734010e587fd0830a7e888c7853a46bf0c7" translate="yes" xml:space="preserve">
          <source>Here's an example action which represents adding a new todo item:</source>
          <target state="translated">ここでは、新しい TODO アイテムを追加するアクションの例を示します。</target>
        </trans-unit>
        <trans-unit id="58052dece84922788386c735487e1b86cccdad36" translate="yes" xml:space="preserve">
          <source>Here's an example of how use of ES6 object literal shorthand with &lt;code&gt;combineReducers&lt;/code&gt; can define the state shape:</source>
          <target state="translated">ES6オブジェクトリテラルの短縮形と &lt;code&gt;combineReducers&lt;/code&gt; を使用して状態の形状を定義する方法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="2070c6c8e07ed8692f85545a5ee98fc311bf9af4" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; works. Let's say you have two reducers, one for a list of todos, and another for the currently selected filter setting:</source>
          <target state="translated">以下に、&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;仕組みを示します。たとえば、todoのリスト用と現在選択されているフィルター設定用の2つのレデューサーがあるとします。</target>
        </trans-unit>
        <trans-unit id="184bf60ef71f5a65467a6a7e96127cd713b7a9bf" translate="yes" xml:space="preserve">
          <source>Here's how to apply it to a Redux store:</source>
          <target state="translated">Reduxストアに適用する方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="c90015c747ff3bb6a4ca0fc41c0c7d1de4924c13" translate="yes" xml:space="preserve">
          <source>Here's what the state shape for our &amp;ldquo;Reddit headlines&amp;rdquo; app might look like:</source>
          <target state="translated">「Reddit headlines」アプリの状態の形状は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f3e2ce3154db89332ee8e9029cbb43d7deffada1" translate="yes" xml:space="preserve">
          <source>Here, we assume that you understand reducer composition with &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, as described in the &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt; section on the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;. If you don't, please &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;read it first&lt;/a&gt;.</source>
          <target state="translated">ここでは、&lt;a href=&quot;../basics/index&quot;&gt;基本ガイドの「&lt;/a&gt;レデューサーの&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;分割」&lt;/a&gt;セクションで説明されているように、&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;を使用してレデューサーの構成を理解していることを前提としています。そうでない場合は、&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;まずそれ&lt;/a&gt;を読んでください。</target>
        </trans-unit>
        <trans-unit id="47fb358d9a27b7f7c208a41f405f09df333fd295" translate="yes" xml:space="preserve">
          <source>High Performance Redux Apps</source>
          <target state="translated">高性能なReduxアプリ</target>
        </trans-unit>
        <trans-unit id="7a6176fc50b39dc51f67828e874d1a9c381927a9" translate="yes" xml:space="preserve">
          <source>High-Performance Redux</source>
          <target state="translated">高性能リデュークス</target>
        </trans-unit>
        <trans-unit id="e0aade7f036690bfbe818641db114550adf02045" translate="yes" xml:space="preserve">
          <source>Higher order reducers</source>
          <target state="translated">高次減速機</target>
        </trans-unit>
        <trans-unit id="661e90fbdb35e42cd0f11c03ad2413796fd99f73" translate="yes" xml:space="preserve">
          <source>Holds application state;</source>
          <target state="translated">アプリケーションの状態を保持します。</target>
        </trans-unit>
        <trans-unit id="70558178e9ca9037c4306a5560966893b2ba1623" translate="yes" xml:space="preserve">
          <source>How can I implement authentication in Redux?</source>
          <target state="translated">Reduxで認証を実装するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="cbbe1f27c0ff1e15f55cf992eaea12f8ad35811b" translate="yes" xml:space="preserve">
          <source>How can I reduce the number of store update events?</source>
          <target state="translated">店舗の更新イベントを減らすにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="fb6d20f2240e1c560f741e78debd31b4eea339de" translate="yes" xml:space="preserve">
          <source>How can I represent &amp;ldquo;side effects&amp;rdquo; such as AJAX calls? Why do we need things like &amp;ldquo;action creators&amp;rdquo;, &amp;ldquo;thunks&amp;rdquo;, and &amp;ldquo;middleware&amp;rdquo; to do async behavior?</source>
          <target state="translated">AJAX呼び出しなどの「副作用」をどのように表すことができますか？非同期動作を実行するために、「アクションクリエーター」、「サンク」、「ミドルウェア」などが必要なのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="8281d5ee1ef4deaaed00468f7711255feaa03216" translate="yes" xml:space="preserve">
          <source>How can I speed up my &lt;code&gt;mapStateToProps&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; をスピードアップするにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="341af2b298ee968641c89dc8fc39d6a76071ec0f" translate="yes" xml:space="preserve">
          <source>How can I speed up my mapStateToProps?</source>
          <target state="translated">mapStateToPropsを高速化するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="074c1f363f6a663f824f52ea0c32767c57407e9c" translate="yes" xml:space="preserve">
          <source>How can immutability in &lt;code&gt;mapStateToProps&lt;/code&gt; cause components to render unnecessarily?</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; の不変性により、コンポーネントが不必要にレンダリングされるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="b224cf4298710c4b3d505de8354cfc9ba8c010d0" translate="yes" xml:space="preserve">
          <source>How can immutability in mapStateToProps cause components to render unnecessarily?</source>
          <target state="translated">mapStateToPropsの不変性は、どのようにしてコンポーネントが不必要にレンダリングされてしまうのでしょうか?</target>
        </trans-unit>
        <trans-unit id="2afd69541aac46a2c40250df385736019b6c57fc" translate="yes" xml:space="preserve">
          <source>How can immutability in your reducers cause components to render unnecessarily?</source>
          <target state="translated">リデューサの不変性がコンポーネントの不必要なレンダリングを引き起こすことはありますか?</target>
        </trans-unit>
        <trans-unit id="03c2da4eb5dd93b3bf52e21145059bf09d5e25b4" translate="yes" xml:space="preserve">
          <source>How do I organize nested or duplicate data in my state?</source>
          <target state="translated">自分の状態で入れ子になっているデータや重複しているデータを整理するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="f37efe0864de2a013d86c02169f816af32cb5f56" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">2つのレデューサー間で状態を共有するにはどうすればよいですか？ &lt;code&gt;combineReducers&lt;/code&gt; を使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="2a2bb6943dc8bbb29ceaf8280fcfbee59990be7f" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use combineReducers?</source>
          <target state="translated">2つのレデューサ間で状態を共有するには?combineReducersを使用する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="39a19a487dfb8b0307ebc780f2d744e66346a60f" translate="yes" xml:space="preserve">
          <source>How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</source>
          <target state="translated">状態の一部だけをサブスクライブするには?サブスクリプションの一部としてディスパッチされたアクションを取得することはできますか?</target>
        </trans-unit>
        <trans-unit id="970d13e8ba247d72a23a1227b9eb76ab329d86fd" translate="yes" xml:space="preserve">
          <source>How do Shallow and Deep Equality Checking differ?</source>
          <target state="translated">シャローとディープの平等性チェックの違いは?</target>
        </trans-unit>
        <trans-unit id="28c2d5d8451c047bc1a0f4cecf88ad6567282a2d" translate="yes" xml:space="preserve">
          <source>How do shallow and deep equality checking differ?</source>
          <target state="translated">浅い平等と深い平等のチェックはどう違うのか?</target>
        </trans-unit>
        <trans-unit id="26ccec8f1ac279469a0f68091311d50666024b89" translate="yes" xml:space="preserve">
          <source>How do we actually delegate the control over the &lt;code&gt;present&lt;/code&gt; state to a custom reducer?</source>
          <target state="translated">&lt;code&gt;present&lt;/code&gt; 状態の制御をカスタムレデューサーに実際に委任するにはどうすればよいですか。</target>
        </trans-unit>
        <trans-unit id="fff3cc86a8e920d14e4b6d08ec84a36cf3ae1884" translate="yes" xml:space="preserve">
          <source>How do we approach this with Redux?</source>
          <target state="translated">Reduxではどのようにアプローチすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="30c14f55ced4d84011da65e3315eb866d4d9ce19" translate="yes" xml:space="preserve">
          <source>How do we include the Redux Thunk middleware in the dispatch mechanism? We use the &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; store enhancer from Redux, as shown below:</source>
          <target state="translated">ディスパッチメカニズムにRedux Thunkミドルウェアを含めるにはどうすればよいですか？以下に示すように、Redux の&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;ストアエンハンサーを使用します。</target>
        </trans-unit>
        <trans-unit id="8959099626f271882311c3c243bbfdda634b6be4" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;combineReducers&lt;/code&gt; use shallow equality checking?</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; はどのように浅い等価チェックを使用しますか？</target>
        </trans-unit>
        <trans-unit id="e264f190d3a7100ff16f8e0b792baf3242dd0158" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?</source>
          <target state="translated">React-Redux は、コンポーネントの再レンダリングが必要かどうかを判断するために、どのように浅い平等性チェックを使用しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="13f4f9bb8ec7adca1dffda3a094e04eb9bf81ce9" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking?</source>
          <target state="translated">React-Reduxはどのようにして浅い平等性チェックを使用しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b5cc6209f66bc3c55e7f41aa1d6494bbd46dc8e9" translate="yes" xml:space="preserve">
          <source>How does Redux use shallow equality checking?</source>
          <target state="translated">Reduxはどのようにして浅い平等性チェックを使うのですか?</target>
        </trans-unit>
        <trans-unit id="96952132f67badca2ba5bab5e41044f8fb225996" translate="yes" xml:space="preserve">
          <source>How does immutability enable a shallow check to detect object mutations?</source>
          <target state="translated">不変性はどのようにしてオブジェクトの突然変異を検出するための浅いチェックを可能にしているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="258f5cf42a9d12d463ef4f13ff6a4e2964d9748d" translate="yes" xml:space="preserve">
          <source>How putting too much logic in action creators could affect debugging</source>
          <target state="translated">アクション クリエイターにロジックを入れすぎるとデバッグにどのような影響があるか</target>
        </trans-unit>
        <trans-unit id="a4c23c5f78cdee9be5d0a8aa246f623d02051202" translate="yes" xml:space="preserve">
          <source>How should I split my logic between reducers and action creators? Where should my &amp;ldquo;business logic&amp;rdquo; go?</source>
          <target state="translated">ロジックをレデューサーとアクションクリエーターにどのように分割すればよいですか？「ビジネスロジック」はどこに行けばよいですか？</target>
        </trans-unit>
        <trans-unit id="844c750f088f6ec26d17f13bffa791aa0381caa4" translate="yes" xml:space="preserve">
          <source>How things look (markup, styles)</source>
          <target state="translated">どのように見えるか (マークアップ、スタイル)</target>
        </trans-unit>
        <trans-unit id="c4042ce0bd829dee86f5f8db37a02e8a871f8f88" translate="yes" xml:space="preserve">
          <source>How things work (data fetching, state updates)</source>
          <target state="translated">物事の仕組み(データの取得、状態の更新</target>
        </trans-unit>
        <trans-unit id="fa346393f4fb3e9654b9c58c84d9e7de2aec74bf" translate="yes" xml:space="preserve">
          <source>How to Scale React Applications</source>
          <target state="translated">Reactアプリケーションをスケールさせる方法</target>
        </trans-unit>
        <trans-unit id="47937596549577004fa72bfb56667e643c361800" translate="yes" xml:space="preserve">
          <source>How to handle state in React: the missing FAQ</source>
          <target state="translated">Reactでステートを扱う方法:不足しているFAQ</target>
        </trans-unit>
        <trans-unit id="49dee5bfff40b97a93bb5e0172be4f4d25ffb4f5" translate="yes" xml:space="preserve">
          <source>How to think in terms of combining functions</source>
          <target state="translated">機能の組み合わせで考える方法</target>
        </trans-unit>
        <trans-unit id="5a44fd27737b51871064dcba886fdf85182ed8ca" translate="yes" xml:space="preserve">
          <source>How well does Redux &amp;ldquo;scale&amp;rdquo; in terms of performance and architecture?</source>
          <target state="translated">Reduxはパフォーマンスとアーキテクチャの点でどの程度「スケーリング」されていますか？</target>
        </trans-unit>
        <trans-unit id="d5049bfb2117becfff285cdc67dde0f10a6d2171" translate="yes" xml:space="preserve">
          <source>How you structure the root reducer is completely up to you. Redux ships with a &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; helper function, useful for &amp;ldquo;splitting&amp;rdquo; the root reducer into separate functions that each manage one branch of the state tree.</source>
          <target state="translated">ルートリデューサーをどのように構成するかは、完全にあなた次第です。Reduxには、ルートリデューサーを状態ツリーの1つのブランチをそれぞれ管理する個別の関数に「分割」するのに役立つ、&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;ヘルパー関数が付属しています。</target>
        </trans-unit>
        <trans-unit id="1d072600a3b53bb4cfed12bc142b48432221674c" translate="yes" xml:space="preserve">
          <source>However, creating new stores shouldn't be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn't solve your problem.</source>
          <target state="translated">しかし、新しいストアを作ることが最初の直感であるべきではありません。最初にレデューサーの構成を試してみて、問題が解決しない場合は複数のストアを使うようにしてください。</target>
        </trans-unit>
        <trans-unit id="27352aa59f7116a388d254a03cb3ffe5f2f70e56" translate="yes" xml:space="preserve">
          <source>However, even if you happen to have many different reducer functions composed together, and even with deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your reducers are probably just using a &lt;code&gt;switch&lt;/code&gt; statement and returning the existing state by default in response to most actions.</source>
          <target state="translated">ただし、多くの異なるレデューサー関数が一緒に構成されていても、ネスト状態が深くても、レデューサーの速度が問題になることはほとんどありません。JavaScriptエンジンは1秒間に非常に多数の関数呼び出しを実行でき、ほとんどのレデューサーはおそらく &lt;code&gt;switch&lt;/code&gt; ステートメントを使用しており、ほとんどのアクションに応じてデフォルトで既存の状態を返します。</target>
        </trans-unit>
        <trans-unit id="209c7d1b896b9b48924c44438236581d9ba02ccc" translate="yes" xml:space="preserve">
          <source>However, guaranteeing immutability with JavaScript is difficult, and it can be easy to mutate an object accidentally, causing bugs in your app that are extremely difficult to locate. For this reason, using an immutable update utility library such as Immutable.JS can significantly improve the reliability of your app, and make your app&amp;rsquo;s development much easier.</source>
          <target state="translated">ただし、JavaScriptで不変性を保証することは困難であり、オブジェクトを誤って変更することが簡単に起こり、アプリ内でバグを特定することが非常に困難になる可能性があります。このため、Immutable.JSなどの不変の更新ユーティリティライブラリを使用すると、アプリの信頼性が大幅に向上し、アプリの開発がはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="007edd469aeadd3134e72ff280534f419b360c63" translate="yes" xml:space="preserve">
          <source>However, if you wrap &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;, the middleware can interpret actions differently, and provide support for dispatching &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt;. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</source>
          <target state="translated">ただし、&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;でラップすると、ミドルウェアはアクションを異なる方法で解釈し、&lt;a href=&quot;../glossary#async-action&quot;&gt;非同期アクションの&lt;/a&gt;ディスパッチをサポートできます。非同期アクションは通常、Promise、Observable、Thunkなどの非同期プリミティブです。</target>
        </trans-unit>
        <trans-unit id="ef6ac0b7fe7b68443642555f387d0a08b371f125" translate="yes" xml:space="preserve">
          <source>However, in our Redux App we will still need &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; is the higher-order component provided by React Redux that lets you bind Redux to React (see &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;).</source>
          <target state="translated">ただし、Reduxアプリでは引き続き &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; が必要です。 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; は、React Reduxによって提供される高次コンポーネントであり、これを使用してReduxをReactにバインドできます（&lt;a href=&quot;../basics/usagewithreact&quot;&gt;Reactでの使用法を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0bf708fc8c3314c936b8e0786f74c3d98798623d" translate="yes" xml:space="preserve">
          <source>However, it is important that we keep logging and crash reporting separate. Ideally we want them to be different modules, potentially in different packages. Otherwise we can't have an ecosystem of such utilities. (Hint: we're slowly getting to what middleware is!)</source>
          <target state="translated">しかし、ロギングとクラッシュレポートは別々にしておくことが重要です。理想的には、これらを別のモジュールにして、潜在的には別のパッケージにしたいと考えています。そうでなければ、そのようなユーティリティのエコシステムを持つことはできません。(ヒント:ミドルウェアとは何かを徐々に理解してきています!)</target>
        </trans-unit>
        <trans-unit id="9d31965c3ec47c4faba43c57bec50a234ddcbc5a" translate="yes" xml:space="preserve">
          <source>However, it is still monkeypatching.</source>
          <target state="translated">とはいえ、やはりモンキーパッチです。</target>
        </trans-unit>
        <trans-unit id="b97da1c31078988cc6aa942ce9cf7c26c29a6edc" translate="yes" xml:space="preserve">
          <source>However, it's also important to understand that using Redux comes with tradeoffs. It's not designed to be the shortest or fastest way to write code. It's intended to help answer the question &quot;When did a certain slice of state change, and where did the data come from?&quot;, with predictable behavior. It does so by asking you to follow specific constraints in your application: store your application's state as plain data, describe changes as plain objects, and handle those changes with pure functions that apply updates immutably. This is often the source of complaints about &quot;boilerplate&quot;. These constraints require effort on the part of a developer, but also open up a number of additional possibilities (such as store persistence and synchronization).</source>
          <target state="translated">しかし、Reduxを使うことにはトレードオフがあることを理解しておくことも重要です。Reduxはコードを書くための最短・最速の方法として設計されているわけではありません。あるスライスの状態がいつ変化したのか、そのデータはどこから来たのか」という質問に、予測可能な動作で答えられるようにすることを目的としています。アプリケーションの状態をプレーンなデータとして保存し、変更をプレーンなオブジェクトとして記述し、更新を不変に適用する純粋な関数でそれらの変更を処理します。これは、しばしば &quot;定型文 &quot;に対する不満の原因となります。これらの制約は、開発者側の努力を必要としますが、多くの追加の可能性(ストアの永続性や同期など)を開きます。</target>
        </trans-unit>
        <trans-unit id="83c39c3a93928d93c157bb221e087802a4b99e7d" translate="yes" xml:space="preserve">
          <source>However, remember that the key is that the &lt;em&gt;original in-memory reference&lt;/em&gt; is not modified. &lt;strong&gt;As long as we make a copy first, we can safely mutate the copy&lt;/strong&gt;. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.</source>
          <target state="translated">ただし、重要なのは、&lt;em&gt;元のメモリ内参照&lt;/em&gt;が変更されないことです。&lt;strong&gt;最初にコピーを作成する限り、コピーを安全に変更できます&lt;/strong&gt;。これは配列とオブジェクトの両方に当てはまりますが、ネストされた値は同じルールを使用して更新する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b9b3dc33e56385563b9249f48fd1c5fc362f06f4" translate="yes" xml:space="preserve">
          <source>However, shallow checking will not work if your data encapsulated within an Immutable.JS object is itself an object. This is because Immutable.JS&amp;rsquo;s &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data contained within an Immutable.JS object as a JavaScript value, will create a new object every time it&amp;rsquo;s called, and so break the reference with the encapsulated data.</source>
          <target state="translated">ただし、Immutable.JSオブジェクト内にカプセル化されたデータ自体がオブジェクトである場合、浅いチェックは機能しません。これは、Immutable.JSオブジェクトに含まれるデータをJavaScript値として返すImmutable.JSの &lt;code&gt;toJS()&lt;/code&gt; メソッドが呼び出されるたびに新しいオブジェクトを作成し、カプセル化されたデータで参照を破壊するためです。</target>
        </trans-unit>
        <trans-unit id="b519a9362c1955561b3e4941334f49ea0df524a1" translate="yes" xml:space="preserve">
          <source>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</source>
          <target state="translated">しかし、異なるコンポーネントが同じ API エンドポイントからデータを要求するため、これはすぐに繰り返しになってしまいます。さらに、このロジックの一部(例えば、キャッシュされたデータが利用可能な場合の早期終了など)を多くのコンポーネントから再利用したいと考えています。</target>
        </trans-unit>
        <trans-unit id="eb8c9304fae62928333a51a2b537a686e6b3a79a" translate="yes" xml:space="preserve">
          <source>However, we don't have to call &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; if we're interested in hiding the fact that the sub-app component is a Redux app.</source>
          <target state="translated">ただし、 &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; コンポーネントがReduxアプリであるという事実を隠したい場合は、ReactDOM.render（&amp;lt;Provider&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/ Provider&amp;gt;）を呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="30c62654e7682bc0051c67f69252368a8aa8daf0" translate="yes" xml:space="preserve">
          <source>However, when you import it, you're actually holding the wrapper component returned by &lt;code&gt;connect()&lt;/code&gt;, and not the &lt;code&gt;App&lt;/code&gt; component itself. If you want to test its interaction with Redux, this is good news: you can wrap it in a &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; with a store created specifically for this unit test. But sometimes you want to test just the rendering of the component, without a Redux store.</source>
          <target state="translated">ただし、インポートすると、実際には、 &lt;code&gt;connect()&lt;/code&gt; によって返されたラッパーコンポーネントが保持され、 &lt;code&gt;App&lt;/code&gt; コンポーネント自体は保持されません。Reduxとの相互作用をテストする場合、これは朗報です。この単体テスト用に特別に作成されたストアを使用して、&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; &lt;/a&gt;でラップすることができます。ただし、Reduxストアを使用せずに、コンポーネントのレンダリングだけをテストしたい場合もあります。</target>
        </trans-unit>
        <trans-unit id="b34092e543dd93b03e651093a3d7a3b5a60f9550" translate="yes" xml:space="preserve">
          <source>However, you &lt;em&gt;do&lt;/em&gt; need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.</source>
          <target state="translated">しかし、あなたは&lt;em&gt;ない&lt;/em&gt;影響を受けている、ネストのレベルごとにコピーされ、更新されたオブジェクトを作成する必要があります。これはそれほど高価ではありませんが、可能であれば状態を正規化し、浅く保つ必要があるもう1つの理由です。</target>
        </trans-unit>
        <trans-unit id="637b51ba07484e27e5e6b55d068f2f69a042cefb" translate="yes" xml:space="preserve">
          <source>I see the following presentational components and their props emerge from this brief:</source>
          <target state="translated">私は、この短信から次のようなプレゼンテーションの構成要素とその小道具が浮かび上がってくるのを見ています。</target>
        </trans-unit>
        <trans-unit id="cc27465fc6ceedd55291ea4f132c806be70591bb" translate="yes" xml:space="preserve">
          <source>I would like to amend this: don't use Redux until you have problems with vanilla React.</source>
          <target state="translated">私はこれを修正したいと思います:バニラReactで問題が発生するまでReduxを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ad18fcf9dd2ee8a9f5ea170593bb2c6bee68d60d" translate="yes" xml:space="preserve">
          <source>I wrote Redux while working on my React Europe talk called &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&amp;ldquo;Hot Reloading with Time Travel&amp;rdquo;&lt;/a&gt;. My goal was to create a state management library with minimal API but completely predictable behavior, so it is possible to implement logging, hot reloading, time travel, universal apps, record and replay, without any buy-in from the developer.</source>
          <target state="translated">私は、React Europeでの&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;「タイムトラベルによるホットリロード」&lt;/a&gt;という講演に取り組んでいる間にReduxを書きました。私の目標は、最小限のAPIで完全に予測可能な動作を備えた状態管理ライブラリを作成することでした。そのため、開発者の関与なしに、ロギング、ホットリロード、タイムトラベル、ユニバーサルアプリ、記録と再生を実装できます。</target>
        </trans-unit>
        <trans-unit id="618b7ca25386b5f5436f346c2ed5051a72f4a73a" translate="yes" xml:space="preserve">
          <source>Idiomatic Redux: Normalizing the State Shape</source>
          <target state="translated">イディオマティック・リドゥ:状態の形状を正規化する</target>
        </trans-unit>
        <trans-unit id="fe91fe24d5f9dd8e770fad3a725bc0cec34aab62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; doesn't assign &lt;code&gt;store.dispatch&lt;/code&gt; immediately after processing the first middleware, &lt;code&gt;store.dispatch&lt;/code&gt; will keep pointing to the original &lt;code&gt;dispatch&lt;/code&gt; function. Then the second middleware will also be bound to the original &lt;code&gt;dispatch&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; が最初のミドルウェアの処理直後に &lt;code&gt;store.dispatch&lt;/code&gt; を割り当てない場合、 &lt;code&gt;store.dispatch&lt;/code&gt; は元の &lt;code&gt;dispatch&lt;/code&gt; 関数を指し続けます。次に、2番目のミドルウェアも元の &lt;code&gt;dispatch&lt;/code&gt; 関数にバインドされます。</target>
        </trans-unit>
        <trans-unit id="35f456ed22b65b432754496a635957ff1170346a" translate="yes" xml:space="preserve">
          <source>If a Redux reducer directly mutates, and returns, the state object passed into it, the values of the root state object will change, but the object itself will not.</source>
          <target state="translated">Redux reducer が直接変異して、それに渡された状態オブジェクトを返す場合、ルートの状態オブジェクトの値は変わりますが、オブジェクト自体は変わりません。</target>
        </trans-unit>
        <trans-unit id="2a08f5491a0b259f6b66f794074ee1e3a74e48f7" translate="yes" xml:space="preserve">
          <source>If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.</source>
          <target state="translated">レデューサが別のスライスからのデータを知る必要がある場合、単一のレデューサがより多くのデータを扱うように、状態ツリーの形状を再編成する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9faa62e0446c64c2b5f25f17a54da0f020cabc00" translate="yes" xml:space="preserve">
          <source>If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; instead of an action.</source>
          <target state="translated">アクション作成者が現在の状態を読み取る、API呼び出しを実行する、またはルーティング遷移などの副作用を引き起こす必要がある場合、アクションの代わりに&lt;a href=&quot;#async-action&quot;&gt;非同期アクション&lt;/a&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="e288fd9913bf6a8a74842392c22a2dd0b95c7906" translate="yes" xml:space="preserve">
          <source>If an object is immutable, any changes that need to be made to it within a function must be made to a &lt;em&gt;copy&lt;/em&gt; of the object.</source>
          <target state="translated">オブジェクトが不変の場合、関数内でオブジェクトに加える必要のある変更は、オブジェクトの&lt;em&gt;コピー&lt;/em&gt;に対して行う必要があります。</target>
        </trans-unit>
        <trans-unit id="8e3b9f89d6838d129b565fe3186a16b253684268" translate="yes" xml:space="preserve">
          <source>If it does, the shallow equality check that &lt;code&gt;combineReducers&lt;/code&gt; performs will always pass, as the values of the state slice returned by the reducer may have been mutated, but the object itself has not - it&amp;rsquo;s still the same object that was passed to the reducer.</source>
          <target state="translated">その場合、 &lt;code&gt;combineReducers&lt;/code&gt; によって返された状態スライスの値は変更されている可能性がありますが、オブジェクト自体は変更されていないため、combinReducersが実行する浅い等価性チェックは常に成功します。</target>
        </trans-unit>
        <trans-unit id="ecb66a4049905816e9b1a9b102420a18f13b1512" translate="yes" xml:space="preserve">
          <source>If logging and crash reporting are separate utilities, they might look like this:</source>
          <target state="translated">ロギングとクラッシュレポートが別のユーティリティである場合、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6d10f3d1de6596be190d60a9a58973fddf0a134c" translate="yes" xml:space="preserve">
          <source>If no changes are needed, it should return the existing state as-is.</source>
          <target state="translated">変更が必要ない場合は、既存の状態をそのまま返します。</target>
        </trans-unit>
        <trans-unit id="bf9ad27c90229a42dd677eb94e9afe7a27ff90c9" translate="yes" xml:space="preserve">
          <source>If one of the values of the props object returned from &lt;code&gt;mapStateToProps&lt;/code&gt; is an object that persists across calls to &lt;code&gt;connect&lt;/code&gt; (such as, potentially, the root state object), yet is directly mutated and returned by a selector function, React-Redux will not be able to detect the mutation, and so will not trigger a re-render of the wrapped component.</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; から返されたpropsオブジェクトの値の1つが、 &lt;code&gt;connect&lt;/code&gt; 呼び出しをまたいで永続化するオブジェクト（ルート状態オブジェクトなど）であるにもかかわらず、直接変更されてセレクター関数によって返された場合、React-Reduxは変異を検出できるため、ラップされたコンポーネントの再レンダリングはトリガーされません。</target>
        </trans-unit>
        <trans-unit id="d5d728b3f7c8756b0e1d6727b86ff4b7f986fb4b" translate="yes" xml:space="preserve">
          <source>If such an operation is used as a selector function in &lt;code&gt;mapStateToProps&lt;/code&gt;, the shallow equality check that React-Redux performs on each value in the props object that&amp;rsquo;s returned will always fail, as the selector is returning a new object each time.</source>
          <target state="translated">そのような操作が &lt;code&gt;mapStateToProps&lt;/code&gt; のセレクター関数として使用される場合、セレクターが毎回新しいオブジェクトを返すため、返されるpropsオブジェクトの各値に対してReact-Reduxが実行する浅い等価性チェックは常に失敗します。</target>
        </trans-unit>
        <trans-unit id="c5ceb90dff402277125291134484216343d65527" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;state&lt;/code&gt; given to it is &lt;code&gt;undefined&lt;/code&gt;, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be &lt;code&gt;undefined&lt;/code&gt; either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">与えられた &lt;code&gt;state&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; の場合、この特定のレデューサーの初期状態を返す必要があります。前のルールによれば、初期状態も &lt;code&gt;undefined&lt;/code&gt; はなりません。ES6のオプションの引数構文で指定すると便利ですが、最初の引数が &lt;code&gt;undefined&lt;/code&gt; であるかどうかを明示的に確認することもできます。</target>
        </trans-unit>
        <trans-unit id="54a886e11c2cb542f0ecf3d252296e52fe4603bb" translate="yes" xml:space="preserve">
          <source>If the check fails, however, the root state object &lt;em&gt;has&lt;/em&gt; been updated, and so &lt;code&gt;connect&lt;/code&gt; will call &lt;code&gt;mapStateToProps&lt;/code&gt;to see if the props for the wrapped component have been updated.</source>
          <target state="translated">ただし、チェックが失敗した場合は、ルート状態オブジェクト&lt;em&gt;が&lt;/em&gt;更新され&lt;em&gt;て&lt;/em&gt;いるため、 &lt;code&gt;connect&lt;/code&gt; は &lt;code&gt;mapStateToProps&lt;/code&gt; を呼び出して、ラップされたコンポーネントの小道具が更新されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="7ddbf9b8aa21e91694b18c1515d700c56e251753" translate="yes" xml:space="preserve">
          <source>If the shallow equality check fails between the new values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; and the previous values that React-Redux kept a reference to, then a re-rendering of the component will be triggered.</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; から返された新しい値と、React-Reduxが参照を保持していた以前の値との間の浅い等価チェックが失敗すると、コンポーネントの再レンダリングがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="dc5775e4e8ec131359e210f027aac76d6574f7fe" translate="yes" xml:space="preserve">
          <source>If these functions are published as separate modules, we can later use them to patch our store:</source>
          <target state="translated">これらの関数が別のモジュールとして公開されている場合、後でストアのパッチを当てるためにそれらを使用することができます。</target>
        </trans-unit>
        <trans-unit id="88d3eb0d142a4003073ed1cec6a2f5fd9c278548" translate="yes" xml:space="preserve">
          <source>If two different variables reference the same immutable object, then a simple equality check of the two variables is enough to determine that they are equal, and that the object they both reference is unchanged. The equality check never has to check the values of any of the object&amp;rsquo;s properties, as it is, of course, immutable.</source>
          <target state="translated">2つの異なる変数が同じ不変オブジェクトを参照する場合、2つの変数の単純な等価チェックで、それらが等しいこと、および両方が参照するオブジェクトが変更されていないことを確認できます。等価性チェックは、もちろん不変なので、オブジェクトのプロパティの値をチェックする必要はありません。</target>
        </trans-unit>
        <trans-unit id="e8ff3107eee34b9cab68e06d253a65fa91028026" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;createStore&lt;/code&gt; without the &lt;code&gt;preloadedState&lt;/code&gt;, it's going to initialize the &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;{}&lt;/code&gt;. Therefore, &lt;code&gt;state.a&lt;/code&gt; and &lt;code&gt;state.b&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; by the time it calls &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers. &lt;strong&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers will receive &lt;code&gt;undefined&lt;/code&gt; as &lt;em&gt;their&lt;/em&gt; &lt;code&gt;state&lt;/code&gt; arguments, and if they specify default &lt;code&gt;state&lt;/code&gt; values, those will be returned.&lt;/strong&gt; This is how the combined reducer returns a &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; state object on the first invocation.</source>
          <target state="translated">我々は呼び出す場合 &lt;code&gt;createStore&lt;/code&gt; せずに &lt;code&gt;preloadedState&lt;/code&gt; 、初期化するために起こっている &lt;code&gt;state&lt;/code&gt; に &lt;code&gt;{}&lt;/code&gt; 。したがって、 &lt;code&gt;state.a&lt;/code&gt; と &lt;code&gt;state.b&lt;/code&gt; がされ &lt;code&gt;undefined&lt;/code&gt; の時間でそれが呼び出すと &lt;code&gt;b&lt;/code&gt; 減速を。&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;と&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;b&lt;/code&gt; の&lt;/strong&gt;&lt;strong&gt;両方&lt;/strong&gt;&lt;strong&gt;の&lt;/strong&gt;&lt;strong&gt;リデューサーは&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;、&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;引数&lt;/strong&gt;&lt;strong&gt;として&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;を受け取り&lt;/strong&gt;&lt;strong&gt;、デフォルトの&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;値&lt;/strong&gt;&lt;strong&gt;を指定して&lt;/strong&gt;&lt;strong&gt;いる&lt;/strong&gt;&lt;strong&gt;場合は、それらが返されます。&lt;/strong&gt;これは、組み合わされたレデューサーが &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; 返す方法です &lt;code&gt;a&lt;/code&gt; &lt;strong&gt;&lt;em&gt;&lt;/em&gt; &lt;/strong&gt; 最初の呼び出し時の状態オブジェクト。</target>
        </trans-unit>
        <trans-unit id="8df247b3c417208103f01c75fc35280be43fc622" translate="yes" xml:space="preserve">
          <source>If we have a nested tree of slice reducers, each slice reducer will need to know how to respond to this action appropriately. We will need to include all the relevant data in the action. We need to update the correct Post object with the comment's ID, create a new Comment object using that ID as a key, and include the Comment's ID in the list of all Comment IDs. Here's how the pieces for this might fit together:</source>
          <target state="translated">スライスレデューサの入れ子になったツリーがある場合、各スライスレデューサは、このアクションに適切に対応する方法を知る必要があります。すべての関連データをアクションに含める必要があります。コメントのIDで正しいPostオブジェクトを更新し、そのIDをキーとして使用して新しいCommentオブジェクトを作成し、すべてのComment IDのリストにCommentのIDを含める必要があります。ここでは、これらの要素をどのように組み合わせるかを説明します。</target>
        </trans-unit>
        <trans-unit id="fb9835b5068457c01cd0ee22c6f2d1f319535710" translate="yes" xml:space="preserve">
          <source>If we pass &lt;code&gt;makeMapStateToProps&lt;/code&gt; to &lt;code&gt;connect&lt;/code&gt;, each instance of the &lt;code&gt;VisibleTodosList&lt;/code&gt; container will get its own &lt;code&gt;mapStateToProps&lt;/code&gt; function with a private &lt;code&gt;getVisibleTodos&lt;/code&gt; selector. Memoization will now work correctly regardless of the render order of the &lt;code&gt;VisibleTodoList&lt;/code&gt; containers.</source>
          <target state="translated">私たちが合格した場合 &lt;code&gt;makeMapStateToProps&lt;/code&gt; をするために &lt;code&gt;connect&lt;/code&gt; 、それぞれのインスタンス &lt;code&gt;VisibleTodosList&lt;/code&gt; のコンテナは、独自のでしょう &lt;code&gt;mapStateToProps&lt;/code&gt; はプライベートで機能 &lt;code&gt;getVisibleTodos&lt;/code&gt; のセレクタ。メモ化は、 &lt;code&gt;VisibleTodoList&lt;/code&gt; コンテナのレンダリング順序に関係なく正しく機能するようになりました。</target>
        </trans-unit>
        <trans-unit id="e5f7ebaf8e95ed592e947bea2433fe217182ccf7" translate="yes" xml:space="preserve">
          <source>If we wanted to implement Undo and Redo in such an app, we'd need to store more state so we can answer the following questions:</source>
          <target state="translated">このようなアプリでUndoとRedoを実装したい場合、以下の質問に答えられるように、より多くの状態を保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e391178bee157d67e539832bad15008f2621985" translate="yes" xml:space="preserve">
          <source>If you actually are concerned about reducer performance, you can use a utility such as &lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; or &lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt; to ensure that only certain reducers listen to specific actions. You can also use &lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt; to do some performance benchmarking.</source>
          <target state="translated">実際にレデューサーのパフォーマンスが気になる場合は、&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt;や&lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt;などのユーティリティを使用して、特定のレデューサーだけが特定のアクションをリッスンするようにできます。&lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt;を使用して、パフォーマンスベンチマークを行うこともできます。</target>
        </trans-unit>
        <trans-unit id="199562b5deb45f1013629dc76cd0a79e09f79a5f" translate="yes" xml:space="preserve">
          <source>If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it's &lt;em&gt;your&lt;/em&gt; application, and how you implement it is up to you. As with many other things about Redux, just be sure you understand what tradeoffs are involved.</source>
          <target state="translated">持続性や時間旅行のデバッグなどが意図したとおりに機能しない可能性がある場合は、シリアライズできないアイテムをReduxストアに入れてもかまいません。最終的に、それは&lt;em&gt;あなたの&lt;/em&gt;アプリケーションであり、あなたがそれをどのように実装するかはあなた次第です。Reduxに関する他の多くのことと同様に、どのようなトレードオフが関係しているかを必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="932e447c8721986d2617272ec0cb57f8fa838b1b" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from Express:</source>
          <target state="translated">Expressから &lt;code&gt;index.html&lt;/code&gt; を提供している場合：</target>
        </trans-unit>
        <trans-unit id="f7e044138df780189a8da20f4e5abaa151739142" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from WebpackDevServer: You can add to your webpack.config.dev.js:</source>
          <target state="translated">WebpackDevServerから &lt;code&gt;index.html&lt;/code&gt; を提供している場合：webpack.config.dev.jsに追加できます：</target>
        </trans-unit>
        <trans-unit id="4c971a979a1e736d56294d1498dc9977ed0a0326" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you can call selectors as regular functions inside &lt;code&gt;mapStateToProps()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;を使用している場合は、 &lt;code&gt;mapStateToProps()&lt;/code&gt; 内の通常の関数としてセレクターを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b429d41b92c2a713e5a488236e816823364d7151" translate="yes" xml:space="preserve">
          <source>If you are using Create React App, you won't need to configure a fallback URL, it is automatically done.</source>
          <target state="translated">Create React Appを使用している場合は、フォールバックURLを設定する必要はなく、自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="a2bbb0e9ddb72ba973272562f236d089b4f6c651" translate="yes" xml:space="preserve">
          <source>If you are using ES6 in your application source, but write your tests in ES5, you should know that Babel handles the interchangeable use of ES6 &lt;code&gt;import&lt;/code&gt; and CommonJS &lt;code&gt;require&lt;/code&gt; through its &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;interop&lt;/a&gt; capability to run two module formats side-by-side, but the behavior is &lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;slightly different&lt;/a&gt;. If you add a second export beside your default export, you can no longer import the default using &lt;code&gt;require('./App')&lt;/code&gt;. Instead you have to use &lt;code&gt;require('./App').default&lt;/code&gt;.</source>
          <target state="translated">アプリケーションソースでES6を使用しているが、ES5でテストを作成する場合、BabelがES6 &lt;code&gt;import&lt;/code&gt; 交換可能な使用を処理し、CommonJS &lt;code&gt;require&lt;/code&gt; &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;相互運用&lt;/a&gt;機能を介して2つのモジュール形式を並べて実行する必要があることを知っている必要がありますが、動作で&lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;わずかに異なります&lt;/a&gt;。デフォルトのエクスポートの横に2番目のエクスポートを追加すると、 &lt;code&gt;require('./App')&lt;/code&gt; を使用してデフォルトをインポートできなくなります。代わりに &lt;code&gt;require('./App').default&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="036337c885ec3cef3b7191a050a9577f4c076991" translate="yes" xml:space="preserve">
          <source>If you attempt to call &lt;code&gt;dispatch&lt;/code&gt; from inside the &lt;a href=&quot;../glossary#reducer&quot;&gt;reducer&lt;/a&gt;, it will throw with an error saying &amp;ldquo;Reducers may not dispatch actions.&amp;rdquo; This is similar to &amp;ldquo;Cannot dispatch in a middle of dispatch&amp;rdquo; error in Flux, but doesn't cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</source>
          <target state="translated">&lt;a href=&quot;../glossary#reducer&quot;&gt;reducerの&lt;/a&gt;内部から &lt;code&gt;dispatch&lt;/code&gt; を呼び出そうとすると、「reducersはアクションをディスパッチできない可能性があります」というエラーでスローされます。これはFluxの「ディスパッチの途中でディスパッチできない」エラーに似ていますが、それに関連する問題は発生しません。Fluxでは、ストアがアクションを処理して更新を発行している間、ディスパッチは禁止されています。コンポーネントのライフサイクルフックまたは他の無害な場所からアクションをディスパッチすることが不可能になるため、これは残念です。</target>
        </trans-unit>
        <trans-unit id="a8a26433b9beefd0c99622c27b6f8d2d577a33f8" translate="yes" xml:space="preserve">
          <source>If you define an action creator, calling it will &lt;em&gt;not&lt;/em&gt; automatically dispatch the action. For example, this code will do nothing:</source>
          <target state="translated">アクション作成者を定義している場合、それを呼び出して&lt;em&gt;も&lt;/em&gt;自動的にアクションがディスパッチされ&lt;em&gt;ません&lt;/em&gt;。たとえば、次のコードは何もしません。</target>
        </trans-unit>
        <trans-unit id="30875373163ba2a0b61d1b93ce3b8577d3f0b61f" translate="yes" xml:space="preserve">
          <source>If you do not provide your own &lt;code&gt;mapDispatchToProps&lt;/code&gt; function when calling &lt;code&gt;connect()&lt;/code&gt;, React Redux will provide a default version, which simply returns the &lt;code&gt;dispatch&lt;/code&gt; function as a prop. That means that if you &lt;em&gt;do&lt;/em&gt; provide your own function, &lt;code&gt;dispatch&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your &lt;code&gt;mapDispatchToProps&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; の呼び出し時に独自の &lt;code&gt;mapDispatchToProps&lt;/code&gt; 関数を提供しない場合、React Reduxはデフォルトのバージョンを提供し、 &lt;code&gt;dispatch&lt;/code&gt; 関数を小道具として返すだけです。あなたがあればことを意味することに&lt;em&gt;行う&lt;/em&gt;独自の機能を提供し、 &lt;code&gt;dispatch&lt;/code&gt; され&lt;em&gt;ません&lt;/em&gt;自動的に提供。それでもプロップとして利用できるようにしたい場合は、 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 実装で自分で明示的に返す必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9737b1fd992921039384e8e5be9f5b18af16860f" translate="yes" xml:space="preserve">
          <source>If you don't use a module bundler, it's also fine. The &lt;code&gt;redux&lt;/code&gt; npm package includes precompiled production and development &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; builds in the &lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt;&lt;code&gt;dist&lt;/code&gt; folder&lt;/a&gt;. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a &lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag&lt;/a&gt; on the page, or &lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;tell Bower to install it&lt;/a&gt;. The UMD builds make Redux available as a &lt;code&gt;window.Redux&lt;/code&gt; global variable.</source>
          <target state="translated">モジュールバンドラーを使用しない場合も問題ありません。 &lt;code&gt;redux&lt;/code&gt; NPMパッケージは、プリコンパイルされた生産と開発が含ま&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMDが&lt;/a&gt;でビルドを&lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt; &lt;code&gt;dist&lt;/code&gt; のフォルダ&lt;/a&gt;。これらは、バンドラーなしで直接使用できるため、多くの一般的なJavaScriptモジュールローダーおよび環境と互換性があります。たとえば、UMDビルドを&lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグ&lt;/a&gt;としてページにドロップしたり&lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;、Bowerにインストールするように指示し&lt;/a&gt;たりできます。 UMDビルドは、Reduxを &lt;code&gt;window.Redux&lt;/code&gt; グローバル変数として利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="4cd567ddaa1825598645d89fa68d6db13748ff49" translate="yes" xml:space="preserve">
          <source>If you don't use npm, you may grab the latest UMD build from unpkg (either a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;development&lt;/a&gt; or a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;production&lt;/a&gt; build). The UMD build exports a global called &lt;code&gt;window.ReactRedux&lt;/code&gt; if you add it to your page via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">npmを使用しない場合は、unpkgから最新のUMDビルド（&lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;開発&lt;/a&gt;ビルドまたは&lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;本番&lt;/a&gt;ビルド）を取得できます。UMDビルドは、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを使用してページに追加すると、 &lt;code&gt;window.ReactRedux&lt;/code&gt; というグローバルをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="8cc59110c4fe5748abe56530a6ab2f4825ec53fe" translate="yes" xml:space="preserve">
          <source>If you enjoyed my course, consider supporting Egghead by &lt;a href=&quot;https://egghead.io/pricing&quot;&gt;buying a subscription&lt;/a&gt;. Subscribers have access to the source code for the example in every one of my videos, as well as to tons of advanced lessons on other topics, including JavaScript in depth, React, Angular, and more. Many &lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead instructors&lt;/a&gt; are also open source library authors, so buying a subscription is a nice way to thank them for the work that they've done.</source>
          <target state="translated">私のコースを楽しんだら&lt;a href=&quot;https://egghead.io/pricing&quot;&gt;、サブスクリプションを購入して&lt;/a&gt; Eggheadをサポートすることを検討してください。購読者は、私のビデオすべての例のソースコードにアクセスできるだけでなく、JavaScriptの詳細、React、Angularなど、他のトピックに関する多くの高度なレッスンにもアクセスできます。多くの&lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Eggheadインストラクター&lt;/a&gt;もオープンソースライブラリの作者であるため、サブスクリプションを購入することは、彼らが行った仕事に感謝する良い方法です。</target>
        </trans-unit>
        <trans-unit id="75a385f2b719ab2caac4808cd62fba207c8acd6d" translate="yes" xml:space="preserve">
          <source>If you figure it out, &lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;edit this document&lt;/a&gt; as a courtesy to the next person having the same problem.</source>
          <target state="translated">あなたがそれを理解するならば、同じ問題を持っている次の人への礼儀として&lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;この文書&lt;/a&gt;を編集してください。</target>
        </trans-unit>
        <trans-unit id="35c54f24f34f6294fae047991edc9eee543297c8" translate="yes" xml:space="preserve">
          <source>If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows this approach, together with &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; to normalize the nested API responses. With this approach, your state might look like this:</source>
          <target state="translated">エンティティをネストしている場合、またはユーザーが受信したエンティティを編集できるようにする場合は、データベースの場合と同じ状態で個別に保持する必要があります。ページネーション情報では、IDでのみ参照します。これにより、常に最新の状態に保つことができます。&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;現実世界の例では&lt;/a&gt;、一緒に、このアプローチを示し&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt;ネストされたAPIのレスポンスを正規化します。このアプローチでは、状態は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4f8b6dfa0ebcbb78dc0a91f22c821a3a280371e2" translate="yes" xml:space="preserve">
          <source>If you make a typo when importing an action constant, you will get &lt;code&gt;undefined&lt;/code&gt;. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.</source>
          <target state="translated">アクション定数をインポートするときにタイプミスをすると、 &lt;code&gt;undefined&lt;/code&gt; になります。Reduxはそのようなアクションをディスパッチするとすぐにスローし、間違いをより早く見つけます。</target>
        </trans-unit>
        <trans-unit id="73befc0dc9f970460cd3aed6b1aca8d76525c521" translate="yes" xml:space="preserve">
          <source>If you use ES5, instead of &lt;code&gt;import * as&lt;/code&gt; syntax you can just pass &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; to &lt;code&gt;bindActionCreators&lt;/code&gt; as the first argument. The only thing it cares about is that the values of the &lt;code&gt;actionCreators&lt;/code&gt; arguments are functions. The module system doesn't matter.</source>
          <target state="translated">あなたはES5を使用する場合は、代わりに &lt;code&gt;import * as&lt;/code&gt; 構文あなただけ渡すことができます &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; に &lt;code&gt;bindActionCreators&lt;/code&gt; 最初の引数としてを。それが気にする唯一のものは、 &lt;code&gt;actionCreators&lt;/code&gt; 引数の値が関数であることです。モジュールシステムは関係ありません。</target>
        </trans-unit>
        <trans-unit id="4df0e81af972f49797fdb77dbfa3675c8af338b1" translate="yes" xml:space="preserve">
          <source>If you use React, note that you can improve performance of multiple synchronous dispatches by wrapping them in &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt;, but this API is experimental and may be removed in any React release so don't rely on it too heavily. Take a look at &lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; (a higher-order reducer that lets you dispatch several actions as if it was one and &amp;ldquo;unpack&amp;rdquo; them in the reducer), &lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; (a store enhancer that lets you debounce subscriber calls for multiple dispatches), or &lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt; (a store enhancer that handles dispatching an array of actions with a single subscriber notification).</source>
          <target state="translated">Reactを使用する場合は、複数の同期ディスパッチを &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt; でラップすることでパフォーマンスを向上させることができますが、このAPIは実験的であり、Reactのリリースで削除される可能性があるため、あまり頼りにしないでください。見てみましょう&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;Reduxの-バッチ処理-アクション&lt;/a&gt;（それは減速に1つ、「アンパック」彼らだったかのように、いくつかのアクションをディスパッチすることができます高次の減速を）、&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;再来-バッチ処理-購読&lt;/a&gt;（加入者デバウンスあなたをすることができます店エンハンサー複数のディスパッチの呼び出し）、または&lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt;（単一のサブスクライバー通知でアクションの配列のディスパッチを処理するストアエンハンサー）。</target>
        </trans-unit>
        <trans-unit id="9271dc344ed7ad99882268b8d2eb8bf8888f3412" translate="yes" xml:space="preserve">
          <source>If you use a library like &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you might be using &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order components&lt;/a&gt; like &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;. This lets you inject Redux state into a regular React component.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;などのライブラリを使用している場合は、&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;などの&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;高次コンポーネント&lt;/a&gt;を使用している可能性があります。これにより、通常のReactコンポーネントにRedux状態を注入できます。</target>
        </trans-unit>
        <trans-unit id="6cd635904f7059bfcd20e75164dcce6a3c6db39b" translate="yes" xml:space="preserve">
          <source>If you use other store enhancers in addition to &lt;code&gt;applyMiddleware&lt;/code&gt;, make sure to put &lt;code&gt;applyMiddleware&lt;/code&gt; before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.</source>
          <target state="translated">&lt;code&gt;applyMiddleware&lt;/code&gt; に加えて他のストアエンハンサーを使用する場合、ミドルウェアは潜在的に非同期であるため、 &lt;code&gt;applyMiddleware&lt;/code&gt; 前にapplyMiddlewareを配置してください。たとえば、それが&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtoolsの&lt;/a&gt;前にある必要があります。そうしないと、DevToolsがPromiseミドルウェアなどによって発行された生のアクションを認識できないためです。</target>
        </trans-unit>
        <trans-unit id="5b994687ed5da06c8ff7d250360e547dbe6399b8" translate="yes" xml:space="preserve">
          <source>If you use something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;, you might also want to express your data fetching dependencies as static &lt;code&gt;fetchData()&lt;/code&gt; methods on your route handler components. They may return &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt;, so that your &lt;code&gt;handleRender&lt;/code&gt; function can match the route to the route handler component classes, dispatch &lt;code&gt;fetchData()&lt;/code&gt; result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Routerの&lt;/a&gt;ようなものを使用する場合は、データフェッチの依存関係をルートハンドラコンポーネントの静的な &lt;code&gt;fetchData()&lt;/code&gt; メソッドとして表現することもできます。それらは&lt;a href=&quot;../advanced/asyncactions&quot;&gt;非同期アクションを&lt;/a&gt;返す可能性があるため、 &lt;code&gt;handleRender&lt;/code&gt; 関数はルートをルートハンドラコンポーネントクラスに &lt;code&gt;fetchData()&lt;/code&gt; せ、それぞれのfetchData（）結果をディスパッチし、Promiseが解決された後にのみレンダリングできます。このように、さまざまなルートに必要な特定のAPI呼び出しは、ルートハンドラーコンポーネント定義と同じ場所に配置されます。クライアント側でも同じ手法を使用して、データが読み込まれるまでルーターがページを切り替えないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="f28ac508cdd88eefae0fc560e0d0772276239bef" translate="yes" xml:space="preserve">
          <source>If you want to conditionally apply a middleware, make sure to only import it when it's needed:</source>
          <target state="translated">ミドルウェアを条件付きで適用したい場合は、必要なときだけインポートするようにしてください。</target>
        </trans-unit>
        <trans-unit id="3e7d35f34c8cafb2605b96694ac400ffa75f61c6" translate="yes" xml:space="preserve">
          <source>If you're already familiar with the basic concepts and have previously completed this tutorial, don't forget to check out &lt;a href=&quot;../advanced/asyncflow&quot;&gt;async flow&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how middleware transforms &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; before they reach the reducer.</source>
          <target state="translated">基本的な概念にすでに精通しており、このチュートリアルをすでに完了している場合は、ミドルウェアがレデューサーに到達する前にミドルウェアが&lt;a href=&quot;../advanced/asyncactions&quot;&gt;非同期アクションを&lt;/a&gt;変換する方法を学ぶために、&lt;a href=&quot;../advanced/index&quot;&gt;高度なチュートリアル&lt;/a&gt;で&lt;a href=&quot;../advanced/asyncflow&quot;&gt;非同期フロー&lt;/a&gt;をチェックすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="816a6eef450003d62c904a3bd887b32f4e650f73" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. &lt;strong&gt;Instead, there is just a single store with a single root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt;.&lt;/strong&gt; As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">Fluxから来ている場合は、理解する必要がある1つの重要な違いがあります。 ReduxにはDispatcherがなく、多くのストアをサポートしていません。&lt;strong&gt;代わりに、単一のルート&lt;a href=&quot;../glossary#reducer&quot;&gt;削減機能を備え&lt;/a&gt;た単一のストアがあります。&lt;/strong&gt;アプリが成長するにつれて、ストアを追加する代わりに、ルートリデューサーを、ステートツリーのさまざまな部分を個別に操作する小さなリデューサーに分割します。あなたはそれらを組み合わせるために&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; の&lt;/a&gt;ようなヘルパーを使用することができます。これは、Reactアプリにルートコンポーネントが1つしかないのと似ていますが、多くの小さなコンポーネントで構成されています。</target>
        </trans-unit>
        <trans-unit id="428736da48a00e318f6b5e97ec36e76a4fb9754a" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">もしあなたがFluxから来ているのであれば、理解しておくべき重要な違いが一つあります。ReduxはDispatcherを持っていませんし、多くのストアをサポートしていません。その代わり、1つのルート削減機能を持つ1つのストアがあるだけです。アプリが成長すると、ストアを追加する代わりに、ルートリデューサを分割して、ステートツリーの異なる部分で独立して動作する小さなリデューサに分割します。これは、React アプリに 1 つのルートコンポーネントがあるのと全く同じですが、多くの小さなコンポーネントから構成されています。</target>
        </trans-unit>
        <trans-unit id="f0cc9c7c3b559caffbbd11ca7ac8b9023f058297" translate="yes" xml:space="preserve">
          <source>If you're in doubt, check out the Redux source code (there isn't much going on there), as well as its ecosystem (for example, &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;). If you don't care too much about it and want to go with the reactive data flow all the way, you might want to explore something like &lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt; instead, or even combine it with Redux. Let us know how it goes!</source>
          <target state="translated">疑わしい場合は、Reduxのソースコード（あまり進んでいない）とそのエコシステム（&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;開発者ツールなど&lt;/a&gt;）を確認してください。あまり気にせず、リアクティブなデータフローにずっと行きたい場合は、代わりに&lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt;などを探索したり、Reduxと組み合わせたりすることもできます。それがどうなるか教えてください！</target>
        </trans-unit>
        <trans-unit id="7a3ca8f9048bbc67b3c079811024df3868485a73" translate="yes" xml:space="preserve">
          <source>If you're just learning React, you should probably focus on thinking in React first, then look at Redux once you better understand React and how Redux might fit into your application.</source>
          <target state="translated">もしあなたがReactを学び始めたばかりなら、最初にReactで考えることに集中し、Reactをより理解してReduxを見て、Reduxがあなたのアプリケーションにどのようにフィットするかを理解した後に、Reduxを見るべきでしょう。</target>
        </trans-unit>
        <trans-unit id="56294c132212d734163e82c754555af03986a8f4" translate="yes" xml:space="preserve">
          <source>If you're new to the NPM ecosystem and have troubles getting a project up and running, or aren't sure where to paste the gist above, check out &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;simplest-redux-example&lt;/a&gt; that uses Redux together with React and Browserify.</source>
          <target state="translated">NPMエコシステムに不慣れで、プロジェクトの起動と実行に問題がある場合、または上記の要点をどこに貼り付けるかわからない場合は、ReactとBrowserifyとともにReduxを使用する&lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;最も簡単なreduxの例&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="2d0d749eb693db3084a30e822fa61e81b13144b8" translate="yes" xml:space="preserve">
          <source>If you're not, you can &lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;access these files on unpkg&lt;/a&gt;, download them, or point your package manager to them.</source>
          <target state="translated">そうでない場合は、&lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;unpkg&lt;/a&gt;でこれらのファイルにアクセスしたり、ファイルをダウンロードしたり、パッケージマネージャーにこれらのファイルを指定したりできます。</target>
        </trans-unit>
        <trans-unit id="89793009075a44d386caea025880b6492221229c" translate="yes" xml:space="preserve">
          <source>If you're somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; lets you use a &lt;code&gt;connect&lt;/code&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order component&lt;/a&gt; that will, apart from subscribing you to a Redux store, inject &lt;code&gt;dispatch&lt;/code&gt; into your component's props.</source>
          <target state="translated">コンポーネント階層のどこかに深い場合、手動でストアを渡すのは面倒です。このため、&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;では、 &lt;code&gt;connect&lt;/code&gt; &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;高次コンポーネント&lt;/a&gt;を使用して、Reduxストアにサブスクライブするほか、コンポーネントのプロップに &lt;code&gt;dispatch&lt;/code&gt; を注入できます。</target>
        </trans-unit>
        <trans-unit id="9847b990c2956da3cc4e51d7455ae0fd5c2d3799" translate="yes" xml:space="preserve">
          <source>If you're still not convinced, read &lt;a href=&quot;../introduction/motivation&quot;&gt;Motivation&lt;/a&gt; and &lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;The Case for Flux&lt;/a&gt; for a compelling argument in favor of unidirectional data flow. Although &lt;a href=&quot;../introduction/priorart&quot;&gt;Redux is not exactly Flux&lt;/a&gt;, it shares the same key benefits.</source>
          <target state="translated">それでも確信が&lt;a href=&quot;../introduction/motivation&quot;&gt;持て&lt;/a&gt;ない場合は、モチベーションと&lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;フラックスの事例を&lt;/a&gt;読んで、一方向のデータフローを支持する説得力のある議論を探してください。が&lt;a href=&quot;../introduction/priorart&quot;&gt;Reduxのは、正確にフラックスではない&lt;/a&gt;、それは同じキーの利点を共有しています。</target>
        </trans-unit>
        <trans-unit id="5c63a9398fd378c51f8bf9e677e8aa928203398f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; or similar bindings, you likely won't have direct access to the store instance in your components. For the next few paragraphs, just assume you pass the store down explicitly.</source>
          <target state="translated">あなたが使用している場合&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;に反応-再来&lt;/a&gt;または類似のバインディングを、あなたはおそらく、あなたのコンポーネントにストアインスタンスへの直接アクセスすることはできません。次のいくつかの段落では、ストアを明示的に渡すと仮定します。</target>
        </trans-unit>
        <trans-unit id="01cdd0731454ffd1d20cd96f11a3d32664207b62" translate="yes" xml:space="preserve">
          <source>If your Backbone codebase is too big for a quick rewrite or you don't want to manage interactions between store and models, use &lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;backbone-redux-migrator&lt;/a&gt; to help your two codebases coexist while keeping healthy separation. Once your rewrite finishes, Backbone code can be discarded and your Redux application can work on its own once you configure router.</source>
          <target state="translated">バックボーンコードベースが大きすぎてすばやく書き換えられない場合、またはストアとモデル間の相互作用を管理したくない場合は、&lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;backbone-redux-migrator&lt;/a&gt;を使用して、2つのコードベースが共存しながら健全な分離を維持できるようにします。書き換えが完了すると、バックボーンコードは破棄され、ルーターを構成すると、Reduxアプリケーションはそれ自体で動作します。</target>
        </trans-unit>
        <trans-unit id="fe98ef98166939af239eed6b2d81cd88bea35531" translate="yes" xml:space="preserve">
          <source>If your head boiled from reading the above section, imagine what it was like to write it. This section is meant to be a relaxation for you and me, and will help get your gears turning.</source>
          <target state="translated">上のセクションを読んで頭が沸騰したなら、それがどんな感じで書かれたのか想像してみてください。このセクションは、あなたと私の息抜きになることを意図しており、あなたのギアを回すのに役立つでしょう。</target>
        </trans-unit>
        <trans-unit id="5a439ce92e30ef4f0c974a7c73870d7c4912681d" translate="yes" xml:space="preserve">
          <source>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;. You can also write &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; if you enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;.</source>
          <target state="translated">状態がプレーンオブジェクトの場合は、変更しないでください。たとえば、レデューサーから &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; ようなものを返す代わりに、 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; ます。このようにして、以前の &lt;code&gt;state&lt;/code&gt; 上書きしません。&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;オブジェクトスプレッドオペレーターの提案&lt;/a&gt;を有効にすると、 &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; 書き込むこともできます。</target>
        </trans-unit>
        <trans-unit id="6373833358e0059931cc766a20497e267d0055c4" translate="yes" xml:space="preserve">
          <source>Imagine your app&amp;rsquo;s state is described as a plain object. For example, the state of a todo app might look like this:</source>
          <target state="translated">アプリの状態がプレーンオブジェクトとして記述されているとしましょう。たとえば、Todoアプリの状態は次のようになります。</target>
        </trans-unit>
        <trans-unit id="0d512cb13653145d5f418624490cb11a59c20835" translate="yes" xml:space="preserve">
          <source>Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.</source>
          <target state="translated">不変性はアプリのパフォーマンスを向上させ、プログラミングやデバッグの簡素化につながります。</target>
        </trans-unit>
        <trans-unit id="7748d3ba70c7e8503005d5183b42db995cf3479a" translate="yes" xml:space="preserve">
          <source>Immutability is what lets &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with &lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;.</source>
          <target state="translated">不変性とは、&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-reduxが&lt;/a&gt;状態の細かい更新を効率的にサブスクライブできるようにするものです。また、&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;を使用したタイムトラベルなどの優れた開発者エクスペリエンス機能も有効にします。</target>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="674da9972545b8a3d30b18b2b631a253089574ce" translate="yes" xml:space="preserve">
          <source>Immutable Data Management</source>
          <target state="translated">不変データ管理</target>
        </trans-unit>
        <trans-unit id="f194c27186d4d976f210a867f1b7493fc5734e87" translate="yes" xml:space="preserve">
          <source>Immutable Data Structures and JavaScript</source>
          <target state="translated">不変データ構造とJavaScript</target>
        </trans-unit>
        <trans-unit id="3f337e1757211d31f0134ce96582c18a500ad82d" translate="yes" xml:space="preserve">
          <source>Immutable Data from Scratch</source>
          <target state="translated">スクラッチからの不変データ</target>
        </trans-unit>
        <trans-unit id="e69f6aa84f66db9f8ef96ac695cc3f24fae1dc21" translate="yes" xml:space="preserve">
          <source>Immutable Data using ES6 and Beyond</source>
          <target state="translated">ES6以降を使用した不変データ</target>
        </trans-unit>
        <trans-unit id="cda456672d3ee4fa81f3ddcd2803e3ee0a8d4c04" translate="yes" xml:space="preserve">
          <source>Immutable Javascript using ES6 and beyond</source>
          <target state="translated">ES6以降を使用した不変のJavascript</target>
        </trans-unit>
        <trans-unit id="973175b7f3b4ff6e4efbc6ead54d53aad1a95619" translate="yes" xml:space="preserve">
          <source>Immutable Object Formatter</source>
          <target state="translated">不変オブジェクトフォーマッタ</target>
        </trans-unit>
        <trans-unit id="d8acc5408d603ab59b3c9faed6a7e6bc40e90b10" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns</source>
          <target state="translated">不変の更新パターン</target>
        </trans-unit>
        <trans-unit id="7453da6cbc7da4258fe3287ac0a6c8690fe9793c" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns for ES6</source>
          <target state="translated">ES6の不変アップデートパターン</target>
        </trans-unit>
        <trans-unit id="33ff07243fabffc0f9f1077cf8800e362ccb5eaa" translate="yes" xml:space="preserve">
          <source>Immutable Update Utility Libraries</source>
          <target state="translated">不変更新ユーティリティライブラリ</target>
        </trans-unit>
        <trans-unit id="5bd90f13857bde1d7e445ee9ceeba04700668e97" translate="yes" xml:space="preserve">
          <source>Immutable and most similar libraries are orthogonal to Redux. Feel free to use them together!</source>
          <target state="translated">Immutableとほとんどの類似ライブラリはReduxと直交しています。ご自由に併用してください。</target>
        </trans-unit>
        <trans-unit id="ea78c55982bab7f948fd4ba6bc2bd11c80ae37ff" translate="yes" xml:space="preserve">
          <source>Immutable data management ultimately makes data handling safer.</source>
          <target state="translated">不変のデータ管理は、最終的にデータの取り扱いをより安全にします。</target>
        </trans-unit>
        <trans-unit id="12e9a327a00ad002de1d25ee12aec93959806cd7" translate="yes" xml:space="preserve">
          <source>Immutable-focused libraries such as Immutable.JS have been designed to overcome the issues with immutability inherent within JavaScript, providing all the benefits of immutability with the performance your app requires.</source>
          <target state="translated">Immutable.JSのような不変性に特化したライブラリは、JavaScriptに内在する不変性の問題を克服するために設計されており、アプリが必要とするパフォーマンスで不変性のすべての利点を提供します。</target>
        </trans-unit>
        <trans-unit id="4e6fbec38c5ba31d45e4cbd8958dc74112ebd4b2" translate="yes" xml:space="preserve">
          <source>Immutable.JS avoids this by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;cleverly sharing data structures&lt;/a&gt; under the surface, minimizing the need to copy data. It also enables complex chains of operations to be carried out without creating unnecessary (and costly) cloned intermediate data that will quickly be thrown away.</source>
          <target state="translated">Immutable.JSは、&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;データ構造&lt;/a&gt;を表面下で巧みに共有することでこれを回避し、データをコピーする必要性を最小限に抑えます。また、不要な（そしてコストのかかる）複製された中間データを作成せずに、複雑な一連の操作を実行できるため、すぐに破棄されます。</target>
        </trans-unit>
        <trans-unit id="c4bca118ae44915dde169b1e2c52c2a3216d820a" translate="yes" xml:space="preserve">
          <source>Immutable.JS can provide significant reliability and performance improvements to your app, but it must be used correctly. If you choose to use Immutable.JS (and remember, you are not required to, and there are other immutable libraries you can use), follow these opinionated best practices, and you&amp;rsquo;ll be able to get the most out of it, without tripping up on any of the issues it can potentially cause.</source>
          <target state="translated">Immutable.JSは、アプリの信頼性とパフォーマンスを大幅に向上させることができますが、正しく使用する必要があります。Immutable.JSを使用することを選択した場合（そして、必須ではなく、使用できる他の不変のライブラリーがあることを覚えておいてください）、これらの意見に基づいたベストプラクティスに従ってください。そうしないと、それを最大限に活用できます。それが潜在的に引き起こす可能性のある問題のいずれかでつまずく。</target>
        </trans-unit>
        <trans-unit id="20c874460a6804e3b2c27f9b25a6746d6bfb6f9b" translate="yes" xml:space="preserve">
          <source>Immutable.JS does a lot work behind the scenes to optimize performance. This is the key to its power, as using immutable data structures can involve a lot of expensive copying. In particular, immutably manipulating large, complex data sets, such as a nested Redux state tree, can generate many intermediate copies of objects, which consume memory and slow down performance as the browser&amp;rsquo;s garbage collector fights to clean things up.</source>
          <target state="translated">Immutable.JSは、パフォーマンスを最適化するために舞台裏で多くの作業を行います。不変のデータ構造を使用すると、高価なコピーが大量に発生する可能性があるため、これはその能力の鍵です。特に、入れ子になったRedux状態ツリーなどの大規模で複雑なデータセットを不変に操作すると、オブジェクトの多くの中間コピーが生成され、ブラウザーのガベージコレクターがクリーンアップを行う際にメモリを消費し、パフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="6cc90700452643c9a9c0e8f4b109806ca1907669" translate="yes" xml:space="preserve">
          <source>Immutable.JS objects, such as &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc., can be difficult to debug, as inspecting such an object will reveal an entire nested hierarchy of Immutable.JS-specific properties that you don&amp;rsquo;t care about, while your actual data that you do care about is encapsulated several layers deep.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;List&lt;/code&gt; などのImmutable.JSオブジェクトは、そのオブジェクトを検査すると、気にしないImmutable.JS固有のプロパティのネストされた階層全体が明らかになり、実際のデータはあなたが気にすることは、いくつかの層の深さでカプセル化されています。</target>
        </trans-unit>
        <trans-unit id="b728994e17e8c21ef4849874d50ee39e9635a6f5" translate="yes" xml:space="preserve">
          <source>Immutable.JS provides a rich set of immutable objects to encapsulate your data (e.g. Maps, Lists, Sets, Records, etc.), and an extensive set of methods to manipulate it, including methods to sort, filter, and group the data, reverse it, flatten it, and create subsets.</source>
          <target state="translated">Immutable.JS は、データをカプセル化するための豊富な Immutable オブジェクトのセット (マップ、リスト、セット、レコードなど)と、データのソート、フィルタリング、グループ化、データの反転、平坦化、サブセットの作成など、データを操作するためのメソッドの豊富なセットを提供します。</target>
        </trans-unit>
        <trans-unit id="8d99c53713fdd9ecf08a9eeb1a70e8a2964a5cf1" translate="yes" xml:space="preserve">
          <source>Immutable.JS was designed to provide immutability in a performant manner in an effort to overcome the limitations of immutability with JavaScript. Its principle advantages include:</source>
          <target state="translated">Immutable.JSは、JavaScriptによる不変性の限界を克服するために、実行可能な方法で不変性を提供するように設計されました。その主な利点は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b492caa1430f9e67bef5127ef78bb8219dbd86c" translate="yes" xml:space="preserve">
          <source>Immutable.JS works best for collections of data, and the larger the better. It can be slow when your data comprises lots of small, simple JavaScript objects, with each comprising a few keys of primitive values.</source>
          <target state="translated">Immutable.JS はデータの集合体に最適です。データが小さなシンプルな JavaScript オブジェクトで構成されていて、それぞれがプリミティブな値のキーをいくつか持っている場合、動作が遅くなることがあります。</target>
        </trans-unit>
        <trans-unit id="1fed6b895cf747a93a21ea8add3ba23effdc034a" translate="yes" xml:space="preserve">
          <source>Immutable.js - Immutable Collections for JavaScript</source>
          <target state="translated">Immutable.js-JavaScriptのためのImmutableコレクション</target>
        </trans-unit>
        <trans-unit id="50598f7dc9386f9779647be8fdfdf65fd92fe212" translate="yes" xml:space="preserve">
          <source>Immutable.js, persistent data structures and structural sharing</source>
          <target state="translated">Immutable.js、永続的なデータ構造と構造的な共有</target>
        </trans-unit>
        <trans-unit id="fd7e1350aad385c556192ea311d3f9f4440b4840" translate="yes" xml:space="preserve">
          <source>ImmutableJS: worth the price?</source>
          <target state="translated">ImmutableJS:価格に見合う価値があるか?</target>
        </trans-unit>
        <trans-unit id="879b24a430b9ab1f4e8c76b4dfa0887fc3c04d07" translate="yes" xml:space="preserve">
          <source>Immutably updating objects and arrays safely</source>
          <target state="translated">オブジェクトと配列を不変に安全に更新</target>
        </trans-unit>
        <trans-unit id="f37f816825de6623c275fae3ddf78ea2ec8ca471" translate="yes" xml:space="preserve">
          <source>Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.</source>
          <target state="translated">不変に状態を更新するということは、一般的には深いコピーではなく浅いコピーを行うことを意味します。浅いコピーは、コピーされるオブジェクトやフィールドが少なくなるため、深いコピーよりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="0a6446305b39453eb5282988df8de2320a57875d" translate="yes" xml:space="preserve">
          <source>Implementing Components</source>
          <target state="translated">コンポーネントの実装</target>
        </trans-unit>
        <trans-unit id="56aeb896976173293390de95c9507133f3d2e7e4" translate="yes" xml:space="preserve">
          <source>Implementing Container Components</source>
          <target state="translated">コンテナコンポーネントの実装</target>
        </trans-unit>
        <trans-unit id="43492db8e2cb0ccb4f69d638a38af639d790168e" translate="yes" xml:space="preserve">
          <source>Implementing Other Components</source>
          <target state="translated">その他のコンポーネントの実装</target>
        </trans-unit>
        <trans-unit id="a1c1c997da2a03119d1777770189d8c530547e28" translate="yes" xml:space="preserve">
          <source>Implementing Presentational Components</source>
          <target state="translated">プレゼントコンポーネントの実装</target>
        </trans-unit>
        <trans-unit id="3c7e5554c6cc65b0860b475288581cda33e0f76b" translate="yes" xml:space="preserve">
          <source>Implementing Undo History</source>
          <target state="translated">Undo履歴の実装</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="461dfd2a69948b84d92969ac1b9fc39ee72ff9b8" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Perf with Reselect</source>
          <target state="translated">リセレクトでReactとReduxのパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="1e6ff2f3e12ce6aab10b9bec9cab6d60b64497ea" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Performance with Reselect</source>
          <target state="translated">ReselectでReactとReduxのパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="831e8524a43e2feb49c2742ea27fbb2612cd63b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;traditional Flux&lt;/a&gt;, action creators often trigger a dispatch when invoked, like so:</source>
          <target state="translated">では&lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;、従来のフラックス&lt;/a&gt;呼び出されたときに、アクションの作成者は、多くの場合、そのような派遣をトリガ：</target>
        </trans-unit>
        <trans-unit id="40dceb766db3717cd4f328d563428fe98260c2e5" translate="yes" xml:space="preserve">
          <source>In Depth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d1fa6c5616fe360b5c666020ecae8fe2e73764" translate="yes" xml:space="preserve">
          <source>In Flux, it is traditionally thought that you would define every action type as a string constant:</source>
          <target state="translated">Fluxでは、すべてのアクションタイプを文字列定数として定義することが伝統的に考えられています。</target>
        </trans-unit>
        <trans-unit id="c614b1de37c0649d85e4de6785709030fe57b0ee" translate="yes" xml:space="preserve">
          <source>In Redux action creators simply return an action:</source>
          <target state="translated">Reduxでは、アクションクリエーターは単にアクションを返すだけです。</target>
        </trans-unit>
        <trans-unit id="13d908827ee0f85cbdbc48b6e6b0f4b0ba7e1ede" translate="yes" xml:space="preserve">
          <source>In Redux this is &lt;em&gt;not&lt;/em&gt; the case.</source>
          <target state="translated">Reduxではこれは当てはまり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fb7413db62de4f3ba71879e02b2f0337a6068408" translate="yes" xml:space="preserve">
          <source>In Redux, action creators are functions which return plain objects. When testing action creators we want to test whether the correct action creator was called and also whether the right action was returned.</source>
          <target state="translated">Reduxでは、アクションクリエーターはプレーンオブジェクトを返す関数です。アクションクリエーターをテストする際には、正しいアクションクリエーターが呼び出されたかどうか、また正しいアクションが返されたかどうかをテストしたいものです。</target>
        </trans-unit>
        <trans-unit id="f0927ace523de150037e069de9e99b9a0427c743" translate="yes" xml:space="preserve">
          <source>In Redux, all the application state is stored as a single object. It's a good idea to think of its shape before writing any code. What's the minimal representation of your app's state as an object?</source>
          <target state="translated">Reduxでは、アプリケーションの状態はすべて1つのオブジェクトとして格納されています。コードを書く前にその形を考えておくといいでしょう。アプリの状態をオブジェクトとして最低限の表現は?</target>
        </trans-unit>
        <trans-unit id="b8579ec417a0f350980bbd379e3d451d4be5f432" translate="yes" xml:space="preserve">
          <source>In Redux, subscriptions are called after the root reducer has returned the new state, so you &lt;em&gt;may&lt;/em&gt; dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;.</source>
          <target state="translated">ルート減速が新しい状態を返した後、あなたがしてReduxのでは、サブスクリプションは、呼ばれて&lt;em&gt;も&lt;/em&gt;、サブスクリプション・リスナーに派遣します。レデューサーには副作用がないため、レデューサー内でのディスパッチのみが許可されています。アクションに応じて副作用を引き起こしたい場合、これを行う適切な場所は、非同期の可能性がある&lt;a href=&quot;../glossary#action-creator&quot;&gt;アクションの作成者&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="025a5c8609578dcf3fbad95a8468e74d10860635" translate="yes" xml:space="preserve">
          <source>In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be &lt;em&gt;pure functions&lt;/em&gt;&amp;mdash;functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.</source>
          <target state="translated">Reduxでは、累積値は状態オブジェクトであり、累積される値はアクションです。リデューサーは、前の状態とアクションを指定して、新しい状態を計算します。これらは&lt;em&gt;純粋な関数で&lt;/em&gt;なければなりません&amp;mdash; 与えられた入力に対してまったく同じ出力を返す&lt;em&gt;関数&lt;/em&gt;です。また、副作用がないことも必要です。これにより、ホットリロードやタイムトラベルなどのエキサイティングな機能が可能になります。</target>
        </trans-unit>
        <trans-unit id="d9e26ebe19ef325c1ead334671d67cb972dd9b0b" translate="yes" xml:space="preserve">
          <source>In a React app, usually you would wrap &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; so that when the URL changes, &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; will match a branch of its routes, and render their configured components. &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; is used to declaratively map routes to your application's component hierarchy. You would declare in &lt;code&gt;path&lt;/code&gt; the path used in the URL and in &lt;code&gt;component&lt;/code&gt; the single component to be rendered when the route matches the URL.</source>
          <target state="translated">Reactアプリでは通常、 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; /&amp;gt;でラップして、URLが変更されたときに &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; がルートのブランチと一致し、構成されたコンポーネントをレンダリングするようにします。 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; は、ルートをアプリケーションのコンポーネント階層に宣言的にマップするために使用されます。URLで使用される &lt;code&gt;path&lt;/code&gt; 宣言し、 &lt;code&gt;component&lt;/code&gt; 、ルートがURLと一致したときにレンダリングされる単一のコンポーネントを宣言します。</target>
        </trans-unit>
        <trans-unit id="552d20c35b7a19e38fbb041cf812c68e0d31ccf1" translate="yes" xml:space="preserve">
          <source>In a more complex app, you're going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app's state as a database. This approach is described in &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr's&lt;/a&gt; documentation in detail. For example, keeping &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; and &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; inside the state would be a better idea in a real app, but we're keeping the example simple.</source>
          <target state="translated">より複雑なアプリでは、さまざまなエンティティが相互に参照するようにします。ネストすることなく、状態をできる限り正規化することをお勧めします。 IDをキーとして格納されたオブジェクト内のすべてのエンティティを保持し、IDを使用して他のエンティティまたはリストからそれを参照します。アプリの状態をデータベースと考えてください。このアプローチについては、&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizrの&lt;/a&gt;ドキュメントで詳しく説明されています。たとえば、実際のアプリでは &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; と &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; をステート内に保持する方が良いアイデアですが、ここでは例をシンプルにしています。</target>
        </trans-unit>
        <trans-unit id="0f7529398006305ace4f3aedcbda960fbff2edf9" translate="yes" xml:space="preserve">
          <source>In a real app, you'd also want to dispatch an action on request failure. We won't implement error handling in this tutorial, but the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows one of the possible approaches.</source>
          <target state="translated">実際のアプリでは、リクエストが失敗したときにアクションをディスパッチすることもできます。このチュートリアルではエラー処理を実装しませんが、&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;実際の例&lt;/a&gt;は可能なアプローチの1つを示しています。</target>
        </trans-unit>
        <trans-unit id="dc5515a15d4d57aff8873c1659dd4ea00cfc4cf6" translate="yes" xml:space="preserve">
          <source>In a unit test, you would normally import the &lt;code&gt;App&lt;/code&gt; component like this:</source>
          <target state="translated">単体テストでは、通常、次のように &lt;code&gt;App&lt;/code&gt; コンポーネントをインポートします。</target>
        </trans-unit>
        <trans-unit id="73d7d394023da3e8367ec8a78e584be34cff3bc0" translate="yes" xml:space="preserve">
          <source>In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called &lt;code&gt;mapDispatchToProps()&lt;/code&gt; that receives the &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and returns callback props that you want to inject into the presentational component. For example, we want the &lt;code&gt;VisibleTodoList&lt;/code&gt; to inject a prop called &lt;code&gt;onTodoClick&lt;/code&gt; into the &lt;code&gt;TodoList&lt;/code&gt; component, and we want &lt;code&gt;onTodoClick&lt;/code&gt; to dispatch a &lt;code&gt;TOGGLE_TODO&lt;/code&gt; action:</source>
          <target state="translated">状態を読み取ることに加えて、コンテナコンポーネントはアクションをディスパッチできます。同様に、&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;メソッドを受け取り、プレゼンテーションコンポーネントに注入するコールバックプロップを返す &lt;code&gt;mapDispatchToProps()&lt;/code&gt; という関数を定義できます。例えば、我々はしたい &lt;code&gt;VisibleTodoList&lt;/code&gt; が呼ばれる小道具注入する &lt;code&gt;onTodoClick&lt;/code&gt; に &lt;code&gt;TodoList&lt;/code&gt; コンポーネントを、私たちは望ん &lt;code&gt;onTodoClick&lt;/code&gt; を派遣する &lt;code&gt;TOGGLE_TODO&lt;/code&gt; のアクションを：</target>
        </trans-unit>
        <trans-unit id="43300067fd4f93325fe0edeb1855206b18b46712" translate="yes" xml:space="preserve">
          <source>In contrast, immutable libraries such as Immutable.JS can employ sophisticated optimization techniques such as &lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;structural sharing&lt;/a&gt; , which effectively returns a new object that reuses much of the existing object being copied from.</source>
          <target state="translated">対照的に、Immutable.JSなどの不変ライブラリーは、&lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;構造共有&lt;/a&gt;などの高度な最適化手法を使用できます。これにより、コピー元の既存オブジェクトの多くを再利用する新しいオブジェクトが効果的に返されます。</target>
        </trans-unit>
        <trans-unit id="29ff2a8b0f9d11d36b350ca4a91fa734773c9d7a" translate="yes" xml:space="preserve">
          <source>In fact, benchmarks have shown that more connected components generally leads to better performance than fewer connected components.</source>
          <target state="translated">実際、ベンチマークでは、接続されているコンポーネントの数が多い方が、接続されているコンポーネントの数が少ないよりも一般的にパフォーマンスが良いことが示されています。</target>
        </trans-unit>
        <trans-unit id="99060159575d5e17d9887f3b127903e3ce8600c6" translate="yes" xml:space="preserve">
          <source>In general, Redux suggests that code with side effects should be part of the action creation process. While that logic &lt;em&gt;can&lt;/em&gt; be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places&amp;mdash;in other words, an action creator function.</source>
          <target state="translated">一般的に、Reduxは副作用のあるコードはアクション作成プロセスの一部であるべきだと提案しています。そのロジック&lt;em&gt;は&lt;/em&gt; UIコンポーネントの内部で実行&lt;em&gt;でき&lt;/em&gt;ますが、通常はそのロジックを再利用可能な関数に抽出して、同じロジックを複数の場所から呼び出すことができるようになっています。つまり、アクションクリエーター関数です。</target>
        </trans-unit>
        <trans-unit id="3e2c413ba873419804cdd854ba00b2ace6bb914c" translate="yes" xml:space="preserve">
          <source>In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of &lt;em&gt;why&lt;/em&gt; the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it's a sign that you might want to introduce a new action type that is handled in a different way.</source>
          <target state="translated">一般に、これらのアクションが関連しているが独立しているのか、または実際には1つのアクションとして表す必要があるのか​​を尋ねます。自分の状況にとって意味のあることを行いますが、レデューサーの可読性とアクションログの可読性のバランスをとるようにしてください。たとえば、新しい状態ツリー全体を含むアクションは、レデューサーをワンライナーにしますが、欠点は、変更が発生した&lt;em&gt;理由&lt;/em&gt;の履歴がないため、デバッグが非常に困難になることです。一方、アクションを細かく保つためにループでアクションを発行する場合、別の方法で処理される新しいアクションタイプを導入する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9d9ba084eaa1fa2c8e34fad4286a77182f2d2144" translate="yes" xml:space="preserve">
          <source>In general, it looks like this:</source>
          <target state="translated">一般的にはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="8f22c2593249db901262ae0d0b5a9dc7e8b78af5" translate="yes" xml:space="preserve">
          <source>In general, remember that reducers are just functions&amp;mdash;you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (&amp;ldquo;reducer composition&amp;rdquo;). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and update state immutably rather than mutating it directly.</source>
          <target state="translated">一般に、レデューサーは単なる関数であることを覚えておいてください。レデューサーは、好きなように整理して細分化できます。また、小さくて再利用可能な関数（「レデューサー構成」）に分解することをお勧めします。その間、子のレデューサーが次の状態を計算するために追加のデータを必要とする場合は、親のレデューサーからカスタムの3番目の引数を渡すことができます。あなたは一緒にそれらがレデューサーの基本的なルールに従っていることを確認する必要があるだけです： &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 、そして状態を直接変更するのではなく不変に更新します。</target>
        </trans-unit>
        <trans-unit id="d63121f6c921270caadcee04ea945bd0333108c2" translate="yes" xml:space="preserve">
          <source>In general, try to find a balance between understandable data flow and areas of responsibility with your components.</source>
          <target state="translated">一般的には、理解しやすいデータフローと、コンポーネントの責任範囲のバランスを取るようにしてください。</target>
        </trans-unit>
        <trans-unit id="51c2fa7138486d88b5fa18d2475648afe59d02ed" translate="yes" xml:space="preserve">
          <source>In general, use Redux when you have reasonable amounts of data changing over time, you need a single source of truth, and you find that approaches like keeping everything in a top-level React component's state are no longer sufficient.</source>
          <target state="translated">一般的には、時間の経過とともに変化する妥当な量のデータがある場合、単一の真実のソースが必要な場合、トップレベルのReactコンポーネントの状態をすべて維持するようなアプローチではもはや十分ではないことがわかった場合にReduxを使用してください。</target>
        </trans-unit>
        <trans-unit id="55c79e3652fe883445e9b3cd96eb5f575b10fb17" translate="yes" xml:space="preserve">
          <source>In order to be able to test the App component itself without having to deal with the decorator, we recommend you to also export the undecorated component:</source>
          <target state="translated">デコレータを扱うことなくアプリのコンポーネント自体をテストできるようにするために、デコレータのないコンポーネントもエクスポートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6c1a7092fe1aea25b944efebbf5658054ed3643a" translate="yes" xml:space="preserve">
          <source>In order to share a selector across multiple &lt;code&gt;VisibleTodoList&lt;/code&gt; components &lt;strong&gt;and&lt;/strong&gt; retain memoization, each instance of the component needs its own private copy of the selector.</source>
          <target state="translated">複数の &lt;code&gt;VisibleTodoList&lt;/code&gt; コンポーネント間でセレクターを共有し、メモ&lt;strong&gt;を&lt;/strong&gt;保持するには、コンポーネントの各インスタンスにセレクターの独自のプライベートコピーが必要です。</target>
        </trans-unit>
        <trans-unit id="ff57866679ccf8351cc1283dd5651be401dbe088" translate="yes" xml:space="preserve">
          <source>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use &lt;code&gt;parseInt&lt;/code&gt; on the &lt;code&gt;counter&lt;/code&gt; parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="translated">この例では、セキュリティに対して初歩的なアプローチを採用しています。リクエストからパラメーターを取得するとき、 &lt;code&gt;counter&lt;/code&gt; パラメーターで &lt;code&gt;parseInt&lt;/code&gt; を使用して、この値が数値であることを確認します。これを行わなかった場合、リクエストにスクリプトタグを指定することで、レンダリングされたHTMLに危険なデータを簡単に取り込むことができます。次のようになります： &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a45d519ec7092557332a21b4f95c7890f59d8c28" translate="yes" xml:space="preserve">
          <source>In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to (a cornerstone of React&amp;rsquo;s performance improvements over other libraries).</source>
          <target state="translated">特に、Webアプリのコンテキストにおける不変性により、洗練された変更検出手法を簡単かつ安価に実装できるため、DOMを更新するための計算コストのかかるプロセスは、絶対に必要な場合にのみ発生します（他のライブラリに対するReactのパフォーマンス向上の要）。 。</target>
        </trans-unit>
        <trans-unit id="3ea8b1a13105717d19bf6d13ca29baf9d351fc73" translate="yes" xml:space="preserve">
          <source>In some cases, you will need to modify the &lt;code&gt;create&lt;/code&gt; function to use different mock implementations of &lt;code&gt;getState&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">場合によっては、 &lt;code&gt;getState&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; の異なるモック実装を使用するように &lt;code&gt;create&lt;/code&gt; 関数を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="9a560778ff92a1d751e213c0779836fe6174dc6b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;, we built a simple todo application. It was fully synchronous. Every time an action was dispatched, the state was updated immediately.</source>
          <target state="translated">では&lt;a href=&quot;../basics/index&quot;&gt;基本ガイド&lt;/a&gt;は、簡単なTODOアプリケーションを構築しました。それは完全に同期していた。アクションがディスパッチされるたびに、状態はすぐに更新されました。</target>
        </trans-unit>
        <trans-unit id="9d35265d513681e328e0eff05e802f8cb476ce9d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics walkthrough&lt;/a&gt;, we explored how to structure a simple Redux application. In this walkthrough, we will explore how AJAX and routing fit into the picture.</source>
          <target state="translated">で&lt;a href=&quot;../basics/index&quot;&gt;ウォークスルー基本&lt;/a&gt;は、簡単なReduxのアプリケーションを構築する方法を検討しました。このウォークスルーでは、AJAXとルーティングがどのように機能するかを説明します。</target>
        </trans-unit>
        <trans-unit id="c7465b6d942c4e067cd6e80afe069da00300c514" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;mapStateToProps&lt;/code&gt; calls &lt;code&gt;getVisibleTodos&lt;/code&gt; to calculate &lt;code&gt;todos&lt;/code&gt;. This works great, but there is a drawback: &lt;code&gt;todos&lt;/code&gt; is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.</source>
          <target state="translated">上記の例では、 &lt;code&gt;mapStateToProps&lt;/code&gt; は &lt;code&gt;getVisibleTodos&lt;/code&gt; を呼び出して &lt;code&gt;todos&lt;/code&gt; を計算します。これはうまく機能しますが、欠点があります。コンポーネントが更新されるたびに &lt;code&gt;todos&lt;/code&gt; が計算されます。状態ツリーが大きい場合、または計算に負荷がかかる場合、更新ごとに計算を繰り返すと、パフォーマンスの問題が発生する可能性があります。再選択は、これらの不要な再計算を回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="74b79c0e319782fa1b2ce1286be0efeb546c9fb7" translate="yes" xml:space="preserve">
          <source>In the app itself, you would still import it normally:</source>
          <target state="translated">アプリ自体では、今まで通り普通にインポートしていました。</target>
        </trans-unit>
        <trans-unit id="37f755748aa6d0df9f0a90fd85dea6dc752d6246" translate="yes" xml:space="preserve">
          <source>In the end, Redux is just a tool. It's a great tool, and there's some great reasons to use it, but there's also reasons you might not want to use it. Make informed decisions about your tools, and understand the tradeoffs involved in each decision.</source>
          <target state="translated">結局のところ、Reduxは単なるツールです。素晴らしいツールであり、それを使うべき素晴らしい理由がいくつかありますが、使いたくない理由もあります。ツールについて十分な情報に基づいた決定を行い、それぞれの決定に関わるトレードオフを理解してください。</target>
        </trans-unit>
        <trans-unit id="26a5d759ba12e2ce01d8df1300b5865e8a1aceec" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. &lt;code&gt;getVisibleTodos&lt;/code&gt; on the other hand is a memoized selector. It takes &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; as input-selectors, and a transform function that calculates the filtered todos list.</source>
          <target state="translated">上記の例では、 &lt;code&gt;getVisibilityFilter&lt;/code&gt; と &lt;code&gt;getTodos&lt;/code&gt; が入力セレクターです。これらは、選択したデータを変換しないため、通常の非メモ化セレクター関数として作成されます。一方、 &lt;code&gt;getVisibleTodos&lt;/code&gt; はメモ化されたセレクターです。それはとり &lt;code&gt;getVisibilityFilter&lt;/code&gt; と &lt;code&gt;getTodos&lt;/code&gt; を入力セレクタとして、そして濾過ドスリストを計算する関数を変換します。</target>
        </trans-unit>
        <trans-unit id="afd7412498e7c4b8984657c38f0316bc34913128" translate="yes" xml:space="preserve">
          <source>In the example below &lt;code&gt;makeMapStateToProps&lt;/code&gt; creates a new &lt;code&gt;getVisibleTodos&lt;/code&gt; selector, and returns a &lt;code&gt;mapStateToProps&lt;/code&gt; function that has exclusive access to the new selector:</source>
          <target state="translated">以下の例では、 &lt;code&gt;makeMapStateToProps&lt;/code&gt; が新しい &lt;code&gt;getVisibleTodos&lt;/code&gt; セレクターを作成し、新しいセレクターへの排他的アクセス権を持つ &lt;code&gt;mapStateToProps&lt;/code&gt; 関数を返します。</target>
        </trans-unit>
        <trans-unit id="02549e5da1d96280abf9f8af834de7e02b0480e3" translate="yes" xml:space="preserve">
          <source>In the example below, if &lt;code&gt;state.todos&lt;/code&gt; and the value returned from &lt;code&gt;getVisibleTodos()&lt;/code&gt; do not change on successive calls to &lt;code&gt;connect&lt;/code&gt;, then the component will not re-render .</source>
          <target state="translated">次の例では、 &lt;code&gt;state.todos&lt;/code&gt; と &lt;code&gt;getVisibleTodos()&lt;/code&gt; から返された値が &lt;code&gt;connect&lt;/code&gt; への連続した呼び出しで変化しない場合、コンポーネントは再レンダリングされません。</target>
        </trans-unit>
        <trans-unit id="74ee9c48a9c85ce991273312632d3dd6b926ea53" translate="yes" xml:space="preserve">
          <source>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</source>
          <target state="translated">このレシピの最初の部分では、UndoとRedoを一般的な方法で実装可能にする根本的な概念を説明します。</target>
        </trans-unit>
        <trans-unit id="b2243bc74f11442cdf674f937bd6d1c08c6272ae" translate="yes" xml:space="preserve">
          <source>In the following recipe, we are going to look at how to set up server-side rendering. We'll use the simplistic &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter app&lt;/a&gt; as a guide and show how the server can render state ahead of time based on the request.</source>
          <target state="translated">次のレシピでは、サーバー側レンダリングの設定方法を見ていきます。単純な&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counterアプリ&lt;/a&gt;をガイドとして使用し、サーバーがリクエストに基づいて事前に状態をレンダリングする方法を示します。</target>
        </trans-unit>
        <trans-unit id="c5cd11df4343550d7d4e43af17f049e566352685" translate="yes" xml:space="preserve">
          <source>In the previous sections, we defined the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; that represent the facts about &amp;ldquo;what happened&amp;rdquo; and the &lt;a href=&quot;reducers&quot;&gt;reducers&lt;/a&gt; that update the state according to those actions.</source>
          <target state="translated">前のセクションでは、「発生したこと」に関する事実を表す&lt;a href=&quot;actions&quot;&gt;アクション&lt;/a&gt;と、それらのアクションに従って状態を更新する&lt;a href=&quot;reducers&quot;&gt;レデューサー&lt;/a&gt;を定義しました。</target>
        </trans-unit>
        <trans-unit id="e93726cac65849e4d12ae302dc65296290899ed8" translate="yes" xml:space="preserve">
          <source>In the second part of this recipe, we will show how to use &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; package that provides this functionality out of the box.</source>
          <target state="translated">このレシピの後半では、この機能をそのまま使える&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;パッケージの使用方法を示します。</target>
        </trans-unit>
        <trans-unit id="faa485784e2157411990893a973a8bd333ffb697" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;state&lt;/code&gt; was specified so it didn't fall back to &lt;code&gt;{}&lt;/code&gt;. It was an object with &lt;code&gt;a&lt;/code&gt; field equal to &lt;code&gt;'horse'&lt;/code&gt;, but without the &lt;code&gt;b&lt;/code&gt; field. This is why the &lt;code&gt;a&lt;/code&gt; reducer received &lt;code&gt;'horse'&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and gladly returned it, but the &lt;code&gt;b&lt;/code&gt; reducer received &lt;code&gt;undefined&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and thus returned &lt;em&gt;its idea&lt;/em&gt; of the default &lt;code&gt;state&lt;/code&gt; (in our example, &lt;code&gt;'wat'&lt;/code&gt;). This is how we get &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; in return.</source>
          <target state="translated">この場合、 &lt;code&gt;state&lt;/code&gt; が指定されたため、 &lt;code&gt;{}&lt;/code&gt; にフォールバックしませんでした。これは、との目的であったに等しいフィールド &lt;code&gt;'horse'&lt;/code&gt; が、なし、 &lt;code&gt;b&lt;/code&gt; フィールド。理由はここにあり減速が受信 &lt;code&gt;'horse'&lt;/code&gt; そのよう &lt;code&gt;state&lt;/code&gt; と喜んでそれを返されたが、 &lt;code&gt;b&lt;/code&gt; 減速が受信 &lt;code&gt;undefined&lt;/code&gt; そのよう &lt;code&gt;state&lt;/code&gt; ので、返された&lt;em&gt;そのアイデア&lt;/em&gt;デフォルトの &lt;code&gt;state&lt;/code&gt; （この例では、 &lt;code&gt;'wat'&lt;/code&gt; ）。これが &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; を返す方法です。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f092b4bf36ca89a0195ff54516fa10e82e7e403d" translate="yes" xml:space="preserve">
          <source>In this code, there are two interesting parts:</source>
          <target state="translated">このコードでは、面白い部分が2つあります。</target>
        </trans-unit>
        <trans-unit id="71ff63357cd40c92d16604f3aa798bf1944dff1e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are both top-level keys in the state, and each represents a &quot;slice&quot; of data for some particular concept.</source>
          <target state="translated">この例では、 &lt;code&gt;todos&lt;/code&gt; と &lt;code&gt;visibilityFilter&lt;/code&gt; はどちらも状態の最上位のキーであり、それぞれが特定の概念のデータの「スライス」を表します。</target>
        </trans-unit>
        <trans-unit id="76b5dc7b5ea1bc39335dc8d9e264ade04c2338c5" translate="yes" xml:space="preserve">
          <source>In this example, we store the received items together with the pagination information. However, this approach won't work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.</source>
          <target state="translated">この例では、受信したアイテムをページ付け情報とともに保存します。しかし、ネストされたエンティティが互いに参照しあっている場合や、ユーザにアイテムを編集させる場合には、このアプローチはうまく機能しません。ユーザーが取得した投稿を編集したいが、この投稿は状態ツリーの複数の場所で重複していると想像してみてください。これは実装するのが非常に面倒です。</target>
        </trans-unit>
        <trans-unit id="d38453f2982934a0e4a9ceb3c56a5bc2171aeeca" translate="yes" xml:space="preserve">
          <source>In this guide, we will build a different, asynchronous application. It will use the Reddit API to show the current headlines for a selected subreddit. How does asynchronicity fit into Redux flow?</source>
          <target state="translated">このガイドでは、別の非同期アプリケーションを構築します。これはReddit APIを使って、選択したサブRedditの現在のヘッドラインを表示します。非同期性はReduxのフローにどのように適合するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6560c487884e558589c10deb770162dd33a72a4b" translate="yes" xml:space="preserve">
          <source>In this guide, we won't normalize entities, but it's something you should consider for a more dynamic application.</source>
          <target state="translated">このガイドでは、エンティティの正規化は行いませんが、よりダイナミックなアプリケーションのために考慮すべきことです。</target>
        </trans-unit>
        <trans-unit id="5a84d91992fe1ee4ade8af66d135912f74026aac" translate="yes" xml:space="preserve">
          <source>In this guide, we'll walk through the process of creating a simple Todo app.</source>
          <target state="translated">このガイドでは、シンプルな Todo アプリを作成するプロセスを順を追って説明します。</target>
        </trans-unit>
        <trans-unit id="7a3264d98279777fdf4abb2ddc1f6f9425eb13ec" translate="yes" xml:space="preserve">
          <source>In this part of the recipe, you will learn how to make the &lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todo List example&lt;/a&gt; undoable. You can find the full source of this recipe in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;&lt;code&gt;todos-with-undo&lt;/code&gt; example that comes with Redux&lt;/a&gt;.</source>
          <target state="translated">レシピのこの部分では、&lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todoリストの例を&lt;/a&gt;取り消し可能にする方法を学びます。このレシピの完全なソース&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;は、Reduxに付属の&lt;/a&gt; &lt;code&gt;todos-with-undo&lt;/code&gt; の例にあります。</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="de155c1609b33aab2a421d885b10f58302427667" translate="yes" xml:space="preserve">
          <source>Initial Reducer</source>
          <target state="translated">イニシャルレデューサ</target>
        </trans-unit>
        <trans-unit id="13ff8f213c0a10779a370cddf8f0fc33be27fbc0" translate="yes" xml:space="preserve">
          <source>Initializing State</source>
          <target state="translated">初期化状態</target>
        </trans-unit>
        <trans-unit id="a5ff420ada3c0a5605a30920772184b34ab3a629" translate="yes" xml:space="preserve">
          <source>Inject Initial Component HTML and State</source>
          <target state="translated">初期コンポーネントのHTMLと状態を注入する</target>
        </trans-unit>
        <trans-unit id="3d86177949674f0d3d6f94fa38a597fbce828a69" translate="yes" xml:space="preserve">
          <source>Insert the &lt;code&gt;present&lt;/code&gt; at the end of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;past&lt;/code&gt; の最後に &lt;code&gt;present&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="bcab0294df72cd75ef5a6d54589ea4dce06c352f" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;beginning&lt;/em&gt; of the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; &lt;em&gt;初め&lt;/em&gt;に古い &lt;code&gt;present&lt;/code&gt; 状態を挿入します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1ec847a17c9bdb6126cb0938660b383ecf56d95" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;end&lt;/em&gt; of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;past&lt;/code&gt; &lt;em&gt;終わり&lt;/em&gt;に古い &lt;code&gt;present&lt;/code&gt; 状態を挿入します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d83e33670ddd1909319192f3e6c17aaca9a84645" translate="yes" xml:space="preserve">
          <source>Inserting and Removing Items in Arrays</source>
          <target state="translated">配列内の項目の挿入と削除</target>
        </trans-unit>
        <trans-unit id="b0907ce47d7d9097da0f4a803702823b572700f6" translate="yes" xml:space="preserve">
          <source>Install Packages</source>
          <target state="translated">パッケージのインストール</target>
        </trans-unit>
        <trans-unit id="6a3270b4b51ff970f769df9e395c358dbef395d0" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt; , and inspect your Immutable.JS data without seeing the noise of Immutable.JS's own object properties.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt;をインストールし、Immutable.JS自体のオブジェクトプロパティのノイズを確認せずにImmutable.JSデータを検査します。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="a2b7d6ff7d322426c52bf0336937cb1f5f83cc7e" translate="yes" xml:space="preserve">
          <source>Installing React Redux</source>
          <target state="translated">React Reduxのインストール</target>
        </trans-unit>
        <trans-unit id="919e9c6771a9e147109378578b2ca429689f31e8" translate="yes" xml:space="preserve">
          <source>Installing React Router</source>
          <target state="translated">Reactルータのインストール</target>
        </trans-unit>
        <trans-unit id="d01c0e156f524f6033babf6a65fdfe5fbe227c04" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt;, we could write &lt;code&gt;applyMiddleware()&lt;/code&gt; that first obtains the final, fully wrapped &lt;code&gt;dispatch()&lt;/code&gt; function, and returns a copy of the store using it:</source>
          <target state="translated">&lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt; の代わりに、最後に完全にラップ &lt;code&gt;dispatch()&lt;/code&gt; れたdispatch（）関数を最初に取得し、それを使用してストアのコピーを返す &lt;code&gt;applyMiddleware()&lt;/code&gt; を作成できます。</target>
        </trans-unit>
        <trans-unit id="19d59912d07b0c1523625f9aa8c4564aa281316e" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called &lt;em&gt;actions&lt;/em&gt;. Then you write a special function called a &lt;em&gt;reducer&lt;/em&gt; to decide how every action transforms the entire application's state.</source>
          <target state="translated">状態を直接変更するのではなく、&lt;em&gt;action&lt;/em&gt;と呼ばれるプレーンオブジェクトで発生させたい変更を指定します。次に、&lt;em&gt;レデューサー&lt;/em&gt;と呼ばれる特別な関数を記述して、すべてのアクションがアプリケーション全体の状態をどのように変換するかを決定します。</target>
        </trans-unit>
        <trans-unit id="7cc634e20909b40b70243f5387f4971fcef12462" translate="yes" xml:space="preserve">
          <source>Instead, to actually initiate a dispatch, pass the result to the &lt;code&gt;dispatch()&lt;/code&gt; function:</source>
          <target state="translated">代わりに、実際にディスパッチを開始するには、結果を &lt;code&gt;dispatch()&lt;/code&gt; 関数に渡します。</target>
        </trans-unit>
        <trans-unit id="d8b4700d865a6bc3050b6238ea39ea11326ddf5b" translate="yes" xml:space="preserve">
          <source>Integrating Data with React Native</source>
          <target state="translated">React Nativeでデータを統合する</target>
        </trans-unit>
        <trans-unit id="e94ff5f5157ce93e1e54097b202ed106931426a0" translate="yes" xml:space="preserve">
          <source>Internally, it uses &lt;a href=&quot;https://github.com/github/fetch&quot;&gt;&lt;code&gt;whatwg-fetch&lt;/code&gt; polyfill&lt;/a&gt; on the client, and &lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt;&lt;code&gt;node-fetch&lt;/code&gt;&lt;/a&gt; on the server, so you won't need to change API calls if you change your app to be &lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;universal&lt;/a&gt;.</source>
          <target state="translated">内部&lt;a href=&quot;https://github.com/github/fetch&quot;&gt;的&lt;/a&gt;には、クライアントではwhatwg &lt;code&gt;whatwg-fetch&lt;/code&gt; ポリフィルを使用し、サーバーでは&lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt; &lt;code&gt;node-fetch&lt;/code&gt; &lt;/a&gt;を使用するため、アプリを&lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;ユニバーサルに&lt;/a&gt;変更する場合にAPI呼び出しを変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8a6f1a995da229b02edaf632a5ace565c8ee09ce" translate="yes" xml:space="preserve">
          <source>Introduction to Immutable.js and Functional Programming Concepts</source>
          <target state="translated">Immutable.jsと関数型プログラミングの概念入門</target>
        </trans-unit>
        <trans-unit id="07b5b8bcb22926ae89618f485d25977d251671eb" translate="yes" xml:space="preserve">
          <source>Introduction: Examples</source>
          <target state="translated">はじめに 事例紹介</target>
        </trans-unit>
        <trans-unit id="4209082024c9cd9683fea7a0702e849132c096c7" translate="yes" xml:space="preserve">
          <source>Introduction: Motivation</source>
          <target state="translated">はじめに モチベーション</target>
        </trans-unit>
        <trans-unit id="7833c7c1e348dea95d2da014ccfe35f763549815" translate="yes" xml:space="preserve">
          <source>Invoke callbacks from props</source>
          <target state="translated">小道具からコールバックを呼び出す</target>
        </trans-unit>
        <trans-unit id="7b224be093f507de08ead59d030ff9b7f95ab8d1" translate="yes" xml:space="preserve">
          <source>Is Immutable.JS worth the effort?</source>
          <target state="translated">Immutable.JSは努力する価値がありますか?</target>
        </trans-unit>
        <trans-unit id="da302071395dfdf468568428a985f282b79b0804" translate="yes" xml:space="preserve">
          <source>Is Using Immutable.JS worth the effort?</source>
          <target state="translated">Immutable.JSを使う価値はありますか?</target>
        </trans-unit>
        <trans-unit id="03b995ff411e93b919b4cdc03f6d0002c9968e7f" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; in a middleware function?</source>
          <target state="translated">ストアエンハンサーに複数のミドルウェアチェーンを含めることはできますか？ミドルウェア機能での &lt;code&gt;next&lt;/code&gt; と &lt;code&gt;dispatch&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="f5a28ea665464bd96297075646b171f933e455eb" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</source>
          <target state="translated">ストアエンハンサーに複数のミドルウェアチェーンがあっても大丈夫ですか?ミドルウェア関数のnextとdispatchの違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="c9383cd73080d3bf5501f85e4702d23a4e04ad13" translate="yes" xml:space="preserve">
          <source>Is the same data being used to drive multiple components?</source>
          <target state="translated">同じデータで複数の部品を駆動しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="da4741570a3bb3f7779f15075dab9fd931487a3a" translate="yes" xml:space="preserve">
          <source>Is there a way to make it easier to comprehend? It seems like &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating &lt;code&gt;todos&lt;/code&gt; into a separate function:</source>
          <target state="translated">理解しやすくする方法はありますか？ &lt;code&gt;todos&lt;/code&gt; と &lt;code&gt;visibilityFilter&lt;/code&gt; は完全に独立して更新されるようです。時々、状態フィールドは互いに依存していて、より多くの考慮が必要ですが、この場合、更新 &lt;code&gt;todos&lt;/code&gt; を別の関数に簡単に分割できます。</target>
        </trans-unit>
        <trans-unit id="c7e83fd15d92fbc9418b683c0d9790a7c6248751" translate="yes" xml:space="preserve">
          <source>Is there always a one-to-one mapping between reducers and actions?</source>
          <target state="translated">レデューサとアクションの間には、常に一対一のマッピングが存在するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="84984bdef5380f48f6df27ee47064798ca74e062" translate="yes" xml:space="preserve">
          <source>Is there anything left to undo or redo?</source>
          <target state="translated">元に戻したりやり直したりすることは残っているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="translated">この状態を特定の時点に復元できることに価値がありますか?</target>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="translated">Reduxのサブアプリを分離する</target>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="translated">サブアプリの分離</target>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="translated">Reduxアプリをより大きなアプリケーションのコンポーネントとして分離し、その場合はルートコンポーネントのインスタンスごとにストアを作成したいかもしれません。</target>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="translated">ルート状態オブジェクトへの参照と、 &lt;code&gt;mapStateToProps&lt;/code&gt; 関数から返されるpropsオブジェクトの&lt;em&gt;各値&lt;/em&gt;への参照を保持することで、変更を検出します。</target>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next(action)&lt;/code&gt; ではなくミドルウェアから &lt;code&gt;store.dispatch(action)&lt;/code&gt; を呼び出す場合、アクションが実際に現在のミドルウェアを含むミドルウェアチェーン全体を再び移動することを確認するために、少し注意が必要です。これは、&lt;a href=&quot;asyncactions&quot;&gt;以前に&lt;/a&gt;見たように、非同期ミドルウェアに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="translated">ビルドシステムやビューフレームワークを必要とせず、ES5 で使用される生の Redux API を表示するために存在します。</target>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="translated">この例のように、propsオブジェクトは実際にはプロップ名とその値(または値を取得したり生成したりするために使用されるセレクタ関数)のハッシュであるため、このようになります。</target>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="translated">これは、オブジェクト内の各値に対して個別に浅い平等性チェックを実行することで行われ、それらのチェックの1つが失敗した場合にのみ再レンダリングをトリガします。</target>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="translated">アクションクリエーターはアクションを&lt;em&gt;返す&lt;/em&gt;関数にすぎないため、機能しません。実際に発送するのはあなた次第です。サーバー上でレンダリングするアプリは、リクエストごとに個別のReduxストアを必要とするため、定義中にアクション作成者を特定のStoreインスタンスにバインドすることはできません。</target>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="translated">すべてのアクションタイプが一箇所に集められているので、名前の一貫性を保つのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="translated">一貫して動作し、さまざまな環境（クライアント、サーバー、ネイティブ）で実行され、テストが容易なアプリケーションを作成するのに役立ちます。その上、&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;ライブコード編集とタイムトラベリングデバッガーの組み合わせ&lt;/a&gt;など、優れた開発者エクスペリエンスを提供します。</target>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="translated">アクションには、レデューサー（またはStores in Flux）がアクションを識別するのに役立つ定数タイプがあるというのが一般的な慣例です。文字列はシリアライズ可能であるため、アクションタイプには&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;シンボル&lt;/a&gt;ではなく文字列を使用することをお勧めします。また、シンボルを使用すると、記録と再生を必要以上に難しくします。</target>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">これは低レベルのAPIです。ほとんどの場合、直接使用する代わりに、React（またはその他の）バインディングを使用します。通常、コールバックをフックとして使用して状態の変化に対応する場合は&lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;、カスタムの &lt;code&gt;observeStore&lt;/code&gt; ユーティリティ&lt;/a&gt;を作成することをお勧めします。 &lt;code&gt;Store&lt;/code&gt; また、ある&lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;あなたができるので、 &lt;code&gt;subscribe&lt;/code&gt; のようなライブラリとの変化に&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="translated">また、同じ手順でReduxからこれらのライブラリのいずれかに逆の手順で移行することも可能です。</target>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="translated">また、トップレベルの歴史を1つにするかどうかは、私たち次第です。</target>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="translated">これは高度なAPIです。アプリがコード分割を実装していて、レデューサの一部を動的にロードしたい場合に必要になるかもしれません。また、Redux のホットリロード機構を実装する場合にも必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="translated">アクションをディスパッチする場所にアクションオブジェクトをインラインで作成するのではなく、アクションオブジェクトを生成する関数を作成するというのも一般的な慣習です。</target>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">ストアのレデューサーが最後に返した値と同じです。</target>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="translated">ミドルウェアのチェーン化には欠かせない!</target>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="translated">プレーンなシリアル化可能なオブジェクト、配列、およびプリミティブのみをストアに配置することを強くお勧めします。シリアル化不可能なアイテムをストアに挿入することは&lt;em&gt;技術的には&lt;/em&gt;可能ですが、そうすると、ストアのコンテンツを保持および再水和する機能が損なわれ、時間旅行のデバッグが妨げられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="translated">&lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; または &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt; から分離することが重要です。それらが次々に発生する可能性がありますが、アプリがより複雑になるにつれて、ユーザーアクションとは無関係に一部のデータをフェッチする必要がある場合があります（たとえば、最も人気のあるサブレディットをプリフェッチしたり、古くなったデータをときどき更新したりします）。ルートの変更に応じてフェッチすることもできます。そのため、フェッチを特定のUIイベントに早い段階で組み合わせることは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="translated">これらの質問に答えるために、私たちの状態の形を変えるべきだと提案するのは妥当なことです。</target>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="translated">Reduxから渡された &lt;code&gt;state&lt;/code&gt; または &lt;code&gt;action&lt;/code&gt; を変更するのは魅力的です。これを行わないでください！</target>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="translated">ちっちゃい(2kB、依存関係も含めて)。</target>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="translated">プロジェクトの規約を選択するのはあなた次第です。最初はインライン文字列を使って、後から定数に移行して、後から一つのファイルにまとめるかもしれません。Reduxはここでは何の意見も持っていませんので、最善の判断をしてください。</target>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="translated">状態のフォーマットを選択するのはあなた次第です。プレーンオブジェクトまたは&lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;などを使用できます。よくわからない場合は、単純なオブジェクトから始めてください。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
