<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="3b52d24461e93aad361aa8a10329f3c23cc49031" translate="yes" xml:space="preserve">
          <source>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what&amp;rsquo;s currently available for Vue templates.</source>
          <target state="translated">JSXのツールサポート（リンティング、型チェック、エディターのオートコンプリートなど）は、Vueテンプレートで現在利用できるものよりも少し高度です。</target>
        </trans-unit>
        <trans-unit id="da2a622928cb7fb2119351d71d4d29385b2f0b02" translate="yes" xml:space="preserve">
          <source>The tree of DOM nodes for the HTML above looks like this:</source>
          <target state="translated">上記のHTML DOMノードのツリーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1e0938b17616f7c664547dd22e0644ffdf02a08b" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;keyCode&lt;/code&gt; events &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;is deprecated&lt;/a&gt; and may not be supported in new browsers.</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; イベント&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;は非推奨&lt;/a&gt;であり、新しいブラウザーではサポートされない場合があります。</target>
        </trans-unit>
        <trans-unit id="c973f4080ca50bd81b6cff2d0a6ded9905288da4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;slot-scope&lt;/code&gt; can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;) you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; in the expression, like so:</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; の値は、関数定義の引数位置に表示される有効なJavaScript式を受け入れることができます。 つまり、サポートされている環境（ &lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;最新のブラウザー&lt;/a&gt; ）では、次のように、式で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015構造化&lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="44c95331b851049a94d5aa5d023b6e2ddaca60d8" translate="yes" xml:space="preserve">
          <source>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</source>
          <target state="translated">回避策は、スペースや引用符のない式を使用するか、複雑な式を計算プロパティで置き換えることです。</target>
        </trans-unit>
        <trans-unit id="d02680275f323eda2de9d2d7078001372e594964" translate="yes" xml:space="preserve">
          <source>Their names often include the name of an element they wrap (e.g. &lt;code&gt;BaseButton&lt;/code&gt;, &lt;code&gt;BaseTable&lt;/code&gt;), unless no element exists for their specific purpose (e.g. &lt;code&gt;BaseIcon&lt;/code&gt;). If you build similar components for a more specific context, they will almost always consume these components (e.g. &lt;code&gt;BaseButton&lt;/code&gt; may be used in &lt;code&gt;ButtonSubmit&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;BaseIcon&lt;/code&gt; 名には、特定の目的の要素（ &lt;code&gt;BaseTable&lt;/code&gt; など）がない限り、多くの場合、ラッピング要素の名前（ &lt;code&gt;BaseButton&lt;/code&gt; 、 BaseTableなど）が含まれます。 より具体的なコンテキスト用に類似のコンポーネントを構築する場合、それらはほとんど常にこれらのコンポーネントを消費します（たとえば、 &lt;code&gt;ButtonSubmit&lt;/code&gt; は &lt;code&gt;BaseButton&lt;/code&gt; を使用する場合があります ）。</target>
        </trans-unit>
        <trans-unit id="cac8885ec5589429c1668b6076e0b655b65a0072" translate="yes" xml:space="preserve">
          <source>Then a &lt;code&gt;tree-folder-contents&lt;/code&gt; component with this template:</source>
          <target state="translated">次に、このテンプレートを使用する &lt;code&gt;tree-folder-contents&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="12ff53d6c9683fe8bc4c3c3ebe06eaf2daa8b2b3" translate="yes" xml:space="preserve">
          <source>Then add some classes when using it:</source>
          <target state="translated">次に、使用するクラスをいくつか追加します。</target>
        </trans-unit>
        <trans-unit id="bdb3d0b6c8743a01fad092b8628997433e226d02" translate="yes" xml:space="preserve">
          <source>Then changes to &lt;code&gt;b&lt;/code&gt; will not trigger any view updates. If you know you&amp;rsquo;ll need a property later, but it starts out empty or non-existent, you&amp;rsquo;ll need to set some initial value. For example:</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; への後続の変更は、ビューの更新をトリガーしません。 後でプロパティが必要であることがわかっているが、空または存在しない場合は、初期値を設定する必要があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="d716ba19ef13983399aba7a4f9b4f99bdb1a5cc3" translate="yes" xml:space="preserve">
          <source>Then define the components you&amp;rsquo;d like to use in a &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="translated">次に、 &lt;code&gt;components&lt;/code&gt; オプションで使用するコンポーネントを定義します。</target>
        </trans-unit>
        <trans-unit id="89b993f413d7a3516733e84da6538330a9b561e6" translate="yes" xml:space="preserve">
          <source>Then import the component options along with Vue, and you can make many common assertions (here we are using Jasmine/Jest style &lt;code&gt;expect&lt;/code&gt; assertions just as an example):</source>
          <target state="translated">次に、Vueでコンポーネントオプションをインポートすることにより、多くの一般的なアサーションを作成できます（ここでは例としてJasmine / Jestスタイルのアサーションを使用します）。</target>
        </trans-unit>
        <trans-unit id="742a07eca2247a701f3fe69d736358f9945a7047" translate="yes" xml:space="preserve">
          <source>Then in a template, you can use the new &lt;code&gt;v-focus&lt;/code&gt; attribute on any element, like this:</source>
          <target state="translated">次に、テンプレートで、次のように任意の要素で新しい &lt;code&gt;v-focus&lt;/code&gt; 属性を使用できます。</target>
        </trans-unit>
        <trans-unit id="d651621f023beec6364c642e7684b35f30f1b1df" translate="yes" xml:space="preserve">
          <source>Then in any descendants, we can use the &lt;code&gt;inject&lt;/code&gt; option to receive specific properties we&amp;rsquo;d like to add to that instance:</source>
          <target state="translated">その後、任意の子孫で、 &lt;code&gt;inject&lt;/code&gt; オプションを使用して特定のプロパティを受け取り、そのインスタンスに追加できます。</target>
        </trans-unit>
        <trans-unit id="07a1a769eabe4ce95fd548704bfe1a9036dff3fe" translate="yes" xml:space="preserve">
          <source>Then in our components, we can use &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; to emit events, listen for events, and clean up event listeners, respectively:</source>
          <target state="translated">その後、コンポーネントは、それぞれ &lt;code&gt;$emit&lt;/code&gt; 、 &lt;code&gt;$on&lt;/code&gt; 、および &lt;code&gt;$off&lt;/code&gt; を使用して 、イベントを発生させ、イベントをリッスンし、イベントリスナーをクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="e5a24c495cff3ba785929f2d1f1232971575aecc" translate="yes" xml:space="preserve">
          <source>Then in the template for &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;, you might have:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; のテンプレートは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="06c17e2b180b30e57b025d1baba4010bf150e5ff" translate="yes" xml:space="preserve">
          <source>Then inside &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; you might find yourself reaching for a hack like this:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 内で 、次のようなハックにアクセスします。</target>
        </trans-unit>
        <trans-unit id="6cb73bd95447c7f774f020d38dc4e977b5d7f966" translate="yes" xml:space="preserve">
          <source>Then switching the &lt;code&gt;loginType&lt;/code&gt; in the code above will not erase what the user has already entered. Since both templates use the same elements, the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; is not replaced - just its &lt;code&gt;placeholder&lt;/code&gt;.</source>
          <target state="translated">次に、上記のコードで &lt;code&gt;loginType&lt;/code&gt; を切り替えても、ユーザーが既に入力したコンテンツは消去されません。 両方のテンプレートが同じ要素を使用するため、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; は置き換えられず、 &lt;code&gt;placeholder&lt;/code&gt; のみが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="6afded1525a7e22ff2f90a6400204ea03039f331" translate="yes" xml:space="preserve">
          <source>Then the child component can emit an event on itself by calling the built-in &lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; method&lt;/a&gt;, passing the name of the event:</source>
          <target state="translated">その後、組み込みの&lt;strong&gt;$ emit&lt;/strong&gt;メソッドを呼び出してイベントの名前を渡すことにより、子コンポーネント自体でイベントを&lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt; &lt;code&gt;$emit&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="fa6a05a02bb2743e63986fe5978b02e07581ae91" translate="yes" xml:space="preserve">
          <source>Then the parent can listen to that event and update a local data property, if it wants to. For example:</source>
          <target state="translated">その後、親はイベントをリッスンし、必要に応じてローカルデータプロパティを更新できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="6a4b4fbfbeb2382afaa428f3aa7171b1ee657214" translate="yes" xml:space="preserve">
          <source>Then the provided content will be rendered instead:</source>
          <target state="translated">次に、提供されたコンテンツが代わりにレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="894b33adf4423b8e17178e298c582eff7b692b2f" translate="yes" xml:space="preserve">
          <source>Then the value will be passed as the first parameter of that method:</source>
          <target state="translated">次に、メソッドの最初のパラメーターとして値が渡されます。</target>
        </trans-unit>
        <trans-unit id="e40f0a46552f37df14dd5aec3ff5064babdeaea5" translate="yes" xml:space="preserve">
          <source>Then want to render a component for each one:</source>
          <target state="translated">次に、各コンポーネントをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="e77b5195b094315391d1471e49e775352de3ff46" translate="yes" xml:space="preserve">
          <source>Then when later accessing this property on a route, you will still go through meta. For example:</source>
          <target state="translated">後でルートでこのプロパティにアクセスすると、メタを通過します。 例えば：</target>
        </trans-unit>
        <trans-unit id="db6fb96dd889a51b383d80ca6045c8aa43c69291" translate="yes" xml:space="preserve">
          <source>Then when we listen to the event in the parent, we can access the emitted event&amp;rsquo;s value with &lt;code&gt;$event&lt;/code&gt;:</source>
          <target state="translated">次に、親でイベントをリッスンすると、発生したイベントの値に &lt;code&gt;$event&lt;/code&gt; アクセスできます。</target>
        </trans-unit>
        <trans-unit id="eb930daa712d8e2eb8fe97e59c6f27531e9b1c3e" translate="yes" xml:space="preserve">
          <source>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.</source>
          <target state="translated">その後、罪悪感やパフォーマンスの問題を心配することなく、Vueコードの記述を開始し、小さなバージョンを本番環境に出荷できます。</target>
        </trans-unit>
        <trans-unit id="ebf3c9e7f553f2151cca31494ec2e2f25d6a17ab" translate="yes" xml:space="preserve">
          <source>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</source>
          <target state="translated">次に、アルファベット順に並べ替えます。 DOMを更新するとき、Vueはレンダリングを最適化し、DOM変換を可能な限り安価に実行します。 つまり、最初のtodo要素を削除してから、リストの最後に追加します。</target>
        </trans-unit>
        <trans-unit id="60891cf748e8a5cfa058d96629753adac1a276a6" translate="yes" xml:space="preserve">
          <source>Then you would now update it to:</source>
          <target state="translated">次に、次のように更新します。</target>
        </trans-unit>
        <trans-unit id="29dfab044dfc1294ff91b939dd91ab9260db5d9f" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll need to import each component you&amp;rsquo;d like to use, before you locally register it. For example, in a hypothetical &lt;code&gt;ComponentB.js&lt;/code&gt; or &lt;code&gt;ComponentB.vue&lt;/code&gt; file:</source>
          <target state="translated">次に、ローカルに登録する前に、使用する各コンポーネントをインポートする必要があります。 たとえば、架空の &lt;code&gt;ComponentB.js&lt;/code&gt; または &lt;code&gt;ComponentB.vue&lt;/code&gt; ファイルの場合：</target>
        </trans-unit>
        <trans-unit id="4a02df39977359aa3a054dc03aa4a5ab9829f85e" translate="yes" xml:space="preserve">
          <source>There also seem to be philosophical differences in the API design which if you&amp;rsquo;re curious, can be demonstrated by how each handles the creation of a &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;simple todo list&lt;/a&gt;. It&amp;rsquo;s definitely somewhat subjective, but many consider Vue&amp;rsquo;s API to be less complex and better structured.</source>
          <target state="translated">また、API設計には哲学的な違いがあるようです。 好奇心が強い場合は、それぞれが単純なtodoリストの作成をどのように処理するかを示すことができます。 確かに、ある程度主観的には、多くの人がVue APIをそれほど複雑でなく構造化されていると考えています。</target>
        </trans-unit>
        <trans-unit id="00ee1410ff14873dae0595e837c501a60becd79c" translate="yes" xml:space="preserve">
          <source>There are a few advantages:</source>
          <target state="translated">いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="a278039d12ee8bace65331079237ab972774e0f6" translate="yes" xml:space="preserve">
          <source>There are also a few array-related caveats, which were discussed earlier in the &lt;a href=&quot;list#Caveats&quot;&gt;list rendering section&lt;/a&gt;.</source>
          <target state="translated">アレイ関連の考慮事項もいくつかあります。 これらについては&lt;a href=&quot;list#Caveats&quot;&gt;、&lt;/a&gt;リストのレンダリングに関するセクションで説明しています。</target>
        </trans-unit>
        <trans-unit id="8355a914d86b23056657ff75f59f4f4811dbbe1e" translate="yes" xml:space="preserve">
          <source>There are also other hooks which will be called at different stages of the instance&amp;rsquo;s lifecycle, such as &lt;a href=&quot;../api/index#mounted&quot;&gt;&lt;code&gt;mounted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#updated&quot;&gt;&lt;code&gt;updated&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt;. All lifecycle hooks are called with their &lt;code&gt;this&lt;/code&gt; context pointing to the Vue instance invoking it.</source>
          <target state="translated">インスタンスのライフサイクルのさまざまな段階で呼び出されるフックもあります（たとえば、 &lt;a href=&quot;../api/index#mounted&quot;&gt; &lt;code&gt;mounted&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;../api/index#updated&quot;&gt; &lt;code&gt;updated&lt;/code&gt; &lt;/a&gt; 、destroy）。 すべてのライフサイクルフックは、呼び出し元のVueインスタンスを指す &lt;code&gt;this&lt;/code&gt; コンテキストで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="595e87e7a707cb9f54dea4bd06abe43f491c5b96" translate="yes" xml:space="preserve">
          <source>There are cases however, particularly shared component libraries, when this &lt;em&gt;might&lt;/em&gt; be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</source>
          <target state="translated">ただし、共有コンポーネントライブラリが特に適切な場合があります。 たとえば、次の架空のGoogleマップコンポーネントなど、HTMLをレンダリングする代わりにJavaScript APIと対話する抽象コンポーネント。</target>
        </trans-unit>
        <trans-unit id="3876196be292a6f75aaef350c2cf3fa6064ad6ee" translate="yes" xml:space="preserve">
          <source>There are cases when it&amp;rsquo;s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">コンテンツが提供されない場合にのみレンダリングされるように、スロットフォールバック（またはデフォルト）コンテンツを指定すると便利な場合があります。 たとえば、 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; コンポーネントの場合：</target>
        </trans-unit>
        <trans-unit id="b097d3f1a1272b7a886d701f8e65981ad1d92968" translate="yes" xml:space="preserve">
          <source>There are quite a few other directives, each with its own special functionality. For example, the &lt;code&gt;v-for&lt;/code&gt; directive can be used for displaying a list of items using the data from an Array:</source>
          <target state="translated">他にも多くのディレクティブがあり、それぞれに特別な機能があります。 たとえば、 &lt;code&gt;v-for&lt;/code&gt; ディレクティブを使用して、配列のデータを使用してアイテムのリストを表示できます。</target>
        </trans-unit>
        <trans-unit id="301d312bbcc93ad24cc77d82516195cad4b40d9a" translate="yes" xml:space="preserve">
          <source>There are six classes applied for enter/leave transitions.</source>
          <target state="translated">Enter / Leaveトランジションには6つのクラスが適用されます。</target>
        </trans-unit>
        <trans-unit id="68ec2c8ded7b22cd2bc4c88259f22e650546ce9b" translate="yes" xml:space="preserve">
          <source>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the &lt;code&gt;data&lt;/code&gt; object is like the schema for your component&amp;rsquo;s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</source>
          <target state="translated">この制限の背後には技術的な理由があります-依存関係追跡システムのエッジケースクラスを排除し、Vueインスタンスを型チェックシステムでより適切に動作させます。 ただし、コードの保守性に関して重要な考慮事項があります。 &lt;code&gt;data&lt;/code&gt; オブジェクトは、コンポーネントの状態のスキーマのようなものです。 すべてのリアクティブプロパティを事前宣言すると、後でコンポーネントコードを理解したり、別の開発者がそれを読んだりしやすくなります。</target>
        </trans-unit>
        <trans-unit id="db30e092cad90bed9c249d97be67dad62ff063c2" translate="yes" xml:space="preserve">
          <source>There are times when it&amp;rsquo;s useful to have multiple slots. For example, in a &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">複数のスロットがあると便利です。 たとえば、次のテンプレートを使用する &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="d66a662b2b692933bc8923306e3e5688421626cb" translate="yes" xml:space="preserve">
          <source>There are two common cases where this can be tempting:</source>
          <target state="translated">これが魅力的な2つの一般的なケースがあります。</target>
        </trans-unit>
        <trans-unit id="4be534cacf73464a26b8c69ecc68abf4cebc095f" translate="yes" xml:space="preserve">
          <source>There are usually two cases where it&amp;rsquo;s tempting to mutate a prop:</source>
          <target state="translated">プロップを変更したい場合は2つの一般的なケースがあります。</target>
        </trans-unit>
        <trans-unit id="9a46df346eecefc8c5696a405d0623a7868c6f68" translate="yes" xml:space="preserve">
          <source>There can still be one unnamed slot, which is the &lt;strong&gt;default slot&lt;/strong&gt; that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</source>
          <target state="translated">名前のないスロットが1つ残っている場合があります。 これは、一致しないコンテンツのキャッチオールとして機能する&lt;strong&gt;デフォルトのスロットです&lt;/strong&gt; 。 上記の両方の例で、レンダリングされたHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="892e9605b3eb99a1e8758152c0f0d14bd50018ba" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;vm.$nextTick()&lt;/code&gt; instance method, which is especially handy inside components, because it doesn&amp;rsquo;t need global &lt;code&gt;Vue&lt;/code&gt; and its callback&amp;rsquo;s &lt;code&gt;this&lt;/code&gt; context will be automatically bound to the current Vue instance:</source>
          <target state="translated">&lt;code&gt;vm.$nextTick()&lt;/code&gt; インスタンスメソッドもあります。 これは、コンポーネントで特に役立ちます。 グローバル &lt;code&gt;Vue&lt;/code&gt; は必要ないため、そのコールバックの &lt;code&gt;this&lt;/code&gt; コンテキストは自動的に現在のVueインスタンスにバインドされます。</target>
        </trans-unit>
        <trans-unit id="e795677faa92646e68896f4fa2d153d1c6b3dad9" translate="yes" xml:space="preserve">
          <source>There is no direct &lt;code&gt;v-model&lt;/code&gt; counterpart in render functions - you will have to implement the logic yourself:</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; の直接レンダリング機能はありません。 ロジックを自分で実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3dc3c28e5738e838da6dece3bd69b468532f5bd" translate="yes" xml:space="preserve">
          <source>There is no longer a special API to initialize an app with Vue Router. That means instead of:</source>
          <target state="translated">Vue Routerでアプリを初期化する特別なAPIはもうありません。 の代わりに：</target>
        </trans-unit>
        <trans-unit id="e786ab8525d61c08d5edd49d36eaafa66121f1c6" translate="yes" xml:space="preserve">
          <source>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the &lt;code&gt;.native&lt;/code&gt; modifier for &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">コンポーネントのルート要素でネイティブイベントを直接リッスンしたい場合があります。 これらの場合、 &lt;code&gt;v-on&lt;/code&gt; に &lt;code&gt;.native&lt;/code&gt; 修飾子を使用できます。</target>
        </trans-unit>
        <trans-unit id="e13a2b6d1fa69f970582ef7c30a8696baaa1caf0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot you can do to help Vue grow in your community:</source>
          <target state="translated">コミュニティでVueを成長させるためにできることはたくさんあります。</target>
        </trans-unit>
        <trans-unit id="c70dcc11c00ce0163cd6cf08b8dae423423a248d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no longer a use case for this in the new Vue Router.</source>
          <target state="translated">新しいVueルーターにはこの使用例はありません。</target>
        </trans-unit>
        <trans-unit id="163f368f2bf083cc1079a14cd05b50989be0cc02" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We&amp;rsquo;ll fix that later.</source>
          <target state="translated">この例には1つの問題があります。 アイテムを追加または削除すると、その周りのアイテムはスムーズに移行するのではなく、すぐに新しい場所にスナップします。 後で修正します。</target>
        </trans-unit>
        <trans-unit id="5d85fbe7675b4e4ec3b50bf7054fe53d2209ebb4" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still one problem though. Try clicking the button below:</source>
          <target state="translated">ただし、まだ1つの問題があります。 下のボタンをクリックしてください。</target>
        </trans-unit>
        <trans-unit id="e6396f41a177bd681652c0e5df217826f32aabe7" translate="yes" xml:space="preserve">
          <source>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;transitioned too&lt;/a&gt;:</source>
          <target state="translated">これらのFLIPアニメーションも、単一の軸に限定されません。 多次元グリッドのアイテムも遷移&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;でき&lt;/a&gt;ます：</target>
        </trans-unit>
        <trans-unit id="101fa3129d0c59027806566e19bcb27a91fd6013" translate="yes" xml:space="preserve">
          <source>These applications always include many in-DOM templates, where &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;kebab-case &lt;strong&gt;must&lt;/strong&gt; be used&lt;/a&gt;.</source>
          <target state="translated">これらのアプリケーションには、常に&lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;ケバブケースを使用する&lt;strong&gt;必要&lt;/strong&gt;&lt;/a&gt;がある多くのDOMテンプレートが含まれています。</target>
        </trans-unit>
        <trans-unit id="79c4f8a294a999f0a432548c8b4a47252ba3a153" translate="yes" xml:space="preserve">
          <source>These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</source>
          <target state="translated">これらは、大規模なテンプレートデモまたは非常に小さなアプリケーションに役立ちますが、テンプレートを残りのコンポーネント定義から分離するため、避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="4eda46855e3962039e549f3d03f1e9beb23fa48b" translate="yes" xml:space="preserve">
          <source>These components are &lt;strong&gt;globally registered&lt;/strong&gt;. That means they can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created after registration. For example:</source>
          <target state="translated">これらのコンポーネントは&lt;strong&gt;グローバルに登録され&lt;/strong&gt;ます。 つまり、登録後に作成されたルートVueインスタンス（ &lt;code&gt;new Vue&lt;/code&gt; ）のテンプレートで使用できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="c11fba5bbbf86f45897e779c4584d6721b0b2522" translate="yes" xml:space="preserve">
          <source>These components lay the foundation for consistent styling and behavior in your application. They may &lt;strong&gt;only&lt;/strong&gt; contain:</source>
          <target state="translated">これらのコンポーネントは、アプリケーションの一貫したスタイリングと動作の基盤となります。 以下&lt;strong&gt;のみを&lt;/strong&gt;含める&lt;strong&gt;こと&lt;/strong&gt;が&lt;strong&gt;でき&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c208483eb8caab5ce32ce55aa9ca8d4751b6d7ab" translate="yes" xml:space="preserve">
          <source>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain &lt;strong&gt;one single expression&lt;/strong&gt;, so the following will &lt;strong&gt;NOT&lt;/strong&gt; work:</source>
          <target state="translated">これらの式は、所有者VueインスタンスのデータスコープでJavaScriptとして評価されます。 制限として、各バインディングには&lt;strong&gt;1つの式&lt;/strong&gt;しか含めることができないため、以下&lt;strong&gt;は機能しません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="894c317239a0c7a65a9e88455fd9ec3ef7ebc237" translate="yes" xml:space="preserve">
          <source>These hooks can be used in combination with CSS transitions/animations or on their own.</source>
          <target state="translated">これらのフックは、CSSトランジション/アニメーションと組み合わせて、または単独で使用できます。</target>
        </trans-unit>
        <trans-unit id="18eb93efc44d56c2080356f2acd2adc1588f6912" translate="yes" xml:space="preserve">
          <source>These limitations become apparent when designing a search indicator, like this one for example:</source>
          <target state="translated">これらの制限は、たとえば次のような検索インジケータを設計するときに明らかになります。</target>
        </trans-unit>
        <trans-unit id="44f058292bf91d7fdc0c19b30d4f231d10c8ffce" translate="yes" xml:space="preserve">
          <source>These modifiers restrict the handler to events triggered by a specific mouse button.</source>
          <target state="translated">これらの修飾子は、特定のマウスボタンによってトリガーされるイベントにハンドラーを制限します。</target>
        </trans-unit>
        <trans-unit id="d2b0e629392045530844771affeff7b43f8ec099" translate="yes" xml:space="preserve">
          <source>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</source>
          <target state="translated">これらのルールは、ほとんどのプロジェクトの可読性と開発者のエクスペリエンスを向上させることがわかっています。 コードに違反しても、コードは実行されますが、違反はまれで正当なものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="91af92ef53fdf34200de7e0b28db35745ed2a1ae" translate="yes" xml:space="preserve">
          <source>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</source>
          <target state="translated">これらのルールはすべて学習され、エラーを防ぐためにすべてのコストが厳守されます。 例外は存在する可能性がありますが、非常にまれであり、JavaScriptとVueの両方の専門知識を持つ者のみが作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e30564da6ab88875780c5728faa3632ae18dc83a" translate="yes" xml:space="preserve">
          <source>These specific languages are only examples. You could as easily use Bubl&amp;eacute;, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with &lt;code&gt;vue-loader&lt;/code&gt;, it also has first-class support for CSS Modules.</source>
          <target state="translated">これらの特定の言語は単なる例です。 Bubl&amp;eacute;、TypeScript、SCSS、PostCSSなど、他の生産性向上プリプロセッサを簡単に使用できます。 Webpackと &lt;code&gt;vue-loader&lt;/code&gt; を使用する場合、CSSモジュールのファーストクラスのサポートもあります。</target>
        </trans-unit>
        <trans-unit id="fdd9827028ef750f7255fe5fc506af18a8fb1368" translate="yes" xml:space="preserve">
          <source>These will override the conventional class names. This is especially useful when you want to combine Vue&amp;rsquo;s transition system with an existing CSS animation library, such as &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;.</source>
          <target state="translated">これらは、従来のクラス名をオーバーライドします。 これは、Vueの移行システムを&lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;などの既存のCSSアニメーションライブラリと組み合わせるときに特に便利です。</target>
        </trans-unit>
        <trans-unit id="a8d1026e768f545462812038bf11ac5597aa461a" translate="yes" xml:space="preserve">
          <source>They document the API of the component, so that it&amp;rsquo;s easy to see how the component is meant to be used.</source>
          <target state="translated">コンポーネントのAPIは文書化されているため、コンポーネントの使用方法を簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="ee9fb3a66c9bf09491269055d05e63e8daff7baf" translate="yes" xml:space="preserve">
          <source>They have slightly different target users however.</source>
          <target state="translated">ただし、対象読者はわずかに異なります。</target>
        </trans-unit>
        <trans-unit id="dddb496772a8230c124e4f06a214f032833805d2" translate="yes" xml:space="preserve">
          <source>They may look a bit different from normal HTML, but &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</source>
          <target state="translated">見た目は通常のHTMLとは少し異なりますが、：および &lt;code&gt;@&lt;/code&gt; は属性名の有効な文字であり、Vueがサポートするすべてのブラウザーで正しく解析できます。 また、最終レンダリングマークアップには表示されません。 省略された構文は完全にオプションですが、使用方法について詳しく知るときに後で理解できます。</target>
        </trans-unit>
        <trans-unit id="6a9f42e561d875ba212a21ce976d18f88707fb7e" translate="yes" xml:space="preserve">
          <source>They&amp;rsquo;re also very useful as wrapper components. For example, when you need to:</source>
          <target state="translated">ラッパーコンポーネントとしても非常に便利です。 たとえば、必要な場合：</target>
        </trans-unit>
        <trans-unit id="36292b3c039d104e965d98c8c9a093ed70eee710" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;prevents conflicts&lt;/a&gt; with existing and future HTML elements, since all HTML elements are a single word.</source>
          <target state="translated">これは、すべてのHTML要素が単一の単語であるため、既存および将来のHTML要素との競合を防ぎます。</target>
        </trans-unit>
        <trans-unit id="1ece11c20b0e27793001fdeec7df491259c0b914" translate="yes" xml:space="preserve">
          <source>This allows us add behavior that a filter alone couldn&amp;rsquo;t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;&lt;code&gt;currencyValidator&lt;/code&gt; object&lt;/a&gt;:</source>
          <target state="translated">これにより、フィルターだけではカプセル化できない動作を追加できます。 たとえば、フォーカスがある入力のコンテンツを選択します。 次のステップは、フィルターからビジネスロジックを抽出することです。 以下で&lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;は&lt;/a&gt; 、すべてを外部 &lt;code&gt;currencyValidator&lt;/code&gt; オブジェクトに引き出します。</target>
        </trans-unit>
        <trans-unit id="74e149b933b7f933e9d6e2560dceac8830da4733" translate="yes" xml:space="preserve">
          <source>This allows you to compose components like this:</source>
          <target state="translated">これにより、次のコンポーネントを構成できます。</target>
        </trans-unit>
        <trans-unit id="2b017e21cf180432f227f352528adf7beedafa7a" translate="yes" xml:space="preserve">
          <source>This also means the following computed property will never update, because &lt;code&gt;Date.now()&lt;/code&gt; is not a reactive dependency:</source>
          <target state="translated">これは、 &lt;code&gt;Date.now()&lt;/code&gt; が事後依存ではないため、次の計算されたプロパティが更新されないことも意味します。</target>
        </trans-unit>
        <trans-unit id="d966b066638dcbfbeb5f7c1fa054b2b9f4ac88e1" translate="yes" xml:space="preserve">
          <source>This attribute does not support dynamic binding.</source>
          <target state="translated">この属性は動的バインディングをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="85db9f37abb47bdae5f9736eb1fa18d771e503d8" translate="yes" xml:space="preserve">
          <source>This brings us full circle back to &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;, so if you&amp;rsquo;ve read this far it&amp;rsquo;s probably time to try it out!</source>
          <target state="translated">これで完全に&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;に戻ったので 、ここまで読んだなら、おそらく試してみる時間です！</target>
        </trans-unit>
        <trans-unit id="e208871e834d455a504dbc7b4789f62b8d51dbdf" translate="yes" xml:space="preserve">
          <source>This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; to manage state in most cases.</source>
          <target state="translated">これは、デモや、いくつかのコンポーネントがある非常に小さなアプリに役立ちます。 ただし、このパターンは中規模または大規模のアプリケーションにうまく対応できないため、ほとんどの場合、 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;を使用して状態を管理することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="f3ae7f80927899cd62140ba3ac91c1a272907e8a" translate="yes" xml:space="preserve">
          <source>This can be especially useful in combination with the &lt;code&gt;$attrs&lt;/code&gt; instance property, which contains the attribute names and values passed to a component, such as:</source>
          <target state="translated">これは、次のようなコンポーネントに渡される属性名と値を含む &lt;code&gt;$attrs&lt;/code&gt; インスタンスプロパティと併用すると特に便利です。</target>
        </trans-unit>
        <trans-unit id="dc35e91b7f0ddcd858a9ed54df8c331d12068bc2" translate="yes" xml:space="preserve">
          <source>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, &lt;code&gt;v-slot&lt;/code&gt; without an argument is assumed to refer to the default slot:</source>
          <target state="translated">これはさらに削減できます。 デフォルトスロットに未指定のコンテンツが想定されているように、引数なしの &lt;code&gt;v-slot&lt;/code&gt; はデフォルトスロットを参照していると想定されます。</target>
        </trans-unit>
        <trans-unit id="e890dd0b9a03e7b18eb3ea7a9ab2b112967c585d" translate="yes" xml:space="preserve">
          <source>This can be useful sometimes, but it&amp;rsquo;s not a good idea when you&amp;rsquo;re trying to listen on a very specific element, like an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. For example, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component above might refactor so that the root element is actually a &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">これは便利な場合もありますが、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; などの非常に具体的な要素をリッスンすることはお勧めできません。 たとえば、上記の &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントは、ルート要素が実際に &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 要素になるようにリファクタリングされる場合があります。</target>
        </trans-unit>
        <trans-unit id="ef2288cfa9c5bb1049786a028d410bf6a81d1c49" translate="yes" xml:space="preserve">
          <source>This can be useful when you&amp;rsquo;ve defined CSS transitions/animations using Vue&amp;rsquo;s transition class conventions and want to switch between them.</source>
          <target state="translated">これは、Vue遷移クラスルールを使用してCSS遷移/アニメーションを定義し、それらを切り替えるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="22ed18f22c3147e4d4b605b99a8c886bf36867ed" translate="yes" xml:space="preserve">
          <source>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. &lt;code&gt;user&lt;/code&gt; to &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">これにより、特にスロットがより多くの小道具を提供する場合、テンプレートがよりきれいになります。 また、小道具の名前を変更するなど、他の可能性を開きます。</target>
        </trans-unit>
        <trans-unit id="91d37bc2f925538550750ba2e9fce0b6e7858848" translate="yes" xml:space="preserve">
          <source>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</source>
          <target state="translated">これは、特定のビューを拡張するためだけにJavaScriptが使用される中小規模のプロジェクトに非常に有効です。 ただし、より複雑なプロジェクトの場合、またはフロントエンドが完全にJavaScriptによって駆動される場合、これらの欠点が明らかになります。</target>
        </trans-unit>
        <trans-unit id="552c6085e6177cea581b90083d77773efb3e8be2" translate="yes" xml:space="preserve">
          <source>This class is mostly useful for specifying the transition timing and easing curve, as you&amp;rsquo;ll see below:</source>
          <target state="translated">このクラスは、以下に示すように、遷移タイミングとイージング曲線を指定するのに最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="a64fb541d6cf03a309471b66f62b3cc4e9df105f" translate="yes" xml:space="preserve">
          <source>This could be rewritten with JavaScript&amp;rsquo;s &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; in a render function:</source>
          <target state="translated">これはJavaScript &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; で書き換えられ、レンダリング関数にマッピングされます。</target>
        </trans-unit>
        <trans-unit id="dc281e6afa265cb93fadcfb1141b35d1dc6b8178" translate="yes" xml:space="preserve">
          <source>This default mode is efficient, but &lt;strong&gt;only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)&lt;/strong&gt;.</source>
          <target state="translated">このデフォルトモードは効率的ですが&lt;strong&gt;、リストレンダリング出力が子コンポーネントの状態または一時的なDOM状態（フォーム入力値など）に依存しない場合にのみ適しています&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="83c6bcc5ab3c17077a142a2b9547158e591eb788" translate="yes" xml:space="preserve">
          <source>This directive triggers transitions when its condition changes.</source>
          <target state="translated">このディレクティブは、条件が変更されたときに遷移をトリガーします。</target>
        </trans-unit>
        <trans-unit id="bcf9f3835622e83dc060967041ab679cca48d307" translate="yes" xml:space="preserve">
          <source>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt;, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</source>
          <target state="translated">このディレクティブは、関連するVueインスタンスがコンパイルを完了するまで要素に残ります。 &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt; などのCSSルールとの組み合わせでは、このディレクティブを使用して、Vueインスタンスの準備ができるまで、コンパイルされていない口ひげバインディングを非表示にできます。</target>
        </trans-unit>
        <trans-unit id="3e343af564058d721599d1f9e8b019d300435ac7" translate="yes" xml:space="preserve">
          <source>This does not mean the component is only used in a single page, but it will only be used once &lt;em&gt;per page&lt;/em&gt;. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it&amp;rsquo;s a good indication that this is actually a reusable component that is only used once per page &lt;em&gt;for now&lt;/em&gt;.</source>
          <target state="translated">これは、コンポーネントが単一のページでのみ使用されることを意味するのではなく、ページ&lt;em&gt;ごとに1&lt;/em&gt;回のみ使用されることを意味します。 これらのコンポーネントは、アプリ内のコンテキストではなくアプリ固有であるため、小道具を受け入れることはありません。 小道具を追加する必要がある場合、これは実際にはページごとに一度だけ使用される再利用可能なコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="045411f2b2e7825926721bc11467177b95eff687" translate="yes" xml:space="preserve">
          <source>This even applies to all subcomponents, meaning all three of these components will also be available &lt;em&gt;inside each other&lt;/em&gt;.</source>
          <target state="translated">これは、すべてのサブコンポーネントにも当てはまります。 これは、3つのコンポーネントすべて&lt;em&gt;が相互に&lt;/em&gt;利用可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="82b2832a220d04d77924bc1b878abfa24eacde86" translate="yes" xml:space="preserve">
          <source>This example demonstrates that we can bind data to not only text and attributes, but also the &lt;strong&gt;structure&lt;/strong&gt; of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply &lt;a href=&quot;guide/transitions&quot;&gt;transition effects&lt;/a&gt; when elements are inserted/updated/removed by Vue.</source>
          <target state="translated">この例は、データをテキストと属性だけでなく、DOMの&lt;strong&gt;構造&lt;/strong&gt;にもバインドできることを示しています。 さらに、Vueは、エレメントがVueによって挿入/更新/削除されたときに自動的に&lt;a href=&quot;guide/transitions&quot;&gt;移行効果を&lt;/a&gt;適用できる強力な移行効果システムを提供します。</target>
        </trans-unit>
        <trans-unit id="28f4e1203d764412549f6b1974ffcd1631f009dd" translate="yes" xml:space="preserve">
          <source>This gives you more complete control over the reactive properties you&amp;rsquo;d like to watch.</source>
          <target state="translated">これにより、見たい反応特性をより完全に制御できます。</target>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">これは、関数を受け入れる &lt;code&gt;scrollBehavior&lt;/code&gt; オプションに置き換えられたため、スクロール動作は完全にカスタマイズ可能です（ルートごとでも）。 これは多くの新しい可能性を開きますが、次の古い動作を再現します。</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">&lt;a href=&quot;../api/index#delimiters&quot;&gt;コンポーネントレベルオプション&lt;/a&gt;として作り直されました。 これにより、サードパーティのコンポーネントを壊すことなく、アプリで代替の区切り文字を使用できます。</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">これはすぐに手に負えなくなりました。 したがって、子孫コンポーネントに任意の深さのコンテキスト情報を提供するには、代わりに&lt;a href=&quot;#Dependency-Injection&quot;&gt;依存性注入&lt;/a&gt;をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">これには2つの潜在的な問題があります。</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">これにより、コンポーネントを編集したり、使用方法を確認したりする必要がある場合に、コンポーネントをすばやく見つけることができます。</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">このモジュール性により、Vue 2への移行が容易になるだけでなく、通貨の解析とフォーマットも可能になります。</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">これは不自然な例ですが、アプリを2つの小さなユニットに分割することができました。 また、子供は小道具インターフェイスを介して親から十分に分離されています。 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; コンポーネントは、親アプリに影響を与えることなく、より複雑なテンプレートとロジックを使用してさらに洗練できます。</target>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">これは間違いなくガイドで書くのが最も難しいページですが、重要だと感じています。 可能性は、解決しようとした問題があり、別のライブラリを使用してそれらを解決したことです。 Vueが特定の問題をよりよく解決できるかどうかを知りたいので、ここにいます。 それは私があなたのために答えたいことです。</target>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">これは現在、 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;ルート定義オプション&lt;/a&gt;です。 したがって、たとえば、更新：</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">これは、エイリアスを作成&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;するルート&lt;/a&gt;を定義するためのオプションです 。 したがって、たとえば、更新：</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; であっても、HTML入力要素の値は常に文字列を返すため、これはしばしば役立ちます。 &lt;code&gt;parseFloat()&lt;/code&gt; は値を解析できません。元の値が返されます。</target>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">これは、 &lt;a href=&quot;../guide/single-file-components&quot;&gt;単一ファイルコンポーネントに&lt;/a&gt;のみ関連します 。 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;/a&gt;はscoped属性を使用する必要&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt; 。 スコーピングは、 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt; 、 &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;などのクラスベースの戦略、または別のライブラリ/規則を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;mixins&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">これは、Global &lt;code&gt;Vue.delete&lt;/code&gt; の &lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">これは、Global &lt;code&gt;Vue.set&lt;/code&gt; の &lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">これは、より低いレベルに移行するコストですが、 &lt;code&gt;v-model&lt;/code&gt; と比較して、相互作用の詳細をより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">これは、コンポーネントオプションの推奨されるデフォルトの順序です。 これらはカテゴリに分かれているため、カスタム属性とディレクティブを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">これは、コンポーネントオプションの推奨されるデフォルトの順序です。 カテゴリに分かれて、プラグインが新しいプロパティを追加する場所を確認できます。</target>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">これは、Vue固有のコードの公式スタイルガイドです。 Vueをプロジェクトで使用する際のエラー、自転車の脱落、アンチパターンを回避するための優れたリファレンス。 ただし、スタイルガイドがすべてのチームまたはプロジェクトに理想的であるとは考えていません。 したがって、過去の経験、周囲の技術スタック、および個人的な価値に基づいて、慎重に逸脱することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">これは実際の例のようです。</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">ただし、これは必ずしも望ましいとは限らず、Vueは「これら2つの要素は完全に分離されています。再利用しないでください」と言う方法を提供します。 一意の値を持つ &lt;code&gt;key&lt;/code&gt; 属性を追加します。</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">次の結果が生じるため、これは推奨されません。</target>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">これにより、複数の条件で &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">これにより、内部スタイルを簡単にオーバーライドできます。 人間が読めるクラス名はあまり明確ではありませんが、競合の可能性は非常に低くなっています。</target>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">このメソッドは、 &lt;code&gt;new Vue()&lt;/code&gt; 呼び出す前に呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">これは魔法のように思えるかもしれませんが、内部では、Vueは&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt;と呼ばれるアニメーション手法を使用して、トランジションを使用して要素を古い位置から新しい位置にスムーズに移行します。</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">これは、コンポーネントを文書化するだけでなく、ユーザーが間違ったタイプを渡すと、ブラウザーのJavaScriptコンソールに警告します。 このページのさらに下で、 &lt;a href=&quot;#Prop-Validation&quot;&gt;型チェックやその他の小道具の検証&lt;/a&gt;について詳しく学びます。</target>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">Vueの移行システムには明示的な&lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; 移行コントロール&lt;/a&gt;があるため、このオプションは不要になりました。</target>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">このページでは、コンポーネントの基本をすでに読んでいること&lt;a href=&quot;components&quot;&gt;を&lt;/a&gt;前提としています。 コンポーネントを初めて使用する場合は、最初に読んでください。</target>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">このペアのオプションを一緒に使用すると、同じ親チェーン内にある限り、コンポーネント階層の深さに関係なく、祖先コンポーネントがそのすべての子孫の依存関係インジェクターとして機能できます。 Reactに精通している場合、これはReactのコンテキスト機能に非常に似ています。</target>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">これにより、 &lt;code&gt;doc&lt;/code&gt; オブジェクトの各プロパティ（ &lt;code&gt;title&lt;/code&gt; など）が個別のプロップとして渡され、 &lt;code&gt;v-on&lt;/code&gt; 更新リスナーが各プロパティに追加されます。</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">このパターンを使用すると、ルートの要素を気にすることなく、未加工のHTML要素などの基本コンポーネントを使用できます。</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">このパターンは、単純なシナリオで &lt;code&gt;$dispatch&lt;/code&gt; および &lt;code&gt;$broadcast&lt;/code&gt; 代わりとして使用できますが、より複雑な場合は、 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;などの専用の状態管理レイヤーを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションは&lt;a href=&quot;components&quot;&gt;コンポーネントの&lt;/a&gt;知識を仮定します 。 スキップして後で戻ります。</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションでは、 &lt;a href=&quot;components&quot;&gt;Vueコンポーネントの&lt;/a&gt;知識を前提としています 。 スキップして後で戻ります。</target>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">これは常に &lt;code&gt;errorClass&lt;/code&gt; を適用し &lt;code&gt;activeClass&lt;/code&gt; 、 &lt;code&gt;isActive&lt;/code&gt; がtrueの場合にのみactiveClassを適用します。</target>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">このような制限がある要素を持つコンポーネントを使用する場合、これは問題になる可能性があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">これはもう機能しません：</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">これにより、ブラウザがサポートする配列の最後の値のみがレンダリングされます。 この例では、prefixedバージョンのflexboxをサポートするブラウザの &lt;code&gt;display: flex&lt;/code&gt; をレンダリングします 。</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">これにより、同じ結果がレンダリングされます。 オブジェクトを返す&lt;a href=&quot;computed&quot;&gt;計算プロパティに&lt;/a&gt;バインドすることもできます。 これは一般的で強力なパターンです。</target>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">これは機能しますが、注意点が1つあります。</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">これにより、ページ上部の200px要素が修正されます。 しかし、上ではなく左から要素を修正する必要があるシナリオに遭遇した場合はどうでしょうか？ コンポーネントインスタンスごとに更新できる動的な引数は非常に便利です。</target>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">したがって、以下を使用して、親コンポーネントが &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; の入力に集中できるようにします。</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">密結合コンポーネント名</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">密結合コンポーネント名を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">この問題に対処するために、Vueは &lt;code&gt;v-on&lt;/code&gt; &lt;strong&gt;イベント修飾子を&lt;/strong&gt;提供しています。 修飾子は、ドットで示されるディレクティブの接尾辞であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">オブジェクトのネストされた値の変更を検出するには、オプション引数に &lt;code&gt;deep: true&lt;/code&gt; を渡す必要があります。 シーケンス変異をリッスンする必要がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">1つの定義では、アニメーション化は復活を意味します。 残念ながら、デザイナーがアイコン、ロゴ、マスコットを作成するとき、それらは通常、画像または静的SVGとして配信されます。 したがって、GitHubのオクトキャット、Twitterの鳥、および他の多くのロゴは生き物に似ていますが、実際には生きているようには見えません。</target>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">リストを非表示にする必要がある場合にリストがレンダリングされないようにする（例： &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ）。 これらの場合、 &lt;code&gt;v-if&lt;/code&gt; をコンテナー要素（ &lt;code&gt;ul&lt;/code&gt; 、 &lt;code&gt;ol&lt;/code&gt; など）に移動します。</target>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">警告2に対処するには、 &lt;code&gt;splice&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">コンポーネントAおよびBを呼び出して、何が起こっているのかを説明しましょう。 モジュールシステムはAを必要としますが、最初のAはBを必要としますが、BはAを必要としますが、AはBを必要とします。 これを修正するには、モジュールシステムに「Aは&lt;em&gt;最終的に&lt;/em&gt; Bを必要としますが、最初にBを解決する必要はありません」と言うことができるポイントを与える必要があります。</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">リスト内のアイテムをフィルタリングするには（たとえば、 &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ）。 これらの場合、 &lt;code&gt;users&lt;/code&gt; をフィルター処理されたリストを返す新しい計算プロパティ（ &lt;code&gt;activeUsers&lt;/code&gt; など ）に置き換えます 。</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Vueを使い始めるには、HTMLおよびES5 JavaScript（つまり、プレーンJavaScript）に精通していれば十分です。 これらの基本的なスキルがあれば&lt;a href=&quot;../index&quot;&gt;、ガイド&lt;/a&gt;を読んでから1日以内に重要なアプリケーションの構築を開始できます。</target>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vueが各ノードのIDを追跡できるようにヒントを提供し、既存の要素を再利用および並べ替えるには、各アイテムに一意の &lt;code&gt;key&lt;/code&gt; 属性を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">この問題を解決するために、 &lt;strong&gt;ストアパターンを&lt;/strong&gt;採用でき&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">プログラムリスナーの詳細については、イベントインスタンスメソッドのAPIをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">TypeScriptでVueコンポーネントオプションのタイプを適切に推測するには、 &lt;code&gt;Vue.component&lt;/code&gt; または &lt;code&gt;Vue.extend&lt;/code&gt; でコンポーネントを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">ユーザーがアプリと対話できるようにするには、 &lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用して、Vueインスタンスのメソッドを呼び出すイベントリスナーをアタッチします。</target>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; を属性として &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素にバインドし、 &lt;code&gt;user&lt;/code&gt; 親のスロットコンテンツで使用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">警告1を克服するには、以下の両方の &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 同じことを行いますが、リアクティブシステムで状態の更新をトリガーします。</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">親から名前付きスロットにコンテンツを渡すには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; で特別な &lt;code&gt;slot&lt;/code&gt; 属性を使用します（ &lt;a href=&quot;#Named-Slots&quot;&gt;ここ&lt;/a&gt;で例として説明する &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; コンポーネントを使用）：</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">VNodeデータの &lt;code&gt;scopedSlots&lt;/code&gt; フィールドを使用して、レンダリング関数を使用してスコープスロットを子コンポーネントに渡します。</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">名前付きスロットのコンテンツを提供するには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; で &lt;code&gt;v-slot&lt;/code&gt; ディレクティブを使用し、 v-slotの引数としてスロットの名前を提供します。</target>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; に渡されたpropを受信するために、親コンポーネントはslot-scope属性で &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; を使用できます（ &lt;a href=&quot;#Scoped-Slots&quot;&gt;ここ&lt;/a&gt;で例として説明する &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">スタイルをスコープするために、Vueは &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; などのコンポーネント要素に一意の属性を追加します。 次に、この属性を持つ一致する要素 &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; （たとえば[button-data-v-f3f3eg9]）のみを選択するようにセレクターが変更されました。</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">この問題を解決するために、Vueは、コンポーネントで使用されるリスナーオブジェクトを含む &lt;code&gt;$listeners&lt;/code&gt; プロパティを提供します。 例えば：</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">日付選択プラグインのテーマを指定するには、次のような特定のクラスを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">プロパティの検証を指定するには、文字列の配列ではなく、オブジェクトの &lt;code&gt;props&lt;/code&gt; の値に検証要件を指定します。 例えば：</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Vue 2.0でより堅牢なソリューションに移行するには、まずこのフィルターを新しい &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; コンポーネントでラップします。</target>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">これらのコンポーネントをテンプレートで使用するには、それらを登録して、Vueがそれらを認識できるようにする必要があります。 コンポーネントの登録には、 &lt;strong&gt;グローバル&lt;/strong&gt;と&lt;strong&gt;ローカルの&lt;/strong&gt; 2つのタイプがあります。 これまでのところ、 &lt;code&gt;Vue.component&lt;/code&gt; を使用してグローバルにコンポーネントのみを登録しました 。</target>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">式の値の真実性に基づいて、要素のCSS &lt;code&gt;display&lt;/code&gt; プロパティを切り替えます。</target>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">実行時エラーの追跡</target>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">トランジション &lt;code&gt;stagger&lt;/code&gt; 属性が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">遷移クラス</target>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">移行モード</target>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">コンポーネント間の移行</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">要素間の遷移</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">単一要素/コンポーネントの移行</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">コンポーネント間の移行はさらに簡単です。 &lt;code&gt;key&lt;/code&gt; 属性も必要ありません。 代わりに、 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;動的コンポーネントを&lt;/a&gt;ラップします 。</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">遷移は、Vueのコンポーネントシステムを介して再利用できます。 再利用可能なトランジションを作成するには、単に &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; コンポーネントをルートに配置し、子をトランジションコンポーネントに渡します。</target>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">初期レンダリング遷移</target>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">ドキュメントを翻訳</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">現在のインスタンスでイベントをトリガーします。 追加の引数がリスナーコールバック関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">トリガー遷移</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; をトリガーして、フックを破棄します。</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 真実/偽造が&lt;sup&gt;変更されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimbaでこのレッスンをお試しください</target>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">本番モードをオンにする</target>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;交換された&lt;/sup&gt;双方向フィルター</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">タイプチェック</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">TypeScriptのサポート</target>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">内部的に、Vueはテンプレートを仮想DOMレンダリング関数にコンパイルします。 レスポンシブシステムと組み合わせると、Vueは最小限のコンポーネント数をインテリジェントに認識し、アプリの状態が変化したときに再レンダリングし、最小限のDOM操作を適用できます。</target>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">残念ながら、HTMLでは、カスタム要素を自己閉鎖することはできません。 &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;公式の「void」要素&lt;/a&gt;のみ。 したがって、戦略は、VueのテンプレートコンパイラがDOMの前にテンプレートに到達し、DOM仕様に準拠したHTMLを提供できる場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">残念ながら、HTMLでは大文字と小文字が区別されないため、DOMテンプレートでは引き続きケバブのケースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">単体テスト</target>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">コンポーネントが複数のファイルに分散していない限り（たとえば&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;、CSS Modulesを使用&lt;/a&gt; ）、ReactでのCSSのスコープはCSS-in-JSソリューション（ &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;華やかな&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;感情など&lt;/a&gt; ）を介して行われます。 これにより、通常のCSSオーサリングプロセスとは異なる新しいコンポーネント指向のスタイリングパラダイムが導入されます。 さらに、ビルド時にCSSを単一のスタイルシートに抽出するサポートがありますが、スタイリングが適切に機能するためには、ランタイムをバンドルに含める必要があるのが一般的です。 スタイルを構築しながらJavaScriptのダイナミズムにアクセスできますが、多くの場合、トレードオフはバンドルサイズとランタイムコストの増加です。</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; とは異なり、デフォルトでは &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; と呼ばれる実際の要素をレンダリングします。 &lt;code&gt;tag&lt;/code&gt; 属性を使用して、レンダリングされた要素を変更できます。</target>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">コンポーネントや小道具とは異なり、イベント名は大文字小文字の自動変換を提供しません。 代わりに、公開されたイベントの名前は、そのイベントをリッスンするために使用される名前と正確に一致する必要があります。 たとえば、camelCasedイベント名を公開するには：</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">コンポーネントや小道具とは異なり、イベント名はJavaScriptの変数名またはプロパティ名として使用されないため、camelCaseまたはPascalCaseを使用する理由はありません。 さらに、 &lt;code&gt;v-on:myevent&lt;/code&gt; はv-on：myeventおよびv-on：myEventがmyEventをリッスンできます。これは、DOMテンプレートの &lt;code&gt;v-on&lt;/code&gt; イベントリスナーが自動的に小文字に変換されるためです（HTMLの大文字と小文字が区別されないため）。</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">1.xとは異なり、これらの &lt;code&gt;$refs&lt;/code&gt; は、レンダリングプロセス中に登録/更新されるため、リアクティブではありません。 それらをリアクティブにするために、各変更には重複したレンダリングが必要です。</target>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">ネイティブDOMイベントに固有の他の修飾子とは異なり、 &lt;code&gt;.once&lt;/code&gt; 修飾子は&lt;a href=&quot;components-custom-events&quot;&gt;コンポーネントイベント&lt;/a&gt;でも使用できます 。 コンポーネントについてまだ読んでいない場合は、今のところ心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0+で更新されました。 &lt;code&gt;slot-scope&lt;/code&gt; 属性を使用した非推奨の構文については、 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0+で更新されました。 &lt;code&gt;slot&lt;/code&gt; 属性を使用した非推奨の構文については、 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">要素の &lt;code&gt;innerHTML&lt;/code&gt; を更新します。 &lt;strong&gt;コンテンツはプレーンHTMLとして挿入され、Vueテンプレートとしてコンパイルされないことに注意してください&lt;/strong&gt; 。 &lt;code&gt;v-html&lt;/code&gt; を使用してテンプレートを作成しようとしている場合は、代わりにコンポーネントを使用してソリューションを再検討してください。</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">要素の &lt;code&gt;textContent&lt;/code&gt; を更新します。 &lt;code&gt;textContent&lt;/code&gt; の一部を更新する必要がある場合は、 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 補間を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">これらのノードをすべて効率的に更新することは困難ですが、ありがたいことに、手動で更新する必要はありません。 代わりに、テンプレートはVueにページに表示するHTMLを指示します。</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">アップグレードパス</target>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replaceを使用します&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodashの &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; （または&lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ）を使用して、高価なメソッド呼び出しを直接制限します。 上記と同じことを達成できます。</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">計算プロパティで&lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodashの &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; （場合によっては&lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">代わりにルートで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">&lt;code&gt;$parent&lt;/code&gt; と &lt;code&gt;$children&lt;/code&gt; 、ほとんどの場合、エスケープハッチとして機能します。 親子通信には小道具とイベントを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">代わりに &lt;code&gt;Array.prototype.splice&lt;/code&gt; を使用してください。 例えば：</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">代わりに &lt;code&gt;Vue.set&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScript組み込みの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScriptの組み込み&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">他のフックでカスタムDOMチェックを使用します。 たとえば、置き換えるには：</target>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">代わりにコンポーネントを使用してください。</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">グローバルミックスインは、サードパーティのコンポーネントを含む、作成されたすべてのVueインスタンスに影響を与えるため、慎重に使用する必要があります。 ほとんどの場合、上記の例に示すように、カスタムオプション処理にのみ使用する必要があります。 また、アプリケーションの重複を避けるために、 &lt;a href=&quot;plugins&quot;&gt;プラグイン&lt;/a&gt;として出荷することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">プラグインを使用する &lt;code&gt;Vue.use()&lt;/code&gt; グローバルメソッド。 これは、 &lt;code&gt;new Vue()&lt;/code&gt; を呼び出してアプリを起動する前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">最適なデバッグエクスペリエンスを得るには、Vue Devtoolsを使用してください。</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、 &lt;code&gt;created&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">代わりに、コンポーネントの&lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt;またはdestroyフックを使用してください。</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">ネイティブDOM APIを使用します。</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">代わりに、新しい &lt;code&gt;beforeCreate&lt;/code&gt; フックを使用してください 。 これは基本的に同じです。 他のライフサイクルメソッドとの一貫性のために名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、新しい &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">代わりに、新しい &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。 ただし、 &lt;code&gt;mounted&lt;/code&gt; は、ドキュメント内にあることを保証しません。 そのためには、 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; も含めます。 例えば：</target>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;動的コンポーネントに&lt;/a&gt;使用&lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;され、DOMのテンプレート制限を&lt;/a&gt;回避するために使用されます 。</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">子コンポーネントに挿入されるコンテンツに使用され、コンテンツが属する名前付きスロットを示します。</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素をスコープ付きスロットとして示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">要素またはコンポーネントをスコープスロットとして示すために使用されます。 属性の値は、関数シグネチャの引数位置に表示できる有効なJavaScript式である必要があります。 つまり、サポートされている環境では、式はES2015構造化も使用できます。 2.5.0以降では、 &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt;代替として機能します 。</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">プログラムで&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;スコープスロット&lt;/a&gt;にアクセスするために使用します。 &lt;code&gt;default&lt;/code&gt; スロットを含む各スロットオブジェクトには、VNodeを返す対応する関数があります。</target>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;スロットによって配信される&lt;/a&gt;コンテンツにプログラムでアクセスするために使用されます 。 各&lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;名前付きスロットには&lt;/a&gt; 、対応する独自のプロパティがあります（たとえば、 &lt;code&gt;v-slot:foo&lt;/code&gt; コンテンツは &lt;code&gt;vm.$slots.foo&lt;/code&gt; ）。 &lt;code&gt;default&lt;/code&gt; プロパティには、名前付きスロットに含まれないノードまたは &lt;code&gt;v-slot:default&lt;/code&gt; コンテンツが含まれます 。</target>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">追加の引数とともに &lt;code&gt;$emit&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">イベント名のみで &lt;code&gt;$emit&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; 属性の使用も許可されています。</target>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">&lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; リテラルオブジェクト（v-bind.sync =&amp;rdquo; {title：doc.title}&amp;rdquo;など）は、解析する際に考慮すべきエッジケースが多すぎるため機能します。複雑な表現はしません。 。</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">&lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; は、レンダリング中にアクティブユーザー&lt;em&gt;のみ&lt;/em&gt; &lt;em&gt;を&lt;/em&gt;反復処理し、レンダリングをより効率的にします。</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; &lt;strong&gt;は&lt;/strong&gt; 、v-ifと &lt;code&gt;v-for&lt;/code&gt; を一緒に使用する &lt;strong&gt;ことを推奨&lt;/strong&gt;し&lt;strong&gt;ません&lt;/strong&gt; 。 詳細については、 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">コンポーネントでの &lt;code&gt;v-model&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">JavaScript式を使用する</target>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">トランジションとアニメーションを一緒に使用する</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">プラグインを使用する</target>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">挿入された値をデータ入力として使用します。</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">挿入された値をpropのデフォルトとして使用します。</target>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">&lt;code&gt;$listeners&lt;/code&gt; プロパティでは、 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; を使用して、コンポーネントのすべてのイベントリスナーを特定の子要素に転送できます。 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; は、&amp;lt;input&amp;gt;などの要素を持つ &lt;code&gt;v-model&lt;/code&gt; を使用する &lt;code&gt;inputListeners&lt;/code&gt; の下のinputListenersなどのリスナーの新しい計算プロパティを作成するのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">ここで例として説明&lt;a href=&quot;#Other-Examples&quot;&gt;した&lt;/a&gt; &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; を使用して、 &lt;code&gt;slot-scope&lt;/code&gt; を使用した同等の使用法を次に示します 。</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 属性は、入力のリアルタイム状態にアクセスできないようにするため、「as input」状態を検出する方法はありません。 ただし、デバウンス機能をVueから分離することにより、制限する操作のみをデバウンスでき、開発可能な機能に対する制限を排除できます。</target>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">この戦略を使用すると、いくつかの入力要素でPikadayを使用することもでき、新しいインスタンスはそれぞれ自動的にクリーンアップされます。</target>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">ただし、通常、すべての小道具は特定のタイプの値である必要があります。 これらの場合、プロパティ名と値にプロパティ名とタイプがそれぞれ含まれるオブジェクトとしてプロパティをリストできます。</target>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">VNodeインターフェイス</target>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodeは一意である必要があります</target>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">値バインディング</target>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;によるビデオ。 Vue Masteryの無料の入門Vueコースをご覧&lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">博物館&lt;em&gt;への&lt;/em&gt;訪問者</target>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue（発音/vjuː/ like &lt;strong&gt;view&lt;/strong&gt; ）は、ユーザーインターフェイスを構築するための&lt;strong&gt;プログレッシブフレームワーク&lt;/strong&gt;です。 他のモノリシックフレームワークとは異なり、Vueは時間をかけて採用するためにゼロから設計されています。 コアライブラリはビューレイヤーのみに焦点を当てているため、他のライブラリや既存のプロジェクトを簡単に選択して統合できます。 一方、Vueは、 &lt;a href=&quot;guide/single-file-components&quot;&gt;最新のツール&lt;/a&gt;および&lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;サポートライブラリ&lt;/a&gt;と組み合わせて使用​​すると、洗練された単一ページのアプリケーションを完全に機能させることもできます 。</target>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vueは、 &lt;strong&gt;仮想DOM&lt;/strong&gt;を構築し、実際のDOMに加える必要のある変更を追跡することでこれを実現します。 この行を詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vueは、 &lt;code&gt;addEventListener&lt;/code&gt; の &lt;code&gt;passive&lt;/code&gt; オプションに対応する &lt;code&gt;.passive&lt;/code&gt; 修飾子も提供します。</target>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vueは、フォーム入力とアプリの状態の間の双方向バインディングを容易にする &lt;code&gt;v-model&lt;/code&gt; ディレクティブも提供します。</target>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vueが役立ちます。 SVGは単なるデータであるため、これらのクリーチャーが興奮、思考、または警戒したときにどのように見えるかの例のみが必要です。 第二に、Vueはこれらの状態間の移行を支援し、ウェルカムページの作成、インジケーターの読み込み、通知をより感情的で説得力のあるものにします。</target>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vueコンポーネントは、単純なカスタム要素では利用できない重要な機能を提供します。 最も注目すべきは、コンポーネント間のデータフロー、カスタムイベント通信、およびビルドツールの統合です。</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vueは、IE8ではシミュレートできないECMAScript 5機能を使用するため、IE8以下をサポートしませ&lt;strong&gt;ん&lt;/strong&gt; 。 ただし、 &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5に準拠&lt;/a&gt;したすべてのブラウザーをサポートしています。</target>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vueでは、作成済みのインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。 ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vueでは、作成済みのインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。 ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加できます。</target>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vueは、Vueインスタンスデータの変更を監視し、それらに反応するより一般的な方法を提供します： &lt;strong&gt;プロパティの監視&lt;/strong&gt; 。 他のデータに基づいて変更する必要があるデータがある場合、特にAngularJSのバックグラウンドから来ている場合は、使いすぎの監視を見ることができます。 ただし、多くの場合、命令的な &lt;code&gt;watch&lt;/code&gt; コールバックの代わりに計算されたプロパティを使用する方が適切です。 この例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vueは、非同期キューイングを備えた透過的な依存関係追跡および監視システムを使用するため、この問題はまったくありません。 明示的な依存関係がない限り、すべての変更は独立してトリガーされます。</target>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vueは、従来のWebテクノロジーを採用して構築しています。 それが何を意味するかを示すために、いくつかの例に飛び込みましょう。</target>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vueでは、ディレクティブとコンポーネントは明確に分離されています。 ディレクティブはDOM操作のみをカプセル化することを目的としていますが、コンポーネントは独自のビューとデータロジックを持つ自己完結型のユニットです。 AngularJSでは、ディレクティブはすべてを実行し、コンポーネントは特定のタイプのディレクティブにすぎません。</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vueはすでに世界中に広がっており、コアチームでさえ少なくとも6つのタイムゾーンにあります。 &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラムに&lt;/a&gt;は7つの言語と数が含まれており、ドキュメントの多くは積極的に&lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;翻訳を&lt;/a&gt;管理しています 。 Vueの国際的な拡大を非常に誇りに思っていますが、さらに改善することができます。</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vueのパフォーマンスが向上し、ダーティチェックを使用しないため、最適化がはるかに簡単になりました。 ウォッチャーが多い場合、AngularJSは遅くなります。 これらのウォッチャーはすべて、スコープ内の何かが変更されるたびに再評価する必要があります。 また、一部のウォッチャーが別の更新をトリガーした場合、ダイジェストサイクルを複数回実行して「安定化」する必要があります。 AngularJSユーザーは、多くの場合、ダイジェストサイクルを回避するために難解な手法に頼る必要があり、状況によっては、多くのウォッチャーがスコープを最適化する方法がありません。</target>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vueは、 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Webコンポーネント仕様ドラフト&lt;/a&gt;に触発されたコンテンツ配信APIを実装し、コンテンツ配信の手段として &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を使用します。</target>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vueは&lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt;および&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt;でも利用可能です（cdnjsの同期には時間がかかる場合があるため、最新リリースはまだ利用できない可能性があります）。</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">VueはAngularよりも意見が少なく、さまざまなビルドシステムの公式サポートを提供します。 アプリケーションの構造に制限はありません。 多くの開発者はこの自由を楽しんでいますが、アプリケーションを構築する正しい方法を1つだけ持っていることを好む開発者もいます。</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vueは、AngularJSよりもAPIと設計の両方ではるかに単純です。 自明ではないアプリケーションを構築するのに十分な学習には、通常1日もかかりません。 これは、AngularJSには当てはまりません。</target>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vueは、イベントリスナーをアタッチして、トランジションがいつ終了したかを知る必要があります。 適用されるCSSルールのタイプに応じて、 &lt;code&gt;transitionend&lt;/code&gt; または &lt;code&gt;animationend&lt;/code&gt; のいずれか。 どちらか一方のみを使用する場合、Vueは自動的に正しいタイプを検出できます。</target>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vueは、次のコンテキストで任意の要素またはコンポーネントの遷移の開始/終了を追加できる &lt;code&gt;transition&lt;/code&gt; ラッパーコンポーネントを提供します。</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vueには、DOMでアイテムを挿入、更新、または削除するときに遷移効果を適用するさまざまな方法が用意されています。 これには次のツールが含まれます。</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vueは、レガシブラウザーをサポートする必要がある場合に、最も一般的に使用されるキーコードのエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vueは、野心的な単一ページアプリケーションを迅速に構築するための&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;公式CLI&lt;/a&gt;を提供します。 最新のフロントエンドワークフロー用のバッテリーを含むビルドセットアップを提供します。 ホットリロード、リントオンセーブ、およびプロダクションビルドで起動して実行するのに数分しかかかりません。 詳細について&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;は、Vue CLIのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vueは、プレーンなJavaScriptオブジェクトと完全に自動化された計算プロパティに対する控えめな応答性を提供します。 Emberでは、すべてをEmberオブジェクトにラップし、計算されたプロパティの依存関係を手動で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">ほとんどの場合、Vueではテンプレートを使用してHTMLを構築することをお勧めします。 ただし、JavaScriptの完全なプログラミング機能が本当に必要な場合があります。 その&lt;strong&gt;ため&lt;/strong&gt; 、テンプレートの代わりにコンパイラに似た&lt;strong&gt;レンダリング関数&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vueは、可能な限り効率的に要素をレンダリングしようとします。 多くの場合、最初からレンダリングする代わりに再利用します。 Vueを非常に高速にすることに加えて、これにはいくつかの有用な利点があります。 たとえば、ユーザーが複数のログインタイプを切り替えることができるようにするには：</target>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vueは &lt;code&gt;_&lt;/code&gt; プレフィックスを使用して独自のプライベートプロパティを定義するため、同じプレフィックス（たとえば &lt;code&gt;_update&lt;/code&gt; ）を使用するとインスタンスプロパティが上書きされる危険があります。 チェックしても、Vueが現在特定のプロパティ名を使用していない場合、以降のバージョンで競合が発生しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vueは、CSSトランジションまたはアニメーションがターゲット要素に適用されているかどうかを自動的に検出します。 存在する場合、CSS遷移クラスは適切なタイミングで追加/削除されます。</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vueはまた、観察された配列変更メソッドをラップし、ビューの更新もトリガーします。 ラップされたメソッドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vueコミュニティは非常に急速に成長しています。 これを読んでいる場合は、参加する準備ができている可能性が非常に高くなります。 だから...ようこそ！</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vueのテンプレート構文はJavaScript式のすべての機能を利用しますが、ハンドルバー式とヘルパー構文は比較において意図的にかなり制限されています。</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vueの移行システムは、 &lt;code&gt;transition&lt;/code&gt; 属性の代わりに &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; ラッパー要素を使用して大幅に変更されました。 詳細については、新しい&lt;a href=&quot;transitions&quot;&gt;移行ガイド&lt;/a&gt;を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vueの移行システムは、エントリ、終了、リストをアニメーション化する多くの簡単な方法を提供しますが、データ自体のアニメーション化についてはどうですか？ 例えば：</target>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile（テンプレート）</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component（id、[定義]）</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete（ターゲット、propertyName /インデックス）</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive（id、[定義]）</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extend（オプション）</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter（id、[定義]）</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.jsを使用すると、一般的なテキスト形式を適用するために使用できるフィルターを定義できます。 フィルターは、2つの場所で使用できます： &lt;strong&gt;口ひげ補間と &lt;code&gt;v-bind&lt;/code&gt; 式&lt;/strong&gt; （後者は2.1.0以降でサポートされています）。 「パイプ」記号で示されるJavaScript式の最後にフィルターを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.jsはHTMLベースのテンプレート構文を使用して、レンダリングされたDOMを基になるVueインスタンスのデータに宣言的にバインドできます。 すべてのVue.jsテンプレートは、仕様に準拠したブラウザーおよびHTMLパーサーで解析できる有効なHTMLです。</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin（ミックスイン）</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick（[コールバック、コンテキスト]）</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable（オブジェクト）</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set（ターゲット、propertyName /インデックス、値）</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">Vue.use（プラグイン）</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0がリリースされました。 このガイドでは、1.0への移行のみを扱っていますか？ タイプミスですか？ また、Vuex 1.0と2.0は同時にリリースされたようです。 どうしましたか？ どちらを使用する必要があり、Vue 2.0と互換性がありますか？</target>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Vue Schoolで無料レッスンを見る</target>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Vue Masteryで無料のビデオコースを見る</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Vue Schoolで無料のビデオコースを見る</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Vue Schoolで無料のビデオレッスンを見る</target>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Vue Masteryビデオの説明を見る</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Vueインスタンスの式または計算された関数の変更に注意してください。 コールバックは、新しい値と古い値で呼び出されます。 この式は、点線のパスのみを受け入れます。 より複雑な式の場合は、代わりに関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">ウォッチャーを使用すると、数値プロパティの変更を別のプロパティにアニメーション化できます。 抽象的には複雑に聞こえるかもしれませんが、 &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;を使用した例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">関連するコンポーネントが再レンダリングされる前に、 &lt;code&gt;vm.$watch&lt;/code&gt; 作成されたウォッチャーが起動されるようになりました。 これにより、コンポーネントが再レンダリングされる前に状態をさらに更新できるため、不必要な更新が回避されます。 たとえば、コンポーネントのプロップを監視し、プロップが変更されたときにコンポーネント自体のデータを更新できます。</target>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">また、偏見を避けるために努力しています。 コアチームとして、明らかにVueが大好きです。 私はそこに他の何よりも解決できると思ういくつかの問題があります。 私たちがそれを信じなかったなら、私たちはそれに取り組みません。 ただし、公正かつ正確になりたいと考えています。 Reactの代替レンダラーの広大なエコシステムや、KnockoutのブラウザーサポートのIE6への復帰など、他のライブラリーが大きなメリットを提供する場合、それらのリストも表示します。</target>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">この手法を以前の実装と組み合わせて、リストの変更をアニメーション化します！</target>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; をカスタム入力で直接使用できるようになりました。 これは、通常の入力との一貫性を意味するだけでなく、コンポーネントがVuexと互換性があることも意味します。</target>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; 配列をv-bind：classに渡して、v-bind：classのリストを適用できます。</target>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">オブジェクトを &lt;code&gt;v-bind:class&lt;/code&gt; に渡して、クラスを動的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; は、v-forディレクティブを使用して、配列に基づいてアイテムのリストをレンダリングできます。 &lt;code&gt;v-for&lt;/code&gt; ディレクティブには、 &lt;code&gt;item in items&lt;/code&gt; 内のitems 内のフォームitemの特別な構文が必要です。 itemsはソースデータ配列で、 &lt;code&gt;item&lt;/code&gt; は繰り返される配列要素の&lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; は、v-onディレクティブを使用してDOMイベントをリッスンし、トリガーされたときにJavaScriptを実行できます。</target>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">この単一のイベントハブを使用して、コンポーネント間の通信を管理できます。</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">&lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;コンポーネント間の移行&lt;/a&gt;については後で説明しますが、 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; を使用して未加工の要素間を移行することもできます。 最も一般的な2要素遷移の1つは、リストコンテナと空のリストを説明するメッセージの間です。</target>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">アップデートも同様の利点を提供します。</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">次の利点があります。</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">新しいAngularはAngularJSとは完全に異なるフレームワークであるため、別のセクションがあります。 たとえば、一流のコンポーネントシステムがあり、実装の詳細の多くが完全に書き直され、APIが大幅に変更されました。</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">最初のVueアプリを作成しました！ これは文字列テンプレートのレンダリングに非常に似ていますが、Vueは内部で多くの作業を行います。 データとDOMはリンクされ、すべてが&lt;strong&gt;リアクティブになりました&lt;/strong&gt; 。 どうして知っていますか？ ブラウザのJavaScriptコンソール（このページ）を &lt;code&gt;app.message&lt;/code&gt; に設定し 、app.messageを別の値に設定します。 上記のレンダリングされた例はそれに応じて更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">サーバーレンダリングされたVueアプリケーションを作成するためのスタンドアロンガイドを作成しました。 これは、クライアント側のVue開発、サーバー側のNode.js開発、およびwebpackにすでに精通している人向けの非常に詳細なガイドです。 &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.orgで確認してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 内にテキスト「Submit」をレンダリングする必要があります 。 フォールバックコンテンツを「送信」するには、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; タグの間に配置します。</target>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">次のように、この代替コンテンツを置き換えて、姓ではなくユーザーの名を表示できます。</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">このコンポーネントを再利用して、ユーザーが複数のリスト（ショッピング、ウィッシュリスト、雑用など）を維持できるようにすることができます。 ただし、問題があります。 コンポーネントのすべてのインスタンスは同じデータオブジェクトを参照するため、1つのリストのタイトルを変更すると、他のすべてのリストのタイトルも変更されます。 Todoの追加/編集/削除についても同様です。</target>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">引数を括弧で囲み、引数をコンマで区切ります。</target>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">また、JavaScriptの世界は急速に変化して&lt;strong&gt;いる&lt;/strong&gt;ため、このドキュメントを最新の状態に保つために&lt;strong&gt;ご&lt;/strong&gt;協力&lt;strong&gt;ください&lt;/strong&gt; 。 不正確または不正確に気付いた場合は、ケースを開いてお知らせください。</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">VNodeについては、後で&lt;a href=&quot;render-function&quot;&gt;関数のレンダリング&lt;/a&gt;について説明するときに詳しく説明します 。</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">次のセクションでは、これらのフックに渡される引数（つまり、 &lt;code&gt;el&lt;/code&gt; 、 &lt;code&gt;binding&lt;/code&gt; 、 &lt;code&gt;vnode&lt;/code&gt; 、および &lt;code&gt;oldVnode&lt;/code&gt; ）を調べます。</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">&lt;a href=&quot;components&quot;&gt;コンポーネントシステムの&lt;/a&gt;詳細は後述します。 現時点では、すべてのVueコンポーネントもVueインスタンスであるため、同じオプションオブジェクトを受け入れます（一部のルート固有オプションを除く）。</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">各言語のルールに従うだけです。 JavaScript内では、camelCaseはより自然です。 HTMLでは、kebab-caseはそうです。</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">ただし、フィルターと一般的なVue 1.0によってまだ制限されているため、Vue 2.0へのアップグレードを完了しましょう。</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Vue.jsコアの最も基本的な機能を簡単に紹介します。このガイドの残りの部分では、Vue.jsコアとその他の高度な機能について詳しく説明します。必ずすべて読んでください。</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">関心の分離についてはどうですか？</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">できること</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; は実際にcreateElementを返しますか？ これは実際のDOM要素ではありません。 おそらくより正確には、 &lt;code&gt;createNodeDescription&lt;/code&gt; という名前を付けることができます。 これは、子ノードの説明など、ページにレンダリングするノードのタイプを説明する情報が含まれているためです。 このノードの説明は「仮想ノード」と呼ばれ、通常は&lt;strong&gt;VNodeと&lt;/strong&gt;略され&lt;strong&gt;ます&lt;/strong&gt; 。 「仮想DOM」は、Vueコンポーネントのツリーによって構築されたVNodeのツリー全体と呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Vue.jsとは何ですか？</target>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; には複数の子があり、最終的には単一の子に評価されます。 最初の子以外の子は無視されます。</target>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">&lt;code&gt;isActive&lt;/code&gt; がtrueの場合、レンダリングされるHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isActive&lt;/code&gt; または &lt;code&gt;hasError&lt;/code&gt; が変更されると、それに応じてクラスリストが更新されます。 たとえば、 &lt;code&gt;hasError&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、クラスリストは &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; は &lt;code&gt;v-for&lt;/code&gt; とともに使用され、取得するrefは、データソースをミラーリングする子コンポーネントを含む配列です。</target>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 変更は、パッチを適用する代わりに常に &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; を置き換えるため、移行をトリガーします。</target>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Vueは、 &lt;code&gt;v-for&lt;/code&gt; によってレンダリングされた要素のリストを更新するときに、デフォルトで「インプレースパッチ」戦略を使用します。 データ項目の順序が変更された場合、DOM要素を移動して項目の順序を一致させるのではなく、Vueは各要素にその場でパッチを当て、その特定のインデックスでレンダリングされた内容を反映します。 君は。 これは、Vue 1.xの &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; の動作に似ています。</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">vueがディレクティブを処理するとき、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも優先順位が高いため、このテンプレートは次のようになります。</target>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModelが破棄されると、すべてのイベントリスナーが自動的に削除されます。 自分で掃除することを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Vueインスタンスが作成されると、その &lt;code&gt;data&lt;/code&gt; オブジェクトにあるすべてのプロパティがVueの&lt;strong&gt;レスポンシブシステムに&lt;/strong&gt;追加され&lt;strong&gt;ます&lt;/strong&gt; 。 これらのプロパティの値が変更されると、ビューは「反応」し、新しい値で更新されます。</target>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">ブラウザーはこのコードを読み取ると&lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;、「DOMノード」のツリーを&lt;/a&gt;構築して、すべてを追跡できるようにします。 これは、拡張された家族を追跡するために家系図を構築することと同じです。</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">コンポーネントが &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 内で切り替えられると、それに応じて &lt;code&gt;activated&lt;/code&gt; および &lt;code&gt;deactivated&lt;/code&gt; ライフサイクルフックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">ミックスインとコンポーネント自体に重複するオプションが含まれる場合、適切な戦略を使用して「マージ」されます。</target>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">&lt;code&gt;transition&lt;/code&gt; コンポーネントにラップされた要素の挿入または削除：</target>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">&lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; で &amp;lt;blog-post&amp;gt;コンポーネントを作成すると、最終的にテンプレートには単なるタイトル以外のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">コンポーネントがクランチを開始するか、判読できないと感じた場合、複数行のプロパティの間にスペースを追加すると、コンポーネントが読みやすくなります。 Vimなどの一部のエディターでは、これらの書式設定オプションにより、キーボードでの移動が簡単になります。</target>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">カスタムオプションがマージされると、既存の値を上書きするデフォルトの戦略が使用されます。 カスタムロジックを使用してカスタムオプションをマージする場合、関数を &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; にアタッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">&lt;strong&gt;componentを&lt;/strong&gt;定義する&lt;strong&gt;とき&lt;/strong&gt; 、 &lt;code&gt;data&lt;/code&gt; は初期データオブジェクトを返す関数として宣言する必要があります。 多くのインスタンスが同じ定義を使用して作成されているためです。 &lt;code&gt;data&lt;/code&gt; にプレーンなオブジェクトを使用すると、作成されたすべてのインスタンス間で同じオブジェクトが&lt;strong&gt;参照によって共有さ&lt;/strong&gt;れます！ &lt;code&gt;data&lt;/code&gt; 関数を提供することにより、新しいインスタンスが作成されるたびに、それを呼び出して初期データの新しいコピーを返すことができます。</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">PascalCaseを使用してコンポーネントを定義する場合、カスタム要素を参照するときにどちらの場合も使用できます。 つまり、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; の両方が受け入れられます。 ただし、ケバブのケース名のみがDOMで直接有効であることに注意してください（つまり、非文字列テンプレート）。</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">kebab-caseを使用してコンポーネントを定義する場合、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; などのカスタム要素を参照するときにkebab-caseも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">各計算プロパティに非常に単純な式のみが含まれ、依存関係がほとんどない場合、テストを作成して動作を確認する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">プロパティ名/キーを含める場合、オブジェクト引数の順序は &lt;code&gt;(name, value)&lt;/code&gt; でした。 現在、lodashなどの一般的なオブジェクトイテレータとの一貫性が向上しています &lt;code&gt;(value, name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(index, value)&lt;/code&gt; を含める場合、配列引数の順序は（index、value）でした。 &lt;code&gt;forEach&lt;/code&gt; や &lt;code&gt;map&lt;/code&gt; などのネイティブJavaScript配列メソッドとの一貫性が改善されました &lt;code&gt;(value, index)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">オブジェクトを反復する場合、順序は &lt;code&gt;Object.keys()&lt;/code&gt; 列挙順序に基づきますが、JavaScriptエンジンの実装全体で一貫性があることは保証されません。</target>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">キーボードイベントをリッスンするときは、特定のキーを確認する必要があります。 Vueでは、キーイベントをリッスンするときに &lt;code&gt;v-on&lt;/code&gt; キー修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">ネイティブDOMイベントをリッスンする場合、メソッドは唯一の引数としてネイティブイベントを受け取ります。 インラインステートメントを使用する場合、ステートメントは特別な &lt;code&gt;$event&lt;/code&gt; プロパティにアクセスできます： &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">エディターでアルファベット順に整理すると、簡単に識別できるようにアプリのすべての基本コンポーネントが一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">クエリパラメータで配列を渡すと、QueryString構文は &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; ではなくなり、代わりに新しい構文は &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; ます。 内部的には、 &lt;code&gt;$route.query.users&lt;/code&gt; は依然として配列ですが、クエリにパラメーターが1つしかない場合： &lt;code&gt;/foo?users=Tom&lt;/code&gt; 、ルーターがこのルートに直接アクセスするときに &lt;code&gt;users&lt;/code&gt; 期待するかどうか配列かどうかを知る方法はありません。 このため、計算プロパティを追加し、 &lt;code&gt;$route.query.users&lt;/code&gt; へのすべての参照をそれで置き換えることを検討してください。</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">プロップの検証が失敗すると、Vueはコンソールアラートを生成します（開発ビルドを使用している場合）。</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">コンポーネントを登録すると、常に名前が付けられます。 たとえば、グローバル登録では次のことがわかりました。</target>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; をに設定すると、テンプレートで見つかったHTMLコメントを保持およびレンダリングします。 デフォルトのアクションは、それらを破棄することです。</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">ただし、これらのコンポーネントを切り替えるときは、パフォーマンス上の理由から、状態を維持したり、再レンダリングを避けたりすることをお勧めします。 たとえば、タブ付きインターフェイスを少し拡張するには：</target>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">&lt;code&gt;inline-template&lt;/code&gt; 特殊属性は子コンポーネントに存在し、コンポーネントはコンテンツを分散コンテンツとして扱う代わりに、テンプレートとして内部コンテンツを使用します。 これにより、より柔軟なテンプレート作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">コンポーネントがレンダリングされると、 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; は「Your Profile」に置き換えられます。 スロットには、HTMLを含む任意のテンプレートコードを含めることができます。</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">グローバルフィルターの名前がローカルフィルターと同じ場合、ローカルフィルターが優先されます。</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">ページがロードされると、要素がフォーカスを取得します。 （注：Mobile Safariではオートフォーカスは機能しません。）実際、このページにアクセスして他の何かをクリックしていない場合は、上記の入力に集中する必要があります。 これを行うためのディレクティブを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; の値はオブジェクトであり、コンポーネントのすべてのインスタンスで共有されます。 たとえば、次のデータを持つ &lt;code&gt;TodoList&lt;/code&gt; コンポーネントを想像してください 。</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">それらが同じノード上にある場合、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも優先順位が高くなります。 つまり、ループの各反復は &lt;code&gt;v-if&lt;/code&gt; を個別に実行します。 これは、次のように、 &lt;em&gt;一部の&lt;/em&gt;アイテムのノードのみをレンダリングするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">このデータが変更されると、ビューが再レンダリングされます。 &lt;code&gt;data&lt;/code&gt; プロパティは、インスタンスの作成時に存在する場合にのみ&lt;strong&gt;反応&lt;/strong&gt;することに注意してください。 つまり、次のような新しいプロパティを追加する場合：</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">同じプラグインに対してこのメ​​ソッドが複数回呼び出された場合、プラグインは一度だけインストールされます。</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;同じタグ名を&lt;/strong&gt;持つ要素を切り替える&lt;strong&gt;場合&lt;/strong&gt; 、Vueに一意の &lt;code&gt;key&lt;/code&gt; 属性を与えて、それらが別個の要素であることを伝える必要があります。 それ以外の場合、Vueのコンパイラは、効率のために要素のコンテンツのみを置き換えます。 ただし、技術的に不要な場合でも&lt;strong&gt;、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネントに複数のアイテムをキー入力する&lt;/strong&gt;ことを&lt;strong&gt;常にお勧めします&lt;/strong&gt; &lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">小道具のバインドに使用する場合、小道具は子コンポーネントで適切に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">コンポーネントで使用される場合、 &lt;code&gt;v-model&lt;/code&gt; は代わりにこれを行います。</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">コンポーネントで使用される場合、 &lt;code&gt;v-on&lt;/code&gt; &lt;code&gt;$emit&lt;/code&gt; はそのコンポーネントによって送信されたカスタムイベントのみをリッスンします。 ルート要素でネイティブDOMイベントをリッスンするには、 &lt;code&gt;.native&lt;/code&gt; 修飾子を使用できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">通常の要素で使用される場合、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;ネイティブDOMイベント&lt;/strong&gt;&lt;/a&gt;のみをリッスンし&lt;strong&gt;ます&lt;/strong&gt; 。 カスタム要素コンポーネントで使用される場合、その子コンポーネントによって&lt;strong&gt;発行&lt;/strong&gt;される&lt;strong&gt;カスタムイベントを&lt;/strong&gt;リッスンします。</target>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用して要素/コンポーネントで使用されるv-forは、登録された参照がDOMノードまたはコンポーネントインスタンスを含む配列になります。</target>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; または &lt;code&gt;style&lt;/code&gt; 属性をバインドするために使用されるクラスは、配列やオブジェクトなどの追加の値タイプをサポートします。 詳細については、以下のリンクガイドのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; は&amp;lt;transition&amp;gt;とともに使用され、必ず内部にネストしてください。</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; をv-ifとともに使用すると、 &lt;code&gt;v-for&lt;/code&gt; の優先順位が &lt;code&gt;v-if&lt;/code&gt; よりも高くなります。 詳細については、 &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">v-ifとともに使用する場合、v-forの優先順位はv-ifよりも高くなります。 詳細については、 &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; をv-bindとともに使用すると、唯一のfalse値は &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 、および &lt;code&gt;false&lt;/code&gt; です。 これは、 &lt;code&gt;0&lt;/code&gt; および空の文字列がtrueとしてレンダリングされることを意味します。 したがって、たとえば、 &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; は &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; としてレンダリングされます 。</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">引数なしで使用すると、属性の名前と値のペアを含むオブジェクトをバインドするために使用できます。 このモードの &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; は、配列またはオブジェクトではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">ローカル登録を使用&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;する場合&lt;/a&gt; 、 &lt;code&gt;Promise&lt;/code&gt; を直接返す関数を提供することもできます。</target>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; または &lt;code&gt;vueify&lt;/code&gt; 、 &lt;code&gt;*.vue&lt;/code&gt; ファイル内のテンプレートは、ビルド時にJavaScriptにプリコンパイルされます。 最終的なバンドルには実際にコンパイラは必要ないため、ランタイムのみのビルドを使用できます。</target>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">JavaScriptのみの遷移を使用する場合&lt;strong&gt;、 &lt;code&gt;enter&lt;/code&gt; フックと &lt;code&gt;leave&lt;/code&gt; フックに&lt;/strong&gt; &lt;strong&gt;は &lt;code&gt;done&lt;/code&gt; コールバックが必要です&lt;/strong&gt; 。 それ以外の場合、フックは同期的に呼び出され、移行はすぐに終了します。</target>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">単一のファイルコンポーネントを使用する場合、コンポーネント内のCSSはJavaScriptを介して &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; タグとして動的に挿入されます。 これには実行時のコストがわずかであり、サーバー側のレンダリングを使用している場合、「スタイル設定されていないコンテンツのフラッシュ」が発生します。 すべてのコンポーネントのCSSを同じファイルに抽出すると、これらの問題が回避され、CSSの縮小とキャッシュが改善されます。</target>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vueを使用する場合は、ブラウザーに&lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;をインストールすることをお勧めします。 これにより、より使いやすいインターフェースでVueアプリケーションを検査およびデバッグできます。</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">WebpackやBrowserifyなどのビルドツールを使用する場合、プロダクションモードはVueソースコードの &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; によって決定され、デフォルトでは開発モードになります。 両方のビルドツールは、この変数をオーバーライドしてVueのプロダクションモードを有効にする方法を提供し、ビルド中に警告がミニファイアーによって削除されます。 すべての &lt;code&gt;vue-cli&lt;/code&gt; テンプレートにはこれらが事前構成されていますが、その方法を知っておくと役立ちます。</target>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">DOMでテンプレート（HTMLファイルに直接記述されたテンプレート）を使用する場合は、ブラウザが属性名を小文字に強制するため、大文字のキーの名前付けも避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">In-DOMテンプレートまたはIn-JavaScriptテンプレート文字列を使用する場合、テンプレートからレンダリング関数へのコンパイルはその場で実行されます。 通常、これはほとんどの場合十分に高速ですが、アプリケーションがパフォーマンスに敏感な場合は避けるのが最善です。</target>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">コンポーネント（つまり、 &lt;code&gt;new Vue&lt;/code&gt; 以外）で &lt;code&gt;data&lt;/code&gt; プロパティを使用する場合、値はオブジェクトを返す関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">ボタンをクリックすると、すべての投稿のテキストを拡大する必要があることを両親に伝える必要があります。 幸いなことに、Vueインスタンスはこの問題を解決するカスタムイベントシステムを提供します。 親は、ネイティブDOMイベントと同様 &lt;code&gt;v-on&lt;/code&gt; 、v-on、v-onを使用して、子コンポーネントインスタンスのイベントをリッスンすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; コンポーネントを定義するとき、次のように、 &lt;code&gt;data&lt;/code&gt; がオブジェクトに直接提供されないことに気付いたかもしれません。</target>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">動的コンポーネントにラップされると、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は非アクティブなコンポーネントインスタンスを破棄する代わりにキャッシュします。 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は抽象コンポーネントです。 DOM要素自体をレンダリングせず、コンポーネントの親チェーンに表示されません。</target>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Vueインスタンスを作成するとき、 &lt;strong&gt;optionsオブジェクト&lt;/strong&gt;を渡し&lt;strong&gt;ます&lt;/strong&gt; 。 このガイドのほとんどでは、これらのオプションを使用して目的の動作を作成する方法について説明します。 参照用に、 &lt;a href=&quot;../api/index#Options-Data&quot;&gt;APIリファレンスの&lt;/a&gt;オプションの完全なリストも参照できます。</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 、インデックスによってアイテムを直接設定します</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 小道具に基づいて見出しのみを生成するコンポーネントの使用を開始するとすぐにこれに到達します 。</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">よく見ると、これらのコンポーネントは実際にはレンダーツリーの子孫で&lt;em&gt;あり、&lt;/em&gt;祖先であることがわかります。これは逆説です。 このパラドックスは、コンポーネントを &lt;code&gt;Vue.component&lt;/code&gt; でグローバルに登録すると自動的に解決されます。 それがあなたなら、ここで読むのをやめることができます。</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">配列の長さを変更するには、たとえば、 &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">プレーンJavaScriptオブジェクトを &lt;code&gt;data&lt;/code&gt; オプションとしてVueインスタンスに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt; 、VueはObject.definePropertyを使用してすべてのプロパティをgetter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;/&lt;/a&gt; setterにObject.definePropertyします。 これはES5固有のshim機能ではないため、VueはIE8以前をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;Vue.component&lt;/code&gt; を使用してグローバルにコンポーネントを登録するVue.component、グローバルIDはコンポーネントの &lt;code&gt;name&lt;/code&gt; オプションとして自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">数値を更新すると、入力の下で変更がアニメーション化されます。 これは素晴らしいデモですが、有効なCSSカラーなど、数値として直接保存されないものはどうでしょうか？ Tween.jsと&lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.jsで&lt;/a&gt;これを実現する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; などの &lt;code&gt;v-bind:style&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;ベンダープレフィックス&lt;/a&gt;を必要とするCSSプロパティを使用する場合、Vueは適切なプレフィックスを自動的に検出し、適用されたスタイルに追加します。</target>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">カスタムコンポーネントで &lt;code&gt;class&lt;/code&gt; 属性を使用すると、それらのクラスがコンポーネントのルート要素に追加されます。 この要素の既存のクラスは上書きされません。</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">次のようなスロットでデータを使用する場合：</target>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">複数のスロットがある場合は、 &lt;em&gt;すべての&lt;/em&gt;スロットに対して &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; ベースの完全な構文を使用してください 。</target>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">同等の優れたオプションが複数ある場合、一貫性を確保するために任意の選択を行うことができます。 これらのルールは、受け入れ可能な各オプションを説明し、デフォルトのオプションを提案します。 これは、一貫した正当な理由がある限り、独自のコードベースで別の選択を自由に行えることを意味します。 正当な理由があります！ コミュニティの標準に適応することにより、次のことができます。</target>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">移行のどこから始めるべきですか？</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">Vueレンダリング関数は、プレーンなJavaScriptで何かを簡単に達成できる場合、独自の代替手段を提供しません。 たとえば、 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用するテンプレートの場合 ：</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">現在のVueインスタンスがサーバーで実行されているかどうか。</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">すべてのブログ投稿のフォントサイズを制御するためにテンプレートで使用されます。</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">以下を書くこともできます：</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">次のようになります。</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">使用されなくなった関数。 ほとんどは検索と置換によってアップグレードできますが、他の場合には数分かかることがあります。 現在、ベストプラクティスに従っていない場合、Vue 2.0はさらに強化されます。 これは長期的には良いことですが、重要な（おそらく期限切れの）リファクタリングを意味します。</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">どちらがレンダリングされます：</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">VueはReactのようにスケールアップしますが、jQueryのようにスケールダウンします。 開始するには、ページにスクリプトタグを1つドロップするだけです。</target>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">スペースを含まない属性値はHTMLで引用符で囲む必要はありませんが、この方法で&lt;em&gt;は&lt;/em&gt;スペースを&lt;em&gt;避け&lt;/em&gt;て属性値を読みにくくすることがよくあります。</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">ほとんどの場合、計算されたプロパティがより適切ですが、カスタムウォッチャーが必要になる場合があります。 Vueが &lt;code&gt;watch&lt;/code&gt; オプションを介してデータ変更に反応するより一般的な方法を提供するのはそのためです。 これは、データの変更に応じて非同期または高価な操作を実行する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">子コンポーネントに情報を渡すには、明示的に定義された小道具をお勧めしますが、コンポーネントライブラリの作成者は、コンポーネントが使用されるコンテキストを常に予測できるとは限りません。 そのため、コンポーネントは、コンポーネントのルート要素に追加された属性を受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">テンプレートはほとんどのコンポーネントで機能しますが、明らかにこれはコンポーネントの1つではありません。 &lt;code&gt;render&lt;/code&gt; 関数で書き直しましょう。</target>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">HTMLでリスナーを使用する理由</target>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">なぜキャッシュが必要なのですか？ 大きな配列をループして多くの計算を行う必要がある高価な計算プロパティ&lt;strong&gt;A&lt;/strong&gt;があるとします。 その後、 &lt;strong&gt;Aに&lt;/strong&gt;依存する他の計算されたプロパティが存在する場合があります&lt;strong&gt;。&lt;/strong&gt;キャッシュがなければ、 &lt;strong&gt;A&lt;/strong&gt;のゲッターを必要以上に実行します。 キャッシュが不要な場合は、代わりにメソッドを使用してください。</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">以下と同等です：</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">次のように評価されます。</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">代わりに定義：</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">高度なJavaScriptアプリケーションの領域に入るための &lt;code&gt;.vue&lt;/code&gt; コンポーネント。 つまり、いくつかの追加ツールを使用することをまだ学習していません。</target>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; および &lt;code&gt;$attrs&lt;/code&gt; 、属性を転送する要素を手動で決定できます。 これは&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本的なコンポーネントに&lt;/a&gt;しばしば望ましいです。</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">ビルドツールを使用する</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">コンポーネント付き</target>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">ES2015シンボルを &lt;code&gt;provide&lt;/code&gt; 、機能を提供し、オブジェクトを &lt;code&gt;inject&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">MobXを使用する</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">次のオプションは、オブジェクトベースの構文に使用できます。</target>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">PascalCaseを使用する</target>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">ケバブケース付き</target>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">1つの属性を追加して、特別なスタイルを追加せずに元の遷移を変更しました。</target>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">とはいえ、調査の多くはやや主観的であるため、一部のReactユーザーにとっては、比較がVueに偏っているように見えることは避けられません。 さまざまな技術的な好みの存在を認めながら、この比較は主に、顧客の好みが偶然一致する場合にVueがより適している理由を概説することを目的としています。</target>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">新しい移行システム&lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;により、コンポーネントを再利用可能な移行に使用できるようになりました&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">この知識があれば、開始したコンポーネントを終了できます。</target>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">子コンポーネント内では、このページで説明されている移行戦略と、Vueの&lt;a href=&quot;transitions&quot;&gt;ビルトイン移行システムが&lt;/a&gt;提供する移行戦略の任意の組み合わせを使用できます。 一緒に、達成できるものに制限はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">ビルドツールなし</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">うわー、これは非常に長いページです！ 2.0は完全に異なることを意味しますか？ 基礎をもう一度学ぶ必要がありますが、移行は事実上不可能ですか？</target>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">テスト可能なコンポーネントの作成</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">プラグインを書く</target>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">はい、Vueトランジションもデータ駆動型です！ 動的遷移の最も基本的な例は、 &lt;code&gt;name&lt;/code&gt; 属性を動的プロパティにバインドします。</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">Vueは、文字列、数値、配列、プレーンオブジェクトのいずれであっても、出力を自動的にフォーマットするため、実際にデバッグする必要はありません。 ただし、JavaScriptの &lt;code&gt;JSON.stringify&lt;/code&gt; とまったく同じ機能が必要な場合は、メソッドまたは計算プロパティで使用できます。</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">強制された値は、propで渡された値と区別する名前を付けることで、より明示的にする必要があります。</target>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt;からVNodeの配列として静的スロットのコンテンツにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">グローバルな &lt;code&gt;config.keyCodes&lt;/code&gt; オブジェクトを介して、 &lt;a href=&quot;../api/index#keyCodes&quot;&gt;カスタムキー修飾子のエイリアス&lt;/a&gt;を定義することもできます。</target>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">ミックスインをグローバルに適用することもできます。 注意して使用してください！ ミックスインをグローバルに適用すると、後で作成される&lt;strong&gt;すべての&lt;/strong&gt; Vueインスタンスに影響&lt;strong&gt;し&lt;/strong&gt;ます。 適切に使用すると、カスタムオプションの処理ロジックを挿入するために使用できます。</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">追加のグローバルプロパティとコンポーネントオプションを宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">JavaScriptフックを属性で定義することもできます。</target>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">また、v-onceディレクティブを使用して、データが変更されても更新されないワンタイム補間を実行できますが、これは同じノード上の他のバインディングにも影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">プロパティ名（キー）の2番目の引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">約束はファクトリ関数で返すこともできます。 そのため、Webpack 2およびES2015構文を使用すると、次のことができます。</target>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">次の属性を指定して、カスタム遷移クラスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">エントリー期間と終了期間に別々の値を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">inの代わりに区切り文字としてを使用することもできます。これにより、反復子のJavaScript構文に似たものになります。</target>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用して、オブジェクトのプロパティを反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、グローバル &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである&lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt;インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、グローバル &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである &lt;code&gt;vm.$set&lt;/code&gt; インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">グローバルな &lt;code&gt;Vue.set&lt;/code&gt; エイリアスである &lt;code&gt;vm.$set&lt;/code&gt; インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;propsData&lt;/code&gt; は、propsDataオプションを使用して、さまざまなプロップでレンダリング出力をアサートできます。</target>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">NPMパッケージのソースはcdn.jsdelivr.net/npm/vueにあります。</target>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">通常のプロパティと同様に、テンプレート内の計算されたプロパティにデータバインドできます。 &lt;code&gt;vm.reversedMessage&lt;/code&gt; がvm.messageに依存するVue vm.reversedMessageであるため、 &lt;code&gt;vm.message&lt;/code&gt; が変更されると、 &lt;code&gt;vm.reversedMessage&lt;/code&gt; に依存するすべてのバインディングが更新されます 。 そして、最良の部分は、この依存関係を宣言的に作成することです。 計算されたゲッター関数には副作用がないため、テストと理解が容易になります。</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">コンポーネントオプションでローカルフィルターを定義できます。</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">必要に応じて、これらのコネクタワードがコンポーネント名に含まれていることを確認できますが、順序は依然として重要です。</target>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">通常の要素と同様に、カスタムコンポーネントで &lt;code&gt;v-for&lt;/code&gt; を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt;を介して公開された有効なキー名は、ケバブケースに変換することにより、修飾子として直接使用できます。</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">スロットプロップが未定義の場合に使用するフォールバックを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">複数の列でソートすることもできます。</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Pue（以前のJade）などのプリプロセッサを使用して、Vueテンプレートを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">オブジェクトのフィールドを増やすことにより、クラスを切り替えることができます。 さらに、 &lt;code&gt;v-bind:class&lt;/code&gt; ディレクティブはプレーン &lt;code&gt;class&lt;/code&gt; 属性と共存できます。 したがって、次のテンプレートが提供されます。</target>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">完全なプログラミング言語（JavaScript）の力を活用してビューを作成します。 これには、一時変数、フロー制御、およびスコープ内のJavaScript値への直接参照が含まれます。</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">このフックでコンポーネントの状態を変更できます。 ただし、エラーがキャプチャされたときに他のコンテンツをショートさせる条件をテンプレートまたはレンダリング関数に含めることが重要です。 そうでない場合、コンポーネントは無限レンダーループにスローされます。</target>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">コンソールを開いて、サンプルvmを自分で試すことができます。 vm.reversedMessageの値は、常にvm.messageの値に依存します。</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">突然変異メソッドを呼び出すことにより、コンソールを開き、前の例の &lt;code&gt;items&lt;/code&gt; 配列を再生できます。 例： &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">オプションとしていくつかのオプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">に置き換えることができます：</target>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;スタイルガイド&lt;/a&gt;でコンポーネント名に関する他の推奨事項を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;ここで完全な例&lt;/a&gt;を見ることができます 。 &lt;code&gt;$parent&lt;/code&gt; を使用する$ parentの利点は&lt;em&gt;、&lt;/em&gt;子孫コンポーネントが &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; のインスタンス全体を公開せずに &lt;code&gt;getMap&lt;/code&gt; にアクセスできることです。 これにより、依存しているものを変更または削除することを恐れずに、子コンポーネントをより安全に開発し続けることができます。 これらのコンポーネント間のインターフェースは、 &lt;code&gt;props&lt;/code&gt; として定義されたままです。</target>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; はv-elseディレクティブを使用して、v-ifの「elseブロック」を示すことができます。</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; は、v-modelディレクティブを使用して、フォーム入力、テキスト領域、および選択要素の双方向データバインディングを作成できます。 入力タイプに基づいて要素を更新する正しい方法を自動的に選択します。 少し魔法ですが、 &lt;code&gt;v-model&lt;/code&gt; は基本的にユーザー入力イベントのデータを更新するための構文糖衣であり、いくつかのエッジケースに特別な注意を払っています。</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">次の修飾子を使用して、対応する修飾子キーが押されたときにのみマウスまたはキーボードイベントリスナーをトリガーできます。</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">次を使用できます。</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">次の方法で、ネストされた &lt;code&gt;userProfile&lt;/code&gt; オブジェクトに新しい &lt;code&gt;age&lt;/code&gt; プロパティを追加できます。</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">プログラムリスナーは両方の問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">次を使用できます。</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">あなたは書ける：</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">コンポーネントをテスト可能にするために、コンポーネントで特別なことをする必要はありません。 生のオプションをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">コンポーネント名を定義するとき、2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vueテンプレートが実際にコンパイルされ、関数をレンダリングすることを知りたい場合があります。 これは、通常は知る必要のない実装の詳細ですが、特定のテンプレート機能がどのようにコンパイルされるかを知りたい場合は興味深いかもしれません。 以下は、 &lt;code&gt;Vue.compile&lt;/code&gt; を使用してテンプレート文字列をライブコンパイルする小さなデモです。</target>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">あなたは疑問に思うかもしれません：</target>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vueコンポーネントは、 &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Webコンポーネント仕様の&lt;/a&gt;一部である&lt;strong&gt;カスタム要素&lt;/strong&gt;に非常に似ていることに気づいたかもしれません。 これは、Vueコンポーネントの構文が仕様に従って大まかにモデル化されているためです。 たとえば、Vueコンポーネントは&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt;を実装し、特別な属性です。 ただし、いくつかの重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">式メソッドを呼び出すことで同じ結果が得られることに気づいたかもしれません。</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">配列または&lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;オブジェクト&lt;/a&gt;を使用して変更検出アラートを検討したり、Vueの反応システムによって追跡されていない &lt;code&gt;data&lt;/code&gt; やその他の条件に依存したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">あなたはそれに気付くかもしれません：</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">なぜ &lt;code&gt;slots()&lt;/code&gt; と &lt;code&gt;children&lt;/code&gt; の両方が必要なのか疑問に思うかもしれません。 &lt;code&gt;slots().default&lt;/code&gt; は &lt;code&gt;children&lt;/code&gt; と同じではありませんか？ 場合によっては、はい、しかし次の子を持つ機能コンポーネントがある場合はどうでしょうか？</target>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">このイベントリスニングアプローチ全体が、「懸念の分離」という古き良き規則に違反していることを懸念するかもしれません。 すべてのVueハンドラー関数と式は、現在のビューを処理しているViewModelに緊密にバインドされているため、メンテナンスが困難です。 実際、 &lt;code&gt;v-on&lt;/code&gt; の使用にはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">この問題を解決するには、親にちなんで名付けられたディレクトリに子コンポーネントをネストします。 例えば：</target>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">別の方法でこの問題を解決することもできます。 すべての検索コンポーネントを検索ディレクトリの下にネストし、すべての構成コンポーネントを設定ディレクトリの下にネストします。 これらの理由から、このアプローチは非常に大きなアプリ（100以上のコンポーネントなど）に対してのみ検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">これにより、Vueが既存のDOMを破棄し、リスト全体を再レンダリングすると思われるかもしれませんが、残念ながらそうではありません。 Vueはスマートヒューリスティックを実装して、DOM要素の再利用を最大化します。 したがって、配列を重複オブジェクトを含む別の配列に置き換えることは非常に効率的な操作です。</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">通常、これらを使用する必要はありませんが、コンポーネントインスタンスのイベントを手動でリッスンする必要がある場合は使用できます。 また、コード編成ツールとしても役立ちます。 たとえば、このパターンはサードパーティのライブラリを統合するために一般的です。</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">ルーターのプロパティをVueインスタンスに渡します。</target>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; デフォルト値が「hello world」であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">まだプロップの元の値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">次を使用して新しいリアクティブプロパティを追加します。</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">次のように記述します。</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">以下を使用してください。</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">次のように更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">投稿を選択し、[ &lt;em&gt;アーカイブ&lt;/em&gt; ]タブに切り替えて投稿に戻ると、選択した投稿は表示されなくなります。 これは、新しいタブに切り替えるたびに、Vueが &lt;code&gt;currentTabComponent&lt;/code&gt; の新しいインスタンスを作成するためです。</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">これらの機能を調べるときに、 &lt;a href=&quot;events#Event-Modifiers&quot;&gt; &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;forms#Modifiers&quot;&gt; &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt;修飾子の他の例が後で表示されます。</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">次のように、 &lt;code&gt;v-bind&lt;/code&gt; を使用して動的に割り当てられた小道具も見ました：</target>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">インラインテンプレートは、VueがアタッチされるDOM要素内で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">x-templateは、VueがアタッチされるDOM要素の外部で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[]クエリ配列構文が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">コンポーネントオプションオブジェクト</target>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">データプロパティ。 デフォルト値の設定に使用されるpropを使用</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">文字列の配列、または</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">キーがローカルバインディング名であり、値が次のいずれかであるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">オブジェクト：</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">祖先コンポーネントは、提供されたプロパティを使用する子孫を知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">カスタムJavaScriptフック：</target>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">クラスをCSSトランジションとアニメーションに自動的に適用する</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">このデータの裏付け：</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">変更を加えずに、ほとんどのコミュニティコード例をコピーして貼り付けることができます</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">&lt;code&gt;checked&lt;/code&gt; およびラジオボタンは、checkedプロパティと &lt;code&gt;change&lt;/code&gt; イベントを使用します。</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">表示色</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">子孫コンポーネントは、挿入されたプロパティがどこから来たかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">次と同じことを行います。</target>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じイベントを公開します。</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; を除き、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じ小道具がリリースされます。</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">Vue 1.0と2.0の両方を完全にサポート</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。 新しく推奨される構文については、 &lt;a href=&quot;#Named-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。 新しく推奨される構文については、 &lt;a href=&quot;#Scoped-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">Animate.cssなどのサードパーティのCSSアニメーションライブラリを統合する</target>
        </trans-unit>
        <trans-unit id="640a88fb22096bdf6bd9b9dad17ad19528e33c74" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</source>
          <target state="translated">Velocity.jsなどのサードパーティのJavaScriptアニメーションライブラリを統合する</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="6ac4338bb79ac3c4906ce72bafa4a59d6e305be8" translate="yes" xml:space="preserve">
          <source>keep-alive</source>
          <target state="translated">keep-alive</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="1a12478dec83ed6e780245cdd0f96617dd7741bb" translate="yes" xml:space="preserve">
          <source>keyCodes</source>
          <target state="translated">keyCodes</target>
        </trans-unit>
        <trans-unit id="d1f56baedcca5a5064e2a4af53cc11a0ed1c0853" translate="yes" xml:space="preserve">
          <source>maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries</source>
          <target state="translated">コンパニオンライブラリによって処理されるルーティングやグローバルな状態管理などの懸念とともに、コアライブラリに集中してください</target>
        </trans-unit>
        <trans-unit id="b85dac7f646475d4018a5c35390352f94773c821" translate="yes" xml:space="preserve">
          <source>methods</source>
          <target state="translated">methods</target>
        </trans-unit>
        <trans-unit id="759733aacfdf4712b7e0071157fe636694093bf6" translate="yes" xml:space="preserve">
          <source>mixins</source>
          <target state="translated">mixins</target>
        </trans-unit>
        <trans-unit id="1d06a0d76f000e6edd18de492383983feefced4e" translate="yes" xml:space="preserve">
          <source>model</source>
          <target state="translated">model</target>
        </trans-unit>
        <trans-unit id="ce7af53b728aacb666b36f215a21ab0dd6a5bce4" translate="yes" xml:space="preserve">
          <source>mounted</source>
          <target state="translated">mounted</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="efa63f31b95d88d80597fd77df60f57d92b5656c" translate="yes" xml:space="preserve">
          <source>numbers and calculations</source>
          <target state="translated">数字と計算</target>
        </trans-unit>
        <trans-unit id="c4f9f9085b98cae6ac4e1ed2d080effcc14c1a1b" translate="yes" xml:space="preserve">
          <source>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</source>
          <target state="translated">多くの場合、少なくともVueの場合、新しい採用者はすでに好みのコーディングスタイルで使用されていることがわかります。</target>
        </trans-unit>
        <trans-unit id="06dc8f8ac9432bbb240e210daed5bff3b05abccb" translate="yes" xml:space="preserve">
          <source>optionMergeStrategies</source>
          <target state="translated">optionMergeStrategies</target>
        </trans-unit>
        <trans-unit id="5460c4665adcba7eae90a69c7fa5c8c721706518" translate="yes" xml:space="preserve">
          <source>or define a filter globally before creating the Vue instance:</source>
          <target state="translated">または、Vueインスタンスを作成する前にフィルターをグローバルに定義します。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="274a7e4ebee8f7f6dc6992677f3c27d94a3001cb" translate="yes" xml:space="preserve">
          <source>other base components, and</source>
          <target state="translated">その他の基本的なコンポーネント、および</target>
        </trans-unit>
        <trans-unit id="d8fd39d0bbdd2dcf322d8b11390a4c5825b11495" translate="yes" xml:space="preserve">
          <source>parent</source>
          <target state="translated">parent</target>
        </trans-unit>
        <trans-unit id="476ee0f6af1d78aa2a3d9a587e8d5ee7e31229f6" translate="yes" xml:space="preserve">
          <source>performance</source>
          <target state="translated">performance</target>
        </trans-unit>
        <trans-unit id="901b0f26761a219ec847f2e563ee7d645ffb0fe8" translate="yes" xml:space="preserve">
          <source>productionTip</source>
          <target state="translated">productionTip</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="9b653d2097967639889ca93223335f45baa750ff" translate="yes" xml:space="preserve">
          <source>propsData</source>
          <target state="translated">propsData</target>
        </trans-unit>
        <trans-unit id="009ec702007827315f19dc796c2a231a2e05c4dc" translate="yes" xml:space="preserve">
          <source>provide / inject</source>
          <target state="translated">オファー/インジェクション</target>
        </trans-unit>
        <trans-unit id="559d8d669c33e3c83eb857ddab7a7179a755573e" translate="yes" xml:space="preserve">
          <source>provide reactive and composable view components</source>
          <target state="translated">リアクティブで構成可能なビューコンポーネントを提供する</target>
        </trans-unit>
        <trans-unit id="69449f994d55805535b9e8fab16f6c39934e9ba4" translate="yes" xml:space="preserve">
          <source>ref</source>
          <target state="translated">ref</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="a0a5278a6cefc309b63b0c4c5fd7593743828a31" translate="yes" xml:space="preserve">
          <source>renderError</source>
          <target state="translated">renderError</target>
        </trans-unit>
        <trans-unit id="ceb562ce431745788c5bafaa3720a09b81bd457a" translate="yes" xml:space="preserve">
          <source>scope &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">スコープが&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0e973bd3838898bd325ed8ba837f26d730a7ed56" translate="yes" xml:space="preserve">
          <source>scope removed</source>
          <target state="translated">スコープが削除されました</target>
        </trans-unit>
        <trans-unit id="2a788a1972f648a6486eea37112a19c4fd342950" translate="yes" xml:space="preserve">
          <source>select fields use &lt;code&gt;value&lt;/code&gt; as a prop and &lt;code&gt;change&lt;/code&gt; as an event.</source>
          <target state="translated">選択フィールドは &lt;code&gt;value&lt;/code&gt; を小道具として使用し、 &lt;code&gt;change&lt;/code&gt; をイベントとして使用します 。</target>
        </trans-unit>
        <trans-unit id="b32285bf14101379e596fd61f24637951f17e78f" translate="yes" xml:space="preserve">
          <source>silent</source>
          <target state="translated">silent</target>
        </trans-unit>
        <trans-unit id="462854f9c73adf5f5d5c411adb6b929ecc19693a" translate="yes" xml:space="preserve">
          <source>slot</source>
          <target state="translated">slot</target>
        </trans-unit>
        <trans-unit id="d3ccd068b20d8bc8c899d2419acc4756a32eabf3" translate="yes" xml:space="preserve">
          <source>slot &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;廃止された&lt;/sup&gt;スロット</target>
        </trans-unit>
        <trans-unit id="1ac938ccaaee0471d9ba1ad826420fb07fe19599" translate="yes" xml:space="preserve">
          <source>slot deprecated</source>
          <target state="translated">廃止されたスロット</target>
        </trans-unit>
        <trans-unit id="9705201399b16c1d9892866519b1fde59ee14c4d" translate="yes" xml:space="preserve">
          <source>slot-scope &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;廃止された&lt;/sup&gt;スロットスコープ</target>
        </trans-unit>
        <trans-unit id="70251443cfbe27230429f393dbeeabf3a5a1141c" translate="yes" xml:space="preserve">
          <source>slot-scope deprecated</source>
          <target state="translated">廃止されたスロットスコープ</target>
        </trans-unit>
        <trans-unit id="3226ecbe650213a49cd03ae67140750e4f340083" translate="yes" xml:space="preserve">
          <source>template</source>
          <target state="translated">template</target>
        </trans-unit>
        <trans-unit id="77bc0357bd1e93d68d50895d6a8281eb11026db0" translate="yes" xml:space="preserve">
          <source>text and textarea elements use &lt;code&gt;value&lt;/code&gt; property and &lt;code&gt;input&lt;/code&gt; event;</source>
          <target state="translated">textおよびtextarea要素は、 &lt;code&gt;value&lt;/code&gt; プロパティと &lt;code&gt;input&lt;/code&gt; イベントを使用します 。</target>
        </trans-unit>
        <trans-unit id="26d762e47535d9d6a0e3b1ec719e818e5029f523" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;default&lt;/code&gt; property is used as fallback value</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; プロパティがフォールバック値として使用されます</target>
        </trans-unit>
        <trans-unit id="025b0f9e93dda2558b27a2297f4ef94cbbc066a0" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;from&lt;/code&gt; property is the key (string or Symbol) to search for in available injections, and</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; プロパティは、利用可能なインジェクションを検索するためのキー（文字列またはシンボル）です。</target>
        </trans-unit>
        <trans-unit id="cad1b9675290b91d92988abdefef24cfeea2451c" translate="yes" xml:space="preserve">
          <source>the custom element name to use in the template, and</source>
          <target state="translated">テンプレートで使用されるカスタム要素名、および</target>
        </trans-unit>
        <trans-unit id="b70d4d793e7c9fcdde8b56387ec8f9f5324536a6" translate="yes" xml:space="preserve">
          <source>the key (string or Symbol) to search for in available injections, or</source>
          <target state="translated">利用可能な注入を検索するキー（文字列または記号）、または</target>
        </trans-unit>
        <trans-unit id="771279a0962f67af2fa5fac029cdf6d9cedebe88" translate="yes" xml:space="preserve">
          <source>the name of a registered component, or</source>
          <target state="translated">登録されたコンポーネントの名前、または</target>
        </trans-unit>
        <trans-unit id="ab4b389f6b8b2c135e895d4f7ee4d31afb1a7b7b" translate="yes" xml:space="preserve">
          <source>the name of the variable containing the component options</source>
          <target state="translated">コンポーネントオプションを含む変数の名前</target>
        </trans-unit>
        <trans-unit id="cb42e295aed62d3d9b5bec47d01a8b0244b984bf" translate="yes" xml:space="preserve">
          <source>the positions of SVG nodes</source>
          <target state="translated">SVGノードの場所</target>
        </trans-unit>
        <trans-unit id="412017c454240f4269a3e3d69329a8001d1bc3a8" translate="yes" xml:space="preserve">
          <source>the sizes and other properties of elements</source>
          <target state="translated">要素サイズとその他のプロパティ</target>
        </trans-unit>
        <trans-unit id="bb128da92e34868c02da7d99c67f861bac948e2f" translate="yes" xml:space="preserve">
          <source>the value of &lt;code&gt;lovingVue&lt;/code&gt; will be passed to the &lt;code&gt;checked&lt;/code&gt; prop. The &lt;code&gt;lovingVue&lt;/code&gt; property will then be updated when &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; emits a &lt;code&gt;change&lt;/code&gt; event with a new value.</source>
          <target state="translated">&lt;code&gt;lovingVue&lt;/code&gt; の値は、 &lt;code&gt;checked&lt;/code&gt; 小道具に渡されます 。 次に、 &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; &lt;code&gt;lovingVue&lt;/code&gt; が &lt;code&gt;change&lt;/code&gt; イベントで新しい値を使用すると、lovingVueプロパティが更新されます。</target>
        </trans-unit>
        <trans-unit id="7a5ae87823ef730b40c73e6882ce9d81869d692b" translate="yes" xml:space="preserve">
          <source>to a definition like below in your &lt;code&gt;routes&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;routes&lt;/code&gt; 設定の定義に従うルート：</target>
        </trans-unit>
        <trans-unit id="9a356bc545ab21a71c127b739b139dcbccc68d5e" translate="yes" xml:space="preserve">
          <source>to access the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component may similarly use a &lt;code&gt;ref&lt;/code&gt; to provide access to specific elements inside it, such as:</source>
          <target state="translated">&lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; インスタンスにアクセスします。 これは、たとえば、プログラムが親からのこの入力に焦点を合わせている場合に便利です。 その場合、 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントも &lt;code&gt;ref&lt;/code&gt; を使用して、次のような特定の要素へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="8b44c248ec32b071a1a7aafa16b55a17a8feb834" translate="yes" xml:space="preserve">
          <source>to this:</source>
          <target state="translated">これに：</target>
        </trans-unit>
        <trans-unit id="b624aaa273eeda72c40e568d21fcbbeb5497dae7" translate="yes" xml:space="preserve">
          <source>to validate that the value of the &lt;code&gt;author&lt;/code&gt; prop was created with &lt;code&gt;new Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; プロパティの値が &lt;code&gt;new Person&lt;/code&gt; に対して作成されたことを確認します。</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="4652e1358ea64fd28779917099faee9815f39f5a" translate="yes" xml:space="preserve">
          <source>train your brain to more easily parse most of the community code you encounter</source>
          <target state="translated">遭遇するほとんどのコミュニティコードをより簡単に分析するように脳を訓練する</target>
        </trans-unit>
        <trans-unit id="56bf8ae82a107d348a5ad5b650394e3f79340670" translate="yes" xml:space="preserve">
          <source>transition</source>
          <target state="translated">transition</target>
        </trans-unit>
        <trans-unit id="0346b11d87b24e82ab5c649ad2ca732f998681d6" translate="yes" xml:space="preserve">
          <source>transition-group</source>
          <target state="translated">transition-group</target>
        </trans-unit>
        <trans-unit id="2439417750083132eec5533d66db361a6f33c86c" translate="yes" xml:space="preserve">
          <source>unit tested in isolation from your Vue code</source>
          <target state="translated">Vueコードとは無関係にテストされたユニット</target>
        </trans-unit>
        <trans-unit id="13a1891af75c642306a6b695377d16e4a91f0e1b" translate="yes" xml:space="preserve">
          <source>updated</source>
          <target state="translated">updated</target>
        </trans-unit>
        <trans-unit id="47c1dcbefaa84b21d8f1b4cacb6d96a2389f8d6c" translate="yes" xml:space="preserve">
          <source>use JavaScript to directly manipulate the DOM during transition hooks</source>
          <target state="translated">JavaScriptを使用して移行フック中にDOMを直接操作します</target>
        </trans-unit>
        <trans-unit id="2ffb3e7b8b54e93fa9c9e2c85136cd36872ebac8" translate="yes" xml:space="preserve">
          <source>used by other parts of your application, such as to validate the payload to an API endpoint</source>
          <target state="translated">APIエンドポイントへのペイロードの検証など、アプリケーションの他の部分で使用されます</target>
        </trans-unit>
        <trans-unit id="71e87a583e04a8c8e91247ed090ea050ff05d929" translate="yes" xml:space="preserve">
          <source>utilize a virtual DOM</source>
          <target state="translated">仮想DOMを使用する</target>
        </trans-unit>
        <trans-unit id="121c33ea7d2fbab17fddc40d29520aa060292a3f" translate="yes" xml:space="preserve">
          <source>v-bind</source>
          <target state="translated">v-bind</target>
        </trans-unit>
        <trans-unit id="61446caf9cec66418312b8afce77b95f760c1542" translate="yes" xml:space="preserve">
          <source>v-cloak</source>
          <target state="translated">v-cloak</target>
        </trans-unit>
        <trans-unit id="9211fc21d367807ce01b01aeaa155eceb994ff10" translate="yes" xml:space="preserve">
          <source>v-else</source>
          <target state="translated">v-else</target>
        </trans-unit>
        <trans-unit id="aad798ca5693051aa59b6d5515d414fb382e1b9d" translate="yes" xml:space="preserve">
          <source>v-else-if</source>
          <target state="translated">v-else-if</target>
        </trans-unit>
        <trans-unit id="d8d5f6f2691961dbe62b3963ea44db6840a098b2" translate="yes" xml:space="preserve">
          <source>v-for</source>
          <target state="translated">v-for</target>
        </trans-unit>
        <trans-unit id="1c21399d4bae3d211e796bf024c68edbb55e3bc3" translate="yes" xml:space="preserve">
          <source>v-html</source>
          <target state="translated">v-html</target>
        </trans-unit>
        <trans-unit id="da1ef073ed7cfaabd197c053859f5aa2996547bc" translate="yes" xml:space="preserve">
          <source>v-if</source>
          <target state="translated">v-if</target>
        </trans-unit>
        <trans-unit id="5c02585ece6d24ec42b855e409120cc1caeae510" translate="yes" xml:space="preserve">
          <source>v-if/v-else-if/v-else without key</source>
          <target state="translated">キーなしのV-if / v-else-if / v-else</target>
        </trans-unit>
        <trans-unit id="e6aa5be18818de68afb647ef7683640c0ccc6f9b" translate="yes" xml:space="preserve">
          <source>v-model</source>
          <target state="translated">v-model</target>
        </trans-unit>
        <trans-unit id="465db0034f4a4aa82a200f7a5acabc5c6dad8449" translate="yes" xml:space="preserve">
          <source>v-on</source>
          <target state="translated">v-on</target>
        </trans-unit>
        <trans-unit id="fb93d4822889186d62901f1d0c2937ba09afb073" translate="yes" xml:space="preserve">
          <source>v-once</source>
          <target state="translated">v-once</target>
        </trans-unit>
        <trans-unit id="8723014a826e07ee1d36588c6cd2790ee471ba3c" translate="yes" xml:space="preserve">
          <source>v-pre</source>
          <target state="translated">v-pre</target>
        </trans-unit>
        <trans-unit id="54272dd05aa79ca6da35bbefacf8c3d5701dea3b" translate="yes" xml:space="preserve">
          <source>v-show</source>
          <target state="translated">v-show</target>
        </trans-unit>
        <trans-unit id="285a211f0f9d5799f4ec4b2694fc5040a7a120fc" translate="yes" xml:space="preserve">
          <source>v-slot</source>
          <target state="translated">v-slot</target>
        </trans-unit>
        <trans-unit id="a3f5fd55c07ee5fe5da9b61ede51058b6932a8ba" translate="yes" xml:space="preserve">
          <source>v-text</source>
          <target state="translated">v-text</target>
        </trans-unit>
        <trans-unit id="9e8c4326a3e5802b6bd32bdeb38f5ea9b5029432" translate="yes" xml:space="preserve">
          <source>vm.$attrs</source>
          <target state="translated">vm.$attrs</target>
        </trans-unit>
        <trans-unit id="af70cd66d8f463ff0c1b87333de9f7abb083bbcb" translate="yes" xml:space="preserve">
          <source>vm.$children</source>
          <target state="translated">vm.$children</target>
        </trans-unit>
        <trans-unit id="92036bba3d6520305ca4419e64187c8bacb4d53b" translate="yes" xml:space="preserve">
          <source>vm.$data</source>
          <target state="translated">vm.$data</target>
        </trans-unit>
        <trans-unit id="0c6c5f8f8645a9e8953886d60d3d38fc9d7e3813" translate="yes" xml:space="preserve">
          <source>vm.$delete( target, propertyName/index )</source>
          <target state="translated">vm $ delete（ターゲット、propertyName /インデックス）</target>
        </trans-unit>
        <trans-unit id="85945dbc9f317e87e1ebe95aacd2d097e0aadd5e" translate="yes" xml:space="preserve">
          <source>vm.$delete()</source>
          <target state="translated">vm.$delete()</target>
        </trans-unit>
        <trans-unit id="494349fee667e22074020faf32a0d4824e463b58" translate="yes" xml:space="preserve">
          <source>vm.$destroy()</source>
          <target state="translated">vm.$destroy()</target>
        </trans-unit>
        <trans-unit id="eb3d8ad0a5a691e540f0cae8b5f4c35c39bed85b" translate="yes" xml:space="preserve">
          <source>vm.$el</source>
          <target state="translated">vm.$el</target>
        </trans-unit>
        <trans-unit id="01e0f31da340e252fe35bb687b3a8604096a8617" translate="yes" xml:space="preserve">
          <source>vm.$emit( eventName, [&amp;hellip;args] )</source>
          <target state="translated">vm $ emit（eventName、[&amp;hellip;args]）</target>
        </trans-unit>
        <trans-unit id="f7a594be4c584e06c7738c18556378cc4dca84e2" translate="yes" xml:space="preserve">
          <source>vm.$emit()</source>
          <target state="translated">vm.$emit()</target>
        </trans-unit>
        <trans-unit id="86a5433d32c4d79baf0873f0e23a3bf1d6a26d26" translate="yes" xml:space="preserve">
          <source>vm.$forceUpdate()</source>
          <target state="translated">vm.$forceUpdate()</target>
        </trans-unit>
        <trans-unit id="0cedbd040ea3774df4b69fa4ae663ee646bab0f3" translate="yes" xml:space="preserve">
          <source>vm.$isServer</source>
          <target state="translated">vm.$isServer</target>
        </trans-unit>
        <trans-unit id="05326313026d4f80968b293f9a29cb767e2674ca" translate="yes" xml:space="preserve">
          <source>vm.$listeners</source>
          <target state="translated">vm.$listeners</target>
        </trans-unit>
        <trans-unit id="baab4fd1f32671646717fa9dc37e706a4aa9fc7d" translate="yes" xml:space="preserve">
          <source>vm.$mount( [elementOrSelector] )</source>
          <target state="translated">vm $マウント（[elementOrSelector]）</target>
        </trans-unit>
        <trans-unit id="57b0780f274178234dca2bf0f994ee7dfc389a4e" translate="yes" xml:space="preserve">
          <source>vm.$mount()</source>
          <target state="translated">vm.$mount()</target>
        </trans-unit>
        <trans-unit id="5c40836793cc9b36ae1e44c2bf0c9d0973b1cb62" translate="yes" xml:space="preserve">
          <source>vm.$nextTick( [callback] )</source>
          <target state="translated">vm $ nextTick（[コールバック]）</target>
        </trans-unit>
        <trans-unit id="3f2f493de9594ab85ab997f6f445b21f8bf32608" translate="yes" xml:space="preserve">
          <source>vm.$nextTick()</source>
          <target state="translated">vm.$nextTick()</target>
        </trans-unit>
        <trans-unit id="c4320c5ab4595a1512d09e454b2afc1e30f53f99" translate="yes" xml:space="preserve">
          <source>vm.$off( [event, callback] )</source>
          <target state="translated">vm $ off（[イベント、コールバック]）</target>
        </trans-unit>
        <trans-unit id="8659b7c176051de19b834751c71d64c023e531f8" translate="yes" xml:space="preserve">
          <source>vm.$off()</source>
          <target state="translated">vm.$off()</target>
        </trans-unit>
        <trans-unit id="faeea08725a5801e45b45e8d9044c3d2edda645d" translate="yes" xml:space="preserve">
          <source>vm.$on( event, callback )</source>
          <target state="translated">vm $ on（イベント、コールバック）</target>
        </trans-unit>
        <trans-unit id="47dd05c213dfee7e3bf78c8e68b730713e6c7872" translate="yes" xml:space="preserve">
          <source>vm.$on()</source>
          <target state="translated">vm.$on()</target>
        </trans-unit>
        <trans-unit id="5ddf55fd8c65e0c64370564ac67c71a598011755" translate="yes" xml:space="preserve">
          <source>vm.$once( event, callback )</source>
          <target state="translated">vm $ once（イベント、コールバック）</target>
        </trans-unit>
        <trans-unit id="95a71f9912a16c82dc4a770971c999acc1c481a4" translate="yes" xml:space="preserve">
          <source>vm.$once()</source>
          <target state="translated">vm.$once()</target>
        </trans-unit>
        <trans-unit id="0413cd705f160430c6855f79f80a44ed08a489dc" translate="yes" xml:space="preserve">
          <source>vm.$options</source>
          <target state="translated">vm.$options</target>
        </trans-unit>
        <trans-unit id="513e55e5a687797c62836b5b87c3bc78152500fe" translate="yes" xml:space="preserve">
          <source>vm.$parent</source>
          <target state="translated">vm.$parent</target>
        </trans-unit>
        <trans-unit id="96a7cb38d4e51f5a9a8a6369eb2854d54f31fd3a" translate="yes" xml:space="preserve">
          <source>vm.$props</source>
          <target state="translated">vm.$props</target>
        </trans-unit>
        <trans-unit id="d07c6d69732e9d49ba257f3637d225a5aed4c96d" translate="yes" xml:space="preserve">
          <source>vm.$refs</source>
          <target state="translated">vm.$refs</target>
        </trans-unit>
        <trans-unit id="ddead883ad1628e96ca570e4221dfc38903f3db2" translate="yes" xml:space="preserve">
          <source>vm.$root</source>
          <target state="translated">vm.$root</target>
        </trans-unit>
        <trans-unit id="77be545f1df363cacfd93eb0c9831ef3c95102f4" translate="yes" xml:space="preserve">
          <source>vm.$scopedSlots</source>
          <target state="translated">vm.$scopedSlots</target>
        </trans-unit>
        <trans-unit id="445f58422508541995e32fe0dceb823dcbaaf2f3" translate="yes" xml:space="preserve">
          <source>vm.$set( target, propertyName/index, value )</source>
          <target state="translated">vm $セット（ターゲット、propertyName /インデックス、値）</target>
        </trans-unit>
        <trans-unit id="12697644997ccacfcfb893110ee18b99abc39f50" translate="yes" xml:space="preserve">
          <source>vm.$set()</source>
          <target state="translated">vm.$set()</target>
        </trans-unit>
        <trans-unit id="3e09115bb4ccfaa59031cd594a8725f9ddff4efe" translate="yes" xml:space="preserve">
          <source>vm.$slots</source>
          <target state="translated">vm.$slots</target>
        </trans-unit>
        <trans-unit id="0b7eb695b0a861c10e273101dd3381aea047bf00" translate="yes" xml:space="preserve">
          <source>vm.$watch( expOrFn, callback, [options] )</source>
          <target state="translated">vm $ watch（expOrFn、コールバック、[オプション]）</target>
        </trans-unit>
        <trans-unit id="fe0401584870a2346a744fe847cf8a6bd902dfbe" translate="yes" xml:space="preserve">
          <source>vm.$watch()</source>
          <target state="translated">vm.$watch()</target>
        </trans-unit>
        <trans-unit id="abc4eb915d83966c3c028e2808e22bda2146ff20" translate="yes" xml:space="preserve">
          <source>vue.common.js</source>
          <target state="translated">vue.common.js</target>
        </trans-unit>
        <trans-unit id="8bc5b029cab40d453cf86de8c720dd795e2a79c0" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.js</source>
          <target state="translated">vue.esm.browser.js</target>
        </trans-unit>
        <trans-unit id="d3ffd20876becca44053e10a61c39d904267ac9f" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.min.js</source>
          <target state="translated">vue.esm.browser.min.js</target>
        </trans-unit>
        <trans-unit id="c117006aa30745b1641f5393741c01bb708cc6db" translate="yes" xml:space="preserve">
          <source>vue.esm.js</source>
          <target state="translated">vue.esm.js</target>
        </trans-unit>
        <trans-unit id="3f7227146eb759f801a054462cc6de123c9a354c" translate="yes" xml:space="preserve">
          <source>vue.js</source>
          <target state="translated">vue.js</target>
        </trans-unit>
        <trans-unit id="99a1d389faffdd980b71470664af47bc6458b2b3" translate="yes" xml:space="preserve">
          <source>vue.min.js</source>
          <target state="translated">vue.min.js</target>
        </trans-unit>
        <trans-unit id="293bf1049872f5a192d03a09bffe06f69b51091d" translate="yes" xml:space="preserve">
          <source>vue.runtime.common.js</source>
          <target state="translated">vue.runtime.common.js</target>
        </trans-unit>
        <trans-unit id="4e9d385e35e8eca60fb7e6083bf2726bc638f977" translate="yes" xml:space="preserve">
          <source>vue.runtime.esm.js</source>
          <target state="translated">vue.runtime.esm.js</target>
        </trans-unit>
        <trans-unit id="2b84e57a624eece08bd137eb6a2c3e4c53c4e1a1" translate="yes" xml:space="preserve">
          <source>vue.runtime.js</source>
          <target state="translated">vue.runtime.js</target>
        </trans-unit>
        <trans-unit id="f4c3c79918026bc22af5b5db5c14b417b1839be0" translate="yes" xml:space="preserve">
          <source>vue.runtime.min.js</source>
          <target state="translated">vue.runtime.min.js</target>
        </trans-unit>
        <trans-unit id="bcbb79f097d6df57f152dc61e8151e0a00cefb2d" translate="yes" xml:space="preserve">
          <source>warnHandler</source>
          <target state="translated">warnHandler</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
        <trans-unit id="b84bfe360a66993ae5d35ff845e9df46ef696052" translate="yes" xml:space="preserve">
          <source>will be maintained for the foreseeable future</source>
          <target state="translated">予見可能な将来のために維持</target>
        </trans-unit>
        <trans-unit id="9d57f6d32929205f7b53a7328ce8817af26246a6" translate="yes" xml:space="preserve">
          <source>will render the fallback content, &amp;ldquo;Submit&amp;rdquo;:</source>
          <target state="translated">フォールバックコンテンツを「Submit」でレンダリングします。</target>
        </trans-unit>
        <trans-unit id="032b3d049c6766e15673ecd6348f41e6baaa865b" translate="yes" xml:space="preserve">
          <source>will render with a value of &amp;ldquo;bar&amp;rdquo; instead of &amp;ldquo;foo&amp;rdquo;. The same goes for a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; with existing content. Instead of:</source>
          <target state="translated">「foo」ではなく「bar」という値でレンダリングされます。 既存のコンテンツを含む &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; についても同様です。 の代わりに：</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
