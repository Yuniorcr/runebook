<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3b52d24461e93aad361aa8a10329f3c23cc49031" translate="yes">
          <source>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what&amp;rsquo;s currently available for Vue templates.</source>
          <target state="translated">JSXのツールサポート（リンティング、型チェック、エディターのオートコンプリートなど）は、Vueテンプレートで現在利用できるものよりもいくつかの点で高度です。</target>
        </trans-unit>
        <trans-unit id="da2a622928cb7fb2119351d71d4d29385b2f0b02" translate="yes">
          <source>The tree of DOM nodes for the HTML above looks like this:</source>
          <target state="translated">上記のHTMLのDOMノードのツリーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1e0938b17616f7c664547dd22e0644ffdf02a08b" translate="yes">
          <source>The use of &lt;code&gt;keyCode&lt;/code&gt; events &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;is deprecated&lt;/a&gt; and may not be supported in new browsers.</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; イベントの使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;は非推奨&lt;/a&gt;であり、新しいブラウザーではサポートされない場合があります。</target>
        </trans-unit>
        <trans-unit id="c973f4080ca50bd81b6cff2d0a6ded9905288da4" translate="yes">
          <source>The value of &lt;code&gt;slot-scope&lt;/code&gt; can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;) you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; in the expression, like so:</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; の値は、関数定義の引数位置に表示される有効なJavaScript式を受け入れることができます。 つまり、サポートされている環境（ &lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;最新のブラウザー&lt;/a&gt; ）では、次のように、式で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015構造&lt;/a&gt;化を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="44c95331b851049a94d5aa5d023b6e2ddaca60d8" translate="yes">
          <source>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</source>
          <target state="translated">回避策は、スペースや引用符のない式を使用するか、複雑な式を計算プロパティに置き換えることです。</target>
        </trans-unit>
        <trans-unit id="d02680275f323eda2de9d2d7078001372e594964" translate="yes">
          <source>Their names often include the name of an element they wrap (e.g. &lt;code&gt;BaseButton&lt;/code&gt;, &lt;code&gt;BaseTable&lt;/code&gt;), unless no element exists for their specific purpose (e.g. &lt;code&gt;BaseIcon&lt;/code&gt;). If you build similar components for a more specific context, they will almost always consume these components (e.g. &lt;code&gt;BaseButton&lt;/code&gt; may be used in &lt;code&gt;ButtonSubmit&lt;/code&gt;).</source>
          <target state="translated">それらの名前には、特定の目的のための要素（ &lt;code&gt;BaseIcon&lt;/code&gt; など ）が存在しない限り、ラップする要素の名前（ &lt;code&gt;BaseButton&lt;/code&gt; 、 &lt;code&gt;BaseTable&lt;/code&gt; など ）が含まれることがよくあります。 より具体的なコンテキストのために同様のコンポーネントを構築する場合、それらはほとんど常にこれらのコンポーネントを消費します（例えば、 &lt;code&gt;ButtonSubmit&lt;/code&gt; で &lt;code&gt;BaseButton&lt;/code&gt; が使用される場合があります）。</target>
        </trans-unit>
        <trans-unit id="cac8885ec5589429c1668b6076e0b655b65a0072" translate="yes">
          <source>Then a &lt;code&gt;tree-folder-contents&lt;/code&gt; component with this template:</source>
          <target state="translated">次に、このテンプレートを使用した &lt;code&gt;tree-folder-contents&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="12ff53d6c9683fe8bc4c3c3ebe06eaf2daa8b2b3" translate="yes">
          <source>Then add some classes when using it:</source>
          <target state="translated">次に、使用するときにいくつかのクラスを追加します。</target>
        </trans-unit>
        <trans-unit id="bdb3d0b6c8743a01fad092b8628997433e226d02" translate="yes">
          <source>Then changes to &lt;code&gt;b&lt;/code&gt; will not trigger any view updates. If you know you&amp;rsquo;ll need a property later, but it starts out empty or non-existent, you&amp;rsquo;ll need to set some initial value. For example:</source>
          <target state="translated">その後、 &lt;code&gt;b&lt;/code&gt; に変更しても、ビューの更新はトリガーされません。 後でプロパティが必要になることがわかっているが、空または存在しない場合は、初期値を設定する必要があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="d716ba19ef13983399aba7a4f9b4f99bdb1a5cc3" translate="yes">
          <source>Then define the components you&amp;rsquo;d like to use in a &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="translated">次に、 &lt;code&gt;components&lt;/code&gt; オプションで使用するコンポーネントを定義します。</target>
        </trans-unit>
        <trans-unit id="89b993f413d7a3516733e84da6538330a9b561e6" translate="yes">
          <source>Then import the component options along with Vue, and you can make many common assertions (here we are using Jasmine/Jest style &lt;code&gt;expect&lt;/code&gt; assertions just as an example):</source>
          <target state="translated">次に、Vueとともにコンポーネントオプションをインポートすると、多くの一般的なアサーションを作成できます（ここでは、例としてJasmine / Jestスタイルのアサーションを使用しています）。</target>
        </trans-unit>
        <trans-unit id="742a07eca2247a701f3fe69d736358f9945a7047" translate="yes">
          <source>Then in a template, you can use the new &lt;code&gt;v-focus&lt;/code&gt; attribute on any element, like this:</source>
          <target state="translated">次に、テンプレートで、次のように任意の要素で新しい &lt;code&gt;v-focus&lt;/code&gt; 属性を使用できます。</target>
        </trans-unit>
        <trans-unit id="d651621f023beec6364c642e7684b35f30f1b1df" translate="yes">
          <source>Then in any descendants, we can use the &lt;code&gt;inject&lt;/code&gt; option to receive specific properties we&amp;rsquo;d like to add to that instance:</source>
          <target state="translated">次に、任意の子孫で、 &lt;code&gt;inject&lt;/code&gt; オプションを使用して、そのインスタンスに追加する特定のプロパティを受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="07a1a769eabe4ce95fd548704bfe1a9036dff3fe" translate="yes">
          <source>Then in our components, we can use &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; to emit events, listen for events, and clean up event listeners, respectively:</source>
          <target state="translated">次に、コンポーネントで、 &lt;code&gt;$emit&lt;/code&gt; 、 &lt;code&gt;$on&lt;/code&gt; 、 &lt;code&gt;$off&lt;/code&gt; を使用して 、イベントの発行、イベントのリッスン、およびイベントリスナーのクリーンアップをそれぞれ実行できます。</target>
        </trans-unit>
        <trans-unit id="e5a24c495cff3ba785929f2d1f1232971575aecc" translate="yes">
          <source>Then in the template for &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;, you might have:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; のテンプレートには、次のものがあります。</target>
        </trans-unit>
        <trans-unit id="06c17e2b180b30e57b025d1baba4010bf150e5ff" translate="yes">
          <source>Then inside &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; you might find yourself reaching for a hack like this:</source>
          <target state="translated">次に、 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 内で、次のようなハックに手を伸ばすことになります。</target>
        </trans-unit>
        <trans-unit id="6cb73bd95447c7f774f020d38dc4e977b5d7f966" translate="yes">
          <source>Then switching the &lt;code&gt;loginType&lt;/code&gt; in the code above will not erase what the user has already entered. Since both templates use the same elements, the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; is not replaced - just its &lt;code&gt;placeholder&lt;/code&gt;.</source>
          <target state="translated">次に、上記のコードで &lt;code&gt;loginType&lt;/code&gt; を切り替えても、ユーザーが既に入力した内容は消去されません。 両方のテンプレートが同じ要素を使用するため、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; は置き換えられず、 &lt;code&gt;placeholder&lt;/code&gt; のみが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="6afded1525a7e22ff2f90a6400204ea03039f331" translate="yes">
          <source>Then the child component can emit an event on itself by calling the built-in &lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; method&lt;/a&gt;, passing the name of the event:</source>
          <target state="translated">次に、組み込みの&lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt; &lt;code&gt;$emit&lt;/code&gt; &lt;/strong&gt;メソッドを&lt;/a&gt;呼び出して、イベントの名前を渡すことにより、子コンポーネント自体でイベントを発行できます。</target>
        </trans-unit>
        <trans-unit id="fa6a05a02bb2743e63986fe5978b02e07581ae91" translate="yes">
          <source>Then the parent can listen to that event and update a local data property, if it wants to. For example:</source>
          <target state="translated">その後、親はそのイベントをリッスンし、必要に応じてローカルデータプロパティを更新できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="6a4b4fbfbeb2382afaa428f3aa7171b1ee657214" translate="yes">
          <source>Then the provided content will be rendered instead:</source>
          <target state="translated">次に、提供されたコンテンツが代わりにレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="894b33adf4423b8e17178e298c582eff7b692b2f" translate="yes">
          <source>Then the value will be passed as the first parameter of that method:</source>
          <target state="translated">次に、そのメソッドの最初のパラメーターとして値が渡されます。</target>
        </trans-unit>
        <trans-unit id="e40f0a46552f37df14dd5aec3ff5064babdeaea5" translate="yes">
          <source>Then want to render a component for each one:</source>
          <target state="translated">次に、各コンポーネントをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="e77b5195b094315391d1471e49e775352de3ff46" translate="yes">
          <source>Then when later accessing this property on a route, you will still go through meta. For example:</source>
          <target state="translated">その後、後でルート上のこのプロパティにアクセスするときに、メタを通過します。 例えば：</target>
        </trans-unit>
        <trans-unit id="db6fb96dd889a51b383d80ca6045c8aa43c69291" translate="yes">
          <source>Then when we listen to the event in the parent, we can access the emitted event&amp;rsquo;s value with &lt;code&gt;$event&lt;/code&gt;:</source>
          <target state="translated">次に、親でイベントをリッスンすると、発行されたイベントの値に &lt;code&gt;$event&lt;/code&gt; アクセスできます。</target>
        </trans-unit>
        <trans-unit id="eb930daa712d8e2eb8fe97e59c6f27531e9b1c3e" translate="yes">
          <source>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.</source>
          <target state="translated">その後、罪悪感やパフォーマンスの問題を心配することなく、Vueコードの記述を開始し、縮小版を実稼働環境に出荷することもできます。</target>
        </trans-unit>
        <trans-unit id="ebf3c9e7f553f2151cca31494ec2e2f25d6a17ab" translate="yes">
          <source>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</source>
          <target state="translated">次に、アルファベット順に並べ替えます。 DOMを更新するとき、Vueはレンダリングを最適化して、可能な限り安価なDOM突然変異を実行します。 つまり、最初のtodo要素を削除してから、リストの最後に再度追加します。</target>
        </trans-unit>
        <trans-unit id="60891cf748e8a5cfa058d96629753adac1a276a6" translate="yes">
          <source>Then you would now update it to:</source>
          <target state="translated">次に、次のように更新します。</target>
        </trans-unit>
        <trans-unit id="29dfab044dfc1294ff91b939dd91ab9260db5d9f" translate="yes">
          <source>Then you&amp;rsquo;ll need to import each component you&amp;rsquo;d like to use, before you locally register it. For example, in a hypothetical &lt;code&gt;ComponentB.js&lt;/code&gt; or &lt;code&gt;ComponentB.vue&lt;/code&gt; file:</source>
          <target state="translated">次に、ローカルに登録する前に、使用する各コンポーネントをインポートする必要があります。 たとえば、架空の &lt;code&gt;ComponentB.js&lt;/code&gt; または &lt;code&gt;ComponentB.vue&lt;/code&gt; ファイルの場合：</target>
        </trans-unit>
        <trans-unit id="4a02df39977359aa3a054dc03aa4a5ab9829f85e" translate="yes">
          <source>There also seem to be philosophical differences in the API design which if you&amp;rsquo;re curious, can be demonstrated by how each handles the creation of a &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;simple todo list&lt;/a&gt;. It&amp;rsquo;s definitely somewhat subjective, but many consider Vue&amp;rsquo;s API to be less complex and better structured.</source>
          <target state="translated">また、API設計には哲学的な違いがあるようです。好奇心が強いなら、それぞれが&lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;単純なtodoリストの&lt;/a&gt;作成をどのように処理するかによって実証できます。 確かにある程度主観的ですが、多くの人はVueのAPIはそれほど複雑ではなく、より構造化されていると考えています。</target>
        </trans-unit>
        <trans-unit id="00ee1410ff14873dae0595e837c501a60becd79c" translate="yes">
          <source>There are a few advantages:</source>
          <target state="translated">いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="a278039d12ee8bace65331079237ab972774e0f6" translate="yes">
          <source>There are also a few array-related caveats, which were discussed earlier in the &lt;a href=&quot;list#Caveats&quot;&gt;list rendering section&lt;/a&gt;.</source>
          <target state="translated">また、配列関連の注意事項もいくつかあります。これらについては、 &lt;a href=&quot;list#Caveats&quot;&gt;リストのレンダリングのセクション&lt;/a&gt;で説明しました。</target>
        </trans-unit>
        <trans-unit id="8355a914d86b23056657ff75f59f4f4811dbbe1e" translate="yes">
          <source>There are also other hooks which will be called at different stages of the instance&amp;rsquo;s lifecycle, such as &lt;a href=&quot;../api/index#mounted&quot;&gt;&lt;code&gt;mounted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#updated&quot;&gt;&lt;code&gt;updated&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt;. All lifecycle hooks are called with their &lt;code&gt;this&lt;/code&gt; context pointing to the Vue instance invoking it.</source>
          <target state="translated">また、インスタンスのライフサイクルのさまざまな段階で、たとえば、 &lt;a href=&quot;../api/index#mounted&quot;&gt; &lt;code&gt;mounted&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;../api/index#updated&quot;&gt; &lt;code&gt;updated&lt;/code&gt; &lt;/a&gt; 、destroyのように呼び出されるフックもあります。 すべてのライフサイクルフックは、呼び出し元のVueインスタンスを指す &lt;code&gt;this&lt;/code&gt; コンテキストで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="595e87e7a707cb9f54dea4bd06abe43f491c5b96" translate="yes">
          <source>There are cases however, particularly shared component libraries, when this &lt;em&gt;might&lt;/em&gt; be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</source>
          <target state="translated">ただし、特に共有コンポーネントライブラリが適切な場合&lt;em&gt;が&lt;/em&gt;あります。 たとえば、次の架空のGoogleマップコンポーネントのように、HTMLをレンダリングする代わりにJavaScript APIと対話する抽象コンポーネントでは：</target>
        </trans-unit>
        <trans-unit id="3876196be292a6f75aaef350c2cf3fa6064ad6ee" translate="yes">
          <source>There are cases when it&amp;rsquo;s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">コンテンツが提供されていない場合にのみレンダリングされるように、スロットのフォールバック（つまりデフォルト）コンテンツを指定すると便利な場合があります。 たとえば、 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; コンポーネントの場合：</target>
        </trans-unit>
        <trans-unit id="b097d3f1a1272b7a886d701f8e65981ad1d92968" translate="yes">
          <source>There are quite a few other directives, each with its own special functionality. For example, the &lt;code&gt;v-for&lt;/code&gt; directive can be used for displaying a list of items using the data from an Array:</source>
          <target state="translated">他にもかなりの数のディレクティブがあり、それぞれに特別な機能があります。 たとえば、 &lt;code&gt;v-for&lt;/code&gt; ディレクティブを使用して、配列のデータを使用してアイテムのリストを表示できます。</target>
        </trans-unit>
        <trans-unit id="301d312bbcc93ad24cc77d82516195cad4b40d9a" translate="yes">
          <source>There are six classes applied for enter/leave transitions.</source>
          <target state="translated">Enter / Leave遷移には6つのクラスが適用されます。</target>
        </trans-unit>
        <trans-unit id="68ec2c8ded7b22cd2bc4c88259f22e650546ce9b" translate="yes">
          <source>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the &lt;code&gt;data&lt;/code&gt; object is like the schema for your component&amp;rsquo;s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</source>
          <target state="translated">この制限の背後には技術的な理由があります-依存関係追跡システムのエッジケースのクラスを排除し、タイプチェックシステムでVueインスタンスをよりうまく動作させます。 ただし、コードの保守性に関しても重要な考慮事項があります。 &lt;code&gt;data&lt;/code&gt; オブジェクトは、コンポーネントの状態のスキーマのようなものです。 すべての事後対応プロパティを事前に宣言すると、コンポーネントコードを後で再確認したり、別の開発者が読んだりするときに理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="db30e092cad90bed9c249d97be67dad62ff063c2" translate="yes">
          <source>There are times when it&amp;rsquo;s useful to have multiple slots. For example, in a &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">複数のスロットがあると便利な場合があります。 たとえば、次のテンプレートを使用した &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="d66a662b2b692933bc8923306e3e5688421626cb" translate="yes">
          <source>There are two common cases where this can be tempting:</source>
          <target state="translated">これが魅力的な2つの一般的なケースがあります。</target>
        </trans-unit>
        <trans-unit id="4be534cacf73464a26b8c69ecc68abf4cebc095f" translate="yes">
          <source>There are usually two cases where it&amp;rsquo;s tempting to mutate a prop:</source>
          <target state="translated">通常、プロップを突然変異させたいと思う場合が2つあります。</target>
        </trans-unit>
        <trans-unit id="9a46df346eecefc8c5696a405d0623a7868c6f68" translate="yes">
          <source>There can still be one unnamed slot, which is the &lt;strong&gt;default slot&lt;/strong&gt; that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</source>
          <target state="translated">名前のないスロットが1つ残っている場合があります。これは、一致しないコンテンツのキャッチオールとして機能する&lt;strong&gt;デフォルトのスロットです&lt;/strong&gt; 。 上記の両方の例で、レンダリングされるHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="892e9605b3eb99a1e8758152c0f0d14bd50018ba" translate="yes">
          <source>There is also the &lt;code&gt;vm.$nextTick()&lt;/code&gt; instance method, which is especially handy inside components, because it doesn&amp;rsquo;t need global &lt;code&gt;Vue&lt;/code&gt; and its callback&amp;rsquo;s &lt;code&gt;this&lt;/code&gt; context will be automatically bound to the current Vue instance:</source>
          <target state="translated">また、 &lt;code&gt;vm.$nextTick()&lt;/code&gt; インスタンスメソッドもあります。これは、グローバル &lt;code&gt;Vue&lt;/code&gt; を必要とせず、そのコールバックの &lt;code&gt;this&lt;/code&gt; コンテキストが現在のVueインスタンスに自動的にバインドされるため、コンポーネント内で特に便利です。</target>
        </trans-unit>
        <trans-unit id="e795677faa92646e68896f4fa2d153d1c6b3dad9" translate="yes">
          <source>There is no direct &lt;code&gt;v-model&lt;/code&gt; counterpart in render functions - you will have to implement the logic yourself:</source>
          <target state="translated">レンダリング関数には、 &lt;code&gt;v-model&lt;/code&gt; 直接対応するものはありません。ロジックを自分で実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3dc3c28e5738e838da6dece3bd69b468532f5bd" translate="yes">
          <source>There is no longer a special API to initialize an app with Vue Router. That means instead of:</source>
          <target state="translated">Vue Routerでアプリを初期化する特別なAPIはもうありません。 次の代わりに：</target>
        </trans-unit>
        <trans-unit id="e786ab8525d61c08d5edd49d36eaafa66121f1c6" translate="yes">
          <source>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the &lt;code&gt;.native&lt;/code&gt; modifier for &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">コンポーネントのルート要素でネイティブイベントを直接リッスンしたい場合があります。 これらの場合、 &lt;code&gt;v-on&lt;/code&gt; に &lt;code&gt;.native&lt;/code&gt; 修飾子を使用できます。</target>
        </trans-unit>
        <trans-unit id="e13a2b6d1fa69f970582ef7c30a8696baaa1caf0" translate="yes">
          <source>There&amp;rsquo;s a lot you can do to help Vue grow in your community:</source>
          <target state="translated">コミュニティでVueを成長させるためにできることはたくさんあります。</target>
        </trans-unit>
        <trans-unit id="c70dcc11c00ce0163cd6cf08b8dae423423a248d" translate="yes">
          <source>There&amp;rsquo;s no longer a use case for this in the new Vue Router.</source>
          <target state="translated">新しいVueルーターには、この使用例はありません。</target>
        </trans-unit>
        <trans-unit id="163f368f2bf083cc1079a14cd05b50989be0cc02" translate="yes">
          <source>There&amp;rsquo;s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We&amp;rsquo;ll fix that later.</source>
          <target state="translated">この例には1つの問題があります。 アイテムを追加または削除すると、その周りのアイテムは、スムーズに移行するのではなく、即座に新しい場所にスナップします。 後で修正します。</target>
        </trans-unit>
        <trans-unit id="5d85fbe7675b4e4ec3b50bf7054fe53d2209ebb4" translate="yes">
          <source>There&amp;rsquo;s still one problem though. Try clicking the button below:</source>
          <target state="translated">ただし、まだ1つの問題があります。 下のボタンをクリックしてみてください。</target>
        </trans-unit>
        <trans-unit id="e6396f41a177bd681652c0e5df217826f32aabe7" translate="yes">
          <source>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;transitioned too&lt;/a&gt;:</source>
          <target state="translated">これらのFLIPアニメーションも、単一の軸に限定されません。 多次元グリッド内のアイテムも&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;遷移できます&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="101fa3129d0c59027806566e19bcb27a91fd6013" translate="yes">
          <source>These applications always include many in-DOM templates, where &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;kebab-case &lt;strong&gt;must&lt;/strong&gt; be used&lt;/a&gt;.</source>
          <target state="translated">これらのアプリケーションには、常に&lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;ケバブケースを使用する&lt;strong&gt;必要&lt;/strong&gt;がある&lt;/a&gt;多くのDOM内テンプレートが含まれています。</target>
        </trans-unit>
        <trans-unit id="79c4f8a294a999f0a432548c8b4a47252ba3a153" translate="yes">
          <source>These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</source>
          <target state="translated">これらは、大きなテンプレートを使用したデモや非常に小さなアプリケーションで役立ちますが、コンポーネント定義の残りの部分からテンプレートを分離するため、避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="4eda46855e3962039e549f3d03f1e9beb23fa48b" translate="yes">
          <source>These components are &lt;strong&gt;globally registered&lt;/strong&gt;. That means they can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created after registration. For example:</source>
          <target state="translated">これらのコンポーネントは&lt;strong&gt;グローバルに登録され&lt;/strong&gt;ます。 つまり、登録後に作成されたルートVueインスタンス（ &lt;code&gt;new Vue&lt;/code&gt; ）のテンプレートで使用できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="c11fba5bbbf86f45897e779c4584d6721b0b2522" translate="yes">
          <source>These components lay the foundation for consistent styling and behavior in your application. They may &lt;strong&gt;only&lt;/strong&gt; contain:</source>
          <target state="translated">これらのコンポーネントは、アプリケーションの一貫したスタイリングと動作の基盤を築きます。 次のもの&lt;strong&gt;のみを&lt;/strong&gt;含めることが&lt;strong&gt;でき&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c208483eb8caab5ce32ce55aa9ca8d4751b6d7ab" translate="yes">
          <source>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain &lt;strong&gt;one single expression&lt;/strong&gt;, so the following will &lt;strong&gt;NOT&lt;/strong&gt; work:</source>
          <target state="translated">これらの式は、所有者VueインスタンスのデータスコープでJavaScriptとして評価されます。 1つの制限として、各バインディングには&lt;strong&gt;1つの式&lt;/strong&gt;のみを含めることができるため、以下は機能し&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="894c317239a0c7a65a9e88455fd9ec3ef7ebc237" translate="yes">
          <source>These hooks can be used in combination with CSS transitions/animations or on their own.</source>
          <target state="translated">これらのフックは、CSSトランジション/アニメーションと組み合わせて、または単独で使用できます。</target>
        </trans-unit>
        <trans-unit id="18eb93efc44d56c2080356f2acd2adc1588f6912" translate="yes">
          <source>These limitations become apparent when designing a search indicator, like this one for example:</source>
          <target state="translated">これらの制限は、たとえば次のような検索インジケータを設計するときに明らかになります。</target>
        </trans-unit>
        <trans-unit id="44f058292bf91d7fdc0c19b30d4f231d10c8ffce" translate="yes">
          <source>These modifiers restrict the handler to events triggered by a specific mouse button.</source>
          <target state="translated">これらの修飾子は、特定のマウスボタンによってトリガーされるイベントにハンドラーを制限します。</target>
        </trans-unit>
        <trans-unit id="d2b0e629392045530844771affeff7b43f8ec099" translate="yes">
          <source>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</source>
          <target state="translated">これらのルールは、ほとんどのプロジェクトで読みやすさや開発者のエクスペリエンスを向上させることがわかっています。 コードに違反してもコードは引き続き実行されますが、違反はまれで正当なものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="91af92ef53fdf34200de7e0b28db35745ed2a1ae" translate="yes">
          <source>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</source>
          <target state="translated">これらのルールはエラーの防止に役立つため、すべてのコストをかけて学習し、順守します。 例外は存在する可能性がありますが、非常にまれであり、JavaScriptとVueの両方の専門知識を持つ者のみが作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e30564da6ab88875780c5728faa3632ae18dc83a" translate="yes">
          <source>These specific languages are only examples. You could as easily use Bubl&amp;eacute;, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with &lt;code&gt;vue-loader&lt;/code&gt;, it also has first-class support for CSS Modules.</source>
          <target state="translated">これらの特定の言語は単なる例です。 Bubl&amp;eacute;、TypeScript、SCSS、PostCSSなど、生産性を高める他のプリプロセッサを簡単に使用できます。 Webpackを &lt;code&gt;vue-loader&lt;/code&gt; とともに使用する場合、CSSモジュールのファーストクラスのサポートもあります。</target>
        </trans-unit>
        <trans-unit id="fdd9827028ef750f7255fe5fc506af18a8fb1368" translate="yes">
          <source>These will override the conventional class names. This is especially useful when you want to combine Vue&amp;rsquo;s transition system with an existing CSS animation library, such as &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;.</source>
          <target state="translated">これらは、従来のクラス名をオーバーライドします。 これは、Vueの移行システムを&lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;などの既存のCSSアニメーションライブラリと組み合わせる場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="a8d1026e768f545462812038bf11ac5597aa461a" translate="yes">
          <source>They document the API of the component, so that it&amp;rsquo;s easy to see how the component is meant to be used.</source>
          <target state="translated">コンポーネントのAPIが文書化されているため、コンポーネントがどのように使用されるのかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="ee9fb3a66c9bf09491269055d05e63e8daff7baf" translate="yes">
          <source>They have slightly different target users however.</source>
          <target state="translated">ただし、ターゲットユーザーは若干異なります。</target>
        </trans-unit>
        <trans-unit id="dddb496772a8230c124e4f06a214f032833805d2" translate="yes">
          <source>They may look a bit different from normal HTML, but &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</source>
          <target state="translated">見た目は通常のHTMLとは少し異なりますが、 &lt;code&gt;:&lt;/code&gt; および &lt;code&gt;@&lt;/code&gt; は属性名に有効な文字であり、Vueがサポートするすべてのブラウザーで正しく解析できます。 また、最終的なレンダリングマークアップには表示されません。 省略形の構文は完全にオプションですが、後でその使用法についてさらに学習するときに、この構文に感謝するでしょう。</target>
        </trans-unit>
        <trans-unit id="6a9f42e561d875ba212a21ce976d18f88707fb7e" translate="yes">
          <source>They&amp;rsquo;re also very useful as wrapper components. For example, when you need to:</source>
          <target state="translated">また、ラッパーコンポーネントとしても非常に便利です。 たとえば、必要な場合：</target>
        </trans-unit>
        <trans-unit id="36292b3c039d104e965d98c8c9a093ed70eee710" translate="yes">
          <source>This &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;prevents conflicts&lt;/a&gt; with existing and future HTML elements, since all HTML elements are a single word.</source>
          <target state="translated">これ&lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;は&lt;/a&gt; 、すべてのHTML要素が単一の単語であるため、既存および将来のHTML要素との競合を防ぎます。</target>
        </trans-unit>
        <trans-unit id="1ece11c20b0e27793001fdeec7df491259c0b914" translate="yes">
          <source>This allows us add behavior that a filter alone couldn&amp;rsquo;t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;&lt;code&gt;currencyValidator&lt;/code&gt; object&lt;/a&gt;:</source>
          <target state="translated">これにより、フィルターだけではカプセル化できない動作を追加できます。たとえば、フォーカスのある入力のコンテンツを選択します。 次のステップは、フィルターからビジネスロジックを抽出することです。 以下では、すべてを外部&lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt; &lt;code&gt;currencyValidator&lt;/code&gt; オブジェクトに&lt;/a&gt;引き出します 。</target>
        </trans-unit>
        <trans-unit id="74e149b933b7f933e9d6e2560dceac8830da4733" translate="yes">
          <source>This allows you to compose components like this:</source>
          <target state="translated">これにより、次のようなコンポーネントを構成できます。</target>
        </trans-unit>
        <trans-unit id="2b017e21cf180432f227f352528adf7beedafa7a" translate="yes">
          <source>This also means the following computed property will never update, because &lt;code&gt;Date.now()&lt;/code&gt; is not a reactive dependency:</source>
          <target state="translated">これは、 &lt;code&gt;Date.now()&lt;/code&gt; は事後の依存関係ではないため、次の計算されたプロパティが更新されないことも意味します。</target>
        </trans-unit>
        <trans-unit id="d966b066638dcbfbeb5f7c1fa054b2b9f4ac88e1" translate="yes">
          <source>This attribute does not support dynamic binding.</source>
          <target state="translated">この属性は動的バインディングをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="85db9f37abb47bdae5f9736eb1fa18d771e503d8" translate="yes">
          <source>This brings us full circle back to &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;, so if you&amp;rsquo;ve read this far it&amp;rsquo;s probably time to try it out!</source>
          <target state="translated">これで&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuexに&lt;/a&gt;完全に戻ることができるので、ここまで読んだなら、おそらく試してみる時間です！</target>
        </trans-unit>
        <trans-unit id="e208871e834d455a504dbc7b4789f62b8d51dbdf" translate="yes">
          <source>This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; to manage state in most cases.</source>
          <target state="translated">これは、デモや、少数のコンポーネントを持つ非常に小さなアプリに便利です。 ただし、このパターンは中規模または大規模のアプリケーションにうまく対応できないため、ほとんどの場合、 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;を使用して状態を管理することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="f3ae7f80927899cd62140ba3ac91c1a272907e8a" translate="yes">
          <source>This can be especially useful in combination with the &lt;code&gt;$attrs&lt;/code&gt; instance property, which contains the attribute names and values passed to a component, such as:</source>
          <target state="translated">これは、次のようなコンポーネントに渡される属性名と値を含む &lt;code&gt;$attrs&lt;/code&gt; インスタンスプロパティと組み合わせて使用​​すると特に便利です。</target>
        </trans-unit>
        <trans-unit id="dc35e91b7f0ddcd858a9ed54df8c331d12068bc2" translate="yes">
          <source>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, &lt;code&gt;v-slot&lt;/code&gt; without an argument is assumed to refer to the default slot:</source>
          <target state="translated">これはさらに短縮できます。 指定されていないコンテンツがデフォルトスロット用であると想定されるように、引数なしの &lt;code&gt;v-slot&lt;/code&gt; はデフォルトスロットを参照すると想定されます。</target>
        </trans-unit>
        <trans-unit id="e890dd0b9a03e7b18eb3ea7a9ab2b112967c585d" translate="yes">
          <source>This can be useful sometimes, but it&amp;rsquo;s not a good idea when you&amp;rsquo;re trying to listen on a very specific element, like an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. For example, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component above might refactor so that the root element is actually a &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">これは時々役立つ場合がありますが、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; のような非常に特定の要素をリッスンしようとするのは良い考えではありません。 たとえば、上記の &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントは、ルート要素が実際に &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 要素になるようにリファクタリングする場合があります。</target>
        </trans-unit>
        <trans-unit id="ef2288cfa9c5bb1049786a028d410bf6a81d1c49" translate="yes">
          <source>This can be useful when you&amp;rsquo;ve defined CSS transitions/animations using Vue&amp;rsquo;s transition class conventions and want to switch between them.</source>
          <target state="translated">これは、Vueの遷移クラス規則を使用してCSS遷移/アニメーションを定義し、それらを切り替える場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="22ed18f22c3147e4d4b605b99a8c886bf36867ed" translate="yes">
          <source>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. &lt;code&gt;user&lt;/code&gt; to &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">これにより、特にスロットが多くの小道具を提供する場合に、テンプレートがよりきれいになります。 また、小道具の名前を変更するなど、他の可能性も開きます。</target>
        </trans-unit>
        <trans-unit id="91d37bc2f925538550750ba2e9fce0b6e7858848" translate="yes">
          <source>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</source>
          <target state="translated">これは、特定のビューを強化するためだけにJavaScriptが使用される中小規模のプロジェクトで非常にうまく機能します。 ただし、より複雑なプロジェクトの場合、またはフロントエンドがJavaScriptによって完全に駆動される場合、これらの欠点が明らかになります。</target>
        </trans-unit>
        <trans-unit id="552c6085e6177cea581b90083d77773efb3e8be2" translate="yes">
          <source>This class is mostly useful for specifying the transition timing and easing curve, as you&amp;rsquo;ll see below:</source>
          <target state="translated">このクラスは、以下に示すように、遷移タイミングとイージングカーブを指定するのに最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="a64fb541d6cf03a309471b66f62b3cc4e9df105f" translate="yes">
          <source>This could be rewritten with JavaScript&amp;rsquo;s &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; in a render function:</source>
          <target state="translated">これはJavaScriptの &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; で書き換えられ、レンダリング関数に &lt;code&gt;map&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="dc281e6afa265cb93fadcfb1141b35d1dc6b8178" translate="yes">
          <source>This default mode is efficient, but &lt;strong&gt;only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)&lt;/strong&gt;.</source>
          <target state="translated">このデフォルトモードは効率的ですが&lt;strong&gt;、リストレンダリング出力が子コンポーネントの状態または一時的なDOM状態（フォーム入力値など）に依存していない場合にのみ適しています&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="83c6bcc5ab3c17077a142a2b9547158e591eb788" translate="yes">
          <source>This directive triggers transitions when its condition changes.</source>
          <target state="translated">このディレクティブは、条件が変わると遷移をトリガーします。</target>
        </trans-unit>
        <trans-unit id="bcf9f3835622e83dc060967041ab679cca48d307" translate="yes">
          <source>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt;, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</source>
          <target state="translated">このディレクティブは、関連するVueインスタンスがコンパイルを完了するまで要素に残ります。 &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt; などのCSSルールと組み合わせて、このディレクティブを使用して、Vueインスタンスの準備ができるまで、コンパイルされていない口ひげバインディングを非表示にすることができます。</target>
        </trans-unit>
        <trans-unit id="3e343af564058d721599d1f9e8b019d300435ac7" translate="yes">
          <source>This does not mean the component is only used in a single page, but it will only be used once &lt;em&gt;per page&lt;/em&gt;. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it&amp;rsquo;s a good indication that this is actually a reusable component that is only used once per page &lt;em&gt;for now&lt;/em&gt;.</source>
          <target state="translated">これは、コンポーネントが単一のページでのみ使用されることを意味するのではなく、ページ&lt;em&gt;ごとに1&lt;/em&gt;回のみ使用され&lt;em&gt;ます&lt;/em&gt; 。 これらのコンポーネントは、アプリ内のコンテキストではなく、アプリ固有のものであるため、決して小道具を受け入れません。 小道具を追加する必要がある場合、これは実際にはページごとに一度だけ使用される再利用可能なコンポーネントであることを示しています。</target>
        </trans-unit>
        <trans-unit id="045411f2b2e7825926721bc11467177b95eff687" translate="yes">
          <source>This even applies to all subcomponents, meaning all three of these components will also be available &lt;em&gt;inside each other&lt;/em&gt;.</source>
          <target state="translated">これはすべてのサブコンポーネントにも当てはまります。つまり、これらの3つのコンポーネントすべて&lt;em&gt;が相互&lt;/em&gt;に利用可能&lt;em&gt;に&lt;/em&gt;なります。</target>
        </trans-unit>
        <trans-unit id="82b2832a220d04d77924bc1b878abfa24eacde86" translate="yes">
          <source>This example demonstrates that we can bind data to not only text and attributes, but also the &lt;strong&gt;structure&lt;/strong&gt; of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply &lt;a href=&quot;guide/transitions&quot;&gt;transition effects&lt;/a&gt; when elements are inserted/updated/removed by Vue.</source>
          <target state="translated">この例は、テキストや属性だけでなく、DOMの&lt;strong&gt;構造&lt;/strong&gt;にもデータをバインドできることを示しています。 さらに、Vueは、エレメントがVueによって挿入/更新/削除されたときに自動的に&lt;a href=&quot;guide/transitions&quot;&gt;遷移効果を&lt;/a&gt;適用できる強力な遷移効果システムも提供します。</target>
        </trans-unit>
        <trans-unit id="28f4e1203d764412549f6b1974ffcd1631f009dd" translate="yes">
          <source>This gives you more complete control over the reactive properties you&amp;rsquo;d like to watch.</source>
          <target state="translated">これにより、視聴したい反応特性をより完全に制御できます。</target>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">これは、関数を受け入れる&lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; オプションに&lt;/a&gt;置き換えられたため、スクロール動作は完全にカスタマイズ可能です（ルートごとでも）。 これは多くの新しい可能性を開きますが、次の古い動作を再現します。</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">これは&lt;a href=&quot;../api/index#delimiters&quot;&gt;コンポーネントレベルのオプション&lt;/a&gt;として作り直されました。 これにより、サードパーティのコンポーネントを壊すことなく、アプリ内で代替の区切り文字を使用できます。</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">これはすぐに手に負えなくなりました。 そのため、子孫コンポーネントにコンテキスト情報を任意の深さで提供するのではなく、 &lt;a href=&quot;#Dependency-Injection&quot;&gt;依存性注入&lt;/a&gt;をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes">
          <source>This has two potential issues:</source>
          <target state="translated">これには2つの潜在的な問題があります。</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">これにより、編集または使用方法の確認が必要な場合に、コンポーネントをより迅速に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">このモジュール性の向上により、Vue 2への移行が容易になるだけでなく、通貨の解析と書式設定が可能になります。</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">これは不自然な例ですが、アプリを2つの小さなユニットに分割することができ、子はpropsインターフェイスを介して親から十分に分離されています。 親アプリに影響を与えることなく、より複雑なテンプレートとロジックを使用して &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; コンポーネントをさらに改善できます。</target>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">これは間違いなくガイドの中で書くのが最も難しいページですが、重要だと感じています。 オッズは、あなたが解決しようとした問題があり、別のライブラリを使用してそれらを解決したことです。 Vueが特定の問題をよりよく解決できるかどうかを知りたいので、ここにいます。 それはあなたのために答えたいと思うものです。</target>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">これは現在、 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;ルート定義のオプション&lt;/a&gt;です。 したがって、たとえば、更新します：</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">これは、エイリアスを&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;作成するルートの定義のオプションになり&lt;/a&gt;ました。 したがって、たとえば、更新します：</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; であっても、HTML入力要素の値は常に文字列を返すため、これはしばしば役立ちます。 &lt;code&gt;parseFloat()&lt;/code&gt; で値を解析できない場合、元の値が返されます。</target>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">これは、 &lt;a href=&quot;../guide/single-file-components&quot;&gt;単一ファイルコンポーネントに&lt;/a&gt;のみ関連します 。 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; 属性&lt;/a&gt;を使用する必要&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt; 。 スコーピングは、 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt; 、 &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;などのクラスベースの戦略、または別のライブラリ/コンベンションを介して行うことができます。</target>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;mixins&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">これは、グローバル &lt;code&gt;Vue.delete&lt;/code&gt; の &lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">これは、グローバル &lt;code&gt;Vue.set&lt;/code&gt; の &lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">これは低レベルに移行するコストですが、 &lt;code&gt;v-model&lt;/code&gt; と比較して、相互作用の詳細をはるかに制御することもできます。</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">これは、コンポーネントオプションに対して推奨されるデフォルトの順序です。 これらはカテゴリに分割されているため、カスタム属性とディレクティブを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">これは、コンポーネントオプションに対して推奨されるデフォルトの順序です。 カテゴリに分割されているため、プラグインから新しいプロパティを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">これは、Vue固有のコードの公式スタイルガイドです。 プロジェクトでVueを使用する場合、エラー、バイクの脱落、およびアンチパターンを回避するための優れたリファレンスです。 ただし、スタイルガイドがすべてのチームまたはプロジェクトに理想的であるとは考えていません。そのため、過去の経験、周囲の技術スタック、および個人的な価値観に基づいて、注意深い逸脱が推奨されます。</target>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes">
          <source>This is what an example looks like in action:</source>
          <target state="translated">これは、実際の例のようです。</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">ただし、これは必ずしも望ましいとは限らないため、Vueでは「これらの2つの要素は完全に分離されています。再利用しないでください」と言う方法を提供しています。 一意の値を持つ &lt;code&gt;key&lt;/code&gt; 属性を追加します。</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">次の結果になるため、これは推奨されません。</target>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">これにより、複数の条件付き子で &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">これにより、内部スタイルのオーバーライドが容易になります。人間が読み取れるクラス名は、あまり高い特異性を持ちませんが、競合が発生する可能性は非常に低いです。</target>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">このメソッドは、 &lt;code&gt;new Vue()&lt;/code&gt; 呼び出す前に呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">これは魔法のように思えるかもしれませんが、フードの下で、Vueは&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt;と呼ばれるアニメーション手法を使用して、変換を使用して要素を古い位置から新しい位置にスムーズに移行します。</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">これはコンポーネントを文書化するだけでなく、ユーザーが間違ったタイプを渡すとブラウザのJavaScriptコンソールで警告します。 このページのさらに下で&lt;a href=&quot;#Prop-Validation&quot;&gt;、型チェックやその他の小道具の検証&lt;/a&gt;について詳しく学習します。</target>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">Vueのトランジションシステムには、明示的に&lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; トランジションコントロール&lt;/a&gt;があるため、このオプションは不要になりました。</target>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">このページは、 &lt;a href=&quot;components&quot;&gt;コンポーネントの基本を&lt;/a&gt;すでに読んでいることを前提としています。 コンポーネントを初めて使用する場合は、最初にお読みください。</target>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">このペアのオプションを一緒に使用すると、同じ親チェーン内にある限り、コンポーネント階層の深さに関係なく、祖先コンポーネントをそのすべての子孫の依存関係インジェクターとして機能させることができます。 Reactに精通している場合、これはReactのコンテキスト機能に非常に似ています。</target>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">これにより、 &lt;code&gt;doc&lt;/code&gt; オブジェクトの各プロパティ（ &lt;code&gt;title&lt;/code&gt; など ）が個別のプロップとして渡され、各プロパティに &lt;code&gt;v-on&lt;/code&gt; 更新リスナーが追加されます。</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">このパターンにより、実際にルートにある要素を気にすることなく、未加工のHTML要素のようなベースコンポーネントを使用できます。</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">このパターンは、単純なシナリオで &lt;code&gt;$dispatch&lt;/code&gt; と &lt;code&gt;$broadcast&lt;/code&gt; 代わりとして使用できますが、より複雑な場合は、 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;などの専用の状態管理レイヤーを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションでは、 &lt;a href=&quot;components&quot;&gt;コンポーネントの&lt;/a&gt;知識を前提としています 。 スキップして後で戻ってください。</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションでは、 &lt;a href=&quot;components&quot;&gt;Vueコンポーネントの&lt;/a&gt;知識を前提としています 。 スキップして後で戻ってください。</target>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">これは常に &lt;code&gt;errorClass&lt;/code&gt; を適用しますが、 &lt;code&gt;isActive&lt;/code&gt; が真実の場合にのみ &lt;code&gt;activeClass&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">このような制限がある要素を持つコンポーネントを使用する場合、これは問題につながります。 例えば：</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes">
          <source>This will no longer work:</source>
          <target state="translated">これはもう機能しません：</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">これは、ブラウザがサポートする配列の最後の値のみをレンダリングします。 この例では、prefixedバージョンのflexboxをサポートするブラウザの &lt;code&gt;display: flex&lt;/code&gt; をレンダリングします 。</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">これにより、同じ結果がレンダリングされます。 オブジェクトを返す&lt;a href=&quot;computed&quot;&gt;計算プロパティに&lt;/a&gt;バインドすることもできます。 これは一般的で強力なパターンです。</target>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">これはうまく機能しますが、注意すべき点が1つあります。</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">これにより、ページの上部から要素200pxが固定されます。 しかし、上ではなく左から要素を固定する必要があるシナリオに遭遇した場合はどうなりますか？ コンポーネントインスタンスごとに更新できる動的な引数が非常に便利です。</target>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">したがって、親コンポーネントは、次を使用して &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 内の入力にフォーカスできます。</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes">
          <source>Tightly coupled component names</source>
          <target state="translated">密結合コンポーネント名</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">密結合コンポーネント名を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">この問題に対処するために、Vueは &lt;code&gt;v-on&lt;/code&gt; の &lt;strong&gt;イベント修飾子&lt;/strong&gt;を提供します。 修飾子はドットで示されるディレクティブの接尾辞であることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">オブジェクト内のネストされた値の変更も検出するには、options引数に &lt;code&gt;deep: true&lt;/code&gt; を渡す必要があります。 配列の変異をリッスンするために、その必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">ある定義では、アニメーション化するということは、生き返らせることを意味します。 残念ながら、デザイナーがアイコン、ロゴ、マスコットを作成するとき、それらは通常、画像または静的SVGとして配信されます。 そのため、GitHubのオクトキャット、Twitterの鳥、その他の多くのロゴは生き物に似ていますが、実際には生きているようには見えません。</target>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">リストを非表示にする必要がある場合にリストをレンダリングしないようにするには（例： &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ）。 これらの場合、 &lt;code&gt;v-if&lt;/code&gt; をコンテナ要素（ &lt;code&gt;ul&lt;/code&gt; 、 &lt;code&gt;ol&lt;/code&gt; など ）に移動します。</target>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">警告2に対処するには、 &lt;code&gt;splice&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">何が起こっているのかを説明するために、コンポーネントAとBを呼び出しましょう。モジュールシステムは、Aが必要ですが、最初にAがBを必要としますが、BはAを必要としますが、AはBを必要とします。最初に他のコンポーネントを解決することなく、いずれかのコンポーネントを完全に解決します。 これを修正するには、モジュールシステムに「Aは&lt;em&gt;最終的&lt;/em&gt;にBを必要としますが、最初にBを解決する必要はありません」と言うことができるポイントを与える必要があります。</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">リスト内のアイテムをフィルタリングするには（例： &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ）。 これらの場合、 &lt;code&gt;users&lt;/code&gt; をフィルター処理されたリストを返す新しい計算プロパティ（例： &lt;code&gt;activeUsers&lt;/code&gt; ）に置き換えます 。</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Vueの使用を開始するには、HTMLとES5 JavaScript（つまり、プレーンJavaScript）に精通していれば十分です。 これらの基本的なスキルを使用すると&lt;a href=&quot;../index&quot;&gt;、ガイド&lt;/a&gt;を読んでから 1日以内に重要なアプリケーションの構築を開始できます。</target>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vueが各ノードのIDを追跡できるようにヒントを提供し、既存の要素を再利用および並べ替えるには、各アイテムに一意の &lt;code&gt;key&lt;/code&gt; 属性を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">この問題を解決するために、 &lt;strong&gt;ストアパターンを&lt;/strong&gt;採用でき&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">プログラムリスナの詳細については、 &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;イベントインスタンスメソッドの&lt;/a&gt; APIをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">TypeScriptがVueコンポーネントオプション内の型を適切に推測できるようにするには、 &lt;code&gt;Vue.component&lt;/code&gt; または &lt;code&gt;Vue.extend&lt;/code&gt; でコンポーネントを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">ユーザーがアプリを操作できるようにするには、 &lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用して、Vueインスタンスのメソッドを呼び出すイベントリスナーをアタッチします。</target>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 親のスロットコンテンツで利用できるようにするために、 &lt;code&gt;user&lt;/code&gt; を属性として &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素にバインドできます 。</target>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">警告1を克服するには、次の両方で &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; と同じことを行いますが、反応性システムで状態の更新をトリガーします。</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">親から名前付きスロットにコンテンツを渡すには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; で特別な &lt;code&gt;slot&lt;/code&gt; 属性を使用します（ &lt;a href=&quot;#Named-Slots&quot;&gt;ここ&lt;/a&gt;で例として説明する &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; コンポーネントを使用）：</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">レンダリング関数を使用してスコープスロットを子コンポーネントに渡すには、VNodeデータの &lt;code&gt;scopedSlots&lt;/code&gt; フィールドを使用します。</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">名前付きスロットにコンテンツを提供するには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; で &lt;code&gt;v-slot&lt;/code&gt; ディレクティブを使用し、 v-slotの引数としてスロットの名前を提供します。</target>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">スロットに渡された小道具を受け取るために、親コンポーネントは &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; と &lt;code&gt;slot-scope&lt;/code&gt; 属性を使用できます（ &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; として&lt;a href=&quot;#Scoped-Slots&quot;&gt;ここで&lt;/a&gt;説明する&amp;lt;slot-example&amp;gt;を使用）：</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">スタイルをスコープするために、Vueは &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; などのコンポーネント要素に一意の属性を追加します。 次に、この属性を持つ一致する要素のみが選択されるようにセレクターが変更され &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; （例button [data-v-f3f3eg9] ）。</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">この問題を解決するために、Vueはコンポーネントで使用されているリスナーのオブジェクトを含む &lt;code&gt;$listeners&lt;/code&gt; プロパティを提供します。 例えば：</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">日付選択プラグインのテーマを指定するには、次のような特定のクラスを追加する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">プロパティの検証を指定するには、文字列の配列ではなく、オブジェクトに &lt;code&gt;props&lt;/code&gt; の値に対する検証要件を提供します。 例えば：</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Vue 2.0を使用してより堅牢なソリューションへの移行を開始するには、最初にこのフィルターを新しい &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; コンポーネントでラップしましょう。</target>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">これらのコンポーネントをテンプレートで使用するには、Vueがそれらについて認識できるように登録する必要があります。 コンポーネントの登録には、 &lt;strong&gt;グローバル&lt;/strong&gt;と&lt;strong&gt;ローカルの&lt;/strong&gt; 2つのタイプがあります。 これまで、 &lt;code&gt;Vue.component&lt;/code&gt; を使用してコンポーネントをグローバルに登録しただけです 。</target>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">式の値の真実性に基づいて、要素の &lt;code&gt;display&lt;/code&gt; CSSプロパティを切り替えます。</target>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes">
          <source>Tracking Runtime Errors</source>
          <target state="translated">実行時エラーの追跡</target>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">トランジション &lt;code&gt;stagger&lt;/code&gt; 属性が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes">
          <source>Transition Classes</source>
          <target state="translated">遷移クラス</target>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes">
          <source>Transition Modes</source>
          <target state="translated">移行モード</target>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes">
          <source>Transitioning Between Components</source>
          <target state="translated">コンポーネント間の移行</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes">
          <source>Transitioning Between Elements</source>
          <target state="translated">要素間の遷移</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">単一の要素/コンポーネントの移行</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">コンポーネント間の移行はさらに簡単です- &lt;code&gt;key&lt;/code&gt; 属性さえ必要ありません。 代わりに、 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;動的コンポーネント&lt;/a&gt;をラップします 。</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">遷移は、Vueのコンポーネントシステムを介して再利用できます。 再利用可能なトランジションを作成するには、ルートに &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; コンポーネントを配置し、トランジションコンポーネントに子を渡すだけです。</target>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes">
          <source>Transitions on Initial Render</source>
          <target state="translated">初期レンダリングの遷移</target>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes">
          <source>Translate Docs</source>
          <target state="translated">ドキュメントを翻訳</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">現在のインスタンスでイベントをトリガーします。 追加の引数は、リスナーのコールバック関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes">
          <source>Trigger transitions</source>
          <target state="translated">トリガー遷移</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; およびdestroyフックをトリガーします。</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; の真偽/偽造が &lt;sup&gt;変更されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimbaでこのレッスンをお試しください</target>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes">
          <source>Turn on Production Mode</source>
          <target state="translated">プロダクションモードをオンにする</target>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;交換された&lt;/sup&gt;双方向フィルター</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes">
          <source>Type Checks</source>
          <target state="translated">型チェック</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes">
          <source>TypeScript Support</source>
          <target state="translated">TypeScriptサポート</target>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">内部では、Vueはテンプレートをコンパイルして仮想DOMレンダリング関数にします。 反応性システムと組み合わせることで、Vueは最小限のコンポーネント数をインテリジェントに把握して、アプリの状態が変化したときに再レンダリングし、最小限のDOM操作を適用できます。</target>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">残念ながら、HTMLでは、カスタム要素を自己閉鎖にすることはできません。 &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;公式の「void」要素&lt;/a&gt;のみです。 そのため、VueのテンプレートコンパイラがDOMの前にテンプレートに到達し、DOM仕様に準拠したHTMLを提供できる場合にのみ戦略が可能です。</target>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">残念ながら、HTMLの大文字と小文字の区別がないため、DOMテンプレートは引き続きケバブケースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes">
          <source>Unit Testing</source>
          <target state="translated">単体テスト</target>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">コンポーネントを複数のファイルに分散しない限り（たとえば&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modulesを使用&lt;/a&gt; ）、ReactでのCSSのスコーピングはCSS-in-JSソリューション（ &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotionなど&lt;/a&gt; ）を介して行われます。 これにより、通常のCSSオーサリングプロセスとは異なる新しいコンポーネント指向のスタイリングパラダイムが導入されます。 さらに、ビルド時にCSSを単一のスタイルシートに抽出するサポートがありますが、スタイリングが適切に機能するためには、バンドルにランタイムを含める必要があることが一般的です。 スタイルの構築中にJavaScriptのダイナミズムにアクセスできますが、多くの場合、トレードオフはバンドルサイズとランタイムコストの増加です。</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; とは異なり、デフォルトでは &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; という実際の要素をレンダリングします。 &lt;code&gt;tag&lt;/code&gt; 属性を使用してレンダリングされる要素を変更できます。</target>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">コンポーネントや小道具とは異なり、イベント名は大文字小文字の自動変換を提供しません。 代わりに、発行されたイベントの名前は、そのイベントをリッスンするために使用される名前と正確に一致する必要があります。 たとえば、camelCasedイベント名を発行する場合：</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">コンポーネントや小道具とは異なり、イベント名はJavaScriptで変数名やプロパティ名として使用されることはないため、camelCaseやPascalCaseを使用する理由はありません。 さらに、DOMテンプレート内の &lt;code&gt;v-on&lt;/code&gt; イベントリスナーは自動的に小文字に変換されるため（HTMLの大文字と小文字が区別されないため）、 &lt;code&gt;v-on:myEvent&lt;/code&gt; は &lt;code&gt;v-on:myevent&lt;/code&gt; なり、 &lt;code&gt;myEvent&lt;/code&gt; をリッスンできなくなります。</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">1.xとは異なり、これらの &lt;code&gt;$refs&lt;/code&gt; は、レンダリングプロセス中に登録/更新されるため、リアクティブではありません。 それらをリアクティブにするには、変更ごとに重複したレンダリングが必要になります。</target>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">ネイティブDOMイベント専用の他の修飾子とは異なり、 &lt;code&gt;.once&lt;/code&gt; 修飾子は&lt;a href=&quot;components-custom-events&quot;&gt;コンポーネントイベントで&lt;/a&gt;も使用できます 。 コンポーネントについてまだ読んでいない場合は、今のところ心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0+で更新されました。 &lt;code&gt;slot-scope&lt;/code&gt; 属性を使用した非推奨の構文については、 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください 。</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0+で更新されました。 &lt;code&gt;slot&lt;/code&gt; 属性を使用した非推奨の構文については、 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください 。</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">要素の &lt;code&gt;innerHTML&lt;/code&gt; を更新します。 &lt;strong&gt;コンテンツはプレーンHTMLとして挿入されることに注意してください-Vueテンプレートとしてコンパイルされません&lt;/strong&gt; 。 &lt;code&gt;v-html&lt;/code&gt; を使用してテンプレートを作成しようとしている場合は、代わりにコンポーネントを使用してソリューションを再考してください。</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">要素の &lt;code&gt;textContent&lt;/code&gt; を更新します。 &lt;code&gt;textContent&lt;/code&gt; の一部を更新する必要がある場合は、 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 補間を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">これらすべてのノードを効率的に更新することは困難な場合がありますが、ありがたいことに、手動で更新する必要はありません。 代わりに、ページ内でテンプレートに必要なHTMLをVueに伝えます。</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes">
          <source>Upgrade Path</source>
          <target state="translated">アップグレードパス</target>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replaceを&lt;/a&gt;使用します 。</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodashの &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; （または&lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ）を使用して、高価なメソッドの呼び出しを直接制限します。 次のように上記と同じことを実現できます。</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">計算されたプロパティで&lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodashの &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; （または場合によっては&lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">代わりにルートで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">&lt;code&gt;$parent&lt;/code&gt; と &lt;code&gt;$children&lt;/code&gt; 控えめに使用してください-ほとんどがエスケープハッチとして機能します。 親子通信には小道具とイベントを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">代わりに &lt;code&gt;Array.prototype.splice&lt;/code&gt; を使用してください。 例えば：</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">代わりに &lt;code&gt;Vue.set&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScriptの組み込み&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScriptの組み込み&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">他のフックでカスタムDOMチェックを使用します。 たとえば、置き換えるには：</target>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes">
          <source>Use components instead.</source>
          <target state="translated">代わりにコンポーネントを使用してください。</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">グローバルミックスインは、サードパーティのコンポーネントを含む作成されたすべてのVueインスタンスに影響するため、まばらに慎重に使用してください。 ほとんどの場合、上記の例で示したようなカスタムオプション処理にのみ使用する必要があります。 また、アプリケーションの重複を避けるために、 &lt;a href=&quot;plugins&quot;&gt;プラグイン&lt;/a&gt;として出荷することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Vue.use()&lt;/code&gt; グローバルメソッドを呼び出してプラグインを使用します。 これは、 &lt;code&gt;new Vue()&lt;/code&gt; 呼び出してアプリを起動する前に実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">最適なデバッグエクスペリエンスを&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;得る&lt;/a&gt;には、 Vue Devtoolsを使用してください。</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、 &lt;code&gt;created&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">代わりに、コンポーネントの&lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt;またはdestroyフックを使用してください。</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes">
          <source>Use the native DOM API:</source>
          <target state="translated">ネイティブDOM APIを使用します。</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">代わりに、新しい &lt;code&gt;beforeCreate&lt;/code&gt; フックを使用します。これは基本的に同じものです。 他のライフサイクルメソッドとの一貫性のために名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、新しい &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">代わりに、新しい &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。 しかし、 &lt;code&gt;mounted&lt;/code&gt; では、ドキュメント内にあるという保証はありません。 そのためには、 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; も含めます。 例えば：</target>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;動的コンポーネントに&lt;/a&gt;使用され&lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;、DOM内テンプレートの制限を&lt;/a&gt;回避するために使用されます 。</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">子コンポーネントに挿入されたコンテンツで使用され、コンテンツが属する名前付きスロットを示します。</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素をスコープ付きスロットとして示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">スコープスロットとして要素またはコンポーネントを示すために使用されます。 属性の値は、関数シグネチャの引数位置に表示できる有効なJavaScript式である必要があります。 つまり、サポートされている環境では、式でES2015構造化を使用することもできます。 2.5.0以降では、 &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt;代替として機能します。</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;スコープスロット&lt;/a&gt;にプログラムでアクセスするために使用されます 。 &lt;code&gt;default&lt;/code&gt; スロットを含む各スロットのオブジェクトには、VNodeを返す対応する関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;スロットによって配信される&lt;/a&gt;コンテンツにプログラムでアクセスするために使用されます 。 各&lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;名前付きスロットに&lt;/a&gt;は、対応する独自のプロパティがあります（たとえば、 &lt;code&gt;v-slot:foo&lt;/code&gt; 内容は &lt;code&gt;vm.$slots.foo&lt;/code&gt; ）。 &lt;code&gt;default&lt;/code&gt; プロパティには、名前付きスロットに含まれていないノードまたは &lt;code&gt;v-slot:default&lt;/code&gt; コンテンツが含まれます 。</target>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">追加の引数で &lt;code&gt;$emit&lt;/code&gt; を使用する ：</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">イベント名のみで &lt;code&gt;$emit&lt;/code&gt; を使用する ：</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; 属性の使用も許可されています。</target>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">&lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; ように、 &lt;code&gt;v-bind.sync&lt;/code&gt; をリテラルオブジェクトで使用すると、このような複雑な式を解析する際に考慮すべきエッジケースが多すぎるため、機能しません。 。</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">&lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; を使用して、レンダリング中にアクティブなユーザー&lt;em&gt;のみを&lt;/em&gt;反復処理するため、レンダリングがより効率的になります。</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を一緒に使用することは&lt;strong&gt;お勧めしません&lt;/strong&gt; 。 詳細については、 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">コンポーネントでの &lt;code&gt;v-model&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes">
          <source>Using JavaScript Expressions</source>
          <target state="translated">JavaScript式を使用する</target>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">トランジションとアニメーションを一緒に使用する</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes">
          <source>Using a Plugin</source>
          <target state="translated">プラグインを使用する</target>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes">
          <source>Using an injected value as data entry:</source>
          <target state="translated">挿入された値をデータ入力として使用：</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">挿入された値をプロップのデフォルトとして使用する：</target>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">&lt;code&gt;$listeners&lt;/code&gt; プロパティを使用して、 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; を使用して、コンポーネントのすべてのイベントリスナーを特定の子要素に転送できます。 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; のような要素で、 &lt;code&gt;v-model&lt;/code&gt; も使用したい場合、以下の &lt;code&gt;inputListeners&lt;/code&gt; のような、リスナー用の新しい計算プロパティを作成すると便利です。</target>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#Other-Examples&quot;&gt;ここ&lt;/a&gt;で例として説明した &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; を使用して、 &lt;code&gt;slot-scope&lt;/code&gt; を使用した同等の使用法を次に示します 。</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 属性を使用すると、入力のリアルタイム状態にアクセスできなくなるため、「入力中」状態を検出する方法はありません。 ただし、デバウンス機能をVueからデカップリングすることで、制限する操作のみをデバウンスすることができ、開発可能な機能の制限がなくなります。</target>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">この戦略を使用すると、いくつかの入力要素でPikadayを使用することもでき、各新しいインスタンスは自動的にクリーンアップされます。</target>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">ただし、通常は、すべての小道具を特定のタイプの値にする必要があります。 これらの場合、プロパティの名前と値にそれぞれプロパティ名とタイプが含まれるオブジェクトとして、プロパティをリストできます。</target>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes">
          <source>VNode Interface</source>
          <target state="translated">VNodeインターフェイス</target>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodeは一意である必要があります</target>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes">
          <source>Value Bindings</source>
          <target state="translated">値のバインド</target>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;によるビデオ。 Vue Masteryの無料の&lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Vue入門コースをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">博物館&lt;em&gt;への&lt;/em&gt;訪問者</target>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue（ &lt;strong&gt;view&lt;/strong&gt;と同様に/vjuː/と発音）は、ユーザーインターフェイスを構築するための&lt;strong&gt;プログレッシブフレームワーク&lt;/strong&gt;です。 他のモノリシックフレームワークとは異なり、Vueは徐々に採用できるようにゼロから設計されています。 コアライブラリはビューレイヤーのみに焦点を当てており、他のライブラリや既存のプロジェクトを簡単に選択して統合できます。 一方、Vueは、 &lt;a href=&quot;guide/single-file-components&quot;&gt;モダンツール&lt;/a&gt; と &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;サポートライブラリ&lt;/a&gt; を組み合わせて、洗練されたシングルページアプリケーションを完全に機能させることができます。</target>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vueは、 &lt;strong&gt;仮想DOM&lt;/strong&gt;を構築して実際のDOMに対して行う必要がある変更を追跡することでこれを実現します。 この行を詳しく見てみましょう：</target>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vueは、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; の &lt;code&gt;passive&lt;/code&gt; オプションに&lt;/a&gt;対応する &lt;code&gt;.passive&lt;/code&gt; 修飾子も提供します 。</target>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vueは、フォーム入力とアプリの状態の間の双方向バインディングを簡単にする &lt;code&gt;v-model&lt;/code&gt; ディレクティブも提供します。</target>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vueが役立ちます。 SVGは単なるデータであるため、これらのクリーチャーが興奮、思考、または警戒したときにどのように見えるかの例のみが必要です。 次に、Vueはこれらの状態間の移行を支援し、ウェルカムページ、読み込みインジケーター、および通知をより感情的に説得力のあるものにします。</target>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vueコンポーネントは、プレーンなカスタム要素では利用できない重要な機能を提供します。最も顕著なのは、クロスコンポーネントデータフロー、カスタムイベント通信、ビルドツールの統合です。</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vueは、IE8ではシム化できないECMAScript 5機能を使用するため、IE8以下をサポートしませ&lt;strong&gt;ん&lt;/strong&gt; 。 ただし、 &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5に準拠&lt;/a&gt;したすべてのブラウザーをサポートしています 。</target>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vueでは、既に作成されたインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。 ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加できます。 たとえば、次の場合：</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vueでは、既に作成されたインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。 ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加することができます。</target>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vueは、Vueインスタンスのデータの変更を監視し、それに反応するより一般的な方法を提供します： &lt;strong&gt;プロパティを監視します&lt;/strong&gt; 。 他のデータに基づいて変更する必要があるデータがある場合、特にAngularJSのバックグラウンドから来ている場合は、 &lt;code&gt;watch&lt;/code&gt; を使いすぎてしまいがちです。 ただし、多くの場合、命令的な &lt;code&gt;watch&lt;/code&gt; コールバックではなく、計算されたプロパティを使用することをお勧めします。 この例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vueは、非同期キューイングを備えた透過的な依存関係追跡監視システムを使用しているため、この問題はまったくありません。明示的な依存関係がない限り、すべての変更は独立してトリガーされます。</target>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vueは従来のWebテクノロジーを採用し、その上に構築します。 それが何を意味するかを示すために、いくつかの例に飛び込みます。</target>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vueでは、ディレクティブとコンポーネントが明確に分離されています。 ディレクティブはDOM操作のみをカプセル化することを目的としていますが、コンポーネントは独自のビューとデータロジックを持つ自己完結型のユニットです。 AngularJSでは、ディレクティブはすべてを実行し、コンポーネントは特定の種類のディレクティブにすぎません。</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vueはすでに世界中に広がっており、コアチームでさえ少なくとも半ダースのタイムゾーンにあります。 &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラムに&lt;/a&gt;は7つの言語とカウントが含まれており、ドキュメントの多くは&lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;翻訳&lt;/a&gt;を積極的に管理しています 。 私たちはVueの国際的な展開を非常に誇りに思っていますが、さらに改善することができます。</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vueはパフォーマンスが向上しており、ダーティチェックを使用しないため、最適化がはるかに簡単です。 ウォッチャーが多い場合、AngularJSは遅くなります。スコープ内の何かが変更されるたびに、これらすべてのウォッチャーを再評価する必要があるためです。 また、一部のウォッチャーが別の更新をトリガーした場合、ダイジェストサイクルを複数回実行して「安定化」する必要があります。 AngularJSユーザーは、多くの場合、難解なテクニックに頼ってダイジェストサイクルを回避する必要があり、状況によっては、多くのウォッチャーでスコープを最適化する方法がありません。</target>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vueは、 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Webコンポーネントの仕様ドラフト&lt;/a&gt;に触発されたコンテンツ配信APIを実装し、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を使用してコンテンツの配信手段として機能します。</target>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vueは&lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt;および&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt;でも利用可能です（cdnjsは同期に時間がかかるため、最新リリースがまだ利用できない可能性があります）。</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">VueはAngularよりも意見が少なく、さまざまなビルドシステムの公式サポートを提供します。アプリケーションの構造に制限はありません。 多くの開発者はこの自由を享受していますが、一部の開発者はアプリケーションを構築する正しい方法を1つだけ持つことを好みます。</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vueは、AngularJSよりもAPIと設計の両方の点ではるかに単純です。 自明でないアプリケーションを構築するのに十分な学習は、通常1日未満で完了します。これは、AngularJSには当てはまりません。</target>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vueは、いつトランジションが終了したかを知るためにイベントリスナーをアタッチする必要があります。 適用されるCSSルールのタイプに応じて、 &lt;code&gt;transitionend&lt;/code&gt; または &lt;code&gt;animationend&lt;/code&gt; のいずれかになります。 どちらか一方のみを使用している場合、Vueは正しいタイプを自動的に検出できます。</target>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vueには &lt;code&gt;transition&lt;/code&gt; ラッパーコンポーネントが用意されており、次のコンテキストで任意の要素またはコンポーネントの移行の開始/終了を追加できます。</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vueは、DOMにアイテムを挿入、更新、または削除するときにトランジション効果を適用するさまざまな方法を提供します。 これには次のツールが含まれます。</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vueは、レガシーブラウザーのサポートに必要な場合、最も一般的に使用されるキーコードのエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vueは、意欲的なシングルページアプリケーションをすばやく構築するための&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;公式CLI&lt;/a&gt;を提供します。 最新のフロントエンドワークフロー用のバッテリーを含むビルドセットアップを提供します。 ホットリロード、リントオンセーブ、および本番対応のビルドで起動して実行するのに数分しかかかりません。 詳細について&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;は、Vue CLIドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vueは、プレーンなJavaScriptオブジェクトと完全に自動化された計算プロパティに対して控えめな反応性を提供します。 Emberでは、すべてをEmberオブジェクトでラップし、計算されたプロパティの依存関係を手動で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vueでは、ほとんどの場合、テンプレートを使用してHTMLを構築することをお勧めします。 ただし、JavaScriptの完全なプログラム機能を本当に必要とする場合があります。 そこで、テンプレートに代わるコンパイラに近い&lt;strong&gt;レンダー関数&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vueは、可能な限り効率的に要素をレンダリングしようとします。多くの場合、ゼロからレンダリングする代わりにそれらを再利用します。 Vueを非常に高速にするだけでなく、これにはいくつかの有用な利点があります。 たとえば、ユーザーに複数のログインタイプの切り替えを許可する場合：</target>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vueは &lt;code&gt;_&lt;/code&gt; プレフィックスを使用して独自のプライベートプロパティを定義するため、同じプレフィックス（たとえば &lt;code&gt;_update&lt;/code&gt; ）を使用するとインスタンスプロパティが上書きされるリスクがあります。 チェックしてもVueが現在特定のプロパティ名を使用していない場合でも、以降のバージョンで競合が発生しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vueは、ターゲット要素にCSSトランジションまたはアニメーションが適用されているかどうかを自動的に検出します。 存在する場合、CSS遷移クラスは適切なタイミングで追加/削除されます。</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vueは、観測された配列の突然変異メソッドをラップして、ビューの更新もトリガーします。 ラップされたメソッドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vueのコミュニティは信じられないほど急速に成長しています。これを読んでいるなら、参加する準備ができている可能性が十分にあります。 だから&amp;hellip;ようこそ！</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vueのテンプレート構文はJavaScript式のすべての機能を利用しますが、Handlebarsの式とヘルパー構文は比較において意図的にかなり制限されています。</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vueの移行システムは大幅に変更されており、 &lt;code&gt;transition&lt;/code&gt; 属性ではなく &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; ラッパー要素を使用しています。 詳細については、新しい&lt;a href=&quot;transitions&quot;&gt;移行ガイド&lt;/a&gt;を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vueの移行システムは、入場、退場、リストをアニメーション化する多くの簡単な方法を提供しますが、データ自体のアニメーション化はどうですか？ 例えば：</target>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile（テンプレート）</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component（id、[definition]）</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete（target、propertyName / index）</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive（id、[definition]）</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extend（options）</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter（id、[definition]）</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.jsでは、一般的なテキスト形式の適用に使用できるフィルターを定義できます。 フィルターは2つの場所で使用できます： &lt;strong&gt;口ひげ補間と &lt;code&gt;v-bind&lt;/code&gt; 式&lt;/strong&gt; （後者は2.1.0+でサポートされています）。 フィルターは、「パイプ」記号で示されるJavaScript式の最後に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.jsはHTMLベースのテンプレート構文を使用しており、レンダリングされたDOMを基になるVueインスタンスのデータに宣言的にバインドできます。 すべてのVue.jsテンプレートは、仕様に準拠したブラウザーおよびHTMLパーサーで解析できる有効なHTMLです。</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin（mixin）</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick（[コールバック、コンテキスト]）</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable（オブジェクト）</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set（target、propertyName / index、value）</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes">
          <source>Vue.use( plugin )</source>
          <target state="translated">Vue.use（プラグイン）</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0がリリースされましたが、このガイドでは1.0への移行についてのみ説明していますか？ それはタイプミスですか？ また、Vuex 1.0と2.0が同時にリリースされたようです。 どうしたの？ どちらを使用する必要があり、Vue 2.0と互換性がありますか？</target>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Vue Schoolの無料レッスンを見る</target>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Vue Masteryの無料ビデオコースを見る</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Vue Schoolで無料のビデオコースを見る</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Vue Schoolで無料のビデオレッスンを見る</target>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Vue Masteryのビデオ説明を見る</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Vueインスタンスの式または計算された関数の変更を監視します。 コールバックは、新しい値と古い値で呼び出されます。 この式は、ドット区切りのパスのみを受け入れます。 より複雑な式の場合は、代わりに関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">ウォッチャーを使用すると、数値プロパティの変更を別のプロパティにアニメーション化できます。 抽象的には複雑に聞こえるかもしれませんが、 &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;を使用した例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">&lt;code&gt;vm.$watch&lt;/code&gt; を介して作成されたウォッチャーは、関連するコンポーネントが再レンダリングされる前に起動されるようになりました。 これにより、コンポーネントが再レンダリングされる前に状態をさらに更新できるため、不必要な更新が回避されます。 たとえば、コンポーネントの小道具を監視し、小道具が変更されたときにコンポーネント自体のデータを更新できます。</target>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">また、偏見を避けるために一生懸命努力しています。 コアチームとして、私たちは明らかにVueが大好きです。 そこにある他の何よりも良く解決できると思ういくつかの問題があります。 私たちがそれを信じなかったなら、私たちはそれに取り組んでいないでしょう。 ただし、公正かつ正確になりたいと考えています。 Reactの代替レンダラーの広大なエコシステムやKnockoutのブラウザーサポートがIE6に戻るなど、他のライブラリーが大きな利点を提供する場合は、これらも一覧表示しようとします。</target>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">この手法を以前の実装と組み合わせて、リストに対するあらゆる可能な変更をアニメーション化できます！</target>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; をカスタム入力で直接使用できるようになりました。これは通常の入力との一貫性が高いだけでなく、コンポーネントがVuexに対応していることを意味します。</target>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; のリストを適用するために、配列をv-bind：classに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">オブジェクトを &lt;code&gt;v-bind:class&lt;/code&gt; に渡して、 クラスを動的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; ディレクティブを使用して、配列に基づいてアイテムのリストをレンダリングできます。 &lt;code&gt;v-for&lt;/code&gt; ディレクティブには、 &lt;code&gt;item in items&lt;/code&gt; のitemの形式の特別な構文が必要です 。itemsはソースデータ配列で、 &lt;code&gt;item&lt;/code&gt; は反復される配列要素の&lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用して、DOMイベントをリッスンし、トリガーされたときにJavaScriptを実行できます。</target>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">この単一のイベントハブを使用して、コンポーネント間の通信を管理できます。</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">&lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;コンポーネント間の移行&lt;/a&gt;については後で説明しますが、 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; を使用してraw要素間を移行することもできます 。 最も一般的な2要素遷移の1つは、リストコンテナと空のリストを説明するメッセージの間です。</target>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes">
          <source>We get similar benefits from updating:</source>
          <target state="translated">更新から同様の利点が得られます。</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes">
          <source>We get the following benefits:</source>
          <target state="translated">次の利点があります。</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">新しいAngularは、AngularJSとはまったく異なるフレームワークであるため、別のセクションがあります。 たとえば、一流のコンポーネントシステムを備えており、多くの実装の詳細が完全に書き直されており、APIも大幅に変更されています。</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">初めてのVueアプリを作成しました！ これは文字列テンプレートのレンダリングと非常に似ていますが、Vueは内部で多くの作業を行っています。 データとDOMがリンクされ、すべてが&lt;strong&gt;リアクティブになりました&lt;/strong&gt; 。 どうやって知るの？ ブラウザーのJavaScriptコンソール（このページ）を &lt;code&gt;app.message&lt;/code&gt; 、 app.messageを別の値に設定します。 それに応じて、上記のレンダリングされた例が更新されるはずです。</target>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">サーバーレンダリングされたVueアプリケーションを作成するためのスタンドアロンガイドを作成しました。 これは、クライアント側のVue開発、サーバー側のNode.js開発、およびwebpackに既に精通している人向けの非常に詳細なガイドです。 &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.orgで&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">ほとんどの場合、テキスト「Submit」を &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 内にレンダリングする必要がある場合があります。 フォールバックコンテンツを「送信」するには、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; タグの間に配置します。</target>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">このフォールバックコンテンツを置き換えて、次のように、姓ではなくユーザーの名を表示することができます。</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">このコンポーネントを再利用して、ユーザーが複数のリストを維持できるようにすることもできます（ショッピング、ウィッシュリスト、日課など）。 ただし、問題があります。 コンポーネントのすべてのインスタンスは同じデータオブジェクトを参照するため、1つのリストのタイトルを変更すると、他のすべてのリストのタイトルも変更されます。 Todoの追加/編集/削除についても同様です。</target>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">引数を括弧で囲み、引数をコンマで区切ります：</target>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">また、JavaScriptの世界は急速に変化しているため、このドキュメントを最新の状態に保つために&lt;strong&gt;ご&lt;/strong&gt;協力&lt;strong&gt;ください&lt;/strong&gt; 。 不正確な点や不正確な点に気付いた場合は&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;、問題を開い&lt;/a&gt;てお知らせください。</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">VNodeについて&lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;は&lt;/a&gt; 、 後で &lt;a href=&quot;render-function&quot;&gt;レンダリング関数&lt;/a&gt;について説明するときに詳しく説明します 。</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">次のセクションでは、これらのフック（つまり、 &lt;code&gt;el&lt;/code&gt; 、 &lt;code&gt;binding&lt;/code&gt; 、 &lt;code&gt;vnode&lt;/code&gt; 、および &lt;code&gt;oldVnode&lt;/code&gt; ）に渡される引数を調べます。</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">&lt;a href=&quot;components&quot;&gt;コンポーネントシステム&lt;/a&gt;については、後で詳しく説明します。 今のところ、すべてのVueコンポーネントもVueインスタンスであるため、同じオプションオブジェクトを受け入れます（いくつかのルート固有のオプションを除く）。</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">私たちは単に各言語の規約に従っています。 JavaScript内では、camelCaseはより自然です。 HTML内では、kebab-caseはそうです。</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">ただし、フィルタと一般的なVue 1.0によってまだ制限されているため、Vue 2.0へのアップグレードを完了しましょう。</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Vue.jsコアの最も基本的な機能を簡単に紹介しました-このガイドの残りの部分では、Vue.jsコアとその他の高度な機能について詳細に説明しますので、必ずすべて読んでください！</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes">
          <source>What About Separation of Concerns?</source>
          <target state="translated">懸念の分離はどうですか？</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes">
          <source>What You Can Do</source>
          <target state="translated">できること</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; が実際に返すものは何ですか？ これは実際のDOM要素ではありません。 おそらく、より正確に &lt;code&gt;createNodeDescription&lt;/code&gt; という名前を付けることができます。これには、子ノードの説明など、ページ上でレンダリングする必要のあるノードの種類を説明する情報が含まれているためです。 このノード記述を「仮想ノード」と呼び、通常は&lt;strong&gt;VNodeと&lt;/strong&gt;略され&lt;strong&gt;ます&lt;/strong&gt; 。 「仮想DOM」は、Vueコンポーネントのツリーによって構築されたVNodeのツリー全体と呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes">
          <source>What is Vue.js?</source>
          <target state="translated">Vue.jsとは何ですか？</target>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; に複数の子がある場合、最終的には単一の子に評価されるはずです。 最初の子以外の子は無視されます。</target>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">&lt;code&gt;isActive&lt;/code&gt; が真の場合、レンダリングされるHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isActive&lt;/code&gt; または &lt;code&gt;hasError&lt;/code&gt; が変更されると、それに応じてクラスリストが更新されます。 たとえば、 &lt;code&gt;hasError&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; になった場合、クラスリストは &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; が &lt;code&gt;v-for&lt;/code&gt; と一緒に使用される場合、取得するrefは、データソースをミラーリングする子コンポーネントを含む配列になります。</target>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; が変更されると、パッチが適用されるのではなく、常に &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; が置換されるため、移行がトリガーされます。</target>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Vueは &lt;code&gt;v-for&lt;/code&gt; でレンダリングされた要素のリストを更新するとき、デフォルトで「インプレースパッチ」戦略を使用します。 データ項目の順序が変更された場合、DOM要素を移動して項目の順序に一致させる代わりに、Vueは各要素をその場でパッチし、その特定のインデックスでレンダリングされるものを反映するようにします。 これは、Vue 1.xの &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; の動作に似ています。</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Vueがディレクティブを処理するとき、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも高い優先度を持つため、このテンプレートは次のようになります。</target>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModelが破棄されると、すべてのイベントリスナーが自動的に削除されます。 自分でクリーンアップすることを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Vueインスタンスが作成されると、その &lt;code&gt;data&lt;/code&gt; オブジェクトで見つかったすべてのプロパティがVueの&lt;strong&gt;反応性システム&lt;/strong&gt;に追加され&lt;strong&gt;ます&lt;/strong&gt; 。 これらのプロパティの値が変更されると、ビューは「反応」し、新しい値に合わせて更新されます。</target>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">ブラウザーはこのコードを読み取ると&lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;、「DOMノード」のツリーを&lt;/a&gt;構築して、すべてを追跡できるようにします。これは、拡張ファミリーを追跡するためにファミリーツリーを構築する場合と同じです。</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">コンポーネントが &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 内で切り替えられると、それに応じて &lt;code&gt;activated&lt;/code&gt; および &lt;code&gt;deactivated&lt;/code&gt; ライフサイクルフックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">ミックスインとコンポーネント自体に重複するオプションが含まれている場合、それらは適切な戦略を使用して「マージ」されます。</target>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">&lt;code&gt;transition&lt;/code&gt; コンポーネントにラップされた要素が挿入または削除されると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">&lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントを構築すると、テンプレートには最終的にタイトル以外のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">コンポーネントがcr屈になったり読みにくいと感じ始めた場合、複数行のプロパティの間にスペースを追加すると、コンポーネントを再度簡単に読みやすくすることができます。 Vimなどの一部のエディターでは、このようなフォーマットオプションを使用すると、キーボードで簡単にナビゲートできます。</target>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">カスタムオプションがマージされると、既存の値を上書きするデフォルトの戦略が使用されます。 カスタムロジックを使用してカスタムオプションをマージする場合は、 &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; に関数を添付する必要があります。</target>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">&lt;strong&gt;コンポーネントを&lt;/strong&gt;定義する場合、 &lt;code&gt;data&lt;/code&gt; は初期データオブジェクトを返す関数として宣言する必要があります。同じ定義を使用して多数のインスタンスが作成されるためです。 &lt;code&gt;data&lt;/code&gt; にプレーンなオブジェクトを使用する場合、作成されたすべてのインスタンス間で同じオブジェクトが&lt;strong&gt;参照によって共有され&lt;/strong&gt;ます！ &lt;code&gt;data&lt;/code&gt; 関数を提供することにより、新しいインスタンスが作成されるたびに、それを呼び出して初期データの新しいコピーを返すことができます。</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">PascalCaseを使用してコンポーネントを定義する場合、カスタム要素を参照するときにどちらの場合も使用できます。 つまり、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; の両方が受け入れられます。 ただし、ケバブケース名のみがDOMで直接有効であることに注意してください（つまり、非文字列テンプレート）。</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">kebab-caseを使用してコンポーネントを定義する場合、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; などのカスタム要素を参照するときにkebab-caseも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">各計算プロパティに非常に単純な式のみが含まれ、依存関係がほとんどない場合、正しく機能することを確認するテストを作成する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">プロパティ名/キーを含める場合、オブジェクトの引数の順序は &lt;code&gt;(name, value)&lt;/code&gt; でした。 現在、lodashなどの一般的なオブジェクトイテレータとの一貫性が向上してい &lt;code&gt;(value, name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; を含める場合、配列の引数の順序は &lt;code&gt;(index, value)&lt;/code&gt; でした。 &lt;code&gt;forEach&lt;/code&gt; や &lt;code&gt;map&lt;/code&gt; などのJavaScriptのネイティブ配列メソッドとの一貫性が向上しました &lt;code&gt;(value, index)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">オブジェクトを反復処理する場合、順序は &lt;code&gt;Object.keys()&lt;/code&gt; 列挙順序に基づきますが、JavaScriptエンジンの実装全体で一貫性があること&lt;strong&gt;は&lt;/strong&gt;保証されて&lt;strong&gt;いませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">キーボードイベントをリッスンする場合、特定のキーを確認する必要があります。 Vueでは、キーイベントをリッスンするときに &lt;code&gt;v-on&lt;/code&gt; のキー修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">ネイティブDOMイベントをリッスンするとき、メソッドは唯一の引数としてネイティブイベントを受け取ります。 インラインステートメントを使用する場合、ステートメントは特別な &lt;code&gt;$event&lt;/code&gt; プロパティ &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; アクセスできます。</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">エディターでアルファベット順に整理すると、アプリのベースコンポーネントがすべて一緒にリストされ、識別しやすくなります。</target>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">クエリパラメータに配列を渡すと、QueryString構文は &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; ではなくなり、代わりに新しい構文は &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; ます。 内部的には、 &lt;code&gt;$route.query.users&lt;/code&gt; は依然として配列ですが、クエリにパラメーターが1つしかない場合： &lt;code&gt;/foo?users=Tom&lt;/code&gt; 、このルートに直接アクセスするときに、ルーターが &lt;code&gt;users&lt;/code&gt; を期待しているかどうかを知る方法がありません配列になります。 このため、計算されたプロパティを追加し、 &lt;code&gt;$route.query.users&lt;/code&gt; すべての参照をそれに置き換えることを検討してください。</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">プロップの検証が失敗すると、Vueはコンソール警告を生成します（開発ビルドを使用している場合）。</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">コンポーネントを登録するとき、常に名前が付けられます。 たとえば、これまで見てきたグローバル登録では：</target>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、テンプレートで見つかったHTMLコメントを保持およびレンダリングします。 デフォルトの動作はそれらを破棄することです。</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">ただし、これらのコンポーネントを切り替えるときは、パフォーマンス上の理由から、それらの状態を維持したり、再レンダリングを避けたい場合があります。 たとえば、タブ付きインターフェイスを少し拡張する場合：</target>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">&lt;code&gt;inline-template&lt;/code&gt; 特殊属性が子コンポーネントに存在する場合、コンポーネントは、コンテンツを分散コンテンツとして扱うのではなく、テンプレートとして内部コンテンツを使用します。 これにより、より柔軟なテンプレート作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">コンポーネントがレンダリングされると、 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; は「Your Profile」に置き換えられます。 スロットには、HTMLを含む任意のテンプレートコードを含めることができます。</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">グローバルフィルターがローカルフィルターと同じ名前の場合、ローカルフィルターが優先されます。</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">ページがロードされると、その要素がフォーカスを取得します（注：モバイルSafariでは &lt;code&gt;autofocus&lt;/code&gt; は機能しません）。 実際、このページにアクセスしてから他に何もクリックしていない場合は、上記の入力に焦点を当てる必要があります。 それでは、これを実現するディレクティブを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; の値がオブジェクトである場合、コンポーネントのすべてのインスタンスで共有されます。 たとえば、次のデータを持つ &lt;code&gt;TodoList&lt;/code&gt; コンポーネントを想像してください。</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">同じノードに存在する場合、 &lt;code&gt;v-for&lt;/code&gt; の優先順位は &lt;code&gt;v-if&lt;/code&gt; よりも高くなります。 つまり、ループの各反復で &lt;code&gt;v-if&lt;/code&gt; が個別に実行されます。 これは、次のように、 &lt;em&gt;一部の&lt;/em&gt;アイテムのみのノードをレンダリングする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">このデータが変更されると、ビューが再レンダリングされます。 &lt;code&gt;data&lt;/code&gt; プロパティは、インスタンスの作成時に存在した場合にのみ&lt;strong&gt;反応&lt;/strong&gt;することに注意してください。 つまり、次のような新しいプロパティを追加する場合：</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">同じプラグインでこのメソッドが複数回呼び出された場合、プラグインは一度だけインストールされます。</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;同じタグ名&lt;/strong&gt;を持つ要素間を切り替える場合、Vueに一意の &lt;code&gt;key&lt;/code&gt; 属性を与えることにより、それらが別個の要素であることを伝える必要があります。 それ以外の場合、Vueのコンパイラは効率のために要素のコンテンツのみを置き換えます。 ただし、技術的に不要な場合でも、 &lt;strong&gt;常に &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネント内の複数のアイテムにキーを設定することをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">小道具のバインドに使用する場合、小道具は子コンポーネントで適切に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">コンポーネントで使用する場合、 &lt;code&gt;v-model&lt;/code&gt; は代わりにこれを行います。</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">コンポーネントで使用すると、 &lt;code&gt;v-on&lt;/code&gt; はそのコンポーネントによって送信されたカスタムイベントのみをリッスンする &lt;code&gt;$emit&lt;/code&gt; ました。 ルート要素でネイティブDOMイベントをリッスンするには、 &lt;code&gt;.native&lt;/code&gt; 修飾子を使用できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">通常の要素で使用する場合、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;ネイティブDOMイベント&lt;/strong&gt;&lt;/a&gt;のみをリッスンし&lt;strong&gt;ます&lt;/strong&gt; 。 カスタム要素コンポーネントで使用すると、その子コンポーネントで発行された&lt;strong&gt;カスタムイベントを&lt;/strong&gt;リッスンします。</target>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用して要素/コンポーネントで使用する場合、登録された参照はDOMノードまたはコンポーネントインスタンスを含む配列になります。</target>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; または &lt;code&gt;style&lt;/code&gt; 属性をバインドするために使用する場合、配列やオブジェクトなどの追加の値タイプをサポートします。 詳細については、以下のリンクガイドのセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と一緒に使用する場合は、必ず内部にネストしてください。</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; と一緒に使用すると、 &lt;code&gt;v-for&lt;/code&gt; の優先順位は &lt;code&gt;v-if&lt;/code&gt; よりも高くなります。 詳細については、 &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">v-ifと一緒に使用すると、v-forの優先順位はv-ifよりも高くなります。 詳細については、 &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; とともに使用する場合、唯一の偽の値は &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 、および &lt;code&gt;false&lt;/code&gt; です。 これは、 &lt;code&gt;0&lt;/code&gt; および空の文字列が真実としてレンダリングされることを意味します。 したがって、たとえば、 &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; は &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; としてレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">引数なしで使用すると、属性の名前と値のペアを含むオブジェクトをバインドするために使用できます。 このモードの &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; は、配列またはオブジェクトはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;ローカル登録&lt;/a&gt;を使用する場合、 &lt;code&gt;Promise&lt;/code&gt; を返す関数を直接提供することもできます。</target>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; または &lt;code&gt;vueify&lt;/code&gt; を使用する場合、 &lt;code&gt;*.vue&lt;/code&gt; ファイル内のテンプレートはビルド時にJavaScriptにプリコンパイルされます。 最終バンドルにコンパイラーは実際には必要ないため、ランタイムのみのビルドを使用できます。</target>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">JavaScriptのみのトランジションを使用する場合&lt;strong&gt;、 &lt;code&gt;enter&lt;/code&gt; フックと &lt;code&gt;leave&lt;/code&gt; フック&lt;/strong&gt;に&lt;strong&gt;は &lt;code&gt;done&lt;/code&gt; コールバックが必要です&lt;/strong&gt; 。 それ以外の場合、フックは同期的に呼び出され、移行はすぐに終了します。</target>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">単一ファイルコンポーネントを使用する場合、コンポーネント内のCSSはJavaScriptを介して &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; タグとして動的に挿入されます。 これには実行時のコストがわずかであり、サーバー側レンダリングを使用している場合、「スタイル設定されていないコンテンツのフラッシュ」が発生します。 すべてのコンポーネントのCSSを同じファイルに抽出すると、これらの問題が回避され、CSSの縮小とキャッシュが改善されます。</target>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vueを使用する場合は、ブラウザーに&lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;をインストールすることをお勧めします。これにより、より使いやすいインターフェースでVueアプリケーションを検査およびデバッグできます。</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">WebpackやBrowserifyなどのビルドツールを使用する場合、プロダクションモードはVueのソースコード内の &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; によって決定され、デフォルトでは開発モードになります。 両方のビルドツールは、この変数を上書きしてVueのプロダクションモードを有効にする方法を提供し、ビルド中に警告がミニファイアーによって削除されます。 すべての &lt;code&gt;vue-cli&lt;/code&gt; テンプレートにはこれらが事前に構成されていますが、その方法を知っておくと有益です。</target>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">DOM内テンプレート（HTMLファイルに直接記述されたテンプレート）を使用する場合は、ブラウザーが属性名を小文字に強制するため、大文字のキーの名前付けも避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">In-DOMテンプレートまたはIn-JavaScriptテンプレート文字列を使用する場合、テンプレートからレンダリング関数へのコンパイルはその場で実行されます。 通常、これはほとんどの場合十分に高速ですが、アプリケーションがパフォーマンスに敏感な場合は避けるのが最善です。</target>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">コンポーネント（つまり、 &lt;code&gt;new Vue&lt;/code&gt; 以外の場所）で &lt;code&gt;data&lt;/code&gt; プロパティを使用する場合 、値はオブジェクトを返す関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">ボタンをクリックすると、すべての投稿のテキストを拡大する必要があることを親に伝える必要があります。 幸いなことに、Vueインスタンスはこの問題を解決するカスタムイベントシステムを提供します。 親は、ネイティブDOMイベントの場合と同様 &lt;code&gt;v-on&lt;/code&gt; 、 v-onを使用して、子コンポーネントインスタンスのイベントをリッスンすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; コンポーネントを定義したとき、次のように、 &lt;code&gt;data&lt;/code&gt; がオブジェクトに直接提供されていないことに気付いたかもしれません。</target>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">動的コンポーネントにラップすると、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は非アクティブなコンポーネントインスタンスを破棄せずにキャッシュします。 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は抽象コンポーネントです。DOM要素自体をレンダリングせず、コンポーネントの親チェーンに表示されません。</target>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Vueインスタンスを作成するとき、 &lt;strong&gt;optionsオブジェクト&lt;/strong&gt;を渡し&lt;strong&gt;ます&lt;/strong&gt; 。 このガイドの大部分では、これらのオプションを使用して目的の動作を作成する方法について説明します。 参照用に、 &lt;a href=&quot;../api/index#Options-Data&quot;&gt;APIリファレンス&lt;/a&gt;でオプションの完全なリストを参照することもできます 。</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 、インデックスでアイテムを直接設定する場合</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 小道具に基づいて見出しのみを生成するコンポーネントを使い始めると、すぐにこれに到達します。</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">よく見ると、これらのコンポーネントは、実際にはレンダーツリーでお互いの子孫で&lt;em&gt;あり&lt;/em&gt;祖先であることがわかります-逆説です！ &lt;code&gt;Vue.component&lt;/code&gt; でコンポーネントをグローバルに登録すると、このパラドックスは自動的に解決されます。 それがあなたなら、ここで読むのをやめることができます。</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">配列の長さを変更する場合、たとえば &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">プレーンなJavaScriptオブジェクトを &lt;code&gt;data&lt;/code&gt; オプションとしてVueインスタンスに渡すと、Vueはそのすべてのプロパティを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt;を使用してそれらを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter / setterに&lt;/a&gt;変換します。 これはES5専用のシム機能ではないため、VueはIE8以下をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;Vue.component&lt;/code&gt; を使用してコンポーネントをグローバルに登録すると、グローバルIDがコンポーネントの &lt;code&gt;name&lt;/code&gt; オプションとして自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">数値を更新すると、入力の下に変更がアニメーション表示されます。 これは素晴らしいデモになりますが、たとえば有効なCSSカラーのように、数値として直接保存されないものはどうでしょうか？ &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt;と&lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.jsで&lt;/a&gt;これを実現する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;ベンダープレフィックス&lt;/a&gt;を必要とするCSSプロパティを使用する場合、たとえば &lt;code&gt;transform&lt;/code&gt; は 、Vueが自動的に適切なプレフィックスを検出し、適用されたスタイルに追加します。</target>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">カスタムコンポーネントで &lt;code&gt;class&lt;/code&gt; 属性を使用すると、それらのクラスがコンポーネントのルート要素に追加されます。 この要素の既存のクラスは上書きされません。</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">次のようなスロット内のデータを使用する場合：</target>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">複数のスロットがある場合は常に、 &lt;em&gt;すべての&lt;/em&gt;スロットに対して &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; ベースの完全な構文を使用&lt;em&gt;し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">複数の同等に優れたオプションが存在する場合、一貫性を確保するために任意の選択を行うことができます。 これらのルールでは、受け入れ可能な各オプションについて説明し、デフォルトの選択肢を提案しています。 つまり、一貫性があり正当な理由がある限り、自分のコードベースで自由に別の選択をすることができます。 もっともな理由があります！ コミュニティ標準に適応することにより、次のことが可能になります。</target>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes">
          <source>Where should I start in a migration?</source>
          <target state="translated">移行のどこから始めるべきですか？</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">プレーンなJavaScriptで簡単に何かを達成できる場合、Vueレンダリング関数は独自の代替手段を提供しません。 たとえば、 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用するテンプレートでは ：</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">現在のVueインスタンスがサーバーで実行されているかどうか。</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">テンプレートで使用して、すべてのブログ投稿のフォントサイズを制御できます。</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes">
          <source>Which could also be written as:</source>
          <target state="translated">次のように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes">
          <source>Which might render something like:</source>
          <target state="translated">これは次のようになります：</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">使用しなくなった機能。 ほとんどは、検索と置換でアップグレードできますが、他の場合は数分かかる場合があります。 現在、ベストプラクティスに従っていない場合、Vue 2.0はさらに強制的に強制します。 これは長期的には良いことですが、重要な（おそらく期限切れの）リファクタリングを意味する場合もあります。</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes">
          <source>Which will render:</source>
          <target state="translated">どちらがレンダリングされます：</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">VueはReactと同様にスケールアップしますが、jQueryと同様にスケールダウンします。 そうです-始めるには、1つのスクリプトタグをページにドロップするだけです。</target>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">スペースを含まない属性値はHTMLで引用符を付ける必要はありませんが、この方法ではスペースを&lt;em&gt;避け&lt;/em&gt; 、属性値を読みにくくすることがよくあります。</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">ほとんどの場合、計算されたプロパティがより適切ですが、カスタムウォッチャーが必要な場合があります。 Vueが &lt;code&gt;watch&lt;/code&gt; オプションを介してデータの変更に反応するより一般的な方法を提供するのはそのためです。 これは、データの変更に応じて非同期または高価な操作を実行する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">子コンポーネントに情報を渡すには、明示的に定義された小道具が推奨されますが、コンポーネントライブラリの作成者は、コンポーネントが使用されるコンテキストを常に予測できるとは限りません。 コンポーネントがコンポーネントのルート要素に追加される任意の属性を受け入れることができる理由です。</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">テンプレートはほとんどのコンポーネントでうまく機能しますが、これがコンポーネントの1つではないことは明らかです。 それでは、 &lt;code&gt;render&lt;/code&gt; 関数で書き直してみましょう。</target>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes">
          <source>Why Listeners in HTML?</source>
          <target state="translated">HTMLでリスナーを使用する理由</target>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">なぜキャッシュが必要なのですか？ 巨大な配列をループして多くの計算を行う必要のある高価な計算プロパティ&lt;strong&gt;A&lt;/strong&gt;があるとします。 次に、 &lt;strong&gt;Aに&lt;/strong&gt;依存する他の計算されたプロパティがある場合があります。 キャッシュがなければ、 &lt;strong&gt;A&lt;/strong&gt;のゲッターを必要以上に多く実行します。 キャッシングが必要ない場合は、代わりにメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes">
          <source>Will be equivalent to:</source>
          <target state="translated">以下と同等になります：</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes">
          <source>Will be evaluated similar to:</source>
          <target state="translated">次のように評価されます。</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes">
          <source>Will instead be defined with:</source>
          <target state="translated">代わりに定義されます：</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes">
          <source>Will result in:</source>
          <target state="translated">結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; コンポーネントを使用して、高度なJavaScriptアプリケーションの領域に入ります。 つまり、まだいくつかの追加ツールを使用することを学んでいません。</target>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; および &lt;code&gt;$attrs&lt;/code&gt; を使用すると、属性を転送する要素を手動で決定できます。これは、 &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本コンポーネントに&lt;/a&gt;望ましい場合が多くあります 。</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes">
          <source>With Build Tools</source>
          <target state="translated">ビルドツールを使用</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes">
          <source>With Components</source>
          <target state="translated">コンポーネント付き</target>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">ES2015 Symbolsを &lt;code&gt;provide&lt;/code&gt; と、関数が提供し 、オブジェクトが &lt;code&gt;inject&lt;/code&gt; ます</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes">
          <source>With MobX</source>
          <target state="translated">MobXを使用</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">オブジェクトベースの構文では、次のオプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes">
          <source>With PascalCase</source>
          <target state="translated">PascalCaseを使用</target>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes">
          <source>With kebab-case</source>
          <target state="translated">ケバブケース付き</target>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">1つの属性を追加することで、特別なスタイルを追加することなく、元の遷移を修正しました。</target>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">とはいえ、調査対象の多くはある程度主観的であるため、一部のReactユーザーにとっては、比較がVueに偏っているように見えることは避けられません。 さまざまな技術的嗜好の存在を認めており、この比較は主に、お客様の好みが偶然にも一致した場合にVueがより適している理由を概説することを目的としています。</target>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">新しい移行システムでは、 &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;再利用可能な移行にコンポーネントを使用&lt;/a&gt;できるようになりました。</target>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">この知識があれば、開始したコンポーネントを終了できます。</target>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">子コンポーネント内では、このページで説明した移行戦略と、Vueの&lt;a href=&quot;transitions&quot;&gt;組み込み移行システムで&lt;/a&gt;提供される移行戦略の任意の組み合わせを使用できます。 合わせて、達成できることにはほとんど制限がありません。</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes">
          <source>Without Build Tools</source>
          <target state="translated">ビルドツールなし</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">うわー、これは超長いページです！ 2.0は完全に異なることを意味しますか？私はもう一度基本を学ぶ必要があり、移行は実質的に不可能でしょうか？</target>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes">
          <source>Writing Testable Components</source>
          <target state="translated">テスト可能なコンポーネントの作成</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes">
          <source>Writing a Plugin</source>
          <target state="translated">プラグインを書く</target>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">はい、Vueのトランジションもデータ駆動型です！ 動的遷移の最も基本的な例は、 &lt;code&gt;name&lt;/code&gt; 属性を動的プロパティにバインドします。</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">Vueは、文字列、数値、配列、プレーンオブジェクトのいずれであっても、出力を自動的に適切にフォーマットするため、実際にデバッグする必要はありません。 ただし、JavaScriptの &lt;code&gt;JSON.stringify&lt;/code&gt; とまったく同じ機能が必要な場合は、メソッドまたは計算プロパティでそれを使用できます。</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">強制された値に、propで渡された値と区別する名前を付けることで、より明示的にする必要があります。</target>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt;からVNodeの配列として静的スロットの内容にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">グローバルな &lt;code&gt;config.keyCodes&lt;/code&gt; オブジェクトを介して&lt;a href=&quot;../api/index#keyCodes&quot;&gt;カスタムキー修飾子のエイリアス&lt;/a&gt;を定義することもできます。</target>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">ミックスインをグローバルに適用することもできます。 注意して使用してください！ ミックスインをグローバルに適用すると、後で作成さ&lt;strong&gt;れるすべての&lt;/strong&gt; Vueインスタンスに影響します。 適切に使用すると、これを使用してカスタムオプションの処理ロジックを挿入できます。</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">追加のグローバルプロパティとコンポーネントオプションを宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">属性でJavaScriptフックを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-once&quot;&gt;v-onceディレクティブ&lt;/a&gt;を使用して、データの変更時に更新しない1回限りの補間を実行することもできますが、これは同じノード上の他のバインディングにも影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">プロパティの名前（キー）の2番目の引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">ファクトリー関数で &lt;code&gt;Promise&lt;/code&gt; を返すこともできるため、Webpack 2およびES2015構文を使用すると次のことができます。</target>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">次の属性を指定して、カスタム遷移クラスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">また、入力期間と終了期間に個別の値を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; の代わりにof を区切り文字として使用することもできます。これにより、反復子に対するJavaScriptの構文により近くなります。</target>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用して、オブジェクトのプロパティを反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、グローバル &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである&lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt;インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、グローバル &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである &lt;code&gt;vm.$set&lt;/code&gt; インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">グローバルな &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである &lt;code&gt;vm.$set&lt;/code&gt; インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;propsData&lt;/code&gt; オプションを使用して、さまざまなプロップでレンダリング出力をアサートできます。</target>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">NPMパッケージのソースは&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;で参照できます。</target>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">通常のプロパティと同様に、テンプレート内の計算されたプロパティにデータバインドできます。 Vueは、 &lt;code&gt;vm.reversedMessage&lt;/code&gt; がvm.messageに依存することを認識しているため、 &lt;code&gt;vm.message&lt;/code&gt; が変更されると、 &lt;code&gt;vm.reversedMessage&lt;/code&gt; に依存するすべてのバインディングを更新します。 そして、最良の部分は、この依存関係を宣言的に作成したことです。計算されたゲッター関数には副作用がないため、テストと理解が容易になります。</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">コンポーネントのオプションでローカルフィルターを定義できます。</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">必要であれば、これらのコネクタワードをコンポーネント名に確実に含めることができますが、順序は依然として重要です。</target>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">通常の要素のように、カスタムコンポーネントで &lt;code&gt;v-for&lt;/code&gt; を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt;を介して公開された有効なキー名を、ケバブケースに変換することにより、修飾子として直接使用できます。</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">スロットプロップが未定義の場合に使用するフォールバックを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes">
          <source>You can even order by multiple columns:</source>
          <target state="translated">複数の列で並べ替えることもできます。</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Pue（以前のJade）のようなプリプロセッサを使用して、Vueテンプレートを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">オブジェクトのフィールドを増やすことで、複数のクラスを切り替えることができます。 さらに、 &lt;code&gt;v-bind:class&lt;/code&gt; ディレクティブはプレーン &lt;code&gt;class&lt;/code&gt; 属性と共存することもできます。 したがって、次のテンプレートが与えられます：</target>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">完全なプログラミング言語（JavaScript）の力を活用して、ビューを構築できます。 これには、一時変数、フロー制御、およびスコープ内のJavaScript値の直接参照が含まれます。</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">このフックでコンポーネントの状態を変更できます。 ただし、エラーがキャプチャされたときに他のコンテンツを短絡させるテンプレートまたはレンダリング関数に条件を含めることが重要です。 そうでない場合、コンポーネントは無限レンダーループにスローされます。</target>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">コンソールを開いて、サンプルvmを自分で試すことができます。 &lt;code&gt;vm.reversedMessage&lt;/code&gt; の値は、常にvm.messageの値に依存します。</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">ミューテーションメソッドを呼び出すことにより、コンソールを開いて前の例の &lt;code&gt;items&lt;/code&gt; 配列を再生できます。 例： &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes">
          <source>You can optionally pass in some options:</source>
          <target state="translated">オプションでいくつかのオプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes">
          <source>You can replace it with:</source>
          <target state="translated">次のものに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;スタイルガイド&lt;/a&gt;で、コンポーネント名に関する他の推奨事項を確認できます。</target>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;ここで完全な例&lt;/a&gt;を見ることができます 。 &lt;code&gt;$parent&lt;/code&gt; を使用する利点は、 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; のインスタンス全体を公開せずに、 &lt;em&gt;任意の&lt;/em&gt;子孫コンポーネントで &lt;code&gt;getMap&lt;/code&gt; にアクセスできることです。 これにより、子コンポーネントが依存しているものを変更または削除することを恐れることなく、そのコンポーネントをより安全に開発し続けることができます。 これらのコンポーネント間のインターフェースは、 &lt;code&gt;props&lt;/code&gt; と同様に明確に定義されたままです。</target>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; ディレクティブを使用して、 v-ifの「elseブロック」を示すことができます。</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; ディレクティブを使用して、フォーム入力、テキストエリア、および選択要素に双方向のデータバインディングを作成できます。 入力タイプに基づいて要素を更新する正しい方法を自動的に選択します。 少し魔法的ですが、 &lt;code&gt;v-model&lt;/code&gt; は基本的にユーザー入力イベントのデータを更新するための構文シュガーであり、いくつかのエッジケースに特別な注意を払っています。</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">次の修飾子を使用して、対応する修飾子キーが押されたときにのみマウスまたはキーボードイベントリスナーをトリガーできます。</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes">
          <source>You can use:</source>
          <target state="translated">次を使用できます。</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">次の方法で、ネストされた &lt;code&gt;userProfile&lt;/code&gt; オブジェクトに新しい &lt;code&gt;age&lt;/code&gt; プロパティを追加できます。</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">プログラムによるリスナーで両方の問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes">
          <source>You could use:</source>
          <target state="translated">次を使用できます。</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes">
          <source>You could write:</source>
          <target state="translated">あなたは書くことができます：</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">コンポーネントをテスト可能にするために、コンポーネントで特別なことをする必要はありません。 生のオプションをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes">
          <source>You have two options when defining component names:</source>
          <target state="translated">コンポーネント名を定義する場合、次の2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vueのテンプレートが実際にコンパイルされて関数をレンダリングすることを知りたい場合があります。 これは、通常は知る必要のない実装の詳細ですが、特定のテンプレート機能がどのようにコンパイルされているかを知りたい場合は、興味深いかもしれません。 以下は、 &lt;code&gt;Vue.compile&lt;/code&gt; を使用してテンプレート文字列をライブコンパイルする小さなデモです。</target>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes">
          <source>You may be wondering:</source>
          <target state="translated">あなたは疑問に思うかもしれません：</target>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vueコンポーネントは、 &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Webコンポーネント仕様の&lt;/a&gt;一部である&lt;strong&gt;カスタム要素&lt;/strong&gt;に非常に似ていることに気づいたかもしれません。 これは、Vueのコンポーネントの構文が仕様に従って緩やかにモデル化されているためです。 たとえば、Vueコンポーネントは&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt;を実装し、特別な属性です。 ただし、いくつかの重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">式のメソッドを呼び出すことで同じ結果を達成できることに気づいたかもしれません。</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;list#Caveats&quot;&gt;配列&lt;/a&gt;または&lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;オブジェクト&lt;/a&gt;を使用して変更検出の警告を考慮していないか、 &lt;code&gt;data&lt;/code&gt; などのVueの反応システムによって追跡されていない状態に依存している可能性があります 。</target>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes">
          <source>You may notice that:</source>
          <target state="translated">あなたはそれに気付くかもしれません：</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">なぜ &lt;code&gt;slots()&lt;/code&gt; と &lt;code&gt;children&lt;/code&gt; の両方が必要なのか疑問に思うかもしれません。 &lt;code&gt;slots().default&lt;/code&gt; は &lt;code&gt;children&lt;/code&gt; と同じではないでしょうか？ 場合によっては、はい-しかし、次の子を持つ機能コンポーネントがある場合はどうでしょうか？</target>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">このイベントリスニングアプローチ全体が、「懸念の分離」に関する古き良きルールに違反していることを懸念するかもしれません。 安心してください-すべてのVueハンドラー関数と式は、現在のビューを処理しているViewModelに厳密にバインドされているため、メンテナンスが困難になりません。 実際、 &lt;code&gt;v-on&lt;/code&gt; を使用することにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">親にちなんで名付けられたディレクトリに子コンポーネントをネストすることにより、この問題を解決したくなるかもしれません。 例えば：</target>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">この問題を別の方法で解決したいと思うかもしれません。「検索」ディレクトリの下にすべての検索コンポーネントをネストし、「設定」ディレクトリの下にすべての設定コンポーネントをネストします。 これらの理由から、非常に大きなアプリ（100以上のコンポーネントなど）でのみこのアプローチを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">これにより、Vueが既存のDOMを破棄し、リスト全体を再レンダリングすると思われるかもしれません-幸いなことに、そうではありません。 VueはDOM要素の再利用を最大化するスマートヒューリスティックを実装しているため、配列を重複するオブジェクトを含む別の配列に置き換えることは非常に効率的な操作です。</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">通常、これらを使用する必要はありませんが、コンポーネントインスタンスのイベントを手動でリッスンする必要がある場合に使用できます。 また、コード編成ツールとしても役立ちます。 たとえば、サードパーティライブラリを統合するためのこのパターンがよく見られます。</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">ルータープロパティをVueインスタンスに渡します。</target>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 初期値が「hello world」であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">まだプロップの元の値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">以下を使用して、新しいリアクティブプロパティを追加します。</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes">
          <source>You would now write:</source>
          <target state="translated">次のように記述します。</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes">
          <source>You would use:</source>
          <target state="translated">次を使用します。</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">次のように更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">投稿を選択し、[ &lt;em&gt;アーカイブ&lt;/em&gt; ]タブに切り替えてから[ &lt;em&gt;投稿&lt;/em&gt; ]に戻ると、選択した投稿が表示されなくなります。 これは、新しいタブに切り替えるたびに、Vueが &lt;code&gt;currentTabComponent&lt;/code&gt; の新しいインスタンスを作成するためです。</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">これらの機能を調べるときに、 &lt;a href=&quot;events#Event-Modifiers&quot;&gt; &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;forms#Modifiers&quot;&gt; &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt;の修飾子の他の例を後で見ることになります。</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">次のように、 &lt;code&gt;v-bind&lt;/code&gt; を使用して動的に割り当てられた小道具も見ました。</target>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">インラインテンプレートは、VueがアタッチされるDOM要素内で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">x-templateは、VueがアタッチされるDOM要素の外部で定義される必要があります。</target>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[]クエリの配列の構文が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">コンポーネントのオプションオブジェクト</target>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes">
          <source>a computed property</source>
          <target state="translated">計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">データプロパティ。デフォルト値を設定するために使用されるpropを使用</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes">
          <source>an array of strings, or</source>
          <target state="translated">文字列の配列、または</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">キーがローカルバインディング名であり、値が次のいずれかであるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes">
          <source>an object where:</source>
          <target state="translated">オブジェクト：</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">祖先コンポーネントは、どの子孫が提供するプロパティを使用するかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">カスタムJavaScriptフック：</target>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">CSSの遷移とアニメーションに自動的にクラスを適用します</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes">
          <source>backed by this data:</source>
          <target state="translated">このデータに裏打ちされた：</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">変更せずにほとんどのコミュニティコード例をコピーして貼り付けることができる</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">チェックボックスとラジオボタンは、 &lt;code&gt;checked&lt;/code&gt; プロパティと &lt;code&gt;change&lt;/code&gt; イベントを使用します 。</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes">
          <source>colors displayed</source>
          <target state="translated">表示される色</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">子孫コンポーネントは、注入されたプロパティがどこから来ているかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes">
          <source>does the same thing as:</source>
          <target state="translated">以下と同じことをします：</target>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じイベントを公開します。</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 以外は &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じ小道具を公開します 。</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">Vue 1.0と2.0の両方を完全にサポート</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。 新しく推奨される構文については、 &lt;a href=&quot;#Named-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。 新しく推奨される構文については、 &lt;a href=&quot;#Scoped-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">Animate.cssなどのサードパーティのCSSアニメーションライブラリを統合する</target>
        </trans-unit>
        <trans-unit id="640a88fb22096bdf6bd9b9dad17ad19528e33c74" translate="yes">
          <source>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</source>
          <target state="translated">Velocity.jsなどのサードパーティのJavaScriptアニメーションライブラリを統合する</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="6ac4338bb79ac3c4906ce72bafa4a59d6e305be8" translate="yes">
          <source>keep-alive</source>
          <target state="translated">keep-alive</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="1a12478dec83ed6e780245cdd0f96617dd7741bb" translate="yes">
          <source>keyCodes</source>
          <target state="translated">keyCodes</target>
        </trans-unit>
        <trans-unit id="d1f56baedcca5a5064e2a4af53cc11a0ed1c0853" translate="yes">
          <source>maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries</source>
          <target state="translated">ルーティングやグローバルな状態管理などの懸念事項は、コンパニオンライブラリによって処理され、コアライブラリに集中します。</target>
        </trans-unit>
        <trans-unit id="b85dac7f646475d4018a5c35390352f94773c821" translate="yes">
          <source>methods</source>
          <target state="translated">methods</target>
        </trans-unit>
        <trans-unit id="759733aacfdf4712b7e0071157fe636694093bf6" translate="yes">
          <source>mixins</source>
          <target state="translated">mixins</target>
        </trans-unit>
        <trans-unit id="1d06a0d76f000e6edd18de492383983feefced4e" translate="yes">
          <source>model</source>
          <target state="translated">model</target>
        </trans-unit>
        <trans-unit id="ce7af53b728aacb666b36f215a21ab0dd6a5bce4" translate="yes">
          <source>mounted</source>
          <target state="translated">mounted</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="efa63f31b95d88d80597fd77df60f57d92b5656c" translate="yes">
          <source>numbers and calculations</source>
          <target state="translated">数字と計算</target>
        </trans-unit>
        <trans-unit id="c4f9f9085b98cae6ac4e1ed2d080effcc14c1a1b" translate="yes">
          <source>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</source>
          <target state="translated">多くの場合、少なくともVueに関しては、新しい採用者が好みのコーディングスタイルに既に慣れていることがわかります。</target>
        </trans-unit>
        <trans-unit id="06dc8f8ac9432bbb240e210daed5bff3b05abccb" translate="yes">
          <source>optionMergeStrategies</source>
          <target state="translated">optionMergeStrategies</target>
        </trans-unit>
        <trans-unit id="5460c4665adcba7eae90a69c7fa5c8c721706518" translate="yes">
          <source>or define a filter globally before creating the Vue instance:</source>
          <target state="translated">または、Vueインスタンスを作成する前にフィルターをグローバルに定義します。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="274a7e4ebee8f7f6dc6992677f3c27d94a3001cb" translate="yes">
          <source>other base components, and</source>
          <target state="translated">他の基本コンポーネント、および</target>
        </trans-unit>
        <trans-unit id="d8fd39d0bbdd2dcf322d8b11390a4c5825b11495" translate="yes">
          <source>parent</source>
          <target state="translated">parent</target>
        </trans-unit>
        <trans-unit id="476ee0f6af1d78aa2a3d9a587e8d5ee7e31229f6" translate="yes">
          <source>performance</source>
          <target state="translated">performance</target>
        </trans-unit>
        <trans-unit id="901b0f26761a219ec847f2e563ee7d645ffb0fe8" translate="yes">
          <source>productionTip</source>
          <target state="translated">productionTip</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="9b653d2097967639889ca93223335f45baa750ff" translate="yes">
          <source>propsData</source>
          <target state="translated">propsData</target>
        </trans-unit>
        <trans-unit id="009ec702007827315f19dc796c2a231a2e05c4dc" translate="yes">
          <source>provide / inject</source>
          <target state="translated">提供/注入</target>
        </trans-unit>
        <trans-unit id="559d8d669c33e3c83eb857ddab7a7179a755573e" translate="yes">
          <source>provide reactive and composable view components</source>
          <target state="translated">リアクティブで構成可能なビューコンポーネントを提供する</target>
        </trans-unit>
        <trans-unit id="69449f994d55805535b9e8fab16f6c39934e9ba4" translate="yes">
          <source>ref</source>
          <target state="translated">ref</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="a0a5278a6cefc309b63b0c4c5fd7593743828a31" translate="yes">
          <source>renderError</source>
          <target state="translated">renderError</target>
        </trans-unit>
        <trans-unit id="ceb562ce431745788c5bafaa3720a09b81bd457a" translate="yes">
          <source>scope &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">スコープが&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0e973bd3838898bd325ed8ba837f26d730a7ed56" translate="yes">
          <source>scope removed</source>
          <target state="translated">スコープが削除されました</target>
        </trans-unit>
        <trans-unit id="2a788a1972f648a6486eea37112a19c4fd342950" translate="yes">
          <source>select fields use &lt;code&gt;value&lt;/code&gt; as a prop and &lt;code&gt;change&lt;/code&gt; as an event.</source>
          <target state="translated">選択フィールドは、 &lt;code&gt;value&lt;/code&gt; を小道具として使用し、 &lt;code&gt;change&lt;/code&gt; をイベントとして使用します 。</target>
        </trans-unit>
        <trans-unit id="b32285bf14101379e596fd61f24637951f17e78f" translate="yes">
          <source>silent</source>
          <target state="translated">silent</target>
        </trans-unit>
        <trans-unit id="462854f9c73adf5f5d5c411adb6b929ecc19693a" translate="yes">
          <source>slot</source>
          <target state="translated">slot</target>
        </trans-unit>
        <trans-unit id="d3ccd068b20d8bc8c899d2419acc4756a32eabf3" translate="yes">
          <source>slot &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;非推奨の&lt;/sup&gt;スロット</target>
        </trans-unit>
        <trans-unit id="1ac938ccaaee0471d9ba1ad826420fb07fe19599" translate="yes">
          <source>slot deprecated</source>
          <target state="translated">非推奨のスロット</target>
        </trans-unit>
        <trans-unit id="9705201399b16c1d9892866519b1fde59ee14c4d" translate="yes">
          <source>slot-scope &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;廃止予定の&lt;/sup&gt;スロットスコープ</target>
        </trans-unit>
        <trans-unit id="70251443cfbe27230429f393dbeeabf3a5a1141c" translate="yes">
          <source>slot-scope deprecated</source>
          <target state="translated">廃止予定のスロットスコープ</target>
        </trans-unit>
        <trans-unit id="3226ecbe650213a49cd03ae67140750e4f340083" translate="yes">
          <source>template</source>
          <target state="translated">template</target>
        </trans-unit>
        <trans-unit id="77bc0357bd1e93d68d50895d6a8281eb11026db0" translate="yes">
          <source>text and textarea elements use &lt;code&gt;value&lt;/code&gt; property and &lt;code&gt;input&lt;/code&gt; event;</source>
          <target state="translated">textおよびtextarea要素は、 &lt;code&gt;value&lt;/code&gt; プロパティと &lt;code&gt;input&lt;/code&gt; イベントを使用します 。</target>
        </trans-unit>
        <trans-unit id="26d762e47535d9d6a0e3b1ec719e818e5029f523" translate="yes">
          <source>the &lt;code&gt;default&lt;/code&gt; property is used as fallback value</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; プロパティがフォールバック値として使用されます</target>
        </trans-unit>
        <trans-unit id="025b0f9e93dda2558b27a2297f4ef94cbbc066a0" translate="yes">
          <source>the &lt;code&gt;from&lt;/code&gt; property is the key (string or Symbol) to search for in available injections, and</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; プロパティは、使用可能なインジェクションで検索するキー（文字列またはシンボル）です。</target>
        </trans-unit>
        <trans-unit id="cad1b9675290b91d92988abdefef24cfeea2451c" translate="yes">
          <source>the custom element name to use in the template, and</source>
          <target state="translated">テンプレートで使用するカスタム要素名、および</target>
        </trans-unit>
        <trans-unit id="b70d4d793e7c9fcdde8b56387ec8f9f5324536a6" translate="yes">
          <source>the key (string or Symbol) to search for in available injections, or</source>
          <target state="translated">使用可能な注入で検索するキー（文字列またはシンボル）、または</target>
        </trans-unit>
        <trans-unit id="771279a0962f67af2fa5fac029cdf6d9cedebe88" translate="yes">
          <source>the name of a registered component, or</source>
          <target state="translated">登録済みコンポーネントの名前、または</target>
        </trans-unit>
        <trans-unit id="ab4b389f6b8b2c135e895d4f7ee4d31afb1a7b7b" translate="yes">
          <source>the name of the variable containing the component options</source>
          <target state="translated">コンポーネントオプションを含む変数の名前</target>
        </trans-unit>
        <trans-unit id="cb42e295aed62d3d9b5bec47d01a8b0244b984bf" translate="yes">
          <source>the positions of SVG nodes</source>
          <target state="translated">SVGノードの位置</target>
        </trans-unit>
        <trans-unit id="412017c454240f4269a3e3d69329a8001d1bc3a8" translate="yes">
          <source>the sizes and other properties of elements</source>
          <target state="translated">要素のサイズとその他のプロパティ</target>
        </trans-unit>
        <trans-unit id="bb128da92e34868c02da7d99c67f861bac948e2f" translate="yes">
          <source>the value of &lt;code&gt;lovingVue&lt;/code&gt; will be passed to the &lt;code&gt;checked&lt;/code&gt; prop. The &lt;code&gt;lovingVue&lt;/code&gt; property will then be updated when &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; emits a &lt;code&gt;change&lt;/code&gt; event with a new value.</source>
          <target state="translated">&lt;code&gt;lovingVue&lt;/code&gt; の値は、 &lt;code&gt;checked&lt;/code&gt; 小道具に渡されます 。 その後、 &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; が新しい値で &lt;code&gt;change&lt;/code&gt; イベントを &lt;code&gt;lovingVue&lt;/code&gt; すると、 lovingVueプロパティが更新されます。</target>
        </trans-unit>
        <trans-unit id="7a5ae87823ef730b40c73e6882ce9d81869d692b" translate="yes">
          <source>to a definition like below in your &lt;code&gt;routes&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;routes&lt;/code&gt; 設定で次のような定義に：</target>
        </trans-unit>
        <trans-unit id="9a356bc545ab21a71c127b739b139dcbccc68d5e" translate="yes">
          <source>to access the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component may similarly use a &lt;code&gt;ref&lt;/code&gt; to provide access to specific elements inside it, such as:</source>
          <target state="translated">&lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; インスタンスにアクセスします。 これは、たとえば、プログラムで親からのこの入力にフォーカスする場合に便利です。 その場合、 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントは同様に &lt;code&gt;ref&lt;/code&gt; を使用して、次のような特定の要素へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="8b44c248ec32b071a1a7aafa16b55a17a8feb834" translate="yes">
          <source>to this:</source>
          <target state="translated">これに：</target>
        </trans-unit>
        <trans-unit id="b624aaa273eeda72c40e568d21fcbbeb5497dae7" translate="yes">
          <source>to validate that the value of the &lt;code&gt;author&lt;/code&gt; prop was created with &lt;code&gt;new Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; プロパティの値が &lt;code&gt;new Person&lt;/code&gt; 作成されたことを検証します。</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="4652e1358ea64fd28779917099faee9815f39f5a" translate="yes">
          <source>train your brain to more easily parse most of the community code you encounter</source>
          <target state="translated">遭遇するほとんどのコミュニティコードをより簡単に解析するように脳を訓練する</target>
        </trans-unit>
        <trans-unit id="56bf8ae82a107d348a5ad5b650394e3f79340670" translate="yes">
          <source>transition</source>
          <target state="translated">transition</target>
        </trans-unit>
        <trans-unit id="0346b11d87b24e82ab5c649ad2ca732f998681d6" translate="yes">
          <source>transition-group</source>
          <target state="translated">transition-group</target>
        </trans-unit>
        <trans-unit id="2439417750083132eec5533d66db361a6f33c86c" translate="yes">
          <source>unit tested in isolation from your Vue code</source>
          <target state="translated">Vueコードから独立してテストされたユニット</target>
        </trans-unit>
        <trans-unit id="13a1891af75c642306a6b695377d16e4a91f0e1b" translate="yes">
          <source>updated</source>
          <target state="translated">updated</target>
        </trans-unit>
        <trans-unit id="47c1dcbefaa84b21d8f1b4cacb6d96a2389f8d6c" translate="yes">
          <source>use JavaScript to directly manipulate the DOM during transition hooks</source>
          <target state="translated">JavaScriptを使用して、移行フック中にDOMを直接操作します</target>
        </trans-unit>
        <trans-unit id="2ffb3e7b8b54e93fa9c9e2c85136cd36872ebac8" translate="yes">
          <source>used by other parts of your application, such as to validate the payload to an API endpoint</source>
          <target state="translated">APIエンドポイントへのペイロードを検証するなど、アプリケーションの他の部分で使用されます</target>
        </trans-unit>
        <trans-unit id="71e87a583e04a8c8e91247ed090ea050ff05d929" translate="yes">
          <source>utilize a virtual DOM</source>
          <target state="translated">仮想DOMを利用する</target>
        </trans-unit>
        <trans-unit id="121c33ea7d2fbab17fddc40d29520aa060292a3f" translate="yes">
          <source>v-bind</source>
          <target state="translated">v-bind</target>
        </trans-unit>
        <trans-unit id="61446caf9cec66418312b8afce77b95f760c1542" translate="yes">
          <source>v-cloak</source>
          <target state="translated">v-cloak</target>
        </trans-unit>
        <trans-unit id="9211fc21d367807ce01b01aeaa155eceb994ff10" translate="yes">
          <source>v-else</source>
          <target state="translated">v-else</target>
        </trans-unit>
        <trans-unit id="aad798ca5693051aa59b6d5515d414fb382e1b9d" translate="yes">
          <source>v-else-if</source>
          <target state="translated">v-else-if</target>
        </trans-unit>
        <trans-unit id="d8d5f6f2691961dbe62b3963ea44db6840a098b2" translate="yes">
          <source>v-for</source>
          <target state="translated">v-for</target>
        </trans-unit>
        <trans-unit id="1c21399d4bae3d211e796bf024c68edbb55e3bc3" translate="yes">
          <source>v-html</source>
          <target state="translated">v-html</target>
        </trans-unit>
        <trans-unit id="da1ef073ed7cfaabd197c053859f5aa2996547bc" translate="yes">
          <source>v-if</source>
          <target state="translated">v-if</target>
        </trans-unit>
        <trans-unit id="5c02585ece6d24ec42b855e409120cc1caeae510" translate="yes">
          <source>v-if/v-else-if/v-else without key</source>
          <target state="translated">キーなしのv-if / v-else-if / v-else</target>
        </trans-unit>
        <trans-unit id="e6aa5be18818de68afb647ef7683640c0ccc6f9b" translate="yes">
          <source>v-model</source>
          <target state="translated">v-model</target>
        </trans-unit>
        <trans-unit id="465db0034f4a4aa82a200f7a5acabc5c6dad8449" translate="yes">
          <source>v-on</source>
          <target state="translated">v-on</target>
        </trans-unit>
        <trans-unit id="fb93d4822889186d62901f1d0c2937ba09afb073" translate="yes">
          <source>v-once</source>
          <target state="translated">v-once</target>
        </trans-unit>
        <trans-unit id="8723014a826e07ee1d36588c6cd2790ee471ba3c" translate="yes">
          <source>v-pre</source>
          <target state="translated">v-pre</target>
        </trans-unit>
        <trans-unit id="54272dd05aa79ca6da35bbefacf8c3d5701dea3b" translate="yes">
          <source>v-show</source>
          <target state="translated">v-show</target>
        </trans-unit>
        <trans-unit id="285a211f0f9d5799f4ec4b2694fc5040a7a120fc" translate="yes">
          <source>v-slot</source>
          <target state="translated">v-slot</target>
        </trans-unit>
        <trans-unit id="a3f5fd55c07ee5fe5da9b61ede51058b6932a8ba" translate="yes">
          <source>v-text</source>
          <target state="translated">v-text</target>
        </trans-unit>
        <trans-unit id="9e8c4326a3e5802b6bd32bdeb38f5ea9b5029432" translate="yes">
          <source>vm.$attrs</source>
          <target state="translated">vm.$attrs</target>
        </trans-unit>
        <trans-unit id="af70cd66d8f463ff0c1b87333de9f7abb083bbcb" translate="yes">
          <source>vm.$children</source>
          <target state="translated">vm.$children</target>
        </trans-unit>
        <trans-unit id="92036bba3d6520305ca4419e64187c8bacb4d53b" translate="yes">
          <source>vm.$data</source>
          <target state="translated">vm.$data</target>
        </trans-unit>
        <trans-unit id="0c6c5f8f8645a9e8953886d60d3d38fc9d7e3813" translate="yes">
          <source>vm.$delete( target, propertyName/index )</source>
          <target state="translated">vm。$ delete（target、propertyName / index）</target>
        </trans-unit>
        <trans-unit id="85945dbc9f317e87e1ebe95aacd2d097e0aadd5e" translate="yes">
          <source>vm.$delete()</source>
          <target state="translated">vm.$delete()</target>
        </trans-unit>
        <trans-unit id="494349fee667e22074020faf32a0d4824e463b58" translate="yes">
          <source>vm.$destroy()</source>
          <target state="translated">vm.$destroy()</target>
        </trans-unit>
        <trans-unit id="eb3d8ad0a5a691e540f0cae8b5f4c35c39bed85b" translate="yes">
          <source>vm.$el</source>
          <target state="translated">vm.$el</target>
        </trans-unit>
        <trans-unit id="01e0f31da340e252fe35bb687b3a8604096a8617" translate="yes">
          <source>vm.$emit( eventName, [&amp;hellip;args] )</source>
          <target state="translated">vm。$ emit（eventName、[&amp;hellip;args]）</target>
        </trans-unit>
        <trans-unit id="f7a594be4c584e06c7738c18556378cc4dca84e2" translate="yes">
          <source>vm.$emit()</source>
          <target state="translated">vm.$emit()</target>
        </trans-unit>
        <trans-unit id="86a5433d32c4d79baf0873f0e23a3bf1d6a26d26" translate="yes">
          <source>vm.$forceUpdate()</source>
          <target state="translated">vm.$forceUpdate()</target>
        </trans-unit>
        <trans-unit id="0cedbd040ea3774df4b69fa4ae663ee646bab0f3" translate="yes">
          <source>vm.$isServer</source>
          <target state="translated">vm.$isServer</target>
        </trans-unit>
        <trans-unit id="05326313026d4f80968b293f9a29cb767e2674ca" translate="yes">
          <source>vm.$listeners</source>
          <target state="translated">vm.$listeners</target>
        </trans-unit>
        <trans-unit id="baab4fd1f32671646717fa9dc37e706a4aa9fc7d" translate="yes">
          <source>vm.$mount( [elementOrSelector] )</source>
          <target state="translated">vm。$ mount（[elementOrSelector]）</target>
        </trans-unit>
        <trans-unit id="57b0780f274178234dca2bf0f994ee7dfc389a4e" translate="yes">
          <source>vm.$mount()</source>
          <target state="translated">vm.$mount()</target>
        </trans-unit>
        <trans-unit id="5c40836793cc9b36ae1e44c2bf0c9d0973b1cb62" translate="yes">
          <source>vm.$nextTick( [callback] )</source>
          <target state="translated">vm。$ nextTick（[コールバック]）</target>
        </trans-unit>
        <trans-unit id="3f2f493de9594ab85ab997f6f445b21f8bf32608" translate="yes">
          <source>vm.$nextTick()</source>
          <target state="translated">vm.$nextTick()</target>
        </trans-unit>
        <trans-unit id="c4320c5ab4595a1512d09e454b2afc1e30f53f99" translate="yes">
          <source>vm.$off( [event, callback] )</source>
          <target state="translated">vm。$ off（[イベント、コールバック]）</target>
        </trans-unit>
        <trans-unit id="8659b7c176051de19b834751c71d64c023e531f8" translate="yes">
          <source>vm.$off()</source>
          <target state="translated">vm.$off()</target>
        </trans-unit>
        <trans-unit id="faeea08725a5801e45b45e8d9044c3d2edda645d" translate="yes">
          <source>vm.$on( event, callback )</source>
          <target state="translated">vm。$ on（event、callback）</target>
        </trans-unit>
        <trans-unit id="47dd05c213dfee7e3bf78c8e68b730713e6c7872" translate="yes">
          <source>vm.$on()</source>
          <target state="translated">vm.$on()</target>
        </trans-unit>
        <trans-unit id="5ddf55fd8c65e0c64370564ac67c71a598011755" translate="yes">
          <source>vm.$once( event, callback )</source>
          <target state="translated">vm。$ once（event、callback）</target>
        </trans-unit>
        <trans-unit id="95a71f9912a16c82dc4a770971c999acc1c481a4" translate="yes">
          <source>vm.$once()</source>
          <target state="translated">vm.$once()</target>
        </trans-unit>
        <trans-unit id="0413cd705f160430c6855f79f80a44ed08a489dc" translate="yes">
          <source>vm.$options</source>
          <target state="translated">vm.$options</target>
        </trans-unit>
        <trans-unit id="513e55e5a687797c62836b5b87c3bc78152500fe" translate="yes">
          <source>vm.$parent</source>
          <target state="translated">vm.$parent</target>
        </trans-unit>
        <trans-unit id="96a7cb38d4e51f5a9a8a6369eb2854d54f31fd3a" translate="yes">
          <source>vm.$props</source>
          <target state="translated">vm.$props</target>
        </trans-unit>
        <trans-unit id="d07c6d69732e9d49ba257f3637d225a5aed4c96d" translate="yes">
          <source>vm.$refs</source>
          <target state="translated">vm.$refs</target>
        </trans-unit>
        <trans-unit id="ddead883ad1628e96ca570e4221dfc38903f3db2" translate="yes">
          <source>vm.$root</source>
          <target state="translated">vm.$root</target>
        </trans-unit>
        <trans-unit id="77be545f1df363cacfd93eb0c9831ef3c95102f4" translate="yes">
          <source>vm.$scopedSlots</source>
          <target state="translated">vm.$scopedSlots</target>
        </trans-unit>
        <trans-unit id="445f58422508541995e32fe0dceb823dcbaaf2f3" translate="yes">
          <source>vm.$set( target, propertyName/index, value )</source>
          <target state="translated">vm。$ set（target、propertyName / index、value）</target>
        </trans-unit>
        <trans-unit id="12697644997ccacfcfb893110ee18b99abc39f50" translate="yes">
          <source>vm.$set()</source>
          <target state="translated">vm.$set()</target>
        </trans-unit>
        <trans-unit id="3e09115bb4ccfaa59031cd594a8725f9ddff4efe" translate="yes">
          <source>vm.$slots</source>
          <target state="translated">vm.$slots</target>
        </trans-unit>
        <trans-unit id="0b7eb695b0a861c10e273101dd3381aea047bf00" translate="yes">
          <source>vm.$watch( expOrFn, callback, [options] )</source>
          <target state="translated">vm。$ watch（expOrFn、コールバック、[オプション]）</target>
        </trans-unit>
        <trans-unit id="fe0401584870a2346a744fe847cf8a6bd902dfbe" translate="yes">
          <source>vm.$watch()</source>
          <target state="translated">vm.$watch()</target>
        </trans-unit>
        <trans-unit id="abc4eb915d83966c3c028e2808e22bda2146ff20" translate="yes">
          <source>vue.common.js</source>
          <target state="translated">vue.common.js</target>
        </trans-unit>
        <trans-unit id="8bc5b029cab40d453cf86de8c720dd795e2a79c0" translate="yes">
          <source>vue.esm.browser.js</source>
          <target state="translated">vue.esm.browser.js</target>
        </trans-unit>
        <trans-unit id="d3ffd20876becca44053e10a61c39d904267ac9f" translate="yes">
          <source>vue.esm.browser.min.js</source>
          <target state="translated">vue.esm.browser.min.js</target>
        </trans-unit>
        <trans-unit id="c117006aa30745b1641f5393741c01bb708cc6db" translate="yes">
          <source>vue.esm.js</source>
          <target state="translated">vue.esm.js</target>
        </trans-unit>
        <trans-unit id="3f7227146eb759f801a054462cc6de123c9a354c" translate="yes">
          <source>vue.js</source>
          <target state="translated">vue.js</target>
        </trans-unit>
        <trans-unit id="99a1d389faffdd980b71470664af47bc6458b2b3" translate="yes">
          <source>vue.min.js</source>
          <target state="translated">vue.min.js</target>
        </trans-unit>
        <trans-unit id="293bf1049872f5a192d03a09bffe06f69b51091d" translate="yes">
          <source>vue.runtime.common.js</source>
          <target state="translated">vue.runtime.common.js</target>
        </trans-unit>
        <trans-unit id="4e9d385e35e8eca60fb7e6083bf2726bc638f977" translate="yes">
          <source>vue.runtime.esm.js</source>
          <target state="translated">vue.runtime.esm.js</target>
        </trans-unit>
        <trans-unit id="2b84e57a624eece08bd137eb6a2c3e4c53c4e1a1" translate="yes">
          <source>vue.runtime.js</source>
          <target state="translated">vue.runtime.js</target>
        </trans-unit>
        <trans-unit id="f4c3c79918026bc22af5b5db5c14b417b1839be0" translate="yes">
          <source>vue.runtime.min.js</source>
          <target state="translated">vue.runtime.min.js</target>
        </trans-unit>
        <trans-unit id="bcbb79f097d6df57f152dc61e8151e0a00cefb2d" translate="yes">
          <source>warnHandler</source>
          <target state="translated">warnHandler</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
        <trans-unit id="b84bfe360a66993ae5d35ff845e9df46ef696052" translate="yes">
          <source>will be maintained for the foreseeable future</source>
          <target state="translated">予見可能な将来のために維持されます</target>
        </trans-unit>
        <trans-unit id="9d57f6d32929205f7b53a7328ce8817af26246a6" translate="yes">
          <source>will render the fallback content, &amp;ldquo;Submit&amp;rdquo;:</source>
          <target state="translated">フォールバックコンテンツ「Submit」をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="032b3d049c6766e15673ecd6348f41e6baaa865b" translate="yes">
          <source>will render with a value of &amp;ldquo;bar&amp;rdquo; instead of &amp;ldquo;foo&amp;rdquo;. The same goes for a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; with existing content. Instead of:</source>
          <target state="translated">「foo」ではなく「bar」の値でレンダリングされます。 既存のコンテンツを含む &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; についても同じことが言えます。 の代わりに：</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
