<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="686299f7711a328af7f7ede481ecd878f135b9f6" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;code&gt;v-if&lt;/code&gt; has higher toggle costs while &lt;code&gt;v-show&lt;/code&gt; has higher initial render costs. So prefer &lt;code&gt;v-show&lt;/code&gt; if you need to toggle something very often, and prefer &lt;code&gt;v-if&lt;/code&gt; if the condition is unlikely to change at runtime.</source>
          <target state="translated">一般的に言って、 &lt;code&gt;v-if&lt;/code&gt; はトグルコストが高く、 &lt;code&gt;v-show&lt;/code&gt; は初期レンダリングコストが高くなります。したがって、非常に頻繁に切り替える必要がある場合は &lt;code&gt;v-show&lt;/code&gt; を選択し、実行時に状態が変化する可能性が低い場合は &lt;code&gt;v-if&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="54c5f98c2534a5664e54bdf67174809b2a27c8a3" translate="yes" xml:space="preserve">
          <source>Get Support</source>
          <target state="translated">サポートを受ける</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="4687f4eea959b8d3a7678579930ba86b60298a4b" translate="yes" xml:space="preserve">
          <source>Global API</source>
          <target state="translated">グローバルAPI</target>
        </trans-unit>
        <trans-unit id="d99de9060d9d291cf15a1d729547287918e216dc" translate="yes" xml:space="preserve">
          <source>Global Config</source>
          <target state="translated">グローバル設定</target>
        </trans-unit>
        <trans-unit id="a87e1f8386cdfab8951563f9287ce245995f5751" translate="yes" xml:space="preserve">
          <source>Global Mixin</source>
          <target state="translated">グローバルミキシン</target>
        </trans-unit>
        <trans-unit id="12acfdfcb7281091faacdbe76162537707d677a4" translate="yes" xml:space="preserve">
          <source>Global Registration</source>
          <target state="translated">グローバル登録</target>
        </trans-unit>
        <trans-unit id="d23476cf27dc98d9e3173cbdb68ad4566d7bbe61" translate="yes" xml:space="preserve">
          <source>Global registration often isn&amp;rsquo;t ideal. For example, if you&amp;rsquo;re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">多くの場合、グローバル登録は理想的ではありません。たとえば、Webpackなどのビルドシステムを使用している場合、すべてのコンポーネントをグローバルに登録すると、コンポーネントの使用を停止しても、最終的なビルドに含まれる可能性があります。これにより、ユーザーがダウンロードしなければならないJavaScriptの量が不必要に増加します。</target>
        </trans-unit>
        <trans-unit id="e2b51a4acf3ac2ad46709058f4a65e88a724bd55" translate="yes" xml:space="preserve">
          <source>Global state management</source>
          <target state="translated">グローバルな状態管理</target>
        </trans-unit>
        <trans-unit id="d2cdbb9287a2eee1e29278ad1a52afa18af50490" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created afterwards &amp;ndash; and even inside all subcomponents of that Vue instance&amp;rsquo;s component tree.</source>
          <target state="translated">グローバルに登録されたコンポーネントは、後で作成されたルートVueインスタンス（ &lt;code&gt;new Vue&lt;/code&gt; ）のテンプレートで、さらにはそのVueインスタンスのコンポーネントツリーのすべてのサブコンポーネント内でも使用できます。</target>
        </trans-unit>
        <trans-unit id="9d53a8dc9787d0f1938039b6b2df16c89e2967b1" translate="yes" xml:space="preserve">
          <source>Go ahead and enter &lt;code&gt;app3.seen = false&lt;/code&gt; in the console. You should see the message disappear.</source>
          <target state="translated">コンソールに &lt;code&gt;app3.seen = false&lt;/code&gt; と入力してください。メッセージが消えるはずです。</target>
        </trans-unit>
        <trans-unit id="61dedcf053ff33692baacbf7789c5d7195d9acbe" translate="yes" xml:space="preserve">
          <source>Good</source>
          <target state="translated">Good</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">ガイド</target>
        </trans-unit>
        <trans-unit id="613dffa8c694c4b79227626375484864e1cbb5bc" translate="yes" xml:space="preserve">
          <source>HTML &amp;amp; CSS</source>
          <target state="translated">HTMLとCSS</target>
        </trans-unit>
        <trans-unit id="ecb5ae374f41987062d1edb5a439c141fbcfee47" translate="yes" xml:space="preserve">
          <source>HTML Interpolation &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">HTML補間が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="61152bedc285b45e3443132c85b9e9eab87b1c71" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">HTML属性名では大文字と小文字が区別されないため、ブラウザは大文字をすべて小文字として解釈します。つまり、DOM内のテンプレートを使用している場合、キャメルケースのプロップ名は、対応するケバブ（ハイフン区切り）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="206317f92c61c3721e7b0ef393e74b50f2adc608" translate="yes" xml:space="preserve">
          <source>HTML elements,</source>
          <target state="translated">HTML要素。</target>
        </trans-unit>
        <trans-unit id="b7d20a95e49462d14a4c08f7dda3686750b36c96" translate="yes" xml:space="preserve">
          <source>HTML interpolation has been &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;removed in favor of &lt;code&gt;v-html&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTML補間が&lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;削除され、 &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt;が採用されました。</target>
        </trans-unit>
        <trans-unit id="0b1c56685d95ab775546bda4c6e1ef23eea39b81" translate="yes" xml:space="preserve">
          <source>HTML interpolations (&lt;code&gt;{{{ foo }}}&lt;/code&gt;) have been removed in favor of the &lt;a href=&quot;../api/index#v-html&quot;&gt;&lt;code&gt;v-html&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">HTML補間（ &lt;code&gt;{{{ foo }}}&lt;/code&gt; ）が削除され、&lt;a href=&quot;../api/index#v-html&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; ディレクティブが追加&lt;/a&gt;されました。</target>
        </trans-unit>
        <trans-unit id="ec5f7d68ba95b6c2f0128818861a5fb3a7ce41b3" translate="yes" xml:space="preserve">
          <source>HTML&amp;rsquo;s built-in input types won&amp;rsquo;t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">HTMLの組み込みの入力タイプは、常にニーズを満たしているとは限りません。幸い、Vueコンポーネントを使用すると、完全にカスタマイズされた動作で再利用可能な入力を構築できます。これらの入力は &lt;code&gt;v-model&lt;/code&gt; でも機能します！詳細については、コンポーネントガイドの&lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;カスタム入力&lt;/a&gt;についてお読みください。</target>
        </trans-unit>
        <trans-unit id="69b83e92529f5151314d046d862c4a9c77d93516" translate="yes" xml:space="preserve">
          <source>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue&amp;rsquo;s reactivity features.</source>
          <target state="translated">HTMLベースのテンプレートを使用すると、既存のアプリケーションを段階的に移行してVueの反応性機能を活用することがはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="5e6fab8d8bdb45dbc0c724b264884e741a1423d5" translate="yes" xml:space="preserve">
          <source>Handling Edge Cases</source>
          <target state="translated">エッジケースの取り扱い</target>
        </trans-unit>
        <trans-unit id="0c27db799f42037e36231e8871e3549a290cef26" translate="yes" xml:space="preserve">
          <source>Handling Loading State</source>
          <target state="translated">読み込み状態を扱う</target>
        </trans-unit>
        <trans-unit id="f70e7e4e8994ebaac734eaf505f7cb87f5015b0f" translate="yes" xml:space="preserve">
          <source>Handling User Input</source>
          <target state="translated">ユーザー入力の処理</target>
        </trans-unit>
        <trans-unit id="553c9fd444b729d939071ffd415fb951213f90a4" translate="yes" xml:space="preserve">
          <source>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</source>
          <target state="translated">ハッシュバングは、GoogleがURLをクロールするために必要なものではなくなったので、ハッシュ戦略のデフォルト(というかオプション)ではなくなりました。</target>
        </trans-unit>
        <trans-unit id="a8d68b23680238f325efc34072a89db096cd1404" translate="yes" xml:space="preserve">
          <source>Having this validator extracted out, we&amp;rsquo;ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it&amp;rsquo;s actually impossible for users to enter anything wrong, similar to what the browser&amp;rsquo;s native number input tries to do.</source>
          <target state="translated">このバリデーターを抽出することで、より堅牢なソリューションに快適に組み込むことができます。状態の癖が取り除かれ、ユーザーがブラウザーのネイティブの数値入力が試行するのと同じように、何かを間違って入力することは実際には不可能です。</target>
        </trans-unit>
        <trans-unit id="5d3e638fd34dc7467faa0ba823b8497588b5815b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;attributeName&lt;/code&gt; はJavaScript式として動的に評価され、その評価された値は引数の最終値として使用されます。たとえば、Vueインスタンスにデータプロパティ &lt;code&gt;attributeName&lt;/code&gt; があり、その値が &lt;code&gt;&quot;href&quot;&lt;/code&gt; である場合、このバインディングは &lt;code&gt;v-bind:href&lt;/code&gt; と同等になります。</target>
        </trans-unit>
        <trans-unit id="89a97b67c98ddcf2e842f6272379190e542a3a62" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;filterA&lt;/code&gt; is defined as a function taking three arguments. The value of &lt;code&gt;message&lt;/code&gt; will be passed into the first argument. The plain string &lt;code&gt;'arg1'&lt;/code&gt; will be passed into the &lt;code&gt;filterA&lt;/code&gt; as its second argument, and the value of expression &lt;code&gt;arg2&lt;/code&gt; will be evaluated and passed in as the third argument.</source>
          <target state="translated">ここで、 &lt;code&gt;filterA&lt;/code&gt; は3つの引数を取る関数として定義されています。 &lt;code&gt;message&lt;/code&gt; の値は最初の引数に渡されます。プレーンな文字列 &lt;code&gt;'arg1'&lt;/code&gt; は2番目の引数として &lt;code&gt;filterA&lt;/code&gt; に渡され、式 &lt;code&gt;arg2&lt;/code&gt; の値が評価されて3番目の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="b533c1b3a997459bdeab6c6103d2b8341430c012" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;href&lt;/code&gt; は引数です。これは、要素の &lt;code&gt;href&lt;/code&gt; 属性を式 &lt;code&gt;url&lt;/code&gt; の値にバインド &lt;code&gt;v-bind&lt;/code&gt; ようにv-bindディレクティブに指示します。</target>
        </trans-unit>
        <trans-unit id="e8a2ad49522f0c5140bd579d6e3f6cc63de82a9e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; can be omitted as it is implied:</source>
          <target state="translated">ここで、 &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; は暗黙的に省略されています。</target>
        </trans-unit>
        <trans-unit id="a5a992eb5c40fb541d26012305484c0906879154" translate="yes" xml:space="preserve">
          <source>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</source>
          <target state="translated">ここでの引数は、聞きたいイベント名です。イベントの処理についても詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="f407b88178ffc4e03f9f78c8af7c050fb1a05bb8" translate="yes" xml:space="preserve">
          <source>Here we are encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you are seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &amp;ldquo;keep this element&amp;rsquo;s &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the Vue instance.&amp;rdquo;</source>
          <target state="translated">ここで私たちは何か新しいことに遭遇しています。表示されている &lt;code&gt;v-bind&lt;/code&gt; 属性は&lt;strong&gt;ディレクティブ&lt;/strong&gt;と呼ばれます。ディレクティブには接頭辞 &lt;code&gt;v-&lt;/code&gt; が付いており、Vueによって提供される特別な属性であることを示します。ご想像のとおり、レンダリングされたDOMに特別な反応動作を適用します。ここでは、基本的に「Vueインスタンスの &lt;code&gt;message&lt;/code&gt; プロパティを使用して、この要素の &lt;code&gt;title&lt;/code&gt; 属性を最新の状態に保ちます」と述べています。</target>
        </trans-unit>
        <trans-unit id="20439924cb310f6e6ebea9dce4e509745f1d1bb0" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;reversedMessage&lt;/code&gt;. The function we provided will be used as the getter function for the property &lt;code&gt;vm.reversedMessage&lt;/code&gt;:</source>
          <target state="translated">ここでは、計算されたプロパティ &lt;code&gt;reversedMessage&lt;/code&gt; を宣言しています。提供した関数は、プロパティ &lt;code&gt;vm.reversedMessage&lt;/code&gt; のゲッター関数として使用されます。</target>
        </trans-unit>
        <trans-unit id="41a58605aec4adfd7f18a1d980084fe022c01384" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete example of a simple todo list:</source>
          <target state="translated">簡単なToDoリストの完全な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="e6deaab1ac1757bb576b7c7fb31ce01f23836233" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a &lt;code&gt;smart-list&lt;/code&gt; component that delegates to more specific components, depending on the props passed to it:</source>
          <target state="translated">渡された小道具に応じて、より具体的なコンポーネントに委任する &lt;code&gt;smart-list&lt;/code&gt; コンポーネントの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="8edc36b060f6cabd0970dde81f8964d59b6e1225" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a Vue component:</source>
          <target state="translated">Vueコンポーネントの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="b31be59658661ba4e66f41944f3554b7a0be5398" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a file we&amp;rsquo;ll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Hello.vue&lt;/code&gt; と呼ぶファイルの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="b33ffef562696923d8035d66d6b00e446f9c5cd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example using a template component:</source>
          <target state="translated">テンプレートコンポーネントを使用した例を次に示します。</target>
        </trans-unit>
        <trans-unit id="99ff339aed17c551cb54d5842ca9646f53c8ed64" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with all of these modifiers used together:</source>
          <target state="translated">これらの修飾子をすべて一緒に使用した例を次に示します。</target>
        </trans-unit>
        <trans-unit id="18a91a386128ffc554ca249fb0825499466cf9d3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">以下は、簡潔にするために接頭辞付きのCSSルールを省略した例です。</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f7ffc75a586e32509010b20213e0f4e623c0e848" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s that in action:</source>
          <target state="translated">これが実際の動作です。</target>
        </trans-unit>
        <trans-unit id="9a829483e3b314613758a5a663c73e6905d5701b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;slot-scope&lt;/code&gt; declares the received props object as the &lt;code&gt;slotProps&lt;/code&gt; variable, and makes it available inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; scope. You can name &lt;code&gt;slotProps&lt;/code&gt; anything you like similar to naming function arguments in JavaScript.</source>
          <target state="translated">ここで、 &lt;code&gt;slot-scope&lt;/code&gt; は受け取ったpropsオブジェクトを &lt;code&gt;slotProps&lt;/code&gt; 変数として宣言し、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; スコープ内で使用できるようにします。JavaScriptで関数の引数に名前を付けるのと同じように、 &lt;code&gt;slotProps&lt;/code&gt; に好きな名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="f68e5bf516c14d7636dc7e787f07b009104eba6f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;v-if&lt;/code&gt; directive would remove/insert the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element based on the truthiness of the value of the expression &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;v-if&lt;/code&gt; ディレクティブは、 &lt;code&gt;seen&lt;/code&gt; 式の値の真実性に基づいて &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 要素を削除/挿入します。</target>
        </trans-unit>
        <trans-unit id="8e26e3e40dfd6774d32a14ec704c7c19bb0bf799" translate="yes" xml:space="preserve">
          <source>Hook Functions</source>
          <target state="translated">フック機能</target>
        </trans-unit>
        <trans-unit id="d2bdd950b4b524b4faf0540c42b846e440d3ebd2" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component&amp;rsquo;s own hooks.</source>
          <target state="translated">同じ名前のフック関数は配列にマージされ、それらすべてが呼び出されます。Mixinフックは、コンポーネント自体のフックの&lt;strong&gt;前&lt;/strong&gt;に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="656dedbf5301c31ed9bdf32f2a451638643101f3" translate="yes" xml:space="preserve">
          <source>How Changes Are Tracked</source>
          <target state="translated">変更の追跡方法</target>
        </trans-unit>
        <trans-unit id="a056aea1f6dc2d57c44eacd2de4c8078611a80e1" translate="yes" xml:space="preserve">
          <source>How long will it take to migrate a Vue 1.x app to 2.0?</source>
          <target state="translated">Vue 1.xアプリを2.0に移行するにはどのくらいの時間がかかりますか?</target>
        </trans-unit>
        <trans-unit id="a173386c8ab0ffd650a7e5d8b6fb73ce6260ce4e" translate="yes" xml:space="preserve">
          <source>How many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!</source>
          <target state="translated">何度気を取られて、クールな新機能で遊び始めたことか 😉 批判ではなく、2.0を構築している間に、私たちにも起こったことです!</target>
        </trans-unit>
        <trans-unit id="5b51fcd95b1bb4c1d0a2feadea82b32351c13de4" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;inline-template&lt;/code&gt; makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the &lt;code&gt;template&lt;/code&gt; option or in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element in a &lt;code&gt;.vue&lt;/code&gt; file.</source>
          <target state="translated">ただし、 &lt;code&gt;inline-template&lt;/code&gt; すると、テンプレートのスコープを推測することが難しくなります。ベストプラクティスとして、 &lt;code&gt;template&lt;/code&gt; オプションを使用してコンポーネント内でテンプレートを定義するか、 &lt;code&gt;.vue&lt;/code&gt; ファイルの &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素でテンプレートを定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="42d602a14282520e03f05621c18e657389b28401" translate="yes" xml:space="preserve">
          <source>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;, &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;, and &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;.</source>
          <target state="translated">ただし、これでもスコープスロットで実行できる機能の表面をかろうじて引っ掻くだけです。スコープ付きスロットの実際の強力な例として、&lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;、&lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;、&lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;などのライブラリを参照することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e377ccc91063a19e1128087c043b05ac14bc27fd" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;Vue.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">ただし、 &lt;code&gt;Vue.component&lt;/code&gt; を介したグローバルコンポーネント定義&lt;strong&gt;のみ&lt;/strong&gt;を使用するアプリケーションの場合は、代わりにケバブケースをお勧めします。理由は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">ただし、&lt;strong&gt;モジュールシステム&lt;/strong&gt;を使用してコンポーネントを要求/インポートする場合（WebpackやBrowserifyなど）、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ただし、上記を除外して、手動で更新を強制しなければならないという非常にまれな状況に陥った場合は、&lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt;使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">ただし、同じ要素に両方を設定したい場合もあります。たとえば、CSSアニメーションをVueでトリガーしたり、ホバー時のCSSトランジション効果を適用したりできます。これらの場合、 &lt;code&gt;type&lt;/code&gt; 属性で、Vueが気にするタイプを明示的に宣言する必要があります。値は、 &lt;code&gt;animation&lt;/code&gt; または &lt;code&gt;transition&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">しかし、他のディレクティブと同様に、この短縮形は引数が与えられたときにのみ利用可能です。つまり、以下の構文は無効です。</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">ただし、誰もがTypeScriptの使用を望んでいるわけではありません。多くの小規模なユースケースでは、型システムを導入すると、生産性の向上よりもオーバーヘッドが大きくなる可能性があります。TypeScriptなしでAngularを使用するのは難しい場合があるため、それらの場合は、代わりにVueを使用するほうがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">ただし、依存性注入には欠点があります。これは、アプリケーションのコンポーネントを現在整理されている方法に結合し、リファクタリングをより困難にします。提供されたプロパティも反応しません。これは設計によるものです。中央データストアを作成するために使用すると、同じ目的で&lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt; &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt;を使用する場合と同じようにスケーリングが不十分になるためです。共有したいプロパティがジェネリックではなくアプリに固有のものである場合、または提供されたデータを祖先内で更新したい場合は、おそらく&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuexの&lt;/a&gt;ような実際の状態管理ソリューションが必要であることを示しています。</target>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">ただし、複数の条件付きクラスがある場合、これは少し冗長になる可能性があります。そのため、配列構文内でオブジェクト構文を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">ただし、コンポーネントには独自の独立したスコープがあるため、コンポーネントにデータが自動的に渡されることはありません。反復されたデータをコンポーネントに渡すには、propsも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">ただし、離れた子孫/祖先の間で通信する場合、 &lt;code&gt;$emit&lt;/code&gt; は役に立ちません。代わりに、最も簡単なアップグレードは、集中型のイベントハブを使用することです。これには、コンポーネントツリー内のどこにあるかに関係なく、コンポーネント間で通信できるという追加の利点があります-兄弟間でも！Vueインスタンスはイベントエミッターインターフェースを実装しているため、実際にはこの目的で空のVueインスタンスを使用できます。</target>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">ただし、明示的にしたい場合は、デフォルトのスロットコンテンツを &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; でラップできます。</target>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">今あなたがこの文章をあなたの好きな言語で読んでいることを望みます。そうでない場合、私たちがそこに到達するのを手伝っていただけませんか？</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">よろしくお願いします！答えはノーだ。APIの約90％は同じであり、コアコンセプトに変更はありません。私たちは非常に詳細な説明を提供し、多くの例を含めるのが好きなので、それは長いです。安心してください、&lt;strong&gt;これは上から下に読む必要があるものではありません！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; のテンプレートはなかった&lt;strong&gt;ではない&lt;/strong&gt;含まれている &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を、その開閉タグの間に設けられたすべてのコンテンツが破棄されるだろう。</target>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">場合 &lt;code&gt;elementOrSelector&lt;/code&gt; の引数が提供されていない、テンプレートがオフの文書要素としてレンダリングされます、そしてあなたは、文書自身にそれを挿入するためにネイティブのDOM APIを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">場合 &lt;code&gt;isButtonDisabled&lt;/code&gt; は値がある &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 、または &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;disabled&lt;/code&gt; 属性がさえ、レンダリングには含まれません &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Vue 2にアップグレードしたら、VuexとVue Routerもアップグレードしないといけないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Vueにこのルールがない場合、1つのボタンをクリックすると、以下のように&lt;em&gt;他&lt;/em&gt;の&lt;em&gt;すべてのインスタンスの&lt;/em&gt;データに影響します。</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Vueインスタンスがインスタンス化時に &lt;code&gt;el&lt;/code&gt; オプションを受信しなかった場合、関連付けられたDOM要素なしで「アンマウント」状態になります。 &lt;code&gt;vm.$mount()&lt;/code&gt; を使用して、マウントされていないVueインスタンスのマウントを手動で開始できます。</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">あるコンポーネントが単一の親コンポーネントのコンテキストでのみ意味を持つ場合、その関係はその名前で明らかになるべきです。エディタは通常、ファイルをアルファベット順に整理するので、関連するファイルを隣り合わせにしておきます。</target>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">コンポーネントのレンダリング中にランタイムエラーが発生した場合、設定されていれば、グローバル &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 構成関数に渡されます。このフックを、Vueの&lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;公式統合&lt;/a&gt;を提供する&lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;などのエラー追跡サービスと一緒に活用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">イベントとコールバックの両方が与えられた場合、その特定のコールバックのみのリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">代わりに、ループの実行を条件付きでスキップすることが目的である &lt;code&gt;v-if&lt;/code&gt; は、ラッパー要素（または&lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt;）にv-ifを配置できます。例えば：</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">別の名前のプロパティから挿入する必要がある場合は、fromプロパティを使用 &lt;code&gt;from&lt;/code&gt; てソースプロパティを示します。</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">コンポーネントの継承チェーンまたは親チェーンに複数の &lt;code&gt;errorCaptured&lt;/code&gt; フックが存在する場合、それらすべてが同じエラーで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 機能も &lt;code&gt;template&lt;/code&gt; オプションも存在しない場合、マウントするDOM要素のDOM内HTMLがテンプレートとして抽出されます。この場合、Vueのランタイム+コンパイラビルドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">CSSトランジション/アニメーションが検出されず、JavaScriptフックが提供されない場合、挿入および/または削除のDOM操作は次のフレームですぐに実行されます（注：これはブラウザーのアニメーションフレームであり、Vueの &lt;code&gt;nextTick&lt;/code&gt; の概念とは異なります）。</target>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">引数を指定しない場合は、すべてのイベントリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">イベントのみが提供されている場合は、そのイベントのすべてのリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Vueオプションにレンダリング機能がある場合、テンプレートは無視されます。</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; を介して &lt;code&gt;vm.$data&lt;/code&gt; を渡すことにより、元のオブジェクトのディープクローンを取得できます。</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">その場合は、&lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;これらのドキュメント&lt;/a&gt;やその他の公式に維持されているドキュメントのリポジトリをフォークして、翻訳を開始してください。ある程度の進展があったら、メインリポジトリで課題またはプルリクエストを開いてください。そうすれば、より多くの寄稿者に助けを求めるための呼び出しが出されます。</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errorCaptured&lt;/code&gt; フック自体がエラーをスローした場合、このエラーと元のキャプチャされたエラーの両方がグローバル &lt;code&gt;config.errorHandler&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">コンポーネントが機能コンポーネントの場合、レンダリングコンポーネントは追加の引数 &lt;code&gt;context&lt;/code&gt; も受け取ります。これにより、機能コンポーネントはインスタンスを持たないため、コンテキストデータにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 式の初期値がどのオプションとも一致しない場合、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 要素は「選択されていない」状態でレンダリングされます。iOSの場合、この場合iOSは変更イベントを発生させないため、ユーザーは最初のアイテムを選択できなくなります。したがって、上記の例で示したように、無効なオプションには空の値を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">文字列が &lt;code&gt;#&lt;/code&gt; で始まる場合、それはquerySelectorとして使用され、選択された要素のinnerHTMLをテンプレート文字列として使用します。これにより、一般的な &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; トリックを使用してテンプレートを含めることができます。</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">遷移コンポーネントが&lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScriptフックを&lt;/a&gt;提供した場合、これらのフックは適切なタイミングで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt;や&lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;など、使用したいサードパーティのルーターがある場合、統合も&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;同様に簡単&lt;/a&gt;です。Page.jsを使用した&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;完全な例&lt;/a&gt;を次に示します。</target>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">このオプションがインスタンス化時に使用できる場合、インスタンスはすぐにコンパイルに入ります。それ以外の場合、ユーザーは明示的に &lt;code&gt;vm.$mount()&lt;/code&gt; を呼び出して手動でコンパイルを開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">ノードの初期レンダーにもトランジションを適用したい場合は、 &lt;code&gt;appear&lt;/code&gt; 属性を追加できます。</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">CSS-in-JSのファンであれば、人気のあるCSS-in-JSライブラリの多くがVueをサポートして&lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;います&lt;/a&gt;（たとえば、styled-components-vueや&lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;）。ここでのReactとVueの主な違いは、Vueでのデフォルトのスタイル設定方法が、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネントの&lt;/a&gt;より馴染みのある &lt;code&gt;style&lt;/code&gt; タグを使用することです。</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">経験豊富なフロントエンド開発者であり、Vueが他のライブラリー/フレームワークと比較する方法を知りたい場合は、&lt;a href=&quot;guide/comparison&quot;&gt;他のフレームワークと&lt;/a&gt;の比較を確認してください。</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">大規模なプロジェクトを開発していたり、他の開発者と一緒に作業をしていたり、時にはサードパーティの HTML/CSS (Auth0 など)が含まれていたりする場合、一貫したスコーピングを行うことで、あなたのスタイルがそれらのコンポーネントにのみ適用されることを保証します。</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">仮想DOMの概念に精通していて、JavaScriptの生の力を好む場合は、オプションのJSXサポートを使用して、テンプレートの代わりに&lt;a href=&quot;render-function&quot;&gt;レンダリング関数を直接作成する&lt;/a&gt;こともできます。</target>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Webpackを使用していて、JavaScriptファイルとテンプレートファイルを分離したい場合は、&lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loaderを&lt;/a&gt;使用できます。これにより、ビルドステップ中にテンプレートファイルがJavaScriptレンダリング関数に変換されます。</target>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">ネイティブのESモジュールを使用している場合は、ESモジュール互換のビルドもあります。</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">テンプレートベースの機能コンポーネントを使用している場合は、属性とリスナーを手動で追加する必要もあります。個々のコンテキストコンテンツにアクセスできるため、 &lt;code&gt;data.attrs&lt;/code&gt; を使用してHTML属性を渡し、 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;（ &lt;code&gt;data.on&lt;/code&gt; のエイリアス）&lt;/em&gt;を使用してイベントリスナーを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vue.min.js&lt;/code&gt; を使用している場合、つまりビルドツールなしでスクリプトタグを介してVueを直接インクルードしている場合は、本番用に必ず縮小バージョン（vue.min.js）を使用してください。どちらのバージョンも&lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;インストールガイドに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">コンポーネントのルート要素に属性を継承さ&lt;strong&gt;せ&lt;/strong&gt;たく&lt;strong&gt;ない&lt;/strong&gt;場合は、コンポーネントのオプションで &lt;code&gt;inheritAttrs: false&lt;/code&gt; を設定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">データオプションで &lt;code&gt;message&lt;/code&gt; を宣言しない場合、Vueは、レンダリング関数が存在しないプロパティにアクセスしようとしていることを警告します。</target>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">型推論またはメンバー補完が機能しない場合は、特定のメソッドに注釈を付けると、これらの問題の解決に役立つことがあります。 &lt;code&gt;--noImplicitAny&lt;/code&gt; オプションを使用すると、これらの注釈なしメソッドの多くを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Vueを強制的に更新する必要がある場合は、99.99％のケースで、どこかで間違いを犯しています。</target>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">アプリのパフォーマンスが重要な部分でパーシャルを使用している場合は、&lt;a href=&quot;render-function#Functional-Components&quot;&gt;機能コンポーネントに&lt;/a&gt;アップグレードする必要があります。それらは（ &lt;code&gt;.vue&lt;/code&gt; ファイルではなく）プレーンなJS / JSXファイルになければならず、パーシャルのようにステートレスでインスタンスレスです。これにより、レンダリングが非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">地元のVueコミュニティにもっと参加する方法について質問がある場合は、&lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@ Vuejs_Events&lt;/a&gt;に連絡してください！</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">テストがある場合は、それらを実行して、まだ失敗するものを確認します。テストがない場合は、ブラウザーでアプリを開き、ナビゲートする際の警告やエラーに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">複数のエイリアスが必要な場合は、配列構文を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">ルーターがインスタンス化された後に新しいルートを追加する必要がある場合は、ルーターのマッチャーを、追加するルートを含む新しいマッチャーに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">クライアントでテンプレートをコンパイルする必要がある場合（たとえば、 &lt;code&gt;template&lt;/code&gt; オプションに文字列を渡す、またはそのDOM内のHTMLをテンプレートとして使用して要素にマウントする）場合は、コンパイラーと完全なビルドが必要になります。</target>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">アプリの起動時にプログラムでルートを生成する必要がある場合は、定義をルート配列に動的にプッシュすることで行うことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">リストの遷移をずらす必要がある場合は、要素の &lt;code&gt;data-index&lt;/code&gt; （または同様の属性）を設定してアクセスすることにより、タイミングを制御できます。こちら&lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;の例をご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">非常にシンプルなルーティングだけが必要で、フル機能のルータライブラリを使用したくない場合は、以下のようにページレベルのコンポーネントを動的にレンダリングすることで実現できます。</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">JavaScriptコンソールを再度開いて &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; と入力すると、バインドされたHTML（この場合は &lt;code&gt;title&lt;/code&gt; 属性）が更新されていることが再びわかります。</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">コンポーネントを宣言するときにクラスベースのAPIを使用する場合は、公式に保守されている&lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt;デコレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">よりインタラクティブなものをお好みの場合は、&lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;このチュートリアルシリーズのScrimba&lt;/a&gt;もチェックしてください。スクリーンキャストとコードプレイグラウンドを組み合わせて、いつでも一時停止して遊ぶことができます。</target>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">本当に別の &lt;code&gt;!important&lt;/code&gt; をオーバーライドする必要がある場合は、文字列構文を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">本当に同じ要素/コンポーネントを何度も複製したい場合は、ファクトリー関数を使用して複製することができます。例えば、以下の render 関数は、20 個の同一の段落をレンダリングするための完全に有効な方法です。</target>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">それでもコールバック内でアンウォッチ関数を呼び出したい場合は、まずその利用可能性を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">ただし、テンプレートでこれを試行すると、Vueはエラーを表示し、&lt;strong&gt;すべてのコンポーネントに単一のルート要素が必要であることを&lt;/strong&gt;説明し&lt;strong&gt;ます&lt;/strong&gt;。このエラーを修正するには、次のようにテンプレートを親要素でラップします。</target>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">Webコンポーネントなど、Vue以外のカスタム要素をテンプレートに使用している場合、PascalCaseはVueコンポーネントを明確に表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">プロップを強制したい場合は、そのプロップに基づいてローカルで計算された値を設定します。例えば、代わりに</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">すぐに始めて、単一ファイルのコンポーネントで遊んでみたい場合は、CodeSandboxで&lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;この単純なtodoアプリ&lt;/a&gt;をチェックしてください。</target>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">あなたが小道具としてオブジェクトのすべてのプロパティを渡したい場合は、使用することができ &lt;code&gt;v-bind&lt;/code&gt; （引数なしで &lt;code&gt;v-bind&lt;/code&gt; の代わりに &lt;code&gt;v-bind:prop-name&lt;/code&gt; ）。たとえば、 &lt;code&gt;post&lt;/code&gt; オブジェクトが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">代わりにディレクティブをローカルに登録する場合、コンポーネントは &lt;code&gt;directives&lt;/code&gt; オプションも受け入れます。</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">ユーザー入力を数値として自動的に型キャストしたい場合は、 &lt;code&gt;number&lt;/code&gt; 修飾子を &lt;code&gt;v-model&lt;/code&gt; 管理入力に追加できます。</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">ユーザー入力の空白を自動的にトリミングする場合は、 &lt;code&gt;v-model&lt;/code&gt; 管理の入力に &lt;code&gt;trim&lt;/code&gt; 修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">コンポーネントの更新後、以前に &lt;code&gt;vm.$watch&lt;/code&gt; に依存してDOMを操作していた場合は、代わりに &lt;code&gt;updated&lt;/code&gt; ライフサイクルフックで行うことができます。</target>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">リスト内のクラスを条件付きで切り替えたい場合は、三項式で行うことができます。</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">始める前にVueについて詳しく知りたい場合は、基本原則とサンプルプロジェクトを紹介する動画を作成しました。</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">非同期コンポーネントを使用したい&lt;strong&gt;Browserify&lt;/strong&gt;ユーザーの場合、その作成者は、残念ながら、非同期読み込みは「Browserifyがサポートするものではない」&lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;ことを明らかに&lt;/a&gt;しました。少なくとも公式には。 Browserifyコミュニティは、既存の複雑なアプリケーションに役立つ&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;いくつかの回避策&lt;/a&gt;を見つけました。他のすべてのシナリオでは、組み込みのファーストクラスの非同期サポートにWebpackを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">Reactから来ている場合、vuex がそのエコシステムで最も人気のあるFlux実装である&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;と比較して不思議に思うかもしれません。Reduxは実際にはビューレイヤーに依存しないため、&lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;単純なバインディング&lt;/a&gt;を介してVueで簡単に使用できます。Vuexは、それ&lt;em&gt;が&lt;/em&gt; Vueアプリにあることを&lt;em&gt;知って&lt;/em&gt;いるという点で異なります。これにより、Vueとの統合が向上し、より直感的なAPIと改善された開発エクスペリエンスが提供されます。</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">注意しないと、再帰コンポーネントが無限ループを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; でモジュールシステムを使用していない場合は、おそらく今のところこのセクションをスキップできます。もしそうなら、私たちはあなたのためだけに特別な指示とヒントをいくつか持っています。</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">Vueのコンポーネントにまだ慣れていない場合は、今のところこれをスキップできます。</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">まだここにいる場合は、BabelやWebpackなどのモジュールシステムを使用している可能性があります。このような場合は、 &lt;code&gt;components&lt;/code&gt; ディレクトリを作成し、各コンポーネントを独自のファイルに含めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">たくさんの &lt;code&gt;render&lt;/code&gt; 関数を書いている場合、次のようなものを書くのは苦痛に感じるかもしれません：</target>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">ディレクティブに複数の値が必要な場合は、 JavaScript オブジェクトリテラルを渡すこともできます。覚えておいてください、ディレクティブは有効な JavaScript の式を受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">これが &lt;code&gt;bootstrap-date-input&lt;/code&gt; のテンプレートであると想像してください：</target>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">暗黙の親子コミュニケーション</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">暗黙的な親子通信の&lt;sup&gt;使用には注意が必要です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">2.2.0以降では、 &lt;code&gt;activated&lt;/code&gt; および &lt;code&gt;deactivated&lt;/code&gt; は、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; ツリー内のすべてのネストされたコンポーネントに対して発生します。</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">2.2.0以降では、このフックはコンポーネントのライフサイクルフックのエラーもキャプチャします。また、このフックが &lt;code&gt;undefined&lt;/code&gt; 場合、アプリをクラッシュさせるのではなく、キャプチャされたエラーが &lt;code&gt;console.error&lt;/code&gt; でログに記録されます。</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">2.2.0以降 &lt;code&gt;v-for&lt;/code&gt; は、コンポーネントでv-forを使用するときに、&lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;が必要になります。</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">2.4.0+では、このフックはVueカスタムイベントハンドラ内でスローされるエラーも捕捉します。</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">2.5.0+では、デフォルト値で注入をオプションにすることができます。</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">2.5.0以降では、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;を使用している場合、テンプレートベースの機能コンポーネントを次のように宣言できます。</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">2.6以降では、 &lt;code&gt;v-for&lt;/code&gt; は、ネイティブの &lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;を実装する値でも機能します。ただし、Vue 2.xは現在 &lt;code&gt;Map&lt;/code&gt; および &lt;code&gt;Set&lt;/code&gt; 値の反応をサポートしていないため、変更を自動的に検出できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">2.6.0以降では、このフックは &lt;code&gt;v-on&lt;/code&gt; DOMリスナー内でスローされたエラーもキャプチャします。さらに、対象のフックまたはハンドラーのいずれかがPromiseチェーン（非同期関数など）を返す場合、そのPromiseチェーンからのエラーも処理されます。</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">2.6.0では、名前付きスロットとスコープスロットに新しい統合構文（ &lt;code&gt;v-slot&lt;/code&gt; ディレクティブ）を導入しました。これは、現在は廃止されているが削除されて&lt;em&gt;おらず&lt;/em&gt;、&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;ここで&lt;/a&gt;説明されている、 &lt;code&gt;slot&lt;/code&gt; および &lt;code&gt;slot-scope&lt;/code&gt; 属性に代わるものです。新しい構文を導入する根拠は、この&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFCで&lt;/a&gt;説明されています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">で&lt;a href=&quot;../guide/single-file-components&quot;&gt;単一ファイルのコンポーネント&lt;/a&gt;、 &lt;code&gt;scoped&lt;/code&gt; スタイルは、コンテンツ内部のには適用されません &lt;code&gt;v-html&lt;/code&gt; そのHTMLがVueののテンプレートコンパイラによって処理されていないため、。スコープCSSを使用して &lt;code&gt;v-html&lt;/code&gt; コンテンツをターゲットにする場合は、代わりに、&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール、&lt;/a&gt;またはBEMなどの手動スコープ戦略で追加のグローバル &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 要素を使用できます。</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">JavaScript では、PascalCase はクラスとプロトタイプ コンストラクタのための規約であり、基本的には、異なるインスタンスを持つことができるすべてのものを指します。Vue コンポーネントもインスタンスを持っているので、PascalCase を使用することは理にかなっています。さらに、JSX (およびテンプレート)内で PascalCase を使用することで、コードを読む人はコンポーネントと HTML 要素をより簡単に区別することができます。</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">JavaScriptでは、複数のプロパティを持つオブジェクトを複数の行に分割することは、はるかに読みやすいため、適切な規則と広く見なされています。テンプレートと&lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt;も同じように検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">また、Polymerでは、パフォーマンスを補うためにデータバインディングシステムを非常に限定的にしています。例えば、Polymerのテンプレートでサポートされている式は、ブーリアン否定と単一メソッド呼び出しのみです。また、計算されたプロパティの実装も柔軟性に欠けています。</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">Reactでは、すべてのコンポーネントはJavaScript内で動作する宣言的なXMLのような構文であるJSXを使用して、レンダー関数内でUIを表現しています。</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">Reactでは、すべてがJavaScriptになっています。HTMLの構造をJSXで表現するだけでなく、最近のトレンドではCSSの管理もJavaScriptの中に入れる傾向にあります。このアプローチにはそれなりのメリットがありますが、すべての開発者にとって価値があるとは思えない様々なトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">Reactでは、コンポーネントの状態が変化すると、コンポーネントサブツリー全体の再レンダリングがトリガーされ、そのコンポーネントがルートとして開始されます。子コンポーネントの再描画不要を回避するには、いずれかの利用に必要 &lt;code&gt;PureComponent&lt;/code&gt; や実装 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; をいつでもすることができます。状態の変更をより最適化しやすくするために、不変のデータ構造を使用する必要がある場合もあります。ただし、場合によっては、 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; がサブツリー全体のレンダリング出力が現在のコンポーネントのプロパティによって決定されると想定しているため、このような最適化に依存できない場合があります。そうでない場合、そのような最適化は一貫性のないDOM状態につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">Vue 2.xでは、 &lt;code&gt;Vue.observable&lt;/code&gt; は渡されたオブジェクトを直接変更するため、&lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;ここで示され&lt;/a&gt;ているように、返されるオブジェクトと同等になります。Vue 3.xでは、代わりにリアクティブプロキシが返され、直接変更された場合、元のオブジェクトは非リアクティブのままになります。したがって、将来の互換性のために、最初に渡されたオブジェクトではなく、常に &lt;code&gt;Vue.observable&lt;/code&gt; によって返されたオブジェクトを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">Vue では、コンポーネントは基本的に、あらかじめ定義されたオプションを持つ Vue インスタンスです。Vue にコンポーネントを登録するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Vueでは、コンポーネントの依存関係はレンダリング中に自動的に追跡されるため、システムは、状態が変化したときに実際にどのコンポーネントを再レンダリングする必要があるかを正確に把握しています。各コンポーネントは、ネストされたコンポーネントの警告なしに、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; が自動的に実装されていると見なすことができます。</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Vueでは、&lt;a href=&quot;render-function&quot;&gt;レンダリング機能&lt;/a&gt;も備えており、&lt;a href=&quot;render-function#JSX&quot;&gt;JSX&lt;/a&gt;もサポートしています。これは、その機能が必要になる場合があるためです。ただし、デフォルトのエクスペリエンスとして、より簡単な代替手段としてテンプレートを提供しています。有効なHTMLも有効なVueテンプレートです。これにより、独自のいくつかの利点が得られます。</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">Webpack 4以降では、 &lt;code&gt;mode&lt;/code&gt; オプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">大規模なアプリケーションでは、開発を管理しやすくするために、アプリケーション全体をコンポーネントに分割する必要があります。この&lt;a href=&quot;guide/components&quot;&gt;ガイドの後半で&lt;/a&gt;コンポーネントについて詳しく説明しますが、コンポーネントを使用したアプリのテンプレートの外観の（架空の）例を次に示します。</target>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">ただし、一般的なアプリでは、 &lt;code&gt;data&lt;/code&gt; 一連の投稿がある可能性があります。</target>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">データプロパティに加えて、Vueインスタンスは多くの便利なインスタンスプロパティとメソッドを公開します。ユーザー定義のプロパティと区別するために、これらの前には &lt;code&gt;$&lt;/code&gt; が付いています。例えば：</target>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">テキスト補間以外にも、このように要素の属性をバインドすることもできます。</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; オプションに加えて、命令型の&lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm。$ watch APIを&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">コア（ &lt;code&gt;v-model&lt;/code&gt; および &lt;code&gt;v-show&lt;/code&gt; ）に付属するデフォルトのディレクティブセットに加えて、Vueでは独自のカスタムディレクティブを登録することもできます。Vue 2.0では、コードの再利用と抽象化の主要な形式はコンポーネントです。ただし、プレーンな要素に対する低レベルのDOMアクセスが必要な場合があり、カスタムディレクティブが役立つ場合があります。たとえば、次のように入力要素に焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">さらに、 &lt;code&gt;type&lt;/code&gt; はカスタムコンストラクター関数にすることもでき、アサーションは &lt;code&gt;instanceof&lt;/code&gt; チェックで行われます。たとえば、次のコンストラクタ関数があるとします。</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">さらに、各インスタンス/コンポーネントは、まだ独自のプライベート状態を所有し、管理することができます。</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">さらに、親コンポーネントが更新されるたびに、子コンポーネントのすべての小道具が最新の値で更新されます。つまり、子コンポーネント内のプロップを変更しようとし&lt;strong&gt;ないで&lt;/strong&gt;ください。その場合、Vueはコンソールで警告します。</target>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">まだ気付いていない場合のために、VueはDOM更新を&lt;strong&gt;非同期で&lt;/strong&gt;実行し&lt;strong&gt;ます&lt;/strong&gt;。データの変更が確認されると、キューが開き、同じイベントループで発生するすべてのデータ変更がバッファリングされます。同じウォッチャーが複数回トリガーされた場合、キューに1回だけプッシュされます。このバッファされた重複除外は、不要な計算やDOM操作を回避する上で重要です。次に、次のイベントループ「ティック」で、Vueはキューをフラッシュし、実際の（すでに重複除外されている）作業を実行します。内部的には、Vue は非同期のキューイングのためにネイティブの &lt;code&gt;Promise.then&lt;/code&gt; 、 &lt;code&gt;MutationObserver&lt;/code&gt; 、および &lt;code&gt;setImmediate&lt;/code&gt; を試行し、 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">独自のビルドセットアップを最初からセットアップする場合は、&lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loaderを&lt;/a&gt;使用してwebpackを手動で構成する必要があります。Webpack自体の詳細については&lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;、公式ドキュメント&lt;/a&gt;と&lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">上記のような場合、デフォルトのスロット&lt;em&gt;のみ&lt;/em&gt;がコンテンツを提供すると、コンポーネントのタグをスロットのテンプレートとして使用できます。これにより、コンポーネントで &lt;code&gt;v-slot&lt;/code&gt; 直接使用できます。</target>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">このような場合、コンポーネントを &lt;code&gt;functional&lt;/code&gt; としてマークできます。つまり、コンポーネントはステートレス（&lt;a href=&quot;../api/index#Options-Data&quot;&gt;反応データなし&lt;/a&gt;）であり、インスタンスレス（ &lt;code&gt;this&lt;/code&gt; コンテキストなし）です。&lt;strong&gt;機能性成分&lt;/strong&gt;のようになります。</target>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">コミットされたコードでは、prop の定義は常に可能な限り詳細に、少なくとも type(s)を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">比較すると、 &lt;code&gt;v-show&lt;/code&gt; ははるかに単純です。要素は、CSSベースの切り替えにより、初期状態に関係なく常にレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">これに対して、メソッドの呼び出しでは、再レンダリングが発生するたびに関数&lt;strong&gt;が&lt;/strong&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">開発中のVueは、コンポーネントが誤ったフォーマットの小道具を提供された場合に警告を発し、エラーの原因となる可能性のあるものを検出するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">&lt;code&gt;new Vue&lt;/code&gt; インスタンスのすべてのサブコンポーネントでは、このルートインスタンスに &lt;code&gt;$root&lt;/code&gt; プロパティを使用してアクセスできます。たとえば、このルートインスタンスでは：</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">実際、依存関係の注入は、以下を除いて、一種の「長距離小道具」と考えることができます。</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">一般的に、プレーンなJavaScriptで何かを達成できる場合は常に、同じ問題に対処するためにフィルターなどの特別な構文を導入することは避けたいと考えています。Vueの組み込みディレクティブフィルターを置き換える方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">大規模なアプリケーションでは、アプリを小さなチャンクに分割し、必要なときにのみサーバーからコンポーネントをロードする必要がある場合があります。これを簡単にするために、Vueでは、コンポーネント定義を非同期的に解決するファクトリー関数としてコンポーネントを定義できます。Vueは、コンポーネントをレンダリングする必要がある場合にのみファクトリー関数をトリガーし、将来の再レンダリングのために結果をキャッシュします。例えば：</target>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">多くのVueプロジェクトでは、グローバルコンポーネントは &lt;code&gt;Vue.component&lt;/code&gt; を使用して定義され、その後に &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; が続き、すべてのページの本文のコンテナー要素をターゲットにします。</target>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">しかし多くの場合、あなたはまだ、奇妙な行動に実行されます（例えば &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; に切り上げ &lt;code&gt;0.04&lt;/code&gt; が、 &lt;code&gt;0.045&lt;/code&gt; ラウンドにダウン &lt;code&gt;0.04&lt;/code&gt; ）。これらの問題を回避するには、&lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt;ライブラリを使用して通貨をより確実にフォーマットできます。</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">多くの場合、 &lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;update&lt;/code&gt; で同じ動作が必要になることがありますが、他のフックは気にしません。例えば：</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">ほとんどの場合、トランジションが終了すると、Vueは自動的に判断できます。デフォルトでは、Vue はルート遷移要素の最初の &lt;code&gt;transitionend&lt;/code&gt; または &lt;code&gt;animationend&lt;/code&gt; イベントを待ちます。ただし、これが常に望ましいとは限りません。たとえば、一部のネストされた内部要素の遷移が遅延したり、遷移期間がルート遷移要素よりも長い場合に、振り付けされた遷移シーケンスがある場合があります。</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">ほとんどの場合、他のコンポーネントインスタンスに手を伸ばしたり、DOM要素を手動で操作したりすることは避けるのが最善です。ただし、適切な場合もあります。</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">ほとんどの場合、親に手を伸ばすと、アプリケーションのデバッグや理解が難しくなります。後でそのコンポーネントを見たときに、その突然変異がどこから来たのかを理解するのは非常に難しいでしょう。</target>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">自然英語では、形容詞やその他の記述子は通常名詞の前に現れますが、例外的に接続語が必要になります。例えば</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">通常の使用例では、このメソッドを自分で呼び出す必要はありません。 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用して、データ駆動の方法で子コ​​ンポーネントのライフサイクルを制御することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">私たちのケースでは、 &lt;code&gt;tree-folder&lt;/code&gt; コンポーネントを指すようにします。パラドックスを作成する子は &lt;code&gt;tree-folder-contents&lt;/code&gt; コンポーネントであることを知っているので、 &lt;code&gt;beforeCreate&lt;/code&gt; ライフサイクルフックまで待機して登録します。</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">私たちの経験では、&lt;em&gt;常に&lt;/em&gt;一意のキーを追加することをお勧めします。これにより、あなたとあなたのチームはこれらのエッジケースについて心配する必要がなくなります。次に、オブジェクトの恒常性が必要ない、パフォーマンスが重要なまれなシナリオで、意識的な例外を作成できます。</target>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">計算されたプロパティが実行できない状況（たとえば、ネストされた &lt;code&gt;v-for&lt;/code&gt; ループ内）では、次のメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">場合によっては、小道具に「双方向バインディング」が必要になることがあります。残念ながら、真の双方向バインディングはメンテナンスの問題を引き起こす可能性があります。これは、子コンポーネントが、親と子の両方でその変更のソースが明らかでない場合でも、親を変更できるためです。</target>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">そのような場合、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネントの &lt;code&gt;duration&lt;/code&gt; プロパティを使用して、明示的な遷移時間（ミリ秒単位）を指定できます。</target>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">その場合、親の &lt;code&gt;.native&lt;/code&gt; リスナーは黙って中断します。エラーは発生しませんが、 &lt;code&gt;onFocus&lt;/code&gt; たときにonFocusハンドラーが呼び出されませんでした。</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPMパッケージ&lt;/a&gt;の &lt;code&gt;dist/&lt;/code&gt; ディレクトリーには、 Vue.jsの多くの異なるビルドがあります。これらの違いの概要は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">上記の例では、ハンドラーは &lt;code&gt;$event.key&lt;/code&gt; が &lt;code&gt;'PageDown'&lt;/code&gt; と等しい場合にのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">ブール属性の場合、それらの単なる存在が &lt;code&gt;true&lt;/code&gt; を意味する場合、 &lt;code&gt;v-bind&lt;/code&gt; 動作は少し異なります。この例では：</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">コンソールで、 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; ます。リストに追加された新しいアイテムが表示されます。</target>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">上記の例では、 &lt;code&gt;currentTabComponent&lt;/code&gt; に次のいずれかを含めることができます。</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">上記の例では、 &lt;code&gt;appear&lt;/code&gt; 属性または &lt;code&gt;v-on:appear&lt;/code&gt; フックのいずれかが表示遷移を引き起こします。</target>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">今後、インスタンスのプロパティとメソッドの完全なリストについては、&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;APIリファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">親では、 &lt;code&gt;postFontSize&lt;/code&gt; データプロパティを追加することでこの機能をサポートできます。</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">上記の2つの例では、たまたま文字列値を渡していますが、実際には&lt;em&gt;任意の&lt;/em&gt;タイプの値をプロップに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">このような場合、 &lt;code&gt;key&lt;/code&gt; 属性を使用して、同じ要素の異なる状態間を遷移することもできます。 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-else&lt;/code&gt; を使用する代わりに、上記の例は次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">このような場合は、コンポーネントをプレーンな JavaScript オブジェクトとして定義することができます。</target>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">この場合、 &lt;code&gt;filterA&lt;/code&gt; 単一の引数で定義され、値の受信する &lt;code&gt;message&lt;/code&gt; 、その後 &lt;code&gt;filterB&lt;/code&gt; の機能の結果で呼び出される &lt;code&gt;filterA&lt;/code&gt; に渡さ &lt;code&gt;filterB&lt;/code&gt; の単一の引数。</target>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">この場合、 &lt;code&gt;class&lt;/code&gt; は2つの異なる値が定義されています。</target>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">この場合、 &lt;code&gt;watch&lt;/code&gt; オプションを使用すると、非同期操作（APIへのアクセス）の実行、その操作の実行頻度の制限、最終的な回答が得られるまでの中間状態の設定が可能になります。計算されたプロパティではそれは不可能です。</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">このコンポーネントでは、どのマップと対話するかを知るために、 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; のすべての子孫が &lt;code&gt;getMap&lt;/code&gt; メソッドにアクセスする必要がありました。残念ながら、 &lt;code&gt;$parent&lt;/code&gt; プロパティを使用しても、より深くネストされたコンポーネントに適切にスケーリングできませんでした。：依存性の注入は、2つの新しいインスタンスオプションを使用して、便利ですところです &lt;code&gt;provide&lt;/code&gt; して &lt;code&gt;inject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">この例では、我々はすべて私たちのスロット小道具含むオブジェクト命名することにしました &lt;code&gt;slotProps&lt;/code&gt; を、しかし、あなたはあなたが好きな名前を使用することができます。</target>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;eventName&lt;/code&gt; の値が &lt;code&gt;&quot;focus&quot;&lt;/code&gt; の場合、 &lt;code&gt;v-on:[eventName]&lt;/code&gt; は &lt;code&gt;v-on:focus&lt;/code&gt; と同等になります。</target>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">テンプレート内の式は非常に便利ですが、単純な操作のためのものです。テンプレートに多くのロジックを入れすぎると、テンプレートが肥大化してメンテナンスが大変になることがあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">個々のノード</target>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">React開発者のための情報</target>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">インラインテンプレート</target>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; ブロックの内部では、親スコープのプロパティに完全にアクセスできます。 &lt;code&gt;v-for&lt;/code&gt; は、現在のアイテムのインデックスのオプションの2番目の引数もサポートします。</target>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Vue.jsプラグインをインストールします。プラグインがオブジェクトの場合、 &lt;code&gt;install&lt;/code&gt; メソッドを公開する必要があります。それ自体が関数の場合は、インストール方法として扱われます。installメソッドは、Vueを引数として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">インスタンス DOM オプション</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">インスタンス ライフサイクル フック</target>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">インスタンスメソッド/データ</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">インスタンス メソッド/イベント</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">インスタンス メソッド/ライフサイクル</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">インスタンスのプロパティ</target>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">計算されたプロパティの代わりに、メソッドと同じ関数を定義できます。最終結果については、2つのアプローチはまったく同じです。ただし、&lt;strong&gt;計算されたプロパティはリアクティブな依存関係に基づいてキャッシュされる&lt;/strong&gt;点が&lt;strong&gt;異なります。&lt;/strong&gt;計算されたプロパティは、その反応依存関係の一部が変更された場合にのみ再評価されます。つまり、 &lt;code&gt;message&lt;/code&gt; が変更されていない限り、 &lt;code&gt;reversedMessage&lt;/code&gt; 計算プロパティへの複数のアクセスは、関数を再度実行する必要なく、以前に計算された結果をすぐに返します。</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">メソッド名に直接バインドするのではなく、インラインのJavaScriptステートメントでメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">各todoのコンテンツをハードコーディングする代わりに、すべてのtodoをスロットにして、 &lt;code&gt;todo&lt;/code&gt; をスロットプロップとしてバインドすることで、親コンポーネントに制御を任せることができます。</target>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">このインターフェイスを使用して、ストア自体によって &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; されたイベントを監視する代わりに（例：store.on（ 'mutation'、callback））、新しいメソッド &lt;code&gt;store.subscribe&lt;/code&gt; が導入されました。プラグイン内の一般的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">代わりに、各インスタンスが返されたデータオブジェクトの独立したコピーを維持できるように&lt;strong&gt;、コンポーネントの &lt;code&gt;data&lt;/code&gt; オプションは関数&lt;/strong&gt;で&lt;strong&gt;なければなりません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">代わりに、反応性のあるデータを直接取得します。</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">代わりに、Vueとの競合を保証しないユーザー定義のプライベートプロパティの規則として、2つのプレフィックスを組み合わせて &lt;code&gt;$_&lt;/code&gt; にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">その代わりに、各コンポーネントのインスタンスが自分のデータだけを管理するようにしたいのです。そのためには、各インスタンスが一意のデータオブジェクトを生成しなければなりません。JavaScriptでは、関数でオブジェクトを返すことで実現できます。</target>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">その代わり、短縮記号を使用したい場合は必ずスロット名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">代わりに、&lt;strong&gt;オブジェクトの&lt;/strong&gt;配列を使用して、 &lt;code&gt;v-model&lt;/code&gt; がオブジェクトのフィールドを更新できるようにする必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">サードパーティ製ルーターの統合</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">興味深いことに、AngularとVueがこれらのAngularJSの問題に対処している点では、かなりの類似点があります。</target>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">内部的には、スコープされたスロットは、1つの引数を渡された関数の中でスロットの内容をラップすることで動作します。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">textareas（ &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; ）の補間は機能しません。代わりに &lt;code&gt;v-model&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;削除された&lt;/sup&gt;属性内の補間&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">属性内での補間は有効ではなくなりました。例えば</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">また、デザイナーや経験の浅い開発者が解析してコードベースに貢献することも、より簡単になります。</target>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">また、要素/コンポーネントを再利用する代わりに強制的に置換するためにも使用できます。これは、次のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">ユーザーが作成した&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;プリセット&lt;/a&gt;からプロジェクトを生成することはできません。これは、事前に確立された規則を持つエンタープライズ環境で特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">それはいくつかの要因によります。</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Vue CLIは、&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;プラグイン&lt;/a&gt;を介して拡張できるアップグレード可能なランタイム依存関係の上で実行されますが、プロジェクト生成中の構成は許可されません。</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">通常、単一の &lt;code&gt;components&lt;/code&gt; ディレクトリをスクロールするよりも、ネストされたサブディレクトリをナビゲートする方が時間がかかります。</target>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">イベントハンドラー内で &lt;code&gt;event.preventDefault()&lt;/code&gt; または &lt;code&gt;event.stopPropagation()&lt;/code&gt; を呼び出すことは非常に一般的です。メソッド内でこれを簡単に行うことができますが、メソッドがDOMイベントの詳細を処理する必要がないよりも、純粋にデータロジックに関するものである方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; を使用して「elseブロック」を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">同じテンプレートに同じ名前の &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; を含めることはサポートされなくなりました。スロットがレンダリングされると、そのスロットは「使い切られ」、同じRender Treeの他の場所にはレンダリングできません。同じコンテンツを複数の場所にレンダリングする必要がある場合は、そのコンテンツを小道具として渡します。</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">現在、コンポーネントインスタンスのルート$ dataを置き換えることは禁止されています。これにより、反応性システムの一部のエッジケースが防止され、コンポーネントの状態がより予測可能になります（特に、型チェックシステムを使用）。</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">スタイルオブジェクトに直接バインドした方がテンプレートがすっきりすることが多いです。</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Vueアプリケーションの真実のソースが生 &lt;code&gt;data&lt;/code&gt; オブジェクトであることはしばしば見落とされます-Vueインスタンスはそれにアクセスすることのみをプロキシします。したがって、複数のインスタンスで共有する必要のある状態がある場合は、IDで共有できます。</target>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">繰り返されるDOMコンテンツが単純な場合、または意図的にパフォーマンスを向上させるためにデフォルトの動作に依存している場合を除き、可能な限り &lt;code&gt;key&lt;/code&gt; 属性に &lt;code&gt;v-for&lt;/code&gt; を提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">ほとんど正常に機能しますが、状態の更新が遅れると奇妙な動作が発生する可能性があります。たとえば、[ &lt;code&gt;Result&lt;/code&gt; ]タブをクリックして、これらの入力の1つに &lt;code&gt;9.999&lt;/code&gt; を入力してみます。入力がフォーカスを失うと、その値は &lt;code&gt;$10.00&lt;/code&gt; 更新されます。ただし、計算された合計を見ると、 &lt;code&gt;9.999&lt;/code&gt; がデータに格納されていることがわかります。ユーザーが見る現実のバージョンは同期していません！</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">これは、単一ページのアプリケーションを構築していることを想定した単一のテンプレートのみを提供しますが、Vueは、さまざまな目的とビルドシステムに対応するさまざまなデフォルトオプションを提供します。</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">ライフサイクルフックのみが &lt;code&gt;picker&lt;/code&gt; にアクセスする必要がある可能性がある場合、ピッカーをコンポーネントインスタンスに保存する必要があります。これはひどいことではありませんが、乱雑と見なされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">ことに留意すべきで&lt;strong&gt;、この制限がない&lt;em&gt;ではない&lt;/em&gt;あなたは、次のいずれかのソースから文字列テンプレートを使用している場合に適用されます&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">レンダリングします。</target>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">実際には、複数の &lt;code&gt;v-if&lt;/code&gt; を使用するか、単一の要素を動的プロパティにバインドすることにより、任意の数の要素間を遷移することが可能です。例えば：</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">JavaScriptのみのトランジションに対して &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; を明示的に追加して、VueがCSS検出をスキップできるようにすることもお勧めします。これにより、CSSルールが誤って移行を妨害することも防ぎます。</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">アプリがネストされたコンポーネントのツリーに編成されるのは一般的です：</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">HTMLテンプレートを読み飛ばすことで、JSコード内でハンドラー関数の実装を見つけやすくなります。</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">要素の存在を切り替えるのも簡単です：</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">これらの制限の多くは、create-react-appチームによって行われた意図的な設計上の決定であり、それらには利点があることに注意することが重要です。たとえば、プロジェクトのニーズが非常に単純で、ビルドプロセスをカスタマイズするために「イジェクト」する必要がない限り、依存関係としてプロジェクトを更新できます。&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;異なる哲学&lt;/a&gt;について詳しくは、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">アクションで元の状態オブジェクトを決して置き換えてはならないことに注意することが重要です。コンポーネントとストアは、変化が観察されるために同じオブジェクトへの参照を共有する必要があります。</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">JavaScriptでグローバルコンポーネントが参照されることはめったにないため、JavaScriptの規則に従うことはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">次のように、コンテンツ全体を新しい要素でラップすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">イベントで特定の値を出力すると便利な場合があります。たとえば、 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントがテキストをどれだけ拡大するかを担当する場合があります。このような場合、 &lt;code&gt;$emit&lt;/code&gt; の2番目のパラメーターを使用して、この値を提供できます。</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSXとテンプレート</target>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScriptフック</target>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">JavaScriptのネイティブ &lt;code&gt;.filter&lt;/code&gt; は、計算されたプロパティ内のJavaScriptの全機能にアクセスできるため、はるかに複雑なフィルタリング操作も管理できます。たとえば、すべてのアクティブユーザーを検索し、大文字と小文字を区別せずに、ユーザーの名前と電子メールの両方に対して照合する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Vue.jsコミュニティに参加してみませんか?</target>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">HTML要素の場合と同様に、次のようにコンテンツをコンポーネントに渡すことができると便利です。</target>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">テンプレート内のマークアップが比較的少ないのをサポートするためだけに。</target>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">ただし、このパターンで構築されたコンポーネントは依然として本質的に壊れやすいことに注意してください。たとえば、新しい &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; コンポーネントを追加し、その中に &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; が表示された場合、そのリージョン内にあるマーカーのみをレンダリングする必要があるとします。</target>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">キーコード</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">キー修飾子</target>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">キー付き &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;エッセンシャル&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">キー付きVフォー</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">KnockoutはMVVMと依存関係追跡スペースのパイオニアであり、その反応システムはVueと非常によく似ています。その&lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;ブラウザーサポート&lt;/a&gt;も、IE6へのサポートとともに、すべてのことを考慮すると非常に印象的です！一方、VueはIE9 +のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">大規模なアプリケーションは、多くのコンポーネントに分散した複数の状態とそれらの間の相互作用のために、複雑さが増すことがよくあります。この問題を解決するために、Vueは&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuexを&lt;/a&gt;提供しています。それは、エルムにインスパイアされた独自の状態管理ライブラリです。さらに、&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtoolsに&lt;/a&gt;統合して、&lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;タイムトラベルデバッグ&lt;/a&gt;へのセットアップ不要のアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">最後に、Vueの単一ファイルコンポーネントのスタイル設定は非常に柔軟です。スルー&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;VUE-ローダー&lt;/a&gt;、あなたが持つ任意のプリプロセッサ、ポストプロセッサ、さらに深い統合に使用できる&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt;内のすべてを- &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">最新の安定版:2.6.10</target>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">依存関係注入の詳細については&lt;a href=&quot;../api/index#provide-inject&quot;&gt;、APIドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">学習曲線</target>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 関数が実用的である簡単な例を見てみましょう。アンカーされた見出しを生成したいとします。</target>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">ToDoリストのリストがあるとします。</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">固定位置を使用して要素をページに固定できるカスタムディレクティブを作成するとします。次のように、値がピクセル単位で垂直位置を更新するカスタムディレクティブを作成できます。</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Finderやエクスプローラなどのファイルディレクトリツリーを構築しているとしましょう。次のテンプレートを使用して、 &lt;code&gt;tree-folder&lt;/code&gt; コンポーネントがあるとします。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">ライフサイクル図</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">ライフサイクルイベント(呼ばれている順</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">ライフサイクルフック</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">入退社・退社のトランジション一覧</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">リストの移動遷移</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">リストレンダリング</target>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">リスト トランジション</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">現在のVMでカスタムイベントをリッスンします。イベントは &lt;code&gt;vm.$emit&lt;/code&gt; によってトリガーできます。コールバックは、これらのイベントトリガーメソッドに渡されるすべての追加の引数を受け取ります。</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">カスタムイベントをリッスンしますが、一度だけです。リスナーは最初にトリガーされると削除されます。</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; だけイベントをリッスンします</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; イベントをリッスンします</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; が&lt;sup&gt;変更さ&lt;/sup&gt;れたコンポーネントでのネイティブイベントのリッスン&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">子コンポーネントのイベントを聞く</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">イベントのリスニング</target>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">子コンポーネントのカスタムイベントをリッスンします（「my-event」が子で発行されると、ハンドラーが呼び出されます）：</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">ケバブ漬けバージョンを聴いても何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">ローカル登録</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">モジュールシステムにおけるローカル登録</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">ロジックがプレゼンテーション層から切り離され、メンテナンス(ロジックの変更・拡張)が格段に楽になりました。</target>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">状態の維持</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Vueの外部で定義されたカスタム要素を無視する（たとえば、WebコンポーネントAPIを使用する）。それ以外の場合は、グローバルコンポーネントの登録を忘れたか、コンポーネント名のスペルを間違えた場合、 &lt;code&gt;Unknown custom element&lt;/code&gt; に関する警告がスローされます。</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">オブジェクトをリアクティブにします。内部的には、Vueは &lt;code&gt;data&lt;/code&gt; 関数によって返されたオブジェクトでこれを使用します。</target>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;Vueのさまざまなビルド&lt;/a&gt;についてお読みになり、公開サイトで&lt;strong&gt;本番&lt;br/&gt;バージョン&lt;/strong&gt;を使用して、 &lt;code&gt;vue.js&lt;/code&gt; を &lt;code&gt;vue.min.js&lt;/code&gt; に置き換えてください。これは、開発経験ではなく、速度を重視して最適化された小さなビルドです。</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">多くの状態遷移を管理すると、Vueインスタンスまたはコンポーネントの複雑さが急速に高まります。幸い、多くのアニメーションを専用の子コンポーネントに抽出できます。前の例のアニメーション化された整数でこれを実行してみましょう：</target>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">&lt;code&gt;this.$root&lt;/code&gt; 状態を管理したり、&lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;グローバルイベントバス&lt;/a&gt;を使用したりすることは、非常に単純な場合には便利ですが、ほとんどのアプリケーションには適していません。Vuexは、状態を管理するための中心的な場所を提供するだけでなく、状態の変更を整理、追跡、およびデバッグするためのツールも提供します。</target>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">子、小道具、またはデータを操作してから子コンポーネントに渡す</target>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">似たような名前のファイルが多く、コードエディタでの迅速なファイル切り替えが難しくなっています。</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">多くのネストされたサブディレクトリ。これにより、エディターのサイドバーでコンポーネントを参照するのにかかる時間が長くなります。</target>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">コンポーネントの多くは比較的汎用的で、おそらく入力やボタンなどの要素をラップするだけです。これらは&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本コンポーネント&lt;/a&gt;と呼ばれることもあり、コンポーネント全体で非常に頻繁に使用される傾向があります。</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用した配列の要素へのマッピング</target>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">メタインスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">メソッドイベントハンドラ</target>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">インラインハンドラのメソッド</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Vueインスタンスに混合されるメソッド。これらのメソッドには、VMインスタンスで直接アクセスするか、ディレクティブ式で使用できます。すべてのメソッドは、 &lt;code&gt;this&lt;/code&gt; コンテキストを自動的にVueインスタンスにバインドします。</target>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;置き換えられた&lt;/sup&gt;ミドルウェア&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">ミドルウェアはプラグインに置き換えられます。プラグインはストアを唯一の引数として受け取り、ストア上の突然変異イベントを聞くことができる関数です。</target>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Vue 1.xからの移行</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Vue Router 0.7.xからの移行</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Vuex 0.6.xから1.0への移行</target>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Mixinフックは提供順に呼び出され、コンポーネント自体のフックの前に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">ミックスインは、Vueコンポーネントの再利用可能な機能を柔軟に配布する方法です。mixinオブジェクトには、任意のコンポーネントオプションを含めることができます。コンポーネントがミックスインを使用する場合、ミックスインのすべてのオプションがコンポーネントの独自のオプションに「ミックス」されます。</target>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobXはReactコミュニティで非常に人気があり、実際にはVueとほぼ同じ反応システムを使用しています。限られた範囲で、React + MobXワークフローはより冗長なVueと考えることができます。そのため、その組み合わせを使用していて楽しんでいる場合、Vueにジャンプすることはおそらく次の論理的なステップです。</target>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">修飾キー</target>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">修飾子は、ドットで示された特別な接尾辞であり、ディレクティブを特別な方法でバインドする必要があることを示します。たとえば、 &lt;code&gt;.prevent&lt;/code&gt; 修飾子は、トリガーされたイベントで &lt;code&gt;event.preventDefault()&lt;/code&gt; を呼び出すように &lt;code&gt;v-on&lt;/code&gt; ディレクティブに指示します。</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">モジュールシステム</target>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">より成熟したツールのサポート。Vueは&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt;と&lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserifyの&lt;/a&gt;公式サポートを提供し、Riotはビルドシステムの統合をコミュニティのサポートに依存しています。</target>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;を使用している場合、以下のヒントのほとんどはデフォルトで有効になっています。このセクションは、カスタムビルドセットアップを使用している場合にのみ該当します。</target>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">プロップの突然変異のほとんどのユースケースは、これらのオプションのいずれかで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">マウスボタンモディファイア</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">はるかに良いですね。</target>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">はるかに簡単です！ちょっと。コードは短くなりますが、Vueインスタンスのプロパティをよく理解する必要もあります。この場合、 &lt;code&gt;v-slot&lt;/code&gt; ディレクティブのない子を &lt;code&gt;Hello world!&lt;/code&gt; のようにコンポーネントに渡すときに知っておく必要があります。 &lt;code&gt;$slots.default&lt;/code&gt; &lt;code&gt;anchored-heading&lt;/code&gt; 内部では、それらの子はコンポーネントインスタンスの$ slots.defaultに保存されます。まだ行っていない場合は、&lt;strong&gt;レンダリング関数に飛び込む前に&lt;/strong&gt;&lt;strong&gt;、&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;インスタンスプロパティAPI&lt;/a&gt;を一読することをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">多属性要素</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">マルチ属性要素を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">複数単語のコンポーネント名</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">マルチワードのコンポーネント名は&lt;sup&gt;必須です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">マルチラインテキスト</target>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">複数の値</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">複数のチェックボックスは、同じ配列にバインドされています。</target>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">一度に1つだけレンダリングされる複数のノード</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">複数選択(Array にバインド)。</target>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">口ひげはHTML属性内では使用できません。代わりに、&lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bindディレクティブを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">プロップをローカルで変更することは、アンチパターンと見なされます。たとえば、プロップを宣言してから、コンポーネントで &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 設定します。新しいレンダリングメカニズムにより、親コンポーネントが再レンダリングされるたびに、子コンポーネントのローカル変更が上書きされます。</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">突然変異法</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">名前が示すように、変異メソッドは、呼び出された元の配列を変異させます。これとは対照的に、元の配列を変更せずに&lt;strong&gt;常に新しい配列を返す&lt;/strong&gt; &lt;code&gt;filter()&lt;/code&gt; 、 &lt;code&gt;concat()&lt;/code&gt; 、および &lt;code&gt;slice()&lt;/code&gt; などの非変更メソッドもあります。変更しないメソッドを使用する場合は、古い配列を新しい配列に置き換えることができます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">NPMは、Vueを使用して大規模なアプリケーションを構築するときに推奨されるインストール方法です。&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;や&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;などのモジュールバンドルとうまく組み合わせられます。Vueは、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;を作成するための付属ツールも提供します。</target>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">ネームケーシング</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">名前の競合（複数の &lt;code&gt;ButtonDelete.vue&lt;/code&gt; コンポーネントなど）により、コードエディターで特定のコンポーネントにすばやく移動することがより困難になります。</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">ネームドスロット</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">ネームドスロットの略語</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; 属性を持つ名前付きスロット</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">ネイティブレンダリング</target>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0+の新機能</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0以降の新機能：コールバックが提供されておらず、実行環境でPromiseがサポートされている場合にPromiseを返します。VueにはPromiseポリフィルが付属していないので、Promiseをネイティブでサポートしていないブラウザー（IEを見て）を対象とする場合は、自分でポリフィルを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+の新機能</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0の新機能</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+の新機能</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+の新機能</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0+の新機能</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+の新機能</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+の新機能</target>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">警告はデフォルトでスタックトレースと一緒に表示されるようになったので、不要になりました。</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">実際の使用はありません。どういうわけかこの機能に依存していて、それを回避する方法がわからない場合は、アイデアを&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラム&lt;/a&gt;に投稿してください。</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">ノード、ツリー、仮想 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">非プロップ属性</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">非フラックス状態の管理</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">非フラックス状態管理の&lt;sup&gt;使用には注意が必要です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">アニメーションが適切に機能するためには、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; のすべての子が&lt;strong&gt;一意にキー設定さ&lt;/strong&gt;れる必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; では、コンポーネントで &lt;code&gt;name&lt;/code&gt; オプションを使用するか、ローカル/グローバル登録を通じて、すべてのコンポーネントに名前を付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; オプションは &lt;code&gt;style&lt;/code&gt; と &lt;code&gt;class&lt;/code&gt; バインディングに&lt;strong&gt;は&lt;/strong&gt;影響し&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">注 &lt;code&gt;mounted&lt;/code&gt; ん&lt;strong&gt;ではない&lt;/strong&gt;すべての子コンポーネントにもマウントされていることを保証します。あなたは全体のビューがレンダリングされるまで待ちたい場合は、使用することができ&lt;a href=&quot;#vm-nextTick&quot;&gt;、VMを$ nextTickする。&lt;/a&gt;内部 &lt;code&gt;mounted&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">なお、 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; でサポートされていません &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; あなたは新しいタブでリンクを開く必要がある場合ので、あなたが使用する必要があり、 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">ことを注意 &lt;code&gt;updated&lt;/code&gt; ない&lt;strong&gt;ではない&lt;/strong&gt;、すべての子コンポーネントも再描画されていることを保証します。あなたはビュー全体が再描画されるまで待つしたい場合は、使用することができ&lt;a href=&quot;#vm-nextTick&quot;&gt;、VMを$ nextTickする。&lt;/a&gt;内部の &lt;code&gt;updated&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">なお、 &lt;code&gt;v-bind&lt;/code&gt; と &lt;code&gt;.sync&lt;/code&gt; 修飾子がない&lt;strong&gt;ではない&lt;/strong&gt;表情で作業（例えば &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 無効です）。代わりに、 &lt;code&gt;v-model&lt;/code&gt; のように、バインドするプロパティの名前のみを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-show&lt;/code&gt; は &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素をサポートしておらず、 &lt;code&gt;v-else&lt;/code&gt; でも機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">非推奨の&lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; &lt;/a&gt;属性とは異なり、&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; は &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;のみ追加できることに&lt;/strong&gt;注意してください（&lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;1つの例外があります&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">&lt;strong&gt;ローカルに登録されたコンポーネントは、サブコンポーネントでも使用でき&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;ことに注意してください。あなたが望んでいた場合たとえば、 &lt;code&gt;ComponentA&lt;/code&gt; はで利用できるようにするために &lt;code&gt;ComponentB&lt;/code&gt; 、あなたが使用する必要があるだろう。</target>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;strong&gt;メソッドの定義にアロー関数を使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;（例： &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ）。理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのVueインスタンスではなく、 &lt;code&gt;this.a&lt;/code&gt; が未定義になるためです。</target>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;strong&gt;ウォッチャーの定義にアロー関数を使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;（例： &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ）。理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのVueインスタンスではなく、 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; が未定義になるためです。</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Vueのイベントシステムは、ブラウザの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;とは異なることに注意してください。 &lt;code&gt;$emit&lt;/code&gt; 、 &lt;code&gt;$on&lt;/code&gt; 、および &lt;code&gt;$off&lt;/code&gt; は同様に機能しますが、 &lt;code&gt;dispatchEvent&lt;/code&gt; 、 &lt;code&gt;addEventListener&lt;/code&gt; 、および &lt;code&gt;removeEventListener&lt;/code&gt; のエイリアスではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">他のディレクティブ（ &lt;code&gt;v-if&lt;/code&gt; や &lt;code&gt;v-show&lt;/code&gt; など）については、JavaScriptの通常の真実性が引き続き適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">計算されたプロパティで矢印関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; プロパティで矢印関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">ES2015 +では、 &lt;code&gt;ComponentA&lt;/code&gt; のような変数名をオブジェクト内に配置することは、 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 短縮形であることに注意してください。つまり、変数の名前は両方です。</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">このメソッドでは、DOM に触れることなくアプリの状態を更新することに注意してください。DOM の操作はすべて Vue によって処理され、あなたが書くコードは基礎となるロジックに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">それがだと注意&lt;strong&gt;ません&lt;/strong&gt;使用することをお勧め &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; 一緒に。詳細については、&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">修飾キーは通常のキーとは異なり、キー &lt;code&gt;keyup&lt;/code&gt; イベントで使用する場合、イベントが発生したときにそれらを押す必要があることに注意してください。つまり、 &lt;code&gt;keyup.ctrl&lt;/code&gt; は、 &lt;code&gt;ctrl&lt;/code&gt; を押しながらキーを離した場合にのみトリガーされます。 &lt;code&gt;ctrl&lt;/code&gt; キーのみを離してもトリガーされません。このような動作が必要な場合は、代わりに &lt;code&gt;ctrl&lt;/code&gt; の &lt;code&gt;keyCode&lt;/code&gt; を使用してください： &lt;code&gt;keyup.17&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">JavaScriptのオブジェクトと配列は参照によって渡されるため、propが配列またはオブジェクトの場合、子コンポーネント内でオブジェクトまたは配列自体を変更する&lt;strong&gt;と&lt;/strong&gt;、親の状態に影響します。</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">コンポーネントのインスタンスが作成さ&lt;strong&gt;れる前に&lt;/strong&gt;小道具が検証さ&lt;strong&gt;れる&lt;/strong&gt;ため、インスタンスのプロパティ（例： &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;computed&lt;/code&gt; など）は、 &lt;code&gt;default&lt;/code&gt; または &lt;code&gt;validator&lt;/code&gt; 関数内では使用できません。</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">ことを注意 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; は、彼らが持っていないため、要素は、まだ効率的に再利用されている &lt;code&gt;key&lt;/code&gt; 属性を。</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">デフォルトのスロットの省略された構文は、スコープのあいまいさにつながるため、名前付きスロットと混在さ&lt;strong&gt;せることはできません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">同じマージ戦略が &lt;code&gt;Vue.extend()&lt;/code&gt; で使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">&lt;code&gt;immediate&lt;/code&gt; オプションでは、最初のコールバック呼び出しで指定されたプロパティを監視解除できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;strict: true&lt;/code&gt; （または少なくとも &lt;code&gt;noImplicitThis: true&lt;/code&gt; を含める必要があります。これは &lt;code&gt;strict&lt;/code&gt; フラグの一部です）を使用し &lt;code&gt;this&lt;/code&gt; 、コンポーネントのメソッドでこれの型チェックを活用しないと、常に &lt;code&gt;any&lt;/code&gt; 型として扱われます。</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">ルートコンポーネントに上記の構文を使用する場合は、&lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0以降を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">コンポーネントの &lt;code&gt;props&lt;/code&gt; オプションで &lt;code&gt;checked&lt;/code&gt; プロップを宣言する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 属性に注意してください。 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 要素のみが &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 内で有効であるため、これはDOMテンプレートで必要です。 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; と同じことを行いますが、潜在的なブラウザ解析エラーを回避します。詳細については、&lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOMテンプレートの解析に関する警告&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">注、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 、それがトグルされている1つの直接の子要素を持っている場合のために設計されています。内部に &lt;code&gt;v-for&lt;/code&gt; がある場合は機能しません。上記のように複数の条件付き子がある場合、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は一度に1つの子のみがレンダリングされることを要求します。</target>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">注：Macintoshキーボードでは、メタはコマンドキー（⌘）です。Windowsキーボードでは、メタはWindowsキー（⊞）です。Sun Microsystemsのキーボードでは、メタはひし形（◆）としてマークされています。特定のキーボード、特にMITおよびLispマシンのキーボードとその後継機（Knightキーボード、スペースカデットキーボードなど）では、メタに「META」というラベルが付いています。シンボリックキーボードでは、メタには「META」または「Meta」というラベルが付いています。</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">注：2.3.0より前のバージョンでは、機能コンポーネントで小道具を受け入れる場合は、 &lt;code&gt;props&lt;/code&gt; オプションが必要です。2.3.0以降では、 &lt;code&gt;props&lt;/code&gt; オプションを省略でき、コンポーネントノードにあるすべての属性が暗黙的にpropsとして抽出されます。</target>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">注：バインディングの &lt;code&gt;provide&lt;/code&gt; と &lt;code&gt;inject&lt;/code&gt; は反応しません。これは意図的なものです。ただし、監視対象のオブジェクトを渡す場合、そのオブジェクトのプロパティは引き続き反応します。</target>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">注：このオプションは、 &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; バインディングに&lt;strong&gt;は&lt;/strong&gt;影響し&lt;strong&gt;ませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">注：オブジェクトまたは配列を（置き換えるのではなく）変更すると、同じオブジェクト/配列を参照するため、古い値は新しい値と同じになります。Vueは事前変換値のコピーを保持しません。</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">ストアの状態を変更するすべてのアクションがストア自体の内部に置かれていることに注意してください。このタイプの集中状態管理により、発生する可能性のある変異のタイプと、それらがどのようにトリガーされるかを理解しやすくなります。何か問題が発生すると、バグに至るまでに何が起こったかのログも表示されます。</target>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">ボタンをクリックすると、ボタンごとに独自の &lt;code&gt;count&lt;/code&gt; 維持されることに注意してください。これは、コンポーネントを使用するたびに、その新しい&lt;strong&gt;インスタンス&lt;/strong&gt;が作成されるためです。</target>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">これで、 &lt;code&gt;v-model&lt;/code&gt; はこのコンポーネントで完全に機能するはずです。</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">今両方 &lt;code&gt;ComponentA&lt;/code&gt; と &lt;code&gt;ComponentC&lt;/code&gt; が内部で使用することができ &lt;code&gt;ComponentB&lt;/code&gt; のテンプレート。</target>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">これで、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素内のすべてが対応するスロットに渡されます。 &lt;code&gt;v-slot&lt;/code&gt; を使用して &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; でラップされていないコンテンツは、デフォルトスロット用であると見なされます。</target>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">この &lt;code&gt;ref&lt;/code&gt; を定義したコンポーネントで、次を使用できます。</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">それでは、詳細を見ていきましょう。Vueの最も特徴的な機能の1つは、目立たない反応システムです。モデルは単なるプレーンJavaScriptオブジェクトです。それらを変更すると、ビューが更新されます。状態管理がシンプルで直感的になりますが、一般的な問題を回避するためにそれがどのように機能するかを理解することも重要です。このセクションでは、Vueの反応性システムの下位レベルの詳細をいくつか掘り下げます。</target>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">次に、すべての投稿のコンテンツの直前にテキストを拡大するボタンを追加しましょう。</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">次に、例を見てみましょう。前に使用したのと同じCSSクラスを使用して、出入りを遷移させます。</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">それでは、例を見てみましょう。Velocity.jsを使用したJavaScriptトランジションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;out-in&lt;/code&gt; を使用してオン/オフボタンの遷移を更新します。</target>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">今 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントがある&lt;strong&gt;完全に透明ラッパー&lt;/strong&gt;、それは正確に通常のように使うことができることを意味、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 要素：すべての同じ属性とリスナーはせずに、動作します &lt;code&gt;.native&lt;/code&gt; 修飾子。</target>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">これで、[ &lt;em&gt;投稿&lt;/em&gt; ]タブは、レンダリングされていなくてもその状態（選択された投稿）を維持します。完全なコードについては、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;このフィドル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">これで、トグルするたびに入力がスクラッチからレンダリングされるようになりました。自分の目で確かめてみてください。</target>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">これで、 &lt;code&gt;v-bind&lt;/code&gt; を使用して、繰り返される各コンポーネントにtodoを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">今、手に入れた。</target>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">コミュニティがあなたのためにできることと、あなたがコミュニティのためにできることの両方に答えます。</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">このコンポーネントで &lt;code&gt;v-model&lt;/code&gt; を使用する場合：</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">ここで、親コンポーネントで &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; を使用すると、スロットにコンテンツが提供されません。</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">&lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; コンポーネントを使用する場合、todoアイテムの代替 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; をオプションで定義できますが、子からのデータにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">ここで、 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; を実行すると、セッターが呼び出され、それに応じて &lt;code&gt;vm.firstName&lt;/code&gt; と &lt;code&gt;vm.lastName&lt;/code&gt; が更新されます。</target>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">これで、 &lt;code&gt;sourceOfTruth&lt;/code&gt; が変更されるたびに、 &lt;code&gt;vmA&lt;/code&gt; と &lt;code&gt;vmB&lt;/code&gt; の両方がビューを自動的に更新します。これらの各インスタンス内のサブコンポーネントも &lt;code&gt;this.$root.$data&lt;/code&gt; 介してアクセスできます。現在、単一の真の情報源がありますが、デバッグは悪夢です。データの一部は、トレースを残さずに、アプリのどの部分でもいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">これで、別のコンポーネントのテンプレートで作成できます。</target>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これで、新しいプロパティが &lt;code&gt;post&lt;/code&gt; オブジェクトに追加されると、 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 内で自動的に利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">オブジェクト変更検出の注意点</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">オブジェクトリテラル</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">オブジェクト構文</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">NPMパッケージでの公式宣言</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">フラックスライクな公式実装</target>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">公式ルーター</target>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">上の &lt;code&gt;input&lt;/code&gt; 、独自のカスタム発する &lt;code&gt;input&lt;/code&gt; 新しい値でイベントを</target>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">より高いレベルでは、コンポーネントを2つのカテゴリに分けることができます:現在のものと論理的なものです。提示的なコンポーネントにはテンプレートを使用し、論理的なコンポーネントにはレンダリング関数/JSXを使用することをお勧めします。これらのコンポーネントの割合は、構築しているアプリの種類によって異なりますが、一般的には、提示型のコンポーネントの方がはるかに一般的です。</target>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">通常のコンポーネントでは、propsとして定義されていない属性は自動的にコンポーネントのルート要素に追加され、同じ名前の既存の属性に置き換えられるか、&lt;a href=&quot;class-and-style&quot;&gt;インテリジェントにマージされ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">ルートVueインスタンス（つまり、 &lt;code&gt;new Vue({ ... })&lt;/code&gt; 作成されたインスタンス）では、 &lt;code&gt;props&lt;/code&gt; ではなく &lt;code&gt;propsData&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">一方、 &lt;code&gt;$refs&lt;/code&gt; は主にJavaScriptでのプログラムによるアクセス用に設計されています。テンプレートでそれらに依存することはお勧めできません。インスタンス自体に属さない状態を参照することになるためです。これは、Vueのデータ駆動型ビューモデルに違反します。</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">一方、ランタイムのみのビルドは完全にCSPに準拠しています。&lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt;または&lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;でランタイムのみのビルドを使用する場合、テンプレートは、CSP環境で完全に機能 &lt;code&gt;render&lt;/code&gt; 関数にプリコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">このページでは、遷移の開始、終了、リストのみを扱いますが、&lt;a href=&quot;transitioning-state&quot;&gt;状態遷移の管理&lt;/a&gt;に関する次のセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">プロップが登録されると、以下のようにカスタム属性としてデータを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">もう一度、このパターンを使いすぎないようにしてください。多くの静的コンテンツをレンダリングする必要があるというまれなケースでは便利ですが、実際に遅いレンダリングに気付かない限り、それは必要ありません。さらに、後で多くの混乱を引き起こす可能性があります。たとえば、 &lt;code&gt;v-once&lt;/code&gt; に慣れていない、または単にテンプレートでそれを見逃している別の開発者を想像してみてください。テンプレートが正しく更新されない理由を解明するために何時間も費やす可能性があります。</target>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">一度観測されると、ルート データ オブジェクトにリアクティブ プロパティを追加することはできなくなります。そのため、インスタンスを作成する前に、すべてのルートレベルの反応性プロパティを前もって宣言しておくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">ダイジェストした知識に満足できたら、&lt;a href=&quot;components-dynamic-async&quot;&gt;ダイナミックと非同期コンポーネント&lt;/a&gt;に関する完全なガイドと、サイドバーの[コンポーネントの詳細]セクションにある他のページをもう一度読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">重要な注意点の1つは、これらのFLIPトランジションは、 &lt;code&gt;display: inline&lt;/code&gt; するように設定された要素では機能しないことです。代わりに、 &lt;code&gt;display: inline-block&lt;/code&gt; 使用するか、要素をflexコンテキストに配置できます。</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">注意すべき重要な点の1つは&lt;strong&gt;、懸念事項の分離はファイルタイプの分離と同じではないということです。&lt;/strong&gt;最近のUI開発では、コードベースを相互に織り交ぜる3つの巨大なレイヤーに分割する代わりに、それらを疎結合コンポーネントに分割して構成する方がはるかに理にかなっていることがわかりました。コンポーネントの内部では、そのテンプレート、ロジック、およびスタイルが本質的に結び付けられており、それらを配置することで、コンポーネントがよりまとまりやすく、保守しやすくなります。</target>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">最も一般的な遷移タイプの1つはCSS遷移を使用します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">これらのメソッドの最も一般的な用途の1つは、親とその直接の子の間の通信です。これらの場合、実際に&lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;は&lt;/a&gt; &lt;code&gt;v-on&lt;/code&gt; の子からの &lt;code&gt;$emit&lt;/code&gt; 聞くことができます。これにより、明示性を追加してイベントの利便性を維持できます。</target>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">1つ以上の名前付きパラメーターが&lt;sup&gt;変更されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">注意すべき点の1つ：テンプレートで &lt;code&gt;v-bind:class&lt;/code&gt; と &lt;code&gt;v-bind:style&lt;/code&gt; が特別に扱われるのと同様に、VNodeデータオブジェクトに独自のトップレベルフィールドがあります。このオブジェクトを使用すると、通常のHTML属性や &lt;code&gt;innerHTML&lt;/code&gt; などのDOMプロパティをバインドすることもできます（これにより、 &lt;code&gt;v-html&lt;/code&gt; ディレクティブが置き換えられます）。</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">ワンタイムバインディング（ &lt;code&gt;{{* foo }}&lt;/code&gt; ）は、新しい&lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; ディレクティブに&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">ワンタイムバインディングが&lt;sup&gt;置き換えられました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">一方向データフロー</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">BowerからはUMDビルドのみの提供となります。</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Vue Router 2のみがVue 2と互換性があるため、Vueを更新する場合は、Vue Routerも更新する必要があります。そのため、メインのドキュメントに移行パスの詳細を含めました。新しいVueルーターの使用に関する完全なガイドについては、&lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vueルーターのドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Vue Router 2のみがVue 2と互換性があるので、はい、&lt;a href=&quot;migration-vue-router&quot;&gt;Vue Routerの移行パスも&lt;/a&gt;たどる必要があります。幸い、ほとんどのアプリケーションにはルーターのコードがたくさんないので、これにはおそらく1時間もかかりません。</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">2.2.0+のみ:Array+indexでも動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">最適化の取り組み</target>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">マージオプション</target>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">オプション/資産</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">オプション・構成</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">オプション/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">オプション/データ</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">オプション/ライフサイクルフック</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">オプション/その他</target>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;acceptStatement&lt;/code&gt; 、 &lt;code&gt;deep&lt;/code&gt; 、 &lt;code&gt;priority&lt;/code&gt; などのオプションはすべて削除されました。 &lt;code&gt;twoWay&lt;/code&gt; ディレクティブを置き換えるには、&lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;この例を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; 、 &lt;code&gt;components&lt;/code&gt; 、 &lt;code&gt;directives&lt;/code&gt; などのオブジェクト値を必要とするオプションは、同じオブジェクトにマージされます。これらのオブジェクトに競合するキーがある場合、コンポーネントのオプションが優先されます。</target>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">またはデータ/計算されたプロパティ。</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">あるいはレンダー関数。</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">または、コンポーネントをローカルに登録するときに、Webpackの非同期 &lt;code&gt;import&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">または、より良いのは、削除方法をインデックスに渡すことです。</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">あるいは他の部品でも。</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">または、 &lt;code&gt;myElement&lt;/code&gt; が最後の子である場合：</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">または、BabelやWebpackなどを介してES2015モジュールを使用している場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">あるいはレンダー機能を使って</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">またはコンポーネントメソッドで。</target>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">または、イベントハンドラがメソッドの場合。</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">または、Vueのランタイムのみのビルドを使用している場合：</target>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">または、 &lt;code&gt;slot&lt;/code&gt; 属性を通常の要素で直接使用することもできます。</target>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">または、使用して&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt;うなり声とで&lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;面倒-browserify&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">または、&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Gulp&lt;/a&gt;でenvifyを使用します。</target>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">関連するコードが同じ順序で生成されるため、修飾子を使用する場合は順序が重要です。したがって、 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; を使用すると&lt;strong&gt;すべてのクリック&lt;/strong&gt;が防止され、 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; を使用するとエレメント自体のクリックのみが防止されます。</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">コンポーネント名の語順</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">コンポーネント名の単語の順序を&lt;sup&gt;強く推奨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">構成要素の整理</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">トランジションをコンポーネントに整理する</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">私たち&lt;a href=&quot;https://vuejs.org/coc&quot;&gt;の行動規範&lt;/a&gt;は、私たちすべてと私たちが参加する技術コミュニティをより豊かにすることを容易にするためのガイドです。</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">私たちのカスタムディレクティブは、いくつかの異なるユースケースにも対応できるように柔軟になりました。</target>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">セットアップコードはクリーンアップコードとは別のものになっているため、セットアップしたものをプログラム的にクリーンアップすることが難しくなっています。</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">ただし、時間の経過とともに、Knockoutの開発は鈍化し、年齢が少し表示され始めています。たとえば、そのコンポーネントシステムにはライフサイクルフックの完全なセットがありません。これは非常に一般的な使用例ですが、子をコンポーネントに渡すためのインターフェースは、&lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vueのに&lt;/a&gt;比べて少し不格好な感じがします。</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">全体として、これにより、開発者の側からクラス全体のパフォーマンス最適化の必要がなくなり、スケーリングに応じてアプリ自体の構築に集中できるようになります。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">小道具を使用して、コンポーネント間のより明示的なデータフローを優先して、パーシャルが削除されました。パフォーマンスが重要な領域でパーシャルを使用しているのでない限り、代わりに&lt;a href=&quot;components&quot;&gt;通常のコンポーネント&lt;/a&gt;を使用することをお勧めします。パーシャルの &lt;code&gt;name&lt;/code&gt; を動的にバインドしていた場合は、&lt;a href=&quot;components#Dynamic-Components&quot;&gt;動的コンポーネントを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCaseはkebab-caseに比べていくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCaseは、可能な限りJS（X）およびテンプレートのコンポーネントを参照する方法と一貫しているため、コードエディターのオートコンプリートで最適に動作します。ただし、大文字と小文字が混在するファイル名は、大文字と小文字を区別しないファイルシステムで問題を引き起こすことがあります。そのため、ケバブケースも完全に受け入れられます。</target>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">インスタンスの作成中にpropsを渡す。これは主にユニットテストを容易にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">属性とイベントを子要素/コンポーネントに渡す</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">プロップを使用した子コンポーネントへのデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">静的または動的な小道具を渡す</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">ブール値を渡す</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">ナンバーパス</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">配列を渡す</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">オブジェクトを渡す</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">&lt;code&gt;immediate: true&lt;/code&gt; 渡す：オプションでtrueを指定すると、式の現在の値でコールバックが直ちにトリガーされます。</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">オブジェクトのプロパティを渡す</target>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">Ember 3.xでの最新のグリマーエンジンの更新後でも、VueはEmberより&lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;かなり&lt;/a&gt;パフォーマンスが優れています。Vueは自動的に更新をバッチ処理しますが、Emberではパフォーマンスがクリティカルな状況で実行ループを手動で管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNodeクラス宣言を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-rendererパッケージのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">プラグインは、Vueのグローバル/インスタンスプロパティとコンポーネントオプションに追加できます。これらの場合、プラグインをTypeScriptでコンパイルするには、型宣言が必要です。さいわい、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;モジュールの拡張&lt;/a&gt;と呼ばれる既存の型を拡張するTypeScript機能があります。</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">プラグインは通常、Vueにグローバルレベルの機能を追加します。プラグインには厳密に定義されたスコープはなく、通常、いくつかのタイプのプラグインがあります。</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">PolymerはGoogleが後援する別のプロジェクトで、実際にはVueのインスピレーションの源でもありました。VueのコンポーネントはPolymerのカスタム要素と大まかに比較でき、どちらも非常に類似した開発スタイルを提供します。最大の違いは、Polymerが最新のWebコンポーネント機能に基づいて構築されており、ネイティブでこれらの機能をサポートしていないブラウザーで動作するために、重要なポリフィル（パフォーマンスの低下）が必要なことです。対照的に、VueはIE9までの依存関係やポリフィルなしで機能します。</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">コンパイル前のテンプレート</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Preact とその他の React ライクなライブラリ</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">多数の要素セレクターは低速であるため、 &lt;code&gt;scoped&lt;/code&gt; スタイルの要素セレクターよりもクラスセレクターを優先します。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">カッコいいでしょ?</target>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">以前は、 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; を &lt;code&gt;v-for&lt;/code&gt; と組み合わせると、要素/コンポーネントの配列が生成されました。これは、各アイテムに一意の名前を付ける方法がなかったためです。各アイテムに同じ &lt;code&gt;ref&lt;/code&gt; を与えることで、この動作を実現できます。</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">以前は、 &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; は0から9 までの &lt;code&gt;number&lt;/code&gt; でしたが、現在は1から10で終わります。</target>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">主に、コンポーネントの状態を保持したり、再レンダリングを回避するために使用されます。</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">優先順位Aのルール。エッセンシャル(エラー防止</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">優先度A:必須</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">優先度Bのルール。強く推奨(読みやすさの向上</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">優先度B:強く推奨</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">優先順位Cのルール。推奨(恣意的な選択と認知的オーバーヘッドの最小化</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">優先度C:おすすめ</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">優先度Dのルール。注意して使用する(潜在的に危険なパターン</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">優先順位D。注意して使用してください</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">私有財産の名称</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">プライベートプロパティ名は&lt;sup&gt;必須&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">問題解決!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">生産展開</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">プログラムイベントリスナー</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">プログラムナビゲーション</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">他のいくつかのコンポーネントの中から、委任するコンポーネントをプログラムで選択します。</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">プロジェクト作成</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">プロップケーシング(ラクダケース対ケバブケース</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;廃止された&lt;/sup&gt;プロップ変異&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="23ca9a44a1ade4d87027ae10b8309bece2e74a54" translate="yes" xml:space="preserve">
          <source>Prop Types</source>
          <target state="translated">プロップの種類</target>
        </trans-unit>
        <trans-unit id="0d718a828e84189a6c1ea77a0099a78e06d7d7c9" translate="yes" xml:space="preserve">
          <source>Prop Validation</source>
          <target state="translated">プロップの検証</target>
        </trans-unit>
        <trans-unit id="3ad34219a208945c8ea06d8eb918df83f7e61456" translate="yes" xml:space="preserve">
          <source>Prop definitions</source>
          <target state="translated">プロップの定義</target>
        </trans-unit>
        <trans-unit id="e2f4b4fdf875186ea4cf16dbb812dbea30216d87" translate="yes" xml:space="preserve">
          <source>Prop definitions &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">プロップ定義が&lt;sup&gt;不可欠&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="895e352dc19c97709d5567c55fe72b1a6d482c35" translate="yes" xml:space="preserve">
          <source>Prop name casing</source>
          <target state="translated">プロップ名のケーシング</target>
        </trans-unit>
        <trans-unit id="b90f11ae0da8cbfe0b2f736a16886c055d6bffd1" translate="yes" xml:space="preserve">
          <source>Prop name casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">プロップ名の大文字小文字を&lt;sup&gt;強く推奨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="66e61e4c98d3b3a635091c842dada04fef1b9143" translate="yes" xml:space="preserve">
          <source>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt;. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.</source>
          <target state="translated">本番環境対応のサーバーレンダリングアプリのすべての議論された側面を適切に構成することは、困難な作業になる可能性があります。幸いなことに、これをすべて簡単にすることを目的とした優れたコミュニティプロジェクト&lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.jsがあり&lt;/a&gt;ます。 Nuxt.jsは、Vueエコシステムの上に構築された高レベルのフレームワークであり、ユニバーサルVueアプリケーションを作成するための非常に合理化された開発エクスペリエンスを提供します。さらに、静的サイトジェネレーターとして使用することもできます（単一ファイルのVueコンポーネントとしてページが作成されます）。ぜひお試しください。</target>
        </trans-unit>
        <trans-unit id="fc7c765b5dbb95f7134159f12c7f78946b944760" translate="yes" xml:space="preserve">
          <source>Properly trigger lifecycle hooks of a component</source>
          <target state="translated">コンポーネントのライフサイクルフックを適切にトリガーする</target>
        </trans-unit>
        <trans-unit id="e9f3056a7ba256cf707e7dce02bf806a8e3e1baf" translate="yes" xml:space="preserve">
          <source>Properties that start with &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; be proxied on the Vue instance because they may conflict with Vue&amp;rsquo;s internal properties and API methods. You will have to access them as &lt;code&gt;vm.$data._property&lt;/code&gt;.</source>
          <target state="translated">始まるプロパティ &lt;code&gt;_&lt;/code&gt; または &lt;code&gt;$&lt;/code&gt; はなり&lt;strong&gt;ません&lt;/strong&gt;、彼らはVueの内部プロパティとAPIのメソッドと競合する可能性があるため、Vueのインスタンスにプロキシされます。 &lt;code&gt;vm.$data._property&lt;/code&gt; としてアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="824b655ece5f935a9f95c151296cb1d2ff2e73ec" translate="yes" xml:space="preserve">
          <source>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a &lt;code&gt;props&lt;/code&gt; option:</source>
          <target state="translated">小道具は、コンポーネントに登録できるカスタム属性です。値がprop属性に渡されると、そのコンポーネントインスタンスのプロパティになります。タイトルをブログ投稿コンポーネントに渡すには、 &lt;code&gt;props&lt;/code&gt; オプションを使用して、このコンポーネントが受け入れる小道具のリストにタイトルを含めます。</target>
        </trans-unit>
        <trans-unit id="02635ba77eef9661786c01a78d90b7501db1be4e" translate="yes" xml:space="preserve">
          <source>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</source>
          <target state="translated">プロップは常に一方通行になりました。親スコープで副作用を生成するには、コンポーネントは暗黙のバインディングに頼るのではなく、明示的にイベントを放出する必要があります。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="f6122d047108de3e0837cf3e23276a8775fc2406" translate="yes" xml:space="preserve">
          <source>Props on a Root Instance &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">ルートインスタンスの小道具が&lt;sup&gt;置き換えられました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="877adb56a197e1259015de3210d87c2e790b7975" translate="yes" xml:space="preserve">
          <source>Provide an alternative render output when the default &lt;code&gt;render&lt;/code&gt; function encounters an error. The error will be passed to &lt;code&gt;renderError&lt;/code&gt; as the second argument. This is particularly useful when used together with hot-reload.</source>
          <target state="translated">デフォルトの &lt;code&gt;render&lt;/code&gt; 機能でエラーが発生したときに、代替のレンダー出力を提供します。エラーは、2番目の引数として &lt;code&gt;renderError&lt;/code&gt; に渡されます。これは、ホットリロードと一緒に使用すると特に便利です。</target>
        </trans-unit>
        <trans-unit id="02efa133aeef7a133aefd2f252af936a5cccad26" translate="yes" xml:space="preserve">
          <source>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</source>
          <target state="translated">Vue インスタンスに、マウントするための既存の DOM 要素を提供します。CSS セレクタ文字列か、実際の HTMLElement を指定します。</target>
        </trans-unit>
        <trans-unit id="dcf49ab626c30fff5ed5ee4dbe07721b4605c56b" translate="yes" xml:space="preserve">
          <source>Quasar Framework SSR + PWA</source>
          <target state="translated">クエーサーフレームワークSSR+PWA</target>
        </trans-unit>
        <trans-unit id="282e30765bd347047d1a351ac3b6f1cf18becd81" translate="yes" xml:space="preserve">
          <source>Quoted attribute values</source>
          <target state="translated">引用された属性値</target>
        </trans-unit>
        <trans-unit id="683b9e103293a057ef4362aa5bc974a4f8bd8131" translate="yes" xml:space="preserve">
          <source>Quoted attribute values &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">引用された属性値を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ed1e44a4093ca562205b72061c34f1507e70c015" translate="yes" xml:space="preserve">
          <source>RFC-0001</source>
          <target state="translated">RFC-0001</target>
        </trans-unit>
        <trans-unit id="b11bf19e3f65b4a1ada383e41f26dab5c503940e" translate="yes" xml:space="preserve">
          <source>Radio</source>
          <target state="translated">Radio</target>
        </trans-unit>
        <trans-unit id="76550ff95e4521edf8dc9e8329b78993dc047414" translate="yes" xml:space="preserve">
          <source>Raw HTML</source>
          <target state="translated">生のHTML</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b183e9aafa930f129da2c452cc641903b8199bea" translate="yes" xml:space="preserve">
          <source>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!</source>
          <target state="translated">React Nativeを使用すると、同じReactコンポーネントモデルを使用して、iOSとAndroid向けのネイティブレンダリングアプリを作成できます。これは、開発者がフレームワークの知識を複数のプラットフォームに適用できるという点で優れています。この面で、Vueは、Alibaba Groupによって作成され、Apache Software Foundation（ASF）によってインキュベートされているクロスプラットフォームUIフレームワークである&lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;との正式なコラボレーションを持っています。 Weexでは、同じVueコンポーネント構文を使用して、ブラウザーでレンダリングできるだけでなく、iOSおよびAndroidでネイティブにレンダリングできるコンポーネントを作成できます。</target>
        </trans-unit>
        <trans-unit id="ee4366331847de86650378c9e4041dac06218df0" translate="yes" xml:space="preserve">
          <source>React and Vue share many similarities. They both:</source>
          <target state="translated">React と Vue には多くの共通点があります。両方ともです。</target>
        </trans-unit>
        <trans-unit id="bb65ef679dc307f628a20a0b729cd808d18c5ac0" translate="yes" xml:space="preserve">
          <source>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React&amp;rsquo;s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it&amp;rsquo;s absolutely not suitable for production.</source>
          <target state="translated">Reactは、その急な学習曲線で有名です。多くの例ではReactのクラス構文を使用しているため、実際に始める前に、JSXとおそらくES2015 +について知っておく必要があります。ビルドシステムについても学ぶ必要があります。技術的にはBabel Standaloneを使用してブラウザーでコードをライブコンパイルすることはできますが、本番環境にはまったく適していません。</target>
        </trans-unit>
        <trans-unit id="bb1b40c27f9e4939cf3ff484fca2a9371f8d3b42" translate="yes" xml:space="preserve">
          <source>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.</source>
          <target state="translated">Reactライクなライブラリは通常、APIとエコシステムを可能な限りReactで共有しようとします。そのため、上記の比較の大部分はそれらにも適用されます。主な違いは、通常、Reactと比較してエコシステムが大幅に縮小されていることです。これらのライブラリはReactエコシステム内のすべてのものと100%互換性があるわけではないので、一部のツールやコンパニオンライブラリは使えない可能性があります。あるいは、動作しているように見えても、特定のReactライクなライブラリがReactと同等に公式にサポートされていない限り、いつでも壊れてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="96578d9c2e6eaee240051ff91e83f741cc87e93b" translate="yes" xml:space="preserve">
          <source>Reactivity</source>
          <target state="translated">Reactivity</target>
        </trans-unit>
        <trans-unit id="38be1878e88addc141471e2ac5be059c49256537" translate="yes" xml:space="preserve">
          <source>Reactivity in Depth</source>
          <target state="translated">深みのある反応性</target>
        </trans-unit>
        <trans-unit id="446d7c237336d575135ddcd7063341761426b025" translate="yes" xml:space="preserve">
          <source>Ready for More?</source>
          <target state="translated">準備はできていますか?</target>
        </trans-unit>
        <trans-unit id="40fe62216df511ee5c87bc8e026789c819f7b21e" translate="yes" xml:space="preserve">
          <source>Really though, any transition attribute can be dynamically bound. And it&amp;rsquo;s not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.</source>
          <target state="translated">実際には、任意の遷移属性を動的にバインドできます。そして、それは属性だけではありません。イベントフックはメソッドであるため、コンテキスト内のすべてのデータにアクセスできます。つまり、コンポーネントの状態に応じて、JavaScriptトランジションの動作が異なります。</target>
        </trans-unit>
        <trans-unit id="cdb5994a5662a9b7831e2e56b44ea27b6edb5bab" translate="yes" xml:space="preserve">
          <source>Recent versions of Angular, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT compilation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;tree-shaking&lt;/a&gt;, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by &lt;code&gt;angular-cli&lt;/code&gt; (~65KB gzipped).</source>
          <target state="translated">Angularの最近のバージョンでは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOTコンパイル&lt;/a&gt;と&lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;ツリーシェー&lt;/a&gt;キングを使用して、サイズを大幅に縮小できました。ただし、Vuex + Vueルーターを含むフル機能のVue 2プロジェクト（〜30KB gzip圧縮）は、 &lt;code&gt;angular-cli&lt;/code&gt; （〜65KB gzip圧縮）で生成された、そのまま使用できるAOTコンパイル済みアプリケーションよりも大幅に軽量です。</target>
        </trans-unit>
        <trans-unit id="3f99a56b4630f2ac18091fad78531d1626d4dac4" translate="yes" xml:space="preserve">
          <source>Recommended Configuration</source>
          <target state="translated">推奨設定</target>
        </trans-unit>
        <trans-unit id="f9d18b779732cc0ea4b60f929feea8a7c40df5fc" translate="yes" xml:space="preserve">
          <source>Recreating dynamic components is normally useful behavior, but in this case, we&amp;rsquo;d really like those tab component instances to be cached once they&amp;rsquo;re created for the first time. To solve this problem, we can wrap our dynamic component with a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">動的コンポーネントの再作成は通常は便利な動作ですが、この場合、それらが初めて作成されたときに、それらのタブコンポーネントのインスタンスがキャッシュされることを望んでいます。この問題を解決するには、動的コンポーネントを &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 要素でラップします。</target>
        </trans-unit>
        <trans-unit id="25c0556aa6352203342eea1a65c58a623378dbcc" translate="yes" xml:space="preserve">
          <source>Recursive Components</source>
          <target state="translated">再帰的なコンポーネント</target>
        </trans-unit>
        <trans-unit id="46819d95829c2f8ee915e7d271f512463387fc11" translate="yes" xml:space="preserve">
          <source>Refactoring becomes more difficult, because find-and-replace often isn&amp;rsquo;t sufficient to update relative references to a moved component.</source>
          <target state="translated">移動されたコンポーネントへの相対参照を更新するには、検索と置換では十分でないことが多いため、リファクタリングはより困難になります。</target>
        </trans-unit>
        <trans-unit id="f4234eefb475a2340f218d9e7a7e6c874a82a6fa" translate="yes" xml:space="preserve">
          <source>Refer to the respective build tool documentations to see how it&amp;rsquo;s done:</source>
          <target state="translated">ビルドツールのドキュメントを参照して、その方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="8d8b1f50199fd6cb6ab6141f41a87fd8dae1f00d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global component. Registration also automatically sets the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; with the given &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">グローバルコンポーネントを登録または取得します。登録では、指定された &lt;code&gt;id&lt;/code&gt; でコンポーネントの &lt;code&gt;name&lt;/code&gt; も自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="0168019975e7b996b73bc3be3562ac476872545c" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global directive.</source>
          <target state="translated">グローバル指令を登録または取得します。</target>
        </trans-unit>
        <trans-unit id="13bd6c258247a18188a7e24270fbc9f007d7c82d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global filter.</source>
          <target state="translated">グローバルフィルタを登録または取得します。</target>
        </trans-unit>
        <trans-unit id="76de89743a325c94ab024ae33f08812f80d685bb" translate="yes" xml:space="preserve">
          <source>Relation to Custom Elements</source>
          <target state="translated">カスタム要素との関係</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">リリースノート</target>
        </trans-unit>
        <trans-unit id="d92abdf653f23351eb7a0ab4d23290ee1313902d" translate="yes" xml:space="preserve">
          <source>Remember that &lt;strong&gt;global registration must take place before the root Vue instance is created (with &lt;code&gt;new Vue&lt;/code&gt;)&lt;/strong&gt;. &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;Here&amp;rsquo;s an example&lt;/a&gt; of this pattern in a real project context.</source>
          <target state="translated">&lt;strong&gt;ルートVueインスタンスが（ &lt;code&gt;new Vue&lt;/code&gt; ）作成される前に、グローバル登録を行う必要があることに&lt;/strong&gt;注意してください。実際のプロジェクトコンテキストでのこのパターンの&lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;例を次に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="73942b04c7d6e9cc0cafd922223a9eab5438c235" translate="yes" xml:space="preserve">
          <source>Remove custom event listener(s).</source>
          <target state="translated">カスタムイベントリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="25c548f4a7b9b6ef1cfbffbca926739476b1c4e2" translate="yes" xml:space="preserve">
          <source>Removed due to hooks simplification. If you really must suppress transition errors, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt;&lt;code&gt;try&lt;/code&gt;&amp;hellip;&lt;code&gt;catch&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">フックの簡素化のために削除されました。移行エラーを本当に抑制する必要がある場合は、代わりに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt; &lt;code&gt;try&lt;/code&gt; &amp;hellip; &lt;code&gt;catch&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="e7f3ed71f5d7421b91e0c25cc42984adb65b4fdd" translate="yes" xml:space="preserve">
          <source>Renamed to &lt;code&gt;base&lt;/code&gt; for consistency with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;the HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;HTMLの&lt;/a&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 要素との一貫性を保つため、 &lt;code&gt;base&lt;/code&gt; に名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="3aa893c2a6ebe75166762d5109366b728fa5dc54" translate="yes" xml:space="preserve">
          <source>Render Functions &amp;amp; JSX</source>
          <target state="translated">レンダリング関数とJSX</target>
        </trans-unit>
        <trans-unit id="f54e5429aec68f05a2b3b43a85ee9662c29159d7" translate="yes" xml:space="preserve">
          <source>Render Functions - Slots</source>
          <target state="translated">レンダリング機能-スロット</target>
        </trans-unit>
        <trans-unit id="aeac0239d7806a13c73e4eacbb8e89032112b08f" translate="yes" xml:space="preserve">
          <source>Render functions with JSX have a few advantages:</source>
          <target state="translated">JSXを使ったレンダー関数にはいくつかのメリットがあります。</target>
        </trans-unit>
        <trans-unit id="c0f479c7d13498bbd2aa42eae8f88242964120b5" translate="yes" xml:space="preserve">
          <source>Render the element and component &lt;strong&gt;once&lt;/strong&gt; only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</source>
          <target state="translated">要素とコンポーネントを&lt;strong&gt;一度&lt;/strong&gt;だけレンダリングします。その後の再レンダリングでは、要素/コンポーネントとそのすべての子は静的コンテンツとして扱われ、スキップされます。これは、更新パフォーマンスを最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1c510f643528b3292df74bbcf70195487418102f" translate="yes" xml:space="preserve">
          <source>Render the element or template block multiple times based on the source data. The directive&amp;rsquo;s value must use the special syntax &lt;code&gt;alias in expression&lt;/code&gt; to provide an alias for the current element being iterated on:</source>
          <target state="translated">ソースデータに基づいて要素またはテンプレートブロックを複数回レンダリングします。ディレクティブの値は &lt;code&gt;alias in expression&lt;/code&gt; 特別な構文エイリアスを使用して、反復される現在の要素のエイリアスを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="9647e21c53c63f65c167aa12298837e080c17cb0" translate="yes" xml:space="preserve">
          <source>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains &lt;strong&gt;a lot&lt;/strong&gt; of static content. In these cases, you can ensure that it&amp;rsquo;s only evaluated once and then cached by adding the &lt;code&gt;v-once&lt;/code&gt; directive to the root element, like this:</source>
          <target state="translated">VueではプレーンHTML要素のレンダリングは非常に高速ですが&lt;strong&gt;、多く&lt;/strong&gt;の静的コンテンツを含むコンポーネントがある場合があります。このような場合は、次のように &lt;code&gt;v-once&lt;/code&gt; ディレクティブをルート要素に追加することで、一度だけ評価されてからキャッシュされることを確認できます。</target>
        </trans-unit>
        <trans-unit id="9a09ee1cf84326d5d5b1fbbb8dcaca046fb652f2" translate="yes" xml:space="preserve">
          <source>Replacing &lt;code&gt;vm.$data&lt;/code&gt;&lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;削除された&lt;/sup&gt; &lt;code&gt;vm.$data&lt;/code&gt; 置き換え&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6336d2b4c545bfdb0a2c2e6130a2fe522bc117ed" translate="yes" xml:space="preserve">
          <source>Replacing Template Features with Plain JavaScript</source>
          <target state="translated">テンプレートの機能をプレーンな JavaScript に置き換える</target>
        </trans-unit>
        <trans-unit id="3694e119ff9868c46a5da68ac50107adb0cd0254" translate="yes" xml:space="preserve">
          <source>Replacing an Array</source>
          <target state="translated">配列の置き換え</target>
        </trans-unit>
        <trans-unit id="448ceec811e5cd1612b41b145f75a74425a6d60a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;capitalize&lt;/code&gt; Filter</source>
          <target state="translated">交換 &lt;code&gt;capitalize&lt;/code&gt; フィルター</target>
        </trans-unit>
        <trans-unit id="8ebc9242fd66a164fb0466c94c267b085022f523" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;currency&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;currency&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="6e8e54f171683ed43699d784bb3a20daa786f68a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;debounce&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="bc05ccbf460e1bee1b220a363cd9b366122fc62c" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;filterBy&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;filterBy&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="5aadbac5cc6d5572fbf9f02300727b922b52477f" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;json&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="5af22200afbbae6350485e71f8a0930a62620a3b" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;limitBy&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;limitBy&lt;/code&gt; フィルターの置き換え</target>
        </trans-unit>
        <trans-unit id="63239b2dfa73a07907b85e48d0e4e3d07aa51efd" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;lowercase&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;lowercase&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="307535ec9952915e10873762b9b0a59ea99d17d1" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;orderBy&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;orderBy&lt;/code&gt; フィルターの置き換え</target>
        </trans-unit>
        <trans-unit id="5a0b57fe75978a4fde52508fa6b11e6a9fcbade8" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;pluralize&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;pluralize&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="5895ba028c303252e37b6295f10778b7ca351267" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;uppercase&lt;/code&gt; Filter</source>
          <target state="translated">&lt;code&gt;uppercase&lt;/code&gt; フィルターの交換</target>
        </trans-unit>
        <trans-unit id="c183ebe6cda4d505c2e49d3160c8367d36be5b90" translate="yes" xml:space="preserve">
          <source>Replacing/Merging with Existing Attributes</source>
          <target state="translated">既存の属性との置き換え/マージ</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="1f5b54bbca313ab53947ed8a4f97b16e01f729d9" translate="yes" xml:space="preserve">
          <source>Reusable Transitions</source>
          <target state="translated">再利用可能なトランジション</target>
        </trans-unit>
        <trans-unit id="a48bbafb258bfc790b66aec7d45e0a6a8fa1cd83" translate="yes" xml:space="preserve">
          <source>Reusing Components</source>
          <target state="translated">コンポーネントの再利用</target>
        </trans-unit>
        <trans-unit id="b836c4c63ed0b1bed339e82e9c78c2b817e6736c" translate="yes" xml:space="preserve">
          <source>Riot</source>
          <target state="translated">Riot</target>
        </trans-unit>
        <trans-unit id="6e85617241bed85b4dcd2ae064b3025078b134e9" translate="yes" xml:space="preserve">
          <source>Riot 3.0 provides a similar component-based development model (which is called a &amp;ldquo;tag&amp;rdquo; in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:</source>
          <target state="translated">Riot 3.0は、最小限の美しく設計されたAPIを備えた、同様のコンポーネントベースの開発モデル（Riotでは「タグ」と呼ばれます）を提供します。RiotとVueはおそらく設計哲学で多くのことを共有しています。ただし、Riotより少し重いにもかかわらず、Vueにはいくつかの重要な利点があります。</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="8e4ecad6a05d926091d335638bbc9859c1de1f8b" translate="yes" xml:space="preserve">
          <source>Rollup + rollup-plugin-vue</source>
          <target state="translated">ロールアップ+ロールアッププラグインビュー</target>
        </trans-unit>
        <trans-unit id="42ec7ccbef29d0422b242b5178f06191bc8484d0" translate="yes" xml:space="preserve">
          <source>Route Definitions</source>
          <target state="translated">ルート定義</target>
        </trans-unit>
        <trans-unit id="6e3b967c60ba49b0f518c43998cb2dc91dd2134c" translate="yes" xml:space="preserve">
          <source>Route Hooks</source>
          <target state="translated">ルートフック</target>
        </trans-unit>
        <trans-unit id="2b73a7098cbf7da1b1613b48acc5eb7c6f35331c" translate="yes" xml:space="preserve">
          <source>Route Matching</source>
          <target state="translated">ルートマッチング</target>
        </trans-unit>
        <trans-unit id="18febd25894978ca61139fd68c461cb521819d89" translate="yes" xml:space="preserve">
          <source>Route Options: Misc</source>
          <target state="translated">ルートオプション。その他</target>
        </trans-unit>
        <trans-unit id="f0865cca790a39153b3f106f9c19244b4f157bd4" translate="yes" xml:space="preserve">
          <source>Route matching now uses &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; under the hood, making it much more flexible than previously.</source>
          <target state="translated">ルートマッチングは、&lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;内部&lt;/a&gt;で正規表現へのパスを使用するようになり、以前よりもはるかに柔軟になりました。</target>
        </trans-unit>
        <trans-unit id="32027b0a6491682801317490f82d9b553e764f1b" translate="yes" xml:space="preserve">
          <source>Router Initialization</source>
          <target state="translated">ルータ初期化</target>
        </trans-unit>
        <trans-unit id="1b4778ead27c045154fa8a8032dcbf9b6b10e64f" translate="yes" xml:space="preserve">
          <source>Router Options: Modes</source>
          <target state="translated">ルーターのオプション。モード</target>
        </trans-unit>
        <trans-unit id="9add2b84e8289fb0ea9dcb2637e5d5907ca4d748" translate="yes" xml:space="preserve">
          <source>Routes are now defined as an array on a &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt;&lt;code&gt;routes&lt;/code&gt; option&lt;/a&gt; at router instantiation. So these routes for example:</source>
          <target state="translated">ルートは、ルータのインスタンス化時に&lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt; &lt;code&gt;routes&lt;/code&gt; オプションの&lt;/a&gt;配列として定義されるようになりました。たとえば、これらのルート：</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="d670f1115ef0c3c29b2d47e241e7dd62eafb1e11" translate="yes" xml:space="preserve">
          <source>Rule Categories</source>
          <target state="translated">ルールカテゴリ</target>
        </trans-unit>
        <trans-unit id="91ba54d8bd5025bb2cb3e7a4cd0c0785af90a756" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find &lt;code&gt;keep-alive&lt;/code&gt; attributes.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;keep-alive&lt;/code&gt; 属性を見つけます。</target>
        </trans-unit>
        <trans-unit id="6d2ac67778b450ed0b9659002961f8409d707930" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find CSS selectors targeting named slots (e.g. &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt;).</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、名前付きスロットをターゲットとするCSSセレクターを見つけます（例： &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fb8ef12ba88bdd9ea8d64f474b58bd5f002af15c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find HTML interpolations.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、HTML補間を見つけます。</target>
        </trans-unit>
        <trans-unit id="e29967481758c6af408495a286989e2f4b3a4403" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find all examples of this hook.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、このフックのすべての例を見つけます。</target>
        </trans-unit>
        <trans-unit id="131ad91eddecfe4bcd3aa1d2c3dae1e7c9a6d28b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;$dispatch&lt;/code&gt; および &lt;code&gt;$broadcast&lt;/code&gt; 例を見つけます。</target>
        </trans-unit>
        <trans-unit id="b5547bdef16b43ebf6aa5572275c3effebf29215" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$remove&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、配列の。 &lt;code&gt;.$remove&lt;/code&gt; 例を見つけます。いずれかを見逃した場合、欠落しているメソッドの&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="4d1a3ee9aa64afee960f48bf970646ff2ca1516a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$set&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、配列の。 &lt;code&gt;.$set&lt;/code&gt; 例を見つけます。いずれかを見逃した場合、欠落しているメソッドの&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="f7cf2f519c21c26383d689b999383e7f48c8daeb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.async&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.config.async&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="adba4cc2d78c532c252af8489b44bb0c82a60071" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.debug&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.config.debug&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="842114654af7636636f5d0ca2790f492b054f6ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.delimiters&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.config.delimiters&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="56d3c94b1fca7d1fecbd0be685fc6a65bfb4e3ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt;. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt; の例を見つけます。この後、ヘルパーはHTML補間のインスタンスも見つけるので、それらを `v-html`で置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="7abfe983d07d10f68fd1a923086c66cfb28e6a0a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.elementDirective&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.elementDirective&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="0cbd833dba88270b867f404265f89cd61957dd9e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.partial&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.partial&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="2be876bb1c3f71e3306a218289a786bebe66e6ac" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.set&lt;/code&gt; or &lt;code&gt;Vue.delete&lt;/code&gt; on a Vue instance. If you miss any, they'll trigger &lt;strong&gt;console warnings&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、Vueインスタンスの &lt;code&gt;Vue.set&lt;/code&gt; または &lt;code&gt;Vue.delete&lt;/code&gt; の例を見つけます。いずれかを見逃した場合、&lt;strong&gt;コンソール警告が表示されます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b9c98c79eef3d7a23f61df5ef62ac7e471ae74fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.transition&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;Vue.transition&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="3cd48bf0c847ee511a1c8d066fdfbdc6f4f6ffc4" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;replace: false&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;replace: false&lt;/code&gt; 例を見つけます：false。</target>
        </trans-unit>
        <trans-unit id="bc77c164d9ea83ca27d60242ad248d1e7b987f0e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.alias&lt;/code&gt; being called.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、呼び出される &lt;code&gt;router.alias&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="7cf69302085bdd68f35cf86d99ec675583acea23" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.go&lt;/code&gt; being used where &lt;code&gt;router.push&lt;/code&gt; should be used instead.</source>
          <target state="translated">実行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパーを&lt;/a&gt;例見つけるためにあなたのコードベースに &lt;code&gt;router.go&lt;/code&gt; 場合に使用されている &lt;code&gt;router.push&lt;/code&gt; を代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e39b23f840933b639f0659fde34e12f635127e7f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.map&lt;/code&gt; being called.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;router.map&lt;/code&gt; れているrouter.mapの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="b828dfd9e2d7bcae2364000145b56e764e6ebe03" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.on&lt;/code&gt; being called.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、呼び出される &lt;code&gt;router.on&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="f9a6975194aa0ce1b5cad1c6626af7c35453fcd0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.redirect&lt;/code&gt; being called.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、呼び出される &lt;code&gt;router.redirect&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="cc5f2a33706f0e2d3f4cdbd090a5e649c5b6ae0f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.start&lt;/code&gt; being called.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、呼び出される &lt;code&gt;router.start&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="f5f2fbe802e2c06eba8dee0a46275f8ee4460bc0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.on&lt;/code&gt;, &lt;code&gt;store.off&lt;/code&gt;, and &lt;code&gt;store.emit&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;store.on&lt;/code&gt; 、 &lt;code&gt;store.off&lt;/code&gt; 、および &lt;code&gt;store.emit&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="00ad6c9fe856a5b4567b7a4dab60a0fe45a37f40" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.watch&lt;/code&gt; with a string as the first argument.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、最初の引数として文字列を &lt;code&gt;store.watch&lt;/code&gt; 例を見つけます。</target>
        </trans-unit>
        <trans-unit id="4f47a47355d74434a753364a679e2f4c9a402ae5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;track-by&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;track-by&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="da0f85cb5aa67bdac2ea466f36918db2fcd36b05" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;v-el&lt;/code&gt; and &lt;code&gt;v-ref&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;v-el&lt;/code&gt; および &lt;code&gt;v-ref&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="7aa5783c6df3a82bb69131d32c3850e7f84cfda7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$after&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$after&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="09e7d78d817c1fd2a45c3cf9b9c21a2069c4fd37" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$appendTo&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$appendTo&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="d7350cc4e203e91682eee37d60894b3e1314af48" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$before&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$before&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="c0c4f878eaed231fe0dbb2225df03cd65dc84e13" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$eval&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$eval&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="3f8e856f05355ed8982ce86f4336ff6eacabf3e2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$get&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$get&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="bd0dd654ce3404b139a97c6070c1ea80255ce0fd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$interpolate&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$interpolate&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="81bbbda8f1ba1322792aa46e4294439738bc392f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$log&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$log&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="381f44de62059e317b1f31d7ce9b3541555d602b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$remove&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$remove&lt;/code&gt; 例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;が表示されます。</target>
        </trans-unit>
        <trans-unit id="b874a37ca4886af9d3b7780e6010cf89d9c7f988" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of arbitrary route properties not scoped under meta.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、メタにスコープされていない任意のルートプロパティの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="1fa158cea69bdd4c40bd2a48988a099538d4dc5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、定義されたディレクティブの例を見つけます。ほとんどの場合、コンポーネントにリファクタリングする必要があるため、ヘルパーはそれらすべてにフラグを立てます。</target>
        </trans-unit>
        <trans-unit id="979e6458f784d896c90752c57e560652f6c8525d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters being used inside directives. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、ディレクティブ内で使用されているフィルターの例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;も表示されます。</target>
        </trans-unit>
        <trans-unit id="801a0e4488b5e174aaaa485bb9fbdd0fb7f5b389" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters used in directives like &lt;code&gt;v-model&lt;/code&gt;. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;v-model&lt;/code&gt; などのディレクティブで使用されるフィルターの例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;も表示されます。</target>
        </trans-unit>
        <trans-unit id="83b833ef69efe1e17f7ef29c061f04dea5876bad" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of interpolation used within attributes.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、属性内で使用される補間の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="9bb76b174b8438ba3c0f4ba54b4026ce44dd98ca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of overwriting &lt;code&gt;vm.$data&lt;/code&gt;. If you miss any, &lt;strong&gt;console warnings&lt;/strong&gt; will be emitted.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;vm.$data&lt;/code&gt; を上書きする例を見つけます。いずれかを見逃した場合、&lt;strong&gt;コンソール警告&lt;/strong&gt;が発せられます。</target>
        </trans-unit>
        <trans-unit id="8dbff7c8c83dec265171807e5ec5ea40ea988ad1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of style bindings with &lt;code&gt;!important&lt;/code&gt; in objects.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、オブジェクトに &lt;code&gt;!important&lt;/code&gt; を含むスタイルバインディングの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="93ebbb2019ca1300c683d3ae1afb72a96650f915" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;$loadingRouteData&lt;/code&gt; meta property.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;$loadingRouteData&lt;/code&gt; メタプロパティの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="52407d926e2b5716bf90f4cb35758896e87892ed" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;.once&lt;/code&gt; and &lt;code&gt;.sync&lt;/code&gt; modifiers.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;.once&lt;/code&gt; および &lt;code&gt;.sync&lt;/code&gt; 修飾子の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="2c8ce2853d843c2c72201a428aaae4467ceec09d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;abstract: true&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;abstract: true&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="2258f58c39858d2874ac267df312bf5774d76c18" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;activate&lt;/code&gt; hook.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;activate&lt;/code&gt; フックの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="0d2dd196d33a6838401706a980c174ba91eb1c6e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;cache: false&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;cache: false&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="635b9a1176068b8a0020a01c4f47cb421d064226" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canActivate&lt;/code&gt; hook.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;canActivate&lt;/code&gt; フックの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="1ef7f740384cd3cfdf159ef6085f2faaac1ec88f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canDeactivate&lt;/code&gt; hook.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;canDeactivate&lt;/code&gt; フックの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="416c87ed212eefdaa2ddbf02f6a0ba2e74d86959" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canReuse: false&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;canReuse: false&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="ce44d3b81054ffa59cb49fd62f006c1d791e2ab0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;coerce&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;coerce&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="61fdd38d446cfe928998b1181aa744e45596c1c5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;data&lt;/code&gt; hook.</source>
          <target state="translated">コードフックで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;data&lt;/code&gt; フックの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="eeb9b18e06a447d16bfa196a854b2eb06f05360a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;deactivate&lt;/code&gt; hook.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;deactivate&lt;/code&gt; フックの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="f483517518991a282467c00ae1cad300e136b269" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;debounce&lt;/code&gt; attribute.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;debounce&lt;/code&gt; 属性の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="b65067f3a77b357e086f22629678c364185b2ab2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;hashbang: false&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;hashbang: false&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="8a2e5b8abfbc6295fa11dd1caccde1ae7c3d69af" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;history: true&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;history: true&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="452c89b5559555a477ca0eb92f956476ce00d5cd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;middlewares&lt;/code&gt; option on a store.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、ストアの &lt;code&gt;middlewares&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="6faa58ba44b5eb605740b8397f8693bbaaa6f840" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;root&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;root&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="ab45ded99a30a006bddeceb3fd6aa38bb6c3d9c6" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;saveScrollPosition: true&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;saveScrollPosition: true&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="6ec2df901f80374c6ff66f398825204e5f18d423" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;subRoutes&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;subRoutes&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="7178b2cc5e9e2a36383d9e60b9eea90fb3bcb121" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;suppressTransitionError: true&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;suppressTransitionError: true&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="4e988285e061dd6f2c40c32cddfbc676c1aab12a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;transition&lt;/code&gt; 属性の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="c5f2b82da8cac7dc4262de8c7c93d4a46587dbca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;transition&lt;/code&gt; 属性の例を見つけます。更新中に、新しい驚異的な戦略に移行することもできます（非常に意図的ですが）。</target>
        </trans-unit>
        <trans-unit id="34922f45eeac604f53b4193f84913c2beb89b350" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transitionOnLoad: true&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;transitionOnLoad: true&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="c9c97a1b14162dd07775888af56118c3a3370301" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;twoWay&lt;/code&gt; option.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;twoWay&lt;/code&gt; オプションの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="cb3445799897bdc7ce3106b11c9b2c1f1d554568" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-else&lt;/code&gt; with &lt;code&gt;v-show&lt;/code&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;v-else&lt;/code&gt; と &lt;code&gt;v-show&lt;/code&gt; の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="bccc02e6c6793423ef659db42169cb5afa5716d0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link-active&lt;/code&gt; directive.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;v-link-active&lt;/code&gt; ディレクティブの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="ea921119a7e1635ac4e5a00b3d8a84491101f3fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link&lt;/code&gt; directive.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、 &lt;code&gt;v-link&lt;/code&gt; ディレクティブの例を見つけます。</target>
        </trans-unit>
        <trans-unit id="a825bdc145076ec6a6e4b0c215f030aa3ba79b85" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the `.literal` modifier on a directive.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、ディレクティブの `.literal`修飾子の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="733bb79e129d2dca49869269db0a3698c6f65fa8" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like &lt;code&gt;position&lt;/code&gt; or &lt;code&gt;num&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、廃止された引数の順序の例を見つけます。インデックス引数に &lt;code&gt;position&lt;/code&gt; や &lt;code&gt;num&lt;/code&gt; のような異常な名前を付けた場合、ヘルパーはそれらにフラグを立てないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="da725380e126a62727af458ad28bac7c6524d798" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;property&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、廃止された引数の順序の例を見つけます。キー引数に &lt;code&gt;name&lt;/code&gt; や &lt;code&gt;property&lt;/code&gt; などの名前を付けた場合、ヘルパーはそれらにフラグを立てないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f1e1035d99ed76f7515df578e692ff719107895a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete route syntax.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、廃止されたルート構文の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="142bb71333ac86e488c9aacc373010de66e961e1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete text filters. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、廃止されたテキストフィルターの例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;も表示されます。</target>
        </trans-unit>
        <trans-unit id="397d5ab0302428112127147010f4482ef9051b5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete usage.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、廃止された使用例を見つけます。</target>
        </trans-unit>
        <trans-unit id="c1aa36c4bb555ce2607bb2d08c4631182d133d50" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the old filter syntax. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、古いフィルター構文の例を見つけます。いずれかを見逃した場合は、&lt;strong&gt;コンソールエラー&lt;/strong&gt;も表示されます。</target>
        </trans-unit>
        <trans-unit id="20564b7f4450c4fa59c4a3ba6fa87121c27fe89f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the the old &lt;code&gt;keyCode&lt;/code&gt; configuration syntax.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、古い &lt;code&gt;keyCode&lt;/code&gt; 構成構文の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="cc0976e79e68e3874825b8d9309f7bc3cf13503f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the these param attributes.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、これらのparam属性の例を見つけます。</target>
        </trans-unit>
        <trans-unit id="4a53e2c9b9e1ccea5753bf6c5b26aa93f8d31041" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of these removed variables. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt; such as: &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、これらの削除された変数の例を見つけます。いずれかを見逃した場合は、次のような&lt;strong&gt;コンソールエラー&lt;/strong&gt;も表示されます &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0ae781de5086e5c0e4123dc4514d344522a5237" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find one-time bindings.</source>
          <target state="translated">コードベースで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行して、1回限りのバインディングを見つけます。</target>
        </trans-unit>
        <trans-unit id="2c800955474c5ae66271d1f51e3a706afff6e929" translate="yes" xml:space="preserve">
          <source>Run your bundling command with the actual &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable set to &lt;code&gt;&quot;production&quot;&lt;/code&gt;. This tells &lt;code&gt;vueify&lt;/code&gt; to avoid including hot-reload and development related code.</source>
          <target state="translated">実際の &lt;code&gt;NODE_ENV&lt;/code&gt; 環境変数を &lt;code&gt;&quot;production&quot;&lt;/code&gt; に設定してバンドルコマンドを実行します。これは、ホットリロードや開発関連のコードを含めないように &lt;code&gt;vueify&lt;/code&gt; に指示します。</target>
        </trans-unit>
        <trans-unit id="65124f23df07644ee66ed5e04606bd6c7b54318b" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about duplicate slots &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">アップグレード後にエンドツーエンドのテストスイートまたはアプリを実行し、スロット &lt;code&gt;v-model&lt;/code&gt; の重複&lt;strong&gt;に関するコンソールの警告&lt;/strong&gt;を探します。</target>
        </trans-unit>
        <trans-unit id="0276baa533bc89d334fafab4aee362813fb56fba" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about inline value attributes with &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">アップグレード後にエンドツーエンドのテストスイートまたはアプリを実行し、 &lt;code&gt;v-model&lt;/code&gt; を使用してインライン値属性に関する&lt;strong&gt;コンソール警告&lt;/strong&gt;を探します。</target>
        </trans-unit>
        <trans-unit id="b9168febc3cd9fb510564d5d619d53cfceebc829" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about multiple root elements in a template.</source>
          <target state="translated">アップグレード後にエンドツーエンドのテストスイートまたはアプリを実行し、テンプレート内の複数のルート要素に関する&lt;strong&gt;コンソール警告&lt;/strong&gt;を探します。</target>
        </trans-unit>
        <trans-unit id="6cd905d20455b18138224bc59c413711a6de22a2" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about prop mutations.</source>
          <target state="translated">アップグレード後にエンドツーエンドのテストスイートまたはアプリを実行し、propの変更&lt;strong&gt;に関するコンソールの警告&lt;/strong&gt;を探します。</target>
        </trans-unit>
        <trans-unit id="7da416f4436591687e3ea5cf9d579fb6711b7dbd" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about the &lt;code&gt;el&lt;/code&gt; option with &lt;code&gt;Vue.extend&lt;/code&gt;.</source>
          <target state="translated">アップグレード後にエンドツーエンドのテストスイートまたはアプリを実行し、 &lt;code&gt;Vue.extend&lt;/code&gt; の &lt;code&gt;el&lt;/code&gt; オプションに関する&lt;strong&gt;コンソール警告&lt;/strong&gt;を探します。</target>
        </trans-unit>
        <trans-unit id="de5aa3b1e8bcd9a2e9b6648cc6da29ebd7c682fa" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">エンドツーエンドのテストスイートがある場合は実行します。&lt;strong&gt;失敗したテストでは&lt;/strong&gt;、この変更によって影響を受ける可能性があり、あなたのアプリのいずれかの部分にあなたに警告しなければなりません。</target>
        </trans-unit>
        <trans-unit id="25b0475e8303e55dc27cdda9bbd8ef8c1c492011" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that a watcher was relying on the old behavior.</source>
          <target state="translated">エンドツーエンドのテストスイートがある場合は実行します。&lt;strong&gt;失敗したテストは、&lt;/strong&gt;ウォッチャーが古い動作に依存しているという事実に、あなたに警告しなければなりません。</target>
        </trans-unit>
        <trans-unit id="3925b4e9140324a46bda954fa3ba6a11551d44d8" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that props passed to root instances are no longer working.</source>
          <target state="translated">エンドツーエンドのテストスイートがある場合は実行します。&lt;strong&gt;失敗したテストでは&lt;/strong&gt;、ルートインスタンスに渡された小道具は、もはや機能していないという事実のためにあなたに警告しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c7a107bdb49919e8c77ec76a87618731104be368" translate="yes" xml:space="preserve">
          <source>Run your test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">テストスイートがある場合は実行します。&lt;strong&gt;失敗したテストでは&lt;/strong&gt;、この変更によって影響を受ける可能性があり、あなたのアプリのいずれかの部分にあなたに警告しなければなりません。</target>
        </trans-unit>
        <trans-unit id="13285023695c206297d4666f3184c48b775d9ec3" translate="yes" xml:space="preserve">
          <source>Runtime + Compiler vs. Runtime-only</source>
          <target state="translated">ランタイム+コンパイラ vs ランタイムのみ</target>
        </trans-unit>
        <trans-unit id="ce3caf82d6dc4282305777c04d22cb7e32e8739f" translate="yes" xml:space="preserve">
          <source>Runtime Performance</source>
          <target state="translated">ランタイムパフォーマンス</target>
        </trans-unit>
        <trans-unit id="0ab3eee80056a96ec147159fe704ef0b8dcd1e74" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#slot-scope&quot;&gt;&lt;code&gt;slot-scope&lt;/code&gt;&lt;/a&gt; except that &lt;code&gt;scope&lt;/code&gt; can only be used on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; が &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素でのみ使用できることを除いて、&lt;a href=&quot;#slot-scope&quot;&gt; &lt;code&gt;slot-scope&lt;/code&gt; と&lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="c41f297530a1a4027d4fe5146dc89421c3603b93" translate="yes" xml:space="preserve">
          <source>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:</source>
          <target state="translated">Sarah Drasner氏は、時間とインタラクティビティに基づいた状態変化の組み合わせを使用して、これを下のデモで実演しています。</target>
        </trans-unit>
        <trans-unit id="a29f0256272e79ca91a1c4e608f09a6264397d12" translate="yes" xml:space="preserve">
          <source>Scale</source>
          <target state="translated">Scale</target>
        </trans-unit>
        <trans-unit id="88011a37856972ada6fede54fa2220927bfb5ac0" translate="yes" xml:space="preserve">
          <source>Scaling Down</source>
          <target state="translated">スケールダウン</target>
        </trans-unit>
        <trans-unit id="2d20a53538fb773c0616dc1ef8c4f21c2ceb637d" translate="yes" xml:space="preserve">
          <source>Scaling Up</source>
          <target state="translated">スケールアップ</target>
        </trans-unit>
        <trans-unit id="bf1e630e7268556a0635e37341aa31c69f284094" translate="yes" xml:space="preserve">
          <source>Scoped Slots</source>
          <target state="translated">スコープされたスロット</target>
        </trans-unit>
        <trans-unit id="c891d436871bb971da8c2ff8081958bff3ddb19a" translate="yes" xml:space="preserve">
          <source>Scoped Slots with the &lt;code&gt;slot-scope&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; 属性を持つスコープスロット</target>
        </trans-unit>
        <trans-unit id="6aa971b69d2fe9a8fec7d58fa039f9aafe0f8da1" translate="yes" xml:space="preserve">
          <source>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">スコープ付きスロット関数は、戻り値が無効でない限り、VNodeの配列を返すことが保証されて &lt;code&gt;undefined&lt;/code&gt; ます。その場合、関数はundefinedを返します。</target>
        </trans-unit>
        <trans-unit id="dfa277d957af13fbcf610edac48d6ff9d1d53991" translate="yes" xml:space="preserve">
          <source>Search your codebase for the regex &lt;code&gt;/\w+ in \d+/&lt;/code&gt;. Wherever it appears in a &lt;code&gt;v-for&lt;/code&gt;, check to see if you may be affected.</source>
          <target state="translated">コードベース &lt;code&gt;/\w+ in \d+/&lt;/code&gt; の正規表現/ \ w +を検索します。 &lt;code&gt;v-for&lt;/code&gt; のどこに表示されていても、影響を受けるかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="0d4f1b3e1926d0de28455af2f7b050061aa08a61" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;this fiddle&lt;/a&gt; for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we&amp;rsquo;d recommend creating a reusable &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">完全なコードについては、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;このフィドル&lt;/a&gt;を参照してください。ただし、1つのコンポーネント内で多くの設定とクリーンアップを行う必要がある場合は、通常、より多くのモジュール式コンポーネントを作成するのが最善の解決策です。この場合、再利用可能な &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; コンポーネントを作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="04b10db48b879dd4894715118934c8f16e790244" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;this fiddle&lt;/a&gt; for the complete code behind the above demo.</source>
          <target state="translated">上記のデモの背後にある完全なコードについては、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;このフィドル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="030b52b1aecbbfd160c5986ee59275d22c9f7672" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;this fiddle&lt;/a&gt; to experiment with the full code, or &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;this version&lt;/a&gt; for an example binding to a component&amp;rsquo;s options object, instead of its registered name.</source>
          <target state="translated">完全なコードを試すには、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;このフィドル&lt;/a&gt;を参照してください。コンポーネントのオプションオブジェクトへのバインディングの例では、登録されている名前ではなく、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;このバージョン&lt;/a&gt;を試してください。</target>
        </trans-unit>
        <trans-unit id="bc6fd808ffb90ac93f1cb9d312e01c08b9a59bf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript compiler options docs&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScriptコンパイラオプションのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8f4b188488a5cff189e4cfc9d54ff0931435281a" translate="yes" xml:space="preserve">
          <source>See example &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;the plugins docs&lt;/a&gt; for more info.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;は、プラグインのドキュメントの&lt;/a&gt;例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b7cdc723bd45704f63d3132765b8411da257e1bf" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue-controlled Wall-E&lt;/a&gt; by Sarah Drasner (&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">CodePenでSarah Drasner（&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;）に&lt;a href=&quot;https://codepen.io&quot;&gt;よる&lt;/a&gt; Pen &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue制御のWall-Eを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="d84be9de2f9e35e379e0e4f6e0bb2340cf1b2d0b" translate="yes" xml:space="preserve">
          <source>Select Options</source>
          <target state="translated">オプションを選択</target>
        </trans-unit>
        <trans-unit id="33e3b8ff7914aff97145e0add0103e5154bdde21" translate="yes" xml:space="preserve">
          <source>Self-closing components</source>
          <target state="translated">自己閉鎖の部品</target>
        </trans-unit>
        <trans-unit id="8aa1710830cfa45dfe404022342d5aade64a9767" translate="yes" xml:space="preserve">
          <source>Self-closing components &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">自動閉鎖コンポーネントを&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">サーバーサイドレンダリング</target>
        </trans-unit>
        <trans-unit id="d986e7075907e08286bd92c14ff694e5215b1ede" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;false&lt;/code&gt; to prevent the production tip on Vue startup.</source>
          <target state="translated">これを &lt;code&gt;false&lt;/code&gt; に設定すると、Vueの起動時に本番のヒントが表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="0322b76a288cd27bf5d650f3c073fe32426bc786" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、ブラウザーのdevtoolパフォーマンス/タイムラインパネルでコンポーネントの初期化、コンパイル、レンダリング、パッチのパフォーマンストレースが有効になります。開発モードと、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API をサポートするブラウザーでのみ機能します。</target>
        </trans-unit>
        <trans-unit id="97f2f59947f62c014c5d7c2a4de9191db27303ae" translate="yes" xml:space="preserve">
          <source>Share (and Build) Your Experience</source>
          <target state="translated">あなたの経験を共有する(構築する)には</target>
        </trans-unit>
        <trans-unit id="89dd25c3e7bb9f776951ef9ad74e60a7d6dd05bb" translate="yes" xml:space="preserve">
          <source>Shorthands</source>
          <target state="translated">Shorthands</target>
        </trans-unit>
        <trans-unit id="1ae7276e79db945fd551dc9db134399c32bb6984" translate="yes" xml:space="preserve">
          <source>Should either be updated to use an inline expression:</source>
          <target state="translated">インライン式を使用するように更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0a3536bb7788ee14bd41892adba577744a1012d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;$root&lt;/code&gt;, the &lt;code&gt;$parent&lt;/code&gt; property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</source>
          <target state="translated">&lt;code&gt;$root&lt;/code&gt; と同様に、 &lt;code&gt;$parent&lt;/code&gt; プロパティを使用して、子から親インスタンスにアクセスできます。これは、小道具を使用してデータを渡す代わりの遅延代替手段として到達するのが魅力的な場合があります。</target>
        </trans-unit>
        <trans-unit id="dadac4906f4bc6e4a81d9058bdcbf1bbcb397f71" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-else&lt;/code&gt;, a &lt;code&gt;v-else-if&lt;/code&gt; element must immediately follow a &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-else-if&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; と同様に、 &lt;code&gt;v-else-if&lt;/code&gt; 要素は &lt;code&gt;v-if&lt;/code&gt; または &lt;code&gt;v-else-if&lt;/code&gt; 要素の直後に続く必要があります。</target>
        </trans-unit>
        <trans-unit id="af9b7b6d2657eb7de92b424e723e1ce34e27dd45" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-on&lt;/code&gt; and &lt;code&gt;v-bind&lt;/code&gt;, &lt;code&gt;v-slot&lt;/code&gt; also has a shorthand, replacing everything before the argument (&lt;code&gt;v-slot:&lt;/code&gt;) with the special symbol &lt;code&gt;#&lt;/code&gt;. For example, &lt;code&gt;v-slot:header&lt;/code&gt; can be rewritten as &lt;code&gt;#header&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; および &lt;code&gt;v-bind&lt;/code&gt; と同様に、 &lt;code&gt;v-slot&lt;/code&gt; にも省略形があり、引数（ &lt;code&gt;v-slot:&lt;/code&gt; ：）の前のすべてを特殊記号 &lt;code&gt;#&lt;/code&gt; に置き換えます。たとえば、 &lt;code&gt;v-slot:header&lt;/code&gt; は &lt;code&gt;#header&lt;/code&gt; に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="110921f9f16f79ec9020d42a774f85de76c9358e" translate="yes" xml:space="preserve">
          <source>Similar to prop defaults, you need to use a factory function for non primitive values:</source>
          <target state="translated">propのデフォルトと同様に、プリミティブではない値に対してファクトリー関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3115d0b13d887f54dba012634384e7c25cfdf659" translate="yes" xml:space="preserve">
          <source>Similar to template &lt;code&gt;v-if&lt;/code&gt;, you can also use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag with &lt;code&gt;v-for&lt;/code&gt; to render a block of multiple elements. For example:</source>
          <target state="translated">テンプレートと同様に &lt;code&gt;v-if&lt;/code&gt; 、あなたも使用することができます &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; とタグを &lt;code&gt;v-for&lt;/code&gt; 複数の要素のブロックをレンダリングします。例えば：</target>
        </trans-unit>
        <trans-unit id="9032b6dd131e5bdf77e7f1e8c9ad6ef9e98b4db4" translate="yes" xml:space="preserve">
          <source>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</source>
          <target state="translated">同様に、動的な引数を使用して、ハンドラを動的なイベント名にバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="e756f11c70f78a0ba1866d4795579c59fa6d1833" translate="yes" xml:space="preserve">
          <source>Simple Assertions</source>
          <target state="translated">単純なアサーション</target>
        </trans-unit>
        <trans-unit id="bbba1d068bf49ca0e64f1e344f51043367c2266d" translate="yes" xml:space="preserve">
          <source>Simple Routing From Scratch</source>
          <target state="translated">スクラッチからのシンプルなルーティング</target>
        </trans-unit>
        <trans-unit id="4e794aae53f27e868a697d7573dd5ec04e937e2a" translate="yes" xml:space="preserve">
          <source>Simple State Management from Scratch</source>
          <target state="translated">スクラッチからのシンプルな状態管理</target>
        </trans-unit>
        <trans-unit id="7a423acd4331de7d207764fc94ba09543c17ef88" translate="yes" xml:space="preserve">
          <source>Simple computed properties</source>
          <target state="translated">単純計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="28fbbfbd1e3c5e7641094f470de044776bb5ad02" translate="yes" xml:space="preserve">
          <source>Simple computed properties &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">簡単に計算されるプロパティを&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="37761f78a8d655b3953b071e198e22dcd5a02587" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates</source>
          <target state="translated">テンプレート内のシンプルな表現</target>
        </trans-unit>
        <trans-unit id="fcf7b67ac329ddfb22fdf3fbec785727bf9bf466" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">テンプレートでの単純な表現を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="211d49f995dbe282f57faa15874e031ac53eeff7" translate="yes" xml:space="preserve">
          <source>Simpler, well-named computed properties are:</source>
          <target state="translated">よりシンプルで名前のついた計算されたプロパティは、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="63a2bccabf19824dace120aef2460e5986003d8a" translate="yes" xml:space="preserve">
          <source>Simplifying computed properties forces you to give each value a descriptive name, even if it&amp;rsquo;s not reused. This makes it much easier for other developers (and future you) to focus in on the code they care about and figure out what&amp;rsquo;s going on.</source>
          <target state="translated">計算されたプロパティを簡略化すると、再利用されない場合でも、各値にわかりやすい名前を付ける必要があります。これにより、他の開発者（および将来の開発者）が関心のあるコードに集中して、何が起こっているのかを理解することがはるかに容易になります。</target>
        </trans-unit>
        <trans-unit id="5fd1e98b263d4df6091312537a5b1fb83da16e24" translate="yes" xml:space="preserve">
          <source>Simply download and include with a script tag. &lt;code&gt;Vue&lt;/code&gt; will be registered as a global variable.</source>
          <target state="translated">単にダウンロードして、スクリプトタグを含めます。 &lt;code&gt;Vue&lt;/code&gt; はグローバル変数として登録されます。</target>
        </trans-unit>
        <trans-unit id="d5938f34f8624b63802c3118f180d5e293766247" translate="yes" xml:space="preserve">
          <source>Simultaneous entering and leaving transitions aren&amp;rsquo;t always desirable though, so Vue offers some alternative &lt;strong&gt;transition modes&lt;/strong&gt;:</source>
          <target state="translated">ただし、遷移の開始と終了が同時に望ましいとは限らないため、Vueにはいくつかの代替&lt;strong&gt;遷移モードがあります&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6a69d78f54bcf8ac6e1f4a3963e04cee33a026d0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;$nextTick()&lt;/code&gt; returns a promise, you can achieve the same as the above using the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 async/await&lt;/a&gt; syntax:</source>
          <target state="translated">以来 &lt;code&gt;$nextTick()&lt;/code&gt; 約束を返すには、新しい使用して上記と同じで達成することができます&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016非同期/のawait&lt;/a&gt;構文：</target>
        </trans-unit>
        <trans-unit id="10a777de149e5a77b75501c009eb466a9bc93514" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v-ref&lt;/code&gt; is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with &lt;code&gt;v-for&lt;/code&gt;. For example:</source>
          <target state="translated">以来 &lt;code&gt;v-ref&lt;/code&gt; もはやディレクティブが、特別な属性であり、それはまた、動的に定義することはできません。これは、 &lt;code&gt;v-for&lt;/code&gt; と組み合わせると特に便利です。例えば：</target>
        </trans-unit>
        <trans-unit id="9de3c1e0a71e1edcdc7ffbc2b45060ebfe43b095" translate="yes" xml:space="preserve">
          <source>Since Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;performs DOM updates asynchronously&lt;/a&gt;, assertions on DOM updates resulting from state change will have to be made in a &lt;code&gt;Vue.nextTick&lt;/code&gt; callback:</source>
          <target state="translated">Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;は非同期&lt;/a&gt;にDOM更新を実行するため、状態の変化に起因するDOM更新のアサーションは &lt;code&gt;Vue.nextTick&lt;/code&gt; コールバックで作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="a6f5eaf2601394efec9f1b3f5eff696573b84807" translate="yes" xml:space="preserve">
          <source>Since Vue doesn&amp;rsquo;t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</source>
          <target state="translated">Vueではルートレベルの反応性プロパティを動的に追加することができないため、空の値でも、すべてのルートレベルの反応性データプロパティを事前に宣言してVueインスタンスを初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="17a485dec90726f134aafab30671454807556666" translate="yes" xml:space="preserve">
          <source>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. &lt;code&gt;MyButton&lt;/code&gt;, &lt;code&gt;VueButton&lt;/code&gt;).</source>
          <target state="translated">コンポーネント名は常にマルチワードである必要があるため、この規則により、単純なコンポーネントラッパー（ &lt;code&gt;MyButton&lt;/code&gt; 、 &lt;code&gt;VueButton&lt;/code&gt; など）に任意のプレフィックスを選択する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="ba2168060abb1674449c97121137c7602377ef42" translate="yes" xml:space="preserve">
          <source>Since components are reusable Vue instances, they accept the same options as &lt;code&gt;new Vue&lt;/code&gt;, such as &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, and lifecycle hooks. The only exceptions are a few root-specific options like &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">コンポーネントは再利用可能なVueインスタンスであるため、 &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;computed&lt;/code&gt; 、 &lt;code&gt;watch&lt;/code&gt; 、 &lt;code&gt;methods&lt;/code&gt; 、ライフサイクルフックなど、 &lt;code&gt;new Vue&lt;/code&gt; と同じオプションを受け入れます。唯一の例外は、 &lt;code&gt;el&lt;/code&gt; のようないくつかのルート固有のオプションです。</target>
        </trans-unit>
        <trans-unit id="2b68173db2c99b86c3a75462f226a7b75ff0f1d5" translate="yes" xml:space="preserve">
          <source>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</source>
          <target state="translated">エディターは通常、アルファベット順にファイルを整理しているため、構成要素間の重要な関係はすべて一目でわかるようになっています。</target>
        </trans-unit>
        <trans-unit id="ef79f75d79e817472bd0ed5aad52845e59dbf2e4" translate="yes" xml:space="preserve">
          <source>Since functional components are just functions, they&amp;rsquo;re much cheaper to render.</source>
          <target state="translated">機能コンポーネントは単なる関数であるため、レンダリングする方がはるかに安価です。</target>
        </trans-unit>
        <trans-unit id="5ca066badcd55a6324af0033eddd42706cb8d9c3" translate="yes" xml:space="preserve">
          <source>Since it&amp;rsquo;s a generic mechanism for Vue to identify nodes, the &lt;code&gt;key&lt;/code&gt; also has other uses that are not specifically tied to &lt;code&gt;v-for&lt;/code&gt;, as we will see later in the guide.</source>
          <target state="translated">これは、Vueがノードを識別するための一般的なメカニズムであるため、ガイドで後で説明するように、 &lt;code&gt;key&lt;/code&gt; は特に &lt;code&gt;v-for&lt;/code&gt; に関連付けられていない他の用途にも使用されます。</target>
        </trans-unit>
        <trans-unit id="c460325ca52e3630249720f5552ae7b020e4765a" translate="yes" xml:space="preserve">
          <source>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</source>
          <target state="translated">実行時のみのビルドは、フルビルドに比べて約30%軽量なので、可能な限り使用してください。それでもフルビルドを使いたい場合は、バンドル内でエイリアスを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e62e1d6e39e14f551529b609a48c6fb619bb1df6" translate="yes" xml:space="preserve">
          <source>Since these are &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;published on NPM&lt;/a&gt;, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don&amp;rsquo;t need any additional tooling to use TypeScript with Vue.</source>
          <target state="translated">これらは&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;NPM&lt;/a&gt;で公開されており、最新のTypeScriptはNPMパッケージの型宣言を解決する方法を知っているため、NPM経由でインストールした場合、TypeScriptをVueで使用するために追加のツールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4ea3d2ff946bc5b79835d964012d367a993b9ca6" translate="yes" xml:space="preserve">
          <source>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</source>
          <target state="translated">これらのコンポーネントは非常に頻繁に使われるので、どこでもインポートするのではなく、単にグローバルにしたいと思うかもしれません。Webpackではプレフィックスをつけることでそれが可能になります。</target>
        </trans-unit>
        <trans-unit id="796906cd98540356e295c43d625d24ed68862aac" translate="yes" xml:space="preserve">
          <source>Since we&amp;rsquo;re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</source>
          <target state="translated">値を返す必要のあるフィルターオプションを使用していないため、通貨の作業は実際には非同期で実行できます。つまり、通貨を使用する必要のあるアプリがたくさんある場合、このロジックを共有マイクロサービスに簡単にリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="a31aa77b805847e93b5d67d3ae054b43de8ddfb3" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</source>
          <target state="translated">JSで手動でイベントリスナーをアタッチする必要がないため、ViewModelコードは純粋なロジックでDOMを使用しなくてもかまいません。これにより、テストが容易になります。</target>
        </trans-unit>
        <trans-unit id="59debd2931aa770a2b0975329d41213dcd9c5d88" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; to learn enough to build non-trivial applications.</source>
          <target state="translated">Vueを使い始めるのにJSX、ES2015、またはビルドシステムについて知る必要がないため、通常、開発者&lt;a href=&quot;../index&quot;&gt;はガイド&lt;/a&gt;を読んで1日もかからず、重要なアプリケーションをビルドするのに十分なことを学ぶことができます。</target>
        </trans-unit>
        <trans-unit id="4a6e205b866dd29d282ce270191d3645216b482d" translate="yes" xml:space="preserve">
          <source>Single File Components</source>
          <target state="translated">シングルファイルコンポーネント</target>
        </trans-unit>
        <trans-unit id="5e7f1d7d63552994a465b38c32202f3620abe335" translate="yes" xml:space="preserve">
          <source>Single checkbox, boolean value:</source>
          <target state="translated">単一のチェックボックス、ブール値。</target>
        </trans-unit>
        <trans-unit id="040f06c8b02b9ecd8ce3bcc463d52f44ab71de30" translate="yes" xml:space="preserve">
          <source>Single select:</source>
          <target state="translated">シングルセレクト。</target>
        </trans-unit>
        <trans-unit id="95ef58f9b3d77202b180ce829f19b7953db91e4d" translate="yes" xml:space="preserve">
          <source>Single-file (&lt;code&gt;.vue&lt;/code&gt;) components</source>
          <target state="translated">単一ファイル（ &lt;code&gt;.vue&lt;/code&gt; ）コンポーネント</target>
        </trans-unit>
        <trans-unit id="a0fcc7019dc5bbeb59c13b0247440b91dff10e8e" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing</source>
          <target state="translated">単一ファイルのコンポーネントファイル名のケーシング</target>
        </trans-unit>
        <trans-unit id="093c716d53dd968ee64e9ba688e8285861d21500" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">単一ファイルのコンポーネントのファイル名の大文字小文字の区別を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="aad2c1946beed7073bd3f80b10b836af1bd801c0" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order</source>
          <target state="translated">シングルファイルコンポーネントのトップレベル要素の順序</target>
        </trans-unit>
        <trans-unit id="369e619c0ac6b0e41c0c5e5672725a1dad22811c" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">単一ファイルコンポーネントの最上位要素の順序を&lt;sup&gt;推奨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e5ab16f7ba44150cac61508afe92cbd1d1dd294b" translate="yes" xml:space="preserve">
          <source>Single-instance component names</source>
          <target state="translated">シングルインスタンスのコンポーネント名</target>
        </trans-unit>
        <trans-unit id="801a9b431b0affdfa69d3dd93084d1b29dae9cb0" translate="yes" xml:space="preserve">
          <source>Single-instance component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">単一インスタンスのコンポーネント名を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="896ccfe8515d070b5a15610d907daecc5196a888" translate="yes" xml:space="preserve">
          <source>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</source>
          <target state="translated">この要素とそのすべての子要素のコンパイルをスキップします。これは生の口ひげタグを表示するために使用できます。大量のノードをスキップして、その上にディレクティブを持たないようにすることで、コンパイルを高速化することもできます。</target>
        </trans-unit>
        <trans-unit id="083d20797ac518ecfd2d5802f11e56f053d9b2a3" translate="yes" xml:space="preserve">
          <source>Slot Content</source>
          <target state="translated">スロットの内容</target>
        </trans-unit>
        <trans-unit id="0c1a16e17517d5db584e59f03e5701a1df0aec29" translate="yes" xml:space="preserve">
          <source>Slots</source>
          <target state="translated">Slots</target>
        </trans-unit>
        <trans-unit id="0c05d5215c9958f423cfa89492ade3561c496be1" translate="yes" xml:space="preserve">
          <source>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</source>
          <target state="translated">小規模で焦点を絞った計算されたプロパティは、情報がどのように使用されるかについての仮定が少ないため、要件の変更に伴うリファクタリングが少なくて済みます。</target>
        </trans-unit>
        <trans-unit id="270782c16d7dfcd9bacc30c93f3205da13a192a6" translate="yes" xml:space="preserve">
          <source>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</source>
          <target state="translated">そのため、たとえごく一部のユーザーの要素だけをレンダリングしたとしても、アクティブなユーザーのセットが変わったかどうかに関わらず、再レンダリングするたびにリスト全体を反復処理しなければなりません。</target>
        </trans-unit>
        <trans-unit id="9efa5f0263f4584699ee25a6ef7cd96b38af2cbd" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</source>
          <target state="translated">これまでは、テンプレート内の単純なプロパティキーにのみバインドしてきました。しかし、Vue.jsは実際にはすべてのデータバインディング内のJavaScript式の全機能をサポートしています。</target>
        </trans-unit>
        <trans-unit id="fc43cc8fe805d607917adfb57b267a4c1e366e21" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve managed transitions for:</source>
          <target state="translated">これまでのところ、トランジションを管理してきました。</target>
        </trans-unit>
        <trans-unit id="9990ce27d68bc258ecfe618b1e117aba2e010d2d" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only created components using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">これまでのところ、 &lt;code&gt;Vue.component&lt;/code&gt; を使用してコンポーネントを作成しました：</target>
        </trans-unit>
        <trans-unit id="67796fb098e807812b451996ffa7c37901a92525" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only seen props listed as an array of strings:</source>
          <target state="translated">これまでのところ、文字列の配列としてリストされている小道具だけを見てきました。</target>
        </trans-unit>
        <trans-unit id="bcb7e6dc22797e50c31c81c6ca57f0d64cd4b40a" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen props passed a static value, like in:</source>
          <target state="translated">これまでのところ、次のようにプロップが静的な値を渡すのを見てきました。</target>
        </trans-unit>
        <trans-unit id="bf5ea7f867584dc6f766ba242591c6f576f49d80" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen uses of &lt;code&gt;$emit&lt;/code&gt;, listened to with &lt;code&gt;v-on&lt;/code&gt;, but Vue instances also offer other methods in its events interface. We can:</source>
          <target state="translated">これまでのところ、 &lt;code&gt;v-on&lt;/code&gt; でリッスンされた &lt;code&gt;$emit&lt;/code&gt; 使用を見てきましたが、Vueインスタンスはそのイベントインターフェースで他のメソッドも提供しています。私たちはできる：</target>
        </trans-unit>
        <trans-unit id="8d84a44b86d81a516326f9813e2b3977e997a457" translate="yes" xml:space="preserve">
          <source>So this might be a good time to refactor the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to accept a single &lt;code&gt;post&lt;/code&gt; prop instead:</source>
          <target state="translated">したがって、これは &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントをリファクタリングして、代わりに単一の &lt;code&gt;post&lt;/code&gt; 小道具を受け入れる良いタイミングかもしれません。</target>
        </trans-unit>
        <trans-unit id="d6aa2762b60d0919d3cc5d125c99532a28d73b78" translate="yes" xml:space="preserve">
          <source>So what about for when we have a whole list of items we want to render simultaneously, for example with &lt;code&gt;v-for&lt;/code&gt;? In this case, we&amp;rsquo;ll use the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component. Before we dive into an example though, there are a few things that are important to know about this component:</source>
          <target state="translated">それで、たとえば &lt;code&gt;v-for&lt;/code&gt; で同時にレンダリングしたいアイテムのリスト全体がある場合はどうでしょうか？この場合、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; コンポーネントを使用します。ただし、例に入る前に、このコンポーネントについて知っておくべき重要なことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="147f6354f521a67959c12f2f8261d77ce2bb9c39" translate="yes" xml:space="preserve">
          <source>Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; などの一部のHTML要素は、その内部に表示できる要素に制限があり、 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; などの一部の要素は他の特定の要素内に表示されます。</target>
        </trans-unit>
        <trans-unit id="9c0790e8dcd7f3a0c69aa32f511de55c1f1ea0e6" translate="yes" xml:space="preserve">
          <source>Some advantages of this convention:</source>
          <target state="translated">この大会の利点をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="2108424fbba417074fadf0d75a3e1edc693ebce6" translate="yes" xml:space="preserve">
          <source>Some argue that you&amp;rsquo;d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn&amp;rsquo;t mean the user doesn&amp;rsquo;t need to learn anything - it&amp;rsquo;s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it&amp;rsquo;s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. &lt;code&gt;v-on&lt;/code&gt; modifiers). The same task can involve a lot more code when using plain JSX or render functions.</source>
          <target state="translated">テンプレートを作成できるようにするには、追加のDSL（ドメイン固有言語）を学ぶ必要があると主張する人もいます。この違いはせいぜい表面的なものだと信じています。まず、JSXはユーザーが何も学ぶ必要がないという意味ではありません。これはプレーンJavaScriptに加えて追加の構文であるため、JavaScriptに慣れている人が簡単に学ぶことができます。同様に、テンプレートはプレーンHTMLに加えた追加の構文にすぎないため、すでにHTMLに慣れている人にとっては、学習コストは非常に低くなります。 DSLを使用すると、ユーザーは少ないコード（ &lt;code&gt;v-on&lt;/code&gt; 修飾子など）でより多くのことを達成できるようにすることもできます。プレーンなJSXまたはレンダー関数を使用する場合、同じタスクにさらに多くのコードが含まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a9ef7770ac385e4eae53d066a2f3c10a8b6c4ab6" translate="yes" xml:space="preserve">
          <source>Some directives can take an &amp;ldquo;argument&amp;rdquo;, denoted by a colon after the directive name. For example, the &lt;code&gt;v-bind&lt;/code&gt; directive is used to reactively update an HTML attribute:</source>
          <target state="translated">一部のディレクティブは、「引数」をとることができ、ディレクティブ名の後にコロンで示されます。たとえば、 &lt;code&gt;v-bind&lt;/code&gt; ディレクティブは、HTML属性を事後的に更新するために使用されます。</target>
        </trans-unit>
        <trans-unit id="09428a807ec781f76bc254d725a9a4e0a2df7f8b" translate="yes" xml:space="preserve">
          <source>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of &lt;code&gt;new Function()&lt;/code&gt; for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</source>
          <target state="translated">Google Chromeアプリなどの一部の環境では、コンテンツセキュリティポリシー（CSP）が適用され、式の評価に &lt;code&gt;new Function()&lt;/code&gt; を使用することが禁止されています。完全なビルドは、テンプレートをコンパイルするためにこの機能に依存しているため、これらの環境では使用できません。</target>
        </trans-unit>
        <trans-unit id="5a2e23d7e711dac515b3913d004594ddb71e0888" translate="yes" xml:space="preserve">
          <source>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</source>
          <target state="translated">Vue の機能の中には、まれなエッジケースや、レガシー コード ベースからの移行をスムーズに行うために存在するものがあります。しかし、これらの機能が過剰に使用されると、コードの保守が難しくなったり、バグの原因になったりする可能性があります。これらのルールでは、危険性のある機能に光を当て、いつ、なぜそれらを避けるべきかを説明しています。</target>
        </trans-unit>
        <trans-unit id="d10fd1239637017ec222f508352aa84bee00680a" translate="yes" xml:space="preserve">
          <source>Some of Vue&amp;rsquo;s syntax will look very similar to AngularJS (e.g. &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt;). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.</source>
          <target state="translated">Vueの構文の一部は、AngularJSに非常に似ています（例： &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;ng-if&lt;/code&gt; ）。これは、AngularJSが正しく行ったことがたくさんあり、それらがVueの開発の非常に早い段階でのインスピレーションであったためです。AngularJSには多くの問題がありますが、Vueは大幅な改善を試みています。</target>
        </trans-unit>
        <trans-unit id="ba632b521cfadde631ed92ffd03194fe0b0a9806" translate="yes" xml:space="preserve">
          <source>Some of the current hooks have different behavior and there are also a couple new hooks.</source>
          <target state="translated">現在のフックの中には動作が異なるものもありますし、新しいフックもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="823d42c9ef6472009b44bd254d2588f2ed0ae4c8" translate="yes" xml:space="preserve">
          <source>Some of the most notable differences include:</source>
          <target state="translated">特筆すべき違いとしては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="85976567c84aab5c4b5906f9117b4275cd11d741" translate="yes" xml:space="preserve">
          <source>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.</source>
          <target state="translated">以下のセクションのいくつかは、React 16+での最近のアップデートのために若干古くなっている可能性があり、近い将来、Reactコミュニティと協力してこのセクションを改訂する予定です。</target>
        </trans-unit>
        <trans-unit id="e66b9d4602dcda92a8811e8379102ad854fa4037" translate="yes" xml:space="preserve">
          <source>Some plugins provided by Vue.js official plugins such as &lt;code&gt;vue-router&lt;/code&gt; automatically calls &lt;code&gt;Vue.use()&lt;/code&gt; if &lt;code&gt;Vue&lt;/code&gt; is available as a global variable. However in a module environment such as CommonJS, you always need to call &lt;code&gt;Vue.use()&lt;/code&gt; explicitly:</source>
          <target state="translated">&lt;code&gt;Vue&lt;/code&gt; がグローバル変数として利用できる場合、 &lt;code&gt;vue-router&lt;/code&gt; などのVue.js公式プラグインによって提供される一部のプラグインは自動的に &lt;code&gt;Vue.use()&lt;/code&gt; を呼び出します。ただし、CommonJSなどのモジュール環境では、常に明示的に &lt;code&gt;Vue.use()&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9fe62eac7aa92f9e248fd4f6cf8a8c9817319b5d" translate="yes" xml:space="preserve">
          <source>Some users have enjoyed using two-way filters with &lt;code&gt;v-model&lt;/code&gt; to create interesting inputs with very little code. While &lt;em&gt;seemingly&lt;/em&gt; simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</source>
          <target state="translated">一部のユーザーは、 &lt;code&gt;v-model&lt;/code&gt; で双方向フィルターを使用して、非常に少ないコードで興味深い入力を作成することを楽しんでいます。一方で&lt;em&gt;、一見&lt;/em&gt;シンプルただし、双方向フィルタも複雑の多くを非表示にすることができます-とさえ状態の更新を遅延させることにより、貧しいUXを奨励します。代わりに、カスタム入力を作成するより明示的で機能豊富な方法として、入力をラップするコンポーネントをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a20659b05e332a0ae32621debfebacc5d1ababa5" translate="yes" xml:space="preserve">
          <source>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</source>
          <target state="translated">遷移するアイテムが絶対的にお互いの上に配置されている場合など、これがうまく機能することもあります。</target>
        </trans-unit>
        <trans-unit id="f26fd8bf6b50010b5da928fa27ec1a70c263cd9c" translate="yes" xml:space="preserve">
          <source>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special &lt;code&gt;$event&lt;/code&gt; variable:</source>
          <target state="translated">インラインステートメントハンドラーで元のDOMイベントにアクセスする必要がある場合もあります。特別な &lt;code&gt;$event&lt;/code&gt; 変数を使用して、それをメソッドに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a58007ff3d542a5e64e8ab0473747490736edba5" translate="yes" xml:space="preserve">
          <source>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</source>
          <target state="translated">元のデータを実際に変異させたりリセットしたりすることなく、フィルタリングされた配列やソートされた配列を表示したい場合があります。このような場合には、フィルタリングされた配列やソートされた配列を返すcomputedプロパティを作成することができます。</target>
        </trans-unit>
        <trans-unit id="bb4776e0f84b8cab0978edcc2a16ccf37eb32d43" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of new properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. In such cases, you should create a fresh object with properties from both objects. So instead of:</source>
          <target state="translated">たとえば、 &lt;code&gt;Object.assign()&lt;/code&gt; または &lt;code&gt;_.extend()&lt;/code&gt; を使用して、既存のオブジェクトにいくつかの新しいプロパティを割り当てたい場合があります。このような場合は、両方のオブジェクトのプロパティを使用して新しいオブジェクトを作成する必要があります。だから代わりに：</target>
        </trans-unit>
        <trans-unit id="4216179a7f142347ead5e8b4c8a44ddd1938267a" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</source>
          <target state="translated">たとえば、 &lt;code&gt;Object.assign()&lt;/code&gt; または &lt;code&gt;_.extend()&lt;/code&gt; を使用して、既存のオブジェクトにいくつかのプロパティを割り当てたい場合があります。ただし、オブジェクトに追加された新しいプロパティは変更をトリガーしません。このような場合は、元のオブジェクトとミックスインオブジェクトの両方のプロパティを使用して、新しいオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="4a3e5c479936fa0c0c3ae63c92af5bdeccbe0976" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful for slot content to have access to data only available in the child component. For example, imagine a &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">スロットコンテンツが子コンポーネントでのみ使用可能なデータにアクセスできると便利な場合があります。たとえば、次のテンプレートを持つ &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; コンポーネントを想像してください。</target>
        </trans-unit>
        <trans-unit id="d2dd5e9a7fd5d98bf25e0a4d4fb18f9f4c3db2f1" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to dynamically switch between components, like in a tabbed interface:</source>
          <target state="translated">タブ付きインターフェースのように、コンポーネントを動的に切り替えると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="878866be830f3d4c0492c7b15ce7d3313f921fc8" translate="yes" xml:space="preserve">
          <source>Soup &lt;em&gt;of the&lt;/em&gt; day</source>
          <target state="translated">スープ&lt;em&gt;の&lt;/em&gt;日</target>
        </trans-unit>
        <trans-unit id="9898b37c34a88e00f23e82b5e3dc9a1701903a0c" translate="yes" xml:space="preserve">
          <source>Special Attributes</source>
          <target state="translated">特殊属性</target>
        </trans-unit>
        <trans-unit id="c1844df643c3c6b29d9ebd395e5456144c913b68" translate="yes" xml:space="preserve">
          <source>Special Attributes - ref</source>
          <target state="translated">特殊属性-参照</target>
        </trans-unit>
        <trans-unit id="7f375124a7e84608fdea56b183bf085ef84dd0dd" translate="yes" xml:space="preserve">
          <source>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</source>
          <target state="translated">プロップのデフォルト値を指定します。プロップが渡されなかった場合は、この値が代わりに使用されます。オブジェクトまたは配列のデフォルト値は、ファクトリー関数から返されなければなりません。</target>
        </trans-unit>
        <trans-unit id="3d419b352796d39146919ef5966306201da0baac" translate="yes" xml:space="preserve">
          <source>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as &lt;code&gt;this.$parent&lt;/code&gt; for the child, and the child will be pushed into the parent&amp;rsquo;s &lt;code&gt;$children&lt;/code&gt; array.</source>
          <target state="translated">作成するインスタンスの親インスタンスを指定します。2つの間に親子関係を確立します。親は子の &lt;code&gt;this.$parent&lt;/code&gt; としてアクセスでき、子は親の &lt;code&gt;$children&lt;/code&gt; 配列にプッシュされます。</target>
        </trans-unit>
        <trans-unit id="e4de7be6dcaca74a1df3b6f74eed72c7caf49130" translate="yes" xml:space="preserve">
          <source>Staggering List Transitions</source>
          <target state="translated">スタガリングリストの遷移</target>
        </trans-unit>
        <trans-unit id="5ba91e4b27bd154b6feecd545db4023c8e7c12d0" translate="yes" xml:space="preserve">
          <source>Start by running the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on a current project. We&amp;rsquo;ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they&amp;rsquo;ll let you know, offer suggestions, and provide links to more info.</source>
          <target state="translated">現在のプロジェクトで&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;移行ヘルパー&lt;/a&gt;を実行することから始めます。上級Vue開発者を注意深く縮小し、シンプルなコマンドラインインターフェイスに圧縮しました。廃止された機能を認識すると、通知、提案、詳細情報へのリンクが提供されます。</target>
        </trans-unit>
        <trans-unit id="5fcf8af955dfbcfec984375c6e8f6a528e65233d" translate="yes" xml:space="preserve">
          <source>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="translated">2.3.0.0+からは、例えばスタイルプロパティに複数の(接頭辞のついた)値の配列を与えることができます。</target>
        </trans-unit>
        <trans-unit id="9ba53e05f135de31a97be4f79621e7c2bfae116b" translate="yes" xml:space="preserve">
          <source>Starting in 2.4.0+, &lt;code&gt;v-on&lt;/code&gt; also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</source>
          <target state="translated">2.4.0以降では、 &lt;code&gt;v-on&lt;/code&gt; は引数なしのイベント/リスナーペアのオブジェクトへのバインドもサポートします。オブジェクト構文を使用する場合、修飾子はサポートされません。</target>
        </trans-unit>
        <trans-unit id="9b9230ebf8a27183774b5eb88b79650092ee23d2" translate="yes" xml:space="preserve">
          <source>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="translated">バージョン 2.6.0 からは、JavaScript の式を角括弧で囲むことで、ディレクティブの引数に使用することも可能になりました。</target>
        </trans-unit>
        <trans-unit id="bfa146787ba4b5ec0af7e28c9b9db98dcdf2cd1c" translate="yes" xml:space="preserve">
          <source>State Management</source>
          <target state="translated">状態管理</target>
        </trans-unit>
        <trans-unit id="d5d64221ddf91f88df67cce91813f4262eb7edaf" translate="yes" xml:space="preserve">
          <source>State Transitions</source>
          <target state="translated">状態遷移</target>
        </trans-unit>
        <trans-unit id="a872ca8fe22c7e62b5337472cd220dc9385362c8" translate="yes" xml:space="preserve">
          <source>Stop listening for an event with &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt; を停止します</target>
        </trans-unit>
        <trans-unit id="a59e5fba28ea5c4503821b338479233b19afe716" translate="yes" xml:space="preserve">
          <source>Store&amp;rsquo;s Event Emitter &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">ストアのイベントエミッターが&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="91315c1968e95b4caef2bb0299209f84b45e1fa3" translate="yes" xml:space="preserve">
          <source>String templates (e.g. &lt;code&gt;template: '...'&lt;/code&gt;)</source>
          <target state="translated">文字列テンプレート（例： &lt;code&gt;template: '...'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="74b4f2ed89813f9a73f7270d61c097ff9c059dd6" translate="yes" xml:space="preserve">
          <source>Style Guide</source>
          <target state="translated">スタイルガイド</target>
        </trans-unit>
        <trans-unit id="93b9066aa73ddae63c26874719afa6da8fe21b7f" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority A: Essential</source>
          <target state="translated">スタイルガイド。優先度A:エッセンシャル</target>
        </trans-unit>
        <trans-unit id="43212530e7b38b61ce475ee08dd6944866d5239c" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority B: Strongly Recommended</source>
          <target state="translated">スタイルガイド。優先度B:強く推奨</target>
        </trans-unit>
        <trans-unit id="dc97fc3044903277305bdcda1967fb4d1dab822e" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority C: Recommended</source>
          <target state="translated">スタイルガイド。優先度C:推奨</target>
        </trans-unit>
        <trans-unit id="b9a479a71d55ce0478bf03634c2c6dce93bce7d7" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority D: Use with Caution</source>
          <target state="translated">スタイルガイド。優先順位D.注意して使用する</target>
        </trans-unit>
        <trans-unit id="d999535d9e96f490d6db66310b5ab700b8118ee7" translate="yes" xml:space="preserve">
          <source>Style Guide: Rule Categories</source>
          <target state="translated">スタイルガイド.ルールのカテゴリー</target>
        </trans-unit>
        <trans-unit id="fbbf610d0cedad761fd69b3fc9625e259e3102c5" translate="yes" xml:space="preserve">
          <source>Suppress all Vue logs and warnings.</source>
          <target state="translated">すべての Vue ログと警告を抑制します。</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ed4b8354b13fc6485ba3014a73af2e474df2ab5c" translate="yes" xml:space="preserve">
          <source>System Modifier Keys</source>
          <target state="translated">システム修飾キー</target>
        </trans-unit>
        <trans-unit id="d3c9825399d84e5c262586eb382db07595391d25" translate="yes" xml:space="preserve">
          <source>Template Compilation</source>
          <target state="translated">テンプレート編集</target>
        </trans-unit>
        <trans-unit id="efb3147068725b40c3436e7283942bba6c112bbf" translate="yes" xml:space="preserve">
          <source>Template Syntax</source>
          <target state="translated">テンプレート構文</target>
        </trans-unit>
        <trans-unit id="a60e21f3a907038b2e4d24850447a7990f71ed0d" translate="yes" xml:space="preserve">
          <source>Template expressions are sandboxed and only have access to a &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;whitelist of globals&lt;/a&gt; such as &lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;Date&lt;/code&gt;. You should not attempt to access user defined globals in template expressions.</source>
          <target state="translated">テンプレート式はサンドボックス化されており、 &lt;code&gt;Math&lt;/code&gt; や &lt;code&gt;Date&lt;/code&gt; など&lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;のグローバルのホワイトリストに&lt;/a&gt;のみアクセスできます。テンプレート式でユーザー定義のグローバルにアクセスしないでください。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="03aaa3887a5a2deee792941da96ae7dda7d74089" translate="yes" xml:space="preserve">
          <source>Thanks to Vue&amp;rsquo;s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</source>
          <target state="translated">VueのReactivityシステムのおかげで、更新するタイミングが常にわかります（正しく使用した場合）。ただし、反応データが変更されていないにもかかわらず、強制的に更新したい場合があります。次に、不要な更新を防止したい場合があります。</target>
        </trans-unit>
        <trans-unit id="b5627556ef42d923efe566603e16cd6d339c54b6" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; listener, the parent will receive the event and update &lt;code&gt;postFontSize&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; リスナーのおかげで、親はイベントを受け取り、 &lt;code&gt;postFontSize&lt;/code&gt; 値を更新します。</target>
        </trans-unit>
        <trans-unit id="36e5dbb5155a7f2f18ff2f7f92eeacd1bc83b650" translate="yes" xml:space="preserve">
          <source>That means the value of &lt;code&gt;v-slot&lt;/code&gt; can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;), you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; to pull out specific slot props, like so:</source>
          <target state="translated">つまり、 &lt;code&gt;v-slot&lt;/code&gt; の値は、関数定義の引数の位置に現れる可能性のある有効なJavaScript式を実際に受け入れることができます。したがって、サポートされている環境（&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;最新のブラウザー&lt;/a&gt;）では、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015の構造解除を&lt;/a&gt;使用して、次のように特定のスロットプロップを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="bcb7688f15ef595e1970dc731883ce107eed33d5" translate="yes" xml:space="preserve">
          <source>That means this element:</source>
          <target state="translated">つまり、この要素。</target>
        </trans-unit>
        <trans-unit id="e26ac9d99d2de3a31a44d33d135f52e40dec965b" translate="yes" xml:space="preserve">
          <source>That said, it would probably make a better comparison between Vue core and Ember&amp;rsquo;s &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;templating&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;object model&lt;/a&gt; layers:</source>
          <target state="translated">そうは言っても、おそらくVueコアとEmberの&lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;テンプレート&lt;/a&gt;層および&lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;オブジェクトモデル&lt;/a&gt;レイヤーをより適切に比較できるでしょう。</target>
        </trans-unit>
        <trans-unit id="fd91ee6e59ac928406a857815fec4a8fd6adac41" translate="yes" xml:space="preserve">
          <source>That slot has access to the same instance properties (i.e. the same &amp;ldquo;scope&amp;rdquo;) as the rest of the template. The slot does &lt;strong&gt;not&lt;/strong&gt; have access to &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s scope. For example, trying to access &lt;code&gt;url&lt;/code&gt; would not work:</source>
          <target state="translated">そのスロットは、テンプレートの他の部分と同じインスタンスプロパティ（つまり、同じ「スコープ」）にアクセスできます。スロットは &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; のスコープにアクセスできませ&lt;strong&gt;ん&lt;/strong&gt;。たとえば、 &lt;code&gt;url&lt;/code&gt; にアクセスしようとしても機能しません。</target>
        </trans-unit>
        <trans-unit id="459dd83f2362d8a07c853704c9fdaa721e9d7d51" translate="yes" xml:space="preserve">
          <source>That template doesn&amp;rsquo;t feel great. It&amp;rsquo;s not only verbose, but we&amp;rsquo;re duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level and will have to do the same when we add the anchor element.</source>
          <target state="translated">そのテンプレートは気分が良くありません。これは冗長であるだけでなく、すべての見出しレベルで &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; を複製しているため、アンカー要素を追加するときにも同じことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="f0e76918c986bcb84adf08fee89b468d3a1fda00" translate="yes" xml:space="preserve">
          <source>That won&amp;rsquo;t work, however, because only the &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component has access to the &lt;code&gt;user&lt;/code&gt; and the content we&amp;rsquo;re providing is rendered in the parent.</source>
          <target state="translated">理由だけでそれは、しかし仕事、しません &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; コンポーネントがアクセス持つ &lt;code&gt;user&lt;/code&gt; 、私たちが提供しているコンテンツが親にレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="f7e6eaf815a0b389b506fd9203ee98688ac385cc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about DOM template parsing caveats for now &amp;ndash; and actually, the end of Vue&amp;rsquo;s &lt;em&gt;Essentials&lt;/em&gt;. Congratulations! There&amp;rsquo;s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</source>
          <target state="translated">今のところ、DOMテンプレートの解析に関する警告について知っておく必要があるのはこれだけです。実際には、Vueの&lt;em&gt;Essentialsの&lt;/em&gt;終わりです。おめでとう！学ぶべきことはまだまだありますが、最初に、Vueを自分で遊んで楽しいものを作るために休憩を取ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e65f913a2b8930db25e11b615901938e35677612" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about custom component events for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-custom-events&quot;&gt;Custom Events&lt;/a&gt;.</source>
          <target state="translated">今のところ、カスタムコンポーネントイベントについて知っておくべきことはこれだけですが、このページを読み終えて内容に慣れたら、後で戻って&lt;a href=&quot;components-custom-events&quot;&gt;カスタムイベントの&lt;/a&gt;完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="814dc84544fcf8f9ba3af47bc369c70717b8fdfa" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about dynamic components for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;.</source>
          <target state="translated">今のところ、動的コンポーネントについて知っておくべきことはこれだけですが、このページを読み終えて内容に慣れたら、後で戻って&lt;a href=&quot;components-dynamic-async&quot;&gt;動的および非同期コンポーネント&lt;/a&gt;に関する完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1370785d9557daacd2793450c22d6061fa0adbc6" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about props for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-props&quot;&gt;Props&lt;/a&gt;.</source>
          <target state="translated">今のところ、小道具について知っておくべきことはこれだけですが、このページを読み終えて内容に慣れたら、後で戻って&lt;a href=&quot;components-props&quot;&gt;小道具の&lt;/a&gt;完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1e701db7e6d05f9288626f8d97a85fc554f9593e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about registration for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-registration&quot;&gt;Component Registration&lt;/a&gt;.</source>
          <target state="translated">今のところ登録について知っておくべきことはこれだけですが、このページを読み終えて内容に納得したら、後で戻って&lt;a href=&quot;components-registration&quot;&gt;コンポーネント登録&lt;/a&gt;に関する完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8e7ac0de9bc7b2393fad83ed8e57aa35094e7cc2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about slots for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-slots&quot;&gt;Slots&lt;/a&gt;.</source>
          <target state="translated">今のところ、スロットについて知っておくべきことはこれだけですが、このページを読み終えて内容に満足したら、後で戻って&lt;a href=&quot;components-slots&quot;&gt;スロット&lt;/a&gt;に関する完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6f39b1bdd26be7312e776a774c103e8b83e7cb1a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why for any complex logic, you should use a &lt;strong&gt;computed property&lt;/strong&gt;.</source>
          <target state="translated">そのため、複雑なロジックでは、&lt;strong&gt;計算されたプロパティ&lt;/strong&gt;を使用する必要があり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3b16487797e90834fa5c92964e14dabbe10606c8" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why instead, we recommend emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, in a hypothetical component with a &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="translated">そのため、代わりに &lt;code&gt;update:myPropName&lt;/code&gt; のパターンでイベントを発行することをお勧めします。たとえば、 &lt;code&gt;title&lt;/code&gt; プロップを持つ架空のコンポーネントでは、新しい値を割り当てる意図を次のように伝えることができます。</target>
        </trans-unit>
        <trans-unit id="996c0c7a918cb9833eb237973fce54baee6b3199" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why there&amp;rsquo;s a &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel plugin&lt;/a&gt; to use JSX with Vue, getting us back to a syntax that&amp;rsquo;s closer to templates:</source>
          <target state="translated">これが、VSXでJSXを使用する&lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babelプラグイン&lt;/a&gt;があり、テンプレートにより近い構文に戻る理由です。</target>
        </trans-unit>
        <trans-unit id="ad7c55b719b44c49b49edeaa4e2789ec22bd2ca2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why we offer a full system for rapid Vue.js development. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.</source>
          <target state="translated">そのため、迅速なVue.js開発のための完全なシステムを提供しています。&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt;は、Vueエコシステムの標準的なツールのベースラインになることを目指しています。これにより、さまざまなビルドツールが適切なデフォルトとスムーズに連動し、構成に時間を費やす代わりにアプリの作成に集中できます。同時に、特定のニーズに合わせて各ツールの構成を調整する柔軟性も提供します。</target>
        </trans-unit>
        <trans-unit id="e8054cccceec827f8cba34b7a1b6bd02a65cd67d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;guide/installation&quot;&gt;Installation&lt;/a&gt; page provides more options of installing Vue. Note: We &lt;strong&gt;do not&lt;/strong&gt; recommend that beginners start with &lt;code&gt;vue-cli&lt;/code&gt;, especially if you are not yet familiar with Node.js-based build tools.</source>
          <target state="translated">[ &lt;a href=&quot;guide/installation&quot;&gt;インストール]&lt;/a&gt;ページには、Vueをインストールするためのその他のオプションがあります。注：特にNode.jsベースのビルドツールにまだ慣れていない場合は、初心者が &lt;code&gt;vue-cli&lt;/code&gt; から始める&lt;strong&gt;ことは&lt;/strong&gt;お勧めしません。</target>
        </trans-unit>
        <trans-unit id="a5ab4cb7708169e37819b6bac8b1dd32c12097a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;pluralize&lt;/a&gt; package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like &lt;code&gt;0&lt;/code&gt;, then you can also easily define your own pluralize functions. For example:</source>
          <target state="translated">NPM の&lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;複数形&lt;/a&gt;パッケージはこの目的をうまく果たしますが、特定の単語のみを複数形にしたい場合、または &lt;code&gt;0&lt;/code&gt; のような場合の特別な出力が必要な場合は、独自の複数形関数を簡単に定義することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="05878157178d05a4e01a1c89173d306a9458b9ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$route&lt;/code&gt; property is now reactive, so you can use a watcher to react to route changes, like this:</source>
          <target state="translated">&lt;code&gt;$route&lt;/code&gt; プロパティが反応性があるので、あなたは、このようなルート変更、に反応するウォッチャーを使用することができます。</target>
        </trans-unit>
        <trans-unit id="26e5d2730ae73e0e0de2df953cf2ee3a5fad3d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; will be the actual link (and will get the correct href), but the active class will be applied to the outer &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 実際のリンクになり（正しいHREFを取得します）が、アクティブクラスは、外側に適用されます &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1c768384d9ec752c708894881ada4881202a8fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will not be visible until the compilation is done.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; のコンパイルが完了するまで表示されません。</target>
        </trans-unit>
        <trans-unit id="6726c886cd7d1313872ea34b72b56e9373d396cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; component might define a &lt;code&gt;map&lt;/code&gt; property that all subcomponents need access to. In this case &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; might want to access that map with something like &lt;code&gt;this.$parent.getMap&lt;/code&gt;, in order to add a set of markers to it. You can see this pattern &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;in action here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; コンポーネントが定義する可能性がある &lt;code&gt;map&lt;/code&gt; すべてのサブコンポーネントがアクセスする必要があるという性質を。この場合、 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; は、マーカーのセットを追加するために、 &lt;code&gt;this.$parent.getMap&lt;/code&gt; ようなものでそのマップにアクセスする必要があります。このパターンの&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;動作をここで&lt;/a&gt;確認できます。</target>
        </trans-unit>
        <trans-unit id="780604d1e5198fdcc94939f3a317c58b142346c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of &lt;strong&gt;the &lt;code&gt;v-move&lt;/code&gt; class&lt;/strong&gt;, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided &lt;code&gt;name&lt;/code&gt; attribute and you can also manually specify a class with the &lt;code&gt;move-class&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 成分は、そのスリーブアップ他のトリックを持っています。出入りのアニメーションだけでなく、位置の変化もアニメーション化できます。この機能を使用するために知っておく必要がある唯一の新しい概念が追加され&lt;strong&gt; &lt;code&gt;v-move&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;クラス&lt;/strong&gt;のアイテムが位置を変更する際に追加され、。他のクラスと同様に、その接頭辞は提供された &lt;code&gt;name&lt;/code&gt; 属性の値と一致し、 &lt;code&gt;move-class&lt;/code&gt; 属性でクラスを手動で指定することもできます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="606648505385790cf915adeb72e619634753fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.camel&lt;/code&gt; modifier allows camelizing a &lt;code&gt;v-bind&lt;/code&gt; attribute name when using in-DOM templates, e.g. the SVG &lt;code&gt;viewBox&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;.camel&lt;/code&gt; の修飾子は、ラクダができ &lt;code&gt;v-bind&lt;/code&gt; 例えばSVG、中-DOMのテンプレートを使用するときに属性名を &lt;code&gt;viewBox&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="b9f947cb89a1b3d04c28ecc1fa1b5146bc308109" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.exact&lt;/code&gt; modifier allows control of the exact combination of system modifiers needed to trigger an event.</source>
          <target state="translated">&lt;code&gt;.exact&lt;/code&gt; 修飾子は、イベントをトリガするために必要なシステムの改質剤の正確な組み合わせを制御することができます。</target>
        </trans-unit>
        <trans-unit id="71dc161e02d764cb61bccce7f7216e558eea41ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.literal&lt;/code&gt; modifier has been removed, as the same can be easily achieved by providing a string literal as the value.</source>
          <target state="translated">&lt;code&gt;.literal&lt;/code&gt; 同じことが容易値として文字列リテラルを提供することによって達成することができるように改質剤は、除去されています。</target>
        </trans-unit>
        <trans-unit id="447f18c9c1ff6544a5bf8da7ab660de9c45d00c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.passive&lt;/code&gt; modifier is especially useful for improving performance on mobile devices.</source>
          <target state="translated">&lt;code&gt;.passive&lt;/code&gt; 修飾子は、モバイルデバイス上でのパフォーマンスを改善するために特に有用です。</target>
        </trans-unit>
        <trans-unit id="21fd043aec56c5be7446f861bc772ebd8e753810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sync&lt;/code&gt; modifier can also be used with &lt;code&gt;v-bind&lt;/code&gt; when using an object to set multiple props at once:</source>
          <target state="translated">&lt;code&gt;.sync&lt;/code&gt; 改質剤はまた、一緒に使用することができる &lt;code&gt;v-bind&lt;/code&gt; 一度に複数の小道具を設定するオブジェクトを使用する場合：</target>
        </trans-unit>
        <trans-unit id="c3321d11e9ef44eba8d358a3614e37323b934b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;events&lt;/code&gt; option has been removed. Event handlers should now be registered in the &lt;code&gt;created&lt;/code&gt; hook instead. Check out the &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt;&lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; migration guide&lt;/a&gt; for a detailed example.</source>
          <target state="translated">&lt;code&gt;events&lt;/code&gt; オプションが削除されました。代わりに、 &lt;code&gt;created&lt;/code&gt; フックにイベントハンドラーを登録する必要があります。詳細な例については、&lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt; &lt;code&gt;$dispatch&lt;/code&gt; および &lt;code&gt;$broadcast&lt;/code&gt; 移行ガイド&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2b7c4b5febaa054c2d70f2972911d81840dc234e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-out&lt;/code&gt; mode isn&amp;rsquo;t used as often, but can sometimes be useful for a slightly different transition effect. Let&amp;rsquo;s try combining it with the slide-fade transition we worked on earlier:</source>
          <target state="translated">&lt;code&gt;in-out&lt;/code&gt; モードは、しばしばとして使用されていないが、時にはわずかに異なる遷移効果のために有用であり得ます。以前に取り組んだスライドフェードトランジションと組み合わせてみましょう：</target>
        </trans-unit>
        <trans-unit id="7bb2562df8be00932287fedd76a233d44e708651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; と &lt;code&gt;exclude&lt;/code&gt; 小道具コンポーネントが条件付きでキャッシュすることを可能にします。両方の小道具は、コンマで区切られた文字列、RegExpまたは配列にすることができます。</target>
        </trans-unit>
        <trans-unit id="4cd088c8b9dd70d20f540d863e4827655ef4afc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; option should be either:</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt; オプションは、いずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="582a8cbd2aa999f85f97f4835ddb07fec729cd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; special attribute is primarily used as a hint for Vue&amp;rsquo;s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の特別な属性は、主に古いリストに対してノードの新しいリストを差分の時はvノードを識別するためのVueの仮想DOMアルゴリズムのためのヒントとして使用されます。キーがない場合、Vueは要素の動きを最小限に抑えるアルゴリズムを使用し、同じタイプの要素を可能な限りインプレースでパッチ/再利用しようとします。キーを使用すると、キーの順序変更に基づいて要素が並べ替えられ、存在しないキーを持つ要素は常に削除/破棄されます。</target>
        </trans-unit>
        <trans-unit id="dc118214d9d96bdcdab86a3dcf6dbc36ea6680a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt; param attributes are now modifiers, to make it more clear what That means instead of:</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; と &lt;code&gt;number&lt;/code&gt; のparam属性は、どのような意味はなく、それをより明確にするために、今修飾されています。</target>
        </trans-unit>
        <trans-unit id="cb26d534e1e0fd7dab034b343fe732f25ec4cdc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mixins&lt;/code&gt; option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in &lt;code&gt;Vue.extend()&lt;/code&gt;. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</source>
          <target state="translated">&lt;code&gt;mixins&lt;/code&gt; オプションは、ミックスインオブジェクトの配列を受け入れます。これらのミックスインオブジェクトには、通常のインスタンスオブジェクトのようなインスタンスオプションを含めることができ、それらは &lt;code&gt;Vue.extend()&lt;/code&gt; の同じオプションマージロジックを使用して、最終的なオプションに対してマージされます。たとえば、ミックスインに作成されたフックが含まれ、コンポーネント自体にもフックがある場合、両方の関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a26f8d5002e995f88abd483d65f2b8981c550aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Reflect.ownKeys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; オプションは、オブジェクトまたはオブジェクトを返す関数でなければなりません。このオブジェクトには、その子孫への注入に使用できるプロパティが含まれています。ES2015のシンボルをこのオブジェクトのキーとして使用できますが、 &lt;code&gt;Symbol&lt;/code&gt; および &lt;code&gt;Reflect.ownKeys&lt;/code&gt; をネイティブでサポートする環境でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1df98a28e225ea8d4b071027515cc8bf9c095a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; options allows us to specify the data/methods we want to &lt;strong&gt;provide&lt;/strong&gt; to descendent components. In this case, that&amp;rsquo;s the &lt;code&gt;getMap&lt;/code&gt; method inside &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; 私たちがしたいデータ/メソッドを指定することを可能にするオプションを&lt;strong&gt;提供&lt;/strong&gt;子孫コンポーネントにを。この場合、それは &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 内の &lt;code&gt;getMap&lt;/code&gt; メソッドです。</target>
        </trans-unit>
        <trans-unit id="e89e752e4e0ad59fc71d8c42dbb8b140ac0a0a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; function has priority over the render function compiled from &lt;code&gt;template&lt;/code&gt; option or in-DOM HTML template of the mounting element which is specified by the &lt;code&gt;el&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 機能からコンパイルレンダリング機能が優先持つ &lt;code&gt;template&lt;/code&gt; オプションまたはで-DOM HTMLテンプレートで指定された取付要素の &lt;code&gt;el&lt;/code&gt; オプションを選択します。</target>
        </trans-unit>
        <trans-unit id="2f312c98cab71695e7dd222c575b78b0d13a0c64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;slot-scope&lt;/code&gt; attribute can also be used directly on a non-&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element (including components):</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; 属性はまた、非上で直接使用することができる &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; （成分を含む）の要素：</target>
        </trans-unit>
        <trans-unit id="955152ea21b24fdf404e6e6a60a1465f0de55be9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;true-value&lt;/code&gt; and &lt;code&gt;false-value&lt;/code&gt; attributes don&amp;rsquo;t affect the input&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; attribute, because browsers don&amp;rsquo;t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. &amp;ldquo;yes&amp;rdquo; or &amp;ldquo;no&amp;rdquo;), use radio inputs instead.</source>
          <target state="translated">&lt;code&gt;true-value&lt;/code&gt; と &lt;code&gt;false-value&lt;/code&gt; 属性は、入力の影響はありません &lt;code&gt;value&lt;/code&gt; ブラウザでは、フォームの送信に未チェックボックスが含まれていないため、属性を。2つの値のいずれかがフォームで送信されることを保証するには（「yes」または「no」など）、代わりに無線入力を使用します。</target>
        </trans-unit>
        <trans-unit id="e182f837614c4a38080aad510dbbf2060bfc370d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; can be one of the following native constructors:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 次のネイティブのコンストラクタのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="e190ce9f5befbb3426f06af3ed96f5a8aa0969e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-&lt;/code&gt; prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the &lt;code&gt;v-&lt;/code&gt; prefix becomes less important when you are building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, &lt;code&gt;v-bind&lt;/code&gt; and &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-&lt;/code&gt; プレフィックスは、あなたのテンプレートでVueの固有の属性を識別するための視覚的な手がかりとしての役割を果たす。これは、Vue.jsを使用して動的な動作を既存のマークアップに適用する場合に便利ですが、頻繁に使用されるいくつかのディレクティブでは冗長に感じる場合があります。同時に、Vueがすべてのテンプレートを管理する&lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;を構築する場合、 &lt;code&gt;v-&lt;/code&gt; プレフィックスの必要性はそれほど重要ではなくなります。したがって、Vueは、 &lt;code&gt;v-bind&lt;/code&gt; と &lt;code&gt;v-on&lt;/code&gt; の最もよく使用される2つのディレクティブの特別な省略表現を提供します。</target>
        </trans-unit>
        <trans-unit id="cd8461a9f091788550d2bcfcb0e99f3643c233d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-else-if&lt;/code&gt;, as the name suggests, serves as an &amp;ldquo;else if block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;. It can also be chained multiple times:</source>
          <target state="translated">&lt;code&gt;v-else-if&lt;/code&gt; その名の通り、について「他にあればブロック」として機能し、 &lt;code&gt;v-if&lt;/code&gt; 。複数回チェーンすることもできます。</target>
        </trans-unit>
        <trans-unit id="0f6244029a3dc18b6cba09b3e6e0a940180e13b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link-active&lt;/code&gt; directive has also been replaced by the &lt;code&gt;tag&lt;/code&gt; attribute on &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;the &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;. So for example, you&amp;rsquo;ll update this:</source>
          <target state="translated">&lt;code&gt;v-link-active&lt;/code&gt; ディレクティブも置き換えられている &lt;code&gt;tag&lt;/code&gt; の属性&lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; &lt;/a&gt;コンポーネント。たとえば、次のように更新します。</target>
        </trans-unit>
        <trans-unit id="83d24c44d5fff24f0114d4c306087248f718b001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link&lt;/code&gt; directive has been replaced with a new &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:</source>
          <target state="translated">&lt;code&gt;v-link&lt;/code&gt; ディレクティブは、新規に置き換えられました&lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; コンポーネント&lt;/a&gt;の仕事のこの種のは、今のVue 2のコンポーネントのもっぱら責任であるとして、それあなたがこのようなリンクを持っているところはどこでもいつでも手段：</target>
        </trans-unit>
        <trans-unit id="913c16238f6be321d10c7aa5ede9be4e8848de68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-slot&lt;/code&gt; directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes. The full rationale for introducing &lt;code&gt;v-slot&lt;/code&gt; is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;. The &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</source>
          <target state="translated">&lt;code&gt;v-slot&lt;/code&gt; ディレクティブはまだサポートに改善し、代わりのAPIを提供し、Vueの2.6.0で導入された &lt;code&gt;slot&lt;/code&gt; と &lt;code&gt;slot-scope&lt;/code&gt; の属性。 &lt;code&gt;v-slot&lt;/code&gt; を導入する根拠は、この&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFCに&lt;/a&gt;記載されています。 &lt;code&gt;slot&lt;/code&gt; と &lt;code&gt;slot-scope&lt;/code&gt; の属性は、将来のすべての2.xのリリースではサポートされていきますが、正式に廃止され、最終的にはVueの3で削除されます。</target>
        </trans-unit>
        <trans-unit id="f371f3394ccbbd9c9c7339bc5a079bc98cf103c4" translate="yes" xml:space="preserve">
          <source>The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; without any build tools before using the CLI.</source>
          <target state="translated">CLIは、Node.jsおよび関連するビルドツールの事前知識があることを前提としています。Vueまたはフロントエンドのビルドツールを初めて使用する場合は、CLIを使用する前に、ビルドツールなしで&lt;a href=&quot;../index&quot;&gt;ガイド&lt;/a&gt;を読むことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="431e39681a2982cceb38425ec480f7e168f10ba0" translate="yes" xml:space="preserve">
          <source>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;config options&lt;/a&gt;.</source>
          <target state="translated">CLIはほとんどのツール構成を処理しますが、独自の構成&lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;オプションを使用し&lt;/a&gt;てきめ細かなカスタマイズも可能です。</target>
        </trans-unit>
        <trans-unit id="37e9961ffd2140433ee6300b4c25596bb92249ae" translate="yes" xml:space="preserve">
          <source>The Complete SSR Guide</source>
          <target state="translated">コンプリートSSRガイド</target>
        </trans-unit>
        <trans-unit id="eb35b5bf284498fbba8e557432a08e707e7edef3" translate="yes" xml:space="preserve">
          <source>The Data Object In-Depth</source>
          <target state="translated">データオブジェクトの詳細</target>
        </trans-unit>
        <trans-unit id="3c531607ce360cbb5aec13ac8c3438a41dc5f330" translate="yes" xml:space="preserve">
          <source>The Virtual DOM</source>
          <target state="translated">仮想 DOM</target>
        </trans-unit>
        <trans-unit id="babecbcffc795b2e20d9189e575e0bb731f8cd62" translate="yes" xml:space="preserve">
          <source>The Vue Instance</source>
          <target state="translated">Vue インスタンス</target>
        </trans-unit>
        <trans-unit id="be83ced5c720e31f43242c0f5e365ad3f2da0751" translate="yes" xml:space="preserve">
          <source>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don&amp;rsquo;t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</source>
          <target state="translated">Web Components Specは完成しましたが、すべてのブラウザーにネイティブに実装されているわけではありません。Safari 10.1以降、Chrome 54以降、Firefox 63以降では、Webコンポーネントがネイティブでサポートされています。比較すると、Vueコンポーネントはポリフィルを必要とせず、サポートされているすべてのブラウザー（IE9以上）で一貫して機能します。必要に応じて、Vueコンポーネントをネイティブのカスタム要素内にラップすることもできます。</target>
        </trans-unit>
        <trans-unit id="0a28d4802ae8f29af4f28a606d7b55fd498ccb1b" translate="yes" xml:space="preserve">
          <source>The above code is imperative and repetitive. Compare it with a computed property version:</source>
          <target state="translated">上記のコードは命令的で反復的です。計算されたプロパティのバージョンと比較してみてください。</target>
        </trans-unit>
        <trans-unit id="bb879e483c23bffcd30b4eb818c6b264dd8b31d3" translate="yes" xml:space="preserve">
          <source>The above declarations allow the following code to be compiled:</source>
          <target state="translated">上記の宣言により、以下のコードをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="f57aa3ad596a32aa0ee96ea34ada406c21b66366" translate="yes" xml:space="preserve">
          <source>The above example and some future ones use JavaScript&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template literal&lt;/a&gt; to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;newline escapes&lt;/a&gt; instead.</source>
          <target state="translated">上記の例と将来のいくつかの例では、JavaScriptの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;テンプレートリテラル&lt;/a&gt;を使用して、複数行のテンプレートを読みやすくしています。これらはInternet Explorer（IE）ではサポートされていないため、IEをサポートする必要があり、トランスパイルしない場合（たとえば、BabelまたはTypeScriptを使用）、代わりに&lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;改行エスケープ&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="99a5b0f10fab94bdbe6947c371a61fc4c4300760" translate="yes" xml:space="preserve">
          <source>The above is made possible by Vue&amp;rsquo;s &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; element with the &lt;code&gt;is&lt;/code&gt; special attribute:</source>
          <target state="translated">上記は、Vueの &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 要素が &lt;code&gt;is&lt;/code&gt; 特殊属性を使用することで可能になります。</target>
        </trans-unit>
        <trans-unit id="b7374ad3f755708e5dc13a8b4b98839ff8d234e1" translate="yes" xml:space="preserve">
          <source>The above only renders the todos that are not complete.</source>
          <target state="translated">上記は未完成のトドのみをレンダリングしています。</target>
        </trans-unit>
        <trans-unit id="4af7e3e4b79fac718e6fd64e5702254c69dcf11f" translate="yes" xml:space="preserve">
          <source>The above syntax means the presence of the &lt;code&gt;active&lt;/code&gt; class will be determined by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthiness&lt;/a&gt; of the data property &lt;code&gt;isActive&lt;/code&gt;.</source>
          <target state="translated">上記の構文は、 &lt;code&gt;active&lt;/code&gt; クラスの存在がデータプロパティ &lt;code&gt;isActive&lt;/code&gt; の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;真実性&lt;/a&gt;によって決定されることを意味します。</target>
        </trans-unit>
        <trans-unit id="aeec69d6935039bffd444e21fbd1ed7763a7edf9" translate="yes" xml:space="preserve">
          <source>The above will be equivalent to:</source>
          <target state="translated">上記に相当するものになります。</target>
        </trans-unit>
        <trans-unit id="bc22dad858f565e9beeefc992c5465134124606c" translate="yes" xml:space="preserve">
          <source>The anchored heading component we created earlier is relatively simple. It doesn&amp;rsquo;t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it&amp;rsquo;s only a function with some props.</source>
          <target state="translated">以前に作成したアンカー付き見出しコンポーネントは比較的単純です。状態の管理、渡された状態の監視は行われず、ライフサイクルメソッドもありません。本当に、それはいくつかの小道具を備えた機能です。</target>
        </trans-unit>
        <trans-unit id="87b9709d9cefabc9cccc6ad0b23e243c50a3cb35" translate="yes" xml:space="preserve">
          <source>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.</source>
          <target state="translated">配列構文は、オブジェクトの反復処理がブラウザ間で同じプロパティの順序を使用することが保証されていないため、より予測可能なルートマッチングを可能にします。</target>
        </trans-unit>
        <trans-unit id="da3ddd2386065d734a4382298ee4c3e11da253a3" translate="yes" xml:space="preserve">
          <source>The array syntax for &lt;code&gt;v-bind:style&lt;/code&gt; allows you to apply multiple style objects to the same element:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; の配列構文を使用すると、複数のスタイルオブジェクトを同じ要素に適用できます。</target>
        </trans-unit>
        <trans-unit id="e823b9beb8c48498f2cf709b4d0756d4d1fc6465" translate="yes" xml:space="preserve">
          <source>The async component factory can also return an object of the following format:</source>
          <target state="translated">async コンポーネント ファクトリは、以下の形式のオブジェクトを返すこともできます。</target>
        </trans-unit>
        <trans-unit id="ba11fc067d05679fdd5921eda5ec20ebd31b1c5d" translate="yes" xml:space="preserve">
          <source>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</source>
          <target state="translated">エディタの自動補完機能は、長い名前を書くコストを非常に低くしてくれますが、その一方で、エディタが提供する明確さは非常に貴重なものです。特に、一般的ではない略語は常に避けるべきです。</target>
        </trans-unit>
        <trans-unit id="8c22ef1ce4c22f9fdb3192ace8ea666bf31d6a91" translate="yes" xml:space="preserve">
          <source>The bound object doesn&amp;rsquo;t have to be inline:</source>
          <target state="translated">バインドされたオブジェクトはインラインである必要はありません：</target>
        </trans-unit>
        <trans-unit id="c473e09bb4188e420d79ebd60ee46d8c65246cf3" translate="yes" xml:space="preserve">
          <source>The component system is another important concept in Vue, because it&amp;rsquo;s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</source>
          <target state="translated">コンポーネントシステムは、Vueのもう1つの重要な概念です。これは、それが小さな自己完結型の、多くの場合再利用可能なコンポーネントで構成される大規模なアプリケーションを構築できるようにする抽象概念だからです。考えてみると、ほとんどすべての種類のアプリケーションインターフェイスをコンポーネントのツリーに抽象化できます。</target>
        </trans-unit>
        <trans-unit id="e2a227479dfaa2ebe9e09278b1482fab712cafda" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it&amp;rsquo;s usually better to use a &lt;a href=&quot;#computed&quot;&gt;computed property&lt;/a&gt; or &lt;a href=&quot;#watch&quot;&gt;watcher&lt;/a&gt; instead.</source>
          <target state="translated">このフックが呼び出されると、コンポーネントのDOMが更新されるため、ここでDOM依存の操作を実行できます。ただし、ほとんどの場合、フック内の状態を変更しないでください。状態の変化に対応するには、通常、代わりに&lt;a href=&quot;#computed&quot;&gt;計算されたプロパティ&lt;/a&gt;または&lt;a href=&quot;#watch&quot;&gt;ウォッチャー&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="33a9c37f2f9908b2ff6754fe4ced3a3b882e927a" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s name is the first argument of &lt;code&gt;Vue.component&lt;/code&gt;.</source>
          <target state="translated">コンポーネントの名前は &lt;code&gt;Vue.component&lt;/code&gt; の最初の引数です。</target>
        </trans-unit>
        <trans-unit id="6c50d6a412a378e537c001610ef774aa9ae31afc" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;span&lt;/code&gt; will be replaced with the value of the &lt;code&gt;rawHtml&lt;/code&gt; property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use &lt;code&gt;v-html&lt;/code&gt; to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</source>
          <target state="translated">&lt;code&gt;span&lt;/code&gt; のコンテンツは &lt;code&gt;rawHtml&lt;/code&gt; プロパティの値に置き換えられ、プレーンHTMLとして解釈されます-データバインディングは無視されます。Vueは文字列ベースのテンプレートエンジンではないため、テンプレートパーシャルを作成するために &lt;code&gt;v-html&lt;/code&gt; を使用できないことに注意してください。代わりに、UIの再利用と構成の基本単位としてコンポーネントが推奨されます。</target>
        </trans-unit>
        <trans-unit id="0aabf5563ee74ceaaa562a702ba84f4906e6efaf" translate="yes" xml:space="preserve">
          <source>The custom component &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the &lt;code&gt;is&lt;/code&gt; special attribute offers a workaround:</source>
          <target state="translated">カスタムコンポーネント &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; は無効なコンテンツとして引き上げられ、最終的にレンダリングされる出力でエラーが発生します。さいわい、 &lt;code&gt;is&lt;/code&gt; 特殊属性は回避策を提供します。</target>
        </trans-unit>
        <trans-unit id="773dcdb0e4554ae71591d98763ca297e3e508d9e" translate="yes" xml:space="preserve">
          <source>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it &amp;ldquo;reactive&amp;rdquo;. &lt;strong&gt;The object must be plain&lt;/strong&gt;: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</source>
          <target state="translated">Vueインスタンスのデータオブジェクト。Vueはそのプロパティを再帰的にゲッター/セッターに変換し、「反応」させます。&lt;strong&gt;オブジェクトはプレーンである必要があります&lt;/strong&gt;。ブラウザAPIオブジェクトやプロトタイププロパティなどのネイティブオブジェクトは無視されます。経験則では、データは単なるデータである必要があります。独自のステートフル動作でオブジェクトを観察することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="f249c1e096e4760333b8a1a164e494b46a537f23" translate="yes" xml:space="preserve">
          <source>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</source>
          <target state="translated">Vue インスタンスが観測しているデータ オブジェクト。Vue インスタンスは、そのデータ オブジェクトのプロパティへのアクセスをプロキシします。</target>
        </trans-unit>
        <trans-unit id="536204b9289a091fc1bfb216ea4a0b6805215f8d" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;v-for&lt;/code&gt; will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the &lt;code&gt;key&lt;/code&gt; special attribute:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; のデフォルトの動作では、要素を移動せずにインプレースでパッチを適用しようとします。要素の順序を変更することを強制するには、あなたが注文ヒントを提供する必要がある &lt;code&gt;key&lt;/code&gt; 特別な属性：</target>
        </trans-unit>
        <trans-unit id="d129c09e272230c72d4816c9cf37d602f78c6b98" translate="yes" xml:space="preserve">
          <source>The detailed usage for &lt;code&gt;v-for&lt;/code&gt; is explained in the guide section linked below.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; の詳細な使用法は、以下にリンクされているガイドセクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="fcb2400b62e62455e5be23679bc16dcd684f0e97" translate="yes" xml:space="preserve">
          <source>The difference is that an element with &lt;code&gt;v-show&lt;/code&gt; will always be rendered and remain in the DOM; &lt;code&gt;v-show&lt;/code&gt; only toggles the &lt;code&gt;display&lt;/code&gt; CSS property of the element.</source>
          <target state="translated">違いは、 &lt;code&gt;v-show&lt;/code&gt; を含む要素が常にレンダリングされ、DOMに残ることです。 &lt;code&gt;v-show&lt;/code&gt; は、要素のCSSプロパティの &lt;code&gt;display&lt;/code&gt; のみを切り替えます。</target>
        </trans-unit>
        <trans-unit id="9beac5c57d068b893c427afee540acec4a448457" translate="yes" xml:space="preserve">
          <source>The direct child components of the current instance. &lt;strong&gt;Note there&amp;rsquo;s no order guarantee for &lt;code&gt;$children&lt;/code&gt;, and it is not reactive.&lt;/strong&gt; If you find yourself trying to use &lt;code&gt;$children&lt;/code&gt; for data binding, consider using an Array and &lt;code&gt;v-for&lt;/code&gt; to generate child components, and use the Array as the source of truth.</source>
          <target state="translated">現在のインスタンスの直接の子コンポーネント。&lt;strong&gt; &lt;code&gt;$children&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;注文保証はなく、反応しないことに注意してください。&lt;/strong&gt;データバインディングに &lt;code&gt;$children&lt;/code&gt; を使用しようとしている場合は、配列と &lt;code&gt;v-for&lt;/code&gt; を使用して子コンポーネントを生成し、配列を真実のソースとして使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="8966ad2384af724eb5afaebd84955178e2bef331" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;v-if&lt;/code&gt; is used to conditionally render a block. The block will only be rendered if the directive&amp;rsquo;s expression returns a truthy value.</source>
          <target state="translated">ディレクティブ &lt;code&gt;v-if&lt;/code&gt; は、条件付きでブロックをレンダリングするために使用されます。ブロックは、ディレクティブの式が真の値を返す場合にのみレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="a9e1b62f46f6347c3255105bf2f7f7bb4beb980e" translate="yes" xml:space="preserve">
          <source>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the &lt;code&gt;v-html&lt;/code&gt; directive:</source>
          <target state="translated">二重口ひげは、データをHTMLではなくプレーンテキストとして解釈します。実際のHTMLを出力するには、 &lt;code&gt;v-html&lt;/code&gt; ディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cdf9489100840a3b7f6fc331943b5d3351ce62f0" translate="yes" xml:space="preserve">
          <source>The easiest way to pre-compile templates is using &lt;a href=&quot;single-file-components&quot;&gt;Single-File Components&lt;/a&gt; - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</source>
          <target state="translated">テンプレートをプリコンパイルする最も簡単な方法は、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;を使用することです。関連するビルドセットアップでは、プリコンパイルが自動的に実行されるため、ビルドされたコードには、生のテンプレート文字列ではなく、コンパイル済みのレンダリング関数が含まれます。</target>
        </trans-unit>
        <trans-unit id="75f9865708d8a06fa846e682702658bdabd9c8e0" translate="yes" xml:space="preserve">
          <source>The easiest way to try out Vue.js is using the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World example&lt;/a&gt;. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;create an &lt;code&gt;index.html&lt;/code&gt; file&lt;/a&gt; and include Vue with:</source>
          <target state="translated">Vue.jsを試す最も簡単な方法は、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello Worldの例&lt;/a&gt;を使用することです。別のタブで開いて、基本的な例をいくつか見ていきましょう。または、&lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt; &lt;code&gt;index.html&lt;/code&gt; &lt;/a&gt;ファイルを作成して、 Vueを次のように含めることができます。</target>
        </trans-unit>
        <trans-unit id="847757f66edc351ea14e3e7f70aa130ed1b67ad7" translate="yes" xml:space="preserve">
          <source>The el option can no longer be used in &lt;code&gt;Vue.extend&lt;/code&gt;. It&amp;rsquo;s only valid as an instance creation option.</source>
          <target state="translated">elオプションは &lt;code&gt;Vue.extend&lt;/code&gt; では使用できなくなりました。インスタンス作成オプションとしてのみ有効です。</target>
        </trans-unit>
        <trans-unit id="14ff2ebab179926c1bba713b3418f8fa507384ca" translate="yes" xml:space="preserve">
          <source>The filter&amp;rsquo;s function always receives the expression&amp;rsquo;s value (the result of the former chain) as its first argument. In the above example, the &lt;code&gt;capitalize&lt;/code&gt; filter function will receive the value of &lt;code&gt;message&lt;/code&gt; as its argument.</source>
          <target state="translated">フィルターの関数は常に最初の引数として式の値（前のチェーンの結果）を受け取ります。上記の例では、 &lt;code&gt;capitalize&lt;/code&gt; フィルター関数は &lt;code&gt;message&lt;/code&gt; の値を引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="25978631002a6e912099e352f219ba34c4dc10cb" translate="yes" xml:space="preserve">
          <source>The filtered list will &lt;em&gt;only&lt;/em&gt; be re-evaluated if there are relevant changes to the &lt;code&gt;users&lt;/code&gt; array, making filtering much more efficient.</source>
          <target state="translated">フィルタリングされたリストは、 &lt;code&gt;users&lt;/code&gt; 配列に関連する変更がある場合に&lt;em&gt;のみ&lt;/em&gt;再評価され、フィルタリングがより効率的になります。</target>
        </trans-unit>
        <trans-unit id="b5951356bec324133fa39def8def2ef7e47b05c1" translate="yes" xml:space="preserve">
          <source>The following template:</source>
          <target state="translated">以下のようなテンプレートです。</target>
        </trans-unit>
        <trans-unit id="6e4a514c82bb3b7baff7919684302ede3370a422" translate="yes" xml:space="preserve">
          <source>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; for a more inspection-friendly interface.</source>
          <target state="translated">ゲッター/セッターはユーザーには見えませんが、内部的には、プロパティがアクセスまたは変更されたときにVueが依存関係の追跡と変更通知を実行できるようにします。1つの注意点は、変換されたデータオブジェクトがログに記録されると、ブラウザーコンソールがゲッター/セッターを異なる形式でフォーマットするため、より検査に適したインターフェースのために&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;をインストールする必要がある場合があることです。</target>
        </trans-unit>
        <trans-unit id="8cd9d811837e0eecf0a4df368877b6262fe04425" translate="yes" xml:space="preserve">
          <source>The implicitly assigned &lt;code&gt;$index&lt;/code&gt; and &lt;code&gt;$key&lt;/code&gt; variables have been removed in favor of explicitly defining them in &lt;code&gt;v-for&lt;/code&gt;. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.</source>
          <target state="translated">暗黙的に割り当てられた &lt;code&gt;$index&lt;/code&gt; 変数と &lt;code&gt;$key&lt;/code&gt; 変数は、 &lt;code&gt;v-for&lt;/code&gt; で明示的に定義するために削除されました。これにより、Vueの経験が少ない開発者にとってコードが読みやすくなり、ネストされたループを処理するときの動作がより明確になります。</target>
        </trans-unit>
        <trans-unit id="cd591127230d8deaf3a79ff7072473dcdfb326ef" translate="yes" xml:space="preserve">
          <source>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</source>
          <target state="translated">現在の Vue インスタンスで使用されているインスタンス化オプション。これは、カスタム プロパティをオプションに含めたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="6507e95ac3123f38dc39170ae522dfbce1786b53" translate="yes" xml:space="preserve">
          <source>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the &lt;code&gt;v-on&lt;/code&gt; attribute isn&amp;rsquo;t feasible. That&amp;rsquo;s why &lt;code&gt;v-on&lt;/code&gt; can also accept the name of a method you&amp;rsquo;d like to call.</source>
          <target state="translated">ただし、多くのイベントハンドラーのロジックはより複雑になるため、JavaScriptを &lt;code&gt;v-on&lt;/code&gt; 属性の値に維持することは現実的ではありません。そのため、 &lt;code&gt;v-on&lt;/code&gt; は、呼び出すメソッドの名前も受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="a7dfd0134284048bc632e36141f4ea3e7333c213" translate="yes" xml:space="preserve">
          <source>The match is first checked on the component&amp;rsquo;s own &lt;code&gt;name&lt;/code&gt; option, then its local registration name (the key in the parent&amp;rsquo;s &lt;code&gt;components&lt;/code&gt; option) if the &lt;code&gt;name&lt;/code&gt; option is not available. Anonymous components cannot be matched against.</source>
          <target state="translated">最初にコンポーネント自体の &lt;code&gt;name&lt;/code&gt; オプションで一致がチェックされ、次に &lt;code&gt;name&lt;/code&gt; オプションが使用できない場合はそのローカル登録名（親の &lt;code&gt;components&lt;/code&gt; オプションのキー）がチェックされます。匿名コンポーネントは照合できません。</target>
        </trans-unit>
        <trans-unit id="a6157926048113f46fe23ee578e48fe424291d8e" translate="yes" xml:space="preserve">
          <source>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</source>
          <target state="translated">キャッシュするコンポーネント インスタンスの最大数。この数に達すると、最も最近アクセスされなかったキャッシュされたコンポーネント インスタンスは、新しいインスタンスを作成する前に破棄されます。</target>
        </trans-unit>
        <trans-unit id="8bf10a52fb597971ee2811a4b6daca68eb87e10e" translate="yes" xml:space="preserve">
          <source>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</source>
          <target state="translated">マージ戦略は、親インスタンスと子インスタンスで定義されたオプションの値をそれぞれ第 1 引数と第 2 引数として受け取ります。コンテキスト Vue インスタンスは、第 3 引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="7f5a003cef802af9e91a6f9747fac2e515359d41" translate="yes" xml:space="preserve">
          <source>The method returns the instance itself so you can chain other instance methods after it.</source>
          <target state="translated">このメソッドはインスタンス自体を返すので、インスタンスの後に他のインスタンスメソッドを連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="46eb4e33843509639b8c44662beadd21ed8310ed" translate="yes" xml:space="preserve">
          <source>The most basic form of data binding is text interpolation using the &amp;ldquo;Mustache&amp;rdquo; syntax (double curly braces):</source>
          <target state="translated">データバインディングの最も基本的な形式は、「Mustache」構文（二重中括弧）を使用したテキスト補間です。</target>
        </trans-unit>
        <trans-unit id="bd564c73b6d49eec1b2c8919fa49f3bc33098a11" translate="yes" xml:space="preserve">
          <source>The most common use case is combined with &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">最も一般的な使用例は &lt;code&gt;v-for&lt;/code&gt; と組み合わされています：</target>
        </trans-unit>
        <trans-unit id="c379b64d918d58c59f406c013a50f15fd94aaa4c" translate="yes" xml:space="preserve">
          <source>The mustache tag will be replaced with the value of the &lt;code&gt;msg&lt;/code&gt; property on the corresponding data object. It will also be updated whenever the data object&amp;rsquo;s &lt;code&gt;msg&lt;/code&gt; property changes.</source>
          <target state="translated">moustacheタグは、対応するデータオブジェクトの &lt;code&gt;msg&lt;/code&gt; プロパティの値に置き換えられます。また、データオブジェクトの &lt;code&gt;msg&lt;/code&gt; プロパティが変更されるたびに更新されます。</target>
        </trans-unit>
        <trans-unit id="37afbe4bcd06f0f0be230e6d8e06d5f57d026a3e" translate="yes" xml:space="preserve">
          <source>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or &lt;a href=&quot;single-file-components&quot;&gt;single-file component&lt;/a&gt;), we strongly recommend following the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C rules&lt;/a&gt; for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</source>
          <target state="translated">コンポーネントに付ける名前は、使用する場所によって異なる場合があります。（文字列テンプレートまたは&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネントではなく&lt;/a&gt;）DOMで直接コンポーネントを使用する場合、カスタムタグ名の&lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3Cルールに&lt;/a&gt;従うことを強くお勧めします（すべて小文字、ハイフンを含める必要があります）。これにより、現在および将来のHTML要素との競合を回避できます。</target>
        </trans-unit>
        <trans-unit id="49544b57b4faf031cbd490df14c62342f8913c7c" translate="yes" xml:space="preserve">
          <source>The new, more concise way to configure &lt;code&gt;keyCodes&lt;/code&gt; is through &lt;code&gt;Vue.config.keyCodes&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;keyCodes&lt;/code&gt; を構成するための新しいより簡潔な方法は、 &lt;code&gt;Vue.config.keyCodes&lt;/code&gt; を使用することです。例えば：</target>
        </trans-unit>
        <trans-unit id="1ba4a8191026a27a782703cf2cb8992c45a25eab" translate="yes" xml:space="preserve">
          <source>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the &lt;code&gt;props&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt; initialization.</source>
          <target state="translated">次の2つの例は、Vue 2.2.1以降で機能します。そのバージョンより下では、挿入された値は、 &lt;code&gt;props&lt;/code&gt; と &lt;code&gt;data&lt;/code&gt; 初期化後に解決されました。</target>
        </trans-unit>
        <trans-unit id="c4e0ddfdd8217a03837dee9d518c520c1cff551b" translate="yes" xml:space="preserve">
          <source>The next thing you&amp;rsquo;ll have to become familiar with is how to use template features in the &lt;code&gt;createElement&lt;/code&gt; function. Here are the arguments that &lt;code&gt;createElement&lt;/code&gt; accepts:</source>
          <target state="translated">次に慣れる必要があるのは、 &lt;code&gt;createElement&lt;/code&gt; 関数でテンプレート機能を使用する方法です。 &lt;code&gt;createElement&lt;/code&gt; が受け入れる引数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a93809e131de1acb92c27480b98ade7c8b177368" translate="yes" xml:space="preserve">
          <source>The object syntax for &lt;code&gt;v-bind:style&lt;/code&gt; is pretty straightforward - it looks almost like CSS, except it&amp;rsquo;s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; のオブジェクト構文は非常に単純です。JavaScriptオブジェクトであることを除いて、CSSとほとんど同じように見えます。CSSプロパティ名には、キャメルケースまたはケバブケース（ケバブケースでは引用符を使用）を使用できます。</target>
        </trans-unit>
        <trans-unit id="f804d7c199bb60087ee99a4d2ed2841ff111fad8" translate="yes" xml:space="preserve">
          <source>The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</source>
          <target state="translated">公式ガイドでは、HTML、CSS、JavaScriptの中級レベルの知識を前提としています。フロントエンド開発が全く初めての場合、最初のステップとしてフレームワークに飛びつくのは最良のアイデアとは言えないかもしれません-基本を把握してから戻ってきてください! 他のフレームワークを使った経験があると助かりますが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="cdcd3cc5d3cb2f01160d1290fc4a6159e0dddd79" translate="yes" xml:space="preserve">
          <source>The only exception to this being the use of &lt;code&gt;Object.freeze()&lt;/code&gt;, which prevents existing properties from being changed, which also means the reactivity system can&amp;rsquo;t &lt;em&gt;track&lt;/em&gt; changes.</source>
          <target state="translated">これの唯一の例外は、既存のプロパティが変更されないようにする &lt;code&gt;Object.freeze()&lt;/code&gt; の使用です。これは、反応システムが変更を&lt;em&gt;追跡&lt;/em&gt;できないことも意味します。</target>
        </trans-unit>
        <trans-unit id="8eb7f5feed0a750d304ea8614d2edca774bd3f41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;scoped&lt;/code&gt; attribute automatically scopes this CSS to your component by adding a unique attribute (such as &lt;code&gt;data-v-21e5b78&lt;/code&gt;) to elements and compiling &lt;code&gt;.list-container:hover&lt;/code&gt; to something like &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;scoped&lt;/code&gt; 属性は、要素に一意の属性（ &lt;code&gt;data-v-21e5b78&lt;/code&gt; など）を追加し、 &lt;code&gt;.list-container:hover&lt;/code&gt; &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt; ようなものにコンパイルすることで、このCSSをコンポーネントに自動的にスコープします。ホバー。</target>
        </trans-unit>
        <trans-unit id="8f86e91201591c3c1631acf2b2475e6e451afce5" translate="yes" xml:space="preserve">
          <source>The parent instance, if the current instance has one.</source>
          <target state="translated">現在のインスタンスに親インスタンスがある場合は、その親インスタンス。</target>
        </trans-unit>
        <trans-unit id="a213359cc7f926ecae5256c14d1f382a33b06e44" translate="yes" xml:space="preserve">
          <source>The problem is event flows that depend on a component&amp;rsquo;s tree structure can be hard to reason about and are very brittle when the tree becomes large. They don&amp;rsquo;t scale well and only set you up for pain later. &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; also do not solve communication between sibling components.</source>
          <target state="translated">問題は、コンポーネントのツリー構造に依存するイベントフローは、ツリーが大きくなると、推論するのが難しく、非常に脆弱になることです。それらはうまく拡張できず、後で痛みを感じるだけです。 &lt;code&gt;$dispatch&lt;/code&gt; および &lt;code&gt;$broadcast&lt;/code&gt; も、兄弟コンポーネント間の通信を解決しません。</target>
        </trans-unit>
        <trans-unit id="98399a72800d5002678971cac53da1533e26a6d2" translate="yes" xml:space="preserve">
          <source>The problem is that large numbers of &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;element-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;) will be considerably slower than &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;class-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt;), so class selectors should be preferred whenever possible.</source>
          <target state="translated">問題は、多数の&lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;要素属性セレクター&lt;/a&gt;（たとえば、 &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ）が&lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;クラス属性セレクター&lt;/a&gt;（たとえば、 &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt; ）よりもかなり遅くなるため、クラスセレクターが可能な限り優先される。</target>
        </trans-unit>
        <trans-unit id="3bc4b51815e1ca75817d438f9a75b79de4143526" translate="yes" xml:space="preserve">
          <source>The problem is, there are also many &lt;em&gt;simple&lt;/em&gt; cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</source>
          <target state="translated">問題は、これらのパターンが便利&lt;em&gt;な&lt;/em&gt;多くの&lt;em&gt;単純な&lt;/em&gt;ケースがあることです。注意：短期的な便宜（コードの記述を減らす）のために、取引の単純さ（状態の流れを理解できる）に誘惑されないでください。</target>
        </trans-unit>
        <trans-unit id="690eaa8b769a27585770a32b044820cae46112dd" translate="yes" xml:space="preserve">
          <source>The problem is, there are cases where it&amp;rsquo;s important not to delete elements that will remain in the DOM. For example, you may want to use &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; to animate list sorting, or maintain focus if the rendered element is an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In these cases, adding a unique key for each item (e.g. &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt;) will tell Vue how to behave more predictably.</source>
          <target state="translated">問題は、DOMに残る要素を削除しないことが重要な場合があることです。たとえば、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; を使用してリストの並べ替えをアニメーション化したり、レンダリングされた要素が &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; の場合はフォーカスを維持したりできます。これらの場合、各アイテムに一意のキー（例 &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt; ）を追加すると、Vueに予測可能な動作を指示します。</target>
        </trans-unit>
        <trans-unit id="35549fb2854bdbc4b65652d62df1f1ddfa7a99ea" translate="yes" xml:space="preserve">
          <source>The problem is, this button doesn&amp;rsquo;t do anything:</source>
          <target state="translated">問題は、このボタンは何もしないことです。</target>
        </trans-unit>
        <trans-unit id="361cd98689630fb5a124f5e83b5f388af1b8a1f3" translate="yes" xml:space="preserve">
          <source>The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">提供された要素は、単にマウントポイントとして機能します。Vue 1.xとは異なり、マウントされた要素は、すべての場合にVueで生成されたDOMに置き換えられます。したがって、ルートインスタンスを &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; にマウントすることはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="34592f5fd4a2054ce0011f9d4e26a9c654b6f7b5" translate="yes" xml:space="preserve">
          <source>The reason for not automatically injecting &lt;code&gt;item&lt;/code&gt; into the component is because that makes the component tightly coupled to how &lt;code&gt;v-for&lt;/code&gt; works. Being explicit about where its data comes from makes the component reusable in other situations.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; をコンポーネントに自動的に挿入しない理由は、コンポーネントが &lt;code&gt;v-for&lt;/code&gt; の動作に密接に結び付けられるためです。データの出所を明確にすることで、コンポーネントを他の状況で再利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="c532c908704eacdd705ddb6c7847a0bd40253f67" translate="yes" xml:space="preserve">
          <source>The reason is this is the equivalent JavaScript that the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; would compile to:</source>
          <target state="translated">これは、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; が次のようにコンパイルする同等のJavaScriptであるからです。</target>
        </trans-unit>
        <trans-unit id="78702fdec5c6b73fa78a98283262c3e3a610ea89" translate="yes" xml:space="preserve">
          <source>The reference will be HTMLElement when used with functional components because they&amp;rsquo;re stateless and instanceless.</source>
          <target state="translated">参照は、機能コンポーネントで使用される場合、それらはステートレスでインスタンスレスであるため、HTMLElementになります。</target>
        </trans-unit>
        <trans-unit id="c0c42bbffd6116ac9f9aa2c29f718360da13a0c7" translate="yes" xml:space="preserve">
          <source>The rendered HTML will be:</source>
          <target state="translated">レンダリングされたHTMLになります。</target>
        </trans-unit>
        <trans-unit id="a426ede2112c009fbf616db449e0c6e3bc884e8e" translate="yes" xml:space="preserve">
          <source>The result is that many components may include long lists of base components:</source>
          <target state="translated">その結果、多くのコンポーネントは、ベースとなるコンポーネントの長いリストを含む場合がある。</target>
        </trans-unit>
        <trans-unit id="0894c1243efd2b6757cc56c901b4af230a9aac04" translate="yes" xml:space="preserve">
          <source>The returned object can be used directly inside &lt;a href=&quot;../guide/render-function&quot;&gt;render functions&lt;/a&gt; and &lt;a href=&quot;../guide/computed&quot;&gt;computed properties&lt;/a&gt;, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</source>
          <target state="translated">返されたオブジェクトは、&lt;a href=&quot;../guide/render-function&quot;&gt;レンダリング関数&lt;/a&gt;と&lt;a href=&quot;../guide/computed&quot;&gt;計算されたプロパティ&lt;/a&gt;内で直接使用でき、変更されたときに適切な更新をトリガーします。また、シンプルなシナリオの最小のクロスコンポーネントステートストアとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="f5f2182d5b9e1141097f081f69203ed474e7f51a" translate="yes" xml:space="preserve">
          <source>The root DOM element that the Vue instance is managing.</source>
          <target state="translated">Vue インスタンスが管理しているルート DOM 要素。</target>
        </trans-unit>
        <trans-unit id="1fb1fe84422a22a87a20ac9a9db7f5aca1ce36fc" translate="yes" xml:space="preserve">
          <source>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</source>
          <target state="translated">現在のコンポーネント ツリーのルート Vue インスタンス。現在のインスタンスに親がない場合、この値はそれ自身になります。</target>
        </trans-unit>
        <trans-unit id="7b232ff8c5c18691a5df8efcbaf774a1cbaab836" translate="yes" xml:space="preserve">
          <source>The same is true for class bindings:</source>
          <target state="translated">クラスバインディングについても同様です。</target>
        </trans-unit>
        <trans-unit id="dd2c503caba50c997d7446df74ac0da742e9b8eb" translate="yes" xml:space="preserve">
          <source>The size of your app (small to medium-sized apps will probably be less than a day)</source>
          <target state="translated">アプリのサイズ(小~中規模のアプリはおそらく1日に満たないでしょう</target>
        </trans-unit>
        <trans-unit id="71c2733bfb43f78b87500262cd44c42870815508" translate="yes" xml:space="preserve">
          <source>The special case to note here is the &lt;code&gt;data&lt;/code&gt; option - it must be a function when used with &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">ここで注意すべき特別なケースは &lt;code&gt;data&lt;/code&gt; オプションです &lt;code&gt;Vue.extend()&lt;/code&gt; と一緒に使用する場合は関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="572f57cb3c88ad0c0b5d74b281c1e800b18bf5b8" translate="yes" xml:space="preserve">
          <source>The store instance no longer exposes the event emitter interface (&lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;emit&lt;/code&gt;). If you were previously using the store as a global event bus, &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;see this section&lt;/a&gt; for migration instructions.</source>
          <target state="translated">ストアインスタンスは、イベントエミッターインターフェース（ &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;off&lt;/code&gt; 、 &lt;code&gt;emit&lt;/code&gt; ）を公開しなくなりました。以前にストアをグローバルイベントバスとして使用していた場合は、&lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;このセクション&lt;/a&gt;の移行手順を参照してください。</target>
        </trans-unit>
        <trans-unit id="77d67a6f8225d0df00a5fc5a901f8f424ef25e4a" translate="yes" xml:space="preserve">
          <source>The syntax has changed slightly, so &lt;code&gt;/category/*tags&lt;/code&gt; for example, should be updated to &lt;code&gt;/category/:tags+&lt;/code&gt;.</source>
          <target state="translated">構文が少し変更されたため、たとえば &lt;code&gt;/category/*tags&lt;/code&gt; は &lt;code&gt;/category/:tags+&lt;/code&gt; 更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="908884184f3cb4e8612386879bc128af52d0df9c" translate="yes" xml:space="preserve">
          <source>The target object cannot be a Vue instance, or the root data object of a Vue instance.</source>
          <target state="translated">ターゲット オブジェクトは、Vue インスタンスまたは Vue インスタンスのルート データ オブジェクトにはできません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
