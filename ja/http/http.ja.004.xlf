<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP フレームは Web 開発者にとって透過的になりました。これは HTTP/1.1 メッセージと基礎となるトランスポートプロトコルの間にある HTTP/2 の追加ステップです。Web 開発者が HTTP フレームを利用するために使用する API に変更は必要ありません。ブラウザとサーバの両方で利用可能な場合、HTTP/2 はスイッチを入れて使用されます。</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTPには&lt;em&gt;条件付きリクエストの&lt;/em&gt;概念があり、影響を受けるリソースを&lt;em&gt;バリデーターの&lt;/em&gt;値と比較することで、結果、さらにはリクエストの成功を変更できます。このようなリクエストは、キャッシュの内容を検証し、役に立たないコントロールを節約し、ダウンロードを再開するときや、サーバーでドキュメントをアップロードまたは変更するときに更新が失われないようにする場合などに、ドキュメントの整合性を検証するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTPは1990年から使用されています。最初のバージョン（後でHTTP / 0.9と呼ばれる）は、単一の要求メソッド（GET）のみを使用し、メタデータを使用しない、インターネットを介したハイパーテキストデータ転送用のシンプルなプロトコルでした。 HTTP / 1.0、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]、一連のリクエストメソッドとMIMEのようなメッセージングを追加し、メタデータを転送し、リクエスト/レスポンスのセマンティクスに修飾子を配置できるようにしました。ただし、HTTP / 1.0では、階層プロキシ、キャッシュ、永続的な接続の必要性、または名前ベースの仮想ホストの影響を十分に考慮していませんでした。 「HTTP / 1.0」と呼ばれる不完全に実装されたアプリケーションの急増により、通信している2つのアプリケーションが互いの真の機能を判断するために、プロトコルバージョンの変更がさらに必要になりました。 HTTP / 1.1は、信頼性の高い実装を可能にするより厳しい要件を含め、HTTP / 1と安全に無視できる機能のみを追加することにより、HTTP / 1.0との互換性を維持しています。受信者0人、またはHTTP / 1.1への適合を宣伝する当事者と通信するときにのみ送信されます。 HTTP / 1.1は、以前のバージョンを簡単にサポートできるように設計されています。汎用のHTTP / 1.1サーバーは、HTTP / 1.0の形式で有効なリクエストを理解でき、HTTP / 1.0クライアントが理解した（または安全に無視した）機能のみを使用するHTTP / 1.1メッセージで適切に応答する必要があります。同様に、HTTP / 1.1クライアントは、有効なHTTP / 1.0応答を理解することが期待できます。 HTTP / 0.9はリクエストのヘッダーフィールドをサポートしていなかったため、名前ベースの仮想ホスト（ホストヘッダーフィールドの検査によるリソースの選択）をサポートするメカニズムはありません。名前ベースの仮想ホストを実装するサーバーは、HTTP / 0.9のサポートを無効にする必要があります。 HTTP / 0のように見えるほとんどのリクエスト。実際、9つは、クライアントがリクエストターゲットを適切にエンコードできなかったために発生した、正しく構成されていないHTTP / 1.xリクエストです。</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP は、クライアントマシン上で実行されるプログラムをホストする機能を持っています。これらのプログラムは、Web スクリプト、実行可能ファイル、プラグインモジュール、ドキュメント内のマクロなど、多くの形態をとることができます。WebDAV はこれらのプログラムに関するセキュリティ上の懸念事項を変更するものではありませんが、多くの場合、WebDAV は幅広いユーザがサーバ上で文書を公開できるような文脈で使用されています。サーバーは、ドキュメントを公開している作者と密接な信頼関係を持っていないかもしれません。クライアントが任意のコンテンツを公開することを許可しているサーバは、サーバに公開されたコンテンツが他のクライアントに有害でないことを確認するための予防措置を実装することが有用です。サーバーでは、公開を許可するコンテンツの種類を制限したり、公開されたコンテンツに対してウイルスやマルウェアの検出ソフトウェアを実行したりすることで、このような対策を講じることができます。また、サーバーは、適切なアクセス制限と、サーバーへのコンテンツの公開を許可されたユーザーの認証を行うことで、リスクを軽減することができます。</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">HTTPヘッダーフィールドは、[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]で定義されているように、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt;にある「メッセージヘッダー」レジストリ内に登録されます。</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + ------------------- + ---------- + ---------- + ------- -------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- -------- + |接続| http |標準| &lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt; | |コンテンツの長さ| http |標準| &lt;a href=&quot;#section-3.3.2&quot;&gt;セクション3.3.2&lt;/a&gt; | |ホスト| http |標準| &lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt; | | TE | http |標準| &lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt; | |トレーラー| http |標準| &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt; | |転送エンコーディング| http |標準| &lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt; | |アップグレード| http |標準| &lt;a href=&quot;#section-6.7&quot;&gt;セクション6.7&lt;/a&gt; | |経由| http |標準| &lt;a href=&quot;#section-5.7.1&quot;&gt;セクション5.7.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- +さらに、HTTPヘッダーフィールドとしてその名前を使用すると、接続ヘッダーフィールドの「閉じる」接続オプションと競合する可能性があるため、ヘッダーフィールド名「Close」は「予約済み」として登録されています。 （&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）。 + ------------------- + ---------- + ---------- + ------- ------ + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + |閉じる| http |予約済み| &lt;a href=&quot;#section-8.1&quot;&gt;セクション8.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + --------------------- + ---------- + ---------- + ----- -------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + --------------------- + ---------- + ---------- + ----- -------- + |認可| http |標準| &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt; | |プロキシ認証| http |標準| &lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt; | |プロキシ認証| http |標準| &lt;a href=&quot;#section-4.4&quot;&gt;セクション4.4&lt;/a&gt;| | WWW-Authenticate | http |標準| &lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、関連するレジストリエントリは、以下の永続的な登録に従って更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）：+ ------------------- + ---------- + ---------- + ------------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + | Accept-Ranges | http |標準| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | |コンテンツ範囲| http |標準| &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt; | | If-Range | http |標準| &lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;| |範囲| http |標準| &lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、関連するレジストリエントリは、以下の永続的な登録に従って更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）：+ ------------------- -+ ---------- + ---------- + ------------- + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http |標準| &lt;a href=&quot;#section-2.3&quot;&gt;セクション2.3&lt;/a&gt; | |イフマッチ| http |標準| &lt;a href=&quot;#section-3.1&quot;&gt;セクション3.1&lt;/a&gt; | | If-Modified-Since | http |標準| &lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;| | If-None-Match | http |標準| &lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt; | | If-Unmodified-Since | http |標準| &lt;a href=&quot;#section-3.4&quot;&gt;セクション3.4&lt;/a&gt; | |最終変更| http |標準| &lt;a href=&quot;#section-2.2&quot;&gt;セクション2.2&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTPヘッダーフィールドは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt;で管理されている「メッセージヘッダー」レジストリ内に登録されます。このドキュメントでは、次のHTTPヘッダーフィールドを定義しているため、 &quot;Permanent Message Header Field Names&quot;レジストリはそれに応じて更新されています（[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]を参照）。 + ------------------- + ---------- + ---------- + ------- ------ + |ヘッダーフィールド名|プロトコル|ステータス|リファレンス| + ------------------- + ---------- + ---------- + ------- ------ + |年齢| http |標準| &lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt; | |キャッシュ制御| http |標準| &lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt; | |期限切れ| http |標準| &lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;| | プラグマ| http | 標準| &lt;a href=&quot;#section-5.4&quot;&gt;セクション5.4&lt;/a&gt; | | 警告| http | 標準| &lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ +変更コントローラは、「IETF（iesg@ietf.org）-Internet Engineering Task Force」です。</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">チャンクメッセージのトレーラー部分に存在するHTTPヘッダーフィールド。次のヘッダーフィールドは&lt;strong&gt;許可されていません&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">一般的なヘッダを含むHTTPヘッダフィールドは、（&lt;a href=&quot;#section-4.5&quot;&gt;セクション4.5&lt;/a&gt;）、リクエストヘッダ（&lt;a href=&quot;#section-5.3&quot;&gt;セクション5.3&lt;/a&gt;）、応答ヘッダ（&lt;a href=&quot;#section-6.2&quot;&gt;セクション6.2&lt;/a&gt;）、およびエンティティヘッダ（&lt;a href=&quot;#section-7.1&quot;&gt;セクション7.1&lt;/a&gt;）フィールドで与えられたものと同じ一般的なフォーマットに従う&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;セクションRFC 822の3.1&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]。各ヘッダーフィールドは、名前とそれに続くコロン（ &quot;：&quot;）およびフィールド値で構成されます。フィールド名は大文字と小文字を区別しません。フィールド値の前に任意の量のLWSを付けることができますが、単一のSPが推奨されます。ヘッダーフィールドは、追加の各行の前に少なくとも1つのSPまたはHTを付けることにより、複数行に拡張できます。 HTTP構造を生成するとき、アプリケーションは「共通の形式」に従う必要があります。これは、共通の形式以外のものを受け入れない実装が存在する可能性があるためです。メッセージヘッダー=フィールド名 &quot;：&quot; [フィールド値]フィールド名=トークンフィールド値= *（フィールドコンテンツ| LWS）フィールドコンテンツ= &amp;lt;* TEXTまたはトークン、セパレーター、引用符付き文字列の組み合わせで構成されるフィールド値を構成するOCTET&amp;gt;フィールドコンテンツには、先頭または末尾のLWSは含まれません。最初の非空白文字の前に発生する線形空白フィールド値の、またはフィールド値の最後の非空白文字の後。このような先頭または末尾のLWSは、フィールド値のセマンティクスを変更せずに削除できます。フィールドコンテンツ間で発生するすべてのLWSは、フィールド値を解釈したり、メッセージをダウンストリームに転送したりする前に、単一のSPで置き換えることができます。異なるフィールド名を持つヘッダーフィールドが受信される順序は重要ではありません。ただし、最初に一般ヘッダーフィールドを送信することは「適切な方法」です。続いてリクエストヘッダーまたはレスポンスヘッダーフィールドがあり、エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））にのみ、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。エンティティヘッダーフィールドで終わります。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））に限り、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」のペアに結合することが可能でなければなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。同じフィールド名を持つ複数のメッセージヘッダーフィールドは、そのヘッダーフィールドのフィールド値全体がコンマ区切りのリストとして定義されている場合（つまり、＃（values））にのみ、メッセージに存在する可能性があります。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」ペアに結合することが可能でなければなりません。後続の各フィールド値を最初のフィールド値にカンマで区切って追加します。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。メッセージのセマンティクスを変更せずに、複数のヘッダーフィールドを1つの「フィールド名：フィールド値」のペアに結合することが可能でなければなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。したがって、同じフィールド名を持つヘッダーフィールドが受信される順序は、結合されたフィールド値の解釈にとって重要です。したがって、プロキシは、メッセージが転送されるときにこれらのフィールド値の順序を変更してはなりません。</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">HTTPヘッダ</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">HTTPヘッダーを使用すると、クライアントとサーバーは要求または応答とともに追加情報を渡すことができます。 HTTPヘッダーは、大文字と小文字を区別しない名前と、その後に続くコロン「 &lt;code&gt;:&lt;/code&gt; 」、およびその値（改行なし）で構成されます。値の前の空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP ヘッダ、メタ要素、言語情報</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ]実装とコードを共有するHTTP実装は、MIME行の長さの制限に注意する必要があります。 HTTPにはこの制限がないため、HTTPは長い行を折り返しません。 HTTPによって転送されるMHTMLメッセージは、行の長さの制限や折りたたみ、正規化などを含むMHTMLのすべての規則に従います。これは、HTTPがメッセージ本体をペイロードとして転送するため、「multipart / byteranges」タイプは別です（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233の&lt;/a&gt;付録A ] ）、コンテンツまたはそこに含まれる可能性のあるMIMEヘッダー行を解釈しません。</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ]実装とコードを共有するHTTP実装は、MIME行の長さの制限に注意する必要があります。 HTTPにはこの制限がないため、HTTPは長い行を折り返しません。 HTTPはすべてのメッセージ本文をペイロードとして転送し（&lt;a href=&quot;#section-3.7.2&quot;&gt;セクション3.7.2を&lt;/a&gt;参照）、コンテンツやMIMEヘッダーを解釈しないため、HTTPによって転送されるMHTMLメッセージは、行の長さの制限や折りたたみ、正規化など、MHTMLのすべての規則に従います。その中に含まれる可能性のある行。</target>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTPでは、ブラウザが好みの形式、言語、またはエンコーディングを通知する方法として、 &lt;code&gt;Accept-&lt;/code&gt; で始まる一連のヘッダーが導入されています。この記事では、このアドバタイズメントがどのように発生するか、サーバーがどのように反応することが期待されるか、サーバーが最も適切な応答を選択する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP はクライアント・サーバ・プロトコルです:リクエストはユーザーエージェント(またはその代理のプロキシ)という1つのエンティティによって送信されます。ほとんどの場合、ユーザーエージェントは Web ブラウザですが、検索エンジンのインデックスを作成・維持するために Web をクロールするロボットなど、どんなものでも構いません。</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP はかなり拡張性の高いプロトコルです。リソースや URI の概念、メッセージのシンプルな構造、通信フローのためのクライアント-サーバ構造など、いくつかの基本的な概念に依存しています。これらの基本的な概念の上に、新しい HTTP メソッドやヘッダを作成することで新しい機能や新しいセマンティクスが追加され、長年にわたって多数の拡張機能が登場してきました。</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTPは、信頼できるトランスポート層またはセッション層の「接続」（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）全体でメッセージを交換することによって動作するステートレスの要求/応答プロトコル（&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）です。）。 HTTP「クライアント」は、1つ以上のHTTP要求を送信する目的でサーバーへの接続を確立するプログラムです。 HTTP「サーバー」は、HTTP応答を送信してHTTP要求を処理するために接続を受け入れるプログラムです。 「クライアント」および「サーバー」という用語は、これらのプログラムが特定の接続に対して実行する役割のみを指します。同じプログラムが一部の接続ではクライアントとして機能し、別の接続ではサーバーとして機能する場合があります。 「ユーザーエージェント」という用語は、ブラウザー、スパイダー（Webベースのロボット）、コマンドラインツール、カスタムアプリケーション、モバイルアプリ（これらに限定されない）を含む、要求を開始するさまざまなクライアントプログラムのいずれかを指します。 「元のサーバー」という用語特定のターゲットリソースに対して信頼できる応答を発信できるプログラムを指します。 「送信者」および「受信者」という用語は、それぞれ特定のメッセージを送信または受信する実装を指します。 HTTPはURI（Uniform Resource Identifier）標準に依存しています[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]ターゲットリソース（&lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1&lt;/a&gt;）とリソース間の関係を示す。メッセージは、インターネットメール[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]および多目的インターネットメール拡張（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ] で使用されるものと同様の形式で渡されます（[ RFC7231 ]の&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;付録Aを&lt;/a&gt;参照）。HTTPメッセージとMIMEメッセージの違いについて）。ほとんどのHTTP通信は、URIで識別されるリソースの表現に対する取得要求（GET）で構成されています。最も単純なケースでは、これはユーザーエージェント（UA）とオリジンサーバー（O）間の単一の双方向接続（===）を介して行われる可能性があります。リクエスト&amp;gt; UA ======================================= O &amp;lt;応答クライアントがHTTPを送信メソッド、URI、プロトコルバージョンを含むrequest-lineで始まり（&lt;a href=&quot;#section-3.1.1&quot;&gt;セクション3.1.1&lt;/a&gt;）、リクエスト修飾子、クライアント情報、表現メタデータを含むヘッダーフィールドが後に続く、リクエストメッセージの形式でサーバーにリクエストします（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、ヘッダーセクションの終わりを示す空の行、最後にペイロードボディを含むメッセージボディ（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3がある&lt;/a&gt;場合）。サーバーは、1つ以上のHTTP応答メッセージを送信することにより、クライアントの要求に応答します。各メッセージは、プロトコルバージョン、成功またはエラーコード、およびテキストの理由句（&lt;a href=&quot;#section-3.1.2&quot;&gt;セクション3.1.2&lt;/a&gt;）を含むステータス行で始まり、ヘッダーフィールドが続く場合があります。サーバー情報、リソースメタデータ、表現メタデータ（&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）、ヘッダーセクションの終わりを示す空の行、ペイロード本文を含むメッセージ本文（&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3）&lt;/a&gt;）。&lt;a href=&quot;#section-6.3&quot;&gt;セクション6.3で&lt;/a&gt;定義されているように、接続は複数の要求/応答交換に使用される場合があります。次の例は、URI &quot;http://www.example.com/hello.txt&quot; でのGETリクエスト（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]のセクション4.3.1&lt;/a&gt;）の一般的なメッセージ交換を示しています。クライアントリクエスト：GET /hello.txt HTTP /1.1 User-Agent：curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3 Host：www.example.com Accept-Language：en、miサーバーの応答：HTTP / 1.1 200 OK日付： 2009年7月27日月曜日12:28:53 GMTサーバー：Apache最終変更日：2009年7月22日水曜日19:15:56 GMT ETag： &quot;34aa387-d-1568eb00&quot; Accept-Ranges：bytes Content-Length：51 Vary： Accept-Encoding Content-Type：text / plain Hello World！ペイロードに末尾のCRLFが含まれています。</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP は使いやすい拡張可能なプロトコルです。クライアントとサーバの構造と、ヘッダを簡単に追加できる機能を組み合わせることで、HTTP はウェブの拡張機能に合わせて進化していきます。</target>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP は拡張可能</target>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTPは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同じ生成元のポリシー&lt;/a&gt;であるWebのセキュリティモデルから独立しています。実際、現在のWebセキュリティモデルは、HTTPの作成後に開発されました。長年にわたり、特定の制約の下でこのポリシーの制限の一部を解除できるようにすることで、より寛大になることができることが有用であることが証明されています。そのような制限が解除される量と時期は、新しい一連のHTTPヘッダーを使用してサーバーからクライアントに送信されます。これらは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;クロスオリジンリソースシェアリング&lt;/a&gt;（CORS）や&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;コンテンツセキュリティポリシー&lt;/a&gt;（CSP）などの仕様で定義されています。</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTPはMIME準拠のプロトコルではありません。ただし、メッセージには、メッセージの作成に使用されたMIMEプロトコルのバージョンを示す単一のMIME-Versionヘッダーフィールドを含めることができます。 MIME-Versionヘッダーフィールドの使用は、メッセージがMIMEプロトコル（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]で定義されている）に完全に準拠していることを示します。送信者は、HTTPメッセージを厳密なMIME環境にエクスポートするときに、（可能な場合）完全な準拠を保証する責任があります。</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTPはMIME準拠のプロトコルではありません。ただし、HTTP / 1.1メッセージには、メッセージの作成に使用されたMIMEプロトコルのバージョンを示す単一のMIME-Version general-headerフィールドが含まれる場合があります。 MIME-Versionヘッダーフィールドの使用は、メッセージがMIMEプロトコル（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]で定義されている）に完全に準拠していることを示します。プロキシ/ゲートウェイは、HTTPメッセージを厳密なMIME環境にエクスポートするときに、（可能な場合）完全なコンプライアンスを保証する責任があります。 MIME-Version = &quot;MIME-Version&quot; &quot;：&quot; 1 * DIGIT &quot;。&quot; 1 * DIGIT MIMEバージョン &quot;1.0&quot;は、HTTP / 1.1で使用するデフォルトです。ただし、HTTP / 1.1メッセージの解析とセマンティクスは、MIME仕様ではなく、このドキュメントで定義されています。</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTPは簡単です。</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP はステートレスですが、セッションレスではありません。</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP はステートレスです:2 つのリクエストが同じ接続上で連続して実行される間のリンクはありません。これは、例えば e コマースのショッピングバスケットを使って特定のページを一貫して操作しようとするユーザーにとっては、すぐに問題となる可能性があります。しかし、HTTP のコアはステートレスですが、HTTP クッキーはステートフルなセッションの使用を可能にします。ヘッダの拡張性を利用して、HTTP クッキーがワークフローに追加され、各 HTTP リクエストで同じコンテキストや同じ状態を共有してセッションを作成できるようになりました。</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTPは通常、応答キャッシュを使用することでパフォーマンスを向上できる分散情報システムに使用されます。このドキュメントでは、応答メッセージのキャッシュと再利用に関連するHTTP / 1.1の側面を定義します。 HTTPキャッシュは、応答メッセージのローカルストアであり、その中のメッセージの格納、取得、および削除を制御するサブシステムです。キャッシュは、将来の同等の要求での応答時間とネットワーク帯域幅の消費を削減するために、キャッシュ可能な応答を格納します。トンネルとして機能しているサーバーはキャッシュを使用できませんが、クライアントまたはサーバーはキャッシュを使用できます（MAY）。共有キャッシュは、複数のユーザーが再利用する応答を格納するキャッシュです。共有キャッシュは通常（常にではありませんが）仲介者の一部として配備されます。対照的に、プライベートキャッシュシングルユーザー専用です。多くの場合、これらはユーザーエージェントのコンポーネントとして展開されます。 HTTP / 1.1でのキャッシングの目的は、現在の要求を満たすために以前の応答メッセージを再利用することにより、パフォーマンスを大幅に改善することです。保存された応答は、「新しい」と見なされます。 &lt;a href=&quot;#section-4.2&quot;&gt;セクション4.2&lt;/a&gt;、「検証」なしで応答を再利用できる場合（キャッシュされた応答がこの要求に対して有効であるかどうかをオリジンサーバーに確認する）。したがって、新しい応答は、再利用されるたびにレイテンシとネットワークオーバーヘッドの両方を削減できます。キャッシュされた応答が最新でない場合でも、検証によって更新できる場合（&lt;a href=&quot;#section-4.3&quot;&gt;セクション4.3&lt;/a&gt;）、または発信元が使用できない場合（&lt;a href=&quot;#section-4.2.4&quot;&gt;セクション4.2.4&lt;/a&gt;）は、再利用できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTPは通常、応答キャッシュを使用することでパフォーマンスを向上できる分散情報システムに使用されます。 HTTP / 1.1プロトコルには、キャッシングを可能な限り機能させることを目的とした多数の要素が含まれています。これらの要素はプロトコルの他の側面から切り離せないため、また相互にやり取りするため、メソッド、ヘッダー、応答コードなどの詳細な説明とは別に、HTTPの基本的なキャッシングデザインを説明すると便利です。キャッシングは役に立ちませんパフォーマンスが大幅に改善されなかった場合。 HTTP / 1.1でのキャッシングの目標は、多くの場合に要求を送信する必要をなくし、他の多くの場合に完全な応答を送信する必要をなくすことです。前者は、多くの操作に必要なネットワークラウンドトリップの数を減らします。この目的のために「有効期限」メカニズムを使用します（&lt;a href=&quot;#section-13.2&quot;&gt;セクション13.2&lt;/a&gt;）。後者は、ネットワーク帯域幅の要件を軽減します。この目的のために「検証」メカニズムを使用します（&lt;a href=&quot;#section-13.3&quot;&gt;セクション13.3を&lt;/a&gt;参照））。パフォーマンス、可用性、非接続操作の要件により、セマンティックの透明性の目標を緩和できる必要があります。 HTTP / 1.1プロトコルにより、オリジンサーバー、キャッシュ、およびクライアントは、必要に応じて透過性を明示的に減らすことができます。ただし、非透過的な操作は、専門家以外のユーザーを混乱させ、特定のサーバーアプリケーション（商品の注文など）と互換性がない場合があるため、プロトコルは透過性を緩和する必要があります。クライアントまたはオリジンサーバー-キャッシュまたはクライアントによって緩和されたときにエンドユーザーに明示的な警告のみが表示されるため、HTTP / 1.1プロトコルは次の重要な要素を提供します。すべての関係者が必要とする場合に、完全なセマンティックの透過性を提供するプロトコル機能。 2.オリジンサーバーまたはユーザーエージェントが非透過的な操作を明示的に要求および制御できるようにするプロトコル機能。 3.要求されたセマンティック透明度の近似を保持しない応答にキャッシュが警告を添付できるようにするプロトコル機能。基本的な原則は、クライアントが意味の透明性の潜在的な緩和を検出できる必要があることです。注：サーバー、キャッシュ、またはクライアントの実装者は、この仕様で明示的に説明されていない設計上の決定に直面する可能性があります。決定が意味の透明性に影響を与える可能性がある場合、実装者は、慎重かつ完全な分析が透明性を破る上で重要な利点を示さない限り、透明性を維持する側で誤りを犯すべきです。</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTPは、汎用コンピュータから家電製品まで、さまざまなアプリケーションで使用されています。場合によっては、通信オプションはクライアントの構成にハードコーディングされます。ただし、ほとんどのHTTPクライアントは、汎用のWebブラウザーと同じリソース識別メカニズムと構成手法に依存しています。 HTTP通信は、何らかの目的でユーザーエージェントによって開始されます。その目的は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]で定義されている要求のセマンティクスと、それらのセマンティクスを適用するターゲットリソースの組み合わせです。 URI参照（&lt;a href=&quot;#section-2.7&quot;&gt;セクション2.7&lt;/a&gt;）は通常、「ターゲットリソース」の識別子として使用されます。ユーザーエージェントは、「ターゲットURI」を取得するためにその絶対形式に解決します。フラグメント識別子はクライアント側の処理用に予約されているため（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]、セクション3.5&lt;/a&gt;）、ターゲットURIは参照のフラグメントコンポーネントを除外します（ある場合）。</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">HTTPメッセージヘッダーは、リソース、またはサーバーやクライアントの動作を記述するために使用されます。 &lt;code&gt;X-&lt;/code&gt; プレフィックスを使用して、独自のカスタムヘッダーを追加できます。&lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANAレジストリの&lt;/a&gt;その他のもの。元のコンテンツは&lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229で&lt;/a&gt;定義されています。IANA &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;は、提案された新しいHTTPメッセージヘッダーのレジストリ&lt;/a&gt;も維持します。</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">HTTP メッセージは ASCII でエンコードされたテキスト情報で構成されており、複数行にわたっています。HTTP/1.1やそれ以前のバージョンのプロトコルでは、これらのメッセージは接続を介してオープンに送信されていました。HTTP/2では、かつては人間が読めるメッセージがHTTPフレームに分割され、最適化とパフォーマンスの向上が図られています。</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">HTTPメッセージは、サーバーとクライアント間でデータが交換される方法です。メッセージには2つのタイプがあります。サーバーからのアクションをトリガーするためにクライアントから送信される&lt;em&gt;要求&lt;/em&gt;と、サーバーからの&lt;em&gt;応答&lt;/em&gt;である応答です。</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP メッセージは HTTP を使う上で重要なものです。HTTP/2 フレーム機構は、HTTP/1.x 構文と基本的なトランスポートプロトコルの間に新しい中間層を追加しますが、根本的に変更することはありません。</target>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">HTTPメッセージは、クライアントからサーバーへの要求とサーバーからクライアントへの応答で構成されます。HTTPメッセージ=リクエスト| 応答; HTTP / 1.1メッセージの要求（&lt;a href=&quot;#section-5&quot;&gt;セクション5&lt;/a&gt;）および応答（&lt;a href=&quot;#section-6&quot;&gt;セクション6&lt;/a&gt;）メッセージは、&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]エンティティ（メッセージのペイロード）を転送します。どちらのタイプのメッセージも、開始行、0個以上のヘッダーフィールド（「ヘッダー」とも呼ばれます）、ヘッダーフィールドの終わりを示す空の行（CRLFの前に何もない行）、および場合によってはメッセージ本文。 generic-message = start-line *（message-header CRLF）CRLF [message-body] start-line = Request-Line | Status-Line堅牢性のために、サーバーは、Request-Lineが期待される場所で受信された空の行を無視する必要があります（SHOULD）。つまり、サーバーがメッセージの先頭でプロトコルストリームを読み取り、最初にCRLFを受信した場合、そのCRLFを無視する必要があります。特定のバグのあるHTTP / 1。0クライアントの実装では、POST要求の後に追加のCRLFが生成されます。 BNFによって明示的に禁止されていることを再説明するために、HTTP / 1.1クライアントは、追加のCRLFを使用して要求の前置または後続してはなりません。</target>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">HTTPメッセージングは​​、基になるトランスポート層またはセッション層の接続プロトコルには依存しません。 HTTPは、要求の順序どおりの配信と対応する応答の順序どおりの配信を伴う信頼性の高いトランスポートのみを前提としています。 HTTPリクエストおよびレスポンス構造の、基盤となるトランスポートプロトコルのデータユニットへのマッピングは、この仕様の範囲外です。&lt;a href=&quot;#section-5.2&quot;&gt;セクション5.2&lt;/a&gt;で説明されているように、HTTP対話に使用される特定の接続プロトコルは、クライアント構成とターゲットURIによって決定されます。たとえば、「http」URIスキーム（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）は、TCP over IPのデフォルト接続を示し、デフォルトのTCPポートは80ですが、クライアントは他の接続、ポート、またはプロトコルを介してプロキシを使用するように構成されている場合があります。 HTTP実装は、現在の接続の状態の維持、新しい接続の確立または既存の接続の再利用、接続で受信したメッセージの処理、接続障害の検出、各接続のクローズなどの接続管理に従事することが期待されます。ほとんどのクライアントは、サーバーエンドポイントごとに複数の接続を含め、複数の接続を並行して維持します。ほとんどのサーバーは、リクエストキューを制御してフェアユースを可能にし、サービス拒否攻撃を検出する一方で、数千の同時接続を維持するように設計されています。</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTPメソッドの登録には、次のフィールドを含める必要があります。oメソッド名（&lt;a href=&quot;#section-4&quot;&gt;セクション4を&lt;/a&gt;参照）o安全（ &quot;yes&quot;または &quot;no&quot;、&lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1を&lt;/a&gt;参照）oべき等（ &quot;yes&quot;または &quot;no&quot;、&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2を&lt;/a&gt;参照））o仕様テキストへのポインターこの名前空間に追加される値には、IETFレビューが必要です（ &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]、セクション4.1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTPメソッド</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP は、クライアントとサーバ間の接続を提供するトランスポートプロトコルとして、ほとんどの場合 TCP に依存しています。初期の頃、HTTP はこのような接続を処理するために単一のモデルを使用していました。これらの接続は短命でした。リクエストを送信するたびに新しい接続が作成され、応答を受信したら閉じます。</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP パイプライン</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">最近のブラウザでは、HTTP パイプラインはデフォルトでは有効になっていません。</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTPは、サーバーがクライアント要求にチャレンジし、クライアントが認証情報を提供するために使用できる、拡張可能なチャレンジ/レスポンス認証スキームのセットを介して、アクセス制御と認証のための一般的なフレームワークを提供します。このドキュメントでは、「Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]で定義されたアーキテクチャの観点から、HTTP / 1.1認証を定義します。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]、および「ハイパーテキスト転送プロトコル&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;-HTTP&lt;/a&gt; / 1.1」[ RFC2616 ]で以前に定義された関連フィールドおよびステータスコード。IANA認証方式レジストリ（ &lt;a href=&quot;#section-5.1&quot;&gt;セクション5.1）&lt;/a&gt;）は、以前に&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617で&lt;/a&gt;定義された「基本」および「ダイジェスト」認証スキームを含む、登録済み認証スキームとそれらに対応する仕様をリストしています。</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTPは、アクセス制御と認証のための一般的なフレームワークを提供します。最も一般的な HTTP 認証は、「基本」スキーマに基づいています。このページでは、認証のためのHTTPフレームワークの紹介と、HTTP &quot;Basic &quot;スキーマを使用してサーバへのアクセスを制限する方法を示します。</target>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTPはシンプルなチャレンジ/レスポンス認証フレームワークを提供します。これは、サーバーがクライアント要求にチャレンジするために使用でき、クライアントが認証情報を提供するために使用できます。認証方式を識別する手段として大文字と小文字を区別しないトークンを使用し、その後、その方式で認証を行うために必要な追加情報が続きます。後者は、コンマで区切られたパラメーターのリスト、またはbase64でエンコードされた情報を保持できる単一の文字シーケンスのいずれかです。認証パラメーターは名前=値のペアであり、名前トークンは大文字と小文字を区別せずに照合され、各パラメーター名はチャレンジごとに1回だけ出現する必要があります。 auth-scheme =トークンauth-param =トークンBWS &quot;=&quot;BWS（token / quoted-string）token68 = 1 *（ALPHA / DIGIT / &quot;-&quot; / &quot;。&quot; / &quot;_&quot; / &quot;〜&quot; / &quot;+&quot; / &quot;/&quot;）* &quot;=&quot; token68構文では、 66の予約されていないURI文字（[&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]）とその他のいくつかの機能により、base64、base64url（URLとファイル名の安全なアルファベット）、base32、またはbase16（16進数）エンコーディングを保持できます。パディングあり、またはパディングなしで、空白は除きます（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]）。要求されたリソースに適用可能なチャレンジを少なくとも1つ含むWWW-Authenticateヘッダーフィールドを含む、ユーザーエージェントの承認を要求するために、オリジンサーバーは401（無許可）応答メッセージを使用します。 407（Proxy Authentication Required）応答メッセージは、要求されたリソースのプロキシに適用可能な少なくとも1つのチャレンジを含むProxy-Authenticateヘッダーフィールドを含む、クライアントの承認を要求するためにプロキシによって使用されます。 challenge = auth-scheme [1 * SP（token68 /＃auth-param）]注：多くのクライアントは、不明なスキームを含むチャレンジの解析に失敗します。この問題の回避策は、サポートされているスキーム（「基本」など）を最初にリストすることです。オリジンサーバーで自身を認証したいユーザーエージェント-通常、必須ではありませんが、401（Unauthorized）を受け取った後、リクエストにAuthorizationヘッダーフィールドを含めることでそれを行うことができます。 407（プロキシ認証が必要）を受信した後、通常は、プロキシで認証することを希望するクライアントは、リクエストにProxy-Authorizationヘッダーフィールドを含めることで認証できます。 Authorizationフィールド値とProxy-Authorizationフィールド値の両方に、応答で受信したチャレンジ（おそらく過去のある時点）に基づいて、要求されているリソースのレルムに対するクライアントの資格情報が含まれています。それらの値を作成するとき、ユーザーエージェントは、それが理解する最も安全な認証方式であると考えるものを使用してチャレンジを選択し、必要に応じてユーザーから資格情報を取得することによって、それを行う必要があります。ヘッダーフィールド値内の資格情報の送信は、基本的な接続の機密性に関する重要なセキュリティ上の考慮事項を意味します。&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;。 credentials = auth-scheme [1 * SP（token68 /＃auth-param）]資格情報を省略し、無効な資格情報（たとえば、不正なパスワード）または部分的な資格情報（たとえば、スキームは複数のラウンドトリップを必要とします）、オリジンサーバーは、要求されたリソースに適用可能な少なくとも1つの（おそらく新しい）チャレンジを含むWWW-Authenticateヘッダーフィールドを含む401（無許可）応答を送信する必要があります（SHOULD）。同様に、プロキシ資格情報を省略したり、無効または部分的なプロキシ資格情報を含む要求を受信すると、認証を必要とするプロキシは、少なくとも1つ（おそらく新しい）のProxy-Authenticateヘッダーフィールドを含む407（Proxy Authentication Required）応答を生成する必要があります（SHOULD）。プロキシに適用可能なチャレンジ。アクセスを取得するのに適切ではない有効な資格情報を受信するサーバーは、403（禁止）ステータスコード（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;[RFC7231]のセクション6.5.3&lt;/a&gt;）。 HTTPは、アプリケーションをアクセス認証のためのこの単純なチャレンジ/レスポンスフレームワークに制限しません。トランスポートレベルでの認証やメッセージのカプセル化による認証など、追加のメカニズムを使用したり、追加のヘッダーフィールドで認証情報を指定したりできます。ただし、このような追加のメカニズムは、この仕様では定義されていません。</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTPはいくつかのオプションのチャレンジ/レスポンス認証メカニズムを提供します。これはサーバーがクライアント要求にチャレンジするために使用でき、クライアントが認証情報を提供するために使用できます。アクセス認証の一般的なフレームワーク、および「基本」および「ダイジェスト」認証の仕様は、「HTTP認証：基本およびダイジェストアクセス認証」[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]で指定されています。この仕様では、その仕様からの「チャレンジ」と「クレデンシャル」の定義を採用しています。</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">HTTP 範囲リクエストでは、サーバからクライアントに HTTP メッセージの一部のみを送信することができます。部分的なリクエストは、大きなメディアや一時停止や再開機能のあるファイルのダウンロードなどに便利です。</target>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">HTTPのリダイレクトは、送信されたページすらないときには必ず最初に実行されますし、もちろん読み込みもしません。</target>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">HTTPリダイレクトはリダイレクトを作成するための推奨される方法ですが、Web開発者がサーバーを制御できないか、サーバーを構成できない場合があります。これらの特定のケースでは、Web開発者は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素と、ページの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;refresh&lt;/code&gt; に設定された &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 属性を使用してHTMLページを作成できます。ページを表示すると、ブラウザはこの要素を見つけて、指定されたページに移動します。</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">HTTPリダイレクトは、リダイレクトを定義する唯一の方法ではありません。他に2つの方法があり&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;ます&lt;/a&gt;。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;要素を使用するHTMLリダイレクトと、DOMを使用するJavaScriptリダイレクトです。</target>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">ウィキペディアのHTTP参照元</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTPは、信頼できる応答の概念に依存しています。つまり、ターゲットURI内で識別された（またはその方向で）権限によって、その時点でターゲットリソースの状態が与えられた要求に最も適した応答であると判断された応答です。応答メッセージの発信。共有キャッシュなどの信頼できないソースからの応答を提供することは、多くの場合、パフォーマンスと可用性を向上させるのに役立ちますが、ソースが信頼できるか、信頼できない応答を安全に使用できる場合に限られます。残念ながら、権限の確立は難しい場合があります。たとえば、フィッシングは、ユーザーの権限に対する認識に対する攻撃であり、ハイパーテキストで同様のブランドを提示することにより、その認識を誤解させることができます。userinfoが権限コンポーネントを難読化することで支援される可能性があります（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）。ユーザーエージェントは、ユーザーがアクションを実行する前にターゲットURIを簡単に検査できるようにし、存在する場合はユーザー情報を目立つように区別（または拒否）し、参照ドキュメントがからのものである場合は保存された資格情報とCookieを送信しないことで、フィッシング攻撃の影響を軽減できます。不明または信頼できないソース。登録された名前が権限コンポーネントで使用される場合、「http」URIスキーム（&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）ユーザーのローカルの名前解決サービスに依存して、信頼できる応答を見つけることができる場所を決定します。つまり、ユーザーのネットワークホストテーブル、キャッシュされた名前、または名前解決ライブラリへの攻撃は、権限の確立に対する攻撃の手段となります。同様に、ドメインネームサービス（DNS）用のユーザーのサーバーの選択、およびサーバーが解決結果を取得するサーバーの階層は、アドレスマッピングの信頼性に影響を与える可能性があります。 DNSセキュリティ拡張機能（DNSSEC、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ]）は、信頼性を向上させる1つの方法です。さらに、IPアドレスが取得された後、「http」URIの認証局を確立することは、インターネットプロトコルルーティングに対する攻撃に対して脆弱です。 「https」スキーム（&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt;）ネゴシエートされたTLS接続が保護され、クライアントが通信しているサーバーのIDがターゲットURIのオーソリティコンポーネントと一致することをクライアントが適切に検証する場合（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]を参照）、オーソリティの確立に対するこれらの潜在的な攻撃の多くを防止（または少なくとも明らかに）することを目的としています。このような検証を正しく実装することは難しい場合があります（[ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt; ]を参照）。</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTPは、必要なときにメッセージの機密性を提供するために、基礎となるトランスポートプロトコルに依存しています。HTTPは、トランスポートプロトコルに依存しないように特別に設計されており、さまざまな形式の暗号化接続で使用でき、そのようなトランスポートの選択は、URIスキームの選択またはユーザーエージェント構成内で識別されます。「https」スキームは、&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2で&lt;/a&gt;説明されているように、機密接続が必要なリソースを識別するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTPリクエストメッセージのルーティングは、ターゲットリソース、クライアントのプロキシ設定、およびインバウンド接続の確立または再利用に基づいて、各クライアントによって決定されます。対応する応答のルーティングは、クライアントに戻る同じ接続チェーンに従う。</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTTP要求方式</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP要求は、サーバーでアクションを開始するためにクライアントによって送信されるメッセージです。彼らの&lt;em&gt;スタートライン&lt;/em&gt;は3つの要素を含みます：</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP のリクエストとレスポンスは、似たような構造を共有しており、構成されています。</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP レスポンスコードは、特定の HTTP リクエストが正常に完了したかどうかを示します。レスポンスは 5 つのクラスに分類されます:情報応答、成功した応答、リダイレクト、クライアントエラー、サーバエラー。</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP応答ヘッダーフィールドは、オリジンのレポートエンドポイントを格納するようにユーザーエージェントに指示します。</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP レスポンスステータスコード</target>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP応答ステータスコードは、特定の&lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt;要求が正常に完了したかどうかを示します。応答は、情報応答、成功応答、リダイレクト、クライアントエラー、サーバーエラーの5つのクラスにグループ化されます。ステータスコードは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;、RFC 2616のセクション10で&lt;/a&gt;定義されています。</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">条件付きまたは無条件のGETメソッドを使用するHTTP取得リクエストは、リクエストの結果として返されたエンティティに適用されるRangeリクエストヘッダーを使用して、エンティティ全体ではなく、エンティティの1つ以上のサブ範囲をリクエストできます：Range = &quot;Range &quot;&quot;： &quot;ranges-specifierサーバーはRangeヘッダーを無視してもよい（MAY）。ただし、範囲は部分的に失敗した転送からの効率的な回復をサポートし、大きなエンティティの効率的な部分的な取得をサポートするため、HTTP / 1.1オリジンサーバーと中間キャッシュは、可能な場合はバイト範囲をサポートする必要があります。サーバーがRangeヘッダーをサポートし、指定された1つまたは複数の範囲がエンティティに適している場合：-無条件のGETにRangeヘッダーが存在すると、GETが成功した場合に返されるものが変更されます。つまり、応答には200（OK）ではなく206（Partial Content）のステータスコードが含まれます。 -条件付きGET（If-Modified-SinceとIf-None-Matchの一方または両方、またはIf-Unmodified-SinceとIf-Matchの一方または両方を使用する要求）にRangeヘッダーが存在すると、返されるものが変更されますGETが成功し、条件が真の場合。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（または、If-Unmodified-SinceとIf-Matchのいずれかまたは両方が、GETが成功し、条件がtrueの場合に返される内容を変更します。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（または、If-Unmodified-SinceとIf-Matchのいずれかまたは両方が、GETが成功し、条件がtrueの場合に返される内容を変更します。条件がfalseの場合に返される304（Not Modified）応答には影響しません。場合によっては、If-Rangeヘッダーを使用する方が適切な場合があります（&lt;a href=&quot;#section-14.27&quot;&gt;セクション14.27&lt;/a&gt;）とRangeヘッダーに加えて。範囲をサポートするプロキシが範囲要求を受信し、その要求を受信サーバーに転送し、応答としてエンティティ全体を受信する場合、要求された範囲のみをクライアントに返す必要があります（SHOULD）。キャッシュ割り当てポリシーと一致する場合は、受信した応答全体をキャッシュに格納する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTPステータス：&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP トンネリング</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTPは、オープンで拡張可能なデータタイプとタイプネゴシエーションを提供するために、Content-Type（&lt;a href=&quot;#section-14.17&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;）およびAccept（&lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt;）ヘッダーフィールドでインターネットメディアタイプ[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]を使用します。メディアタイプ=タイプ &quot;/&quot;サブタイプ*（ &quot;;&quot;パラメータ）タイプ=トークンサブタイプ=トークンパラメータは、タイプ/サブタイプの後に属性/値のペアの形式で続くことができます（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6で&lt;/a&gt;定義））。タイプ、サブタイプ、およびパラメーターの属性名では、大文字と小文字は区別されません。パラメータ名のセマンティクスに応じて、パラメータ値は大文字と小文字を区別する場合としない場合があります。タイプとサブタイプの間、または属性とその値の間では線形空白（LWS）を使用してはなりません（MUST NOT）。メディアタイプレジストリ内の定義によっては、パラメータの有無がメディアタイプの処理にとって重要になる場合があります。一部の古いHTTPアプリケーションはメディアタイプパラメータを認識しないことに注意してください。古いHTTPアプリケーションにデータを送信する場合、実装では、そのタイプ/サブタイプの定義で必要な場合にのみメディアタイプパラメータを使用する必要があります（SHOULD）。メディアタイプの値は、Internet Assigned Number Authority（IANA [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]）。メディアタイプ登録プロセスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]で概説されています。登録されていないメディアタイプの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTPは、Content-Type（&lt;a href=&quot;#section-3.1.1.5&quot;&gt;セクション3.1.1.5&lt;/a&gt;）およびAccept（&lt;a href=&quot;#section-5.3.2&quot;&gt;セクション5.3.2&lt;/a&gt;）でインターネットメディアタイプ[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]を使用します。）ヘッダーフィールド。オープンで拡張可能なデータタイプとタイプネゴシエーションを提供します。メディアタイプは、データ形式とさまざまな処理モデルの両方を定義します。つまり、受信した各コンテキストに従ってデータを処理する方法です。 media-type = type &quot;/&quot; subtype *（OWS &quot;;&quot; OWS parameter）type = token subtype = token type / subtypeの後には、name = valueペアの形式のパラメータが続く場合があります。 parameter = token &quot;=&quot;（token / quoted-string）タイプ、サブタイプ、およびパラメータ名のトークンは、大文字と小文字を区別しません。パラメータ名のセマンティクスに応じて、パラメータ値は大文字と小文字を区別する場合としない場合があります。パラメータの有無は、メディアタイプの処理にとって重要な場合があります。メディアタイプレジストリ内の定義に応じて。トークンの生成と一致するパラメーター値は、トークンとして、または引用文字列内で送信できます。引用符で囲まれた値と引用符で囲まれていない値は同等です。たとえば、次の例はすべて同等ですが、一貫性を保つために最初の例が推奨されます：text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html ; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。ただし、一貫性を保つために最初のものが推奨されます。text/ html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。ただし、一貫性を保つために最初のものが推奨されます。text/ html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot; text / html; charset = &quot;utf-8&quot;インターネットメディアタイプは、[で定義されている手順に従ってIANAに登録する必要があります。&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]。注：他のヘッダーフィールドのいくつかの同様の構成要素とは異なり、メディアタイプパラメーターでは、「=」文字の前後に空白（「悪い」空白であっても）を使用できません。</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTPは &quot;&amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&quot;番号付けスキームを使用して、プロトコルのバージョンを示します。この仕様はバージョン「1.1」を定義しています。全体としてのプロトコルバージョンは、送信者がそのバージョンの対応するHTTP仕様で規定されている一連の要件に準拠していることを示します。 HTTPメッセージのバージョンは、メッセージの最初の行のHTTP-versionフィールドで示されます。 HTTPバージョンでは大文字と小文字が区別されます。 HTTP-version = HTTP-name &quot;/&quot; DIGIT &quot;。&quot; DIGIT HTTP-name =％x48.54.54.50; 「HTTP」、大文字と小文字を区別HTTPバージョン番号は、「。」で区切られた2つの10進数で構成されます。 （ピリオドまたは小数点）。最初の数字（「メジャーバージョン」）は、HTTPメッセージング構文を示します。一方、2番目の数字（「マイナーバージョン」）は、送信者が準拠し、将来の通信のために理解できるメジャーバージョン内の最高のマイナーバージョンを示します。マイナーバージョンは、送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、送信者の通信機能をアドバタイズします。これにより、より高度な機能が応答（サーバー）または将来の要求（クライアント）で使用できることを受信者に通知します。 。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、通信機能。これにより、受信者は、より高度な機能を応答（サーバー）または将来の要求（クライアント）で使用できることを認識できます。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[送信者がプロトコルの下位互換性のあるサブセットのみを使用している場合でも、通信機能。これにより、受信者は、より高度な機能を応答（サーバー）または将来の要求（クライアント）で使用できることを認識できます。 HTTP / 1.1メッセージがHTTP / 1.0受信者に送信される場合[&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]またはバージョンが不明な受信者である場合、HTTP / 1.1メッセージは、新しい機能がすべて無視された場合に有効なHTTP / 1.0メッセージとして解釈されるように構築されます。この仕様では、受信者バージョンの要件をいくつかの新機能に課しているため、構成またはメッセージの受信を通じて、受信者がHTTP / 1.1をサポートしていると判断するまで、適合送信者は互換機能のみを使用します。ヘッダーフィールドの解釈は、同じメジャーHTTPバージョンのマイナーバージョン間では変わりませんが、そのようなフィールドがない場合の受信者のデフォルトの動作は変わる可能性があります。特に明記されていない限り、HTTP / 1.1で定義されているヘッダーフィールドは、HTTP / 1.xのすべてのバージョンに対して定義されています。特に、HostおよびConnectionヘッダーフィールドは、HTTP / 1.1への準拠をアドバタイズするかどうかに関係なく、すべてのHTTP / 1.x実装によって実装される必要があります。定義されたセマンティクスにより、それらを認識しない受信者が安全に無視できる場合、プロトコルバージョンを変更せずに新しいヘッダーフィールドを導入できます。ヘッダーフィールドの拡張性については、&lt;a href=&quot;#section-3.2.1&quot;&gt;セクション3.2.1&lt;/a&gt;。 HTTPメッセージを処理する仲介者（つまり、トンネルとして機能する仲介者以外のすべての仲介者）は、転送されたメッセージで独自のHTTPバージョンを送信する必要があります。つまり、メッセージのプロトコルバージョンが、メッセージの受信と送信の両方で仲介者が準拠しているバージョンと一致していることを確認せずに、HTTPメッセージの最初の行を盲目的に転送することはできません。 HTTPバージョンを書き換えずにHTTPメッセージを転送すると、ダウンストリーム受信者がメッセージ送信者のバージョンを使用して、その送信者と後で通信するために安全に使用できる機能を判断するときに、通信エラーが発生する可能性があります。クライアントは、クライアントが準拠している最高バージョンに等しいリクエストバージョンを送信する必要があります（SHOULD）。そのメジャーバージョンは、サーバーでサポートされている最高バージョン（既知の場合）以下です。クライアントは、準拠していないバージョンを送信してはなりません（MUST NOT）。サーバーが誤ってHTTP仕様を実装していることがわかっている場合、クライアントはより低い要求バージョンを送信できますが、クライアントが少なくとも1つの通常の要求を試み、応答ステータスコードまたはヘッダーフィールド（例：サーバー）からサーバーは、より高いリクエストバージョンを不適切に処理します。サーバーは、サーバーが準拠している最も高いバージョンに等しい応答バージョンを送信する必要があります（SHOULDは、要求で受信したメジャーバージョン以下のメジャーバージョンを持っています）。サーバーは、準拠していないバージョンを送信してはなりません（MUST NOT）。サーバーは、何らかの理由でクライアントのメジャープロトコルバージョンのサービスを拒否したい場合は、505（HTTPバージョンはサポートされていません）応答を送信できます。クライアントがHTTP仕様を誤って実装していて、クライアントがバージョン番号を正しく解析できない場合や、クライアントがバージョン番号を正しく解析できない場合など、後のバージョンの応答を正しく処理できないことがわかっているか疑われる場合、サーバーは要求にHTTP / 1.0応答を送信できます（MAY）仲介者は、指定されたマイナーバージョンのプロトコルに準拠していない場合でも、HTTPバージョンを盲目的に転送することが知られています。そのようなプロトコルのダウングレードは、1つ以上のリクエストヘッダーフィールド（たとえば、User-Agent）は、エラーのあることがわかっているクライアントから送信された値と一意に一致します。 HTTPのバージョン管理設計の意図は、互換性のないメッセージ構文が導入された場合にのみメジャー番号が増分されること、およびプロトコルに加えられた変更がメッセージセマンティクスに追加または追加を示唆する効果を持つ場合にのみマイナー番号が増分されることです。送信者の機能。ただし、マイナーバージョンは、[そして、マイナー番号は、プロトコルに加えられた変更がメッセージの意味に追加する、または送信者の追加機能を示唆する効果を持つ場合にのみ増加します。ただし、マイナーバージョンは、[そして、マイナー番号は、プロトコルに加えられた変更がメッセージの意味に追加する、または送信者の追加機能を示唆する効果を持つ場合にのみ増加します。ただし、マイナーバージョンは、[&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ]と[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、およびこの改訂では、プロトコルに対するこのような変更は特に回避されています。受信者が実装するメジャーバージョン番号を含むHTTPメッセージが受信されたが、受信者が実装するものよりも大きいマイナーバージョン番号である場合、受信者は、そのメジャーバージョンの中で最も高いマイナーバージョンであるかのようにメッセージを処理する必要があります（SHOULD）。受信者は適合しています。受信者は、より高いマイナーバージョンのメッセージが、そのより高いバージョンのサポートをまだ示していない受信者に送信された場合、同じメジャーバージョンの実装で安全に処理できるように十分な下位互換性があると想定できます。</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTPは &quot;&amp;lt;major&amp;gt;。&amp;lt;minor&amp;gt;&quot;番号付けスキームを使用して、プロトコルのバージョンを示します。プロトコルのバージョン管理ポリシーは、送信者がメッセージの形式と、HTTP通信を介して取得される機能ではなく、HTTP通信をさらに理解するための容量を示すことを目的としています。通信動作に影響を与えない、または拡張可能なフィールド値のみを追加するメッセージコンポーネントを追加しても、バージョン番号は変更されません。 &amp;lt;マイナー&amp;gt;番号は、プロトコルに加えられた変更により、一般的なメッセージ解析アルゴリズムを変更しない機能が追加された場合に増加しますが、メッセージのセマンティクスに追加され、送信者の追加機能を意味する場合があります。 &amp;lt;メジャー&amp;gt;プロトコル内のメッセージのフォーマットが変更されると、番号が増加します。見る&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]詳細な説明については。 HTTPメッセージのバージョンは、メッセージの最初の行のHTTP-Versionフィールドで示されます。 HTTP-Version = &quot;HTTP&quot; &quot;/&quot; 1 * DIGIT &quot;。&quot; 1 * DIGITメジャー番号とマイナー番号は別々の整数として扱われる必要があり、各桁が1桁より大きくなる場合があることに注意してください。したがって、HTTP / 2.4はHTTP / 2.13よりも下位のバージョンであり、HTTP / 2.13はHTTP / 12.3よりも下位です。先行ゼロは受信者によって無視されなければならず、送信されてはなりません。 「HTTP / 1.1」のHTTPバージョンを含む要求または応答メッセージを送信するアプリケーションは、少なくともこの条件に条件付きで準拠している必要があります。この仕様に少なくとも条件付きで準拠しているアプリケーションは、「HTTP / 1.1」のHTTPバージョンを使用する必要があります（SHOULD）。メッセージで、HTTP / 1.0と互換性のないすべてのメッセージに対してそのようにする必要があります。特定のHTTP-Version値を送信するタイミングの詳細については、を参照してください。&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]。アプリケーションのHTTPバージョンは、アプリケーションが少なくとも条件付きで準拠している最も高いHTTPバージョンです。プロキシおよびゲートウェイアプリケーションは、アプリケーションのプロトコルバージョンとは異なるプロトコルバージョンでメッセージを転送する場合は注意が必要です。プロトコルバージョンは送信者のプロトコル機能を示すため、プロキシ/ゲートウェイは、実際のバージョンよりも大きいバージョンインジケータを含むメッセージを送信してはなりません（MUST NOT）。より高いバージョンのリクエストを受信した場合、プロキシ/ゲートウェイは、リクエストのバージョンをダウングレードするか、エラーで応答するか、トンネルの動作に切り替える必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33の&lt;/a&gt;公開以降に発見されたHTTP / 1.0プロキシとの相互運用性の問題のため]、キャッシングプロキシは、MUST、ゲートウェイはMAY、トンネルは、サポートする最新バージョンにリクエストをアップグレードしてはなりません（MUST NOT）。そのリクエストに対するプロキシ/ゲートウェイの応答は、リクエストと同じメジャーバージョンである必要があります。注：HTTPのバージョン間の変換には、関連するバージョンで必要または禁止されているヘッダーフィールドの変更が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTPは文字セット名を使用して、テキスト表現の文字エンコーディングスキームを示したり、ネゴシエートしたりします[ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]。文字セットは、大文字と小文字を区別しないトークンによって識別されます。charset =トークン文字セット名は、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]で定義されている手順に従って、IANAの「文字セット」レジストリ（&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;）に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTPは、MIMEについて説明したものと同じ「文字セット」という用語の定義を使用します。このドキュメントでは、「文字セット」という用語は、1つまたは複数のテーブルで使用され、オクテットのシーケンスを文字。すべての文字が特定の文字セットで使用できるわけではなく、文字セットが特定の文字を表すオクテットの複数のシーケンスを提供する場合があるため、逆方向の無条件変換は必要ありません。この定義は、US-ASCIIなどの単純な単一テーブルマッピングからISO-2022の手法を使用するような複雑なテーブルスイッチング方法まで、さまざまな種類の文字エンコーディングを可能にすることを目的としています。しかしながら、MIME文字セット名に関連付けられた定義では、オクテットから文字へのマッピングを完全に指定する必要があります。特に、正確なマッピングを決定するための外部プロファイリング情報の使用は許可されていません。注：この「文字セット」という用語の使用法は、より一般的には「文字エンコーディング」と呼ばれています。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[より一般的には「文字エンコーディング」と呼ばれます。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[より一般的には「文字エンコーディング」と呼ばれます。ただし、HTTPとMIMEは同じレジストリを共有するため、用語も共有することが重要です。 HTTP文字セットは、大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セットレジストリ[&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]。 charset = token HTTPでは任意のトークンを文字セット値として使用できますが、IANA文字セットレジストリ[ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 内に事前定義された値を持つトークンは、そのレジストリで定義された文字セットを表す必要があります。アプリケーションは、文字セットの使用をIANAレジストリで定義されているものに制限する必要があります（SHOULD）。実装者は、IETF文字セットの要件を認識する必要があります[ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP は World Wide Web (WWW)アーキテクチャのために作られ、世界的なハイパーテキストシステムのスケーラビリティのニーズをサポートするために時間をかけて進化してきました。そのアーキテクチャの多くは、HTTP を定義するために使用される用語や構文に反映されています。</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP は 1990 年代初頭に作られ、何度か拡張されてきました。この記事では、その歴史を辿り、HTTP/0.9、HTTP/1.0、HTTP/1.1、そして現代のHTTP/2と、その間に導入されたマイナーな新機能について説明します。</target>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP が最初に規定されたのは 1990 年代初頭のことです。拡張性を念頭に置いて設計されていますが、何年にもわたって何度も追加されてきました。このページでは、HTTP に関連するリソースをリストアップしています。</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">エラー処理に対するHTTPのアプローチについて説明しました。 （&lt;a href=&quot;#section-2.5&quot;&gt;セクション2.5&lt;/a&gt;）HTTPバージョンのABNFプロダクションでは、大文字と小文字が区別されることが明確になっています。さらに、実装は複数桁のバージョン番号を誤って処理することが知られているため、バージョン番号は1桁に制限されています。 （&lt;a href=&quot;#section-2.6&quot;&gt;2.6節&lt;/a&gt;）HTTPとHTTPSのURIで、ユーザー情報（つまり、ユーザー名とパスワード）は、ネットワーク上での送信に関連するセキュリティ問題のため、許可されなくなりました。 （&lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt;）HTTPS URIスキームがこの仕様で定義されるようになりました。以前は、&lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;[RFC2818]のセクション2.4で&lt;/a&gt;行われていました。さらに、エンドツーエンドのセキュリティを意味します。 （&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt;）HTTPメッセージは、実装によってバッファリングできます（多くの場合、バッファリングされます）。ストリームとして利用できることもありますが、HTTPは基本的にメッセージ指向プロトコルです。相互運用性を向上させるために、さまざまなプロトコル要素でサポートされる最小サイズが提案されています。 （&lt;a href=&quot;#section-3&quot;&gt;セクション3&lt;/a&gt;）フィールド名を囲む無効な空白は、受け入れるとセキュリティの脆弱性を表すため、拒否する必要があります。ヘッダーフィールドを定義するABNFプロダクションは、フィールド値のみをリストするようになりました。 （&lt;a href=&quot;#section-3.2&quot;&gt;セクション3.2&lt;/a&gt;）特定の文法プロダクション間の暗黙的な線形空白に関するルールが削除されました。現在、空白は、ABNFで明確に定義されている場合にのみ許可されます。 （&lt;a href=&quot;#section-3.2.3&quot;&gt;セクション3.2.3&lt;/a&gt;）複数の行にまたがるヘッダーフィールド（「行の折り返し」）は非推奨になりました。 （&lt;a href=&quot;#section-3.2.4&quot;&gt;セクション3.2.4&lt;/a&gt;）NULオクテットはコメントおよび引用符付きテキストで許可されなくなり、バックスラッシュエスケープの取り扱いが明確になりました。クォートペアルールでは、HTAB以外の制御文字をエスケープすることはできなくなりました。ヘッダーフィールドのUS-ASCII以外のコンテンツと理由フレーズが廃止され、不透明になりました（TEXTルールは削除されました）。 （&lt;a href=&quot;#section-3.2.6&quot;&gt;セクション3.2.6&lt;/a&gt;）偽のContent-Lengthヘッダーフィールドは、受信者によってエラーとして処理される必要があります。 （&lt;a href=&quot;#section-3.3.2&quot;&gt;セクション3.3.2&lt;/a&gt;）メッセージ本文の長さを決定するためのアルゴリズムが明確になり、それに影響するすべての特殊なケース（たとえば、メソッドまたはステータスコードによって駆動される）を示し、新しいプロトコル要素はそのような特殊なケースを定義できません。 CONNECTは、メッセージ本文の長さを決定する際の新しい特別なケースです。 「multipart / byteranges」は、メッセージ本文の長さの検出を決定する方法ではなくなりました。 （&lt;a href=&quot;#section-3.3.3&quot;&gt;セクション3.3.3&lt;/a&gt;）「ID」転送コーディングトークンが削除されました。 （セクション&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; および4）チャンク長には、チャンクヘッダーとトレーラーのオクテットの数は含まれません。チャンク拡張での行折りたたみは許可されていません。 （&lt;a href=&quot;#section-4.1&quot;&gt;セクション4.1&lt;/a&gt;）「deflate」コンテンツコーディングの意味が明確になりました。 （&lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt;）&lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;のabs_pathの代わりに、&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;のセグメント+クエリコンポーネントを使用して要求ターゲットを定義しました。 request-targetのアスタリスク形式は、OPTIONSメソッドでのみ使用できます。 （&lt;a href=&quot;#section-5.3&quot;&gt;5.3項&lt;/a&gt;）「Effective Request URI」という用語が導入されました。 （&lt;a href=&quot;#section-5.5&quot;&gt;セクション5.5&lt;/a&gt;）ゲートウェイは、Viaヘッダーフィールドを生成する必要がなくなりました。 （&lt;a href=&quot;#section-5.7.1&quot;&gt;セクション5.7.1&lt;/a&gt;）「閉じる」接続オプションを送信する必要がある正確なタイミングが明確になりました。また、「ホップバイホップ」ヘッダーフィールドは、接続ヘッダーフィールドに表示される必要があります。この仕様でホップバイホップとして定義されているからといって、それらは免除されません。（ &lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）サーバーごとの2つの接続の制限が削除されました。べき等の一連の要求を再試行する必要がなくなりました。サーバーが途中で接続を閉じるときに、特定の状況下で要求を再試行する必要がなくなりました。また、サーバーが時期尚早に接続を閉じることが許可される時期に関するいくつかの無関係な要件が削除されました。 （&lt;a href=&quot;#section-6.3&quot;&gt;セクション6.3&lt;/a&gt;）101以外の応答でUpgradeヘッダーフィールドのセマンティクスが定義されるようになりました（これは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] から組み込まれました）。さらに、フィールド値の順序は重要です。 （&lt;a href=&quot;#section-6.7&quot;&gt;6.7節&lt;/a&gt;）リスト生成における空のリスト要素（たとえば、「、」を含むリストヘッダーフィールド）は非推奨になりました。 （&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）転送コーディングの登録にはIETFレビューが必要になりました（&lt;a href=&quot;#section-8.4&quot;&gt;セクション8.4&lt;/a&gt;）。この仕様では、以前&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]のセクション7.2で&lt;/a&gt;定義されたアップグレードトークンレジストリを定義するようになりました。（&lt;a href=&quot;#section-8.6&quot;&gt;セクション8.6&lt;/a&gt;）HTTP / 0.9リクエストをサポートするという期待は削除されました。（付録A）リクエストのKeep-AliveおよびProxy-Connectionヘッダーフィールドの問題が指摘されていますが、後者の使用は完全に推奨されません。（付録A.1.2）</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">クロスサイトスクリプティング（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）に対する攻撃を緩和するために、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;プロパティ、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; APIを介してJavaScript経由でHTTPのみのCookieにアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash;単一行プロトコル</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP/0.9は非常に限られたもので、ブラウザもサーバもすぐに拡張して、より汎用性の高いものにしました。</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash;拡張性の構築</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">HTTP / 1.0接続は、デフォルトでは永続的ではありません。&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;close&lt;/code&gt; 以外、通常は &lt;code&gt;retry-after&lt;/code&gt; 以外に設定すると、永続的になります。</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0は、要求/応答交換ごとにTCP接続を開き、2つの大きな欠陥をもたらしました。接続を開くには、メッセージのいくつかのラウンドトリップが必要であり、そのために遅くなりますが、複数のメッセージが送信され、定期的に送信されるとより効率的になります。&lt;em&gt;ウォーム&lt;/em&gt;接続は&lt;em&gt;冷たい&lt;/em&gt;ものよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash;標準化されたプロトコル</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1を使用すると、クライアントは応答エンティティの一部（範囲）のみを応答に含めるように要求できます。 HTTP / 1.1は、範囲（&lt;a href=&quot;#section-14.35&quot;&gt;セクション14.35&lt;/a&gt;）およびコンテンツ範囲（&lt;a href=&quot;#section-14.16&quot;&gt;セクション14.16&lt;/a&gt;）ヘッダーフィールドで範囲単位を使用します。エンティティは、さまざまな構造単位に従ってサブレンジに分割できます。範囲単位=バイト単位| other-range-unit bytes-unit = &quot;bytes&quot; other-range-unit = token HTTP / 1.1で定義されている唯一の範囲単位は &quot;bytes&quot;です。 HTTP / 1.1実装は、他の単位を使用して指定された範囲を無視してもよい（MAY）。 HTTP / 1.1は、範囲の知識に依存しないアプリケーションの実装を可能にするように設計されています。</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP/1.1 およびそれ以前の HTTP メッセージは人間が読むことができます。HTTP/2 では、これらのメッセージはフレームという新しいバイナリ構造に組み込まれており、ヘッダの圧縮や多重化などの最適化が可能になっています。このバージョンの HTTP では、元の HTTP メッセージの一部だけが送信されたとしても、各メッセージのセマンティクスは変更されず、クライアントは元の HTTP/1.1 リクエストを (事実上)再構成します。したがって、HTTP/1.1 形式の HTTP/2 メッセージを理解することは有用です。</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP/1.1の曖昧さを明確にし、多数の改善点を紹介しました。</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1では、デフォルトで「持続的接続」が使用され、複数の要求と応答を1つの接続で伝送できます。 「閉じる」接続オプションは、現在の要求/応答後に接続が持続しないことを通知するために使用されます。 HTTP実装は永続的な接続をサポートする必要があります（SHOULD）。受信者は、最後に受信したメッセージのプロトコルバージョンと接続ヘッダーフィールド（存在する場合）に基づいて、接続が永続的かどうかを判断します。o「閉じる」接続オプションが存在する場合、現在の応答後に接続は永続化されません。それ以外の場合、o受信したプロトコルがHTTP / 1.1（またはそれ以降）の場合、接続は現在の応答後も持続します。それ以外の場合、o受信したプロトコルがHTTP / 1.0の場合、「keep-alive &quot;接続オプションが存在し、受信者がプロキシではなく、受信者がHTTP / 1.0の&quot; keep-alive &quot;メカニズムを尊重したい場合、接続は現在の応答後も持続します。それ以外の場合は、o接続は終了します現在の応答。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続に追加の要求を送信できます（MAY）。永続性を維持するために、すべてのメッセージで説明されているように、接続では自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）が必要です。メカニズム、接続は現在の応答後も持続します。それ以外の場合、o現在の応答後に接続が閉じます。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続で追加の要求を送信する場合があります。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。メカニズム、接続は現在の応答後も持続します。それ以外の場合、o現在の応答後に接続が閉じます。クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP / 1.0応答を受信するまで、永続的な接続で追加の要求を送信する場合があります。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。「キープアライブ」接続オプションなしの0応答。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。「キープアライブ」接続オプションなしの0応答。永続性を維持するために、接続上のすべてのメッセージは、以下で説明するように、自己定義のメッセージ長（つまり、接続のクローズによって定義されていないもの）を持つ必要があります。&lt;a href=&quot;#section-3.3&quot;&gt;セクション3.3&lt;/a&gt;。サーバーは、要求メッセージ本文全体を読み取るか、応答を送信した後で接続を閉じる必要があります。そうしないと、永続的な接続の残りのデータが次の要求として誤って解釈されます。同様に、クライアントは、後続の要求で同じ接続を再利用する場合は、応答メッセージ本文全体を読み取る必要があります。プロキシサーバーは、HTTP / 1.0クライアントとの永続的な接続を維持してはなりません（多くのHTTP / 1.0クライアントによって実装されたKeep-Aliveヘッダーフィールドの問題と情報については、&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;[RFC2068]のセクション19.7.1を&lt;/a&gt;参照してください）。HTTP / 1.0クライアントとの下位互換性の詳細については、&lt;a href=&quot;#appendix-A.1.2&quot;&gt;付録A.1.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1では、Transfer-Encodingヘッダーフィールドが導入されています（&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt;）。MIME準拠のプロトコルでHTTPメッセージを転送する前に、転送コーディングをデコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1では、Transfer-Encodingヘッダーフィールドが導入されています（&lt;a href=&quot;#section-14.41&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;）。プロキシ/ゲートウェイは、MIME準拠のプロトコルを介してメッセージを転送する前に、転送コーディングを削除する必要があります。「チャンク」転送コーディングをデコードするプロセス（&lt;a href=&quot;#section-3.6&quot;&gt;セクション3.6&lt;/a&gt;）擬似コードでは次のように表すことができます：length：= 0チャンクサイズ、チャンク拡張（存在する場合）、CRLFを読み取りながら（チャンクサイズ&amp;gt; 0）{チャンクデータを読み取り、CRLFがエンティティにチャンクデータを追加します。 body length：= length + chunk-size read chunk-size and CRLF} entity-header while（entity-header not empty）{entity-header to existing header fields read entity-header} Content-Length：= length Remove &quot; Transfer-Encodingからチャンク化</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP/1.1 サーバは持続的な接続を維持し、クライアントが再試行することを期待して接続を終了するのではなく、一時的な過負荷を解決するために TCP のフロー制御メカニズムを使用すべきである[SHOULD]。後者の技術はネットワークの混雑を悪化させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1は、日付比較のプロセスを簡素化するために、日付フォーマットの制限されたセット（&lt;a href=&quot;#section-3.3.1&quot;&gt;セクション3.3.1&lt;/a&gt;）を使用します。他のプロトコルからのプロキシとゲートウェイは、メッセージに存在するすべての日付ヘッダーフィールドがHTTP / 1.1形式のいずれかに準拠していることを確認し、必要に応じて日付を書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1は、日付比較のプロセスを簡素化するために、制限された一連の日付フォーマット（&lt;a href=&quot;#section-7.1.1.1&quot;&gt;セクション7.1.1.1&lt;/a&gt;）を使用します。他のプロトコルのプロキシとゲートウェイは、メッセージに存在する日付ヘッダーフィールドがHTTP / 1.1形式のいずれかに準拠していることを確認し、必要に応じて日付を書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1は、インターネットメール（&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]）および多目的インターネットメール拡張（MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]）用に定義された多くの構成を使用して、エンティティをさまざまな表現で拡張可能なメカニズムで送信できるようにします。ただし、&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; はメールについて説明しており、HTTPには&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045で&lt;/a&gt;説明されているものとは異なるいくつかの機能があります。これらの違いは、バイナリ接続でのパフォーマンスを最適化し、新しいメディアタイプをより自由に使用できるようにし、日付の比較を容易にし、一部の初期のHTTPサーバーとクライアントの慣行を認めるために慎重に選択されました。この付録では、HTTPが異なる特定の領域について説明します&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;。厳密なMIME環境へのプロキシとゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります（SHOULD）。MIME環境からHTTPへのプロキシとゲートウェイも、一部の変換が必要になる場合があるため、違いを認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1は、インターネットメッセージフォーマット[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ]および多目的インターネットメール拡張（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]に定義されている多くの構造を使用して、メッセージ本文をさまざまな表現で、拡張可能なヘッダーフィールドで送信できるようにします。ただし、&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;メールのみに焦点を当てています。HTTPのアプリケーションには、電子メールとは異なる多くの特性があります。したがって、HTTPにはMIMEとは異なる機能があります。これらの違いは、バイナリ接続でのパフォーマンスを最適化し、新しいメディアタイプをより自由に使用できるようにし、日付の比較を容易にし、一部の初期のHTTPサーバーとクライアントの慣行を認めるために慎重に選択されました。この付録では、HTTPがMIMEと異なる特定の領域について説明します。厳密なMIME環境との間のプロキシおよびゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1は、1997年1月に&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;として最初に公開されました。</target>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP/1.1はHTTPの最初のバージョンで、永続的な接続とパイプラインをサポートしていました。この記事では、この2つの概念について説明します。</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP/1.1.認証</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP/1.1.セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP/1.xのメッセージは、パフォーマンスの面でいくつかの欠点があります。</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash;パフォーマンスを向上させるプロトコル</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP/2 フレーム</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP/2では、接続管理のためのモデルが追加されています。</target>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP/2は接続がどのように作成され、維持されるかを完全に見直しました:この記事では、HTTPフレームがどのように多重化を可能にするかを説明し、以前のHTTPバージョンの「行頭」ブロッキングの問題を解決しています。</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP/2 は HTTP/1.x のメッセージをバイナリフレームでカプセル化して表現します。この記事では、フレームの構造、その目的、エンコードの方法について説明します。</target>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2は追加のステップを導入します：HTTP / 1.xメッセージをストリームに埋め込まれたフレームに分割します。データフレームとヘッダーフレームが分離されているため、ヘッダーを圧縮できます。複数のストリームを組み合わせることができます。このプロセスは&lt;em&gt;多重化&lt;/em&gt;と呼ばれ、基礎となるより効率的なTCP接続を可能にします。</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP/3-HTTP over QUIC</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;ホスト：ポート&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">サーバー上でのCORSの処理(Javaの例</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">ヘッダーフィールド名：SLUG該当するプロトコル：http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]ステータス：標準。作成者/変更コントローラー：IETF（iesg@ietf.org）インターネット技術特別調査委員会の仕様書： &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;。関連情報：なし。</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：DAV該当プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.1&quot;&gt;セクション10.1&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：深さ適用プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.2&quot;&gt;セクション10.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：宛先該当するプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.3&quot;&gt;セクション10.3&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：該当するプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.4&quot;&gt;10.4項&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：Lock-Token該当プロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.5&quot;&gt;セクション10.5&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：上書き適用可能なプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.6&quot;&gt;セクション10.6&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">ヘッダーフィールド名：タイムアウト適用可能なプロトコル：httpステータス：標準の作成者/変更コントローラー：IETF仕様ドキュメント：この仕様（&lt;a href=&quot;#section-10.7&quot;&gt;セクション10.7&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">ヘッダーフィールドは完全に拡張可能です。新しいフィールド名の導入、それぞれがおそらく新しいセマンティクスを定義していること、および特定のメッセージで使用されるヘッダーフィールドの数に制限はありません。既存のフィールドは、この仕様の各部分およびこのドキュメントセット以外の多くの仕様で定義されています。新しいヘッダーフィールドを定義して、受信者が理解したときに、以前に定義されたヘッダーフィールドの解釈を上書きまたは強化したり、要求評価の前提条件を定義したり、応答の意味を調整したりできます。接続ヘッダーフィールドにフィールド名がリストされていない限り、プロキシは、認識されないヘッダーフィールドを転送する必要があります（&lt;a href=&quot;#section-6.1&quot;&gt;セクション6.1&lt;/a&gt;）または、プロキシはそのようなフィールドをブロックするか、そうでなければ変換するように特別に構成されています。他の受信者は、認識されないヘッダーフィールドを無視する必要があります。これらの要件により、デプロイされた仲介者を事前に更新することなく、HTTPの機能を拡張できます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;[RFC7231]のセクション8.3で&lt;/a&gt;説明されているように、定義されたすべてのヘッダーフィールドは、「メッセージヘッダー」レジストリのIANAに登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">ヘッダーフィールドは、メッセージ、そのペイロード、ターゲットリソース、または接続に関するデータ（つまり、制御データ）の通信に使用できるキーと値のペアです。HTTPメッセージのヘッダーフィールド構文の一般的な定義については、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2を&lt;/a&gt;参照してください。ヘッダーフィールド名の要件は、[ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]。新しいフィールドを定義する仕様の作成者は、名前をできるだけ短くし、ヘッダーフィールドがインターネットで使用されない限り、名前の前に「X-」を付けないことをお勧めします。 （「X-」接頭辞のイディオムは、実際には広く誤用されています。これは、独自のソフトウェアまたはイントラネット処理内での名前の衝突を回避するメカニズムとしてのみ使用することを目的としていました。インターネット名。詳細については、[ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ]を参照してください）。新しいヘッダーフィールド値は通常&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;、[RFC7230]のセクション7で&lt;/a&gt;定義されている拡張を使用して、ABNF（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ]）を使用して定義された構文を持っています必要に応じて、通常はUS-ASCII文字の範囲に制限されます。より広い範囲の文字を必要とするヘッダーフィールドは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]で定義されているようなエンコーディングを使用できます。生のフィールド値の先頭と末尾の空白は、フィールドの解析時に削除されます（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]のセクション3.2.4&lt;/a&gt;）。値の先頭または末尾の空白が重要なフィールド定義では、quoted-string（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]のセクション3.2.6）&lt;/a&gt;などのコンテナ構文を使用する必要があります。）。コンマ（ &quot;、&quot;）はフィールド値間の一般的な区切り文字として使用されるため、フィールド値で許可されている場合は慎重に扱う必要があります。通常、コンマを含む可能性のあるコンポーネントは、引用文字列ABNFプロダクションを使用して二重引用符で保護されます。たとえば、テキストの日付とURI（どちらもカンマが含まれている可能性があります）は、次のようなフィールド値で安全に運ぶことができます。Example-URI-Field： &quot;http://example.com/a.html,foo&quot; 、 &quot;http://without-a-comma.example.com/&quot; Example-Date-Field： &quot;Sat、04 May 1996&quot;、 &quot;Wed、14 Sep 2005&quot;二重引用符区切り文字は、ほとんどの場合、引用文字列の生成。二重引用符内で異なる構文を使用すると、不要な混乱を招く可能性があります。多くのヘッダーフィールドは、（大文字と小文字を区別せずに）名前付きパラメーターを含む形式を使用します（たとえば、Content-Type、&lt;a href=&quot;#section-3.1.1.5&quot;&gt;セクション3.1.1.5&lt;/a&gt;）。パラメータ値に引用符なし（トークン）と引用符付き（引用符付き文字列）の両方の構文を許可すると、受信者は既存のパーサーコンポーネントを使用できます。両方の形式を許可する場合、パラメーター値の意味は、使用される構文とは無関係である必要があります（例については、&lt;a href=&quot;#section-3.1.1.1&quot;&gt;セクション3.1.1.1の&lt;/a&gt;メディアタイプのパラメーター処理に関する注記を参照してください ）。新しいヘッダーフィールドを定義する仕様の作成者は、文書化を検討することをお勧めします。oフィールドが単一の値であるか、それがリストであるか（コンマで区切られるかどうか。&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2を&lt;/a&gt;参照））。リスト構文を使用しない場合は、フィールドが複数回発生するメッセージの処理方法を文書化します（適切なデフォルトはフィールドを無視することですが、これが常に正しい選択であるとは限りません）。フィールドの定義でリスト構文が許可されていなくても、仲介者とソフトウェアライブラリは複数のヘッダーフィールドインスタンスを1つのインスタンスに結合する場合があることに注意してください。堅牢なフォーマットにより、受信者はこれらの状況を発見できます（コンマは引用符付きの文字列内にのみ表示できるため、「Content-Type」、URI内にはコンマが発生する可能性があるため、「Location」など）。 oヘッダーフィールドを使用できる条件。たとえば、応答または要求のみ、すべてのメッセージ、特定の要求メソッドへの応答のみなど。o PUTリクエストでそれを理解するオリジンサーバーがフィールドを保存するかどうか。 oフィールドのセマンティクスが、既存のリクエストメソッドやステータスコードなどのコンテキストによってさらに洗練されているかどうか。 o Connectionヘッダーフィールドにフィールド名をリストすることが適切かどうか（つまり、ヘッダーフィールドをホップバイホップにする場合;を参照） &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]のセクション6.1&lt;/a&gt;）。 o仲介者がフィールドの値を挿入、削除、または変更することが許可される状況。 oフィールド名をVary応答ヘッダーフィールドにリストすることが適切かどうか（たとえば、要求ヘッダーフィールドがオリジンサーバーのコンテンツ選択アルゴリズムによって使用される場合。&lt;a href=&quot;#section-7.1.4&quot;&gt;セクション7.1.4を&lt;/a&gt;参照 ）。 oヘッダーフィールドがトレーラーで有用か許容されるか（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;[RFC7230]のセクション4.1を&lt;/a&gt;参照 ）。 oヘッダーフィールドをリダイレクト間で保持する必要があるかどうか。 oプライバシー関連データの開示など、セキュリティに関する追加の考慮事項が導入されているかどうか。</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">トレーラーの使用を規制するヘッダーフィールド：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;（要求）および&lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt;（応答）。</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">ヘッダーの種類</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コンテンツネゴシエーションの結果を含むヘッダー：&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">ヘッダーは、あるメッセージから次のメッセージまで非常によく似ていますが、それでも接続をまたいで繰り返されます。</target>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">ヘッダーは、プロキシがどのように処理するかによってグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">ヘッダーは、その文脈に応じてグループ化することができます。</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">ヘッダーはボディとは異なり、圧縮されていません。</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">HTTP の理解とデバッグに役立つツールやリソース。</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">ここでも、他の人が有効な番号を含むことを保証するものではないので、あなたが探しているブラウザのために正しいトークンを取ることを確認してください。</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">ここでは、UA文字列にデバイスIDを持つデバイスを含むすべてのモバイルデバイスを検出するJavaScriptの正規表現を示します。</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">ここでは、ドキュメントのタイプ別に関連付けられた MIME タイプのリストを、共通の拡張子の順に並べています。</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">ここでは、HTTP で制御可能な一般的な機能のリストを示します。</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">ここでは、クライアントとサーバ間のやりとりのサンプルを紹介します。</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">以下は、&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;プリフライトされたリクエスト&lt;/a&gt;を処理するPHPの例です。</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">以下は、パーセントエンコーディングを使用してUnicode文字U + 00E8（ラテン文字の小文字EとGRAVE）を表すSlugヘッダーの例です。POST / myblog / entries HTTP / 1.1ホスト：example.org Content-Type：image / png Slug：S％C3％A8teのビーチAuthorization：Basic ZGFmZnk6c2VjZXJldA == Content-Length：nnn ... binary data Entry Resourceの作成に適用されるSlugヘッダーの例については、&lt;a href=&quot;#section-9.2.1&quot;&gt;セクション9.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">ここでは、共有キャッシュプロキシを使用した処理の例を示します。</target>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">ここでは、クレデンシャル付きのリクエストを処理するPHPを紹介します。</target>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">ここでは、 &lt;code&gt;Upgrade&lt;/code&gt; ヘッダーの最も一般的な使用例を示します。</target>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; ヘッダーの例を次に示します。これは、「単純な」ヘッダーに加えて、 &lt;code&gt;X-Custom-Header&lt;/code&gt; という名前のカスタムヘッダーがサーバーへのCORSリクエストでサポートされていることを示しています。</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">ここで、 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; は認証スキームです（「Basic」は最も一般的なスキームであり、&lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;以下&lt;/a&gt;で紹介します）。&lt;em&gt;レルムは、&lt;/em&gt;保護された領域を記述するために、または保護の範囲を示すために使用されます。これは、「ステージングサイトへのアクセス」などのメッセージである可能性があります。これにより、ユーザーは、アクセスしようとしているスペースを知ることができます。</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">ここで、 &lt;code&gt;base64EncodedSettings&lt;/code&gt; は、HTTP64の &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; フレームのペイロードであり、base64urlエンコードされており、このテキストヘッダー形式に安全に含めるために、末尾の &lt;code&gt;&quot;=&quot;&lt;/code&gt; （等しい）文字がすべて削除されています。</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">ここで、&lt;em&gt;xy&lt;/em&gt;はMac OS Xのバージョンです（たとえば、Mac OS X 10.6）。</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">ここでは、デフォルトでは、以下の例外を除いて、コンテンツはドキュメントの元の場所からのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">ここでは、クロスオリジンリソースシェアリングがどのように機能するかを示す3つのシナリオを示します。これらの例はすべて、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;オブジェクトを使用しています。このオブジェクトを使用して、サポートされている任意のブラウザーでクロスサイト呼び出しを行うことができます。</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">HerokuのプロキシライブラリVegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">ヒューリスティック満了</target>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;によって廃止されたHTTP状態管理メカニズムの歴史的な仕様</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">履歴リスト (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">ホップバイホップ圧縮</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">ホップバイホップ圧縮は、エンドツーエンド圧縮と似ていますが、1つの基本的な要素が異なります。圧縮はサーバー内のリソースでは発生せず、送信される特定の表現を作成しますが、クライアントとサーバー間のパス上の任意の2つのノード間のメッセージ。連続する中間ノード間の接続では、&lt;em&gt;異なる&lt;/em&gt;圧縮が適用される場合があります。</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">ホップバイホップヘッダー</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">ホスト(RFC2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">リバースプロキシ（ロードバランサー、CDN）のホスト名とポートは、リクエストを処理するオリジンサーバーと異なる場合があります。その場合、 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; ヘッダーは、どのホストが最初に使用されたかを判断するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">ホスト固有のファイル名</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">HTTPS移行のためのホスト型CSPレポート</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">ホスト名に基づく条件</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">ブラウザの仕組み</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">Cookieの仕組みは&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265で&lt;/a&gt;定義されています。HTTP要求を処理するとき、サーバーは応答とともに &lt;code&gt;Set-Cookie&lt;/code&gt; HTTPヘッダーを送信できます。次に、クライアントは、すべてのリクエストでCookieの値を &lt;code&gt;Cookie&lt;/code&gt; リクエストヘッダーの形式で同じサーバーに返します。Cookieは、特定の日付で期限切れになるように設定したり、特定のドメインおよびパスに制限したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">ドキュメントをどのようにキャッシュするかは HTTP で制御できます。サーバはプロキシやクライアントに何をどのくらいの期間キャッシュするかを指示できます。クライアントは、中間キャッシュプロキシに保存されたドキュメントを無視するように指示することができます。</target>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">ブラウザの扱い方</target>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">CORSのプリフライトを回避する方法</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「Access-Control-Allow-Originヘッダーをワイルドカードにすることはできません」&lt;/em&gt;を修正する方法&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">CORSの問題を修正するには?</target>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">CORSプロキシを使用して&lt;em&gt;「No Access-Control-Allow-Originヘッダー」を&lt;/em&gt;回避する方法&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">ただし、リクエストに &lt;code&gt;Authorization&lt;/code&gt; ヘッダーが存在するためにリクエストがプリフライトをトリガーするリクエストである場合、上記の手順を使用して制限を回避することはできません。また、リクエストが送信されるサーバーを制御できない限り、この問題を回避することはできません。</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">しかし、整合性のないスクリプトはロードされなくなりました。</target>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">ただし、要素の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt;プロパティに直接設定されたスタイルプロパティはブロックされないため、ユーザーはJavascriptを介して安全にスタイルを操作できます。</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">ただし、上記のコードは絶対にひどく、考えも悪いです。Chromeがこの後読み機能を削除するとどうなりますか？別のブラウザが正規表現の背後にあるルックアップを実装している場合はどうなりますか？別のブラウザがユーザーエージェント文字列で&lt;em&gt;Chrome&lt;/em&gt;を使用している場合はどうなりますか？ひどく間違っている可能性のあるもののリストはどんどん続きます。したがって、代わりに次のような特徴検出を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly オプション</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">ハイパーテキストコーヒーポット制御プロトコル(HTCPCP/1.0</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">ハイパーテキストコーヒーポット制御プロトコル(HTCPCP/1.0)。セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">ハイパーテキスト転送プロトコル(セキュア</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">ハイパーテキストマークアップげんご</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">ハイパーテキストトランスポートプロトコルキープアライブヘッダー</target>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP)キープアライブヘッダー</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP)クライアントでは、キャンセルされたリクエストや接続の切断の結果、データ転送が中断されることがよくあります。クライアントが部分的な表現を保存している場合、表現全体を転送するのではなく、後続のリクエストでその表現の残りをリクエストすることが望ましい。同様に、ローカルストレージが限られているデバイスでは、非常に大きな文書の単一ページや埋め込み画像の寸法など、より大きな表現のサブセットのみを要求できることが利点となるかもしれません。このドキュメントでは、HTTP/1.1 の範囲要求、部分応答、および multipart/byteranges メディアタイプを定義しています。範囲要求は HTTP の OPTIONAL 機能であり、この機能を実装していない (あるいはターゲットリソースに対してこの機能をサポートしていない)受信者が、相互運用性に影響を与えることなく、通常の GET 要求のように応答できるように設計されています。部分的な応答は、この機能を実装していない可能性のあるキャッシュによって完全な応答と間違われないように、別個のステータスコードによって示されます。範囲リクエストメカニズムは拡張可能な範囲タイプを可能にするように設計されていますが、この仕様ではバイト範囲のリクエストのみを定義しています。</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1)。認証</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):キャッシング</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP/1.1)。条件付きリクエスト</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):メッセージ構文とルーティング</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1):範囲リクエスト</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">ハイパーテキスト転送プロトコル(HTTP/1.1)。セマンティクスとコンテンツ</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">ハイパーテキスト転送プロトコル (HTTP/1.1)。セマンティクスとコンテキスト</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">ハイパーテキスト転送プロトコル --HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">ハイパーテキスト転送プロトコルバージョン2(HTTP/2</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA の考慮事項 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA の考慮事項 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA の考慮事項 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANAの考慮事項(RFC7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA の考慮事項 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA の考慮事項 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANAは、'application/atom+xml'メディアタイプ登録において、この仕様への参照を追加しました。</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANAはMIMEメディアタイプの公式レジストリで&lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;あり、すべての公式MIMEタイプのリストを&lt;/a&gt;保持しています。次の表に、Webの重要なMIMEタイプをいくつか示します。</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">URIスキームのIANAリスト</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANAは、&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; で「HTTPコンテンツコーディングレジストリ」を維持しています。 「HTTPコンテンツコーディングレジストリ」は、以下の登録で更新されています。+ ------------ + --------------------- ----------------- + --------------- + |名前|説明|リファレンス| + ------------ + ------------------------------------ -+ --------------- + |圧縮| UNIXの「圧縮」データ形式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | |しぼむ|圧縮データを「デフレート」する| &lt;a href=&quot;#section-4.2.2&quot;&gt;セクション4.2.2&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）「zlib」データ内| | | |形式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIPファイル形式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | | x-compress | 非推奨（圧縮のエイリアス）| &lt;a href=&quot;#section-4.2.1&quot;&gt;セクション4.2.1&lt;/a&gt; | | x-gzip | 非推奨（gzipのエイリアス）| &lt;a href=&quot;#section-4.2.3&quot;&gt;セクション4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANAは、インターネットメディアタイプ[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] のレジストリを&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;で管理しています。このドキュメントは、インターネットメディアタイプ「message / http」および「application / http」の仕様として機能します。以下はIANAに登録されています。</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANAは、インターネットメディアタイプ[ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] のレジストリを&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt;で管理しています。このドキュメントは、インターネットメディアタイプ「multipart / byteranges」の仕様となります。以下はIANAに登録されています。</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANAは、URIスキームのレジストリ[ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ]を&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt;に維持しています。このドキュメントでは次のURIスキームを定義しているため、「Permanent URI Schemes」レジストリはそれに応じて更新されています。 + ------------ + ------------------------------------ + --------------- + | URIスキーム|説明|リファレンス| + ------------ + ------------------------------------ + --------------- + | http |ハイパーテキスト転送プロトコル| &lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt; | | https |安全なハイパーテキスト転送プロトコル| &lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">HTTPステータスコードのIANA公式レジストリ</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">イアナレジストリ</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">認証スキームのIANAレジストリ</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">アイイーティーエフドラフト</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">アイイーティーエフアールエフ</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">アイコン形式</target>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">理想的には、1つのリソースに対して1つの場所、つまり1つのURLが存在します。ただし、リソースに別の名前を付けたい理由があります（wwwプレフィックスがある場合とない場合、または短くて覚えやすいURLなど、いくつかのドメイン）。このような場合、リソースを複製するのではなく、1つの真の（正規の）URLへのリダイレクトを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">アイデムポテントメソッド (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">クライアントがプロキシやロードバランサーに接続するために使用した元のホストを識別します。</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">HTTP プロキシまたはロードバランサーを介してウェブサーバに接続するクライアントの発信元 IP アドレスを識別します。</target>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">許可されたリクエスト方法の識別</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">ウェブ上のリソースを特定する</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">課題の特定</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">場合は&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（関連項目）応答は常にの使用につながる&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;メソッド、&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;（一時的なリダイレクト）と&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;（パーマネントリダイレクト）は、元の要求に使用される方法を変更しないでください。</target>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If = &quot;If&quot; &quot;：&quot;（1 *タグなしリスト| 1 *タグ付きリスト）タグなしリスト=リストタグ付きリスト=リソースタグ1 *リストリスト= &quot;（&quot; 1 *条件 &quot;） &quot;Condition = [&quot; Not &quot;]（State-token |&quot; [&quot;entity-tag&quot;] &quot;）; entity-tag：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]のセクション3.11を&lt;/a&gt;参照してください 。 「[」、エンティティタグ、「]」の間でLWSを許可しないState-token = Coded-URL Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;; simple-ref：&lt;a href=&quot;#section-8.3&quot;&gt;セクション8.3を&lt;/a&gt;参照 ; Resource-TagでLWSを許可しない構文は、タグなしリスト（「No-tag-list」）とタグ付きリスト（「Tagged-list」）を区別します。タグなしリストはRequest-URIで識別されるリソースに適用され、タグ付きリストは先行するResource-Tagで識別されるリソースに適用されます。リソースタグは、次のリソースタグまで、後続のすべてのリストに適用されます。 2つのリストタイプをIfヘッダー内で混在させることはできません。 No-tag-list構文は、Request-URIを参照するResource-Tagを使用したタグ付きリストプロダクションの略記であるため、これは機能上の制限ではありません。各リストは、1つ以上の条件で構成されています。各条件は、エンティティタグまたはステートトークンの観点から定義され、接頭辞「Not」によって潜在的に否定されます。Ifヘッダー構文では、単一のリクエストでIfヘッダーの複数のインスタンスを使用できないことに注意してください。ただし、HTTPヘッダー構文では、改行の後に空白を挿入することで、単一のヘッダー値を複数行に拡張できます（[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、&lt;a href=&quot;#section-4.2&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">HTTP パイプラインを有効にすると、最初のレスポンスが完全に受信されるのを待たずに、いくつかのリクエストを送信することができます。HTTP パイプラインは、古いソフトウェアが最新のバージョンと共存している既存のネットワークでは実装が難しいことが証明されています。HTTP パイプラインは HTTP/2 に取って代わられ、フレーム内のリクエストをより強固に多重化するようになりました。</target>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">（プロキシ）サーバーが、特定のリソースへのアクセスを取得するのに適切ではない有効な資格情報を受信した場合、サーバーは&lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; ステータスコードで応答する必要があります。&lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; または&lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; とは異なり、このユーザーの認証は不可能です。</target>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; メソッドが正常に適用された場合、いくつかの応答ステータスコードが考えられます。</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">場合 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; ヘッダを用意し、このヘッダーの値をとり、文字列「258EAFA5-E914-47DA-95CA-C5AB0DC85B11」それにを連結し、キーの値をとることによって計算される&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;のハッシュをその連結された文字列は、20バイトの値になります。次に、その値を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64で&lt;/a&gt;エンコードして、このプロパティの値を取得します。</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">COPYリクエストに「F」の値を持つOverwriteヘッダーがあり、リソースが宛先URLに存在する場合、サーバーはリクエストを失敗させる必要があります。サーバーがCOPYリクエストを実行して宛先リソースを上書きする場合、正確な動作はWebDAV拡張機能を含む多くの要因に依存する可能性があります（特に[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253を&lt;/a&gt;参照]]）。たとえば、通常のリソースが上書きされると、サーバーはコピーを実行する前にターゲットリソースを削除したり、ライブプロパティを保持するために上書きしたりできます。コレクションが上書きされる場合、COPYリクエストが成功した後の宛先コレクションのメンバーシップは、COPYの直前のソースコレクションと同じメンバーシップである必要があります。したがって、ソースコレクションと宛先コレクションのメンバーシップを宛先でマージすることは、準拠した動作ではありません。一般に、クライアントがCOPYの前に宛先URLの状態を消去する必要がある場合（たとえば、ライブプロパティを強制的にリセットするため）、クライアントはCOPYリクエストの前にDELETEを宛先に送信して、このリセットを確認できます。 。</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">キャッシュが表現可能な値よりも大きい値を受け取った場合、またはその後の計算でオーバーフローした場合、キャッシュはその値を 2147483648 (2^31)または都合よく表現可能な最大の正の整数のいずれかであるとみなします。</target>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">クライアントが表現の部分的なコピーを持っていて、表現全体の最新のコピーを持ちたい場合、条件付きGETでRangeヘッダーフィールドを使用できます（If-Unmodified-SinceとIfのいずれかまたは両方を使用） -一致。）ただし、表現が変更されたために前提条件が満たされない場合、クライアントは現在の表現全体を取得するために2番目の要求を行う必要があります。 「If-Range」ヘッダーフィールドを使用すると、クライアントは2番目のリクエストを「短絡」できます。非公式には、その意味は次のとおりです。表現が変更されていない場合は、範囲で要求しているパーツを送ってください。それ以外の場合は、表現全体を送ってください。If-Range = entity-tag / HTTP-dateクライアントは、Rangeヘッダーフィールドを含まないリクエストでIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。サーバーは、範囲ヘッダーフィールドを含まないリクエストで受信したIf-Rangeヘッダーフィールドを無視する必要があります。オリジンサーバーは、範囲要求をサポートしないターゲットリソースの要求で受信されたIf-Rangeヘッダーフィールドを無視する必要があります。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントは、弱いとマークされているエンティティタグを含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。クライアントが対応する表現のエンティティタグを持たず、日付が次のように定義されている意味で強力なバリデータでない限り、クライアントはHTTP日付を含むIf-Rangeヘッダーフィールドを生成してはなりません（MUST NOT）。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]のセクション2.2.2&lt;/a&gt;。 If-Range前提条件を評価するサーバーは、エンティティタグを比較するときに強力な比較関数を使用する必要があり（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]のセクション2.3.2&lt;/a&gt;）、強力ではないHTTP日付バリデーターが提供される場合、条件をfalseとして評価する必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]のセクション2.2.2で&lt;/a&gt;定義されている意味でのバリデータ。有効なエンティティタグは、DQUOTEの最初の2文字を調べることにより、有効なHTTP日付と区別できます。 If-Rangeヘッダーフィールドで指定されたバリデーターが、ターゲットリソースの選択された表現の現在のバリデーターと一致する場合、サーバーは要求に応じてRangeヘッダーフィールドを処理する必要があります（SHOULD）。バリデーターが一致しない場合、サーバーはRangeヘッダーフィールドを無視する必要があります。完全一致によるこの比較は、バリデーターがHTTP日付の場合も含めて、If-Unmodified-Since条件を評価するときに使用される「以前の値または等しい」比較とは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">クライアントがキャッシュ内にあるエンティティの部分的なコピーを持っていて、キャッシュ内のエンティティ全体の最新のコピーを取得したい場合、条件付きGET(If-Unmodified-SinceとIf-Matchのどちらか、または両方を使用)でRangeリクエストヘッダを使用することができます。If-Rangeヘッダーは、クライアントが2回目のリクエストを「短絡」させることを可能にする。非公式には、その意味は「エンティティが変更されていなければ、私が見落としている部分を送ってください。If-Range=&quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date)クライアントがエンティティに対してエンティティタグを持たないが、Last-Modifiedの日付を持っている場合、その日付をIf-Rangeヘッダーで使用してもよい[MAY]。(サーバーは、有効なHTTP-dateといかなる形式のエンティティタグを 2文字以下の文字を調べることで区別することができる)。If-RangeヘッダーはRangeヘッダーと共にのみ使用されるべきであり[SHOULD]、 リクエストがRangeヘッダーを含まない場合、またはサーバーが サブレンジ操作をサポートしない場合は無視されなければならない[MUST]。If-Rangeヘッダーで与えられたエンティティタグがそのエンティティの現在の エンティティタグにマッチする場合、サーバーは206(Partial content)応答を使用してエンティティの指定されたサブレンジを提供するべきである[SHOULD]。エンティティタグがマッチしない場合、サーバーは200(OK)応答を使用して エンティティ全体を返すべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">新しいキャッシュ可能に（セクションを参照した場合&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;、&lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;、&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;および&lt;a href=&quot;#section-13.8&quot;&gt;13.8を&lt;/a&gt;同じリソースに対する既存のレスポンスがキャッシュされている間に）レスポンスがリソースから受信され、キャッシュは現在に返信する新しいレスポンスを使用すべきですリクエスト。それをキャッシュストレージに挿入してもよいし、他のすべての要件を満たしている場合は、それを使用して、以前に古い応答が返される原因となっていた将来の要求に応答してもよい。新しい応答をキャッシュストレージに挿入する場合、&lt;a href=&quot;#section-13.5.3&quot;&gt;セクション13.5.3の&lt;/a&gt;ルールが適用されます。注：既存のキャッシュされた応答よりも古い日付ヘッダー値を持つ新しい応答はキャッシュできません。</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">リクエストが複数のプロキシを経由する場合、各プロキシのIPアドレスがリストされます。つまり、一番右のIPアドレスが一番新しいプロキシのIPアドレスで、 一番左のIPアドレスが発信元のクライアントのIPアドレスである。</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">宛先にリソースが存在し、Overwriteヘッダーが「T」である場合、移動を実行する前に、サーバーは宛先リソースに対して「Depth:infinity」でDELETEを実行しなければならない[MUST]。上書きヘッダーが「F」に設定されている場合、操作は失敗する。</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">同じサイトのCookieにこの属性がある場合、Cookieを設定したWebサイトから要求が発信された場合にのみ、ブラウザーはCookieを送信します。リクエストが現在の場所のURLとは異なるURLから発生した場合、 &lt;code&gt;strict&lt;/code&gt; 属性でタグ付けされたcookie は含まれません。</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">サーバがこのようなエラーステータスを返す場合、メッセージの本文には、利用可能なリソースの表現のリストが含まれ、ユーザがそれらの中から選択できるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">単一のサーバが、互いに信頼できない複数の組織をサポートしている場合、その組織が権限のないリソースを無効にしようとしないことを 確認するために、その組織の管理下で生成される応答の中のLocationおよびContent-Locationヘッダの値を チェックしなければならない[MUST]。</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">ユーザーがWebサイトまたはサービスからサインアウトした場合、ローカルに保存されたデータを削除することができます。これは、https：//example.com/logoutの応答に &lt;code&gt;Clear-Site-Data&lt;/code&gt; ヘッダーを追加することで実現できます。</target>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">Web サイトが HTTP で接続を受け付けて HTTPS にリダイレクトすると、訪問者が最初に暗号化されていないバージョンのサイトと通信してからリダイレクトされる可能性があります。これは、中間者攻撃の機会を生み出します。リダイレクトは、訪問者を元のサイトの安全なバージョンではなく、悪意のあるサイトに誘導するために悪用される可能性がある。</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">すべてのプロキシがダウンしており、DIRECT オプションが指定されていない場合、ブラウザはプロキシを一時的に無視して直接接続を試みるべきかどうかを尋ねます。20 分後、ブラウザはプロキシを再試行すべきかどうかを尋ね、さらに 40 分後に再度尋ねます。クエリは継続され、クエリ間の経過時間に常に 20 分が加算されます。</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">HTTP/1.1クライアントが、リクエストボディを含むが「100-continue」の期待値を持つ Expectリクエストヘッダーフィールドを含まないリクエストを送る場合、クライアントがHTTP/1.1オリジンサー バーに直接接続されておらず、クライアントがサーバーから何らかのステータスを受け取る前 に接続が終了するのを見る場合、クライアントはリクエストを再試行するべきである[SHOULD]。クライアントがこのリクエストを再試行する場合、信頼できる応答を確実に得るために、 以下の「バイナリ指数バックオフ(binary exponential backoff)」アルゴリズムを使用してもよい[MAY]。1.1.サーバーへの新しい接続を開始する。2.リクエストヘッダーを送信する 3.3.変数Rをサーバーへの推定往復時間(例えば、接続を確立するのにかかった時間に基づ く)に初期化するか、往復時間が利用できない場合は5秒の定数値に初期化する。4.4.T=R*(2**N)を計算する。Nはこのリクエストの前回の再試行回数である。5.5.サーバからのエラー応答を待つか、T秒待つ(どちらか早い方)6.6.エラー応答を受け取らない場合、T秒後にリクエストの本文を送信する。7.7.クライアントが接続が早々に終了したことを確認した場合は、リクエストが受理されるか、エラー応答を受信するか、ユーザーが焦ってリトライ処理を終了するまで、ステップ1から繰り返す。どの時点でもエラーステータスを受け取った場合、クライアントは -続行すべきではなく[SHOULD NOT]、 リクエストメッセージの送信が完了していない場合は接続を閉じるべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">別のプリンシパルがプリンシパルがアクセスしたいリソースをロックした場合、第二のプリンシパルが第一のプリンシパルが誰であるかを知ることができると便利です。この目的のために DAV:lockdiscovery プロパティが提供されています。このプロパティは、すべての未解決のロックをリストアップし、そのタイプを記述し、ロックトークンを提供してもよいでしょう(MAY)。LOCK メソッドをサポートする DAV 準拠のリソースはすべて DAV:lockdiscovery プロパティをサポートしなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">&lt;strong&gt;wd1&lt;/strong&gt;と&lt;strong&gt;wd1の&lt;/strong&gt;両方が定義されている場合、現在の平日が&lt;em&gt;順序付けられた&lt;/em&gt; 2つの平日の間にある場合、条件は真です。&lt;em&gt;境界&lt;/em&gt;は包括的です&lt;em&gt;が、境界は順序付けられてい&lt;/em&gt;ます。「GMT」パラメーターが指定されている場合、時刻はGMTであると見なされます。それ以外の場合は、ローカルのタイムゾーンが使用されます。</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">両方の場合は&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダと&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーが同じ応答で存在している、両方のポリシーが優先されます。 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; ポリシーがレポートを生成する間、 &lt;code&gt;Content-Security-Policy&lt;/code&gt; ヘッダーで指定されたポリシーが適用されますが、適用されません。</target>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">このディレクティブと &lt;code&gt;allowfullscreen&lt;/code&gt; 属性の両方が &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 要素に存在する場合、このディレクティブが優先されます。</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; が指定されていない場合、デフォルトでは、コンテンツはすべての言語の対象ユーザーを対象としています。複数の言語タグも可能であり、 &lt;code&gt;Content-Language&lt;/code&gt; ヘッダーをテキストドキュメントだけでなくさまざまなメディアタイプに適用することもできます。</target>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">ポートが指定されていない場合は、要求されたサービスのデフォルトポート(例えば、HTTP URLの場合は &quot;80 &quot;など)が暗示されます。</target>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">単一の値のみが指定されている場合（各カテゴリーから：日、月、年）、関数はその指定に一致する日にのみtrue値を返します。両方の値が指定されている場合&lt;em&gt;、境界&lt;/em&gt;を含むそれらの時間の間の結果はtrueです&lt;em&gt;が、境界は順序付けられ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">単一の値のみが指定されている場合（各カテゴリーから：時間、分、秒）、関数はその指定に一致する場合にのみ真の値を返します。両方の値が指定されている場合&lt;em&gt;、境界&lt;/em&gt;を含むそれらの時間の間の結果はtrueです&lt;em&gt;が、境界は順序付けられ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">パラメータが1つだけ指定された場合、関数はパラメータが表す平日にtrueを返します。2番目のパラメータとして文字列 &quot;GMT&quot; が指定された場合、時刻はGMTとみなされます。それ以外の場合は、ローカルタイムゾーンであるとみなされます。</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">複数の範囲が返送される場合、&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;multipart/byteranges&lt;/code&gt; に設定され、各フラグメントは1つの範囲をカバーし、&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;はそれを記述します。</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">サイトが &lt;code&gt;Accept-Ranges&lt;/code&gt; ヘッダーを省略した場合、それらはおそらく部分的なリクエストをサポートしません。一部のサイトでは、値として「 &lt;code&gt;none&lt;/code&gt; 」を明示的に送信しており、サポートがないことを示しています。その場合、一部のアプリでは、ダウンロードマネージャーが一時停止ボタンを無効にします。</target>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">Basic」認証スキームを使用している場合、クレデンシャルはこのように構成されます。</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">場合は&lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; HTTPレスポンスに存在している（と、その値が「ではないん &lt;code&gt;none&lt;/code&gt; 」）、サーバーがサポートは、要求の範囲。たとえば、&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;リクエストとcURLを発行してこれを確認できます。</target>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">ヘッダーが応答に含まれている場合でも、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;ユーザーエージェント&lt;/a&gt;がこのヘッダーに指定された値を検出できない場合、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">CORS構成が正しく設定されていない場合、ブラウザーコンソールに &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; ようなエラーが表示され、CORSセキュリティに違反したために要求がブロックされたことを示しますルール。ただし、これは必ずしもセットアップの間違いではない可能性があります。ユーザーのウェブアプリケーションとリモートの外部サービスによって、リクエストが実際に意図的に拒否されている可能性があります。ただし、エンドポイントを使用できるようにする場合は、成功するためにいくつかのデバッグが必要です。</target>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">属性が緩く設定されている場合、同じサイトのクッキーは、画像やフレームを読み込むための呼び出しなどのクロスドメインのサブリクエストでは保留されますが、ユーザーがリンクをたどるなどして外部サイトからURLにナビした場合には送信されます。</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">クライアントが条件付きGETリクエストを実行し、アクセスは許可されているが、ドキュメントが変更されていない場合、サーバーはこのステータスコードで応答する必要があります（SHOULD）。 304応答にはメッセージ本文を含めることはできません。したがって、常にヘッダーフィールドの後の最初の空行で終了します。応答には次のヘッダーフィールドを含める必要があり&lt;a href=&quot;#section-14.18.1&quot;&gt;ます。-セクション14.18.1で&lt;/a&gt;省略が必要な場合を除いて、日付。 クロックレスオリジンサーバーがこれらのルールに従い、プロキシとクライアントが独自の日付を、応答なしで受信した応答に追加した場合（すでに&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068]、セクション14.19&lt;/a&gt;）、キャッシュは正しく動作します。 -ヘッダーが同じリクエストへの200応答で送信された場合、ETagおよび/またはContent-Location-Expires、Cache-Control、および/またはVary、以前の応答で送信されたものとフィールド値が異なる場合同じバリアントの場合条件付きGETが強力なキャッシュバリデーターを使用した場合（&lt;a href=&quot;#section-13.3.3&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3を&lt;/a&gt;参照））、応答には他のエンティティヘッダーを含めないでください。それ以外の場合（つまり、条件付きGETが弱いバリデーターを使用した場合）、応答に他のエンティティヘッダーを含めてはなりません（MUST NOT）。これにより、キャッシュされたエンティティ本体と更新されたヘッダーの間の不整合が防止されます。304応答が、現在キャッシュされていないエンティティを示している場合、キャッシュは応答を無視し、条件なしで要求を繰り返す必要があります。キャッシュが受信した304応答を使用してキャッシュエントリを更新する場合、キャッシュはエントリを更新して、応答で指定された新しいフィールド値を反映する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 応答を受け取ったクライアントがTLSにアップグレードできる場合、クライアントが開始したTLSへのアップグレードで説明した同じプロセスを&lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;開始する必要があります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">データがテキストの場合、テキストを埋め込むことができます（適切なエンティティを使用するか、囲んでいるドキュメントのタイプに基づいてエスケープします）。それ以外の場合は、 &lt;code&gt;base64&lt;/code&gt; を指定して、base64でエンコードされたバイナリデータを埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">「Mobi」のマークが付いていないほどデバイスが大きい場合は、デスクトップサイトを提供する必要があります（ベストプラクティスとして、タッチスクリーンが表示されるデスクトップマシンが増えるため、とにかくタッチ入力をサポートする必要があります）。</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">ハッシュが一致しない場合、ドキュメントが &lt;code&gt; Precondition Failed&lt;/code&gt; 編集されており、&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; Precondition Failedエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">リクエストが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;を使用して発行されている場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;true&lt;/code&gt; に設定していないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">要求されたメソッドがサポートされていない場合、サーバはエラーで応答します。</target>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">特定のURLのリソースが変更された場合、新しい &lt;code&gt;Etag&lt;/code&gt; 値を生成する必要があります。したがって、etagsは指紋に似ており、一部のサーバーでは追跡目的で使用されることもあります。それらを比較することで、リソースの2つの表現が同じであるかどうかをすばやく判別できますが、追跡サーバーによって無期限に永続化するように設定することもできます。</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">リソースが変更された場合、サーバーは、リクエストが条件付きではなく、クライアントがこの新しいリソースを使用（およびキャッシュ）する場合と同様に、リソースの新しいバージョンで&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 応答を返します。</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">リソースが変更されていない場合、サーバーは&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 応答を返します。これにより、キャッシュが再びフレッシュになり、クライアントはキャッシュされたリソースを使用します。一部のリソースを消費する応答/要求のラウンドトリップがありますが、これは、リソース全体を再びネットワーク経由で送信するよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">問題のリソースが広くアクセスされることを意図している場合（GETによってアクセスされるHTTPリソースと同様に）、リソースが&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;やHTTP などの資格情報を必要とし&lt;strong&gt;ない限り&lt;/strong&gt;、&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; ヘッダーを送り返すだけで十分です。認証情報。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">リソースをリクエスタドメインに基づいて制限する必要がある場合、&lt;strong&gt;または&lt;/strong&gt;リソースに認証情報でアクセスする必要がある場合（または認証情報を設定する場合）、リクエストの&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダーによるフィルタリングが必要になるか、少なくともリクエスタの &lt;code&gt;Origin&lt;/code&gt; をエコーバックする必要があります（例：&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; : //arunranga.com）。さらに、&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; ヘッダーを送信する必要があります。これについては、&lt;a href=&quot;#Credentialed_Requests&quot;&gt;次のセクションで&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; リクエストの結果が、&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;リクエスト後にキャッシュされたリソースが古くなっていることを示している場合、 &lt;code&gt;GET&lt;/code&gt; リクエストが行われていなくても、キャッシュは無効になります。</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">応答の最適な表現の選択がサーバーにあるアルゴリズムによって行われる場合、それはサーバー駆動のネゴシエーションと呼ばれます。選択は、応答の利用可能な表現（変化する可能性のある次元、たとえば言語、コンテンツコーディングなど）と、要求メッセージ内の特定のヘッダーフィールドの内容、または要求に関連するその他の情報（たとえば、クライアントのネットワークアドレスとして）。サーバー主導のネゴシエーションは、利用可能な表現から選択するためのアルゴリズムをユーザーエージェントに説明することが難しい場合、またはサーバーが最初の応答と一緒にその「最良の推測」をクライアントに送信することを望む場合に有利です（ 「最良の推測」の場合、後続のリクエストの往復遅延ユーザーにとって十分です）。サーバーの推測を改善するために、ユーザーエージェントは、そのような応答の設定を記述する要求ヘッダーフィールド（Accept、Accept-Language、Accept-Encodingなど）を含めることができます（MAY）。サーバー主導のネゴシエーションには欠点があります。1。ユーザーエージェントの機能と応答の使用目的の両方について完全な知識が必要になるため、サーバーが特定のユーザーにとって何が「最適」かを正確に判断することは不可能です。 （例えば、ユーザーはそれを画面に表示したり、紙に印刷したりしますか？） 2。ユーザーエージェントにすべてのリクエストでその機能を説明させることは非常に非効率的であり（応答のごく一部のみが複数の表現を持つ場合）、ユーザーのプライバシーの潜在的な違反となる可能性があります。 3.オリジンサーバーの実装と、要求に対する応答を生成するためのアルゴリズムが複雑になります。 4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。4.複数のユーザーの要求に対して同じ応答を使用するパブリックキャッシュの機能が制限される場合があります。 HTTP / 1.1には、ユーザーエージェント機能とユーザー設定の説明を通じてサーバー主導のネゴシエーションを有効にするための次のリクエストヘッダーフィールドが含まれています。&lt;a href=&quot;#section-14.1&quot;&gt;セクション14.1&lt;/a&gt;）、Accept- Charset（&lt;a href=&quot;#section-14.2&quot;&gt;セクション14.2&lt;/a&gt;）、Accept-Encoding（&lt;a href=&quot;#section-14.3&quot;&gt;セクション14.3&lt;/a&gt;）、Accept- Language（&lt;a href=&quot;#section-14.4&quot;&gt;セクション14.4&lt;/a&gt;）、およびUser-Agent（&lt;a href=&quot;#section-14.43&quot;&gt;セクション14.43&lt;/a&gt;）。ただし、オリジンサーバーはこれらのディメンションに限定されず、リクエストヘッダーフィールドの外側またはこの仕様で定義されていない拡張ヘッダーフィールド内の情報を含む、リクエストのあらゆる側面に基づいて応答を変更する場合があります。Varyヘッダーフィールドは、サーバー主導のネゴシエーションの対象となる表現を選択するためにサーバーが使用するパラメーターを表すために使用できます。キャッシュによるVaryヘッダーフィールドの使用と&lt;a href=&quot;#section-14.44&quot;&gt;セクション14.44&lt;/a&gt;については、&lt;a href=&quot;#section-13.6&quot;&gt;セクション13.6&lt;/a&gt;を参照してください。 サーバーによるVaryヘッダーフィールドの使用。</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">サーバー&lt;em&gt;が&lt;/em&gt; TLSアップグレードをサポート&lt;em&gt;していない&lt;/em&gt;場合、またはその時点でTLSにアップグレードでき&lt;em&gt;ない&lt;/em&gt;場合、サーバー&lt;em&gt;は次の&lt;/em&gt;ような標準のHTTP / 1.1応答で応答します。</target>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">サーバー&lt;em&gt;が&lt;/em&gt; TLSアップグレードをサポートしており、アップグレードを許可する場合は、次のように &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 応答コードで応答します。</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">サーバーがCORSリクエストに&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;メソッドの使用を許可する場合、サーバーは&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;レスポンスヘッダーで応答します。このヘッダーには、 &lt;code&gt;DELETE&lt;/code&gt; とサポートする他のメソッドがリストされています。</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">サーバーが指定されたバージョンのWebSocketプロトコルを使用して通信できない場合、ヘッダーに &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; ヘッダーが含まれるエラー（426アップグレードが必要など）が返され、サポートされているコンマ区切りのリストが含まれます。プロトコルのバージョン。サーバーが要求されたプロトコルバージョンをサポートしていない場合、 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; ヘッダーは応答に含まれません。</target>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">サーバーが一致する文字セットを提供できない場合、理論上は&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（Not Acceptable）エラーコードを返すことができます。ただし、ユーザーエクスペリエンスを向上させるために、これが行われることはめったにありません。この場合、より一般的な方法は &lt;code&gt;Accept-Charset&lt;/code&gt; ヘッダーを無視することです。</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">サーバーが一致する言語を処理できない場合、理論的には&lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（受け入れられない）エラーコードを返すことができます。ただし、ユーザーエクスペリエンスを向上させるために、これはめったに行われません。この場合、より一般的な方法は &lt;code&gt;Accept-Language&lt;/code&gt; ヘッダーを無視することです。</target>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">サーバーに適切な選択肢がある場合は、&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;ヘッダーを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">サーバーが何らかの理由でHTTP / 2に切り替えることができない場合、サーバーは要求を通常どおり処理した後、標準のHTTP / 1応答で応答します。したがって、実際に存在するWebページをフェッチする要求の場合、ヘッダーの残りの部分に続くWebページを含む標準の &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 応答が返されます。サーバーがHTTP / 2に切り替えることができる場合、「 &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 応答が送信されます。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">サーバーが管理下にある場合は、要求サイトの起点を &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーの値に追加して、アクセスを許可する一連のドメインに追加します。</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">サーバーが（ &quot; &lt;code&gt;*&lt;/code&gt; &quot;ワイルドカードではなく）明示的な &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; であるAccess-Control-Allow-Origin値を含む応答を送信する場合、応答には、値 &lt;code&gt;Origin&lt;/code&gt; を持つ&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;応答ヘッダーも含まれ、ブラウザーに示されます。サーバーの応答は、 &lt;code&gt;Origin&lt;/code&gt; リクエストヘッダーの値によって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">サーバーが &quot; &lt;code&gt;*&lt;/code&gt; &quot;ワイルドカードではなく単一の起点を指定する場合、サーバーは&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;応答ヘッダーに &lt;code&gt;Origin&lt;/code&gt; も含める必要があります。これは、サーバー応答が&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;要求ヘッダーの値に基づいて異なることをクライアントに示します。</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">サーバーが範囲要求をサポートしている場合は、&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;ヘッダーを使用してそのような要求を発行できます。サーバーが返す必要があるドキュメントの部分を示します。</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">サーバーがより高速なWebサイトまたはアプリケーションの応答を望む場合、サーバーがより多くの接続を強制的に開くことが可能です。たとえば、すべてのリソースを同じドメイン（たとえば &lt;code&gt;www.example.com&lt;/code&gt; ）に &lt;code&gt;www1.example.com&lt;/code&gt; 、複数のドメイン（www1.example.com、 &lt;code&gt;www2.example.com&lt;/code&gt; 、 &lt;code&gt;www3.example.com&lt;/code&gt; )に分割できます。これらの各ドメインは&lt;em&gt;同じ&lt;/em&gt;サーバーに解決され、Webブラウザーはそれぞれに6つの接続を開きます（この例では、接続を18に増やします）。この手法は&lt;em&gt;ドメインシャーディング&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">CORSリクエストを使用してコードがアクセスしているサービスが管理下にある場合は、その &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーにオリジンを含めるように設定されていること、およびそのようなヘッダーが1つだけレスポンスに含まれていることを確認してください。ヘッダー自体は、起点のコンマ区切りのリストを受け入れるため、新しい起点の追加は難しくありません。</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">文字列が NULL の場合、プロキシは使用されません。</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">ターゲットリソースに現在の表現があり、その表現が囲まれた表現の状態に従って正常に変更された場合、配信元サーバーは&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）または&lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;No Content&lt;/code&gt; ）応答のいずれかを送信して、リクエスト。</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">ターゲットリソースに現在の表現がなく、 &lt;code&gt;PUT&lt;/code&gt; リクエストがそれを正常に作成した場合、オリジンサーバーは&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;Created&lt;/code&gt; ）応答を送信してユーザーエージェントに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">TLSへのアップグレードが成功すると、サーバーは前のセクションで説明したように &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 応答します。アップグレードが失敗した場合、HTTP / 1.1接続は失敗します。</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">ローカルドメインに属しているがファイアウォールの外側にあり、プロキシサーバー経由でのみ到達可能なホスト（メインWebサーバーなど）がある場合、これらの例外は &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 関数を使用して処理できます。</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">セミコロンで区切られた設定が複数ある場合、Firefox がプロキシとの接続に失敗するまでは、一番左の設定が使用されます。その場合、次の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">他のディレクティブが指定されている場合、 &lt;code&gt;default-src&lt;/code&gt; はそれらに影響を与えません。次のヘッダー</target>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">応答に「max-age」または「s-maxage」ディレクティブを含む&lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt;ヘッダーがある場合、 &lt;code&gt;Expires&lt;/code&gt; ヘッダーは無視されます。</target>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">範囲が1つしかない場合は、応答全体の&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;がドキュメントのタイプに設定され、&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;が提供されます。</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">このディレクティブがない場合、ユーザーエージェントは最初に&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探し、次に&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探し、最後に&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探して、ワーカーの実行を制御します。</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">このディレクティブがない場合、ユーザーエージェントは&lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt;ディレクティブを探します（これは&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;ディレクティブにフォールバックします）。</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">このヘッダが https://example.com/clear-cookies でのレスポンスで配信された場合、同じドメイン https://example.com 上のすべてのクッキーと、サブドメイン(https://stage.example.com など)上のすべてのクッキーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">このオプションのパラメータを指定すると、ピンの検証に失敗した場合は、指定された URL に報告されます。</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">このオプションのパラメータを指定した場合、このルールはサイトのすべてのサブドメインにも適用されます。</target>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;サーバー送信イベント&lt;/a&gt;を使用する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;false&lt;/code&gt; （デフォルト値）であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;を使用する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;&quot;omit&quot;&lt;/code&gt; であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">サードパーティのCookieを開示していない場合、Cookieの使用が発見されると、消費者の信頼が損なわれる可能性があります。（プライバシーポリシーなどの）明確な開示は、Cookieの検出による悪影響を排除する傾向があります。一部の国ではCookieに関する法律もあります。たとえば、ウィキメディア財団の&lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;Cookieステートメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">ロボットユーザーエージェント（クローラーなど）を実行している場合は、 &lt;code&gt;From&lt;/code&gt; ヘッダーを送信する必要があります。これにより、ロボットが過剰な要求、望ましくない要求、または無効な要求を送信しているなど、サーバーで問題が発生した場合に連絡できます。</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">この状態が一時的なものか永続的なものかわからない場合は、代わりに&lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt;ステータスコードを使用してください。</target>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">一時的なリダイレクトを設定したくない場合は、追加のパラメーター（使用するHTTPステータスコードまたは &lt;code&gt;permanent&lt;/code&gt; キーワード）を使用して、別のリダイレクトを設定できます。</target>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">WebSocket接続を最初から作成する必要がある場合は、ハンドシェイクプロセスを自分で処理する必要があります。最初のHTTP / 1.1セッションを作成した後、次のように、標準リクエストに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;ヘッダーと&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを追加して、アップグレードをリクエストする必要があります。</target>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">このディレクティブを使ってスクリプトやスタイルに SRI を要求するようにサイトを設定している場合。</target>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;deny&lt;/code&gt; を指定すると、他のサイトからロードされたときにフレーム内のページをロードしようとすると失敗するだけでなく、同じサイトからロードされたときに失敗します。一方、 &lt;code&gt;sameorigin&lt;/code&gt; を指定した場合、ページをフレームで提供しているサイトがページを提供しているサイトと同じである限り、フレームでページを使用できます。</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">それでもレポートを受け取りたいが、ポリシーを適用したい場合は、&lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;ディレクティブで&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーを使用します。</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">クライアントが他のヘッダーにアクセスできるようにするには、 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; ヘッダーを使用してそれらを一覧表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">ユーザーエージェント検出を使用しないようにしたい場合は、場合によってはオプションがあります!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">アプリケーション、サーバー、またはプロキシが標準化された &lt;code&gt;Forwarded&lt;/code&gt; ヘッダーをサポートしている場合、&lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt;ヘッダーを置き換えることができます。IPv6アドレスは引用符で囲まれ、 &lt;code&gt;Forwarded&lt;/code&gt; では角括弧で囲まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">代わりに、サーバーの動作を調整する必要がある場合は、 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; の値を変更して、クライアントの読み込み元へのアクセスを許可する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">If-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">If-None-None-Match (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">If-None-None-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">If-Range (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">If-Range (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">If-Range (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
        <trans-unit id="bd06e3f28f4c3da6f75241cead3ad85962385407" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 2616)</source>
          <target state="translated">If-Unmodified-Since (RFC2616)</target>
        </trans-unit>
        <trans-unit id="dc5f0278046c847aae6cb54bbb6bf9f7d5e45609" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 7232)</source>
          <target state="translated">If-Unmodified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ae9940a55ac6950c887c90446b032a2b825302da" translate="yes" xml:space="preserve">
          <source>If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
       [&quot;I am an ETag&quot;])
       ([&quot;I am another ETag&quot;])

   The previous header would require that the resource identified in the
   Request-URI be locked with the specified lock token and be in the
   state identified by the &quot;I am an ETag&quot; ETag or in the state
   identified by the second ETag &quot;I am another ETag&quot;.

   To put the matter more plainly one can think of the previous If
   header as expressing the condition below:

     (
       is-locked-with(urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2) AND
       matches-etag(&quot;I am an ETag&quot;)
     )
     OR
     (
       matches-etag(&quot;I am another ETag&quot;)
     )</source>
          <target state="translated">次の場合：（&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; [&quot;I am an ETag&quot;]）（[&quot;I am another ETag&quot;]）前のヘッダーでは、Request- URIは指定されたロックトークンでロックされ、「I am an ETag」ETagで識別される状態、または2番目のETag「I am another ETag」で識別される状態になります。さらにわかりやすく言えば、前のIfヘッダーを以下の条件を表すものと考えることができます：（is-locked-with（urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2）AND matches-etag（ &quot; ETag &quot;））OR（matches-etag（&quot; I am another ETag &quot;））</target>
        </trans-unit>
        <trans-unit id="e179e2a27f46763d373e2f3b6cb41b4cc29be61b" translate="yes" xml:space="preserve">
          <source>If: (Not &amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
     &amp;lt;urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;)

   This If header requires that the resource must not be locked with a
   lock having the lock token
   urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 and must be locked by a
   lock with the lock token
   urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092.</source>
          <target state="translated">If：（&amp;lt;urn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; &amp;lt;urn：uuid：58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;ではない）このIfヘッダーは、リソースがロックトークンurn：uuid：181d4fae-7d8c-11d0-a765-00a0c91e6bf2であり、ロックトークンurn：uuid：58f202ac-22cf-11d1-b12d-002035b29092のロックによってロックされている必要があります。</target>
        </trans-unit>
        <trans-unit id="01602140e2a7c5c326242ee266afd5572f9bb02d" translate="yes" xml:space="preserve">
          <source>Image type</source>
          <target state="translated">画像の種類</target>
        </trans-unit>
        <trans-unit id="6ae89c7f31fe68afd0052be4204a1384141e4bde" translate="yes" xml:space="preserve">
          <source>Image types</source>
          <target state="translated">画像の種類</target>
        </trans-unit>
        <trans-unit id="7769fde23e24138d1e8d5303368e943a1ccb83f4" translate="yes" xml:space="preserve">
          <source>Images may load from anywhere (note the &quot;*&quot; wildcard).</source>
          <target state="translated">画像はどこからでも読み込むことができます(ワイルドカード「*」に注意)。</target>
        </trans-unit>
        <trans-unit id="4c18ce69b9abb0f85c6c4dd561b8fa929e369a90" translate="yes" xml:space="preserve">
          <source>Images/video frames drawn to a canvas using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt;&lt;code&gt;drawImage()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt; &lt;code&gt;drawImage()&lt;/code&gt; &lt;/a&gt;を使用してキャンバスに描画された画像/ビデオフレーム。</target>
        </trans-unit>
        <trans-unit id="f257a0723093d9a811b4ad768559384cb6bd8ec4" translate="yes" xml:space="preserve">
          <source>Implementation notes for applications, vendors, and extensions</source>
          <target state="translated">アプリケーション、ベンダー、拡張機能の実装ノート</target>
        </trans-unit>
        <trans-unit id="da02a5e4655c1c65c2babb044e19b5d72a9968f1" translate="yes" xml:space="preserve">
          <source>Implementation-specific header that may have various effects anywhere along the request-response chain. Used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; header is not yet present.</source>
          <target state="translated">要求/応答チェーンのどこにでもさまざまな影響を与える可能性がある実装固有のヘッダー。 &lt;code&gt;Cache-Control&lt;/code&gt; ヘッダーがまだ存在しないHTTP / 1.0キャッシュとの下位互換性のために使用されます。</target>
        </trans-unit>
        <trans-unit id="e1eb8fc6775c68df3e1147c016e8f5a910aa93c4" translate="yes" xml:space="preserve">
          <source>Implementations of HTTP origin servers SHOULD be careful to restrict
   the documents returned by HTTP requests to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs directly into file system calls, the server MUST take
   special care not to serve files that were not intended to be
   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and
   other operating systems use &quot;..&quot; as a path component to indicate a
   directory level above the current one. On such a system, an HTTP
   server MUST disallow any such construct in the Request-URI if it
   would otherwise allow access to a resource outside those intended to
   be accessible via the HTTP server. Similarly, files intended for
   reference only internally to the server (such as access control
   files, configuration files, and script code) MUST be protected from
   inappropriate retrieval, since they might contain sensitive
   information. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security risks.</source>
          <target state="translated">HTTPオリジンサーバーの実装は、HTTPリクエストによって返されるドキュメントを、 サーバー管理者によって意図されたものだけに制限するように注意すべきである[SHOULD]。HTTPサーバーがHTTP URIを直接ファイルシステムの呼び出しに変換する場合、サーバーはHTTPクライアントに配信されることを意図していないファイルを提供しないように特別な注意を払わなければならない[MUST]。例えば、UNIX、Microsoft Windows、その他のオペレーティングシステムでは、現在のディレクトリレベルより上のディレクトリレベルを示すパスコンポーネントとして「...」を使用しています。そのようなシステムでは、HTTPサーバは、HTTPサーバを介してアクセスすることを意図したリソース以外のリソースへのアクセスを許可する場合、Request-URI中のそのような構成を許可しないようにしなければならない[MUST](MUST)。同様に、サーバ内部でのみ参照することを目的としたファイル (アクセス制御ファイル、設定ファイル、スクリプトコードなど)は、機密情報を含んでいる可能性があるため、不適切な取得から保護されなければなりません[MUST]。経験上、このような HTTP サーバの実装における些細なバグがセキュリティ上のリスクとなっていることが示されています。</target>
        </trans-unit>
        <trans-unit id="14daa0dc1eaa5670a20dd5d15e7e163107880fe7" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header in Firefox 4.</source>
          <target state="translated">Firefox 4 で X-Content-Security-Policy ヘッダとして実装。</target>
        </trans-unit>
        <trans-unit id="603ce634b762f92f6e05c3f3e6b9b238a85f5318" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header, only supporting 'sandbox' directive.</source>
          <target state="translated">X-Content-Security-Policy ヘッダとして実装され、'sandbox' ディレクティブのみをサポート。</target>
        </trans-unit>
        <trans-unit id="3b13dd24d3dc6eaf8faafe83a8f22898c5b86d5d" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Chrome 14.</source>
          <target state="translated">Chrome 14 で X-Webkit-CPP ヘッダとして実装。</target>
        </trans-unit>
        <trans-unit id="b0eba0ad36d67027ac7933274e7042a9d3fc6e6f" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Safari 6.</source>
          <target state="translated">Safari 6 で X-Webkit-CPP ヘッダとして実装。</target>
        </trans-unit>
        <trans-unit id="cb60fa324f738059434ec9f563fd92bd6eb364fe" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in iOS 5.1.</source>
          <target state="translated">iOS 5.1でX-Webkit-CPPヘッダとして実装されました。</target>
        </trans-unit>
        <trans-unit id="60d472d41f188e74df2d9f7da2711afae460cd86" translate="yes" xml:space="preserve">
          <source>Implementers are advised to pay attention to cache controls and to
   make use of the mechanisms available in HTTP when editing Resources,
   in particular, entity-tags as outlined in [&lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;].
   Clients are not assured to receive the most recent representations of
   Collection Members using GET if the server is authorizing
   intermediaries to cache them.</source>
          <target state="translated">実装者は、キャッシュコントロールに注意を払い、リソースを編集するときにHTTPで利用可能なメカニズム、特に[ &lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ]で概説されているエンティティタグを利用することをお勧めします。サーバーが仲介者にそれらをキャッシュすることを許可している場合、クライアントはGETを使用してコレクションメンバーの最新の表現を受け取ることが保証されていません。</target>
        </trans-unit>
        <trans-unit id="e3af5ce8ec47b166e13f8ce8cbe13ad9af1cdf60" translate="yes" xml:space="preserve">
          <source>Implementors should be aware that the software represents the user in
   their interactions over the Internet, and should be careful to allow
   the user to be aware of any actions they might take which may have an
   unexpected significance to themselves or others.

   In particular, the convention has been established that the GET and
   HEAD methods SHOULD NOT have the significance of taking an action
   other than retrieval. These methods ought to be considered &quot;safe&quot;.
   This allows user agents to represent other methods, such as POST, PUT
   and DELETE, in a special way, so that the user is made aware of the
   fact that a possibly unsafe action is being requested.

   Naturally, it is not possible to ensure that the server does not
   generate side-effects as a result of performing a GET request; in
   fact, some dynamic resources consider that a feature. The important
   distinction here is that the user did not request the side-effects,
   so therefore cannot be held accountable for them.</source>
          <target state="translated">実装者は、ソフトウェアがインターネット上でのインタラクションにおいてユーザを代表するものであることを認識し、ユーザが自分自身や他の人にとって予期せぬ意味を持つ可能性のあるアクションを取ることを意識させるように注意すべきである。特に、GETメソッドとHEADメソッドは、検索以外のアクションを取ることに意味を持つべきではないという慣習が確立されています[SHOULD NOT]。これらのメソッドは &quot;安全 &quot;であると考えるべきです。これにより、ユーザエージェントは、POST、PUT、DELETEのような他のメソッドを特別な方法で表現することができ、安全でない可能性のあるアクションが要求されているという事実をユーザに認識させることができます。当然のことながら、サーバが GET リクエストを実行した結果として副作用が発生しないことを保証することはできません;実際、ダイナミックリソースの中にはそれを機能と考えるものもあります。ここでの重要な違いは、ユーザは副作用を要求しなかったので、その責任を負うことができないということです。</target>
        </trans-unit>
        <trans-unit id="9f5bcb265afe8c10a0333f200168f39077ccb2a2" translate="yes" xml:space="preserve">
          <source>Importance of setting the correct MIME type</source>
          <target state="translated">正しい MIME タイプを設定することの重要性</target>
        </trans-unit>
        <trans-unit id="50b4adf7a95c03b87b497db3ec73f7756f713782" translate="yes" xml:space="preserve">
          <source>Important MIME types for Web developers</source>
          <target state="translated">ウェブ開発者にとって重要な MIME タイプ</target>
        </trans-unit>
        <trans-unit id="a9147f5aaafb06475c8b837fee41cebfad64027d" translate="yes" xml:space="preserve">
          <source>Improved connection management allows considerable boosting of performance in HTTP. With HTTP/1.1 or HTTP/1.0, using a persistent connection &amp;ndash; at least until it becomes idle &amp;ndash; leads to the best performance. However, the failure of pipelining has lead to designing superior connection management models, which have been incorporated into HTTP/2.</source>
          <target state="translated">接続管理の改善により、HTTPのパフォーマンスが大幅に向上します。HTTP / 1.1またはHTTP / 1.0では、少なくともアイドル状態になるまで持続的な接続を使用すると、最高のパフォーマンスが得られます。ただし、パイプライン化の失敗により、HTTP / 2に組み込まれた優れた接続管理モデルが設計されました。</target>
        </trans-unit>
        <trans-unit id="ed3056eb7dfdbbf414ed2c77758a13ddb4dea4dc" translate="yes" xml:space="preserve">
          <source>In 1989, while he was working at CERN, Tim Berners-Lee wrote a proposal to build a hypertext system over the Internet. Initially calling it the &lt;em&gt;Mesh&lt;/em&gt;, it was later renamed to &lt;em&gt;World Wide Web&lt;/em&gt; during its implementation in 1990. Built over the existing TCP and IP protocols, it consisted of 4 building blocks:</source>
          <target state="translated">1989年、CERNで働いていた間、ティムバーナーズリーはインターネット上でハイパーテキストシステムを構築する提案を書きました。最初は&lt;em&gt;Mesh&lt;/em&gt;と呼ばれていましたが、1990年の実装時に後に&lt;em&gt;World Wide Web&lt;/em&gt;に名前が変更されました。既存のTCPおよびIPプロトコル上に構築され、4つのビルディングブロックで構成されていました。</target>
        </trans-unit>
        <trans-unit id="bc75911a51c61595cb9f9517b6870c9ae4a76b47" translate="yes" xml:space="preserve">
          <source>In 200 (OK) responses to GET or HEAD, an origin server:

   o  SHOULD send an entity-tag validator unless it is not feasible to
      generate one.

   o  MAY send a weak entity-tag instead of a strong entity-tag, if
      performance considerations support the use of weak entity-tags, or
      if it is unfeasible to send a strong entity-tag.

   o  SHOULD send a Last-Modified value if it is feasible to send one.

   In other words, the preferred behavior for an origin server is to
   send both a strong entity-tag and a Last-Modified value in successful
   responses to a retrieval request.

   A client:

   o  MUST send that entity-tag in any cache validation request (using
      If-Match or If-None-Match) if an entity-tag has been provided by
      the origin server. 

   o  SHOULD send the Last-Modified value in non-subrange cache
      validation requests (using If-Modified-Since) if only a
      Last-Modified value has been provided by the origin server.

   o  MAY send the Last-Modified value in subrange cache validation
      requests (using If-Unmodified-Since) if only a Last-Modified value
      has been provided by an HTTP/1.0 origin server.  The user agent
      SHOULD provide a way to disable this, in case of difficulty.

   o  SHOULD send both validators in cache validation requests if both
      an entity-tag and a Last-Modified value have been provided by the
      origin server.  This allows both HTTP/1.0 and HTTP/1.1 caches to
      respond appropriately.</source>
          <target state="translated">GETまたはHEADに対する200(OK)応答では、オリジンサーバーは以下のことを行 うべきである[SHOULD]。 o エンティティタグバリデータを生成することが不可能でない限り、エンティティタグ バリデータを送るべきである[SHOULD]。 o パフォーマンス上の考慮事項が弱いエンティティタグの使用をサポートする場合、または強い エンティティタグを送ることが現実的でない場合、強いエンティティタグの代わりに弱い エンティティタグを送ってもよい[MAY]。言い換えれば、オリジンサーバーにとって好ましい動作は、検索リクエストに対する 成功した応答において、強いエンティティタグとLast-Modified値の両方を 送ることである。クライアント:o エンティティタグがオリジンサーバーによって提供された場合、そのエンティティタ グを(If-MatchまたはIf-None-Matchを使用して)すべてのキャッシュ検証リクエス トで送らなければならない[MUST]。 o Last-Modified値のみがオリジンサーバーによって提供された場合、非サブレンジ キャッシュ検証リクエスト(If-Modified-Sinceを使用して)でLast-Modified値 を送るべきである[SHOULD]。 o Last-Modified値のみがHTTP/1.0オリジンサーバーによって提供された場合、 サブレンジキャッシュ検証リクエスト(If-Unmodified-Sinceを使用して)でLast-Modified 値を送ってもよい[MAY]。ユーザーエージェントは、困難な場合にはこれを無効にする方法を提供すべきである[SHOULD]。 o エンティティタグとLast-Modified値の両方がオリジンサーバーによって提供されている場合、 キャッシュ検証リクエストで両方のバリデータを送るべきである[SHOULD]。これにより、HTTP/1.0 と HTTP/1.1 キャッシュの両方が適切に応答できるようになります。</target>
        </trans-unit>
        <trans-unit id="296574e47729d1eae5c728c2cee0ace56802d4ed" translate="yes" xml:space="preserve">
          <source>In 2000, a new pattern for using HTTP was designed: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;representational state transfer&lt;/a&gt; (or REST). The actions induced by the API were no more conveyed by new HTTP methods, but only by accessing specific URIs with basic HTTP/1.1 methods. This allowed any Web application to provide an API to allow retrieval and modification of its data without having to update the browsers or the servers: all what is needed was embedded in the files served by the Web sites through standard HTTP/1.1. The drawback of the REST model resides in the fact that each website defines its own non-standard RESTful API and has total control on it; unlike the *DAV extensions were clients and servers are interoperable. RESTful APIs became very common in the 2010s.</source>
          <target state="translated">2000年に、HTTPを使用するための新しいパターンである、Representational &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;State&lt;/a&gt; Transfer （REST）が設計されました。 APIによって引き起こされたアクションは、新しいHTTPメソッドでは伝達されず、基本的なHTTP / 1.1メソッドで特定のURIにアクセスすることによってのみ伝達されました。これにより、すべてのWebアプリケーションがAPIを提供して、ブラウザーやサーバーを更新せずにデータを取得および変更できるようになりました。必要なものはすべて、標準のHTTP / 1.1を介してWebサイトによって提供されるファイルに埋め込まれていました。 RESTモデルの欠点は、各Webサイトが独自の非標準RESTful APIを定義し、それを完全に制御できることです。 * DAV拡張とは異なり、クライアントとサーバーは相互運用可能です。 RESTful APIは2010年代に非常に一般的になりました。</target>
        </trans-unit>
        <trans-unit id="97be88d1cc954daadbfa1c4539779b9d17810aba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;, a preflight request with the &lt;code&gt;OPTIONS&lt;/code&gt; method is sent, so that the server can respond whether it is acceptable to send the request with these parameters. The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">で&lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;、とプリフライトリクエスト &lt;code&gt;OPTIONS&lt;/code&gt; の方法は、サーバがこれらのパラメータを使用して要求を送信するために許容可能であるかどうか対応できるよう、送信されます。&lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;ヘッダは、実際の要求が送信されるとき、それはして送信されることをプリフライトリクエストの一部としてサーバに通知 &lt;code&gt;POST&lt;/code&gt; のリクエスト方法。&lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;の実際の要求が送られたとき、それはして送信されることを見出し通知サーバー &lt;code&gt;X-PINGOTHER&lt;/code&gt; と &lt;code&gt;Content-Type&lt;/code&gt; カスタムヘッダ。サーバーは、これらの状況下で要求を受け入れたいかどうかを判断する機会を得ました。</target>
        </trans-unit>
        <trans-unit id="22094d906cb0cb930d1261041451d23d682d9443" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;, &lt;em&gt;&lt;strong&gt;content negotiation&lt;/strong&gt;&lt;/em&gt; is the mechanism that is used for serving different representations of a resource at the same URI, so that the user agent can specify which is best suited for the user (for example, which language of a document, which image format, or which content encoding).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;、&lt;em&gt;&lt;strong&gt;コンテンツネゴシエーションは、&lt;/strong&gt;&lt;/em&gt;ユーザエージェントが最良（例えば、その文書の言語、画像フォーマットのユーザに適しているかを指定することができるように、同じURIでリソースの異なる表現を提供するために使用される機構であります、またはどのコンテンツのエンコーディング）。</target>
        </trans-unit>
        <trans-unit id="6df737fe0a6a8b38fe1752df0541af98393864b5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;server-driven content negotiation&lt;/em&gt;, or proactive content negotiation, the browser (or any other kind of user-agent) sends several HTTP headers along with the URL. These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. The algorithm is server-specific and not defined in the standard. See, for example, the &lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2 negotiation algorithm&lt;/a&gt;.</source>
          <target state="translated">では&lt;em&gt;、サーバ主導のコンテンツネゴシエーション&lt;/em&gt;、または積極的なコンテンツネゴシエーション、ブラウザ（またはユーザーエージェントの他の種類）は、URLと一緒にいくつかのHTTPヘッダを送信します。これらのヘッダーは、ユーザーの望ましい選択を説明します。サーバーはそれらをヒントとして使用し、内部アルゴリズムがクライアントに提供する最適なコンテンツを選択します。アルゴリズムはサーバー固有であり、標準では定義されていません。たとえば、&lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2ネゴシエーションアルゴリズムを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b8513ce94ddf5be70926f38324a0c5067702e67d" translate="yes" xml:space="preserve">
          <source>In Firefox, the preference that disables CORS is &lt;code&gt;content.cors.disable&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; disables CORS, so whenever that's the case, CORS requests will always fail with this error.</source>
          <target state="translated">Firefoxでは、CORSを無効にする設定は &lt;code&gt;content.cors.disable&lt;/code&gt; です。これを &lt;code&gt;true&lt;/code&gt; に設定するとCORSが無効になるため、その場合は常に、CORSリクエストは常にこのエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="77ae93055516fe4030d75a83ef29b37fe614cda5" translate="yes" xml:space="preserve">
          <source>In HTTP, a redirection is triggered by the server by sending special responses to a request: &lt;em&gt;redirects&lt;/em&gt;. HTTP redirects are responses with a status code of &lt;code&gt;3xx&lt;/code&gt;. A browser, when receiving a redirect response, uses the new URL provided and immediately loads it: most of the time, the redirection is transparent to the user, besides a small performance hit.</source>
          <target state="translated">HTTPでは、リクエストに対して特別な応答を送信することにより、サーバーによってリダイレクトがトリガーされます：&lt;em&gt;redirects&lt;/em&gt;。HTTPリダイレクトは、ステータスコード &lt;code&gt;3xx&lt;/code&gt; の応答です。ブラウザは、リダイレクト応答を受信すると、提供された新しいURLを使用し、すぐにそれをロードします。ほとんどの場合、リダイレクトは、小さなパフォーマンスヒットを除いて、ユーザーに対して透過的です。</target>
        </trans-unit>
        <trans-unit id="37f3f173cc83c393621e6b6a49dbe5d27a1b2c33" translate="yes" xml:space="preserve">
          <source>In HTTP/1.0, each connection is established by the client prior to
   the request and closed by the server after sending the response.
   However, some implementations implement the explicitly negotiated
   (&quot;Keep-Alive&quot;) version of persistent connections described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;19.7.1 of [RFC2068]&lt;/a&gt;.

   Some clients and servers might wish to be compatible with these
   previous approaches to persistent connections, by explicitly
   negotiating for them with a &quot;Connection: keep-alive&quot; request header
   field.  However, some experimental implementations of HTTP/1.0
   persistent connections are faulty; for example, if an HTTP/1.0 proxy
   server doesn't understand Connection, it will erroneously forward
   that header field to the next inbound server, which would result in a
   hung connection.

   One attempted solution was the introduction of a Proxy-Connection
   header field, targeted specifically at proxies.  In practice, this
   was also unworkable, because proxies are often deployed in multiple
   layers, bringing about the same problem discussed above.

   As a result, clients are encouraged not to send the Proxy-Connection
   header field in any requests.

   Clients are also encouraged to consider the use of Connection:
   keep-alive in requests carefully; while they can enable persistent
   connections with HTTP/1.0 servers, clients using them will need to
   monitor the connection for &quot;hung&quot; requests (which indicate that the
   client ought stop sending the header field), and this mechanism ought
   not be used by clients at all when a proxy is being used.</source>
          <target state="translated">HTTP / 1.0では、各接続は要求の前にクライアントによって確立され、応答の送信後にサーバーによって閉じられます。ただし、一部の実装&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;では、[RFC2068]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;セクション&lt;/a&gt;19.7.1で説明されている永続的な接続の明示的にネゴシエートされた（ &quot;Keep-Alive&quot;）バージョンを実装しています。。一部のクライアントとサーバーは、 &quot;Connection：keep-alive&quot;リクエストヘッダーフィールドで明示的にネゴシエートすることにより、永続的な接続に対するこれらの以前のアプローチとの互換性を望む場合があります。ただし、HTTP / 1.0の永続的な接続の一部の実験的な実装には問題があります。たとえば、HTTP / 1.0プロキシサーバーが接続を認識しない場合、そのヘッダーフィールドは誤って次の受信サーバーに転送され、接続がハングします。解決策として試みられたのは、特にプロキシを対象としたProxy-Connectionヘッダーフィールドの導入でした。実際には、これも機能しませんでした。プロキシが複数のレイヤーに展開されることが多く、前​​述の同じ問題が発生するためです。結果として、クライアントは、リクエストでProxy-Connectionヘッダーフィールドを送信しないことをお勧めします。クライアントは、Connectionの使用を検討することもお勧めします。それらはHTTP / 1.0サーバーとの永続的な接続を有効にすることができますが、それらを使用するクライアントは「ハング」リクエスト（クライアントがヘッダーフィールドの送信を停止すべきであることを示す）の接続を監視する必要があり、このメカニズムはクライアントで使用されるべきではありません。プロキシが使用されている場合はすべて。リクエスト（クライアントがヘッダーフィールドの送信を停止する必要があることを示します）。このメカニズムは、プロキシが使用されているときはクライアントで使用されるべきではありません。リクエスト（クライアントがヘッダーフィールドの送信を停止する必要があることを示します）。このメカニズムは、プロキシが使用されているときはクライアントで使用されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="252a80be2932a5745af0ff3008231856ec0831a7" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, method parameter information was exclusively encoded in
   HTTP headers.  Unlike HTTP/1.1, WebDAV encodes method parameter
   information either in an XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) request entity body, or in
   an HTTP header.  The use of XML to encode method parameters was
   motivated by the ability to add extra XML elements to existing
   structures, providing extensibility; and by XML's ability to encode
   information in ISO 10646 character sets, providing
   internationalization support.

   In addition to encoding method parameters, XML is used in WebDAV to
   encode the responses from methods, providing the extensibility and
   internationalization advantages of XML for method output, as well as
   input.

   When XML is used for a request or response body, the Content-Type
   type SHOULD be application/xml.  Implementations MUST accept both
   text/xml and application/xml in request and response bodies.  Use of
   text/xml is deprecated.

   All DAV-compliant clients and resources MUST use XML parsers that are
   compliant with [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] and [&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;].  All XML used in either
   requests or responses MUST be, at minimum, well formed and use
   namespaces correctly.  If a server receives XML that is not well-
   formed, then the server MUST reject the entire request with a 400
   (Bad Request).  If a client receives XML that is not well-formed in a
   response, then the client MUST NOT assume anything about the outcome
   of the executed method and SHOULD treat the server as malfunctioning.

   Note that processing XML submitted by an untrusted source may cause
   risks connected to privacy, security, and service quality (see
   &lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).  Servers MAY reject questionable requests (even though
   they consist of well-formed XML), for instance, with a 400 (Bad
   Request) status code and an optional response body explaining the
   problem.</source>
          <target state="translated">HTTP / 1.1では、メソッドパラメータ情報はHTTPヘッダーでのみエンコードされていました。 HTTP / 1.1とは異なり、WebDAVはメソッドパラメータ情報をXML（[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]）リクエストエンティティボディ、またはHTTPヘッダー内。メソッドパラメータをエンコードするためのXMLの使用は、既存の構造に追加のXML要素を追加して拡張性を提供する機能が動機でした。また、ISO 10646文字セットで情報をエンコードするXMLの機能により、国際化をサポートします。メソッドパラメーターのエンコードに加えて、XMLはWebDAVでメソッドからの応答をエンコードするために使用され、メソッドの出力と入力にXMLの拡張性と国際化の利点を提供します。 XMLが要求または応答の本文に使用される場合、Content-Typeタイプはapplication / xmlである必要があります（SHOULD）。実装は、要求と応答の本文でtext / xmlとapplication / xmlの両方を受け入れる必要があります。 text / xmlの使用は非推奨です。すべてのDAV準拠のクライアントとリソースは、[に準拠したXMLパーサーを使用する必要があります。&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]および[ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt; ]。要求または応答で使用されるすべてのXMLは、少なくとも整形式であり、名前空間を正しく使用する必要があります。サーバーが整形式でないXMLを受信した場合、サーバーはリクエスト全体を400（Bad Request）で拒否する必要があります。クライアントが応答で整形式でないXMLを受信した場合、クライアントは実行されたメソッドの結果について何も想定してはならず（MUST NOT）、サーバーを誤動作として扱う必要があります（SHOULD）。信頼できないソースから送信されたXMLを処理すると、プライバシー、セキュリティ、サービス品質に関連するリスクが発生する可能性があることに注意してください（&lt;a href=&quot;#section-20&quot;&gt;セクション20を&lt;/a&gt;参照） ）。サーバーは、問題のあるリクエストを（適切なXMLで構成されていても）、たとえば、400（Bad Request）ステータスコードと、問題を説明するオプションのレスポンス本文で拒否する場合があります。</target>
        </trans-unit>
        <trans-unit id="04b117019d6e8bc547e56f34a1e382befb6df3b1" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, persistence is the default, and the header is no longer needed (but it is often added as a defensive measure against cases requiring a fallback to HTTP/1.0).</source>
          <target state="translated">HTTP/1.1では、persistenceがデフォルトで、ヘッダは不要になりました(ただし、HTTP/1.0へのフォールバックが必要な場合の防御策として追加されることが多いです)。</target>
        </trans-unit>
        <trans-unit id="7dad8ae742410e88380cfba396cb4fa1d4e9131d" translate="yes" xml:space="preserve">
          <source>In HTTP/2 - the &lt;code&gt;TE&lt;/code&gt; header field is only accepted if the &lt;code&gt;trailers&lt;/code&gt; value is set.</source>
          <target state="translated">HTTP / 2では、 &lt;code&gt;TE&lt;/code&gt; ヘッダーフィールドは、 &lt;code&gt;trailers&lt;/code&gt; 値が設定されている場合にのみ受け入れられます。</target>
        </trans-unit>
        <trans-unit id="bf70ecd71ae33feef50c75a643497aa1f8c4c6bc" translate="yes" xml:space="preserve">
          <source>In IIS, you use the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; element to configure redirections.</source>
          <target state="translated">IISでは、 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; 要素を使用してリダイレクトを構成します。</target>
        </trans-unit>
        <trans-unit id="a73ab14a2ec5bf02be9050f108c718d592c94a24" translate="yes" xml:space="preserve">
          <source>In Nginx, you create a specific server block for the content you want to redirect:</source>
          <target state="translated">Nginxでは、リダイレクトしたいコンテンツのために特定のサーバーブロックを作成します。</target>
        </trans-unit>
        <trans-unit id="24471cf4aea973802e7f0eb0517d9a17c92a5dcd" translate="yes" xml:space="preserve">
          <source>In PROPFIND responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well.

   200 OK - A property exists and/or its value is successfully returned.

   401 Unauthorized - The property cannot be viewed without appropriate
   authorization.

   403 Forbidden - The property cannot be viewed regardless of
   authentication.

   404 Not Found - The property does not exist.</source>
          <target state="translated">PROPFIND応答では、個々のプロパティに関する情報が 'propstat'要素（&lt;a href=&quot;#section-14.22&quot;&gt;セクション14.22を&lt;/a&gt;参照）内に返され、それぞれに表示されるプロパティに関する情報を含む個別の 'status'要素が含まれます。以下のリストは、「propstat」内で使用される最も一般的なステータスコードをまとめたものです。ただし、クライアントは他の2/3/4 / 5xxシリーズのステータスコードも処理できるように準備する必要があります。 200 OK-プロパティが存在するか、その値が正常に返されました。 401 Unauthorized-適切な許可なしにプロパティを表示することはできません。 403禁止-認証に関係なく、プロパティを表示できません。 404見つかりません-プロパティは存在しません。</target>
        </trans-unit>
        <trans-unit id="86628559f615b8ba5dc79d241d665acce969377c" translate="yes" xml:space="preserve">
          <source>In PROPPATCH responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well. 

   200 (OK) - The property set or change succeeded.  Note that if this
   appears for one property, it appears for every property in the
   response, due to the atomicity of PROPPATCH.

   403 (Forbidden) - The client, for reasons the server chooses not to
   specify, cannot alter one of the properties.

   403 (Forbidden): The client has attempted to set a protected
   property, such as DAV:getetag.  If returning this error, the server
   SHOULD use the precondition code 'cannot-modify-protected-property'
   inside the response body.

   409 (Conflict) - The client has provided a value whose semantics are
   not appropriate for the property.

   424 (Failed Dependency) - The property change could not be made
   because of another property change that failed.

   507 (Insufficient Storage) - The server did not have sufficient space
   to record the property.</source>
          <target state="translated">PROPPATCH応答では、個々のプロパティに関する情報が「propstat」要素内に返されます（&lt;a href=&quot;#section-14.22&quot;&gt;セクション14.22を&lt;/a&gt;参照））、それぞれに表示されるプロパティに関する情報を含む個別の 'status'要素を含みます。以下のリストは、「propstat」内で使用される最も一般的なステータスコードをまとめたものです。ただし、クライアントは他の2/3/4 / 5xxシリーズのステータスコードも処理できるように準備する必要があります。 200（OK）-プロパティの設定または変更が成功しました。これが1つのプロパティに表示される場合、PROPPATCHのアトミック性により、応答のすべてのプロパティに表示されることに注意してください。 403（禁止）-サーバーが指定しないことを選択した理由により、クライアントはプロパティの1つを変更できません。 403（禁止）：クライアントがDAV：getetagなどの保護されたプロパティを設定しようとしました。このエラーを返す場合、サーバーは前提条件コード「cannot-modify-protected-property」を使用する必要があります（SHOULD）。応答本文の内部。 409（競合）-クライアントが、そのセマンティクスがプロパティに適切でない値を提供しました。 424（失敗した依存関係）-失敗した別のプロパティ変更のため、プロパティ変更を行うことができませんでした。 507（不十分なストレージ）-サーバーには、プロパティを記録するための十分なスペースがありませんでした。</target>
        </trans-unit>
        <trans-unit id="4287fa4592630c32398d87b197eab0ac7661318b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request, resulting from an HTML form submission, the &lt;code&gt;Content-Type&lt;/code&gt; of the request is specified by the &lt;code&gt;enctype&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTMLフォーム送信の結果である&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;リクエストでは、リクエストの &lt;code&gt;Content-Type&lt;/code&gt; は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt;要素の &lt;code&gt;enctype&lt;/code&gt; 属性で指定されます。</target>
        </trans-unit>
        <trans-unit id="b96a6a626ade04f611b917e292048082979c2db6" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Request&lt;/a&gt; scenario, the request will be sent with Cookies (e.g. if the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; flag is set on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;). If the server responds with &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; attached to the credentialed response, then the response is accepted by the client and exposed to web content. In a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Request&lt;/a&gt;, the server can respond with &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; to the &lt;code&gt;OPTIONS&lt;/code&gt; request.</source>
          <target state="translated">では&lt;a href=&quot;cors#Simple_requests&quot;&gt;単純な要求の&lt;/a&gt;シナリオ、要求はクッキーで送信されます（例えば場合 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; のフラグがONに設定されている&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;）。サーバーが&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 認証応答に添付して応答した場合、その応答はクライアントによって受け入れられ、Webコンテンツに公開されます。では&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;プリフライトリクエスト&lt;/a&gt;、サーバがで応答することができ &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; へ &lt;code&gt;OPTIONS&lt;/code&gt; 要求。</target>
        </trans-unit>
        <trans-unit id="268020b94aef4013d8492a7be59945867c54beea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;multipart/form-data&lt;/code&gt; body, the HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; general header is a header that can be used on the subpart of a multipart body to give information about the field it applies to. The subpart is delimited by the &lt;em&gt;boundary&lt;/em&gt; defined in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header. Used on the body itself, &lt;code&gt;Content-Disposition&lt;/code&gt; has no effect.</source>
          <target state="translated">で &lt;code&gt;multipart/form-data&lt;/code&gt; 本体、HTTPの &lt;code&gt;Content-Disposition&lt;/code&gt; 一般的なヘッダーは、それが適用されるフィールドについての情報を与えるためにマルチ体のサブパートに使用することができるヘッダです。サブパートは、&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;ヘッダーで定義された&lt;em&gt;境界&lt;/em&gt;によって区切られます。本文自体に使用すると、 &lt;code&gt;Content-Disposition&lt;/code&gt; は効果がありません。</target>
        </trans-unit>
        <trans-unit id="205c117fa86b98a94b5278af3d27ff4834e8a8cf" translate="yes" xml:space="preserve">
          <source>In a Web page, using JavaScript</source>
          <target state="translated">Webページでは、JavaScriptを使用して</target>
        </trans-unit>
        <trans-unit id="217ea5cca9699504b57fcecb48b0029845d1abba" translate="yes" xml:space="preserve">
          <source>In a nutshell</source>
          <target state="translated">一言で言えば</target>
        </trans-unit>
        <trans-unit id="2761e7950da20aac090169d0c4a8c94e9c82afce" translate="yes" xml:space="preserve">
          <source>In a regular HTTP response, the &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; response header is a header indicating if the content is expected to be displayed &lt;em&gt;inline&lt;/em&gt; in the browser, that is, as a Web page or as part of a Web page, or as an &lt;em&gt;attachment&lt;/em&gt;, that is downloaded and saved locally.</source>
          <target state="translated">定期的なHTTP応答で、 &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; レスポンスヘッダは、コンテンツが表示されることが予想されるかどうかを示すヘッダである&lt;em&gt;インライン&lt;/em&gt; Webページとして、またはWebページの一部として、又は、あるブラウザで、&lt;em&gt;添付ファイルを&lt;/em&gt;、ことローカルにダウンロードして保存します。</target>
        </trans-unit>
        <trans-unit id="95ef9f1f98a924832244a2938c1f564593efc504" translate="yes" xml:space="preserve">
          <source>In addition to defining the HTTP/1.1 protocol, this document serves
   as the specification for the Internet media type &quot;message/http&quot; and
   &quot;application/http&quot;. The message/http type can be used to enclose a
   single HTTP request or response message, provided that it obeys the
   MIME restrictions for all &quot;message&quot; types regarding line length and
   encodings. The application/http type can be used to enclose a
   pipeline of one or more HTTP request or response messages (not
   intermixed). The following is to be registered with IANA [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;].

       Media Type name:         message
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed message
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none

       Media Type name:         application
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed messages
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: HTTP messages enclosed by this type
                 are in &quot;binary&quot; format; use of an appropriate
                 Content-Transfer-Encoding is required when
                 transmitted via E-mail.
       Security considerations: none</source>
          <target state="translated">このドキュメントは、HTTP / 1.1プロトコルの定義に加えて、インターネットメディアタイプ「message / http」および「application / http」の仕様としても機能します。 message / httpタイプは、行の長さとエンコーディングに関するすべての「メッセージ」タイプのMIME制限に従う場合、単一のHTTP要求または応答メッセージを囲むために使用できます。 application / httpタイプは、1つ以上のHTTP要求または応答メッセージ（混合されていない）のパイプラインを囲むために使用できます。以下はIANAに登録されます[ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]。メディアタイプ名：メッセージメディアサブタイプ名：http必須パラメーター：なしオプションパラメーター：バージョン、msgtypeバージョン：囲まれたメッセージのHTTP-Version番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコーディングに関する考慮事項：「7ビット」、「8ビット」、または「バイナリ」のみが許可されますセキュリティに関する考慮事項：なしメディアタイプ名：アプリケーションメディアサブタイプ名：http必須パラメーター：なしオプションパラメータ：version、msgtype version：囲まれたメッセージのHTTP-Version番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信する場合は、適切なContent-Transfer-Encodingを使用する必要があります。セキュリティに関する考慮事項：なし囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信する場合は、適切なContent-Transfer-Encodingを使用する必要があります。セキュリティに関する考慮事項：なし囲まれたメッセージのHTTPバージョン番号（たとえば、「1.1」）。存在しない場合、バージョンは本文の最初の行から判断できます。 msgtype：メッセージタイプ-「リクエスト」または「レスポンス」。存在しない場合、タイプは本文の最初の行から判別できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信する場合は、適切なContent-Transfer-Encodingを使用する必要があります。セキュリティに関する考慮事項：なし存在しない場合、タイプは本文の最初の行から判断できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。適切なContent-Transfer-Encodingを使用して、電子メールセキュリティに関する考慮事項：なし存在しない場合、タイプは本文の最初の行から判断できます。エンコードに関する考慮事項：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。適切なContent-Transfer-Encodingを使用して、電子メールセキュリティに関する考慮事項：なし</target>
        </trans-unit>
        <trans-unit id="ba23aa0ff8e4e6c04210bb32cbc84ce861b595e8" translate="yes" xml:space="preserve">
          <source>In addition to having &lt;code&gt;Server-Timing&lt;/code&gt; header metrics appear in the developer tools of the browser, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface enables tools to automatically collect and process metrics from JavaScript. This interface is restricted to the same origin, but you can use the &lt;a href=&quot;timing-allow-origin&quot;&gt;&lt;code&gt;Timing-Allow-Origin&lt;/code&gt;&lt;/a&gt; header to specify the domains that are allowed to access the server metrics. The interface is only available in secure contexts (HTTPS) in some browsers.</source>
          <target state="translated">ブラウザの開発者ツールに &lt;code&gt;Server-Timing&lt;/code&gt; ヘッダーメトリックを表示することに加えて、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;インターフェイスを使用すると、ツールはJavaScriptからメトリックを自動的に収集および処理できます。このインターフェイスは同じオリジンに制限されていますが、&lt;a href=&quot;timing-allow-origin&quot;&gt; &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、サーバーメトリックへのアクセスを許可するドメインを指定できます。このインターフェースは、一部のブラウザーのセキュアコンテキスト（HTTPS）でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="ad2112dae19cc7c327768fb0823cb8c15ee2b0a2" translate="yes" xml:space="preserve">
          <source>In addition to restricting the domains from which content can be loaded, the server can specify which protocols are allowed to be used; for example (and ideally, from a security standpoint), a server can specify that all content must be loaded using HTTPS. A complete data transmission security strategy includes not only enforcing HTTPS for data transfer, but also marking all &lt;a href=&quot;cookies&quot;&gt;cookies with the secure flag&lt;/a&gt; and providing automatic redirects from HTTP pages to their HTTPS counterparts. Sites may also use the &lt;a href=&quot;headers/strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; HTTP header to ensure that browsers connect to them only over an encrypted channel&lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">コンテンツのロード元のドメインを制限することに加えて、サーバーは、使用を許可するプロトコルを指定できます。たとえば（理想的にはセキュリティの観点から）、サーバーはすべてのコンテンツをHTTPSを使用してロードする必要があることを指定できます。完全なデータ転送セキュリティ戦略には、データ転送にHTTPSを適用するだけでなく、すべての&lt;a href=&quot;cookies&quot;&gt;Cookieにセキュアフラグ&lt;/a&gt;を付け、HTTPページから対応するHTTPSへの自動リダイレクトを提供することも含まれます。サイトは&lt;a href=&quot;headers/strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; HTTPヘッダーを使用して、ブラウザが暗号化されたチャネルを介してのみサイトに接続するようにすることもできます&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cc3248a0c52202ec569f1b1018d21d9a3d88bcc" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to COPY:

   201 (Created) - The source resource was successfully copied.  The
   COPY operation resulted in the creation of a new resource.

   204 (No Content) - The source resource was successfully copied to a
   preexisting destination resource.

   207 (Multi-Status) - Multiple resources were to be affected by the
   COPY, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a destination resource was locked
   and could not be overwritten, then the destination resource URL
   appears with the 423 (Locked) status.

   403 (Forbidden) - The operation is forbidden.  A special case for
   COPY could be that the source and destination resources are the same
   resource.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   412 (Precondition Failed) - A precondition header check failed, e.g.,
   the Overwrite header is &quot;F&quot; and the destination URL is already mapped
   to a resource. 

   423 (Locked) - The destination resource, or resource within the
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server, repository, or URL namespace.  Either the source namespace
   does not support copying to the destination namespace, or the
   destination namespace refuses to accept the resource.  The client may
   wish to try GET/PUT and PROPFIND/PROPPATCH instead.

   507 (Insufficient Storage) - The destination resource does not have
   sufficient space to record the state of the resource after the
   execution of this method.</source>
          <target state="translated">一般的なステータスコードに加えて、以下のステータスコードがCOPYに特有の適用可能性を持っています:201(Created)-ソースリソースが正常にコピーされました。COPY操作により、新しいリソースが作成されました。204(内容なし)-コピー元リソースは、既存のコピー先リソースへのコピーに成功しました。207 (Multi-Status)-複数のリソースがCOPYの影響を受ける予定でしたが、一部のリソースでエラーが発生し、操作が実行できませんでした。特定のエラーメッセージは、ソースURLとデスティネーションURLの中で最も適切なものとともに、マルチステータス応答の本文に表示されます。例えば、宛先リソースがロックされていて上書きできなかった場合、宛先リソース URL は 423 (Locked)ステータスで表示されます。403 (Forbidden)-操作は禁止されています。COPYの特殊なケースとしては、送信元リソースと送信先リソースが同じリソースである場合が考えられます。409 (競合)-1つ以上の中間コレクションが作成されるまで、宛先にリソースを作成することはできません。サーバーはこれらの中間コレクションを自動的に作成してはいけません[MUST NOT]。412 (Precondition Failed)-前提条件ヘッダーのチェックに失敗しました。例えば、Overwrite ヘッダーが &quot;F&quot; で、宛先 URL がすでにリソースにマップされています。423 (ロックされました)-デスティネーションリソース、またはデスティネーションコレクション内のリソー スがロックされました。この応答は 'lock-token-submitted' 前提条件要素を含むべきである[SHOULD]。502 (Bad Gateway)-これは、宛先が別のサーバー、リポジトリ、または URL 名前空間上にある場合に発生する可能性があります。ソースの名前空間が宛先の名前空間へのコピーをサポートしていないか、宛先の名前空間がリソースの受け入れを拒否しています。クライアントは、代わりに GET/PUT および PROPFIND/PROPPATCH を試してみてください。507 (ストレージが不足しています)-宛先リソースには、このメソッドの実行後のリソースの状態を記録するのに十分なスペースがありません。</target>
        </trans-unit>
        <trans-unit id="ee897ff0362cf4245c71fb432f38bd23904179b3" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to LOCK:

   200 (OK) - The LOCK request succeeded and the value of the DAV:
   lockdiscovery property is included in the response body.

   201 (Created) - The LOCK request was to an unmapped URL, the request
   succeeded and resulted in the creation of a new resource, and the
   value of the DAV:lockdiscovery property is included in the response
   body. 

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   423 (Locked), potentially with 'no-conflicting-lock' precondition
   code - There is already a lock on the resource that is not compatible
   with the requested lock (see lock compatibility table above).

   412 (Precondition Failed), with 'lock-token-matches-request-uri'
   precondition code - The LOCK request was made with an If header,
   indicating that the client wishes to refresh the given lock.
   However, the Request-URI did not fall within the scope of the lock
   identified by the token.  The lock may have a scope that does not
   include the Request-URI, or the lock could have disappeared, or the
   token may be invalid.</source>
          <target state="translated">200 (OK)-LOCK リクエストは成功し、DAV:lockdiscovery プロパティの値がレスポンスボディに含まれる。201 (Created)-LOCK リクエストはマッピングされていない URL へのものであり、リクエストは成功し、新しいリソースの作成につながった。409 (競合)-1つ以上の中間コレクションが作成されるまで、リソースはデスティネーションで作成できません。サーバーはこれらの中間コレクションを自動的に作成してはいけません[MUST NOT]。423 (ロックされています)、「no-conflicting-lock」前提条件コードを持つ可能性があります-要求されたロックと互換性のないロックがすでにリソースに存在します (上記のロック互換性表を参照)。412 (Precondition Failed)、'lock-token-matches-request-uri' 前提条件コード付き-LOCK リクエストは、クライアントが与えられたロックの更新を希望していることを示す If ヘッダーで行われた。しかし、Request-URIは、トークンによって識別されたロックのスコープ内には入らなかった。ロックはRequest-URIを含まないスコープを持っているか、 ロックが消えたか、トークンが無効である可能性がある。</target>
        </trans-unit>
        <trans-unit id="a26231e92d79838933371916af08188230312c93" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MKCOL:

   201 (Created) - The collection was created.

   403 (Forbidden) - This indicates at least one of two conditions: 1)
   the server does not allow the creation of collections at the given
   location in its URL namespace, or 2) the parent collection of the
   Request-URI exists but cannot accept members.

   405 (Method Not Allowed) - MKCOL can only be executed on an unmapped
   URL.

   409 (Conflict) - A collection cannot be made at the Request-URI until
   one or more intermediate collections have been created.  The server
   MUST NOT create those intermediate collections automatically.

   415 (Unsupported Media Type) - The server does not support the
   request body type (although bodies are legal on MKCOL requests, since
   this specification doesn't define any, the server is likely not to
   support any given body type).

   507 (Insufficient Storage) - The resource does not have sufficient
   space to record the state of the resource after the execution of this
   method.</source>
          <target state="translated">可能な一般的なステータスコードに加えて、以下のステータスコードはMKCOLに特定の適用可能性を持つ。403(禁止)-これは 2 つの条件のうち少なくとも 1 つを示しています。1)サーバーが URL 名前空間の指定された場所でのコレクションの作成を許可していない、または 2)Request-URI の親コレクションは存在するが、メンバーを受け入れることができない。405 (Method Not Allowed)-MKCOL はマップされていない URL でのみ実行できます。409 (競合)-1つ以上の中間コレクションが作成されるまで、Request-URIでコレクションを作成することはできません。サーバーはこれらの中間コレクションを自動的に作成してはなりません[MUST NOT]。415 (サポートされていないメディアタイプ)-サーバーはリクエストのボディタイプをサポートしていません(ボディは MKCOL リクエストでは合法ですが、この仕様ではボディは定義されていないので、サーバーは任意のボディタイプを サポートしていない可能性が高いです)。507 (Insufficient Storage)-このメソッドの実行後にリソースの状態を記録するのに十分なスペースがありません。</target>
        </trans-unit>
        <trans-unit id="abd88f2d1d87ef7a1f30945f9393736f0e9efad8" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MOVE:

   201 (Created) - The source resource was successfully moved, and a new
   URL mapping was created at the destination.

   204 (No Content) - The source resource was successfully moved to a
   URL that was already mapped.

   207 (Multi-Status) - Multiple resources were to be affected by the
   MOVE, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a source resource was locked and
   could not be moved, then the source resource URL appears with the 423
   (Locked) status.

   403 (Forbidden) - Among many possible reasons for forbidding a MOVE
   operation, this status code is recommended for use when the source
   and destination resources are the same.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.
   Or, the server was unable to preserve the behavior of the live
   properties and still move the resource to the destination (see
   'preserved-live-properties' postcondition).

   412 (Precondition Failed) - A condition header failed.  Specific to
   MOVE, this could mean that the Overwrite header is &quot;F&quot; and the
   destination URL is already mapped to a resource.

   423 (Locked) - The source or the destination resource, the source or
   destination resource parent, or some resource within the source or
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server and the destination server refuses to accept the resource.
   This could also occur when the destination is on another sub-section
   of the same server namespace.</source>
          <target state="translated">201 (Created)-ソースリソースが正常に移動され、宛先で新しい URL マッピングが作成されました。204 (No Content)-ソースリソースは、既にマッピングされた URL への移動に成功しました。207 (Multi-Status)-複数のリソースが MOVE の影響を受ける予定でしたが、そのうちのいくつかのリソースでエラーが発生し、操作が行われませんでした。特定のエラーメッセージは、ソースとデスティネーション URL の中で最も適切なものとともに、マルチステータス応答の本文に表示されます。例えば、ソースリソースがロックされていて移動できなかった場合、ソースリソースURLは423(Locked)ステータスで表示されます。403 (禁止)-MOVE 操作を禁止する多くの理由の中で、このステータスコードは、ソースリソースとデスティネーションリソースが同じ場合に使用することをお勧めします。409 (競合)-1 つ以上の中間コレクションが作成されるまで、リソースをデスティネーションで作成することはできません。サーバーはこれらの中間コレクションを自動的に作成してはなりません[MUST NOT]。または、サーバーがライブ・プロパティの動作を保持できず、リソースを移動先に移動させることができませんでした('pervesed-live-properties' postconditionを参照してください)。412 (Precondition Failed)-条件ヘッダーが失敗しました。MOVEに特有のもので、これは上書きヘッダーが「F」であり、宛先URLがすでにリソースにマップされていることを意味する可能性があります。423 (Locked)-ソースまたは宛先リソース、ソースまたは宛先リソースの親、またはソースまたは宛先コレクション内のリソースがロックされました。この応答には 'lock-token-submitted' 前提条件要素を含むべきである[SHOULD]。502 (Bad Gateway)-これは、宛先が別のサーバー上にあり、宛先サーバーがリソースの受け入れを拒否した場合に発生する可能性があります。これは、宛先が同じサーバー名前空間の別のサブセクションにある場合にも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4629e09c06eba402676b36f28c77b568459e792b" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to UNLOCK:

   204 (No Content) - Normal success response (rather than 200 OK, since
   200 OK would imply a response body, and an UNLOCK success response
   does not normally contain a body).

   400 (Bad Request) - No lock token was provided.

   403 (Forbidden) - The currently authenticated principal does not have
   permission to remove the lock.

   409 (Conflict), with 'lock-token-matches-request-uri' precondition -
   The resource was not locked, or the request was made to a Request-URI
   that was not within the scope of the lock.</source>
          <target state="translated">204 (No Content)-通常の成功応答(200 OK ではなく 200 OK)。400 (Bad Request)-ロックトークンが提供されなかった。403 (Forbidden)-現在認証されているプリンシパルがロックを解除する権限を持っていない。409 (競合)、'lock-token-matches-request-uri' 前提条件付き-リソースがロックされていないか、ロックの範囲外の Request-URI に対してリクエストが行われました。</target>
        </trans-unit>
        <trans-unit id="9e2b59b56283e49cf87a4756ab287a316a572fba" translate="yes" xml:space="preserve">
          <source>In addition to these large extensions, numerous other headers have been added, sometimes experimentally only. Notable headers are Do Not Track (&lt;a href=&quot;../headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt;) header to control privacy, &lt;a href=&quot;../headers/x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt;&lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt;&lt;/a&gt; but many more exist.</source>
          <target state="translated">これらの大きな拡張に加えて、他の多くのヘッダーが追加されています。注目すべきヘッダーは、プライバシーを制御するDo Not Track（&lt;a href=&quot;../headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt;）ヘッダー、&lt;a href=&quot;../headers/x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt; &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; です&lt;/a&gt;が、さらに多くのヘッダーが存在します。</target>
        </trans-unit>
        <trans-unit id="3b131cf2fd0e3eeeeb8387fc020ce526e5bb2a21" translate="yes" xml:space="preserve">
          <source>In addition to these usual redirections, there are two specific redirections. The &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) redirects a page to the locally cached copy (that was stale), and &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choice) is a manual redirection: the body, presented by the browser as a Web page, lists the possible redirections and the user clicks on one to select it.</source>
          <target state="translated">これらの通常のリダイレクトに加えて、2つの特定のリダイレクトがあります。&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; は、&lt;/a&gt;（変更不可）（失効した）ローカルにキャッシュされたコピーにページをリダイレクトして、&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（複数選択）手動でリダイレクトです：Webページとしてブラウザによって提示されたボディ、リストの可能なリダイレクトとユーザー1つをクリックして選択します。</target>
        </trans-unit>
        <trans-unit id="d635ae50b7ab2f51933a439ac178e121013926c5" translate="yes" xml:space="preserve">
          <source>In addition to these, there is an experimental proposal to add more headers to the list of available headers, called &lt;em&gt;client hints&lt;/em&gt;. Client hints advertise what kind of device the user agent runs on (for example, if it is a desktop computer or a mobile device).</source>
          <target state="translated">これらに加えて、&lt;em&gt;クライアントヒント&lt;/em&gt;と呼ばれる、利用可能なヘッダーのリストにさらにヘッダーを追加する実験的な提案があり&lt;em&gt;ます&lt;/em&gt;。クライアントヒントは、ユーザーエージェントが実行されるデバイスの種類をアドバタイズします（たとえば、デスクトップコンピューターまたはモバイルデバイスの場合）。</target>
        </trans-unit>
        <trans-unit id="452c8d06b2f6623a8650c4fa111cc03980282cde" translate="yes" xml:space="preserve">
          <source>In an HTTP URL, the first substring that follows the initial &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt; is called the domain name. This domain name is hosted on a server where the document resides.</source>
          <target state="translated">HTTP URLでは、最初の &lt;code&gt;http://&lt;/code&gt; または &lt;code&gt;https://&lt;/code&gt; に続く最初のサブストリングはドメイン名と呼ばれます。このドメイン名は、ドキュメントが存在するサーバーでホストされています。</target>
        </trans-unit>
        <trans-unit id="c6a374d59d054a3737c0b7d32f324c37547cb7c5" translate="yes" xml:space="preserve">
          <source>In both cases it's clear, conditional requests are a fundamental feature behind the Web.</source>
          <target state="translated">どちらの場合も、条件付きリクエストがウェブの基本的な機能であることは明らかです。</target>
        </trans-unit>
        <trans-unit id="b7d3d4c052ce3a72008b8168b5362d9899fce376" translate="yes" xml:space="preserve">
          <source>In both cases, the user can't do much (unless a corruption is happening on their side, like a mismatch of cache or cookies).</source>
          <target state="translated">どちらの場合も、ユーザーは大したことができません(キャッシュやクッキーのミスマッチのように、ユーザー側で破損が起きていない限り)。</target>
        </trans-unit>
        <trans-unit id="891082881f414bc74764d1a5ea2c1afe84e85946" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;をサポートするブラウザーでは、 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは無視されます。</target>
        </trans-unit>
        <trans-unit id="99d503921123b6885340a4372a8a6b0ea5626e01" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">&lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;をサポートするブラウザーでは、 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; ディレクティブは無視されます。</target>
        </trans-unit>
        <trans-unit id="2eeb5d5719bfe66a723ed9a7de204a618f713d1f" translate="yes" xml:space="preserve">
          <source>In case of a range request that is out of bounds (range values overlap the extent of the resource), the server responds with a &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; status.</source>
          <target state="translated">範囲外の範囲要求（範囲値がリソースの範囲と重複する）の場合、サーバーは&lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; ステータスで応答します。</target>
        </trans-unit>
        <trans-unit id="fe1bbb314fd4c01d67a4a1927444c74b1ecc3b84" translate="yes" xml:space="preserve">
          <source>In case of a successful range request, the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">範囲リクエストが成功した場合、&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; ステータスがサーバーから返信されます。</target>
        </trans-unit>
        <trans-unit id="aedd7950da9e5893c670001b73efaf8f02facdd1" translate="yes" xml:space="preserve">
          <source>In case of no support of range requests, the &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">範囲リクエストがサポートされていない場合、&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; ステータスがサーバーから返送されます。</target>
        </trans-unit>
        <trans-unit id="73542c18d725b27c3411be51053fdddc86d53fc0" translate="yes" xml:space="preserve">
          <source>In cases of redirection, the HTTP method used to make the new request to fetch the page pointed to by &lt;code&gt;Location&lt;/code&gt; depends of the original method and of the kind of redirection:</source>
          <target state="translated">リダイレクトの場合、 &lt;code&gt;Location&lt;/code&gt; が指すページをフェッチするための新しいリクエストを作成するために使用されるHTTPメソッドは、元のメソッドとリダイレクトの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="400b65ba68994eae44783d4597cd6426d0ef1020" translate="yes" xml:space="preserve">
          <source>In cases of resource creation, it indicates the URL to the newly created resource.</source>
          <target state="translated">リソース作成の場合は、新たに作成したリソースへのURLを示します。</target>
        </trans-unit>
        <trans-unit id="83f79ebc079d3c0c0d4572bcf4378eb80a9d0af2" translate="yes" xml:space="preserve">
          <source>In client-server protocols, it is the client which establishes the connection. Opening a connection in HTTP means initiating a connection in the underlying transport layer, usually this is TCP.</source>
          <target state="translated">クライアント-サーバプロトコルでは、接続を確立するのはクライアントです。HTTP で接続を開くということは、基礎となるトランスポート層で接続を開始することを意味します。</target>
        </trans-unit>
        <trans-unit id="8c10db7321992e2a8f17abad3e89745464a5099e" translate="yes" xml:space="preserve">
          <source>In client-server protocols, like HTTP, sessions consist of three phases:</source>
          <target state="translated">HTTPのようなクライアント・サーバ・プロトコルでは、セッションは3つのフェーズで構成されています。</target>
        </trans-unit>
        <trans-unit id="3f9a70e3c7b55315e54b4db55bc22d039b7ec58c" translate="yes" xml:space="preserve">
          <source>In conjunction with a range request with a &lt;a href=&quot;if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; header, it can be used to ensure that the new fragment requested comes from an unmodified document.</source>
          <target state="translated">&lt;a href=&quot;if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt;ヘッダーを含む範囲リクエストと組み合わせて、リクエストされた新しいフラグメントが未変更のドキュメントからのものであることを確認するために使用できます。</target>
        </trans-unit>
        <trans-unit id="e9ab6733bb319a29784b72221a4697f634e9bdd1" translate="yes" xml:space="preserve">
          <source>In conjunction with non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, it can be used to implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;optimistic concurrency control&lt;/a&gt;, like done by some wikis: editions are rejected if the stored document has been modified since the original has been retrieved.</source>
          <target state="translated">&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;などの非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;メソッドと組み合わせて、一部のWikiのように&lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;楽観的同時実行制御&lt;/a&gt;を実装するために使用できます。元のドキュメントが取得されてから保存されているドキュメントが変更されている場合、エディションは拒否されます。</target>
        </trans-unit>
        <trans-unit id="fbebaf8ae5ad813c6e5579cad204cc0afeb3f2a6" translate="yes" xml:space="preserve">
          <source>In early versions of HTTP/1.1, a default charset (&lt;code&gt;ISO-8859-1&lt;/code&gt;) was defined. This is no more the case and now each content type may have its own default.</source>
          <target state="translated">HTTP / 1.1の初期のバージョンでは、デフォルトの文字セット（ &lt;code&gt;ISO-8859-1&lt;/code&gt; ）が定義されていました。これはもう当てはまりません。現在、各コンテンツタイプには独自のデフォルトがあります。</target>
        </trans-unit>
        <trans-unit id="76b87dd4cff176256a7ffd91b11051848e914ccf" translate="yes" xml:space="preserve">
          <source>In general, you don't need to do anything to manage prefetching. However, the user may wish to disable prefetching. On Firefox, this can be done by setting the &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; preference to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">一般に、プリフェッチを管理するために何もする必要はありません。ただし、ユーザーはプリフェッチを無効にしたい場合があります。Firefoxでは、 &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; 設定を &lt;code&gt;true&lt;/code&gt; に設定することでこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="674099d2a81c401b8baaba7396a1a690e7a583af" translate="yes" xml:space="preserve">
          <source>In most cases, the policy-controlled features represent functionality that when used will negatively impact the user experience. To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. Best practices are then enforced by using policies that disable the policy-controlled features. For more details see &quot;Enforcing best practices for good user experiences&quot;.</source>
          <target state="translated">ほとんどの場合、ポリシー制御された機能は、使用するとユーザーエクスペリエンスに悪影響を与える機能を表しています。既存のウェブコンテンツが壊れるのを避けるために、このようなポリシー制御機能のデフォルトでは、すべてのオリジンでその機能を使用できるようにすることになっています。ベスト プラクティスは、ポリシー制御機能を無効にするポリシーを使用して実施します。詳細については、「優れたユーザー体験のためのベストプラクティスの実施」を参照してください。</target>
        </trans-unit>
        <trans-unit id="5408e40c9a5920880e7570b54ae2fe87a76b064d" translate="yes" xml:space="preserve">
          <source>In opposition to the previous &lt;code&gt;Accept-*&lt;/code&gt; headers which are sent by the client, the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP header is sent by the web server in its response. It indicates the list of headers used by the server during the server-driven content negotiation phase. The header is needed in order to inform the cache of the decision criteria so that it can reproduce it, allowing the cache to be functional while preventing serving erroneous content to the user.</source>
          <target state="translated">クライアントによって送信される以前の &lt;code&gt;Accept-*&lt;/code&gt; ヘッダーとは対照的に、&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTPヘッダーは応答でWebサーバーによって送信されます。これは、サーバー主導のコンテンツネゴシエーションフェーズ中にサーバーによって使用されるヘッダーのリストを示します。ヘッダーは、判断基準をキャッシュに通知してそれを再現できるようにするために必要です。これにより、ユーザーに誤ったコンテンツを提供することを防ぎながら、キャッシュを機能させることができます。</target>
        </trans-unit>
        <trans-unit id="badfc139e7e8ad666da707d60e16523bcd32cfa3" translate="yes" xml:space="preserve">
          <source>In order to decide whether a response is fresh or stale, we need to
   compare its freshness lifetime to its age. The age is calculated as
   described in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;; this section describes how to calculate
   the freshness lifetime, and to determine if a response has expired.
   In the discussion below, the values can be represented in any form
   appropriate for arithmetic operations.

   We use the term &quot;expires_value&quot; to denote the value of the Expires
   header. We use the term &quot;max_age_value&quot; to denote an appropriate
   value of the number of seconds carried by the &quot;max-age&quot; directive of
   the Cache-Control header in a response (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;).

   The max-age directive takes priority over Expires, so if max-age is
   present in a response, the calculation is simply:

      freshness_lifetime = max_age_value

   Otherwise, if Expires is present in the response, the calculation is:

      freshness_lifetime = expires_value - date_value

   Note that neither of these calculations is vulnerable to clock skew,
   since all of the information comes from the origin server.

   If none of Expires, Cache-Control: max-age, or Cache-Control: s-
   maxage (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;) appears in the response, and the response
   does not include other restrictions on caching, the cache MAY compute
   a freshness lifetime using a heuristic. The cache MUST attach Warning
   113 to any response whose age is more than 24 hours if such warning
   has not already been added.

   Also, if the response does have a Last-Modified time, the heuristic
   expiration value SHOULD be no more than some fraction of the interval
   since that time. A typical setting of this fraction might be 10%.

   The calculation to determine if a response has expired is quite
   simple:

      response_is_fresh = (freshness_lifetime &amp;gt; current_age)</source>
          <target state="translated">応答が新鮮であるか古くなっているのかを判断するには、新鮮さの存続期間をその年齢と比較する必要があります。年齢は&lt;a href=&quot;#section-13.2.3&quot;&gt;セクション13.2.3で&lt;/a&gt;説明されているように計算されます。このセクションでは、鮮度の有効期間を計算する方法と、応答の有効期限が切れているかどうかを判断する方法について説明します。以下の説明では、値は算術演算に適した任意の形式で表すことができます。 Expiresヘッダーの値を示すために、「expires_value」という用語を使用します。 「max_age_value」という用語を使用して、応答内のCache-Controlヘッダーの「max-age」ディレクティブによって伝送される秒数の適切な値を示します（&lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3を&lt;/a&gt;参照））。 max-ageディレクティブはExpiresよりも優先されるため、応答にmax-ageが存在する場合、計算は次のようになります。すべての情報はオリジンサーバーから取得されるため、これらの計算はどちらもクロックスキューに対して脆弱です。 Expires、Cache-Control：max-age、またはCache-Control：s- maxageがない場合（&lt;a href=&quot;#section-14.9.3&quot;&gt;セクション14.9.3を&lt;/a&gt;参照））が応答に表示され、応答にはキャッシングに関する他の制限が含まれていません。キャッシュは、ヒューリスティックを使用してフレッシュネスライフタイムを計算できます（MAY）。このような警告がまだ追加されていない場合、キャッシュは経過時間が24時間を超える応答には警告113を添付する必要があります。また、応答にLast-Modified時間がある場合、ヒューリスティックな有効期限値は、その時間以降の間隔の一部にすぎない（SHOULD）。この割合の一般的な設定は10％です。応答の有効期限が切れているかどうかを判断する計算は非常に簡単です。response_is_fresh=（freshness_lifetime&amp;gt; current_age）</target>
        </trans-unit>
        <trans-unit id="d03e66527d9041fe3d196b0602d934ec30eb980d" translate="yes" xml:space="preserve">
          <source>In order to fix this problem, Mozilla changed the behavior of loading resource: URIs in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;bug 863246&lt;/a&gt;, which landed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;Firefox 57 (Quantum)&lt;/a&gt;.</source>
          <target state="translated">この問題を修正するために、Mozilla は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;Firefox 57（Quantum）に&lt;/a&gt;上陸した&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;バグ863246の&lt;/a&gt;リソース読み込みURIの動作を変更しました。</target>
        </trans-unit>
        <trans-unit id="e3cacbc626f64e05a875aafa03b69d5da76a91ff" translate="yes" xml:space="preserve">
          <source>In order to know if a cached entry is fresh, a cache needs to know if
   its age exceeds its freshness lifetime. We discuss how to calculate
   the latter in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;; this section describes how to calculate
   the age of a response or cache entry.

   In this discussion, we use the term &quot;now&quot; to mean &quot;the current value
   of the clock at the host performing the calculation.&quot; Hosts that use
   HTTP, but especially hosts running origin servers and caches, SHOULD
   use NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;] or some similar protocol to synchronize their clocks to
   a globally accurate time standard. 

   HTTP/1.1 requires origin servers to send a Date header, if possible,
   with every response, giving the time at which the response was
   generated (see &lt;a href=&quot;#section-14.18&quot;&gt;section 14.18&lt;/a&gt;). We use the term &quot;date_value&quot; to denote
   the value of the Date header, in a form appropriate for arithmetic
   operations.

   HTTP/1.1 uses the Age response-header to convey the estimated age of
   the response message when obtained from a cache. The Age field value
   is the cache's estimate of the amount of time since the response was
   generated or revalidated by the origin server.

   In essence, the Age value is the sum of the time that the response
   has been resident in each of the caches along the path from the
   origin server, plus the amount of time it has been in transit along
   network paths.

   We use the term &quot;age_value&quot; to denote the value of the Age header, in
   a form appropriate for arithmetic operations.

   A response's age can be calculated in two entirely independent ways:

      1. now minus date_value, if the local clock is reasonably well
         synchronized to the origin server's clock. If the result is
         negative, the result is replaced by zero.

      2. age_value, if all of the caches along the response path
         implement HTTP/1.1.

   Given that we have two independent ways to compute the age of a
   response when it is received, we can combine these as

       corrected_received_age = max(now - date_value, age_value)

   and as long as we have either nearly synchronized clocks or all-
   HTTP/1.1 paths, one gets a reliable (conservative) result.

   Because of network-imposed delays, some significant interval might
   pass between the time that a server generates a response and the time
   it is received at the next outbound cache or client. If uncorrected,
   this delay could result in improperly low ages.

   Because the request that resulted in the returned Age value must have
   been initiated prior to that Age value's generation, we can correct
   for delays imposed by the network by recording the time at which the
   request was initiated. Then, when an Age value is received, it MUST
   be interpreted relative to the time the request was initiated, not 

   the time that the response was received. This algorithm results in
   conservative behavior no matter how much delay is experienced. So, we
   compute:

      corrected_initial_age = corrected_received_age
                            + (now - request_time)

   where &quot;request_time&quot; is the time (according to the local clock) when
   the request that elicited this response was sent.

   Summary of age calculation algorithm, when a cache receives a
   response:

      /*
       * age_value
       *      is the value of Age: header received by the cache with
       *              this response.
       * date_value
       *      is the value of the origin server's Date: header
       * request_time
       *      is the (local) time when the cache made the request
       *              that resulted in this cached response
       * response_time
       *      is the (local) time when the cache received the
       *              response
       * now
       *      is the current (local) time
       */

      apparent_age = max(0, response_time - date_value);
      corrected_received_age = max(apparent_age, age_value);
      response_delay = response_time - request_time;
      corrected_initial_age = corrected_received_age + response_delay;
      resident_time = now - response_time;
      current_age   = corrected_initial_age + resident_time;

   The current_age of a cache entry is calculated by adding the amount
   of time (in seconds) since the cache entry was last validated by the
   origin server to the corrected_initial_age. When a response is
   generated from a cache entry, the cache MUST include a single Age
   header field in the response with a value equal to the cache entry's
   current_age.

   The presence of an Age header field in a response implies that a
   response is not first-hand. However, the converse is not true, since
   the lack of an Age header field in a response does not imply that the 

   response is first-hand unless all caches along the request path are
   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement
   the Age header field).</source>
          <target state="translated">キャッシュされたエントリが新しいかどうかを知るために、キャッシュはその存続期間が経過したかどうかを知る必要があります。後者の計算方法については、&lt;a href=&quot;#section-13.2.4&quot;&gt;セクション13.2.4で説明し&lt;/a&gt;ます。このセクションでは、応答またはキャッシュエントリの経過時間を計算する方法について説明します。この説明では、「現在」という用語を使用して、「計算を実行するホストでのクロックの現在の値」を意味します。 HTTPを使用するホスト、特にオリジンサーバーとキャッシュを実行するホストは、NTP [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt; ]または同様のプロトコルを使用して、クロックをグローバルに正確な時間標準に同期する必要があります（SHOULD）。 HTTP / 1.1は、可能であれば、すべての応答とともに日付ヘッダーを送信し、応答が生成された時刻を提供するようにオリジンサーバーに要求します（&lt;a href=&quot;#section-14.18&quot;&gt;セクション14.18を&lt;/a&gt;参照）。）。 「date_value」という用語は、算術演算に適した形式で、Dateヘッダーの値を示すために使用します。 HTTP / 1.1は、Age応答ヘッダーを使用して、キャッシュから取得した応答メッセージの推定経過時間を伝えます。 Ageフィールドの値は、応答がオリジンサーバーによって生成または再検証されてからのキャッシュの推定時間です。本質的に、Age値は、応答がオリジンサーバーからのパスに沿って各キャッシュに常駐していた時間と、ネットワークパスに沿って転送されていた時間の合計です。 「age_value」という用語を使用して、算術演算に適した形式でAgeヘッダーの値を示します。応答の年齢は、2つの完全に独立した方法で計算できます.1。ローカルクロックが元のサーバーのクロックにかなりよく同期している場合は、マイナスdate_valueになります。結果が負の場合、結果はゼロに置き換えられます。 2.応答パス上のすべてのキャッシュがHTTP / 1.1を実装している場合、age_value。受信時の応答の経過時間を計算する2つの独立した方法があることを考えると、ほぼ同期したクロックまたはすべてのHTTP / 1.1のいずれかがある限り、これらをcorrected_received_age = max（now-date_value、age_value）として組み合わせることができます。パス、信頼できる（保守的な）結果が得られます。ネットワークによる遅延のため、サーバーが応答を生成してから次のアウトバウンドキャッシュまたはクライアントで受信されるまでの間に、かなりの間隔が経過する場合があります。修正されていない場合、この遅延により、年齢が不適切に低くなる可能性があります。返されるAge値の原因となった要求は、そのAge値の生成前に開始されている必要があるため、要求が開始された時間を記録することにより、ネットワークによって課される遅延を修正できます。次に、Age値が受信されると、応答が受信された時間ではなく、要求が開始された時間に関連して解釈される必要があります。このアルゴリズムは、どの程度の遅延が発生しても、保守的な動作になります。したがって、次のように計算します。corrected_initial_age= corrected_received_age +（now-request_time）ここで、「request_time」は、この応答を引き出した要求が送信された時間（ローカルクロックによる）です。年齢計算アルゴリズムのまとめ、キャッシュが応答を受信したとき：/ * * age_value *は、この応答とともにキャッシュが受信したAge：ヘッダーの値です。 * date_value *は、オリジンサーバーのDate：ヘッダーの値です。* request_time *は、キャッシュがリクエストを行った（ローカル）時間です*このキャッシュされた応答が返されました* response_time *は、キャッシュが*を受け取った（ローカル）時間ですresponse * now *は現在の（ローカル）時間です* / Appearance_age = max（0、response_time-date_value）; corrected_received_age = max（apparent_age、age_value）; response_delay = response_time-request_time; corrected_initial_age = corrected_received_age + response_delay;resident_time = now-response_time; current_age = corrected_initial_age + resident_time;キャッシュエントリのcurrent_ageは、キャッシュエントリがオリジンサーバーによって最後に検証されてからの時間（秒単位）をcorrected_initial_ageに追加することによって計算されます。キャッシュエントリから応答が生成される場合、キャッシュは、キャッシュエントリのcurrent_ageと等しい値を持つ単一のAgeヘッダーフィールドを応答に含める必要があります。応答にAgeヘッダーフィールドが存在することは、応答が直接ではないことを意味します。ただし、応答にAgeヘッダーフィールドがないことは、要求パスに沿ったすべてのキャッシュがHTTP / 1.1に準拠していない限り、応答が直接であることを意味しないため（つまり、古いHTTPキャッシュはAgeヘッダーフィールドを実装します）。</target>
        </trans-unit>
        <trans-unit id="93eea119dacd0c2679005705eb05947c3bbce8c5" translate="yes" xml:space="preserve">
          <source>In order to mitigate these flaws, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm, and more efficient.</source>
          <target state="translated">これらの欠陥を軽減するために、HTTP / 1.1はパイプライン化（​​実装が難しいことが判明）と永続的な接続を導入しました。基になるTCP接続は、&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して部分的に制御できます。HTTP / 2は、単一の接続を介してメッセージを多重化することにより、さらに一歩進んで、接続を暖かく保ち、より効率的にしました。</target>
        </trans-unit>
        <trans-unit id="d06ed585978c0a513808590b8c6743bd98c74164" translate="yes" xml:space="preserve">
          <source>In parallel to the somewhat chaotic use of the diverse implementations of HTTP/1.0, and since 1995, well before the publication of HTTP/1.0 document the next year, proper standardization was in progress. The first standardized version of HTTP, HTTP/1.1 was published in early 1997, only a few months after HTTP/1.0.</source>
          <target state="translated">HTTP/1.0の多様な実装のやや混沌とした使用と並行して、翌年のHTTP/1.0文書の発行よりもずっと前の1995年から、適切な標準化が進んでいました。最初の標準化されたHTTPのバージョンであるHTTP/1.1は、HTTP/1.0の数ヶ月後の1997年の初めに公開されました。</target>
        </trans-unit>
        <trans-unit id="4a373ca506ac7942c288749c8f149a921b16adb3" translate="yes" xml:space="preserve">
          <source>In particular, a request is preflighted if &lt;strong&gt;any of the following conditions&lt;/strong&gt; is true:</source>
          <target state="translated">特に、&lt;strong&gt;次のいずれかの条件&lt;/strong&gt;に該当&lt;strong&gt;する&lt;/strong&gt;場合、リクエストはプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="6d1e5ffefab8e49049390586276d922518d4d867" translate="yes" xml:space="preserve">
          <source>In particular, the request &lt;em&gt;requires&lt;/em&gt; these two additional headers:</source>
          <target state="translated">特に、リクエストに&lt;em&gt;は&lt;/em&gt;次の2つの追加ヘッダー&lt;em&gt;が必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="32f825d053979b2bbea746eee217de968d1740ce" translate="yes" xml:space="preserve">
          <source>In practice, hop-by-hop compression is transparent for the server and the client, and is rarely used. &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; are mostly used to send a response by chunks, allowing to start transmitting a resource without knowing its length.</source>
          <target state="translated">実際には、ホップバイホップ圧縮はサーバーとクライアントに対して透過的であり、めったに使用されません。&lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;は主にチャンクで応答を送信するために使用され、その長さを知らなくてもリソースの送信を開始できます。</target>
        </trans-unit>
        <trans-unit id="6fb0378e9b8c8212e3d2de953dca5265e4ca3124" translate="yes" xml:space="preserve">
          <source>In practice, this error is very rarely used. Instead of responding using this error code, which would be cryptic for the end user and difficult to fix, servers ignore the relevant header and serve an actual page to the user. It is assumed that even if the user won't be completely happy, they will prefer this to an error code.</source>
          <target state="translated">実際には、このエラーが使われることはほとんどありません。このエラーコードを使って応答するよりも、エンドユーザにとっては暗号的で修正が難しいこのエラーコードを使って応答する方が、サーバは関連するヘッダを無視して実際のページをユーザに提供します。ユーザーが完全に満足しないとしても、エラーコードよりもこの方が好まれることが想定されます。</target>
        </trans-unit>
        <trans-unit id="5897a27e39859a1490a88859d07dae77805526ee" translate="yes" xml:space="preserve">
          <source>In practice, web developers don't need to implement compression mechanisms, both browsers and servers have it implemented already, but they have to be sure that the server is configured adequately. Compression happens at three different levels:</source>
          <target state="translated">実際には、ウェブ開発者は圧縮機構を実装する必要はありません。ブラウザにもサーバにもすでに実装されていますが、サーバが適切に設定されていることを確認する必要があります。圧縮は3つの異なるレベルで行われます。</target>
        </trans-unit>
        <trans-unit id="495136708e3b335d9a535e1968ab6547efcb7046" translate="yes" xml:space="preserve">
          <source>In presence of an &lt;code&gt;Accept-Ranges&lt;/code&gt; header, the browser may try to &lt;em&gt;resume&lt;/em&gt; an interrupted download, rather than to start it from the start again.</source>
          <target state="translated">&lt;code&gt;Accept-Ranges&lt;/code&gt; ヘッダーが存在する場合、ブラウザは、ダウンロードを最初からやり直すのではなく、中断されたダウンロードを&lt;em&gt;再開&lt;/em&gt;しようとする&lt;em&gt;ことが&lt;/em&gt;あります。</target>
        </trans-unit>
        <trans-unit id="b7c4393bb4e04346146f3edbaf7c8cd5fd81dd69" translate="yes" xml:space="preserve">
          <source>In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top at the application layer. Although important to diagnose network problems, the underlying layers are mostly irrelevant to the description of HTTP.</source>
          <target state="translated">実際には、ブラウザとリクエストを処理するサーバの間には、ルータやモデムなど、より多くのコンピュータが存在します。ウェブの層状設計のおかげで、これらはネットワーク層とトランスポート層に隠されています。HTTP はアプリケーション層の上にあります。ネットワークの問題を診断するためには重要ですが、その下にある層は、HTTP の説明にはほとんど関係ありません。</target>
        </trans-unit>
        <trans-unit id="5bf5f583aa5451ac94eabad6345a75ed78fe4350" translate="yes" xml:space="preserve">
          <source>In requests, (such as &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;), the client tells the server what type of data is actually sent.</source>
          <target state="translated">リクエスト（&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; など&lt;/a&gt;）では、クライアントはサーバーに実際に送信されるデータのタイプを通知します。</target>
        </trans-unit>
        <trans-unit id="1d41bda365255372b63ef811da0c711c5a50b4a0" translate="yes" xml:space="preserve">
          <source>In responses, a &lt;code&gt;Content-Type&lt;/code&gt; header tells the client what the content type of the returned content actually is. Browsers will do MIME sniffing in some cases and will not necessarily follow the value of this header; to prevent this behavior, the header &lt;a href=&quot;x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; can be set to &lt;code&gt;nosniff&lt;/code&gt;.</source>
          <target state="translated">応答では、 &lt;code&gt;Content-Type&lt;/code&gt; ヘッダーは、返されたコンテンツのコンテンツタイプが実際に何であるかをクライアントに通知します。ブラウザは、場合によってはMIMEスニッフィングを実行し、このヘッダーの値に必ずしも従う必要はありません。この動作を防ぐために、ヘッダー&lt;a href=&quot;x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;nosniff&lt;/code&gt; に設定できます。</target>
        </trans-unit>
        <trans-unit id="7328d876f6eb63e7721164796f1284534dc9f3db" translate="yes" xml:space="preserve">
          <source>In short the EU directive means that before somebody can store or retrieve any information from a computer, mobile phone or other device, the user must give informed consent to do so. Many websites have added banners (AKA &quot;cookie banners&quot;) since then to inform the user about the use of cookies.</source>
          <target state="translated">要するに、EU指令とは、コンピュータ、携帯電話、その他のデバイスから情報を保存したり取得したりする前に、利用者がインフォームド・コンセントを与えなければならないということを意味しています。多くのウェブサイトでは、それ以来、クッキーの使用について利用者に知らせるためのバナー(別名「クッキーバナー」)を追加しています。</target>
        </trans-unit>
        <trans-unit id="1d12b916e1ea56872beecbf2e4e9757af03ec500" translate="yes" xml:space="preserve">
          <source>In some cases, the operator of a cache MAY choose to configure it to
   return stale responses even when not requested by clients. This
   decision ought not be made lightly, but may be necessary for reasons
   of availability or performance, especially when the cache is poorly
   connected to the origin server. Whenever a cache returns a stale
   response, it MUST mark it as such (using a Warning header) enabling
   the client software to alert the user that there might be a potential
   problem. 

   It also allows the user agent to take steps to obtain a first-hand or
   fresh response. For this reason, a cache SHOULD NOT return a stale
   response if the client explicitly requests a first-hand or fresh one,
   unless it is impossible to comply for technical or policy reasons.</source>
          <target state="translated">場合によっては、キャッシュのオペレータはクライアントから要求されなくても古い応答を返すように設定してもよい[MAY]。この決定は軽々しく行われるべきではありませんが、可用性やパフォーマンスの理由、特にキャッシュがオリジンサーバへの接続が悪い場合には必要になるかもしれません。キャッシュが古いレスポンスを返すときはいつでも、(Warning ヘッダを使って)そのようにマークしなければならない(MUST)ので、クライアントソフトウェアは潜在的な問題があるかもしれないことをユーザに警告することができます。これはまた、ユーザーエージェントが最初の、あるいは新しい応答を得るための手順を取ることを可能にします。この理由から、技術的な理由やポリシー上の理由でそれが不可能な場合を除いて、クライアントが明示的に最初の応答や新しい応答を要求した場合、キャッシュは古い応答を返すべきではありません(SHOULD NOT)。</target>
        </trans-unit>
        <trans-unit id="d9444a4e91ad14c01e9590e0bedd4b5d6e8c782c" translate="yes" xml:space="preserve">
          <source>In summary, we recommend looking for the string &amp;ldquo;Mobi&amp;rdquo; anywhere in the User Agent to detect a mobile device.</source>
          <target state="translated">要約すると、ユーザーエージェントの任意の場所で文字列「Mobi」を探して、モバイルデバイスを検出することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="32c2d5256e5dc0b53e01514a025fbdaca4825463" translate="yes" xml:space="preserve">
          <source>In the absence of a MIME type, or in certain cases where browsers believe they are incorrect, browsers may perform &lt;em&gt;MIME sniffing&lt;/em&gt; &amp;mdash; guessing the correct MIME type by looking at the bytes of the resource.</source>
          <target state="translated">MIMEタイプがない場合、またはブラウザがそれらを正しくないと信じている特定のケースでは、ブラウザは&lt;em&gt;MIMEスニッフィングを&lt;/em&gt;実行する可能性があります。リソースのバイトを見て、正しいMIMEタイプを推測します。</target>
        </trans-unit>
        <trans-unit id="cdc3e1dfd2d8a54df8817aa9e2334a8c551dfaed" translate="yes" xml:space="preserve">
          <source>In the case of a &quot;Basic&quot; authentication like shown in the figure, the exchange &lt;strong&gt;must&lt;/strong&gt; happen over an HTTPS (TLS) connection to be secure.</source>
          <target state="translated">図に示すような「基本」認証の場合、安全性を確保するには、HTTPS（TLS）接続を介して交換を行う&lt;strong&gt;必要&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="9597ab40baf818d41d5819712b2c6f8aebbfee81" translate="yes" xml:space="preserve">
          <source>In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give a response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resource but a confirmation message such as: 'you successfully uploaded XYZ'.</source>
          <target state="translated">メソッドを&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;に変更する場合は、代わりに&lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; を&lt;/a&gt;使用してください。これは、アップロードされたリソースではなく、次のような確認メッセージである&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;メソッドに応答する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="8606d0b35470c00c20840dcc3a06c5fbe9904c62" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept = [ ( &quot;,&quot; / ( media-range [ accept-params ] ) ) *( OWS &quot;,&quot; [
    OWS ( media-range [ accept-params ] ) ] ) ]
   Accept-Charset = *( &quot;,&quot; OWS ) ( ( charset / &quot;*&quot; ) [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( ( charset / &quot;*&quot; ) [ weight ] ) ] )
   Accept-Encoding = [ ( &quot;,&quot; / ( codings [ weight ] ) ) *( OWS &quot;,&quot; [ OWS
    ( codings [ weight ] ) ] ) ]
   Accept-Language = *( &quot;,&quot; OWS ) ( language-range [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( language-range [ weight ] ) ] )
   Allow = [ ( &quot;,&quot; / method ) *( OWS &quot;,&quot; [ OWS method ] ) ]

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Content-Encoding = *( &quot;,&quot; OWS ) content-coding *( OWS &quot;,&quot; [ OWS
    content-coding ] )
   Content-Language = *( &quot;,&quot; OWS ) language-tag *( OWS &quot;,&quot; [ OWS
    language-tag ] )
   Content-Location = absolute-URI / partial-URI
   Content-Type = media-type

   Date = HTTP-date

   Expect = &quot;100-continue&quot;

   From = mailbox

   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date

   IMF-fixdate = day-name &quot;,&quot; SP date1 SP time-of-day SP GMT

   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   RWS = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds 

   Server = product *( RWS ( product / comment ) )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   User-Agent = product *( RWS ( product / comment ) )

   Vary = &quot;*&quot; / ( *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ]
    ) )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]
   accept-params = weight *accept-ext
   asctime-date = day-name SP date3 SP time-of-day SP year

   charset = token
   codings = content-coding / &quot;identity&quot; / &quot;*&quot;
   comment = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   content-coding = token

   date1 = day SP month SP year
   date2 = day &quot;-&quot; month &quot;-&quot; 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   field-name = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   hour = 2DIGIT

   language-range = &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;
   language-tag = &amp;lt;Language-Tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   media-range = ( &quot;*/*&quot; / ( type &quot;/*&quot; ) / ( type &quot;/&quot; subtype ) ) *( OWS
    &quot;;&quot; OWS parameter ) 

   media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date / asctime-date

   parameter = token &quot;=&quot; ( token / quoted-string )
   partial-URI = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   product = token [ &quot;/&quot; product-version ]
   product-version = token
   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   qvalue = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )

   &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   subtype = token

   time-of-day = hour &quot;:&quot; minute &quot;:&quot; second
   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   type = token

   weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue

   year = 4DIGIT 

Index

   1
      1xx Informational (status code class)  50

   2
      2xx Successful (status code class)  51

   3
      3xx Redirection (status code class)  54

   4
      4xx Client Error (status code class)  58

   5
      5xx Server Error (status code class)  62

   1
      100 Continue (status code)  50
      100-continue (expect value)  34
      101 Switching Protocols (status code)  50

   2
      200 OK (status code)  51
      201 Created (status code)  52
      202 Accepted (status code)  52
      203 Non-Authoritative Information (status code)  52
      204 No Content (status code)  53
      205 Reset Content (status code)  53

   3
      300 Multiple Choices (status code)  55
      301 Moved Permanently (status code)  56
      302 Found (status code)  56
      303 See Other (status code)  57
      305 Use Proxy (status code)  58
      306 (Unused) (status code)  58
      307 Temporary Redirect (status code)  58

   4
      400 Bad Request (status code)  58
      402 Payment Required (status code)  59
      403 Forbidden (status code)  59
      404 Not Found (status code)  59
      405 Method Not Allowed (status code)  59
      406 Not Acceptable (status code)  59
      408 Request Timeout (status code)  60
      409 Conflict (status code)  60 

      410 Gone (status code)  60
      411 Length Required (status code)  61
      413 Payload Too Large (status code)  61
      414 URI Too Long (status code)  61
      415 Unsupported Media Type (status code)  62
      417 Expectation Failed (status code)  62
      426 Upgrade Required (status code)  62

   5
      500 Internal Server Error (status code)  63
      501 Not Implemented (status code)  63
      502 Bad Gateway (status code)  63
      503 Service Unavailable (status code)  63
      504 Gateway Timeout (status code)  63
      505 HTTP Version Not Supported (status code)  64

   A
      Accept header field  38
      Accept-Charset header field  40
      Accept-Encoding header field  41
      Accept-Language header field  42
      Allow header field  72

   C
      cacheable  24
      compress (content coding)  11
      conditional request  36
      CONNECT method  30
      content coding  11
      content negotiation  6
      Content-Encoding header field  12
      Content-Language header field  13
      Content-Location header field  15
      Content-Transfer-Encoding header field  89
      Content-Type header field  10

   D
      Date header field  67
      deflate (content coding)  11
      DELETE method  29

   E
      Expect header field  34

   F
      From header field  44 

   G
      GET method  24
      Grammar
         Accept  38
         Accept-Charset  40
         Accept-Encoding  41
         accept-ext  38
         Accept-Language  42
         accept-params  38
         Allow  72
         asctime-date  66
         charset  9
         codings  41
         content-coding  11
         Content-Encoding  12
         Content-Language  13
         Content-Location  15
         Content-Type  10
         Date  67
         date1  65
         day  65
         day-name  65
         day-name-l  65
         delay-seconds  69
         Expect  34
         From  44
         GMT  65
         hour  65
         HTTP-date  65
         IMF-fixdate  65
         language-range  42
         language-tag  13
         Location  68
         Max-Forwards  36
         media-range  38
         media-type  8
         method  21
         minute  65
         month  65
         obs-date  66
         parameter  8
         product  46
         product-version  46
         qvalue  38
         Referer  45
         Retry-After  69
         &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  66
         second  65 

         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip (content coding)  11

   H
      HEAD method  25

   I
      idempotent  23

   L
      Location header field  68

   M
      Max-Forwards header field  36
      MIME-Version header field  89

   O
      OPTIONS method  31

   P
      payload  17
      POST method  25
      PUT method  26

   R
      Referer header field  45
      representation  7
      Retry-After header field  69

   S
      safe  22
      selected representation  7, 71
      Server header field  73
      Status Codes Classes
         1xx Informational  50
         2xx Successful  51
         3xx Redirection  54
         4xx Client Error  58
         5xx Server Error  62 

   T
      TRACE method  32

   U
      User-Agent header field  46

   V
      Vary header field  70

   X
      x-compress (content coding)  11
      x-gzip (content coding)  11

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                  [Page 101]</source>
          <target state="translated">以下の収集されたABNFでは、リストルールが&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;セクション&lt;/a&gt;1.2に従って拡張されています。 Accept = [（ &quot;、&quot; /（media-range [accept-params]））*（OWS &quot;、&quot; [OWS（media-range [accept-params]）]）] Accept-Charset = *（ &quot;、&quot; OWS ）（（charset / &quot;*&quot;）[weight]）*（OWS &quot;、&quot; [OWS（（charset / &quot;*&quot;）[weight]）]）Accept-Encoding = [（ &quot;、&quot; /（codings [weight] ））*（OWS &quot;、&quot; [OWS（codings [weight]）]）] Accept-Language = *（ &quot;、&quot; OWS）（language-range [weight]）*（OWS &quot;、&quot; [OWS（language-range [重み]）]）許可= [（ &quot;、&quot; /メソッド）*（OWS &quot;、&quot; [OWSメソッド））] BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; Content-Encoding = *（ &quot;、&quot; OWS）content-coding *（OWS &quot;、&quot; [OWS content-coding]）Content-Language = *（ &quot;、&quot; OWS）言語タグ*（OWS &quot;、&quot; [OWS言語タグ]）Content-Location = absolute-URI / partial-URI Content-Type = media-type Date = HTTP-date Expect = &quot;100-continue&quot; From = mailbox GMT =％x47.4D.54; GMT HTTP-date = IMF-fixdate / obs-date IMF-fixdate = day-name &quot;、&quot; SP date1 SP time-of-day SP GMT Location = URI-reference Max-Forwards = 1 * DIGIT OWS = &amp;lt;OWS、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt;リファラー=絶対URI /部分URI再試行後= HTTP日付/遅延秒数サーバー=製品*（RWS（製品/コメント））URI参照= &amp;lt;URI参照、参照&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt; User-Agent = product *（RWS（product / comment））Vary = &quot;*&quot; /（*（ &quot;、&quot; OWS）field-name *（OWS &quot;、&quot; [OWS field-name] ））absolute-URI = &amp;lt;absolute-URI、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]のセクション2.7を&lt;/a&gt;参照&amp;gt; accept-ext = OWS &quot;;&quot; OWSトークン[&quot;=&quot;（token / quoted-string）] accept-params = weight * accept-ext asctime-date = day-name SP date3 SP time-of-day SP year charset = tokencodings = content-coding / &quot; identity &quot;/&quot; * &quot;コメント= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.6&amp;gt; content-coding = token date1 =日SP月SP年date2 =日 &quot;-&quot;月 &quot;-&quot; 2DIGIT date3 =月SP（2DIGIT /（SP DIGIT））日= 2DIGIT日名=％x4D.6F.6E;月/%x54.75.65;火/%x57.65.64;水/％x54.68.75;木/％x46.72.69;金/％x53.61.74;土/％x53.75.6E;日曜日名-l =％x4D.6F.6E.64.61.79;月曜日/％x54.75.65.73.64.61.79;火曜日/％x57.65.64.6E.65.73.64.61.79;水曜日/％x54.68.75.72.73.64.61.79;木曜日/％x46.72.69.64.61.79;金曜日/％x53.61.74.75.72.64.61.79;土曜日/％x53.75.6E.64.61.79;日曜日の遅延秒数= 1 * DIGITフィールド名= &amp;lt;コメント、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]、セクション3.2を&lt;/a&gt;参照&amp;gt;時間= 2DIGIT言語範囲= &amp;lt;言語範囲、&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647]、セクション2.1を&lt;/a&gt;参照&amp;gt; language-tag = &amp;lt;Language-Tag、&lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646]、セクション2.1を&lt;/a&gt;参照&amp;gt; mailbox = &amp;lt;メールボックス、&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]、セクション3.4を&lt;/a&gt;参照&amp;gt; media-range =（ &quot;* / *&quot; /（type &quot;/ *&quot;）/ （タイプ &quot;/&quot;サブタイプ））*（OWS &quot;;&quot; OWSパラメータ）media-type =タイプ &quot;/&quot;サブタイプ*（OWS &quot;;&quot; OWSパラメータ）メソッド=トークン分= 2DIGIT月=％x4A.61.6E; 1月/％x46.65.62; 2月/％x4D.61.72; 3月/％x41.70.72; 4月/％x4D.61.79; 5月/％x4A.75.6E; 6月/％x4A.75.6C; 7月/％x41.75.67; 8月/％x53.65.70; 9月/％x4F.63.74; 10月/％x4E.6F.76; 11月/％x44.65.63; Dec obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date / asctime-dateパラメータ= token &quot;=&quot;（token / quoted-string）partial-URI = &amp;lt;partial-URI、 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7を参照&lt;/a&gt;&amp;gt; product = token [&quot;/&quot; product-version] product-version = token quoted-string = &amp;lt;quoted-string、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、Section 3.2.6&lt;/a&gt; &amp;gt; qvalue =（ &quot;0&quot; [&quot;。&quot; * 3DIGIT]） /（ &quot;1&quot; [&quot;。&quot; * 3 &quot;0&quot;]） &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date = day-name-l &quot;、&quot; SP date2 SP時刻SP GMT秒= 2DIGITサブタイプ=トークン時刻=時 &quot;：&quot;分 &quot;：&quot;秒トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.6&amp;gt;タイプ=トークンの重み= OWS &quot;;&quot; OWS &quot;q =&quot;qvalue年= 4DIGITインデックス1 1xx情報（ステータスコードクラス）50 2 2xx成功（ステータスコードクラス）51 3 3xxリダイレクト（ステータスコードクラス）54 4 4xxクライアントエラー（ステータスコードクラス）58 5 5xxサーバーエラー（ステータスコードクラス） ）62 1 100続行（ステータスコード）50100-継続（期待値）34101スイッチングプロトコル（ステータスコード）50 2200 OK（ステータスコード）51201作成（ステータスコード）52202承認（ステータスコード）52203非-信頼できる情報（ステータスコード）52204コンテンツなし（ステータスコード）53205コンテンツのリセット（ステータスコード）53 3300複数の選択肢（ステータスコード）55301永久に移動（ステータスコード）56302検出（ステータスコード）56 303参照その他（ステータスコード）57305使用プロキシ（ステータスコード）58306（未使用）（ステータスコード）58307一時的なリダイレクト（ステータスコード）58 4400不正なリクエスト（ステータスコード）58402支払いが必要（ステータスコード）59403禁止（ステータスコード）59404見つかりません（ステータスコード）59 405メソッドは許可されていません（ステータスコード）59 406受け入れられません（ステータスコード）59 408リクエストタイムアウト（ステータスコード）60 409競合（ステータスコード）60410存在しない（ステータスコード）60 411長さが必要（ステータスコード） ）61 413ペイロードが大きすぎます（ステータスコード）61 414 URIが長すぎます（ステータスコード）61 415サポートされていないメディアタイプ（ステータスコード）62417予期しない失敗（ステータスコード）62426アップグレードが必要です（ステータスコード）62 5500内部サーバーエラー（ステータスコード）63 501未実装（ステータスコード）63502不正なゲートウェイ（ステータスコード）63 503サービスを利用できません（ステータスコード）63 504ゲートウェイのタイムアウト（ステータスコード）63 505サポートされていないHTTPバージョン（ステータスコード）64 A Acceptヘッダーフィールド38 Accept-Charsetヘッダーフィールド40 Accept-Encodingヘッダーフィールド41 Accept-Languageヘッダーフィールド42 Allowヘッダーフィールド72 Cキャッシュ可能24圧縮（コンテンツコーディング）11条件付き要求36 CONNECTメソッド30コンテンツコーディング11コンテンツネゴシエーション6 Content-Encodingヘッダーフィールド12 Content-Languageヘッダーフィールド13 Content-Locationヘッダーフィールド15 Content-Transfer-Encodingヘッダーフィールド89 Content-Typeヘッダーフィールド10 D日付ヘッダーフィールド67 deflate（コンテンツコーディング）11 DELETEメソッド29 E Expectヘッダーフィールド34 F Fromヘッダーフィールド44 G GETメソッド24文法Accept 38 Accept-Charset 40 Accept-Encoding 41 accept-ext 38 Accept-Language 42 accept-params 38 Allow 72 asctime-date 66 charset 9codings 41 content-coding 11 Content-エンコーディング12 Content-Language 13 Content-Location 15 Content-Type 10 Date 67 date1 65 day 65 day-name 65 day-name-l 65 delay-seconds 69 Expect 34 From 44 GMT 65 hour 65 HTTP-date 65 IMF-fixdate 65言語範囲42言語タグ13場所68最大転送36メディア範囲38media-type 8 method 21 min 65 month 65 obs-date 66 parameter 8 product 46 product-version 46 qvalue 38 Referer 45 Retry-After 69 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date 66秒65 Server 73サブタイプ8 time-of-day 65タイプ8 User-Agent 46 Vary 70重量38年65 gzip（コンテンツコーディング）11 H HEADメソッド25 Iべき等23 L Locationヘッダーフィールド68 M Max-Forwardsヘッダーフィールド36 MIME-Versionヘッダーフィールド89 O OPTIONSメソッド31 Pペイロード17 POSTメソッド25 PUTメソッド26 Rリファラーヘッダーフィールド45表現7 Retry-Afterヘッダーフィールド69 Sセーフ22選択された表現771サーバーヘッダーフィールド73ステータスコードクラス1xx情報50 2xx成功51 3xxリダイレクション54 4xxクライアントエラー58 5xxサーバーエラー62 T TRACEメソッド32 Uユーザーエージェントヘッダーフィールド46 V可変ヘッダーフィールド70 X x-compress（コンテンツコーディング）11 x-gzip（コンテンツコーディング）11著者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI：CA 95110 USAメール：fielding@gbiv.com URI：CA 95110 USAメール：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（editor）greenbytes GmbH Hafenweg 16 Muenster、NW 48155 Germany Eメール：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke Standards Track [Page 101]</target>
        </trans-unit>
        <trans-unit id="e5c21a021da725c4cf94f0a415f9a51eddeeff8c" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept-Ranges = acceptable-ranges

   Content-Range = byte-content-range / other-content-range

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Range = entity-tag / HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Range = byte-ranges-specifier / other-ranges-specifier

   acceptable-ranges = ( *( &quot;,&quot; OWS ) range-unit *( OWS &quot;,&quot; [ OWS
    range-unit ] ) ) / &quot;none&quot;

   byte-content-range = bytes-unit SP ( byte-range-resp /
    unsatisfied-range )
   byte-range = first-byte-pos &quot;-&quot; last-byte-pos
   byte-range-resp = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
   byte-range-set = *( &quot;,&quot; OWS ) ( byte-range-spec /
    suffix-byte-range-spec ) *( OWS &quot;,&quot; [ OWS ( byte-range-spec /
    suffix-byte-range-spec ) ] )
   byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
   byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
   bytes-unit = &quot;bytes&quot;

   complete-length = 1*DIGIT

   entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;

   first-byte-pos = 1*DIGIT

   last-byte-pos = 1*DIGIT

   other-content-range = other-range-unit SP other-range-resp
   other-range-resp = *CHAR
   other-range-set = 1*VCHAR
   other-range-unit = token
   other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set

   range-unit = bytes-unit / other-range-unit

   suffix-byte-range-spec = &quot;-&quot; suffix-length 

   suffix-length = 1*DIGIT

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   unsatisfied-range = &quot;*/&quot; complete-length

Index

   2
      206 Partial Content (status code)  10

   4
      416 Range Not Satisfiable (status code)  15

   A
      Accept-Ranges header field  7

   C
      Content-Range header field  12

   G
      Grammar
         Accept-Ranges  7
         acceptable-ranges  7
         byte-content-range  12
         byte-range  12
         byte-range-resp  12
         byte-range-set  5
         byte-range-spec  5
         byte-ranges-specifier  5
         bytes-unit  5
         complete-length  12
         Content-Range  12
         first-byte-pos  5
         If-Range  9
         last-byte-pos  5
         other-content-range  12
         other-range-resp  12
         other-range-unit  5, 7
         Range  8
         range-unit  5
         ranges-specifier  5
         suffix-byte-range-spec  6
         suffix-length  6
         unsatisfied-range  12 

   I
      If-Range header field  9

   M
      Media Type
         multipart/byteranges  18, 21
         multipart/x-byteranges  19
      multipart/byteranges Media Type  18, 21
      multipart/x-byteranges Media Type  21

   R
      Range header field  8

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Yves Lafon (editor)
   World Wide Web Consortium
   W3C / ERCIM
   2004, rte des Lucioles
   Sophia-Antipolis, AM  06902
   France

   EMail: ylafon@w3.org
   URI:   &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http://www.raubacapeu.net/people/yves/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 25]</source>
          <target state="translated">以下の収集されたABNFでは、リストルールが&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;セクション&lt;/a&gt;1.2に従って拡張されています。Accept-Ranges = Acceptable-ranges Content-Range = byte-content-range / other-content-range HTTP-date = &amp;lt;HTTP-date、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、Section 7.1.1.1&lt;/a&gt; &amp;gt; If-Range = entity-tag / HTTP -date OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt;範囲=バイト範囲指定子/その他の範囲指定子許容範囲=（*（ &quot;、&quot; OWS）範囲単位*（OWS &quot;、&quot; [OWS範囲単位]））/ &quot;なし&quot;バイト内容-range = bytes-unit SP（byte-range-resp / unsatisfied-range）byte-range = first-byte-pos &quot;-&quot; last-byte-pos byte-range-resp = byte-range &quot;/&quot;（complete- length / &quot;*&quot;）byte-range-set = *（ &quot;、&quot; OWS）（byte-range-spec / suffix-byte-range-spec）*（OWS &quot;、&quot; [OWS（byte-range-spec / suffix -byte-range-spec）]）byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos] byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set bytes-unit = &quot;バイト&quot;完全長= 1 * DIGITエンティティタグ= &amp;lt;エンティティタグ、&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]を&lt;/a&gt;参照、セクション2.3&amp;gt; first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT other-content-range = other-range-unit SP other-range-resp other-range-resp = * CHAR other-range-set = 1 * VCHAR other-range-unit = token other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set range-unit = bytes-unit / other-range-unit suffix-byte-range-spec = &quot;-&quot; suffix-length suffix-length = 1 * DIGIT token = &amp;lt;token、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、Section 3.2.6&lt;/a&gt;&amp;gt; unsatisfied-range = &quot;* /&quot;完全長インデックス2 206部分的なコンテンツ（ステータスコード）10 4416範囲が満たされていません（ステータスコード）15 A Accept-Rangesヘッダーフィールド7 C Content-Rangeヘッダーフィールド12 G文法Accept-範囲7許容範囲7バイトコンテンツ範囲12バイト範囲12バイト範囲応答12バイト範囲セット5バイト範囲仕様5バイト範囲指定子5バイト単位5完全長12コンテンツ範囲12 first-byte-pos 5 If-Range 9 last-byte-pos 5 other-content-range 12 other-range-resp 12 other-range-unit 57範囲8範囲単位5範囲指定子5 suffix-byte-range-spec 6 suffix-length 6 unsatisfied-range 12 I If-Rangeヘッダーフィールド9 Mメディアタイプmultipart / byteranges 18、21 multipart / x-byteranges 19 multipart / byterangesメディアタイプ18、21 multipart / x-byterangesメディアタイプ21 R範囲ヘッダーフィールド8作成者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USA EMail：fielding@gbiv.com URI ：21 multipart / x-byterangesメディアタイプ21 R範囲ヘッダーフィールド8作者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI：21 multipart / x-byterangesメディアタイプ21 R範囲ヘッダーフィールド8作者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Yves Lafon（editor）World Wide Web Consortium W3C / ERCIM 2004、rte des Lucioles Sophia-Antipolis、AM 06902 Franceメール：ylafon@w3.org URI： &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http：//www.raubacapeu .net / people / yves /&lt;/a&gt; Julian F. Reschke（編集者）greenbytes GmbH Hafenweg 16 Muenster、NW 48155ドイツEメール：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fieldingなど。規格トラック[ページ25]</target>
        </trans-unit>
        <trans-unit id="7f7187563510f7b95d508990280bc6d64358c455" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Age = delta-seconds

   Cache-Control = *( &quot;,&quot; OWS ) cache-directive *( OWS &quot;,&quot; [ OWS
    cache-directive ] )

   Expires = HTTP-date

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Pragma = *( &quot;,&quot; OWS ) pragma-directive *( OWS &quot;,&quot; [ OWS
    pragma-directive ] )

   Warning = *( &quot;,&quot; OWS ) warning-value *( OWS &quot;,&quot; [ OWS warning-value ]
    )

   cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   field-name = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   pragma-directive = &quot;no-cache&quot; / extension-pragma
   pseudonym = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   uri-host = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   warn-code = 3DIGIT
   warn-date = DQUOTE HTTP-date DQUOTE
   warn-text = quoted-string
   warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
    ] 

Index

   1
      110 (warn-code)  31
      111 (warn-code)  31
      112 (warn-code)  31
      113 (warn-code)  31
      199 (warn-code)  32

   2
      214 (warn-code)  32
      299 (warn-code)  32

   A
      age  11
      Age header field  21

   C
      cache  4
      cache entry  5
      cache key  5-6
      Cache-Control header field  21

   D
      Disconnected Operation (warn-text)  31

   E
      Expires header field  28
      explicit expiration time  11

   F
      fresh  11
      freshness lifetime  11

   G
      Grammar
         Age  21
         Cache-Control  22
         cache-directive  22
         delta-seconds  5
         Expires  28
         extension-pragma  29
         Pragma  29
         pragma-directive  29
         warn-agent  29
         warn-code  29
         warn-date  29
         warn-text  29 

         Warning  29
         warning-value  29

   H
      Heuristic Expiration (warn-text)  31
      heuristic expiration time  11
   M
      max-age (cache directive)  22, 26
      max-stale (cache directive)  22
      min-fresh (cache directive)  22
      Miscellaneous Persistent Warning (warn-text)  32
      Miscellaneous Warning (warn-text)  32
      must-revalidate (cache directive)  24

   N
      no-cache (cache directive)  23, 25
      no-store (cache directive)  23, 24
      no-transform (cache directive)  23, 25

   O
      only-if-cached (cache directive)  23

   P
      Pragma header field  29
      private (cache directive)  25
      private cache  4
      proxy-revalidate (cache directive)  26
      public (cache directive)  25

   R
      Response is Stale (warn-text)  30
      Revalidation Failed (warn-text)  31

   S
      s-maxage (cache directive)  27
      shared cache  4
      stale  11
      strong validator  18

   T
      Transformation Applied (warn-text)  32

   V
      validator  16

   W
      Warning header field  29 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Mark Nottingham (editor)
   Akamai

   EMail: mnot@mnot.net
   URI:   &lt;a href=&quot;http://www.mnot.net/&quot;&gt;http://www.mnot.net/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 43]</source>
          <target state="translated">以下の収集されたABNFでは、リストルールが&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;セクション&lt;/a&gt;1.2に従って拡張されています。エージ=デルタ秒Cache-Control = *（ &quot;、&quot; OWS）cache-directive *（OWS &quot;、&quot; [OWS cache-directive]）Expires = HTTP-date HTTP-date = &amp;lt;HTTP-date、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231] 、セクション7.1.1.1&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.3 &amp;gt;プラグマ= *（ &quot;、&quot; OWS）プラグマディレクティブ*（OWS &quot;、&quot; [OWSプラグマディレクティブ））警告= *（ &quot;、&quot; OWS）警告値*（OWS &quot;、&quot; [OWS警告値]）cache-directive = token [&quot;=&quot;（token / quoted-string）] delta-seconds = 1 * DIGIT extension-pragma = token [&quot;=&quot;（トークン/引用文字列）]フィールド名= &amp;lt;フィールド名、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]のセクション3.2を&lt;/a&gt;参照&amp;gt; port = &amp;lt;port、see&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]、セクション2.7&lt;/a&gt; &amp;gt; pragma-directive = &quot;no-cache&quot; / extension-pragma pseudonym = &amp;lt;pseudonym、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]、Section 5.7.1&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、Section 3.2.6&lt;/a&gt; &amp;gt;トークン= &amp;lt;トークン、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション3.2.6 &amp;gt; uri-host = &amp;lt;uri-host、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]を&lt;/a&gt;参照、セクション2.7&amp;gt; warn-agent =（uri-host [&quot;：&quot;port））/ pseudonym warn-code = 3DIGIT warn-date = DQUOTE HTTP-date DQUOTE warn-text = quoted-string warning-value = warn-code SP warn-agent SP warn-text [SP warn-date] Index 1 110 （警告コード）31111（警告コード）31112（警告コード）31113（警告コード）31 199（警告コード）32 2214（警告コード）32299（警告コード）32 A age 11 Ageヘッダーフィールド21 Cキャッシュ4キャッシュエントリ5キャッシュキー5-6 Cache-Controlヘッダーフィールド21 D Disconnected Operation（warn-text）31 E Expiresヘッダーフィールド28明示的な有効期限11 F fresh 11フレッシュネスライフタイム11 G Grammar Age 21キャッシュ制御22キャッシュディレクティブ22デルタ秒5有効期限28extension-pragma 29 Pragma 29 pragma-directive 29 warn-agent 29 warn-code 29 warn-date 29 warn-text 29 Warning 29 warning-value 29 H Heuristic Expiration（warn-text）31 heuristic expiration time 11 M max-age（キャッシュディレクティブ）22、26 max-stale（キャッシュディレクティブ）22 min-fresh（キャッシュディレクティブ）22その他の永続的な警告（警告テキスト）32その他の警告（警告テキスト）32必須の修正（キャッシュディレクティブ）24 N no-キャッシュ（キャッシュディレクティブ）23、25非ストア（キャッシュディレクティブ）23、24非変換（キャッシュディレクティブ）23、25 O only-if-cached（キャッシュディレクティブ）23 Pプラグマヘッダーフィールド29プライベート（キャッシュディレクティブ）25プライベートキャッシュ4プロキシ再検証（キャッシュディレクティブ）26パブリック（キャッシュディレクティブ）25 R応答が古い（警告テキスト）30再検証に失敗しました（警告テキスト）31 S s-maxage（キャッシュディレクティブ）27共有キャッシュ4古い11強力なバリデーター18 T変換が適用されました（警告テキスト）32 Vバリデーター16 W警告ヘッダーフィールド29作者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI：フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI：フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Mark Nottingham（editor）Akamai EMail：mnot@mnot.net URI：&lt;a href=&quot;http://www.mnot.net/&quot;&gt;http&lt;/a&gt; ://www.mnot.net/ Julian F. Reschke（editor）greenbytes GmbH Hafenweg 16 Muenster、NW 48155ドイツメール：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding、et al。規格トラック[ページ43]</target>
        </trans-unit>
        <trans-unit id="847bccd23d1c7feafc0bf9bbe4823064cad9878a" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Authorization = credentials

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Proxy-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS
    challenge ] )
   Proxy-Authorization = credentials

   WWW-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS challenge
    ] )

   auth-param = token BWS &quot;=&quot; BWS ( token / quoted-string )
   auth-scheme = token

   challenge = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param ) *(
    OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]
   credentials = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param )
    *( OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   token68 = 1*( ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; )
    *&quot;=&quot; 

Index

   4
      401 Unauthorized (status code)  6
      407 Proxy Authentication Required (status code)  6

   A
      Authorization header field  8

   C
      Canonical Root URI  5

   G
      Grammar
         auth-param  4
         auth-scheme  4
         Authorization  8
         challenge  4
         credentials  5
         Proxy-Authenticate  8
         Proxy-Authorization  9
         token68  4
         WWW-Authenticate  7

   P
      Protection Space  5
      Proxy-Authenticate header field  8
      Proxy-Authorization header field  9

   R
      Realm  5

   W
      WWW-Authenticate header field  7 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 19]</source>
          <target state="translated">以下の収集されたABNFでは、リストルールが&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;セクション&lt;/a&gt;1.2に従って拡張されています。許可=資格情報BWS = &amp;lt;BWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; OWS = &amp;lt;OWS、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、セクション3.2.3を&lt;/a&gt;参照&amp;gt; Proxy-Authenticate = *（ &quot;、&quot; OWS）チャレンジ*（OWS &quot;、&quot; [OWSチャレンジ]）Proxy-Authorization = credentials WWW-Authenticate = *（ &quot;、&quot; OWS）チャレンジ*（OWS &quot;、&quot; [OWSチャレンジ]）auth-param = token BWS &quot;=&quot; BWS（token / quoted-string）auth-scheme = token challenge = auth-scheme [1 * SP（token68 / [（ &quot;、&quot; / auth-param）*（OWS &quot; 、 &quot;[OWS auth-param]）]）] credentials = auth-scheme [1 * SP（token68 / [（&quot;、 &quot;/ auth-param）*（OWS&quot;、 &quot;[OWS auth-param]）]）]] quoted-string = &amp;lt;quoted-string、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、Section 3.2.6&lt;/a&gt; &amp;gt; token = &amp;lt;token、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、Section 3.2.6&lt;/a&gt;&amp;gt; token68 = 1 *（ALPHA / DIGIT / &quot;-&quot; / &quot;。&quot; / &quot;_&quot; / &quot;〜&quot; / &quot;+&quot; / &quot;/&quot;）* &quot;=&quot;インデックス4 401未承認（ステータスコード）6 407プロキシ認証必須（ステータスコード）6 A承認ヘッダーフィールド8 C正規ルートURI 5 G文法auth-param 4 auth-scheme 4承認8チャレンジ4資格情報5プロキシ認証8プロキシ認証9 token68 4 WWW認証7 P保護スペース5プロキシ認証ヘッダーフィールド8プロキシ認証ヘッダーフィールド9 Rレルム5 W WWW認証ヘッダーフィールド7作成者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（editor）greenbytes GmbH Hafenweg 16 Muenster、NW 48155 Germany Eメール：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke Standards Track [Page 19]</target>
        </trans-unit>
        <trans-unit id="feeba52d99d5a0008f5d811bd13452d39d2497a5" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   ETag = entity-tag

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Modified-Since = HTTP-date
   If-None-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Unmodified-Since = HTTP-date

   Last-Modified = HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   entity-tag = [ weak ] opaque-tag
   etagc = &quot;!&quot; / %x23-7E ; '#'-'~'
    / obs-text

   obs-text = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   opaque-tag = DQUOTE *etagc DQUOTE

   weak = %x57.2F ; W/ 

Index

   3
      304 Not Modified (status code)  19

   4
      412 Precondition Failed (status code)  18

   E
      ETag header field  9

   G
      Grammar
         entity-tag  9
         ETag  9
         etagc  9
         If-Match  13
         If-Modified-Since  15
         If-None-Match  14
         If-Unmodified-Since  17
         Last-Modified  7
         opaque-tag  9
         weak  9

   I
      If-Match header field  13
      If-Modified-Since header field  16
      If-None-Match header field  14
      If-Unmodified-Since header field  17

   L
      Last-Modified header field  7

   M
      metadata  5

   S
      selected representation  4

   V
      validator  5
         strong  5
         weak  5 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 28]</source>
          <target state="translated">以下の収集されたABNFでは、リストルールが&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;セクション&lt;/a&gt;1.2に従って拡張されています。 ETag = entity-tag HTTP-date = &amp;lt;HTTP-date、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]、Section 7.1.1.1&lt;/a&gt; &amp;gt; If-Match = &quot;*&quot; /（*（ &quot;、&quot; OWS）entity-tag *（OWS &quot;、&quot; [ OWSエンティティタグ]））If-Modified-Since = HTTP-date If-None-Match = &quot;*&quot; /（*（ &quot;、&quot; OWS）エンティティタグ*（OWS &quot;、&quot; [OWSエンティティタグ]） ）If-Unmodified-Since = HTTP-date Last-Modified = HTTP-date OWS = &amp;lt;OWS、see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]、Section 3.2.3&lt;/a&gt; &amp;gt; entity-tag = [weak] opaque-tag etagc = &quot;！&quot; /％x23-7E; '＃'-'〜' / obs-text obs-text = &amp;lt;obs-text、&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]、セクション3.2.6を&lt;/a&gt;参照&amp;gt; opaque-tag = DQUOTE * etagc DQUOTE weak =％x57.2F; W /インデックス3 304変更なし（ステータスコード）19 4 412前提条件失敗（ステータスコード）18 E ETagヘッダーフィールド9 G文法エンティティタグ9 ETag 9 etagc 9 If-Match 13 If-Modified-Since 15 If-None-一致14 If-Unmodified-Since 17 Last-Modified 7 opaque-tag 9 weak 9 I If-Matchヘッダーフィールド13 If-Modified-Sinceヘッダーフィールド16 If-None-Matchヘッダーフィールド14 If-Unmodified-Sinceヘッダーフィールド17 L最終変更ヘッダーフィールド7 Mメタデータ5 S選択表現4 Vバリデーター5強い5弱い5作者のアドレスロイT.フィールディング（編集者）Adobe Systems Incorporated 345 Park Ave San Jose、CA 95110 USAメール：fielding@gbiv.com URI： &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke（編集者）greenbytes GmbH Hafenweg 16 Muenster、NW 48155ドイツEメール：julian.reschke@greenbytes.de URI：&lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http&lt;/a&gt; ://greenbytes.de/tech/webdav/ Fielding ＆Reschke Standards Track [Page 28]</target>
        </trans-unit>
        <trans-unit id="472f98def3eac77e06a2358d336b65f3adb470f7" translate="yes" xml:space="preserve">
          <source>In the example above, line 3 creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request in line 8. Also, on line 9, a &quot;customized&quot; (non-standard) HTTP request header is set (&lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt;). Such headers are not part of the HTTP/1.1 protocol, but are generally useful to web applications. Since the request uses a Content-Type of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="translated">上記の例では、3 行目で、8行目の &lt;code&gt;POST&lt;/code&gt; リクエストで送信するXML本文を作成しています。また、9行目では、「カスタマイズされた」（非標準の）HTTPリクエストヘッダーが設定されています（ &lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt; ）。このようなヘッダーはHTTP / 1.1プロトコルの一部ではありませんが、一般的にWebアプリケーションに役立ちます。リクエストは &lt;code&gt;application/xml&lt;/code&gt; の Content-Typeを使用し、カスタムヘッダーが設定されているため、このリクエストはプリフライトされます。</target>
        </trans-unit>
        <trans-unit id="90a33fcc28f73464c7c1ed80b477376d44e96863" translate="yes" xml:space="preserve">
          <source>In the first half of the 2010s, Google demonstrated an alternative way of exchanging data between client and server, by implementing an experimental protocol SPDY. This amassed interest from developers working on both browsers and servers. Defining an increase in responsiveness, and solving the problem of duplication of data transmitted, SPDY served as the foundations of the HTTP/2 protocol.</source>
          <target state="translated">2010年代前半、Googleは実験的なプロトコルSPDYを実装することで、クライアントとサーバ間のデータ交換を代替する方法を示しました。これは、ブラウザとサーバの両方の開発者の関心を集めました。応答性の向上を定義し、送信されるデータの重複の問題を解決したSPDYは、HTTP/2プロトコルの基礎となりました。</target>
        </trans-unit>
        <trans-unit id="20562e67671b5bf845611bfa4f3b14fd6e956c7a" translate="yes" xml:space="preserve">
          <source>In the past, specific plug-ins, add-ons or extensions added user agent parts to notify sites they were installed. The recommended way to do this, if it's absolutely necessary (remember that it slows down every request) is to &lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;set a custom HTTP header&lt;/a&gt;.</source>
          <target state="translated">以前は、特定のプラグイン、アドオン、または拡張機能がユーザーエージェントパーツを追加して、インストールされていることをサイトに通知していました。絶対に必要な場合（これによりすべての要求が遅くなることを忘れないでください）、これを行うための推奨される方法は&lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;、カスタムHTTPヘッダー&lt;/a&gt;を設定することです。</target>
        </trans-unit>
        <trans-unit id="312bfeb98e09b0ebf786270e4655ffbe98874e6b" translate="yes" xml:space="preserve">
          <source>In the past, web content was able to access whatever &lt;code&gt;resource:&lt;/code&gt; URIs were desired &amp;mdash; not only Firefox&amp;rsquo;s internal resources, but also extensions&amp;rsquo; assets. Now this behavior is prohibited by default.</source>
          <target state="translated">以前は、Webコンテンツはあらゆる &lt;code&gt;resource:&lt;/code&gt; にアクセスできました。URIが必要でした-Firefoxの内部リソースだけでなく、拡張機能のアセットも必要でした。現在、この動作はデフォルトで禁止されています。</target>
        </trans-unit>
        <trans-unit id="75008cbe2513d02694dbb1b988119207d90d0106" translate="yes" xml:space="preserve">
          <source>In the realm of internationalization, this specification complies
   with the IETF Character Set Policy [&lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt;].  In this specification,
   human-readable fields can be found either in the value of a property,
   or in an error message returned in a response entity body.  In both
   cases, the human-readable content is encoded using XML, which has
   explicit provisions for character set tagging and encoding, and
   requires that XML processors read XML elements encoded, at minimum,
   using the UTF-8 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] and UTF-16 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt;] encodings of the ISO
   10646 multilingual plane.  XML examples in this specification
   demonstrate use of the charset parameter of the Content-Type header
   (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]), as well as XML charset declarations.

   XML also provides a language tagging capability for specifying the
   language of the contents of a particular XML element.  The &quot;xml:lang&quot;
   attribute appears on an XML element to identify the language of its
   content and attributes.  See [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] for definitions of values and
   scoping.

   WebDAV applications MUST support the character set tagging, character
   set encoding, and the language tagging functionality of the XML
   specification.  Implementors of WebDAV applications are strongly
   encouraged to read &quot;XML Media Types&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;] for instruction on
   which MIME media type to use for XML transport, and on use of the
   charset parameter of the Content-Type header.

   Names used within this specification fall into four categories: names
   of protocol elements such as methods and headers, names of XML
   elements, names of properties, and names of conditions.  Naming of
   protocol elements follows the precedent of HTTP, using English names
   encoded in US-ASCII for methods and headers.  Since these protocol
   elements are not visible to users, and are simply long token
   identifiers, they do not need to support multiple languages.
   Similarly, the names of XML elements used in this specification are
   not visible to the user and hence do not need to support multiple
   languages.

   WebDAV property names are qualified XML names (pairs of XML namespace
   name and local name).  Although some applications (e.g., a generic
   property viewer) will display property names directly to their users,
   it is expected that the typical application will use a fixed set of
   properties, and will provide a mapping from the property name and
   namespace to a human-readable field when displaying the property name 

   to a user.  It is only in the case where the set of properties is not
   known ahead of time that an application need display a property name
   to a user.  We recommend that applications provide human-readable
   property names wherever feasible.

   For error reporting, we follow the convention of HTTP/1.1 status
   codes, including with each status code a short, English description
   of the code (e.g., 423 (Locked)).  While the possibility exists that
   a poorly crafted user agent would display this message to a user,
   internationalized applications will ignore this message, and display
   an appropriate message in the user's language and character set.

   Since interoperation of clients and servers does not require locale
   information, this specification does not specify any mechanism for
   transmission of this information.</source>
          <target state="translated">国際化の領域では、この仕様はIETF文字セットポリシー[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt; ]に準拠しています。この仕様では、人間が読めるフィールドは、プロパティの値、または応答エンティティ本体で返されるエラーメッセージのいずれかにあります。どちらの場合も、人間が読めるコンテンツはXMLを使用してエンコードされます。これには、文字セットのタグ付けとエンコードが明示的に規定されており、XMLプロセッサが少なくともUTF-8 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt; ]とUTF-16 を使用してエンコードされたXML要素を読み取る必要があります。[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt; ] ISO 10646多言語プレーンのエンコーディング。この仕様のXMLの例は、Content-Typeヘッダー（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]）、およびXML文字セット宣言。 XMLは、特定のXML要素のコンテンツの言語を指定するための言語タグ付け機能も提供します。 「xml：lang」属性は、コンテンツと属性の言語を識別するためにXML要素に表示されます。値とスコープの定義については、[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]を参照してください。 WebDAVアプリケーションは、XML仕様の文字セットタグ付け、文字セットエンコーディング、および言語タグ付け機能をサポートする必要があります。 WebDAVアプリケーションの実装者は、「XMLメディアタイプ」[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;を読むことを強くお勧めします。] XMLトランスポートに使用するMIMEメディアタイプ、およびContent-Typeヘッダーのcharsetパラメータの使用に関する指示。この仕様で使用される名前は、4つのカテゴリに分類されます。メソッドやヘッダーなどのプロトコル要素の名前、XML要素の名前、プロパティの名前、条件の名前です。プロトコル要素の命名は、メソッドとヘッダーにUS-ASCIIでエンコードされた英語名を使用して、HTTPの前例に従います。これらのプロトコル要素はユーザーには表示されず、単に長いトークン識別子であるため、複数の言語をサポートする必要はありません。同様に、この仕様で使用されるXML要素の名前はユーザーには表示されないため、複数の言語をサポートする必要はありません。WebDAVプロパティ名は、修飾されたXML名（XML名前空間名とローカル名のペア）です。一部のアプリケーション（たとえば、一般的なプロパティビューア）は、プロパティ名をユーザーに直接表示しますが、一般的なアプリケーションは、プロパティの固定セットを使用し、プロパティ名と名前空間から人へのマッピングを提供します。プロパティ名をユーザーに表示するときに読み取り可能なフィールド。アプリケーションがプロパティ名をユーザーに表示する必要があるのは、プロパティのセットが事前にわからない場合のみです。アプリケーションでは、可能な限り人間が読めるプロパティ名を提供することをお勧めします。エラー報告については、HTTP / 1.1ステータスコードの規約に従います。各ステータスコードには、コードの短い英語の説明（例：423（ロック済み））が含まれます。巧妙に作成されていないユーザーエージェントがこのメッセージをユーザーに表示する可能性がありますが、国際化されたアプリケーションはこのメッセージを無視し、ユーザーの言語と文字セットで適切なメッセージを表示します。クライアントとサーバーの相互運用にはロケール情報が必要ないため、この仕様では、この情報を送信するためのメカニズムを指定していません。</target>
        </trans-unit>
        <trans-unit id="08819ce444413d248ed409d1bf3d59a094d39073" translate="yes" xml:space="preserve">
          <source>In this article, we focus on resource URIs, which are used internally by Firefox to point to built-in resources.</source>
          <target state="translated">この記事では、Firefox が内蔵リソースを指すために内部的に使用するリソース URI に焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="0238c032fe8b075e22eb8b6c9fa8e03afd0be1e7" translate="yes" xml:space="preserve">
          <source>In this case, responses can be sent back based on some considerations.</source>
          <target state="translated">この場合、ある程度の配慮をした上で回答を送り返すことができます。</target>
        </trans-unit>
        <trans-unit id="06b277eb0332b7d0f528bc488b7a6ac8fc32ac6b" translate="yes" xml:space="preserve">
          <source>In this case, the server can send back a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) response that will contain the right information, but if the reload button is pressed, only this page is redisplayed, without replaying the unsafe requests.</source>
          <target state="translated">この場合、サーバーは正しい情報を含む&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（その他を参照）応答を返すことができますが、再読み込みボタンが押された場合、危険な要求を再生せずにこのページのみが再表示されます。</target>
        </trans-unit>
        <trans-unit id="18d9fe67ef95cf5048b92cb9c02dafef0b4ac177" translate="yes" xml:space="preserve">
          <source>In this case, you need to configure the server receiving the HTTP requests (which is most likely the same for www and non-www URLs) to respond with an adequate HTTP &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; response to any request to the non-canonical domain. This will redirect the browser trying to access the non-canonical URLs to their canonical equivalent. For example, if you've chosen to use non-www URLs as the canonical type, you should redirect all www URLs to their equivalent URL without the www.</source>
          <target state="translated">この場合、HTTP要求を受信するサーバー（wwwとwww以外のURLで同じである可能性が高い）を構成して、非正規ドメインへの要求に対して適切なHTTP &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;応答で応答する必要があります。これにより、非正規URLにアクセスしようとするブラウザーが、同等の正規URLにリダイレクトされます。たとえば、www以外のURLを正規のタイプとして使用することを選択した場合は、すべてのwww URLをwwwなしの同等のURLにリダイレクトする必要があります。</target>
        </trans-unit>
        <trans-unit id="7847050425f6d076cc4ad765d4143b2fe451ad2c" translate="yes" xml:space="preserve">
          <source>In this example all of the hosts in a given subnet are connected-to directly, others are connected through the proxy:</source>
          <target state="translated">この例では、与えられたサブネット内のすべてのホストが直接接続され、他のホストはプロキシを介して接続されています。</target>
        </trans-unit>
        <trans-unit id="463b3c56a942948bf5001ffa290aad288ddfa0e2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.net/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">この例では、&lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt;は、&lt;strong&gt;本番環境で&lt;/strong&gt;使用されるサーバーの公開鍵を&lt;strong&gt;固定&lt;/strong&gt;します。 2番目のピン宣言&lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt;もバックアップキーをピン&lt;strong&gt;留めし&lt;/strong&gt;ます。&lt;strong&gt;max-age = 5184000&lt;/strong&gt;は、この情報を2か月間保存するようにクライアントに指示します。これは、IETF RFCによると妥当な時間制限です。このキーの固定は、&lt;strong&gt;includeSubDomains&lt;/strong&gt;宣言によって&lt;strong&gt;通知&lt;/strong&gt;されるすべてのサブドメインにも有効です。最後に、&lt;strong&gt;report-uri = &quot;https://www.example.net/hpkp-report&quot;&lt;/strong&gt;は、ピン検証エラーを報告する場所を説明しています。</target>
        </trans-unit>
        <trans-unit id="15fe4fb824d6da70afb6414abaf5dbbc417ed391" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">この例では、&lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt;は、&lt;strong&gt;本番環境で&lt;/strong&gt;使用されるサーバーの公開鍵を&lt;strong&gt;固定&lt;/strong&gt;します。 2番目のピン宣言&lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt;もバックアップキーをピン&lt;strong&gt;留めし&lt;/strong&gt;ます。&lt;strong&gt;max-age = 5184000&lt;/strong&gt;は、この情報を2か月間保存するようにクライアントに指示します。これは、IETF RFCによると妥当な時間制限です。このキーの固定は、&lt;strong&gt;includeSubDomains&lt;/strong&gt;宣言によって&lt;strong&gt;通知&lt;/strong&gt;されるすべてのサブドメインにも有効です。最後に、&lt;strong&gt;report-uri = &quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt;は、ピン検証エラーを報告する場所を説明しています。</target>
        </trans-unit>
        <trans-unit id="7b4d6bd9abca71a4536572bc7fcac564f95ec372" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">この例では、&lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt;は、&lt;strong&gt;本番環境で&lt;/strong&gt;使用されるサーバーの公開鍵を&lt;strong&gt;固定&lt;/strong&gt;します。2番目のピン宣言&lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt;もバックアップキーをピン&lt;strong&gt;留めし&lt;/strong&gt;ます。このキーの固定は、&lt;strong&gt;includeSubDomains&lt;/strong&gt;宣言によって&lt;strong&gt;通知&lt;/strong&gt;されるすべてのサブドメインにも有効です。最後に、&lt;strong&gt;report-uri = &quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt;は、ピン検証エラーを報告する場所を説明しています。</target>
        </trans-unit>
        <trans-unit id="26e35d19a2c9f9c005f9c384d2fca94ef727d3c6" translate="yes" xml:space="preserve">
          <source>In this example, content originally loaded from &lt;code&gt;http://foo.example&lt;/code&gt; makes a simple GET request to a resource on &lt;code&gt;http://bar.other&lt;/code&gt; which sets Cookies. Content on foo.example might contain JavaScript like this:</source>
          <target state="translated">この例では、元々 &lt;code&gt;http://foo.example&lt;/code&gt; からロードされたコンテンツが、Cookieを設定する &lt;code&gt;http://bar.other&lt;/code&gt; 上のリソースに対して単純なGETリクエストを作成します。foo.exampleのコンテンツには、次のようなJavaScriptが含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="1bad895874eb650b248a44ce79a14ea76d8467d2" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;a href=&quot;expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is used at the end of the chunked message and serves as a trailing header.</source>
          <target state="translated">この例では、チャンクされたメッセージの最後に&lt;a href=&quot;expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt;ヘッダーが使用され、後続ヘッダーとして機能します。</target>
        </trans-unit>
        <trans-unit id="d3619c052570e6c7b13df3247db7eb34508081c2" translate="yes" xml:space="preserve">
          <source>In this example, the domain name &quot;&lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt;&quot; will be pre-resolved.</source>
          <target state="translated">この例では、ドメイン名「&lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt;」が事前に解決されます。</target>
        </trans-unit>
        <trans-unit id="ece92baae1897d8ad92e5e7a0a62d4670b062563" translate="yes" xml:space="preserve">
          <source>In this example, the user agent string is mobile safari version. It contains the word &quot;Mobile&quot;.</source>
          <target state="translated">この例では、ユーザーエージェント文字列はモバイルサファリバージョンです。これには「モバイル」という単語が含まれています。</target>
        </trans-unit>
        <trans-unit id="bb7d3fc0025e51622cf41c74720e5e287c75d33c" translate="yes" xml:space="preserve">
          <source>In this response, &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; indicates that bytes can be used as unit to define a range. Here the &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header is also useful as it indicates the full size of the image to retrieve.</source>
          <target state="translated">このレスポンスの &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; は、バイトを単位として使用して範囲を定義できることを示しています。ここで、&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;ヘッダーは、取得する画像のフルサイズを示すので便利です。</target>
        </trans-unit>
        <trans-unit id="795b5c095ca34b9eb4357638cfdaae755baa1753" translate="yes" xml:space="preserve">
          <source>In this section, the final line of each section gives the element
   type declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).  Note that all of the elements defined
   here may be extended according to the rules defined in &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;.
   All elements defined here are in the &quot;DAV:&quot; namespace.</source>
          <target state="translated">このセクションでは、各セクションの最後の行に、[ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]で定義されたフォーマットを使用した要素タイプ宣言を示しています。「Value」フィールドが存在する場合は、BNFを使用してXMLエレメントの許容されるコンテンツに対する追加の制限を指定します（つまり、PCDATAエレメントの値をさらに制限するため）。ここで定義されているすべての要素は、&lt;a href=&quot;#section-17&quot;&gt;セクション17で&lt;/a&gt;定義されている規則に従って拡張できることに注意してください。ここで定義されているすべての要素は、「DAV：」名前空間にあります。</target>
        </trans-unit>
        <trans-unit id="179432a2d14c1874e18b6638eed524eeb5842b02" translate="yes" xml:space="preserve">
          <source>Included in the response message from the server during the opening handshake process when the server is willing to initiate a WebSocket connection. It will appear no more than once in the response headers.</source>
          <target state="translated">サーバが WebSocket 接続を開始する意思があるときに、オープン・ハンドシェイク・プロセス中にサーバからの応答メッセージに含まれます。これは、応答ヘッダに一度しか表示されません。</target>
        </trans-unit>
        <trans-unit id="9cab054870dbf49daaae3aee35de09e7abf09a42" translate="yes" xml:space="preserve">
          <source>Incomplete results: a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt; (Partial Content) response.</source>
          <target state="translated">不完全な結果：&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt;（部分的なコンテンツ）応答。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="522b16bedc865c8cbd64e7b9adb9223fbc62cbb9" translate="yes" xml:space="preserve">
          <source>IndexedDB (for each database execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt;&lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IndexedDB（データベースごとに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt; &lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt; を&lt;/a&gt;実行します）、</target>
        </trans-unit>
        <trans-unit id="77a0f0c640c4020f67d5dbd8adc3745275738665" translate="yes" xml:space="preserve">
          <source>Indicates a URL path that must exist in the requested resource before sending the Cookie header. The %x2F (&quot;/&quot;) character is interpreted as a directory separator and sub directories will be matched as well (e.g. path=/docs, &quot;/docs&quot;, &quot;/docs/Web/&quot;, or &quot;/docs/Web/HTTP&quot; will all be matched).</source>
          <target state="translated">クッキーヘッダを送信する前に、要求されたリソース内に存在する必要がある URL パスを示します。x2F (&quot;/&quot;)文字はディレクトリの区切り文字として解釈され、サブディレクトリも同様にマッチします (例:path=/docs、&quot;/docs&quot;,&quot;/docs/Web/&quot;,&quot;/docs/Web/HTTP&quot; はすべてマッチします)。</target>
        </trans-unit>
        <trans-unit id="2cd7bebabc246b7398c2557d2f27d3f5dfbfc228" translate="yes" xml:space="preserve">
          <source>Indicates an alternate location for the returned data.</source>
          <target state="translated">返されたデータの別の場所を示します。</target>
        </trans-unit>
        <trans-unit id="9bf3af3031e2a167d607e233517fe07840ad0ce2" translate="yes" xml:space="preserve">
          <source>Indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">リクエストを適切に処理するためにサーバが満たす必要がある期待値を示す。</target>
        </trans-unit>
        <trans-unit id="552935b2453887e59cf2e4f3e94e2e9ac12d93ef" translate="yes" xml:space="preserve">
          <source>Indicates how long the results of a preflight request can be cached.</source>
          <target state="translated">プリフライトリクエストの結果がキャッシュされる期間を示します。</target>
        </trans-unit>
        <trans-unit id="7c9b44d689ef4104318af0511c11748dc3967c95" translate="yes" xml:space="preserve">
          <source>Indicates how long the user agent should wait before making a follow-up request.</source>
          <target state="translated">ユーザーエージェントがフォローアップリクエストを行う前に、どのくらいの時間 待つべきかを示す。</target>
        </trans-unit>
        <trans-unit id="ad3a4c007f7db3dfac95c3ba5f703c8f8dd59961" translate="yes" xml:space="preserve">
          <source>Indicates if the server supports range requests and if so, in which unit the range can be expressed.</source>
          <target state="translated">サーバが範囲要求をサポートしているかどうかを示し、サポートしている場合は、その範囲をどの単位で表現できるかを示します。</target>
        </trans-unit>
        <trans-unit id="3430ae2cd395b1c94c2f79f53999b8989357367e" translate="yes" xml:space="preserve">
          <source>Indicates that either the client or the server would like to close the connection. This is the default on HTTP/1.0 requests.</source>
          <target state="translated">クライアントかサーバのどちらかが接続を閉じたいことを示します。これは HTTP/1.0 リクエストのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="c99b1484ee170cc3fd51d8eb0f92ba2eff8fc73e" translate="yes" xml:space="preserve">
          <source>Indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application.</source>
          <target state="translated">アプリケーションからダウンロードしたファイルをブラウザ(Internet Explorer)に「開く」オプションを表示しないようにすると、ファイルがアプリケーションのコンテキスト内で実行されるようにアクセスされてしまうため、フィッシング攻撃を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="c4f79f8a6a3c8718f3618cea1550c9060b2c9c67" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a response that has exceeded its expiration time. Optionally, you can assign a value in seconds, indicating the time the response must not be expired by.</source>
          <target state="translated">クライアントが有効期限を超えた応答を受け入れることを示します。オプションで、応答が期限切れになってはならない時間を示す秒単位の値を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="06f0d192853b0ab8b3406d2dd070fa47ec20ae34" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response if the check for a fresh one fails. The seconds value indicates for how long the client is willing to accept the stale response after the initial expiration.</source>
          <target state="translated">新しい応答のチェックに失敗した場合、クライアントは古い応答を受け入れても構わないことを示す。秒数は、最初の有効期限が切れた後、クライアントが陳腐な応答を受け入れる意思があることを示す。</target>
        </trans-unit>
        <trans-unit id="deaef90dde647ea30a46f347a0d9e248199a5f91" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response while asynchronously checking in the background for a fresh one. The seconds value indicates for how long the client is willing to accept a stale response.</source>
          <target state="translated">クライアントが古い応答を受け入れても構わないことを示しますが、バックグラウンドで新しい応答を非同期的にチェックしている間、クライアントは古い応答を受け入れます。秒数は、クライアントが古い応答を受け入れる意思があることを示します。</target>
        </trans-unit>
        <trans-unit id="33fbfac7a3753ad2fc4a262b8c0b818d20d43473" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept trailer fields in a chunked transfer coding.</source>
          <target state="translated">クライアントがチャンク化された転送コーディングのトレーラフィールドを受け入れる意思があることを示す。</target>
        </trans-unit>
        <trans-unit id="a44c16e62480d86b3a9b9458e2ea45fed4f4e530" translate="yes" xml:space="preserve">
          <source>Indicates that the client wants a response that will still be fresh for at least the specified number of seconds.</source>
          <target state="translated">クライアントが、少なくとも指定された秒数の間は新鮮なままのレスポンスを要求していることを示します。</target>
        </trans-unit>
        <trans-unit id="b642df972d92ffd9369fe8f647cb5c9e563d0505" translate="yes" xml:space="preserve">
          <source>Indicates that the client would like to keep the connection open. Having a persistent connection is the default on HTTP/1.1 requests. The list of headers are the name of the header to be removed by the first non-transparent proxy or cache in-between: these headers define the connection between the emitter and the first entity, not the destination node.</source>
          <target state="translated">クライアントが接続をオープンしたままにしたいことを示します。HTTP/1.1 リクエストでは、持続的な接続を持つことがデフォルトです。これらのヘッダはエミッタと最初のエンティティ間の接続を定義するものであり、 宛先ノードではありません。</target>
        </trans-unit>
        <trans-unit id="f97447000dd6a21db07563d6ef729be734f5e4a3" translate="yes" xml:space="preserve">
          <source>Indicates that the request has been conveyed in early data.</source>
          <target state="translated">初期データでリクエストが伝達されたことを示す。</target>
        </trans-unit>
        <trans-unit id="5955a042968bb418bc770fb1ac84f6a1e3b04e52" translate="yes" xml:space="preserve">
          <source>Indicates that the response body will not change over time. The resource, if unexpired, is unchanged on the server and therefore the client should not send a conditional revalidation for it (e.g. &lt;code&gt;If-None-Match&lt;/code&gt; or &lt;code&gt;If-Modified-Since&lt;/code&gt;) to check for updates, even when the user explicitly refreshes the page. Clients that aren't aware of this extension must ignore them as per the HTTP specification. In Firefox, &lt;code&gt;immutable&lt;/code&gt; is only honored on &lt;code&gt;https://&lt;/code&gt; transactions. For more information, see also this &lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">応答本文が時間の経過とともに変化しないことを示します。リソースは、有効期限が切れていない場合、サーバー上で変更されていないため、ユーザーが明示的にページを更新した場合でも、クライアントは条件付きの再検証（例： &lt;code&gt;If-None-Match&lt;/code&gt; または &lt;code&gt;If-Modified-Since&lt;/code&gt; ）を送信して更新を確認しないでください。 。この拡張機能を認識していないクライアントは、HTTP仕様に従ってそれらを無視する必要があります。Firefoxでは、 &lt;code&gt;immutable&lt;/code&gt; は &lt;code&gt;https://&lt;/code&gt; トランザクションでのみ有効です。詳細については、この&lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;ブログ投稿&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="7d6f6e0f4b09d76d1dc1ccd2d2b141f2a442a1d2" translate="yes" xml:space="preserve">
          <source>Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.</source>
          <target state="translated">レスポンスが単一のユーザー向けであり、共有キャッシュに保存されてはならないことを示します。プライベートキャッシュはレスポンスを保存することができます。</target>
        </trans-unit>
        <trans-unit id="619c7b97c107a9d7b9f0f9a1bf6f8d31f3066053" translate="yes" xml:space="preserve">
          <source>Indicates that the response may be cached by any cache.</source>
          <target state="translated">レスポンスが任意のキャッシュによってキャッシュされる可能性があることを示します。</target>
        </trans-unit>
        <trans-unit id="0a024414359139c546eb2b06d1c63cbb97a90599" translate="yes" xml:space="preserve">
          <source>Indicates that the server is unwilling to risk processing a request that might be replayed.</source>
          <target state="translated">サーバーが再生される可能性のあるリクエストを処理するリスクを冒したくないことを示す。</target>
        </trans-unit>
        <trans-unit id="1764f0a2dc1d82d92287ff0957396522996daa3d" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to clear all types of data for the origin of the response. If more data types are added in future versions of this header, they will also be covered by it.</source>
          <target state="translated">サーバが応答の元となるデータのすべてのタイプをクリアしたいことを示す。このヘッダの将来のバージョンでより多くのデータタイプが追加された場合、それらのデータタイプもこのヘッダの対象となる。</target>
        </trans-unit>
        <trans-unit id="d0874c17bb0051bdad46f81276a7a676b678ee89" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to reload all browsing contexts for the origin of the response (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt;&lt;code&gt;Location.reload&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">サーバーが応答の発信元のすべてのブラウジングコンテキスト（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt; &lt;code&gt;Location.reload&lt;/code&gt; &lt;/a&gt;）を再ロードすることを希望していることを示します。</target>
        </trans-unit>
        <trans-unit id="cc5b7853c11f1c815426aacf326e6a5f1048b0f0" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all DOM storage for the origin of the response URL. This includes storage mechanisms such as:</source>
          <target state="translated">サーバがレスポンス URL の元となる DOM ストレージをすべて削除したいことを示します。これには、以下のようなストレージメカニズムが含まれます。</target>
        </trans-unit>
        <trans-unit id="ef7e1742a157a2de2bf388f99e235ed9711fd524" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all cookies for the origin of the response URL. HTTP authentication credentials are also cleared out. This affects the entire registered domain, including subdomains. So https://example.com as well as https://stage.example.com, will have cookies cleared.</source>
          <target state="translated">サーバが応答 URL の送信元のすべての Cookie の削除を希望していることを示します。HTTP 認証情報もクリアされます。これはサブドメインを含む登録ドメイン全体に影響します。つまり、https://example.com も https://stage.example.com と同様に、クッキーがクリアされることになります。</target>
        </trans-unit>
        <trans-unit id="ac63007b3c6f50bd4fa2b0ef581a82efee07a128" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove locally cached data (i.e. the browser cache, see &lt;a href=&quot;../caching&quot;&gt;HTTP caching&lt;/a&gt;) for the origin of the response URL. Depending on the browser, this might also clear out things like pre-rendered pages, script caches, WebGL shader caches, or address bar suggestions.</source>
          <target state="translated">サーバーが、応答URLの発信元のローカルにキャッシュされたデータ（つまり、ブラウザーのキャッシュ&lt;a href=&quot;../caching&quot;&gt;。HTTPキャッシュを&lt;/a&gt;参照）を削除したいことを示します。ブラウザーによっては、これにより、事前レンダリングされたページ、スクリプトキャッシュ、WebGLシェーダーキャッシュ、アドレスバーの候補なども消去される場合があります。</target>
        </trans-unit>
        <trans-unit id="cf528554c916e8834415e263fe337623229bfac2" translate="yes" xml:space="preserve">
          <source>Indicates the URL to redirect a page to.</source>
          <target state="translated">ページをリダイレクトするためのURLを示します。</target>
        </trans-unit>
        <trans-unit id="c8fbcc1100e604b3e848463d05946c3ca0c4fdb5" translate="yes" xml:space="preserve">
          <source>Indicates the approximate amount of device RAM. This value is an approximation given by rounding to the nearest power of 2 and dividing that number by 1024. For example, 512 megabytes will be reported as &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">デバイスRAMのおおよその量を示します。この値は、最も近い2の累乗に四捨五入し、その数を1024で除算して得られる概算です。たとえば、512メガバイトは &lt;code&gt;0.5&lt;/code&gt; として報告されます。</target>
        </trans-unit>
        <trans-unit id="79a4facd7bfa2752abc2651ad8a22d1290f85fac" translate="yes" xml:space="preserve">
          <source>Indicates the client's device pixel ratio.</source>
          <target state="translated">クライアントのデバイスのピクセル比率を示す。</target>
        </trans-unit>
        <trans-unit id="7c99e10959087264a8f9f76bbe0fb6c6616be7db" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">ID 機能を示す(すなわち、圧縮も修正もしない)。明示的に指定された場合を除き、このトークンは常に許容可能とみなされる。</target>
        </trans-unit>
        <trans-unit id="300e6bcab08b44f020c00b953beb914707cf781f" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This value is always considered as acceptable, even if not present.</source>
          <target state="translated">ID 機能を示す(すなわち、圧縮も修正もしない)。この値は、存在しない場合でも、常に許容可能な値とみなされます。</target>
        </trans-unit>
        <trans-unit id="4412b21a02fb471172b40a65fca71a926bc03433" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e., no compression or modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">アイデンティティ機能を示す(すなわち、圧縮や修正を行わない)。明示的に指定された場合を除き、このトークンは常に許容可能とみなされる。</target>
        </trans-unit>
        <trans-unit id="76a871a5c993107287ac4f26321af85411e97af4" translate="yes" xml:space="preserve">
          <source>Indicates the layout viewport width in CSS pixels.</source>
          <target state="translated">レイアウトのビューポートの幅をCSSピクセルで表します。</target>
        </trans-unit>
        <trans-unit id="13225f32edcd936d283f2308a7685081e9a67758" translate="yes" xml:space="preserve">
          <source>Indicates the media type of the resource.</source>
          <target state="translated">リソースのメディアタイプを示す。</target>
        </trans-unit>
        <trans-unit id="fc5582911590b64a930b456a56b69a37cf02610d" translate="yes" xml:space="preserve">
          <source>Indicates the part of a document that the server should return.</source>
          <target state="translated">サーバが返すべきドキュメントの部分を示します。</target>
        </trans-unit>
        <trans-unit id="d639acdf32e7294320e546fc64936adb232d2c83" translate="yes" xml:space="preserve">
          <source>Indicates the resource width in physical pixels (in other words the intrinsic size of an image).</source>
          <target state="translated">リソースの幅を物理ピクセル単位で示します(言い換えれば、画像の本質的なサイズ)。</target>
        </trans-unit>
        <trans-unit id="7befcc9a5a8e27a8f507455ba0c663658e48c7d6" translate="yes" xml:space="preserve">
          <source>Indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">対応するリクエストに適用されたトラッキングステータスを示します。</target>
        </trans-unit>
        <trans-unit id="9743929feee03e6db93823d546a5b6519ece671b" translate="yes" xml:space="preserve">
          <source>Indicates to not retrieve new data. This being the case, the server wishes the client to obtain a response only once and then cache. From this moment the client should keep releasing a cached copy and avoid contacting the origin-server to see if a newer copy exists.</source>
          <target state="translated">新しいデータを取得しないことを示します。この場合、サーバはクライアントが一度だけレスポンスを取得してキャッシュすることを望みます。この時点からクライアントはキャッシュされたコピーをリリースし続け、新しいコピーが存在するかどうかを確認するためにオリジンサーバに連絡することを避けなければなりません。</target>
        </trans-unit>
        <trans-unit id="c3f04a324f464c13b3de7ed6c10ccdaea39b71f5" translate="yes" xml:space="preserve">
          <source>Indicates where a fetch originates from.</source>
          <target state="translated">フェッチがどこから来たのかを示します。</target>
        </trans-unit>
        <trans-unit id="850af2d2f10fe8221618b8b2b077bcf0329a3edf" translate="yes" xml:space="preserve">
          <source>Indicates where in a full body message a partial message belongs.</source>
          <target state="translated">フルボディメッセージの中で、部分的なメッセージがどこに属するかを示します。</target>
        </trans-unit>
        <trans-unit id="be2f75e053430254664cae4d27f3e51d38721d53" translate="yes" xml:space="preserve">
          <source>Indicates whether a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ブラウザが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; で&lt;/a&gt;ページをレンダリングできるかどうかを示します</target>
        </trans-unit>
        <trans-unit id="f69a3c7ddba822bcbbe58dfda37543497c04707b" translate="yes" xml:space="preserve">
          <source>Indicates whether the response can be shared.</source>
          <target state="translated">応答を共有できるかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="b1d669ea27317208a9d7ef5173080a7f6aeec565" translate="yes" xml:space="preserve">
          <source>Indicates whether the response to the request can be exposed when the credentials flag is true.</source>
          <target state="translated">クレデンシャルフラグが真の場合に、リクエストに対する応答を公開できるかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="5fc014b0691c6356400a50c33337bc3eb5a7b831" translate="yes" xml:space="preserve">
          <source>Indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">どのヘッダがレスポンスの一部として公開されるかを、その名前をリストアップして示します。</target>
        </trans-unit>
        <trans-unit id="99d7331d101ff2b635886de75d335f15281ec8b0" translate="yes" xml:space="preserve">
          <source>Indicates which protocol was used to make the request (typically &quot;http&quot; or &quot;https&quot;).</source>
          <target state="translated">リクエストを行うためにどのプロトコルが使用されたかを示す (通常は「http」または「https」)。</target>
        </trans-unit>
        <trans-unit id="0c0dafad80f67d7e9dd4f5b440cd064e7a6c1c13" translate="yes" xml:space="preserve">
          <source>Indicating a target audience for a resource</source>
          <target state="translated">リソースの対象者を示す</target>
        </trans-unit>
        <trans-unit id="5a9618787236f752551e7febb8e28aa6e4ab7345" translate="yes" xml:space="preserve">
          <source>Indicating the URL of a transaction's result</source>
          <target state="translated">トランザクションの結果のURLを示す</target>
        </trans-unit>
        <trans-unit id="fca6301092f0f25b345065ddc8bcf56276e0afd5" translate="yes" xml:space="preserve">
          <source>Indicating the language a document is written in</source>
          <target state="translated">文書が書かれている言語の表示</target>
        </trans-unit>
        <trans-unit id="7f8525ef38cab4390ca786bdef36f2a78190d70f" translate="yes" xml:space="preserve">
          <source>Information regarding the HSTS preload list in Chrome : &lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https://www.chromium.org/hsts&lt;/a&gt;</source>
          <target state="translated">ChromeのHSTSプリロードリストに関する情報：&lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https&lt;/a&gt; : //www.chromium.org/hsts</target>
        </trans-unit>
        <trans-unit id="a98006b47abdad4b8d9d147e829058b52579a85e" translate="yes" xml:space="preserve">
          <source>Information responses</source>
          <target state="translated">情報対応</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="9e7c1323910f2b5174a834226f71b3b7aee441c8" translate="yes" xml:space="preserve">
          <source>Informational (Expired)</source>
          <target state="translated">情報提供(期限切れ</target>
        </trans-unit>
        <trans-unit id="1af57283b2cb4e6ccf06b8fbe5453fc2d6fbb913" translate="yes" xml:space="preserve">
          <source>Informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) interim response.</source>
          <target state="translated">クライアントがこのリクエストで（おそらく大きな）メッセージ本文を送信しようとしていることを受信者に通知し、&lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt;（続行）中間応答の受信を希望します。</target>
        </trans-unit>
        <trans-unit id="59f3ea8d1fb37b159cf5cc21991810bccf67d68b" translate="yes" xml:space="preserve">
          <source>Informs the server about the encoding algorithm, usually a compression algorithm, that can be used on the resource sent back.</source>
          <target state="translated">送られてきたリソースで使用できるエンコーディングアルゴリズム (通常は圧縮アルゴリズム)についてサーバに通知する。</target>
        </trans-unit>
        <trans-unit id="ddb5e7a065792d4b30e1cbf2d728a2ac83ecc7bb" translate="yes" xml:space="preserve">
          <source>Informs the server about the language the server is expected to send back. This is a hint and is not necessarily under the full control of the user: the server should always pay attention not to override an explicit user choice (like selecting a language in a drop down list).</source>
          <target state="translated">サーバが返す言語をサーバに通知します。これはヒントであり、必ずしもユーザの完全な制御下にあるわけではありません:サーバは、ユーザの明示的な選択 (ドロップダウンリストで言語を選択するなど)を上書きしないように常に注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="87b0141515a7b36be28ca5afb9e3d2f36da758a0" translate="yes" xml:space="preserve">
          <source>Informs the server about the types of data that can be sent back. It is MIME-type.</source>
          <target state="translated">サーバに、送り返すことができるデータの種類を通知します。MIME タイプです。</target>
        </trans-unit>
        <trans-unit id="eee6e27810ba2393a1392a0340b18fa6717ec6eb" translate="yes" xml:space="preserve">
          <source>Informs the server about which character set the client is able to understand.</source>
          <target state="translated">クライアントがどの文字セットを理解できるかをサーバに通知します。</target>
        </trans-unit>
        <trans-unit id="42cf6c04980a1ce5076cbc436e3d8fd8f9bd1eaa" translate="yes" xml:space="preserve">
          <source>Inheritance of policy for embedded content</source>
          <target state="translated">埋め込みコンテンツのポリシーの継承</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="translated">初期定義</target>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="translated">初期定義。</target>
        </trans-unit>
        <trans-unit id="e33acc0f454b7bc534181d5c180450e08b663048" translate="yes" xml:space="preserve">
          <source>Initial definition. Defines the &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header. Directives are defined in the specs for the features they control. See individual directive pages for details.</source>
          <target state="translated">初期定義。&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;ヘッダーを定義します。ディレクティブは、それらが制御する機能の仕様で定義されています。詳細については、個別のディレクティブページを参照してください。</target>
        </trans-unit>
        <trans-unit id="edd05a55e87a0a4d81fe6d4260b5996b65256986" translate="yes" xml:space="preserve">
          <source>Inline style attributes are also blocked:</source>
          <target state="translated">インラインのスタイル属性もブロックされます。</target>
        </trans-unit>
        <trans-unit id="b1392fca8ed54aab0cc2cacc082edcfe0d478690" translate="yes" xml:space="preserve">
          <source>Inspecting cookies using the Storage Inspector</source>
          <target state="translated">ストレージインスペクタを使用したクッキーの検査</target>
        </trans-unit>
        <trans-unit id="888016dc3b8bc43c7d35e5a67e82071570e7e662" translate="yes" xml:space="preserve">
          <source>Instantiation of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; element will fail if:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;要素のインスタンス化は、次の場合に失敗します：</target>
        </trans-unit>
        <trans-unit id="fcd90298324aef5e8378a11b58c0458589479afd" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;content-security-policy/frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-security-policy/worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; の代わりに、ネストされたブラウジングコンテキストとワーカーを規制する作成者は、それぞれ&lt;a href=&quot;content-security-policy/frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt;ディレクティブとworker-srcディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7d972ef39c5afd44ac2beb99c854651c87a78a6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; の代わりに、ネストされたブラウジングコンテキストとワーカーを規制する作成者は、それぞれ&lt;a href=&quot;frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt;ディレクティブとworker-srcディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2c345c2bb8c9ae2f11a593aebecd152fbd0acd7" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client closes,&lt;em&gt;permanent cookies&lt;/em&gt; expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;永久Cookie&lt;/em&gt;は、クライアントが閉じるときに期限切れになるのではなく、特定の日付（ &lt;code&gt;Expires&lt;/code&gt; ）または特定の期間（ &lt;code&gt;Max-Age&lt;/code&gt; ）後に期限切れになります。</target>
        </trans-unit>
        <trans-unit id="687abe5b976f19cc45e08804dc047a80872035fb" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client is closed, permanent cookies expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">永続的なCookieは、クライアントが閉じたときに期限切れになる代わりに、特定の日付（ &lt;code&gt;Expires&lt;/code&gt; ）または特定の期間（ &lt;code&gt;Max-Age&lt;/code&gt; ）後に期限切れになります。</target>
        </trans-unit>
        <trans-unit id="36cf82c2a961317e1eff83740cd0b4132837ed88" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header you can also use a &lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt;&lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt;&lt;/a&gt; header. This header only sends reports to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header and does still allow browsers to connect to the webserver even if the pinning is violated.</source>
          <target state="translated">&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;ヘッダーを使用する代わりに、&lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt; &lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt; &lt;/a&gt;ヘッダーを使用することもできます。このヘッダーは、ヘッダーで指定された &lt;code&gt;report-uri&lt;/code&gt; にのみレポートを送信し、ピン留めに違反した場合でもブラウザーがWebサーバーに接続することを許可します。</target>
        </trans-unit>
        <trans-unit id="3750ed931b77d473b6340fb847310a94be2c064d" translate="yes" xml:space="preserve">
          <source>Instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">ユーザーエージェントに、コンテンツセキュリティポリシーに違反する試みを報告するように指示します。これらの違反レポートは、HTTP &lt;code&gt;POST&lt;/code&gt; リクエストを介して指定されたURIに送信された&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;ドキュメントで構成されます。</target>
        </trans-unit>
        <trans-unit id="da42a3abb7f8b91ffc4fd5c08ba6b30c83141085" translate="yes" xml:space="preserve">
          <source>Instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">安全でない URL (HTTP で提供されているもの)をすべて安全な URL (HTTPS で提供されているもの)に置き換えたかのように扱うように ユーザエージェントに指示します。このディレクティブは、書き換えが必要な安全でない古い URL が大量にある Web サイトを対象としています。</target>
        </trans-unit>
        <trans-unit id="206bbd6a7b7d6a23df99e3ac10a5c7e4495332dd" translate="yes" xml:space="preserve">
          <source>Integration with CSS</source>
          <target state="translated">CSSとの統合</target>
        </trans-unit>
        <trans-unit id="eded9e1af9c609a228692b23c36ea0973e62cf9c" translate="yes" xml:space="preserve">
          <source>Integration with HTML</source>
          <target state="translated">HTMLとの統合</target>
        </trans-unit>
        <trans-unit id="241c7e4997c321b689e3324be2a21f7dbf1a7358" translate="yes" xml:space="preserve">
          <source>Integrity of a partial download</source>
          <target state="translated">部分ダウンロードの完全性</target>
        </trans-unit>
        <trans-unit id="d7339840c521459441002b60ebbff7f9e4807175" translate="yes" xml:space="preserve">
          <source>Internet Draft</source>
          <target state="translated">インターネットドラフト</target>
        </trans-unit>
        <trans-unit id="944b611c46b28ffd8244fb42daaa4b9496b1cf13" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7230                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                    J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818&lt;/a&gt;                                           greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。7230アドビ時代遅れにします。：要求のコメント&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145年&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke、エド。更新：&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817年&lt;/a&gt;、&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818&lt;/a&gt; greenbytesカテゴリ：標準化過程2014年6月ISSN：2070から1721</target>
        </trans-unit>
        <trans-unit id="a37f9383c64e54f8eb287b01c2b6207a20637c11" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。コメントの要求：7231 Adob​​e廃止：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke、エド。アップデート：&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt; グリーンバイトカテゴリ：標準化トラック2014年6月ISSN：2070-1721</target>
        </trans-unit>
        <trans-unit id="ac7e3a4b626b90a8dbd99bacd4566ca932b34a3b" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7232                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Category: Standards Track                                     greenbytes
ISSN: 2070-1721                                                June 2014</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。コメントの要求：7232 Adob​​e廃止：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke、エド。カテゴリー：標準はグリーンバイトを追跡ISSN：2070-1721 2014年6月</target>
        </trans-unit>
        <trans-unit id="f19a38d04cab53923494c67976d4e498a99f2c29" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7233                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                            Y. Lafon, Ed.
Category: Standards Track                                            W3C
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                              June 2014</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。コメントのリクエスト：7233 Adob​​e廃止：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; Y. Lafon、Ed。カテゴリー：Standards Track W3C ISSN：2070-1721 J. Reschke、Ed。 greenbytes 2014年6月</target>
        </trans-unit>
        <trans-unit id="abf0c52384302c538626557887406ff5785b7493" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7234                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                       M. Nottingham, Ed.
Category: Standards Track                                         Akamai
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                               June 2014</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。コメントの要求：7234アドビ廃止：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; M.ノッティンガム、エド。カテゴリー：規格追跡Akamai ISSN：2070-1721 J. Reschke、Ed。 greenbytes 2014年6月</target>
        </trans-unit>
        <trans-unit id="4cf7cbfbbfccd70ae7ed26796d1828c5ad2463df" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7235                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">インターネット技術特別調査委員会（IETF）R.フィールディング、エド。コメントの要求：7235 Adob​​e廃止：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke、エド。アップデート：&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt; グリーンバイトカテゴリ：標準化過程2014年6月ISSN：2070-1721</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">インターネットエクスプローラ</target>
        </trans-unit>
        <trans-unit id="ee29687168fb4fd84a3acc654a9db5d9db8c1813" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8</source>
          <target state="translated">インターネットエクスプローラ8</target>
        </trans-unit>
        <trans-unit id="b50d4fdd010f7da47bc090ba56b32ab192bd7efd" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 and 9 expose CORS via the &lt;code&gt;XDomainRequest&lt;/code&gt; object, but have a full implementation in IE 10.</source>
          <target state="translated">Internet Explorer 8および9は、 &lt;code&gt;XDomainRequest&lt;/code&gt; オブジェクトを介してCORSを公開しますが、IE 10では完全に実装されています。</target>
        </trans-unit>
        <trans-unit id="f09fc55fe960cdc577a491b6af400c7ecc717639" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 or earlier</source>
          <target state="translated">インターネットエクスプローラ8以前</target>
        </trans-unit>
        <trans-unit id="9df82ce454660e2e95801528c257a56a7c65b8f4" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9</source>
          <target state="translated">インターネットエクスプローラ9</target>
        </trans-unit>
        <trans-unit id="ab3ccd4c44d2e9f7601c41c05c58eb093f7971c4" translate="yes" xml:space="preserve">
          <source>Internet Explorer UA string</source>
          <target state="translated">インターネットエクスプローラUA文字列</target>
        </trans-unit>
        <trans-unit id="935b07a4771d1ecca905a5712a8abb0cb5f5eebd" translate="yes" xml:space="preserve">
          <source>Internet Explorer doesn't put its name in the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; format</source>
          <target state="translated">Internet Explorerは、その名前を&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;形式で入れません。</target>
        </trans-unit>
        <trans-unit id="b2b280e0cd215dee60eed1d1e3dbd22fa9b08456" translate="yes" xml:space="preserve">
          <source>Internet Explorer put this token in the &lt;em&gt;comment&lt;/em&gt; part of the User Agent String</source>
          <target state="translated">Internet Explorerは、このトークンをユーザーエージェント文字列の&lt;em&gt;コメント&lt;/em&gt;部分に配置します</target>
        </trans-unit>
        <trans-unit id="a1ee7fdf2dfeeebbbf381e7307a8cb5b69c060fd" translate="yes" xml:space="preserve">
          <source>Internet Standard</source>
          <target state="translated">インターネット標準</target>
        </trans-unit>
        <trans-unit id="a3dfded56299e82b9ecd1b36148982d1169af1c0" translate="yes" xml:space="preserve">
          <source>Internet hosts by name or IP address, as well as an optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL scheme&lt;/a&gt; and/or port number. The site's address may include an optional leading wildcard (the asterisk character, &lt;code&gt;'*'&lt;/code&gt;), and you may use a wildcard (again, &lt;code&gt;'*'&lt;/code&gt;) as the port number, indicating that all legal ports are valid for the source.</source>
          <target state="translated">名前またはIPアドレス、およびオプションの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URLスキーム&lt;/a&gt;やポート番号によるインターネットホスト。サイトのアドレスには、オプションの先行ワイルドカード（アスタリスク文字、 &lt;code&gt;'*'&lt;/code&gt; ）を含めることができ、ワイルドカード（ここでも &lt;code&gt;'*'&lt;/code&gt; ）をポート番号として使用できます。これは、すべての有効なポートがソースで有効であることを示します。</target>
        </trans-unit>
        <trans-unit id="037a2067974b5b1a90e1e346b9991a68825acb64" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form in order to
   be interoperable among systems with varying native encoding formats.
   Representations selected or transferred via HTTP ought to be in
   canonical form, for many of the same reasons described by the
   Multipurpose Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;].  However, the
   performance characteristics of email deployments (i.e., store and
   forward messages to peers) are significantly different from those
   common to HTTP and the Web (server-based information services).
   Furthermore, MIME's constraints for the sake of compatibility with
   older mail transfer protocols do not apply to HTTP (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;). 

   MIME's canonical form requires that media subtypes of the &quot;text&quot; type
   use CRLF as the text line break.  HTTP allows the transfer of text
   media with plain CR or LF alone representing a line break, when such
   line breaks are consistent for an entire representation.  An HTTP
   sender MAY generate, and a recipient MUST be able to parse, line
   breaks in text media that consist of CRLF, bare CR, or bare LF.  In
   addition, text media in HTTP is not limited to charsets that use
   octets 13 and 10 for CR and LF, respectively.  This flexibility
   regarding line breaks applies only to text within a representation
   that has been assigned a &quot;text&quot; media type; it does not apply to
   &quot;multipart&quot; types or HTTP elements outside the payload body (e.g.,
   header fields).

   If a representation is encoded with a content-coding, the underlying
   data ought to be in a form defined above prior to being encoded.</source>
          <target state="translated">インターネットメディアタイプは、さまざまなネイティブエンコーディング形式のシステム間で相互運用できるように、正規の形式で登録されます。多目的インターネットメール拡張（MIME）[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]で説明されているのと同じ理由の多くにより、HTTP経由で選択または転送された表現は、正規の形式である必要があります。ただし、電子メール展開のパフォーマンス特性（つまり、ピアへのメッセージの保存と転送）は、HTTPおよびWeb（サーバーベースの情報サービス）に共通するものとは大きく異なります。さらに、古いメール転送プロトコルとの互換性のためのMIMEの制約は、HTTPには適用されません（&lt;a href=&quot;#appendix-A&quot;&gt;付録Aを&lt;/a&gt;参照）。）。 MIMEの標準形式では、「テキスト」タイプのメディアサブタイプでCRLFをテキストの改行として使用する必要があります。 HTTPでは、表現全体で一貫した改行がある場合に、改行を表すプレーンCRまたはLFのみのテキストメディアを転送できます。 HTTP送信者は生成でき、受信者はCRLF、ベアCR、またはベアLFで構成されるテキストメディアの改行を解析できる必要があります。さらに、HTTPのテキストメディアは、CRとLFにそれぞれオクテット13と10を使用する文字セットに限定されません。改行に関するこの柔軟性は、「テキスト」メディアタイプが割り当てられている表現内のテキストにのみ適用されます。 「マルチパート」タイプまたはペイロード本体の外部のHTTP要素（ヘッダーフィールドなど）には適用されません。表現がコンテンツコーディングでエンコードされている場合、基礎となるデータは、エンコードされる前に上記で定義された形式である必要があります。</target>
        </trans-unit>
        <trans-unit id="23ce3ccc1ff356540fdaac404f8bf64e60f80ef1" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form. An
   entity-body transferred via HTTP messages MUST be represented in the
   appropriate canonical form prior to its transmission except for
   &quot;text&quot; types, as defined in the next paragraph.

   When in canonical form, media subtypes of the &quot;text&quot; type use CRLF as
   the text line break. HTTP relaxes this requirement and allows the
   transport of text media with plain CR or LF alone representing a line
   break when it is done consistently for an entire entity-body. HTTP
   applications MUST accept CRLF, bare CR, and bare LF as being
   representative of a line break in text media received via HTTP. In
   addition, if the text is represented in a character set that does not
   use octets 13 and 10 for CR and LF respectively, as is the case for
   some multi-byte character sets, HTTP allows the use of whatever octet
   sequences are defined by that character set to represent the
   equivalent of CR and LF for line breaks. This flexibility regarding
   line breaks applies only to text media in the entity-body; a bare CR
   or LF MUST NOT be substituted for CRLF within any of the HTTP control
   structures (such as header fields and multipart boundaries).

   If an entity-body is encoded with a content-coding, the underlying
   data MUST be in a form defined above prior to being encoded.

   The &quot;charset&quot; parameter is used with some media types to define the
   character set (&lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;) of the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the &quot;text&quot;
   type are defined to have a default charset value of &quot;ISO-8859-1&quot; when
   received via HTTP. Data in character sets other than &quot;ISO-8859-1&quot; or
   its subsets MUST be labeled with an appropriate charset value. See
   &lt;a href=&quot;#section-3.4.1&quot;&gt;section 3.4.1&lt;/a&gt; for compatibility problems.</source>
          <target state="translated">インターネットメディアタイプは、正規フォームで登録されます。 HTTPメッセージを介して転送されたエンティティ本体は、次の段落で定義されている「テキスト」タイプを除いて、送信前に適切な正規形式で表現する必要があります。正規形式の場合、「テキスト」タイプのメディアサブタイプはCRLFをテキストの改行として使用します。 HTTPはこの要件を緩和し、エンティティボディ全体で一貫して行われる場合、改行を表すプレーンCRまたはLFのみのテキストメディアの転送を許可します。 HTTPアプリケーションは、HTTP経由で受信したテキストメディアの改行を表すものとして、CRLF、ベアCR、およびベアLFを受け入れる必要があります。さらに、テキストがCRおよびLFにそれぞれオクテット13および10を使用しない文字セットで表されている場合、一部のマルチバイト文字セットの場合と同様に、HTTPでは、その文字セットで定義されているオクテットシーケンスを使用して、改行のCRとLFに相当するものを表すことができます。改行に関するこの柔軟性は、エンティティ本体のテキストメディアにのみ適用されます。ベアフィールドCRまたはLFは、HTTP制御構造（ヘッダーフィールドやマルチパート境界など）内でCRLFの代わりに使用してはなりません（MUST NOT）。 entity-bodyがcontent-codingでエンコードされている場合、基礎となるデータは、エンコードされる前に上で定義された形式でなければなりません。 「charset」パラメータは、一部のメディアタイプで文字セット（改行に関するこの柔軟性は、エンティティ本体のテキストメディアにのみ適用されます。ベアフィールドCRまたはLFは、HTTP制御構造（ヘッダーフィールドやマルチパート境界など）内でCRLFの代わりに使用してはなりません（MUST NOT）。 entity-bodyがcontent-codingでエンコードされている場合、基礎となるデータは、エンコードされる前に上で定義された形式でなければなりません。 「charset」パラメータは、一部のメディアタイプで文字セット（改行に関するこの柔軟性は、エンティティ本体のテキストメディアにのみ適用されます。すべてのHTTP制御構造（ヘッダーフィールドやマルチパート境界など）内のCRLFをベアCRまたはLFで置き換えてはなりません（MUST NOT）。 entity-bodyがcontent-codingでエンコードされている場合、基礎となるデータは、エンコードされる前に上で定義された形式でなければなりません。 「charset」パラメータは、一部のメディアタイプで文字セット（パラメータは、一部のメディアタイプで文字セット（パラメータは、一部のメディアタイプで文字セット（&lt;a href=&quot;#section-3.4&quot;&gt;&lt;/a&gt;データのセクション3.4）。送信者によって明示的な文字セットパラメータが提供されない場合、「テキスト」タイプのメディアサブタイプは、HTTP経由で受信されたときに「ISO-8859-1」のデフォルト文字セット値を持つように定義されます。「ISO-8859-1」またはそのサブセット以外の文字セットのデータは、適切な文字セット値でラベル付けする必要があります。互換性の問題については、&lt;a href=&quot;#section-3.4.1&quot;&gt;セクション3.4.1&lt;/a&gt;を参照してください 。</target>
        </trans-unit>
        <trans-unit id="ded9c72dfd997c4640e3e4defef803106231f1f6" translate="yes" xml:space="preserve">
          <source>Introduced in HTTP/1.0, &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; made this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header's semantics.</source>
          <target state="translated">HTTP / 1.0で導入されたHTTP &lt;a href=&quot;headers&quot;&gt;ヘッダー&lt;/a&gt;により、このプロトコルの拡張と実験が容易になりました。新しい機能は、新しいヘッダーのセマンティクスに関するクライアントとサーバー間の単純な合意によって導入することもできます。</target>
        </trans-unit>
        <trans-unit id="1117753f6df6a46418e743d7060ef1767501957d" translate="yes" xml:space="preserve">
          <source>Introduction to Feature Policy</source>
          <target state="translated">フィーチャーポリシーのご紹介</target>
        </trans-unit>
        <trans-unit id="80e829c3a10d9e489ea935dbe19658e50845954c" translate="yes" xml:space="preserve">
          <source>Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired.</source>
          <target state="translated">値0のような無効な日付は、過去の日付を表し、リソースがすでに期限切れであることを意味します。</target>
        </trans-unit>
        <trans-unit id="dfa60022094016d57bd557254bafb6ff9bbe3d2a" translate="yes" xml:space="preserve">
          <source>Invalid domains</source>
          <target state="translated">無効なドメイン</target>
        </trans-unit>
        <trans-unit id="9032ed3737ead87641e8c9fd63add1c68fa832be" translate="yes" xml:space="preserve">
          <source>Invalid parameters in media, or typos when specifying &lt;code&gt;'base64'&lt;/code&gt;, are ignored, but no error is provided.</source>
          <target state="translated">メディアの無効なパラメーター、または &lt;code&gt;'base64'&lt;/code&gt; を指定するときのタイプミスは無視されますが、エラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="db5e158a717067d22e2fe4cb88250953ddf29eb6" translate="yes" xml:space="preserve">
          <source>Invalidation (RFC 7234)</source>
          <target state="translated">失格 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="380eceb118a2210931ae6c7c6f4918fcad2be151" translate="yes" xml:space="preserve">
          <source>Invention of the World Wide Web</source>
          <target state="translated">ワールドワイドウェブの発明</target>
        </trans-unit>
        <trans-unit id="96fe62d1784a07fd038cfab3bf1502f6c16a7790" translate="yes" xml:space="preserve">
          <source>Invocations of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs in a cross-site manner, as discussed above.</source>
          <target state="translated">上記で説明したように、クロスサイト方式での&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIの呼び出し。</target>
        </trans-unit>
        <trans-unit id="2422fcd418c687b013805ec7620a6399f1372c7e" translate="yes" xml:space="preserve">
          <source>Is a response header if the resource transmitted should be displayed inline (default behavior when the header is not present), or it should be handled like a download and the browser should present a 'Save As' window.</source>
          <target state="translated">送信されたリソースがインラインで表示されるべきか(ヘッダが存在しない場合のデフォルトの動作)、ダウンロードのように処理されるべきか、ブラウザが'名前を付けて保存'ウィンドウを表示するべきか、応答ヘッダです。</target>
        </trans-unit>
        <trans-unit id="54e9ec692a56ffab91bf47f24b6f5f04f83ce33b" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot; or is left out.</source>
          <target state="translated">文字列 &quot;GMT&quot; があるか、または省略されています。</target>
        </trans-unit>
        <trans-unit id="a64fa4c3a913c82e4add144ea7fbfd9cf3825b6d" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot;, which makes time comparison occur in GMT timezone, or is left out. If left unspecified, times are taken to be in the local timezone.</source>
          <target state="translated">文字列 &quot;GMT&quot; は、時刻比較をGMTタイムゾーンで行うようにするか、指定されていないかのいずれかです。指定されていない場合、時刻はローカルタイムゾーンのものとみなされます。</target>
        </trans-unit>
        <trans-unit id="7ba85fc81b8929d8f78e20fd1bc753c0fb30e0fc" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the name of the HTML field in the form that the content of this subpart refers to. When dealing with multiple files in the same field (for example, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; attribute of an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; element), there can be several subparts with the same name.</source>
          <target state="translated">このサブパートのコンテンツが参照する形式でHTMLフィールドの名前を含む文字列が続きます。同じフィールドで複数のファイルを処理する場合（たとえば、 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; 要素の &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; 属性）、同じ名前のサブパートが複数存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3e092b4d92d6c6e47005b961bfdf49f31576121c" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the original name of the file transmitted. The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done. This parameter provides mostly indicative information. When used in combination with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;, it is used as the default filename for an eventual &quot;Save As&quot; dialog presented to the user.</source>
          <target state="translated">送信されたファイルの元の名前を含む文字列が続きます。ファイル名は常にオプションであり、アプリケーションで盲目的に使用してはなりません。パス情報を削除し、サーバーファイルシステムルールへの変換を行う必要があります。このパラメーターは、主に指示的な情報を提供します。 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; と組み合わせて使用​​すると、最終的にユーザーに表示される「名前を付けて保存」ダイアログのデフォルトのファイル名として使用されます。</target>
        </trans-unit>
        <trans-unit id="ad350b49b6105f7ba408d2cd47de12fe45080a69" translate="yes" xml:space="preserve">
          <source>Is one of the ordered month strings below.</source>
          <target state="translated">以下の月の文字列のうちの一つです。</target>
        </trans-unit>
        <trans-unit id="77e28a9350d45487207b84bc262233bfb40e6bc5" translate="yes" xml:space="preserve">
          <source>Is the domain name to test the hostname against.</source>
          <target state="translated">ホスト名をテストするドメイン名です。</target>
        </trans-unit>
        <trans-unit id="5e530d4a48748eedf183a271fc2d6561b7e57883" translate="yes" xml:space="preserve">
          <source>Is the hostname from the URL.</source>
          <target state="translated">URLからのホスト名です。</target>
        </trans-unit>
        <trans-unit id="2e041ae111b4fa679b2480031c90505ef7ed4674" translate="yes" xml:space="preserve">
          <source>Is the hour from 0 to 23. (0 is midnight, 23 is 11 pm.)</source>
          <target state="translated">0から23までの時間です。(0は真夜中、23は午後11時)。</target>
        </trans-unit>
        <trans-unit id="76bc382859db96f13208fadcaadcd35c9c7d32d7" translate="yes" xml:space="preserve">
          <source>Is the ordered day of the month between 1 and 31 (as an integer).</source>
          <target state="translated">1から31までの間の月の順序の日を整数で表します。</target>
        </trans-unit>
        <trans-unit id="7165ac45c85ea0d30878e33d1b544beb92ad0407" translate="yes" xml:space="preserve">
          <source>Is the ordered full year integer number. For example, 2016 (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">注文された通年の整数です。例えば、2016年（&lt;strong&gt;ではありません&lt;/strong&gt; 16で）。</target>
        </trans-unit>
        <trans-unit id="ecffee78fc03e20a569b23ceac7747629660f84c" translate="yes" xml:space="preserve">
          <source>Is true if the hostname matches exactly the specified hostname, or if there is no domain name part in the hostname, but the unqualified hostname matches.</source>
          <target state="translated">ホスト名が指定されたホスト名と完全に一致する場合、または、ホスト名にドメイン名の部分がないが、修飾されていないホスト名が一致する場合に真です。</target>
        </trans-unit>
        <trans-unit id="0bea60d3e6673895b89b3e27ba8883ed44567185" translate="yes" xml:space="preserve">
          <source>It allows a server to populate data in a client cache, in advance of it being required, through a mechanism called the server push.</source>
          <target state="translated">これにより、サーバーは、サーバープッシュと呼ばれるメカニズムを使って、必要になる前に、クライアントキャッシュ内のデータを埋め込んでおくことができます。</target>
        </trans-unit>
        <trans-unit id="f46736fbac23773dd54664bce214c5dc4f10a2c6" translate="yes" xml:space="preserve">
          <source>It can be used when the total number of request header fields is too large, or when a single header field is at too large.</source>
          <target state="translated">リクエストヘッダフィールドの総数が多すぎる場合や、1つのヘッダフィールドが多すぎる場合に使用することができます。</target>
        </trans-unit>
        <trans-unit id="c1727a3eed7f9b9c35a928b776172744af8666f3" translate="yes" xml:space="preserve">
          <source>It compresses headers. As these are often similar among a set of requests, this removes duplication and overhead of data transmitted.</source>
          <target state="translated">ヘッダーを圧縮します。これらはリクエストのセットの中でも似たようなものであることが多いので、送信されるデータの重複やオーバーヘッドを取り除きます。</target>
        </trans-unit>
        <trans-unit id="4b480764290e819516d7c049141dbc95445b3642" translate="yes" xml:space="preserve">
          <source>It is a binary protocol rather than text. It can no longer be read and created manually. Despite this hurdle, improved optimization techniques can now be implemented.</source>
          <target state="translated">テキストではなくバイナリプロトコルです。もはや手動で読み込んで作成することはできません。このハードルにもかかわらず、改良された最適化技術が実装できるようになりました。</target>
        </trans-unit>
        <trans-unit id="bad2ad311f9d8d7e181ed23c4b923cbf915ec8c4" translate="yes" xml:space="preserve">
          <source>It is a multiplexed protocol. Parallel requests can be handled over the same connection, removing the order and blocking constraints of the HTTP/1.x protocol.</source>
          <target state="translated">これは多重化されたプロトコルです。並列リクエストは、HTTP/1.x プロトコルの順序やブロッキングの制約を取り除き、同じ接続上で処理することができます。</target>
        </trans-unit>
        <trans-unit id="a7b12c882112937be30ce15f7fdc909be28edb8f" translate="yes" xml:space="preserve">
          <source>It is a validator, a unique string identifying the version of the resource. Conditional requests using &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">これはバリデーターであり、リソースのバージョンを識別する一意の文字列です。&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; を&lt;/a&gt;使用した条件付きリクエストは、この値を使用してリクエストの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="5cdf965cca7cbedbb40498332c66597692a803a9" translate="yes" xml:space="preserve">
          <source>It is a validator, the last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">これはバリデーターであり、リソースの最終変更日であり、同じリソースの複数のバージョンを比較するために使用されます。&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;ほど正確ではありませんが、一部の環境では計算が簡単です。&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;を使用した条件付きリクエスト使用したは、この値を使用してリクエストの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="9785aaf5047339a17ab49de4a65661f34c75c502" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of a protocol specification to mandate
   compliance with previous versions. HTTP/1.1 was deliberately
   designed, however, to make supporting previous versions easy. It is
   worth noting that, at the time of composing this specification
   (1996), we would expect commercial HTTP/1.1 servers to:

      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and
        1.1 requests; 

      - understand any valid request in the format of HTTP/0.9, 1.0, or
        1.1;

      - respond appropriately with a message in the same major version
        used by the client.

   And we would expect HTTP/1.1 clients to:

      - recognize the format of the Status-Line for HTTP/1.0 and 1.1
        responses;

      - understand any valid response in the format of HTTP/0.9, 1.0, or
        1.1.

   For most implementations of HTTP/1.0, each connection is established
   by the client prior to the request and closed by the server after
   sending the response. Some implementations implement the Keep-Alive
   version of persistent connections described in section 19.7.1 of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">以前のバージョンへの準拠を義務付けることは、プロトコル仕様の範囲を超えています。ただし、HTTP / 1.1は、以前のバージョンのサポートを容易にするために意図的に設計されました。この仕様を作成した時点（1996年）では、商用のHTTP / 1.1サーバーが次のことを期待していることに注意してください。 -HTTP / 0.9、1.0、または1.1の形式で有効なリクエストを理解します。 -クライアントが使用しているのと同じメジャーバージョンのメッセージで適切に応答します。また、HTTP / 1.1クライアントは次のことを期待します。-HTTP / 1.0および1.1応答のStatus-Lineの形式を認識します。 -HTTP / 0.9、1.0、または1.1の形式で有効な応答を理解します。HTTP / 1.0のほとんどの実装では、各接続は要求の前にクライアントによって確立され、応答の送信後にサーバーによって閉じられます。一部の実装は、セクション19.7.1で説明されている永続的な接続のキープアライブバージョンを実装します。&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="8259fef778fc701ed117ff363698b323da319cfd" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this specification to describe how
   connections are established via various transport- or session-layer
   protocols.  Each connection applies to only one transport link.</source>
          <target state="translated">さまざまなトランスポートまたはセッションレイヤーのプロトコルを介して接続がどのように 確立されるかを記述することは、この仕様の範囲を超えている。各接続は1つのトランスポートリンクのみに適用される。</target>
        </trans-unit>
        <trans-unit id="f2d087e11ffd49739b77d44827cb4d007b8288ad" translate="yes" xml:space="preserve">
          <source>It is especially important that proxies correctly implement the
   properties of the Connection header field as specified in &lt;a href=&quot;#section-14.10&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;.

   The proxy server MUST signal persistent connections separately with
   its clients and the origin servers (or other proxy servers) that it
   connects to. Each persistent connection applies to only one transport
   link.

   A proxy server MUST NOT establish a HTTP/1.1 persistent connection
   with an HTTP/1.0 client (but see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;] for information and
   discussion of the problems with the Keep-Alive header implemented by
   many HTTP/1.0 clients).</source>
          <target state="translated">&lt;a href=&quot;#section-14.10&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;14.10で&lt;/a&gt;指定されているように、プロキシがConnectionヘッダーフィールドのプロパティを正しく実装することが特に重要です。プロキシサーバーは、クライアントと、接続先のオリジンサーバー（または他のプロキシサーバー）との永続的な接続を個別に通知する必要があります。各永続的接続は、1つのトランスポートリンクにのみ適用されます。プロキシサーバーは、HTTP / 1.0クライアントとのHTTP / 1.1永続的接続を確立してはなりません（ただし、多くのHTTP / 1.0クライアントによって実装されたKeep-Aliveヘッダーの問題と情報については、&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]を参照してください）。</target>
        </trans-unit>
        <trans-unit id="b498c25fadce9f183d82dd50870c277f51907a88" translate="yes" xml:space="preserve">
          <source>It is however still necessary for Firefox to load resources in web content under certain circumstances. For example, if you open the view source page (View Page Source or View Selection Source), you will find it requires &lt;code&gt;viewsource.css&lt;/code&gt; through a &lt;code&gt;resource:&lt;/code&gt; URI. Resources that have to be exposed to web content have been moved to a new location named &lt;code&gt;resource://content-accessible/&lt;/code&gt;, which is isolated and only contains non-sensitive resources. In this way we can keep essential resources exposed and have most threats eliminated.</source>
          <target state="translated">ただし、特定の状況下では、FirefoxがWebコンテンツにリソースをロードする必要があります。たとえば、ソースの表示ページ（ページのソースの表示または選択ソースの表示）を &lt;code&gt;viewsource.css&lt;/code&gt; と、 &lt;code&gt;resource:&lt;/code&gt; URIを介してviewsource.cssが必要であることがわかります。 Webコンテンツに公開する必要のある &lt;code&gt;resource://content-accessible/&lt;/code&gt; は、分離され、機密性の低いリソースのみが含まれるresource：// content-accessible /という名前の新しい場所に移動されました。このようにして、重要なリソースを公開し、ほとんどの脅威を排除することができます。</target>
        </trans-unit>
        <trans-unit id="a7d678015e6dbddd6cd806a3a207ba38d15b32ae" translate="yes" xml:space="preserve">
          <source>It is important to avoid redirection loops as they completely break the user experience.</source>
          <target state="translated">リダイレクトループはユーザーエクスペリエンスを完全に破壊するので、回避することが重要です。</target>
        </trans-unit>
        <trans-unit id="7abd5b5646d7b956a07aef0207e3f862399863c2" translate="yes" xml:space="preserve">
          <source>It is possible to add a special HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element to a page to indicate what the canonical address of a page is. This has no impact on the human reader of the page, but tells search engine crawlers where the page actually lives. This way, search engines don't index the same page several times, potentially leading to it being considered as duplicate content or spam, and even removing or lowering your page from the search engine result pages.</source>
          <target state="translated">特別なHTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;要素をページに追加して、ページの正規アドレスを示すことができます。これはページの人間の読者には影響しませんが、ページが実際にどこにあるかを検索エンジンクローラーに通知します。このように、検索エンジンは同じページを数回インデックスに登録しないため、重複したコンテンツまたはスパムと見なされたり、検索エンジンの結果ページからページが削除または低下したりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="8a360170218e1e7d2c6f7cc097d32c2f58946eee" translate="yes" xml:space="preserve">
          <source>It is possible to deploy &lt;code&gt;strict-dynamic&lt;/code&gt; in a backwards compatible way, without requiring user-agent sniffing.</source>
          <target state="translated">ユーザーエージェントのスニッフィングを必要とせずに、後方互換性のある方法で &lt;code&gt;strict-dynamic&lt;/code&gt; をデプロイすることが可能です。</target>
        </trans-unit>
        <trans-unit id="d542c890e06636447b6f6b9d8af60c44ef672877" translate="yes" xml:space="preserve">
          <source>It is quite difficult to have a unique identifier for strong validation with &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt;. Often this is done using an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; with the MD5 hash of the resource (or a derivative).</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;で強力な検証を行うための一意の識別子を持つことは非常に困難です。多くの場合、これはリソース（または派生物）のMD5ハッシュを持つ&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;を使用して行われます。</target>
        </trans-unit>
        <trans-unit id="98ff32d0856e5c15bbca04673b6c6f97714c4530" translate="yes" xml:space="preserve">
          <source>It's difficult to build a website that uses all the latest best practices and provides great performance and user experiences. As the website evolves, it can become even harder to maintain the user experience over time. You can use feature policies to specify the desired best practices, and rely on the browser to enforce the policies to prevent regressions.</source>
          <target state="translated">最新のベストプラクティスを駆使して、素晴らしいパフォーマンスとユーザーエクスペリエンスを提供するウェブサイトを構築するのは難しいです。ウェブサイトが進化するにつれて、時間の経過とともにユーザーエクスペリエンスを維持することがさらに難しくなる可能性があります。機能ポリシーを使用して望ましいベストプラクティスを指定し、ブラウザがポリシーを実施することで回帰を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="efa57fd9b104487236e3d21ead681f7448b30db9" translate="yes" xml:space="preserve">
          <source>It's easy to find the correspondences by looking at the &lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurial repository names&lt;/a&gt;: repositories starting by &lt;code&gt;mozilla-b2g&lt;/code&gt; are the release repositories for Firefox OS, and have both Firefox OS and Gecko versions in their names.</source>
          <target state="translated">&lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurialリポジトリ名を&lt;/a&gt;見れば、対応を簡単に見つけることができます &lt;code&gt;mozilla-b2g&lt;/code&gt; 始まるリポジトリは、Firefox OSのリリースリポジトリであり、名前にFirefox OSとGeckoの両方のバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="5250b829db5c42c7a082fb33c46a6aed6b45b478" translate="yes" xml:space="preserve">
          <source>It's important point to note that connection management in HTTP applies to the connection between two consecutive nodes, which is &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; and not &lt;a href=&quot;headers#e2e&quot;&gt;end-to-end&lt;/a&gt;. The model used in connections between a client and its first proxy may differ from the model between a proxy and the destination server (or any intermediate proxies). The HTTP headers involved in defining the connection model, like &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, are &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; headers with their values able to be changed by intermediary nodes.</source>
          <target state="translated">HTTPの接続管理は、&lt;a href=&quot;headers#e2e&quot;&gt;エンドツーエンド&lt;/a&gt;ではなく&lt;a href=&quot;headers#hbh&quot;&gt;ホップバイホップ&lt;/a&gt;である2つの連続するノード間の接続に適用されることに注意することが重要です。クライアントとその最初のプロキシ間の接続で使用されるモデルは、プロキシと宛先サーバー（または中間プロキシ）間のモデルと異なる場合があります。&lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;などの接続モデルの定義に関係するHTTPヘッダーは、&lt;a href=&quot;headers#hbh&quot;&gt;ホップバイホップ&lt;/a&gt;ヘッダーであり、その値は中間ノードによって変更できます。</target>
        </trans-unit>
        <trans-unit id="739ff299232862f99e9340517c687340775d8925" translate="yes" xml:space="preserve">
          <source>It's standard procedure to start a connection using HTTP/1.1, due to its broad support, then request an upgrade to HTTP/2. This way, you have a functioning connection still even if HTTP/2 isn't supported by the server. However, you can only upgrade to an insecure (cleartext) HTTP/2 connection. This is done using the target protocol name &lt;code&gt;h2c&lt;/code&gt;, which stands for &quot;HTTP/2 Cleartext&quot;. This also &lt;em&gt;requires&lt;/em&gt; the specification of the &lt;code&gt;HTTP2-Settings&lt;/code&gt; header field.</source>
          <target state="translated">幅広いサポートにより、HTTP / 1.1を使用して接続を開始し、HTTP / 2へのアップグレードを要求するのが標準的な手順です。これにより、サーバーでHTTP / 2がサポートされていない場合でも、機能している接続が維持されます。ただし、安全でない（クリアテキスト）HTTP / 2接続にのみアップグレードできます。これは、 &quot;HTTP / 2 Cleartext&quot;を表すターゲットプロトコル名 &lt;code&gt;h2c&lt;/code&gt; を使用して行われます。これには、 &lt;code&gt;HTTP2-Settings&lt;/code&gt; ヘッダーフィールドの指定も&lt;em&gt;必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="8bea6d61f9c2501d81011d81f34e205f8686dfa5" translate="yes" xml:space="preserve">
          <source>It's worth re-iterating: it's very rarely a good idea to use user agent sniffing. You can almost always find a better, more broadly compatible way to solve your problem!</source>
          <target state="translated">繰り返しになりますが、ユーザーエージェントのスニッフィングを使用することは非常に稀です。あなたの問題を解決するために、より良い、より広く互換性のある方法を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="1eed6d58a74c7c8d582fdf2be8d22bcb2c8939ca" translate="yes" xml:space="preserve">
          <source>JPEG images</source>
          <target state="translated">JPEG画像</target>
        </trans-unit>
        <trans-unit id="5766bfd5841dee1b6f2aaf89bbb921f60e7d1b6f" translate="yes" xml:space="preserve">
          <source>JSON format</source>
          <target state="translated">JSON形式</target>
        </trans-unit>
        <trans-unit id="eb7b5a55874bccbd5415aa333ebe2f4d5bc10f49" translate="yes" xml:space="preserve">
          <source>Java Archive (JAR)</source>
          <target state="translated">Java アーカイブ (JAR)</target>
        </trans-unit>
        <trans-unit id="0bd88372ee65c120d42e02af79e6d6a3eb158cea" translate="yes" xml:space="preserve">
          <source>JavaScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">JavaScript（&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt;仕様&lt;/em&gt;&lt;/a&gt;）（&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329セクション8.2&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="14198645a38762965b009588906bec6466424e7f" translate="yes" xml:space="preserve">
          <source>JavaScript access using &lt;code&gt;Document.cookie&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Document.cookie&lt;/code&gt; を使用したJavaScriptアクセス</target>
        </trans-unit>
        <trans-unit id="02726ffcb85ce089b78555f5977ff60b7b1e1236" translate="yes" xml:space="preserve">
          <source>JavaScript files</source>
          <target state="translated">ジャバスクリプトファイル</target>
        </trans-unit>
        <trans-unit id="3be64216bdf0b966d93ddd891c18c487fb2b9ae8" translate="yes" xml:space="preserve">
          <source>JavaScript redirections</source>
          <target state="translated">JavaScript のリダイレクト</target>
        </trans-unit>
        <trans-unit id="8a908fed06c72f5e490a9950a8717a85839ac02f" translate="yes" xml:space="preserve">
          <source>JavaScript redirects are used as the last resort, and only if JavaScript is enabled on the client side.</source>
          <target state="translated">JavaScript のリダイレクトは最後の手段として使用され、クライアント側で JavaScript が有効になっている場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="8a51f0d37d8a868b09fd7045118623248a30aff4" translate="yes" xml:space="preserve">
          <source>JavaScript types</source>
          <target state="translated">JavaScriptの種類</target>
        </trans-unit>
        <trans-unit id="b2bea8b7008e2db2d0b0548f31cebaf54a8e8d9f" translate="yes" xml:space="preserve">
          <source>Julian Reschke
   &amp;lt;green/&amp;gt;bytes GmbH
   Hafenweg 16, 48155 Muenster, Germany
   EMail: julian.reschke@greenbytes.de


   Elias Sinderson
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: elias@cse.ucsc.edu


   Jim Whitehead
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: ejw@soe.ucsc.edu</source>
          <target state="translated">Julian Reschke &amp;lt;green /&amp;gt; bytes GmbH Hafenweg 16、48155 Muenster、Germany EMail：julian.reschke@greenbytes.de Elias Sinderson University of California、Santa Cruz 1156 High Street、Santa Cruz、CA 95064 EMail：elias@cse.ucsc.eduジムホワイトヘッドカリフォルニア大学サンタクルーズ1156ハイストリート、サンタクルーズ、カリフォルニア95064 Eメール：ejw@soe.ucsc.edu</target>
        </trans-unit>
        <trans-unit id="7e8b1d0fc088bb90dbbe8a2dbd8d00105aebfdf3" translate="yes" xml:space="preserve">
          <source>Keep-Alive</source>
          <target state="translated">Keep-Alive</target>
        </trans-unit>
        <trans-unit id="518fe23acc32b680b6c7064b18768ce9a4edc6c7" translate="yes" xml:space="preserve">
          <source>Keeping links alive</source>
          <target state="translated">リンクの維持</target>
        </trans-unit>
        <trans-unit id="0b80404ac1f938e0ad58d9a575e0e0aa00a66dd0" translate="yes" xml:space="preserve">
          <source>Kind of document</source>
          <target state="translated">文書の種類</target>
        </trans-unit>
        <trans-unit id="471e7dd9c2f2d4bd1722ed06bd63bae32d792b07" translate="yes" xml:space="preserve">
          <source>Klar Version (Rendering Engine)</source>
          <target state="translated">クラーバージョン(レンダリングエンジン</target>
        </trans-unit>
        <trans-unit id="53a344b79c8c2c1639455bd4ca9631b250cbb736" translate="yes" xml:space="preserve">
          <source>Klar for Android</source>
          <target state="translated">Klar for Android</target>
        </trans-unit>
        <trans-unit id="1cfc0d8b05e463c4269f42611f344e37e54aaf18" translate="yes" xml:space="preserve">
          <source>Konqueror 4.6</source>
          <target state="translated">Konqueror 4.6</target>
        </trans-unit>
        <trans-unit id="1971c93380e2bf924d413b56239bd916d71c69a0" translate="yes" xml:space="preserve">
          <source>Lack of error handling</source>
          <target state="translated">エラー処理の不足</target>
        </trans-unit>
        <trans-unit id="3df68e70fa194f3c844cf64d5417d8356ae60b51" translate="yes" xml:space="preserve">
          <source>Large message body</source>
          <target state="translated">大きなメッセージボディ</target>
        </trans-unit>
        <trans-unit id="aba1a47c51ae2e1013a1da8b769f84aea5b8154d" translate="yes" xml:space="preserve">
          <source>Large-Allocation</source>
          <target state="translated">Large-Allocation</target>
        </trans-unit>
        <trans-unit id="4312b9cdc22a0d8cf25ab213c9d034cee9ce16ee" translate="yes" xml:space="preserve">
          <source>Last-Modified</source>
          <target state="translated">Last-Modified</target>
        </trans-unit>
        <trans-unit id="5ad73a8c3ddef48b03c719ec7b68bf049b1d82e3" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 2616)</source>
          <target state="translated">最終更新(RFC2616)</target>
        </trans-unit>
        <trans-unit id="99e5db4754c5b7e5f7aa2bb6b93799f72088bd2e" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 7232)</source>
          <target state="translated">最終更新 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="47055864cbe7192dae27bdfff260957e5075db67" translate="yes" xml:space="preserve">
          <source>Lastly, the above code snippets bring about a critical issue with cross-browser coding that must always be taken into account. Don't unintentionally use the API you are testing for in unsupported browsers. This may sound obvious and simple, but sometimes it is not. For example, in the above code snippets, using lookbehind in short-regexp notation (e.g. /reg/igm) will cause a parser error in unsupported browsers. Thus, in the above example, you would use &lt;em&gt;new RegExp(&quot;(?&amp;lt;=look_behind_stuff)&quot;);&lt;/em&gt; instead of &lt;em&gt;/(?&amp;lt;=look_behind_stuff)/&lt;/em&gt;, even in the lookbehind supported section of your code.</source>
          <target state="translated">最後に、上記のコードスニペットは、常に考慮しなければならないクロスブラウザコーディングで重大な問題を引き起こします。サポートされていないブラウザでテストするAPIを誤って使用しないでください。これは明白でシンプルに聞こえるかもしれませんが、そうでない場合もあります。たとえば、上記のコードスニペットで、short-regexp表記（たとえば、/ reg / igm）で後読みを使用すると、サポートされていないブラウザーでパーサーエラーが発生します。したがって、上記の例では、&lt;em&gt;new RegExp（ &quot;（？&amp;lt;= look_behind_stuff）&quot;）;を使用します。&lt;/em&gt;&lt;em&gt;/（？&amp;lt;= look_behind_stuff）/の&lt;/em&gt;代わりに、コードのサポートされている後読みセクションでも。</target>
        </trans-unit>
        <trans-unit id="eafc1856088b0c25b5dc46fcf0e9827359916eb5" translate="yes" xml:space="preserve">
          <source>Layout-inducing Animations</source>
          <target state="translated">レイアウト誘導アニメーション</target>
        </trans-unit>
        <trans-unit id="2c4b740fafd105be97b958562b8d0b2c61b96ad1" translate="yes" xml:space="preserve">
          <source>Layout-inducing animations</source>
          <target state="translated">レイアウト誘導アニメーション</target>
        </trans-unit>
        <trans-unit id="002f595b3413c96ece78e3ec6628adfe5d342941" translate="yes" xml:space="preserve">
          <source>Lazyload</source>
          <target state="translated">Lazyload</target>
        </trans-unit>
        <trans-unit id="4c1df5a82059a1ccfbe352d4ab0834213813478b" translate="yes" xml:space="preserve">
          <source>Learn how to use HTTP with guides and tutorials.</source>
          <target state="translated">ガイドやチュートリアルでHTTPの使い方を学びます。</target>
        </trans-unit>
        <trans-unit id="14b20b4a9f9427cb013c488330c0a01cc370bf8c" translate="yes" xml:space="preserve">
          <source>Legacy image formats</source>
          <target state="translated">レガシー画像フォーマット</target>
        </trans-unit>
        <trans-unit id="657da249aededaf980a2d1ed290fee63a37d340e" translate="yes" xml:space="preserve">
          <source>Length limitations</source>
          <target state="translated">長さ制限</target>
        </trans-unit>
        <trans-unit id="5084aa81ee35e345974545e25d8c6c32ab615e45" translate="yes" xml:space="preserve">
          <source>Let us look at what the browser will send to the server in this case, and let's see how the server responds:</source>
          <target state="translated">この場合、ブラウザがサーバーに何を送るのか、サーバーがどのような反応をするのかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="fa210c261a8eda6a3085253bdfc33931dfb0a50f" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt; にあるページを考えてみましょう。次のポリシーを使用し、 &lt;code&gt;cdn.example.com&lt;/code&gt; からのスタイルシート以外はすべて禁止します。</target>
        </trans-unit>
        <trans-unit id="152516c7d9cfd6fae5d3a79c8e35a362dbc55ac2" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;http://example.com/signup.html&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://example.com/signup.html&lt;/code&gt; にあるページを考えてみましょう。次のポリシーを使用し、 &lt;code&gt;cdn.example.com&lt;/code&gt; からのスタイルシート以外はすべて禁止します。</target>
        </trans-unit>
        <trans-unit id="442acc84011b22aa128b910d7dd61aeabb2c24b6" translate="yes" xml:space="preserve">
          <source>Let's look at an example of a preflight request involving &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; を含むプリフライトリクエストの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="928b6441798d4590009f5cc1febcd4f4cc9b6912" translate="yes" xml:space="preserve">
          <source>Let's say a site's API can return data in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt; formats. If the URL for a particular document is at &lt;code&gt;https://example.com/documents/foo&lt;/code&gt;, the site could return different URLs for &lt;code&gt;Content-Location&lt;/code&gt; depending on the request's &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">サイトのAPIが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt;、または&lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt;形式でデータを返すことができるとしましょう。特定のドキュメントのURLが &lt;code&gt;https://example.com/documents/foo&lt;/code&gt; にある場合、サイトはリクエストの&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;ヘッダーに応じて &lt;code&gt;Content-Location&lt;/code&gt; に異なるURLを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="a649ee77f17b9ff4d60ac31c6bda763b09061da1" translate="yes" xml:space="preserve">
          <source>Let's take a look at the full exchange between client and server. The first exchange is the &lt;em&gt;preflight request/response&lt;/em&gt;:</source>
          <target state="translated">クライアントとサーバー間の完全なやり取りを見てみましょう。最初の交換は&lt;em&gt;プリフライト要求/応答&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="76d8e88746aed29c5732084d86f85c42f51868b5" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.</source>
          <target state="translated">クリエイティブ・コモンズ 表示-継承ライセンス v2.5以降でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="db10ddafdbaf44fe84055e66ecf49ecd6e6f7755" translate="yes" xml:space="preserve">
          <source>Like HTML redirections, this can't work on all resources, and obviously, this will only work on clients that execute JavaScript. On the other side, there are more possibilities as you can trigger the redirection only if some conditions are met, for example.</source>
          <target state="translated">HTMLリダイレクトのように、これはすべてのリソースで動作するわけではなく、明らかにJavaScriptを実行するクライアントでのみ動作します。一方で、いくつかの条件が満たされた場合にのみリダイレクトをトリガーすることができるので、より多くの可能性があります。</target>
        </trans-unit>
        <trans-unit id="70be75ce577f3ebafccca55b5df13ee8aef2157c" translate="yes" xml:space="preserve">
          <source>Like any generic data transfer protocol, HTTP cannot regulate the
   content of the data that is transferred, nor is there any a priori
   method of determining the sensitivity of any particular piece of
   information within the context of any given request. Therefore,
   applications SHOULD supply as much control over this information as
   possible to the provider of that information. Four header fields are
   worth special mention in this context: Server, Via, Referer and From.

   Revealing the specific software version of the server might allow the
   server machine to become more vulnerable to attacks against software
   that is known to contain security holes. Implementors SHOULD make the
   Server header field a configurable option.

   Proxies which serve as a portal through a network firewall SHOULD
   take special precautions regarding the transfer of header information
   that identifies the hosts behind the firewall. In particular, they
   SHOULD remove, or replace with sanitized versions, any Via fields
   generated behind the firewall.

   The Referer header allows reading patterns to be studied and reverse
   links drawn. Although it can be very useful, its power can be abused
   if user details are not separated from the information contained in 

   the Referer. Even when the personal information has been removed, the
   Referer header might indicate a private document's URI whose
   publication would be inappropriate.

   The information sent in the From field might conflict with the user's
   privacy interests or their site's security policy, and hence it
   SHOULD NOT be transmitted without the user being able to disable,
   enable, and modify the contents of the field. The user MUST be able
   to set the contents of this field within a user preference or
   application defaults configuration.

   We suggest, though do not require, that a convenient toggle interface
   be provided for the user to enable or disable the sending of From and
   Referer information.

   The User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;) or Server (&lt;a href=&quot;#section-14.38&quot;&gt;section 14.38&lt;/a&gt;) header
   fields can sometimes be used to determine that a specific client or
   server have a particular security hole which might be exploited.
   Unfortunately, this same information is often used for other valuable
   purposes for which HTTP currently has no better mechanism.</source>
          <target state="translated">一般的なデータ転送プロトコルと同様に、HTTPは転送されるデータの内容を規制できません。また、特定の要求のコンテキスト内で特定の情報の機密性を判断するアプリオリな方法もありません。したがって、アプリケーションは、この情報の提供者に可能な限りこの情報を制御する必要があります。このコンテキストでは、Server、Via、Referer、およびFromの4つのヘッダーフィールドについて特に言及する価値があります。サーバーの特定のソフトウェアバージョンを明らかにすると、サーバーマシンがセキュリティホールを含むことがわかっているソフトウェアに対する攻撃に対してより脆弱になる可能性があります。実装者は、サーバーヘッダーフィールドを構成可能なオプションにする必要があります。ネットワークファイアウォールを介してポータルとして機能するプロキシは、ファイアウォールの背後にあるホストを識別するヘッダー情報の転送に関して、特別な予防策を講じるべきです（SHOULD）。特に、ファイアウォールの背後で生成されたViaフィールドを削除するか、サニタイズされたバージョンで置き換える必要があります（SHOULD）。リファラーヘッダーを使用すると、読み取りパターンを調査し、逆リンクを描画できます。これは非常に便利ですが、ユーザーの詳細がリファラーに含まれる情報から分離されていないと、その能力が悪用される可能性があります。個人情報が削除された場合でも、Refererヘッダーは、公開が不適切な非公開ドキュメントのURIを示している可能性があります。差出人フィールドで送信された情報は、ユーザーのプライバシー保護やサイトのセキュリティポリシーと競合する可能性があります。したがって、ユーザーがフィールドの内容を無効化、有効化、および変更できない限り、それは送信されるべきではない（SHOULD NOT）。ユーザーは、このフィールドの内容をユーザー設定またはアプリケーションのデフォルト構成内で設定できる必要があります。必須ではありませんが、ユーザーがFromおよびReferer情報の送信を有効または無効にするための便利なトグルインターフェイスを提供することをお勧めします。 User-Agent（ユーザーがFromおよびReferer情報の送信を有効または無効にするための便利なトグルインターフェースが提供されること。 User-Agent（ユーザーがFromおよびReferer情報の送信を有効または無効にするための便利なトグルインターフェースが提供されること。 User-Agent（&lt;a href=&quot;#section-14.43&quot;&gt;セクション14.43&lt;/a&gt;）またはサーバー（&lt;a href=&quot;#section-14.38&quot;&gt;セクション14.38&lt;/a&gt;）のヘッダーフィールドを使用して、特定のクライアントまたはサーバーに特定のセキュリティホールが存在することを確認できます。残念ながら、この同じ情報は、HTTPが現在より優れたメカニズムを備えていない他の貴重な目的によく使用されます。</target>
        </trans-unit>
        <trans-unit id="de09479df824aa67e637b0690aa7154dd273d917" translate="yes" xml:space="preserve">
          <source>Like images, HTML doesn't define supported types for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, so only some can be used on the Web. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;Media formats supported by the HTML audio and video elements&lt;/a&gt; explains both the codecs and container formats which can be used.</source>
          <target state="translated">画像と同様に、HTMLは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;要素のサポートされているタイプを定義しないため、Webで使用できるのは一部のみです。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;HTMLオーディオおよびビデオ要素でサポートされるメディア形式は、&lt;/a&gt;使用できるコーデックとコンテナ形式の両方を説明しています。</target>
        </trans-unit>
        <trans-unit id="b17f9b3a3f5f94964505eae8dc076c8167b437f2" translate="yes" xml:space="preserve">
          <source>Like in all cases, these strings may change in the future, one should use them only in conjunction with the detection of already released browsers. A technological survey must be in place to adapt the script when new browser versions are coming out.</source>
          <target state="translated">すべての場合と同様に、これらの文字列は将来的に変更される可能性がありますので、すでにリリースされているブラウザの検出と併用して使用する必要があります。新しいブラウザのバージョンが出てきたときにスクリプトを適応させるためには、技術的な調査が必要です。</target>
        </trans-unit>
        <trans-unit id="c3f7813f6513530fae5d20c357e1018dfbdab752" translate="yes" xml:space="preserve">
          <source>Like the compress program, which has disappeared from most UNIX distributions, this content-encoding is used by almost no browsers today, partly because of a patent issue (which expired in 2003).</source>
          <target state="translated">ほとんどの UNIX ディストリビューションから姿を消してしまった圧縮プログラムと同様に、このコンテンツエンコーディングは、特許の問題(2003年に期限切れ)もあって、今日ではほとんどのブラウザで使われていません。</target>
        </trans-unit>
        <trans-unit id="c924aeab714bffe66c4c22bc5d8bd00099533380" translate="yes" xml:space="preserve">
          <source>Limiting the possible &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; values to a set of allowed origins requires code on the server side to check the value of the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header, compare that to a list of allowed origins, and then if the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value is in the list, to set the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">可能な &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 値を許可されたオリジンのセットに制限するには、サーバー側でコードが&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;リクエストヘッダーの値を確認し、それを許可されたオリジンのリストと比較して、&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;値がリストには、設定する &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; と同じ値に値を&lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;値。</target>
        </trans-unit>
        <trans-unit id="a118fb8cb53f5dd1fc14f29be01804384762f7e9" translate="yes" xml:space="preserve">
          <source>Line 7 shows the flag on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; that has to be set in order to make the invocation with Cookies, namely the &lt;code&gt;withCredentials&lt;/code&gt; boolean value. By default, the invocation is made without Cookies. Since this is a simple &lt;code&gt;GET&lt;/code&gt; request, it is not preflighted, but the browser will &lt;strong&gt;reject&lt;/strong&gt; any response that does not have the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header, and &lt;strong&gt;not&lt;/strong&gt; make the response available to the invoking web content.</source>
          <target state="translated">行7は、Cookieを使用して呼び出しを行うために設定する必要がある&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;のフラグ、つまり &lt;code&gt;withCredentials&lt;/code&gt; ブール値を示しています。デフォルトでは、呼び出しはCookieなしで行われます。これは単純な &lt;code&gt;GET&lt;/code&gt; リクエストであるため、プリフライトされませんが、ブラウザーは&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; ヘッダーを持たない応答を&lt;strong&gt;拒否&lt;/strong&gt;し、呼び出し側のWebコンテンツで応答を利用できるようにし&lt;strong&gt;ません&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e4ad5eac403df09e0c0c7d48c364588c499b639" translate="yes" xml:space="preserve">
          <source>Lines 1 - 10 are headers sent. The main HTTP request header of note here is the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header on line 10 above, which shows that the invocation is coming from content on the domain &lt;code&gt;http://foo.example&lt;/code&gt;.</source>
          <target state="translated">1行目から10行目は、送信されるヘッダーです。ここで注目すべき主なHTTPリクエストヘッダーは、上記の行10の&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダーです。これは、呼び出しがドメイン &lt;code&gt;http://foo.example&lt;/code&gt; のコンテンツから行われていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a288b2c5ce1d7dc2f4906f2097cd01bf3ad43ed7" translate="yes" xml:space="preserve">
          <source>Lines 1 - 12 above represent the preflight request with the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent (lines 10 and 11 respectively):</source>
          <target state="translated">上記の1〜12行目は、&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;メソッドを使用したプリフライトリクエストを表しています。ブラウザは、上記のJavaScriptコードスニペットが使用していたリクエストパラメータに基づいてこれを送信する必要があると判断します。これにより、サーバーは、実際のリクエストパラメータでリクエストを送信してもよいかどうかを応答できます。 OPTIONSは、サーバーからの詳細情報を決定するために使用されるHTTP / 1.1メソッドであり、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全な&lt;/a&gt;メソッドです。つまり、リソースを変更するために使用することはできません。 OPTIONSリクエストとともに、他の2つのリクエストヘッダーが送信されることに注意してください（それぞれ10行目と11行目）。</target>
        </trans-unit>
        <trans-unit id="656e5cef78d93570c111bd1f498ea5a75f7e0f4b" translate="yes" xml:space="preserve">
          <source>Lines 13 - 22 show the HTTP response from the server on domain &lt;code&gt;http://bar.other&lt;/code&gt;. In response, the server sends back an &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, shown above in line 16. The use of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header and of &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; show the access control protocol in its simplest use. In this case, the server responds with a &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; which means that the resource can be accessed by &lt;strong&gt;any&lt;/strong&gt; domain in a cross-site manner. If the resource owners at &lt;code&gt;http://bar.other&lt;/code&gt; wished to restrict access to the resource to requests only from &lt;code&gt;http://foo.example&lt;/code&gt;, they would send back:</source>
          <target state="translated">&lt;code&gt;http://bar.other&lt;/code&gt; 、ドメインhttp：//bar.other上のサーバーからのHTTP応答を示しています。これに応答して、サーバが返信する&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;の使用ライン16内の上方に示すヘッダ、&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; の&lt;/a&gt;ヘッダとの&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;、その最も単純な使用におけるアクセス制御プロトコルを示します。この場合、サーバーは &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; で応答します。これは、リソースがクロスサイトの方法で&lt;strong&gt;任意の&lt;/strong&gt;ドメインからアクセスできることを意味します。 &lt;code&gt;http://bar.other&lt;/code&gt; のリソース所有者が、リソースへのアクセスを &lt;code&gt;http://foo.example&lt;/code&gt; からのリクエストのみに制限したい場合は、次のように送信します。</target>
        </trans-unit>
        <trans-unit id="0936ed44f0ff243a8948b7ff1f3424ae3dd946dd" translate="yes" xml:space="preserve">
          <source>Lines 14 - 26 above are the response that the server sends back indicating that the request method (&lt;code&gt;POST&lt;/code&gt;) and request headers (&lt;code&gt;X-PINGOTHER&lt;/code&gt;) are acceptable. In particular, let's look at lines 17-20:</source>
          <target state="translated">上記の14行目から26行目は、サーバーが返信する応答で、要求メソッド（ &lt;code&gt;POST&lt;/code&gt; ）と要求ヘッダー（ &lt;code&gt;X-PINGOTHER&lt;/code&gt; ）が受け入れ可能であることを示しています。特に、17〜20行目を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="82027c0f9c7057e65bf210d13353910e8d71c0f4" translate="yes" xml:space="preserve">
          <source>Links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;.</source>
          <target state="translated">生成されたコードを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;ソースマップに&lt;/a&gt;リンクします。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="549589564fb88551ce209cf08bbdd821d0b56959" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686</source>
          <target state="translated">Linux デスクトップ、i686</target>
        </trans-unit>
        <trans-unit id="2c1006c548ffce988561b572ae63ee4b2e4e044d" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686 running on x86_64</source>
          <target state="translated">Linux デスクトップ、i686 が x86_64 で動作しています。</target>
        </trans-unit>
        <trans-unit id="7162da293f4c110abd9006ea0fe9502688b6d134" translate="yes" xml:space="preserve">
          <source>Linux desktop, x86_64</source>
          <target state="translated">Linux デスクトップ、x86_64</target>
        </trans-unit>
        <trans-unit id="ceb42a6047d0fbee0d6dbc845c8b0bf73fb0ee1b" translate="yes" xml:space="preserve">
          <source>Linux is a more diverse platform. A few common examples are given below.</source>
          <target state="translated">Linuxはより多様なプラットフォームです。いくつかの一般的な例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="065f1e3b7da760e47bd326f001407c11b87dca01" translate="yes" xml:space="preserve">
          <source>Linux version</source>
          <target state="translated">リナックス版</target>
        </trans-unit>
        <trans-unit id="f35d685de7aa50ed56af00a2c8d048a65fb3313a" translate="yes" xml:space="preserve">
          <source>List of HTTP status codes on Wikipedia</source>
          <target state="translated">ウィキペディアのHTTPステータスコード一覧</target>
        </trans-unit>
        <trans-unit id="c7facdad0c38a8be559aae543266310890041f74" translate="yes" xml:space="preserve">
          <source>Lists the set of HTTP request methods support by a resource.</source>
          <target state="translated">リソースがサポートするHTTPリクエストメソッドのセットをリストアップします。</target>
        </trans-unit>
        <trans-unit id="59afca4aa349dcb2585efb358d932b086d06c52a" translate="yes" xml:space="preserve">
          <source>Live properties described in this document SHOULD be moved along with
   the resource, such that the resource has identically behaving live
   properties at the destination resource, but not necessarily with the
   same values.  Note that some live properties are defined such that
   the absence of the property has a specific meaning (e.g., a flag with
   one meaning if present, and the opposite if absent), and in these
   cases, a successful MOVE might result in the property being reported
   as &quot;Not Found&quot; in subsequent requests.  If the live properties will
   not work the same way at the destination, the server MAY fail the
   request.

   MOVE is frequently used by clients to rename a file without changing
   its parent collection, so it's not appropriate to reset all live
   properties that are set at resource creation.  For example, the DAV:
   creationdate property value SHOULD remain the same after a MOVE.

   Dead properties MUST be moved along with the resource.</source>
          <target state="translated">この文書で記述されているライブプロパティは、リソースが宛先リソースで同じ動作をするライブプロパティを持つように、リソースと共に移動されるべきである[SHOULD]が、必ずしも同じ値を持つとは限らない。いくつかのライブプロパティは、そのプロパティが存在しない場合に特定の意味を持つように定義されていることに注意してください(例えば、存在する場合には1つの意味を持つフラグ、存在しない場合にはその逆の意味を持つフラグ)。ライブのプロパティが宛先で同じように動作しない場合、サーバはリクエストを失敗させてもよい[MAY]。MOVEは、親コレクションを変更せずにファイルの名前を変更するためにクライアントによって頻繁に使用されるので、リソースの作成時に設定されたすべてのライブプロパティをリセットするのは適切ではありません。例えば、DAV:creationdateプロパティ値はMOVE後も同じままであるべきである[SHOULD]。死んだプロパティはリソースと共に移動させなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="d81b072a609cb829f45333cb83e086a659ba9738" translate="yes" xml:space="preserve">
          <source>Living Standard</source>
          <target state="translated">生活水準</target>
        </trans-unit>
        <trans-unit id="6a7b5bd9c1e9247bb26bc70611e9ed0c08ee1e45" translate="yes" xml:space="preserve">
          <source>Load balancing/routing based on URL patterns</source>
          <target state="translated">URLパターンに基づくロードバランシング/ルーティング</target>
        </trans-unit>
        <trans-unit id="2bf154fc59dbac071e95bfd447b96ee4cb26055c" translate="yes" xml:space="preserve">
          <source>Load balancing: distribute the load to several web servers,</source>
          <target state="translated">ロードバランシング:複数のウェブサーバーに負荷を分散させます。</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="a65e984205ab4c0ed633ba5ae6a32d6c797cec2d" translate="yes" xml:space="preserve">
          <source>Location (RFC 2616)</source>
          <target state="translated">レンタル(RFC2616)</target>
        </trans-unit>
        <trans-unit id="a192553dfc610dd4624b27cebff4825c0c7e9331" translate="yes" xml:space="preserve">
          <source>Location (RFC 7231)</source>
          <target state="translated">レンタル(RFC7231</target>
        </trans-unit>
        <trans-unit id="c6e7ecfb5bf0d5af9da443ea9b5d77cb9bee2bce" translate="yes" xml:space="preserve">
          <source>Lock-Token = &quot;Lock-Token&quot; &quot;:&quot; Coded-URL

   The Lock-Token request header is used with the UNLOCK method to
   identify the lock to be removed.  The lock token in the Lock-Token
   request header MUST identify a lock that contains the resource
   identified by Request-URI as a member.

   The Lock-Token response header is used with the LOCK method to
   indicate the lock token created as a result of a successful LOCK
   request to create a new lock.</source>
          <target state="translated">Lock-Token=&quot;Lock-Token&quot; &quot;:&quot; Coded-URL Lock-Tokenリクエストヘッダは、削除するロックを識別するためにUNLOCKメソッドと共に使用される。Lock-Token リクエストヘッダのロックトークンは、Request-URI で識別されたリソースをメンバとして含むロックを識別しなければならない[MUST]。LOCK-Token レスポンスヘッダは、LOCK メソッドと共に使用され、新しいロックの作成に成功した LOCK リクエストの結果として作成されたロックトークンを示すために使用される。</target>
        </trans-unit>
        <trans-unit id="1a4b53727bcb9a035c59d80c57451cf3de2a5c3e" translate="yes" xml:space="preserve">
          <source>Logins, shopping carts, game scores, or anything else the server should remember</source>
          <target state="translated">ログイン、ショッピングカート、ゲームのスコアなど、サーバーが覚えておくべきことは何でもあります。</target>
        </trans-unit>
        <trans-unit id="bf49284c6e80b1a37a4cb9aa4fa17eb56ebba27b" translate="yes" xml:space="preserve">
          <source>Look, or ask, in specialized forums: you're unlikely to be the first to hit this problem. Also, experts, or simply people with another point of view, can give you ideas for working around the bug. If the problem seems uncommon, it's worth checking if this bug has been reported to the browser vendor via their bug tracking system (&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;; &lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;). Browser makers do pay attention to bug reports, and the analysis may hint about other workarounds for the bug.</source>
          <target state="translated">専門のフォーラムで見て、質問してください。この問題に最初に遭遇することはまずありません。また、エキスパート、または単に別の視点を持つ人々が、バグを回避するためのアイデアを提供できます。問題が珍しいと思われる場合は、このバグがバグ追跡システム（&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt; ; &lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt; ; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt; ; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;）を介してブラウザーベンダーに報告されているかどうかを確認する価値があります。ブラウザメーカーはバグレポートに注意を払っています。分析により、バグの他の回避策についてヒントが得られる場合があります。</target>
        </trans-unit>
        <trans-unit id="43ddda7cc2412992344e22fd844143dbcfe3bfc3" translate="yes" xml:space="preserve">
          <source>Lossy compression algorithms are usually more efficient that loss-less ones.</source>
          <target state="translated">損失のない圧縮アルゴリズムは、通常、損失のないものよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="ac2665911917ab5f698cf6ff5ed62343c6057a6a" translate="yes" xml:space="preserve">
          <source>MIME Type</source>
          <target state="translated">MIMEタイプ</target>
        </trans-unit>
        <trans-unit id="403274b7a1852e5261e595fa61397d41178bdb18" translate="yes" xml:space="preserve">
          <source>MIME Types</source>
          <target state="translated">MIME タイプ</target>
        </trans-unit>
        <trans-unit id="8e48cee9b67b50e883f2ce1444b5166e76e1cf17" translate="yes" xml:space="preserve">
          <source>MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field.  Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the Content-Type header
   field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail
   have used a media-type parameter of &quot;;conversions=&amp;lt;content-coding&amp;gt;&quot;
   to perform a function equivalent to Content-Encoding.  However, this
   parameter is not part of the MIME standards).</source>
          <target state="translated">MIMEには、HTTP / 1.1のContent-Encodingヘッダーフィールドに相当する概念は含まれていません。これはメディアタイプの修飾子として機能するため、HTTPからMIME準拠のプロトコルへのプロキシとゲートウェイは、メッセージを転送する前にContent-Typeヘッダーフィールドの値を変更するか、表現をデコードする必要があります。 （インターネットメールのContent-Typeの一部の実験的アプリケーションでは、「-conversions = &amp;lt;content-coding&amp;gt;」のメディアタイプパラメーターを使用して、Content-Encodingと同等の機能を実行しています。ただし、このパラメーターはMIME標準の一部ではありません。 ）。</target>
        </trans-unit>
        <trans-unit id="969c21cbc7a0aaa20e68f4d797544fee58a73005" translate="yes" xml:space="preserve">
          <source>MIME media types define what kind of document a specific resource is. This article presents both the syntax and the most useful MIME types for use on the Web.</source>
          <target state="translated">MIME メディアタイプは、特定のリソースがどのようなドキュメントであるかを定義します。この記事では、Web で使用するための構文と最も有用な MIME タイプの両方を紹介します。</target>
        </trans-unit>
        <trans-unit id="6bd9c9b5a57f317bcf5534bd7d83b023a8ee7df7" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more entities within a single message-body. All multipart
   types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;section&amp;nbsp;5.1.1 of RFC 2046&lt;/a&gt; 

   [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;], and MUST include a boundary parameter as part of the media type
   value. The message body is itself a protocol element and MUST
   therefore use only CRLF to represent line breaks between body-parts.
   Unlike in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, the epilogue of any multipart message MUST be
   empty; HTTP applications MUST NOT transmit the epilogue (even if the
   original multipart contains an epilogue). These restrictions exist in
   order to preserve the self-delimiting nature of a multipart message-
   body, wherein the &quot;end&quot; of the message-body is indicated by the
   ending multipart boundary.

   In general, HTTP treats a multipart message-body no differently than
   any other media type: strictly as payload. The one exception is the
   &quot;multipart/byteranges&quot; type (appendix 19.2) when it appears in a 206
   (Partial Content) response, which will be interpreted by some HTTP
   caching mechanisms as described in sections &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; and &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. In all
   other cases, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   The MIME header fields within each body-part of a multipart message-
   body do not have any significance to HTTP beyond that defined by
   their MIME semantics.

   In general, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   If an application receives an unrecognized multipart subtype, the
   application MUST treat it as being equivalent to &quot;multipart/mixed&quot;.

      Note: The &quot;multipart/form-data&quot; type has been specifically defined
      for carrying form data suitable for processing via the POST
      request method, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [&lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt;].</source>
          <target state="translated">MIMEは、多数の「マルチパート」タイプを提供します-単一のメッセージ本文内の1つ以上のエンティティのカプセル化。&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]のセクション5.1.1で定義されているように、すべてのマルチパートタイプは共通の構文を共有し、メディアタイプ値の一部として境界パラメーターを含める必要があります。メッセージ本文自体はプロトコル要素であるため、CRLFのみを使用して、本文部分間の改行を表す必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;とは異なり、マルチパートメッセージのエピローグは空でなければなりません。 HTTPアプリケーションは、エピローグを送信してはなりません（元のマルチパートにエピローグが含まれている場合でも）。これらの制限は、マルチパートメッセージ本文の自己区切りの性質を維持するために存在します。メッセージ本文の「終了」は、終了マルチパート境界によって示されます。一般に、HTTPはマルチパートメッセージ本文を他のメディアタイプとまったく同じように、厳密にはペイロードとして扱います。 1つの例外は、「multipart / byteranges」タイプ（付録19.2）であり、206（Partial Content）応答に表示される場合、セクション&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;および&lt;a href=&quot;#section-14.16&quot;&gt;14.16で&lt;/a&gt;説明されているように、一部のHTTPキャッシュメカニズムによって解釈されます。。他のすべてのケースでは、HTTPユーザーエージェントは、マルチパートタイプを受信したときのMIMEユーザーエージェントと同じまたは同様の動作に従う必要があります（SHOULD）。マルチパートメッセージボディの各ボディパート内のMIMEヘッダーフィールドは、MIMEセマンティクスで定義されているものを超えて、HTTPに対して重要ではありません。一般に、HTTPユーザーエージェントは、MIMEユーザーエージェントがマルチパートタイプを受信したときと同じまたは類似の動作に従う必要があります（SHOULD）。アプリケーションが認識されないマルチパートサブタイプを受信した場合、アプリケーションはそれを「マルチパート/混合」と同等のものとして扱う必要があります。注：「multipart / form-data」タイプは、POSTリクエストメソッドによる処理に適したフォームデータを伝送するために明確に定義されています。&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [ &lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt; ]に記載されています。</target>
        </trans-unit>
        <trans-unit id="4a0b826ef29a7a4a5fcb4cc1856fb5706a1d940c" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more representations within a single message body.  All
   multipart types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of
   [RFC2046]&lt;/a&gt;, and include a boundary parameter as part of the media type
   value.  The message body is itself a protocol element; a sender MUST
   generate only CRLF to represent line breaks between body parts.

   HTTP message framing does not use the multipart boundary as an
   indicator of message body length, though it might be used by
   implementations that generate or process the payload.  For example,
   the &quot;multipart/form-data&quot; type is often used for carrying form data
   in a request, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388&lt;/a&gt;], and the &quot;multipart/
   byteranges&quot; type is defined by this specification for use in some 206
   (Partial Content) responses [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;].</source>
          <target state="translated">MIMEは、多数の「マルチパート」タイプを提供します-単一のメッセージ本文内の1つ以上の表現のカプセル化。&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;[RFC2046]のセクション5.1.1で&lt;/a&gt;定義されているように、すべてのマルチパートタイプは共通の構文を共有し、メディアタイプ値の一部として境界パラメーターを含みます。メッセージ本文自体がプロトコル要素です。送信者は、ボディパーツ間の改行を表すCRLFのみを生成する必要があります。 HTTPメッセージフレーミングは、ペイロードを生成または処理する実装で使用される場合がありますが、メッセージ本文の長さのインジケータとしてマルチパート境界を使用しません。たとえば、「multipart / form-data」タイプは、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388で&lt;/a&gt;説明されているように、リクエストでフォームデータを運ぶためによく使用されます。]、および「multipart / byteranges」タイプは、一部の206（部分コンテンツ）応答[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] で使用するためにこの仕様で定義されています。</target>
        </trans-unit>
        <trans-unit id="c8e0f31f1df09630671c1f651e4e3b3a2f9c9629" translate="yes" xml:space="preserve">
          <source>MIME requires that an Internet mail body part be converted to
   canonical form prior to being transferred, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;Section&amp;nbsp;4
   of [RFC2049]&lt;/a&gt;.  &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document describes the forms
   allowed for subtypes of the &quot;text&quot; media type when transmitted over
   HTTP.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] requires that content with a type of &quot;text&quot;
   represent line breaks as CRLF and forbids the use of CR or LF outside
   of line break sequences.  HTTP allows CRLF, bare CR, and bare LF to
   indicate a line break within text content.

   A proxy or gateway from HTTP to a strict MIME environment ought to
   translate all line breaks within the text media types described in
   &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document to the &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; canonical form of
   CRLF.  Note, however, this might be complicated by the presence of a
   Content-Encoding and by the fact that HTTP allows the use of some
   charsets that do not use octets 13 and 10 to represent CR and LF,
   respectively. 

   Conversion will break any cryptographic checksums applied to the
   original content unless the original content is already in canonical
   form.  Therefore, the canonical form is recommended for any content
   that uses such checksums in HTTP.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;[RFC2049]のセクション4で&lt;/a&gt;説明されているように、MIMEでは、転送する前にインターネットメールの本文部分を正規形式に変換する必要があります。 このドキュメントの&lt;a href=&quot;#section-3.1.1.3&quot;&gt;セクション3.1.1.3&lt;/a&gt;は、HTTP経由で送信されるときに「テキスト」メディアタイプのサブタイプに許可されるフォームについて説明しています。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]は、タイプが「テキスト」のコンテンツが改行をCRLFとして表すことを要求し、改行シーケンスの外でのCRまたはLFの使用を禁止します。 HTTPでは、CRLF、ベアCR、およびベアLFでテキストコンテンツ内の改行を示すことができます。 HTTPから厳密なMIME環境へのプロキシまたはゲートウェイは、このドキュメントの&lt;a href=&quot;#section-3.1.1.3&quot;&gt;セクション3.1.1.3&lt;/a&gt;で説明されているテキストメディアタイプ内のすべての改行を&lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;に変換する 必要がありますCRLFの正規形。ただし、これは、Content-Encodingの存在と、HTTPではオクテット13と10を使用しない一部の文字セットを使用してCRとLFを表すことができるため、複雑になる場合があることに注意してください。元のコンテンツが既に正規形式でない限り、変換によって元のコンテンツに適用されている暗号化チェックサムは無効になります。したがって、HTTPでこのようなチェックサムを使用するコンテンツには、正規形式が推奨されます。</target>
        </trans-unit>
        <trans-unit id="dc3173f339d6234c3d312054225c8bdaf39b65b0" translate="yes" xml:space="preserve">
          <source>MIME sniffing</source>
          <target state="translated">MIME スニッフィング</target>
        </trans-unit>
        <trans-unit id="8c6307bfb3b795f533739b8404318fa008b26432" translate="yes" xml:space="preserve">
          <source>MIME type</source>
          <target state="translated">MIMEタイプ</target>
        </trans-unit>
        <trans-unit id="a4195024d58b7afd14c9753b91c2a9db35d2b08f" translate="yes" xml:space="preserve">
          <source>MIME types</source>
          <target state="translated">MIME タイプ</target>
        </trans-unit>
        <trans-unit id="c3957f21878ad7ce2b26fefff8051376805431e8" translate="yes" xml:space="preserve">
          <source>MIME types are case-insensitive but traditionally written in lowercase.</source>
          <target state="translated">MIME タイプは大文字小文字を区別しませんが、伝統的には小文字で書かれます。</target>
        </trans-unit>
        <trans-unit id="b860a02c04e9037685ceb44ac49fc8833ef95f3c" translate="yes" xml:space="preserve">
          <source>MIME types are not the only way to convey document type information:</source>
          <target state="translated">ドキュメントタイプの情報を伝える方法は、MIMEタイプだけではありません。</target>
        </trans-unit>
        <trans-unit id="4da8182b81c1bb802c3acafa674af9adc81313c0" translate="yes" xml:space="preserve">
          <source>MIME types: Complete list of MIME types</source>
          <target state="translated">MIME タイプ。MIME タイプの完全なリスト</target>
        </trans-unit>
        <trans-unit id="148704e082bf337e21217553e9d3d3709aea42bf" translate="yes" xml:space="preserve">
          <source>MKCOL creates a new collection resource at the location specified by
   the Request-URI.  If the Request-URI is already mapped to a resource,
   then the MKCOL MUST fail.  During MKCOL processing, a server MUST
   make the Request-URI an internal member of its parent collection,
   unless the Request-URI is &quot;/&quot;.  If no such ancestor exists, the
   method MUST fail.  When the MKCOL operation creates a new collection
   resource, all ancestors MUST already exist, or the method MUST fail
   with a 409 (Conflict) status code.  For example, if a request to
   create collection /a/b/c/d/ is made, and /a/b/c/ does not exist, the
   request must fail.

   When MKCOL is invoked without a request body, the newly created
   collection SHOULD have no members. 

   A MKCOL request message may contain a message body.  The precise
   behavior of a MKCOL request when the body is present is undefined,
   but limited to creating collections, members of a collection, bodies
   of members, and properties on the collections or members.  If the
   server receives a MKCOL request entity type it does not support or
   understand, it MUST respond with a 415 (Unsupported Media Type)
   status code.  If the server decides to reject the request based on
   the presence of an entity or the type of an entity, it should use the
   415 (Unsupported Media Type) status code.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">MKCOLは、Request-URIで指定された場所に新しいコレクションリソースを作成します。 Request-URIがすでにリソースにマップされている場合、MKCOLは失敗する必要があります。 MKCOL処理中、サーバーは、Request-URIが &quot;/&quot;でない限り、Request-URIをその親コレクションの内部メンバーにする必要があります。そのような祖先が存在しない場合、メソッドは失敗する必要があります。 MKCOL操作が新しいコレクションリソースを作成する場合、すべての祖先がすでに存在している必要があります。そうでない場合、メソッドは409（競合）ステータスコードで失敗する必要があります。たとえば、コレクション/ a / b / c / d /を作成する要求が行われ、/ a / b / c /が存在しない場合、要求は失敗する必要があります。 MKCOLがリクエストボディなしで呼び出された場合、新しく作成されたコレクションにはメンバーがありません。 MKCOL要求メッセージには、メッセージ本文が含まれる場合があります。本文が存在する場合のMKCOL要求の正確な動作は定義されていませんが、コレクション、コレクションのメンバー、メンバーの本文、およびコレクションまたはメンバーのプロパティの作成に限定されています。サーバーがサポートまたは理解していないMKCOL要求エンティティタイプを受信した場合、サーバーは415（Unsupported Media Type）ステータスコードで応答する必要があります。サーバーがエンティティの存在またはエンティティのタイプに基づいてリクエストを拒否する場合は、415（サポートされていないメディアタイプ）ステータスコードを使用する必要があります。この方法はべき等ですが、安全ではありません（サーバーがサポートまたは理解していないMKCOL要求エンティティタイプを受信した場合、サーバーは415（サポートされていないメディアタイプ）ステータスコードで応答する必要があります。サーバーがエンティティの存在またはエンティティのタイプに基づいて要求を拒否することを決定した場合、サーバーは415（サポートされていないメディアタイプ）ステータスコードを使用する必要があります。この方法はべき等ですが、安全ではありません（サーバーがサポートまたは理解していないMKCOL要求エンティティタイプを受信した場合、サーバーは415（サポートされていないメディアタイプ）ステータスコードで応答する必要があります。サーバーがエンティティの存在またはエンティティのタイプに基づいて要求を拒否することを決定した場合、サーバーは415（サポートされていないメディアタイプ）ステータスコードを使用する必要があります。この方法はべき等ですが、安全ではありません（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]のセクション9.1&lt;/a&gt;）。このメソッドへの応答はキャッシュしてはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="2a7163944345c31e87c18d422da826101ae9abe5" translate="yes" xml:space="preserve">
          <source>MPEG Video</source>
          <target state="translated">MPEGビデオ</target>
        </trans-unit>
        <trans-unit id="6856eb8cd7bbe158e86b90aca7643f9eb2028c7e" translate="yes" xml:space="preserve">
          <source>MS Embedded OpenType fonts</source>
          <target state="translated">MS 組み込み OpenType フォント</target>
        </trans-unit>
        <trans-unit id="6ee635274712baef8781c8d8f996b059e9c0d4e0" translate="yes" xml:space="preserve">
          <source>Mac OS X on Intel x86 or x86_64</source>
          <target state="translated">インテル x86 または x86_64 の Mac OS X</target>
        </trans-unit>
        <trans-unit id="973e3aaf5ab321c24d7296e6f425c45df453a860" translate="yes" xml:space="preserve">
          <source>Mac OS X on PowerPC</source>
          <target state="translated">Mac OS X on PowerPC</target>
        </trans-unit>
        <trans-unit id="70bafc26930c7270181eba7fdab16bde2ac8ad22" translate="yes" xml:space="preserve">
          <source>Mac OS X version</source>
          <target state="translated">Mac OS Xバージョン</target>
        </trans-unit>
        <trans-unit id="c0fd8053739db52e4d7f47348c57c75e3099c202" translate="yes" xml:space="preserve">
          <source>Macintosh</source>
          <target state="translated">Macintosh</target>
        </trans-unit>
        <trans-unit id="cd1cb4ddbb5f5f302fe8ca08ece123325b6c28dd" translate="yes" xml:space="preserve">
          <source>Magic numbers. The syntax of different formats allows file-type inference by looking at their byte structure. For example, GIF files start with the &lt;code&gt;47 49 46 38 39&lt;/code&gt; hexadecimal value (&lt;code&gt;GIF89&lt;/code&gt;), and PNG files with &lt;code&gt;89 50 4E 47&lt;/code&gt; (&lt;code&gt;.PNG&lt;/code&gt;). Not all file types have magic numbers, so this is not 100% reliable either.</source>
          <target state="translated">マジックナンバー。さまざまな形式の構文では、バイト構造を調べることでファイルタイプを推測できます。たとえば、GIFファイルは &lt;code&gt;47 49 46 38 39&lt;/code&gt; 16進値（ &lt;code&gt;GIF89&lt;/code&gt; ）で始まり、PNGファイルは &lt;code&gt;89 50 4E 47&lt;/code&gt; （ &lt;code&gt;.PNG&lt;/code&gt; ）です。すべてのファイルタイプにマジックナンバーがあるわけではないため、これも100％信頼できるわけではありません。</target>
        </trans-unit>
        <trans-unit id="37e6025eda2c374b5e1db64db721c1f61e0d7e8c" translate="yes" xml:space="preserve">
          <source>Make a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; (using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt;&lt;code&gt;Response.url&lt;/code&gt;&lt;/a&gt; for the Fetch API, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt;&lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt;&lt;/a&gt;) to determine what URL the real preflighted request would end up at.</source>
          <target state="translated">（Fetch APIの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt; &lt;code&gt;Response.url&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt; &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; &lt;/a&gt;を使用して）&lt;a href=&quot;#Simple_requests&quot;&gt;単純なリクエスト&lt;/a&gt;を行い、実際のプリフライトされたリクエストが最終的にどのURLになるかを判断します。</target>
        </trans-unit>
        <trans-unit id="db608f8e24798e21b8d041453cb94e74e2d2499f" translate="yes" xml:space="preserve">
          <source>Make another request (the &amp;ldquo;real&amp;rdquo; request) using the URL you obtained from &lt;code&gt;Response.url&lt;/code&gt; or &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; in the first step.</source>
          <target state="translated">最初のステップで &lt;code&gt;Response.url&lt;/code&gt; または &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; から取得したURLを使用して、別のリクエスト（「実際の」リクエスト）を作成します。</target>
        </trans-unit>
        <trans-unit id="05029130870878b79b7335852828d865e01799dc" translate="yes" xml:space="preserve">
          <source>Make sure your code only uses the permitted HTTP methods when accessing the service.</source>
          <target state="translated">サービスにアクセスする際には、許可された HTTP メソッドのみを使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="85896aa2638b32ee0bc92737649fbc2fda06cf32" translate="yes" xml:space="preserve">
          <source>Make your page work for both</source>
          <target state="translated">あなたのページを両方のために機能させる</target>
        </trans-unit>
        <trans-unit id="f989199f5291676ea54cc4b082182819742c121f" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource doesn't match any of the given ETags. This is used to update caches (for safe requests), or to prevent to upload a new resource when one is already existing.</source>
          <target state="translated">リクエストを条件付きにし、保存されているリソースが与えられた ETags にマッチしない場合にのみメソッドを適用します。これは、キャッシュを更新したり (安全なリクエストのために)、すでにリソースが存在する場合に新しいリソースをアップロードしないようにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="44bbd70969c3a3e1d64163feeed015fad79d423a" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource matches one of the given ETags.</source>
          <target state="translated">リクエストを条件付きにし、保存されたリソースが与えられたETagsのいずれかにマッチした場合にのみメソッドを適用します。</target>
        </trans-unit>
        <trans-unit id="169b3478c02104479a6e6958b18af330ce9e16b1" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has been modified after the given date. This is used to transmit data only when the cache is out of date.</source>
          <target state="translated">要求を条件付きにし、指定された日付以降に変更された場合にのみ送信されることを期待します。これは、キャッシュが古い場合にのみデータを送信するために使用されます。</target>
        </trans-unit>
        <trans-unit id="09d74b4e76e350446f9d2ba5e44f9fb97d8901cd" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has not been modified after the given date. This is used to ensure the coherence of a new fragment of a specific range with previous ones, or to implement an optimistic concurrency control system when modifying existing documents.</source>
          <target state="translated">要求を条件付きにして,指定された日付以降に変更されていない場合にのみ送信されることを期待します。これは、特定の範囲の新しいフラグメントと以前のフラグメントの一貫性を確保したり、 既存のドキュメントを修正する際に楽観的な同時実行制御システムを実装したりするために使用されます。</target>
        </trans-unit>
        <trans-unit id="ee449b1a1e7a790032bd3390fdea7fc50fbb85e5" translate="yes" xml:space="preserve">
          <source>Mandatory upgrade</source>
          <target state="translated">強制アップグレード</target>
        </trans-unit>
        <trans-unit id="aa95526dca52047ea17840984f5ae03c1700be81" translate="yes" xml:space="preserve">
          <source>Many &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;developer tools' network panels&lt;/a&gt; of browsers create extraneous requests leading to &lt;code&gt;304&lt;/code&gt; responses, so that access to the local cache is visible to developers.</source>
          <target state="translated">多くの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;開発者ツールの&lt;/a&gt;ブラウザーのネットワークパネルは、 &lt;code&gt;304&lt;/code&gt; 応答につながる無関係な要求を作成するため、ローカルキャッシュへのアクセスが開発者に表示されます。</target>
        </trans-unit>
        <trans-unit id="a0c2d53d901c528a1965720abe35932f4bbca17a" translate="yes" xml:space="preserve">
          <source>Many WebDAV clients that have already been implemented have account
   settings (similar to the way email clients store IMAP account
   settings).  Thus, the WebDAV client would be able to authenticate
   with its first couple requests to the server, provided it had a way
   to get the authentication challenge from the server with realm name, 

   nonce, and other challenge information.  Note that the results of
   some requests might vary according to whether or not the client is
   authenticated -- a PROPFIND might return more visible resources if
   the client is authenticated, yet not fail if the client is anonymous.

   There are a number of ways the client might be able to trigger the
   server to provide an authentication challenge.  This appendix
   describes a couple approaches that seem particularly likely to work.

   The first approach is to perform a request that ought to require
   authentication.  However, it's possible that a server might handle
   any request even without authentication, so to be entirely safe, the
   client could add a conditional header to ensure that even if the
   request passes permissions checks, it's not actually handled by the
   server.  An example of following this approach would be to use a PUT
   request with an &quot;If-Match&quot; header with a made-up ETag value.  This
   approach might fail to result in an authentication challenge if the
   server does not test authorization before testing conditionals as is
   required (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;), or if the server does not need to test
   authorization.

   Example - forcing auth challenge with write request

   &amp;gt;&amp;gt;Request

     PUT /forceauth.txt HTTP/1.1
     Host: www.example.com
     If-Match: &quot;xxx&quot;
     Content-Type: text/plain
     Content-Length: 0


   The second approach is to use an Authorization header (defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]), which is likely to be rejected by the server but which
   will then prompt a proper authentication challenge.  For example, the
   client could start with a PROPFIND request containing an
   Authorization header containing a made-up Basic userid:password
   string or with actual plausible credentials.  This approach relies on
   the server responding with a &quot;401 Unauthorized&quot; along with a
   challenge if it receives an Authorization header with an unrecognized
   username, invalid password, or if it doesn't even handle Basic
   authentication.  This seems likely to work because of the
   requirements of &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;: 

   &quot;If the origin server does not wish to accept the credentials sent
   with a request, it SHOULD return a 401 (Unauthorized) response.  The
   response MUST include a WWW-Authenticate header field containing at
   least one (possibly new) challenge applicable to the requested
   resource.&quot;

   There's a slight problem with implementing that recommendation in
   some cases, because some servers do not even have challenge
   information for certain resources.  Thus, when there's no way to
   authenticate to a resource or the resource is entirely publicly
   available over all accepted methods, the server MAY ignore the
   Authorization header, and the client will presumably try again later.

   Example - forcing auth challenge with Authorization header

   &amp;gt;&amp;gt;Request

     PROPFIND /docs/ HTTP/1.1
     Host: www.example.com
     Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
     Content-type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     [body omitted]</source>
          <target state="translated">既に実装されている多くのWebDAVクライアントには、アカウント設定があります（電子メールクライアントがIMAPアカウント設定を保存する方法と同様）。したがって、WebDAVクライアントは、レルム名、nonce、およびその他のチャレンジ情報を使用してサーバーから認証チャレンジを取得する方法を備えていれば、サーバーへの最初のカップル要求で認証できます。一部のリクエストの結果は、クライアントが認証されているかどうかによって異なる場合があることに注意してください。クライアントが認証されている場合、PROPFINDはより多くの可視リソースを返しますが、クライアントが匿名の場合は失敗しません。クライアントがサーバーをトリガーして認証チャレンジを提供できる方法はいくつかあります。この付録では、特に機能すると思われるいくつかのアプローチについて説明します。最初のアプローチは、認証を要求するはずのリクエストを実行することです。ただし、サーバーが認証なしでもリクエストを処理する可能性があるため、完全に安全であるために、クライアントは条件付きヘッダーを追加して、リクエストが権限チェックに合格しても、実際にはサーバーで処理されないようにすることができます。このアプローチに従う例は、作成されたETag値を持つ &quot;If-Match&quot;ヘッダーを持つPUTリクエストを使用することです。必要に応じて条件をテストする前にサーバーが承認をテストしない場合、このアプローチは認証チャレンジに失敗する可能性があります（を参照）クライアントは条件付きヘッダーを追加して、リクエストが権限チェックに合格した場合でも、サーバーで実際に処理されないようにすることができます。このアプローチに従う例は、作成されたETag値を持つ &quot;If-Match&quot;ヘッダーを持つPUTリクエストを使用することです。必要に応じて条件をテストする前にサーバーが承認をテストしない場合、このアプローチは認証チャレンジに失敗する可能性があります（を参照）クライアントは条件付きヘッダーを追加して、リクエストが権限チェックに合格した場合でも、サーバーで実際に処理されないようにすることができます。このアプローチに従う例は、作成されたETag値を持つ &quot;If-Match&quot;ヘッダーを持つPUTリクエストを使用することです。必要に応じて条件をテストする前にサーバーが承認をテストしない場合、このアプローチは認証チャレンジに失敗する可能性があります（を参照）必要に応じて条件をテストする前にサーバーが承認をテストしない場合、このアプローチは認証チャレンジに失敗する可能性があります（を参照）必要に応じて条件をテストする前にサーバーが承認をテストしない場合、このアプローチは認証チャレンジに失敗する可能性があります（を参照）&lt;a href=&quot;#section-8.5&quot;&gt;セクション8.5&lt;/a&gt;）、またはサーバーが承認をテストする必要がない場合。例-書き込みリクエストで認証チャレンジを強制する&amp;gt;&amp;gt; Request PUT /forceauth.txt HTTP / 1.1 Host：www.example.com If-Match： &quot;xxx&quot; Content-Type：text / plain Content-Length：0 2番目のアプローチは、 Authorizationヘッダーを使用する（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]）、これはサーバーによって拒否される可能性がありますが、適切な認証チャレンジを促します。たとえば、クライアントは、作成されたBasic userid：password文字列を含むAuthorizationヘッダーを含むPROPFIND要求、または実際のもっともらしい資格情報を使用して開始できます。このアプローチは、サーバーが認識できないユーザー名、無効なパスワードを含むAuthorizationヘッダーを受信した場合、または基本認証を処理しない場合に、チャレンジとともに「401 Unauthorized」で応答するサーバーに依存しています。&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617の&lt;/a&gt;要件のため、これは機能するようです：「オリジンサーバーがリクエストとともに送信された資格情報を受け入れたくない場合は、401（無許可）応答を返す必要があります。応答には、少なくとも1つの（おそらく新しい）チャレンジを含むWWW-Authenticateヘッダーフィールドを含める必要があります。リクエストされたリソース。」一部のサーバーでは特定のリソースのチャレンジ情報すら持っていないため、この推奨事項の実装には若干の問題があります。したがって、リソースに対して認証する方法がない場合、またはリソースがすべての受け入れられたメソッドで完全に公開されている場合、サーバーはAuthorizationヘッダーを無視する場合があり、クライアントはおそらく後で再試行します。例-Authorizationヘッダーで認証チャレンジを強制する&amp;gt;&amp;gt; Request PROPFIND / docs / HTTP / 1.1 Host：www.example。com Authorization：Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ == Content-type：application / xml; charset = &quot;utf-8&quot; Content-Length：xxxx [body省略]</target>
        </trans-unit>
        <trans-unit id="c2f40e3ce20552730e2da9b44cf88aa049c3f277" translate="yes" xml:space="preserve">
          <source>Many clients also let you avoid the login prompt by using an encoded URL containing the username and the password like this:</source>
          <target state="translated">多くのクライアントでは、このようにユーザ名とパスワードを含むエンコードされたURLを使用することで、ログインプロンプトを回避することもできます。</target>
        </trans-unit>
        <trans-unit id="283c9af22dd90c8866e71dddbfce0cce3700a5b6" translate="yes" xml:space="preserve">
          <source>Many of the request header fields for proactive negotiation use a
   common parameter, named &quot;q&quot; (case-insensitive), to assign a relative
   &quot;weight&quot; to the preference for that associated kind of content.  This
   weight is referred to as a &quot;quality value&quot; (or &quot;qvalue&quot;) because the
   same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various
   representations that can be selected for a resource. 

   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred; a
   value of 0 means &quot;not acceptable&quot;.  If no &quot;q&quot; parameter is present,
   the default weight is 1.

     weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue
     qvalue = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
            / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   A sender of qvalue MUST NOT generate more than three digits after the
   decimal point.  User configuration of these values ought to be
   limited in the same fashion.</source>
          <target state="translated">プロアクティブネゴシエーションのためのリクエストヘッダーフィールドの多くは、 「q」(大文字小文字を区別しない)という名前の一般的なパラメータを使用して、 関連する種類のコンテンツの優先度に相対的な「重み」を割り当てる。この重みは「品質値」(または「qvalue」)と呼ばれる。なぜなら、同じパラメー タ名が、リソースに対して選択できるさまざまな表現の相対的な品質に重みを 割り当てるために、サーバーの設定の中でよく使われるからである。重みは0から1の範囲の実数に正規化され、0.001は最も好ましくない値であり、1は最も好ましい値である。もし &quot;q &quot;パラメータが存在しない場合、デフォルトの重みは1である。 weight=OWS &quot;;&quot; OWS &quot;q=&quot; qvalue qvalue=(&quot;0&quot;[&quot;.&quot; 0*3DIGIT])/(&quot;1&quot;[&quot;.&quot; 0*3(&quot;0&quot;)]))qvalueの送信者は、小数点以下の3桁を超えて生成してはならない[MUST NOT]。これらの値のユーザ設定も同様に制限されるべきです。</target>
        </trans-unit>
        <trans-unit id="2fec0947cbf922d8434fc8fe01a93bf6110f4bdb" translate="yes" xml:space="preserve">
          <source>Many user agents make it possible for users to override the basic
   caching mechanisms. For example, the user agent might allow the user
   to specify that cached entities (even explicitly stale ones) are
   never validated. Or the user agent might habitually add &quot;Cache-
   Control: max-stale=3600&quot; to every request. The user agent SHOULD NOT
   default to either non-transparent behavior, or behavior that results
   in abnormally ineffective caching, but MAY be explicitly configured
   to do so by an explicit action of the user.

   If the user has overridden the basic caching mechanisms, the user
   agent SHOULD explicitly indicate to the user whenever this results in
   the display of information that might not meet the server's
   transparency requirements (in particular, if the displayed entity is
   known to be stale). Since the protocol normally allows the user agent
   to determine if responses are stale or not, this indication need only
   be displayed when this actually happens. The indication need not be a
   dialog box; it could be an icon (for example, a picture of a rotting
   fish) or some other indicator.

   If the user has overridden the caching mechanisms in a way that would
   abnormally reduce the effectiveness of caches, the user agent SHOULD
   continually indicate this state to the user (for example, by a
   display of a picture of currency in flames) so that the user does not
   inadvertently consume excess resources or suffer from excessive
   latency.</source>
          <target state="translated">多くのユーザエージェントは、ユーザが基本的なキャッシュ機構を上書きすることを可能にしています。例えば、ユーザーエージェントは、キャッシュされたエンティティ (明示的に古いものであっても)を決して検証しないことをユーザーに指定させるかもしれません。あるいは、ユーザーエージェントは、すべてのリクエストに「Cache-Control:max-stale=3600」を習慣的に追加するかもしれない。ユーザーエージェントは、非透過的な動作や、異常に効果的でないキャッシングをもたらす動作をデフォルトにすべきではない[SHOULD NOT]が、ユーザーの明示的なアクションによって明示的にそうするように設定されてもよい[MAY]。ユーザーが基本的なキャッシュメカニズムをオーバーライドした場合、ユーザーエージェント は、その結果、サーバーの透過性要件を満たさないかもしれない情報が表示されるときはいつで も、ユーザーに明示的に示すべきである[SHOULD](特に、表示されるエンティティが古いことが知られている場合)。プロトコルは通常、応答が古くなったかどうかをユーザエージェントが判断することを可能にしているので、この表示は、これが実際に起こったときにのみ表示される必要がある。表示はダイアログボックスである必要はなく、アイコン(例えば、腐った魚の画像)や他のインジケータであってもよい。ユーザーがキャッシュの有効性を異常に低下させるような方法でキャッシュメカニズムを上書きした場合、ユーザーエージェントは、ユーザーが誤って過剰なリソースを消費したり、過剰な遅延に苦しむことがないように、(例えば、炎の中の通貨の絵の表示によって)この状態をユーザーに継続的に示すべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="91d901c4ba5ec936d334c6e339e3c5a344ea50ad" translate="yes" xml:space="preserve">
          <source>Many web sites customize the look of a 404 page to be more helpful to the user and provide guidance on what to do next. Apache servers can be configured using an &lt;code&gt;.htaccess&lt;/code&gt; file and a code snippet like the following example.</source>
          <target state="translated">多くのWebサイトは、404ページの外観をカスタマイズしてユーザーにとってより役立つようにし、次に何をすべきかについてのガイダンスを提供しています。Apacheサーバーは、次の例のような &lt;code&gt;.htaccess&lt;/code&gt; ファイルとコードスニペットを使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="a17963b7961c54316ccf166b602f9000c64c4f9a" translate="yes" xml:space="preserve">
          <source>Matches any content encoding not already listed in the header. This is the default value if the header is not present. It doesn't mean that any algorithm is supported; merely that no preference is expressed.</source>
          <target state="translated">ヘッダにまだリストされていないコンテンツエンコーディングにマッチします。これは、ヘッダが存在しない場合のデフォルト値です。これは、任意のアルゴリズムがサポートされていることを意味するものではなく、 単に優先順位が表現されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="380542fdbbc688e8e6c3dd27ea8f678b7e9f1ca5" translate="yes" xml:space="preserve">
          <source>Max-Age=&amp;lt;number&amp;gt; Optional</source>
          <target state="translated">Max-Age = &amp;lt;number&amp;gt;オプション</target>
        </trans-unit>
        <trans-unit id="1f82181c1557956a09c87927dc4ce27ccc4098f3" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 2616)</source>
          <target state="translated">マックスフォワード(RFC2616)</target>
        </trans-unit>
        <trans-unit id="2b2d8c8ce404909b199641932433093016cba38f" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 7231)</source>
          <target state="translated">最大フォワード (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="02e6cf952f41741b2d0d0521bab1b080b79a5956" translate="yes" xml:space="preserve">
          <source>Maximum number of seconds the results can be cached.</source>
          <target state="translated">結果をキャッシュできる最大秒数。</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="cfef933803d5e6538306daeac1d4318fa9cda10c" translate="yes" xml:space="preserve">
          <source>May be set by hosting environments or other frameworks and contains information about them while not providing any usefulness to the application or its visitors. Unset this header to avoid exposing potential vulnerabilities.</source>
          <target state="translated">ホスティング環境や他のフレームワークによって設定される可能性があり、それらに関する情報が含まれていますが、アプリケーションやその訪問者には何の役にも立ちません。潜在的な脆弱性の暴露を避けるために、このヘッダの設定を解除してください。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="0d2e9b5ce7309f95a7890febc6e837b7f6d73bb0" translate="yes" xml:space="preserve">
          <source>Media formats supported by the HTML audio and video elements</source>
          <target state="translated">HTML のオーディオおよびビデオ要素でサポートされるメディア形式</target>
        </trans-unit>
        <trans-unit id="e73c2e204a43c925f331f4a9f4aa965ffa11300d" translate="yes" xml:space="preserve">
          <source>Media is only allowed from media1.com and media2.com (and not from subdomains of those sites).</source>
          <target state="translated">メディアはmedia1.comとmedia2.comからのみ許可されています(これらのサイトのサブドメインからは許可されていません)。</target>
        </trans-unit>
        <trans-unit id="62da738dbc54cd00c3ecc7aaa0efba6cf80eed5e" translate="yes" xml:space="preserve">
          <source>Message Format (RFC 7230)</source>
          <target state="translated">メッセージフォーマット(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="cd72d478c14d1e61f4d253f077b3b5817e52cd02" translate="yes" xml:space="preserve">
          <source>Message Routing (RFC 7230)</source>
          <target state="translated">メッセージルーティング (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="ed576c67d1fde583bfb7d4b0af04da9e09035d6c" translate="yes" xml:space="preserve">
          <source>Message body information</source>
          <target state="translated">メッセージ本文情報</target>
        </trans-unit>
        <trans-unit id="f1702b4686278becffc88baabe6f4b7a8355532c" translate="yes" xml:space="preserve">
          <source>Messages</source>
          <target state="translated">Messages</target>
        </trans-unit>
        <trans-unit id="f361b914c2431b8337949e5a832a53f9c04c4160" translate="yes" xml:space="preserve">
          <source>Messages are parsed using a generic algorithm, independent of the
   individual header field names.  The contents within a given field
   value are not parsed until a later stage of message interpretation
   (usually after the message's entire header section has been
   processed).  Consequently, this specification does not use ABNF rules
   to define each &quot;Field-Name: Field Value&quot; pair, as was done in
   previous editions.  Instead, this specification uses ABNF rules that
   are named according to each registered field name, wherein the rule
   defines the valid grammar for that field's corresponding field values
   (i.e., after the field-value has been extracted from the header
   section by a generic field parser).

   No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.

   A field value might be preceded and/or followed by optional
   whitespace (OWS); a single SP preceding the field-value is preferred
   for consistent readability by humans.  The field value does not
   include any leading or trailing whitespace: OWS occurring before the
   first non-whitespace octet of the field value or after the last
   non-whitespace octet of the field value ought to be excluded by
   parsers when extracting the field value from a header field.

   Historically, HTTP header field values could be extended over
   multiple lines by preceding each extra line with at least one space
   or horizontal tab (obs-fold).  This specification deprecates such
   line folding except within the message/http media type
   (&lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).  A sender MUST NOT generate a message that includes
   line folding (i.e., that has any field-value that contains a match to
   the obs-fold rule) unless the message is intended for packaging
   within the message/http media type. 

   A server that receives an obs-fold in a request message that is not
   within a message/http container MUST either reject the message by
   sending a 400 (Bad Request), preferably with a representation
   explaining that obsolete line folding is unacceptable, or replace
   each received obs-fold with one or more SP octets prior to
   interpreting the field value or forwarding the message downstream.

   A proxy or gateway that receives an obs-fold in a response message
   that is not within a message/http container MUST either discard the
   message and replace it with a 502 (Bad Gateway) response, preferably
   with a representation explaining that unacceptable line folding was
   received, or replace each received obs-fold with one or more SP
   octets prior to interpreting the field value or forwarding the
   message downstream.

   A user agent that receives an obs-fold in a response message that is
   not within a message/http container MUST replace each received
   obs-fold with one or more SP octets prior to interpreting the field
   value.

   Historically, HTTP has allowed field content with text in the
   ISO-8859-1 charset [&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;], supporting other charsets only
   through use of [&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt;] encoding.  In practice, most HTTP header
   field values use only a subset of the US-ASCII charset [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;].
   Newly defined header fields SHOULD limit their field values to
   US-ASCII octets.  A recipient SHOULD treat other octets in field
   content (obs-text) as opaque data.</source>
          <target state="translated">メッセージは、個々のヘッダーフィールド名とは関係なく、一般的なアルゴリズムを使用して解析されます。特定のフィールド値の内容は、メッセージ解釈の後の段階（通常はメッセージのヘッダーセクション全体が処理された後）まで解析されません。したがって、この仕様では、以前の版で行われていたように、ABNFルールを使用して各「フィールド名：フィールド値」のペアを定義していません。代わりに、この仕様は、登録された各フィールド名に従って名前が付けられたABNFルールを使用します。このルールは、そのフィールドの対応するフィールド値の有効な文法を定義します（つまり、フィールド値が汎用フィールドパーサーによってヘッダーセクションから抽出された後） ）。ヘッダーのフィールド名とコロンの間に空白を入れることはできません。過去には、このような空白の処理の違いにより、要求のルーティングと応答の処理にセキュリティ上の脆弱性が生じています。サーバーは、ヘッダーフィールド名とコロンの間に空白を含み、応答コード400（Bad Request）で受信した要求メッセージを拒否する必要があります。プロキシは、メッセージをダウンストリームに転送する前に、そのような空白を応答メッセージから削除する必要があります。フィールド値の前後には、オプションの空白（OWS）が続く場合があります。人間が一貫して読みやすくするために、フィールド値の前の単一のSPが推奨されます。フィールド値には、先頭または末尾の空白は含まれません。フィールド値の最初の非空白オクテットの前、またはフィールド値の最後の非空白オクテットの後に発生するOWSは、ヘッダーフィールドからフィールド値を抽出するときにパーサーによって除外されるべきです。従来、HTTPヘッダーフィールドの値は、余分な各行の前に少なくとも1つのスペースまたは水平タブ（obs-fold）を付けることで、複数行に拡張できました。この仕様では、message / httpメディアタイプ（&lt;a href=&quot;#section-8.3.1&quot;&gt;セクション8.3.1&lt;/a&gt;）。送信者は、メッセージがメッセージ/ httpメディアタイプ内でのパッケージ化を意図していない限り、行折りたたみを含むメッセージ（つまり、obs-foldルールへの一致を含むフィールド値を持つメッセージ）を生成してはなりません（MUST NOT）。メッセージ/ httpコンテナー内にない要求メッセージでobs-foldを受信するサーバーは、400（Bad Request）を送信してメッセージを拒否する必要があります。古い行の折りたたみは受け入れられないことを説明する表現を使用するか、それぞれを置き換える必要があります。フィールド値を解釈するか、メッセージをダウンストリームに転送する前に、1つ以上のSPオクテットでobs-foldを受信しました。メッセージ/ httpコンテナ内にない応答メッセージでobs-foldを受信するプロキシまたはゲートウェイは、メッセージを破棄して502（不正なゲートウェイ）応答に置き換える必要があります。好ましくは、許容できないラインフォールディングが受信されたことを説明する表現、またはフィールド値を解釈するか、メッセージをダウンストリームに転送する前に、受信された各obs-foldを1つ以上のSPオクテットに置き換えます。メッセージ/ httpコンテナー内にない応答メッセージでobs-foldを受信するユーザーエージェントは、フィールド値を解釈する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換えなければなりません（MUST）。歴史的に、HTTPはISO-8859-1文字セット[メッセージ/ httpコンテナー内にない応答メッセージでobs-foldを受信するユーザーエージェントは、フィールド値を解釈する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換えなければなりません（MUST）。歴史的に、HTTPはISO-8859-1文字セット[メッセージ/ httpコンテナー内にない応答メッセージでobs-foldを受信するユーザーエージェントは、フィールド値を解釈する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換えなければなりません（MUST）。歴史的に、HTTPはISO-8859-1文字セット[&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt; ]、[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt; ]エンコーディングの使用を通じてのみ他の文字セットをサポートします。実際には、ほとんどのHTTPヘッダーフィールド値はUS-ASCII文字セット[ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]のサブセットのみを使用します。新しく定義されたヘッダーフィールドは、フィールド値をUS-ASCIIオクテットに制限する必要があります（SHOULD）。受信者は、フィールドコンテンツ（obs-text）内の他のオクテットを不透明なデータとして扱う必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="a45a53f69ac8d4f9beb81fdb6abdda0d81b83401" translate="yes" xml:space="preserve">
          <source>Meta tag configuration</source>
          <target state="translated">メタタグの設定</target>
        </trans-unit>
        <trans-unit id="d3bc7449553df912945049faf23d54805daa3cef" translate="yes" xml:space="preserve">
          <source>Method Definitions (RFC 2616)</source>
          <target state="translated">メソッド定義 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="cb7ac4b5940dd1c323d62b5a8e651330e7495257" translate="yes" xml:space="preserve">
          <source>Method and body not changed</source>
          <target state="translated">メソッドとボディが変更されていない</target>
        </trans-unit>
        <trans-unit id="2d2721aaa9ac715c71cff1347bdeb0765b82f40d" translate="yes" xml:space="preserve">
          <source>Method and body not changed.</source>
          <target state="translated">方法と本体は変更していません。</target>
        </trans-unit>
        <trans-unit id="53d262d73147d297967a65df5e7306875b16e48d" translate="yes" xml:space="preserve">
          <source>Method handling</source>
          <target state="translated">メソッドの取り扱い</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="7e8cf9e2eae4020fb1e8917e8ab3068925ba7380" translate="yes" xml:space="preserve">
          <source>Methods can also have the property of &quot;idempotence&quot; in that (aside
   from error or expiration issues) the side-effects of N &amp;gt; 0 identical
   requests is the same as for a single request. The methods GET, HEAD,
   PUT and DELETE share this property. Also, the methods OPTIONS and
   TRACE SHOULD NOT have side effects, and so are inherently idempotent. 

   However, it is possible that a sequence of several requests is non-
   idempotent, even if all of the methods executed in that sequence are
   idempotent. (A sequence is idempotent if a single execution of the
   entire sequence always yields a result that is not changed by a
   reexecution of all, or part, of that sequence.) For example, a
   sequence is non-idempotent if its result depends on a value that is
   later modified in the same sequence.

   A sequence that never has side effects is idempotent, by definition
   (provided that no concurrent operations are being executed on the
   same set of resources).</source>
          <target state="translated">メソッドは、（エラーまたは期限切れの問題を除いて）N&amp;gt; 0の同一リクエストの副作用が単一リクエストの場合と同じであるという点で、「べき等」のプロパティを持つこともできます。メソッドGET、HEAD、PUT、DELETEはこのプロパティを共有します。また、メソッドOPTIONSおよびTRACEには副作用がないため、本質的にべき等です。ただし、そのシーケンスで実行されるすべてのメソッドがべき等であっても、複数のリクエストのシーケンスが非べき等である可能性があります。 （シーケンス全体の単一の実行が常にそのシーケンスのすべてまたは一部の再実行によって変更されない結果を生成する場合、シーケンスはべき等です。）たとえば、結果が後で同じシーケンスで変更される値。副作用がない決してシーケンスはべき等です（同じリソースのセットで並行操作が実行されていない場合）。</target>
        </trans-unit>
        <trans-unit id="242805378404a310345cf70839197bf474f74005" translate="yes" xml:space="preserve">
          <source>Microphone</source>
          <target state="translated">Microphone</target>
        </trans-unit>
        <trans-unit id="87276ecf605640589cec1d79d00bf26c970b94e4" translate="yes" xml:space="preserve">
          <source>Microsoft Excel</source>
          <target state="translated">マイクロソフトエクセル</target>
        </trans-unit>
        <trans-unit id="2a323ed6449b617238b82a3dfc75eb9621adc7da" translate="yes" xml:space="preserve">
          <source>Microsoft Excel (OpenXML)</source>
          <target state="translated">マイクロソフトエクセル(OpenXML</target>
        </trans-unit>
        <trans-unit id="95afea748c2d83deeb5e505cb3467080a79ec0dd" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint</source>
          <target state="translated">マイクロソフトパワーポイント</target>
        </trans-unit>
        <trans-unit id="66f10ebd0f328820d7789369e62c94f10eb4d83b" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint (OpenXML)</source>
          <target state="translated">マイクロソフトパワーポイント(OpenXML</target>
        </trans-unit>
        <trans-unit id="f8f6993a5165c131c1d8c5214734c809b756f2ef" translate="yes" xml:space="preserve">
          <source>Microsoft Visio</source>
          <target state="translated">マイクロソフトビジオ</target>
        </trans-unit>
        <trans-unit id="1549499155dcad76ee4cf933519cd8cacaf632b7" translate="yes" xml:space="preserve">
          <source>Microsoft Word</source>
          <target state="translated">マイクロソフトワード</target>
        </trans-unit>
        <trans-unit id="36cf4ee07cac5059a5ad97ffe928503bd176751c" translate="yes" xml:space="preserve">
          <source>Microsoft Word (OpenXML)</source>
          <target state="translated">マイクロソフトワード</target>
        </trans-unit>
        <trans-unit id="1198ed8512c8cdd797293daa67494bddc3770413" translate="yes" xml:space="preserve">
          <source>Microsoft document</source>
          <target state="translated">マイクロソフトドキュメント</target>
        </trans-unit>
        <trans-unit id="1df4b94ae4d5602d088aff532dae5e38510a6678" translate="yes" xml:space="preserve">
          <source>Midi</source>
          <target state="translated">Midi</target>
        </trans-unit>
        <trans-unit id="f3c717723ab8734d12784f68a0722e11e80fcc72" translate="yes" xml:space="preserve">
          <source>Minutes from 0 to 59.</source>
          <target state="translated">0から59までの分数。</target>
        </trans-unit>
        <trans-unit id="89539c6918ebad2db5606b4128932b01811ff405" translate="yes" xml:space="preserve">
          <source>Miscellaneous Persistent Warning</source>
          <target state="translated">その他の永続的な警告</target>
        </trans-unit>
        <trans-unit id="a58539b42f2a5b03e79f0e0357f01220b1c564c9" translate="yes" xml:space="preserve">
          <source>Miscellaneous Warning</source>
          <target state="translated">その他の注意事項</target>
        </trans-unit>
        <trans-unit id="6440b6c15fbd440237dd7ddf04fa83c555b31d51" translate="yes" xml:space="preserve">
          <source>Mitigating MIME Confusion Attacks in Firefox</source>
          <target state="translated">Firefox での MIME 混同攻撃の緩和</target>
        </trans-unit>
        <trans-unit id="5d489f5457c01748e6b6d121f8ab0bb76ce6faab" translate="yes" xml:space="preserve">
          <source>Mitigating cross site scripting</source>
          <target state="translated">クロスサイトスクリプティングの緩和</target>
        </trans-unit>
        <trans-unit id="a06d1d2ac6f2847420dd550f09dcb2166ef5252d" translate="yes" xml:space="preserve">
          <source>Mitigating packet sniffing attacks</source>
          <target state="translated">パケットスニッフィング攻撃の軽減</target>
        </trans-unit>
        <trans-unit id="f7fb61404c2b0add12a8de94361ca1262d06c970" translate="yes" xml:space="preserve">
          <source>Mixed Content</source>
          <target state="translated">混合コンテンツ</target>
        </trans-unit>
        <trans-unit id="4a03a5aca91ea4ae835ab37b3456e345e1c824ad" translate="yes" xml:space="preserve">
          <source>Mixed Content&lt;br/&gt;&lt;small&gt;The definition of 'block-all-mixed-content' in that specification.&lt;/small&gt;</source>
          <target state="translated">混合コンテンツ&lt;br/&gt;&lt;small&gt;その仕様における「block-all-mixed-content」の定義。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="69248b8f3367a963f6ed1431265d03d542c43778" translate="yes" xml:space="preserve">
          <source>Mixed content</source>
          <target state="translated">混合された内容</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="0efeb0636336539c3bcea3d1fe128360ba3a0b9d" translate="yes" xml:space="preserve">
          <source>Mobile Device Detection</source>
          <target state="translated">モバイルデバイス検出</target>
        </trans-unit>
        <trans-unit id="2ae9795ad44783e26e39ba8db6b981786d39f71b" translate="yes" xml:space="preserve">
          <source>Mobile and Tablet indicators</source>
          <target state="translated">モバイルとタブレットの指標</target>
        </trans-unit>
        <trans-unit id="183f26ae5771e151ff87bc3aac010eef4b387ac0" translate="yes" xml:space="preserve">
          <source>Mobile, Tablet or Desktop</source>
          <target state="translated">モバイル、タブレット、デスクトップ</target>
        </trans-unit>
        <trans-unit id="1387238e2992cdaf972778c0a1519b7892c33930" translate="yes" xml:space="preserve">
          <source>More specifically, this article is for web administrators, server developers, and front-end developers. Modern browsers handle the client-side components of cross-origin sharing, including headers and policy enforcement. But this new standard means servers have to handle new request and response headers. Another article for server developers discussing &lt;a href=&quot;server-side_access_control&quot;&gt;cross-origin sharing from a server perspective (with PHP code snippets)&lt;/a&gt; is supplementary reading.</source>
          <target state="translated">具体的には、この記事はWeb管理者、サーバー開発者、フロントエンド開発者を対象としています。最新のブラウザーは、ヘッダーやポリシーの適用など、クロスオリジン共有のクライアント側コンポーネントを処理します。しかし、この新しい標準は、サーバーが新しい要求ヘッダーと応答ヘッダーを処理する必要があることを意味します。&lt;a href=&quot;server-side_access_control&quot;&gt;サーバーの観点からのクロスオリジン共有（PHPコードスニペットを使用）&lt;/a&gt;について説明するサーバー開発者向けのもう1つの記事は、補足的な読み物です。</target>
        </trans-unit>
        <trans-unit id="4d672ad094374129b7ac45aa56021f772e22d674" translate="yes" xml:space="preserve">
          <source>More than 15 years of extensions</source>
          <target state="translated">15年以上の増築実績</target>
        </trans-unit>
        <trans-unit id="93defa8d9384e526ec8c563df8553e7f68474a93" translate="yes" xml:space="preserve">
          <source>More than one &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header was sent by the server. This isn't allowed.</source>
          <target state="translated">サーバーから複数の&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;ヘッダーが送信されました。これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="1be543deb68df132d0c179bafbe0c9f9d5ae66cd" translate="yes" xml:space="preserve">
          <source>Most HTTP header field values are defined using common syntax
   components (token, quoted-string, and comment) separated by
   whitespace or specific delimiting characters.  Delimiters are chosen
   from the set of US-ASCII visual characters not allowed in a token
   (DQUOTE and &quot;(),/:;&amp;lt;=&amp;gt;?@[\]{}&quot;).

     token          = 1*tchar

     tchar          = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot;
                    / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot;
                    / DIGIT / ALPHA
                    ; any VCHAR, except delimiters

   A string of text is parsed as a single value if it is quoted using
   double-quote marks.

     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
     obs-text       = %x80-FF

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses.  Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.

     comment        = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

   The backslash octet (&quot;\&quot;) can be used as a single-octet quoting
   mechanism within quoted-string and comment constructs.  Recipients
   that process the value of a quoted-string MUST handle a quoted-pair
   as if it were replaced by the octet following the backslash.

     quoted-pair    = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )

   A sender SHOULD NOT generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within
   that string.  A sender SHOULD NOT generate a quoted-pair in a comment
   except where necessary to quote parentheses [&quot;(&quot; and &quot;)&quot;] and
   backslash octets occurring within that comment.</source>
          <target state="translated">ほとんどのHTTPヘッダーフィールド値は、空白または特定の区切り文字で区切られた一般的な構文コンポーネント（トークン、引用符付き文字列、コメント）を使用して定義されます。区切り文字は、トークンで許可されていないUS-ASCIIビジュアル文字のセットから選択されます（DQUOTEおよび &quot;（）、/ :; &amp;lt;=&amp;gt;？@ [\] {}&quot;）。トークン= 1 * tchar tchar = &quot;！&quot; / &quot;＃&quot; / &quot;$&quot; / &quot;％&quot; / &quot;＆&quot; / &quot;'&quot; / &quot;*&quot; / &quot;+&quot; / &quot;-&quot; / &quot;。&quot; / &quot;^&quot; / &quot;_&quot; / &quot;` &quot;/&quot; | &quot; / &quot;〜&quot; / DIGIT / ALPHA;区切り文字を除く任意のVCHAR二重引用符を使用して引用符で囲まれている場合、テキストの文字列は単一の値として解析されます。quoted-string = DQUOTE *（qdtext / quoted-pair）DQUOTE qdtext = HTAB / SP /％x21 /％x23-5B /％x5D-7E / obs-text obs-text =％x80-FFコメントは一部に含めることができます括弧でコメントテキストを囲むことによるHTTPヘッダーフィールド。コメントは、フィールド値の定義の一部として「コメント」を含むフィールドでのみ許可されます。コメント= &quot;（&quot; *（ctext / quoted-pair /コメント） &quot;）&quot; ctext = HTAB / SP /％x21-27 /％x2A-5B /％x5D-7E / obs-textバックスラッシュオクテット（ &quot;\&quot;） quoted-stringおよびcomment構文内の単一オクテット引用メカニズムとして使用できます。 quoted-stringの値を処理する受信者は、引用符で囲まれたペアを、バックスラッシュに続くオクテットに置き換えられたかのように処理する必要があります。 quoted-pair = &quot;\ &quot;（HTAB / SP / VCHAR / obs-text）送信者は、DQUOTEおよびその文字列内で発生するバックスラッシュオクテットを引用する必要がある場合を除いて、引用符付き文字列に引用符付きペアを生成してはいけません（SHOULD NOT）。送信者は引用符付きペアを生成してはいけません（SHOULD NOT）括弧[&quot;（&quot;と &quot;）&quot;]とそのコメント内で発生するバックスラッシュオクテットを引用する必要がある場合を除いて、コメント内。</target>
        </trans-unit>
        <trans-unit id="812bdf18b5a605c99457c43782814e036fcbedcf" translate="yes" xml:space="preserve">
          <source>Most HTTP responses include an entity which contains information for
   interpretation by a human user. Naturally, it is desirable to supply
   the user with the &quot;best available&quot; entity corresponding to the
   request. Unfortunately for servers and caches, not all users have the
   same preferences for what is &quot;best,&quot; and not all user agents are
   equally capable of rendering all entity types. For that reason, HTTP
   has provisions for several mechanisms for &quot;content negotiation&quot; --
   the process of selecting the best representation for a given response
   when there are multiple representations available.

      Note: This is not called &quot;format negotiation&quot; because the
      alternate representations may be of the same media type, but use
      different capabilities of that type, be in different languages,
      etc. 

   Any response containing an entity-body MAY be subject to negotiation,
   including error responses.

   There are two kinds of content negotiation which are possible in
   HTTP: server-driven and agent-driven negotiation. These two kinds of
   negotiation are orthogonal and thus may be used separately or in
   combination. One method of combination, referred to as transparent
   negotiation, occurs when a cache uses the agent-driven negotiation
   information provided by the origin server in order to provide
   server-driven negotiation for subsequent requests.</source>
          <target state="translated">ほとんどのHTTPレスポンスは、人間のユーザが解釈するための情報を含む実体を含む。当然のことながら、リクエストに対応する「利用可能な最善の」エンティティをユーザに提供することが望ましい。しかし、サーバやキャッシュにとっては残念ながら、すべてのユーザが何が「最良」であるかについて同じ好みを持っているわけではなく、また、すべてのユーザエージェントがすべてのエンティティタイプをレンダリングできるわけでもありません。そのため、HTTP には「コンテントネゴシエーション」のためのいくつかのメカニズムが用意されています。注意:これは「フォーマットネゴシエーション」とは呼ばれない。なぜなら、代替の表現は同じメディアタイプであっても、そのタイプの異なる機能を使用したり、異なる言語であったりするからである。エラー応答を含め、エンティティボディを含む応答はすべてネゴシエーションの対象としてもよい[MAY]。HTTPで可能なコンテンツネゴシエーションには、サーバー駆動型とエージェント駆動型のネゴシエーションの2種類があります。これら2種類のネゴシエーションは直交しているので、別々に使用してもよいし、組み合わせて使用してもよい。透過ネゴシエーションと呼ばれる組み合わせの一つの方法は、キャッシュが後続のリクエストにサーバ駆動型ネゴシエーションを提供するためにオリジンサーバによって提供されたエージェント駆動型ネゴシエーション情報を使用するときに発生します。</target>
        </trans-unit>
        <trans-unit id="7460036b5d618f72b9d5e87b1f21806669419e9d" translate="yes" xml:space="preserve">
          <source>Most browsers set the name and version in the format &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt;, with the notable exception of Internet Explorer. But as the name is not the only information in a user agent string that is in that format, you can not discover the name of the browser, you can only check if the name you are looking for. But note that some browsers are lying: Chrome for example reports both as Chrome and Safari. So to detect Safari you have to check for the Safari string and the absence of the Chrome string, Chromium often reports itself as Chrome too or Seamonkey sometimes reports itself as Firefox.</source>
          <target state="translated">ほとんどのブラウザーは、名前とバージョンを&lt;em&gt;BrowserName / VersionNumber&lt;/em&gt;の形式で設定しますが、Internet Explorerは例外です。しかし、名前はその形式のユーザーエージェント文字列の唯一の情報ではないため、ブラウザの名前を見つけることはできず、探している名前かどうかしか確認できません。ただし、一部のブラウザは嘘をついていることに注意してください。たとえば、ChromeはChromeとSafariの両方としてレポートします。そのため、Safariを検出するには、Safari文字列とChrome文字列がないことを確認する必要があります。ChromiumはしばしばChromeとしても報告するか、SeamonkeyはFirefoxとして報告することがあります。</target>
        </trans-unit>
        <trans-unit id="02c0fa975a9a4f1c1a39487a5147f2636b69eb9e" translate="yes" xml:space="preserve">
          <source>Most of the standard JavaScript functionality is available for use in the FindProxyForURL() function. As an example, to set different proxies based on the protocol the substring() function can be used:</source>
          <target state="translated">標準的な JavaScript の機能のほとんどは FindProxyForURL()関数で使用できます。例えば、プロトコルに基づいて異なるプロキシを設定するには substring()関数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="92624466818eb51fd53a17208603205adea7766c" translate="yes" xml:space="preserve">
          <source>Most of the time identity and location of a Web resource are shared, this can be changed with the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">ほとんどの場合、WebリソースのIDと場所は共有され、これは&lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt;ヘッダーで変更できます。</target>
        </trans-unit>
        <trans-unit id="7b365dcd7a6f5dfd969c8f5a85717b49e744e8f9" translate="yes" xml:space="preserve">
          <source>Most of the time this is a server problem, and if the server cannot detect it, it will send back a &lt;a href=&quot;status/500&quot;&gt;&lt;code&gt;500&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Internal Server Error&lt;/code&gt;. If you encounter such an error soon after modifying a server configuration, this is likely a redirection loop.</source>
          <target state="translated">ほとんどの場合、これはサーバーの問題であり、サーバーがそれを検出できない場合は、&lt;a href=&quot;status/500&quot;&gt; &lt;code&gt;500&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Internal Server Error&lt;/code&gt; 返されます。サーバー構成を変更した直後にこのようなエラーが発生する場合は、リダイレクトループである可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd93e26ede2192a4f8e353e3bbf7ab476b541a23" translate="yes" xml:space="preserve">
          <source>Most rendering engines put the version number in the &lt;em&gt;RenderingEngine/VersionNumber&lt;/em&gt; token, with the notable exception of Gecko. Gecko puts the Gecko version number in the comment part of the User Agent after the &lt;code&gt;rv:&lt;/code&gt; string. From Gecko 14 for the mobile version and Gecko 17 for the desktop version, it also puts this value in the &lt;code&gt;Gecko/version&lt;/code&gt; token (previous version put there the build date, then a fixed date called the GeckoTrail).</source>
          <target state="translated">ほとんどのレンダリングエンジンは、Geckoを除いて、バージョン番号を&lt;em&gt;RenderingEngine / VersionNumber&lt;/em&gt;トークンに&lt;em&gt;入れ&lt;/em&gt;ます。Geckoは、ユーザーエージェントのコメント部分の &lt;code&gt;rv:&lt;/code&gt; 文字列の後にGeckoのバージョン番号を入れます。モバイルバージョンのGecko 14およびデスクトップバージョンのGecko 17から、この値を &lt;code&gt;Gecko/version&lt;/code&gt; トークンにも入れます（以前のバージョンにはビルド日付が置かれ、次にGeckoTrailと呼ばれる固定日付が置かれます）。</target>
        </trans-unit>
        <trans-unit id="c37f0d1445fedf718be400753c3dbf6a2412f759" translate="yes" xml:space="preserve">
          <source>Most web servers send unrecognized resources as the &lt;code&gt;application/octet-stream&lt;/code&gt; MIME type. For security reasons, most browsers do not allow setting a custom default action for such resources, forcing the user to save it to disk to use it.</source>
          <target state="translated">ほとんどのWebサーバーは、認識されないリソースを &lt;code&gt;application/octet-stream&lt;/code&gt; MIMEタイプとして送信します。セキュリティ上の理由から、ほとんどのブラウザでは、そのようなリソースにカスタムのデフォルトアクションを設定することはできません。ユーザーはそれをディスクに保存して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a8946eed2c78e3706e8f2276333fa60dc5390eb" translate="yes" xml:space="preserve">
          <source>Moving to a different domain. For example, your company has been renamed and you when searching for the old name, you want people used to the old company Web site still find you under the new name.</source>
          <target state="translated">別のドメインへの移動。例えば、あなたの会社が名前を変更されており、古い名前を検索するときに、あなたは、古い会社のウェブサイトに使用されている人々はまだ新しい名前の下であなたを見つけるしたいと思います。</target>
        </trans-unit>
        <trans-unit id="0ef3be393a351dfa2ef963cfdc34f9e6563cc892" translate="yes" xml:space="preserve">
          <source>Mozilla (Gecko, Firefox)</source>
          <target state="translated">モジラ(Gecko、Firefox</target>
        </trans-unit>
        <trans-unit id="a0934075575145263129d33cbbd963bcda3860f4" translate="yes" xml:space="preserve">
          <source>Mozilla Observatory</source>
          <target state="translated">もじら天文台</target>
        </trans-unit>
        <trans-unit id="decab94514e261dda8ed0ab5f5a50868157343e3" translate="yes" xml:space="preserve">
          <source>Mozilla web security guidelines</source>
          <target state="translated">モジラウェブセキュリティガイドライン</target>
        </trans-unit>
        <trans-unit id="0fee1a221e5d621522c4cae25d2d3f0781412c73" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Mobile; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla/5.0 (Android 4.4;Mobile;rv:41.0)Gecko/41.0 Firefox/41.0</target>
        </trans-unit>
        <trans-unit id="06ca2e8b107ebc3017f1b6838abe49d90a2337b1" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Tablet; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla/5.0 (Android 4.4;Tablet;rv:41.0)Gecko/41.0 Firefox/41.0</target>
        </trans-unit>
        <trans-unit id="12388f0ea73a7de9d571898b4be2154ce15cb9f4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 7.0; Mobile; rv:62.0) Gecko/62.0 Firefox/62.0</source>
          <target state="translated">Mozilla/5.0 (Android 7.0;Mobile;rv:62.0)Gecko/62.0 Firefox/62.0</target>
        </trans-unit>
        <trans-unit id="adf944b54ec9b6df9ba954b5789e4f037d57ad12" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0</source>
          <target state="translated">Mozilla/5.0 (Android;Mobile;rv:13.0)Gecko/13.0 Firefox/13.0</target>
        </trans-unit>
        <trans-unit id="4d33bd8f87ba06abe4fe1c0b9f3fd3d4ef39a64b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla/5.0 (Android;Mobile;rv:40.0)Gecko/40.0 Firefox/40.0</target>
        </trans-unit>
        <trans-unit id="b1165e7e7925427d068dfe4278ee0a0ab81d03a6" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Tablet; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla/5.0 (Android;Tablet;rv:40.0)Gecko/40.0 Firefox/40.0</target>
        </trans-unit>
        <trans-unit id="1eff4492cf201da272b181a0826abf69087bdbae" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 4.4.2); Nexus 5 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 4.4.2);Nexus 5 Build/KOT49H)AppleWebKit/537.36 (KHTML,like Gecko)Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047</target>
        </trans-unit>
        <trans-unit id="187263e2548b4eea2d8d1b7718d1e58bc486ee8f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 5.1.1) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.1 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 5.1.1)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Focus/1.1 Chrome/59.0.3017.125 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="f069d17af594e5cc6ceb8bcf6da674fc68ec9615" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Mobile Safari/537.36</target>
        </trans-unit>
        <trans-unit id="5cdca6439d9f4f75159a9c3f7e09c52e695e1e6d" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="d3772cfc2095a71baa2d031dbccc5f42fe0a9faa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/4.1 Chrome/62.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Focus/4.1 Chrome/62.0.3029.83 Mobile Safari/537.36</target>
        </trans-unit>
        <trans-unit id="5c9a7c5212d961b33810bd5d24bd5d65d22acc7b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Klar/1.0 Chrome/58.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.0)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Klar/1.0 Chrome/58.0.3029.83 Mobile Safari/537.36</target>
        </trans-unit>
        <trans-unit id="3ebf95e0e00b50d02895700858ee637ccce16aee" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.1.2) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/3.0 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla/5.0 (Linux;Android 7.1.2)AppleWebKit/537.36 (GeckoのようなKHTML)Version/4.0 Focus/3.0 Chrome/59.0.3017.125 Safari/537.36</target>
        </trans-unit>
        <trans-unit id="2107ee483b37620cd27469a83622677f75ba74e7" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; U; Android 4.0.3; de-ch; HTC Sensation Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</source>
          <target state="translated">Mozilla/5.0 (Linux;U;Android 4.0.3;de-ch;HTC Sensation Build/IML74K)AppleWebKit/534.30 (KHTML,like Gecko)Version/4.0 Mobile Safari/534.30</target>
        </trans-unit>
        <trans-unit id="b1d3f926e92bfa21fd4b0d0fe771e000d5d2b871" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (Macintosh;Intel Mac OS X 10.5;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="6d87ab26fc3278b385f67646186cafe62f1226c0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:2.0.1) Gecko/20100101 Firefox/4.0.1 Camino/2.2.1</source>
          <target state="translated">Mozilla/5.0 (Macintosh;Intel Mac OS X 10.5;rv:2.0.1)Gecko/20100101 Firefox/4.0.1 Camino/2.2.1</target>
        </trans-unit>
        <trans-unit id="08a47789f901ac4697d74b3d7f335103a2d1b4b2" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Macintosh; Intel Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv：10.0）Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="92e71ac1941b70b8a195b2038b988eb15e2633cf" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; PPC Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Macintosh; PPC Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv：10.0）Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="49a7b83668313b9e1281eda63779e0047234a704" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0) Gecko/20100101 Firefox/10.0 Fennec/10.0</source>
          <target state="translated">Mozilla/5.0 (Maemo;Linux armv7l;rv:10.0)Gecko/20100101 Firefox/10.0 Fennec/10.0</target>
        </trans-unit>
        <trans-unit id="4912bc7f8d14158acb5958155825887af72f69e0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1</source>
          <target state="translated">Mozilla/5.0 (Maemo;Linux armv7l;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1</target>
        </trans-unit>
        <trans-unit id="24d7bfb4e448eb6a6f2b2c05f9ccace8303e7951" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla / 5.0（モバイル; &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; rv：26.0）Gecko / 26.0 Firefox / 26.0</target>
        </trans-unit>
        <trans-unit id="fe824479059b41314b08fccf6ffd2df216b210a4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla/5.0 (Mobile;rv:26.0)Gecko/26.0 Firefox/26.0</target>
        </trans-unit>
        <trans-unit id="1e65d98e39260d268ec140c75dfc14eb88fe1d22" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (TV; rv:44.0) Gecko/44.0 Firefox/44.0</source>
          <target state="translated">Mozilla/5.0 (TV;rv:44.0)Gecko/44.0 Firefox/44.0</target>
        </trans-unit>
        <trans-unit id="1b0c7be81a38400e6eab6ae6602316f1c9727b89" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Tablet; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla/5.0 (タブレット;rv:26.0)Gecko/26.0 Firefox/26.0</target>
        </trans-unit>
        <trans-unit id="d5494fe16df11ab5f5d2c945da5478c2861a6327" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT 5.2; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (Windows NT 5.2;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="c103c7575720327d828e07fcd68a2f214656eb84" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; WOW64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Windows NTは&lt;em&gt;xは&lt;/em&gt;。&lt;em&gt;Y&lt;/em&gt; ; WOW64; RV：10.0）のGecko / 20100101 Firefoxの/ 10.0</target>
        </trans-unit>
        <trans-unit id="e357311b1eddbb286305456c0cae57cb232b5c1f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; Win64; x64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Windows NTは&lt;em&gt;xは&lt;/em&gt;。&lt;em&gt;Y&lt;/em&gt;、Win64の、のx64; RV：10.0）のGecko / 20100101 Firefoxの/ 10.0</target>
        </trans-unit>
        <trans-unit id="325bb5b76845bcf2d6d17880f0df8de3120fa91b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0（Windows NTは、&lt;em&gt;xは&lt;/em&gt;。&lt;em&gt;Y&lt;/em&gt; ; RV：10.0）のGecko / 20100101 Firefoxの/ 10.0</target>
        </trans-unit>
        <trans-unit id="5530c08605b863c3ac834dac7f9e551adfc1e552" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686 on x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686 on x86_64;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="b117257c04f02d34e73001cfc8d0da1abaac01f8" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="fa04af9816f0793fdc1a867eef08c9bba4602d70" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla/5.0 (X11;Linux i686;rv:10.0.1)Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</target>
        </trans-unit>
        <trans-unit id="3d160a2e76c2d144bd854abad33abe579e0d1e79" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla/5.0 (X11;Linux x86_64;rv:10.0)Gecko/20100101 Firefox/10.0</target>
        </trans-unit>
        <trans-unit id="709cd7ecb895ccc0d811c9b3e76ade66b0e1f3aa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)</source>
          <target state="translated">Mozilla/5.0(互換性あり;MSIE 9.0;Windows Phone OS 7.5;Trident/5.0;IEMobile/9.0</target>
        </trans-unit>
        <trans-unit id="eb659b396a68f6ea514ab25964c9404e2397367b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPad; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPad; CPU iPhone OS 8_3 like Mac OS X）AppleWebKit / 600.1.4（KHTML、like Gecko）&lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="4e72c500d652c15de7cda1433b6379f4dfd1c6c4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPhone; CPU iPhone OS 8_3 like Mac OS X）AppleWebKit / 600.1.4（KHTML、like Gecko）&lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="f8a8856f3bffbe976e558e919bc886558bcab84f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPod touch; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0（iPod touch; Mac OS XのようなCPU iPhone OS 8_3）AppleWebKit / 600.1.4（GeckoのようなKHTML） &lt;strong&gt; FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="6c18301fd3a10882deaa39ee10288f7f929f1e77" translate="yes" xml:space="preserve">
          <source>Multipart ranges</source>
          <target state="translated">マルチパートレンジ</target>
        </trans-unit>
        <trans-unit id="6492593dec5dae0d0f4611760da5545108ace9bb" translate="yes" xml:space="preserve">
          <source>Multipart types</source>
          <target state="translated">マルチパートタイプ</target>
        </trans-unit>
        <trans-unit id="d39efeff869bd677fa96ec0c45b55ce64ce505cd" translate="yes" xml:space="preserve">
          <source>Multiple content security policies</source>
          <target state="translated">複数のコンテンツセキュリティポリシー</target>
        </trans-unit>
        <trans-unit id="313424e8960d9a8154e0f8c4d03334fd46afad67" translate="yes" xml:space="preserve">
          <source>Multiple headers</source>
          <target state="translated">複数のヘッダ</target>
        </trans-unit>
        <trans-unit id="bdca688fc4125e8ff0c8017144fee0ab18afe32f" translate="yes" xml:space="preserve">
          <source>Multiple language tags are separated by comma. Each language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character (&quot;&lt;code&gt;-&lt;/code&gt;&quot;, &lt;code&gt;%x2D&lt;/code&gt;). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., &quot;&lt;code&gt;en&lt;/code&gt;&quot; = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., &quot;&lt;code&gt;en-CA&lt;/code&gt;&quot; = the variety of English as communicated in Canada).</source>
          <target state="translated">複数の言語タグはコンマで区切られます。各言語タグは、それぞれがハイフン文字（ &quot; &lt;code&gt;-&lt;/code&gt; &quot;、 &lt;code&gt;%x2D&lt;/code&gt; ）で区切られた、1つ以上の大文字と小文字を区別しないサブタグのシーケンスです。ほとんどの場合、言語タグは、関連する言語の幅広いファミリを識別する一次言語サブタグ（例： &quot; &lt;code&gt;en&lt;/code&gt; &quot; =英語）で構成され、その後にオプションで、その言語の範囲を調整または狭める一連のサブタグ（例： 」 &lt;code&gt;en-CA&lt;/code&gt; 」=カナダで伝えられる英語の多様性）。</target>
        </trans-unit>
        <trans-unit id="b290c69355489b91460f7513bfaca4d5713cfa85" translate="yes" xml:space="preserve">
          <source>Musical Instrument Digital Interface (MIDI)</source>
          <target state="translated">楽器デジタルインターフェース(MIDI)</target>
        </trans-unit>
        <trans-unit id="38d7a0163e1ee433772d04a8bfb66c70abef1a41" translate="yes" xml:space="preserve">
          <source>Must contain</source>
          <target state="translated">含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="7eb2625cecaa68b91f751ad2fe9dc1b532d0b9b2" translate="yes" xml:space="preserve">
          <source>Must not contain</source>
          <target state="translated">を含んではいけません。</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="7fba45dc69034264a59f6cf73b586c39dab3f873" translate="yes" xml:space="preserve">
          <source>Name/alias of an internal proxy.</source>
          <target state="translated">内部プロキシの名前/エイリアス。</target>
        </trans-unit>
        <trans-unit id="fc0e8280e5c94d0883853c5c4b17f81c3e799bdf" translate="yes" xml:space="preserve">
          <source>Name:   activelock

   Purpose:   Describes a lock on a resource.


   &amp;lt;!ELEMENT activelock (lockscope, locktype, depth, owner?, timeout?,
             locktoken?, lockroot)&amp;gt;</source>
          <target state="translated">名前：activelock目的：リソースのロックについて説明します。&amp;lt;！ELEMENT activelock（lockscope、locktype、depth、owner ?, timeout ?, locktoken ?, lockroot）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7309308604381e0eab9cfba61516e4469cbce658" translate="yes" xml:space="preserve">
          <source>Name:   allprop

   Purpose:   Specifies that all names and values of dead properties and
      the live properties defined by this document existing on the
      resource are to be returned.

   &amp;lt;!ELEMENT allprop EMPTY &amp;gt;</source>
          <target state="translated">名前：allprop目的：リソース上に存在するこのドキュメントで定義されているデッドプロパティとライブプロパティのすべての名前と値が返されることを指定します。&amp;lt;！ELEMENT allprop EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ba1c5dfdf3f6b036dcf6b3dcedf50ec6b5d7aa0" translate="yes" xml:space="preserve">
          <source>Name:   collection

   Purpose:   Identifies the associated resource as a collection.  The
      DAV:resourcetype property of a collection resource MUST contain
      this element.  It is normally empty but extensions may add sub-
      elements.

   &amp;lt;!ELEMENT collection EMPTY &amp;gt;</source>
          <target state="translated">名前：コレクション目的：関連するリソースをコレクションとして識別します。コレクションリソースのDAV：resourcetypeプロパティには、この要素を含める必要があります。通常は空ですが、拡張機能によってサブ要素が追加される場合があります。&amp;lt;！ELEMENTコレクションEMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="87181b0cf2e6abfd8e3d27cf6a43721cccb1a786" translate="yes" xml:space="preserve">
          <source>Name:   creationdate

   Purpose:   Records the time and date the resource was created.

   Value:   date-time (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt;], see the ABNF in &lt;a href=&quot;#section-5.6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt;.)

   Protected:   MAY be protected.  Some servers allow DAV:creationdate
      to be changed to reflect the time the document was created if that
      is more meaningful to the user (rather than the time it was
      uploaded).  Thus, clients SHOULD NOT use this property in
      synchronization logic (use DAV:getetag instead).

   COPY/MOVE behavior:   This property value SHOULD be kept during a
      MOVE operation, but is normally re-initialized when a resource is
      created with a COPY.  It should not be set in a COPY. 

   Description:   The DAV:creationdate property SHOULD be defined on all
      DAV compliant resources.  If present, it contains a timestamp of
      the moment when the resource was created.  Servers that are
      incapable of persistently recording the creation date SHOULD
      instead leave it undefined (i.e. report &quot;Not Found&quot;).

   &amp;lt;!ELEMENT creationdate (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：creationdate目的：リソースが作成された日時を記録します。値：日時（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt; ]で定義されています。&lt;a href=&quot;#section-5.6&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6の&lt;/a&gt;。）保護：保護される場合があります。一部のサーバーでは、DAV：creationdateを変更して、ドキュメントが作成された時刻（ユーザーがアップロードした時刻ではなく）の方が意味がある場合は、それを反映することができます。したがって、クライアントは同期ロジックでこのプロパティを使用しないでください（代わりにDAV：getetagを使用してください）。 COPY / MOVE動作：このプロパティ値はMOVE操作中に保持する必要があります（SHOULD）が、通常、COPYを使用してリソースが作成されると、再初期化されます。 COPYでは設定しないでください。説明：DAV：creationdateプロパティは、すべてのDAV準拠リソースで定義する必要があります（SHOULD）。存在する場合は、リソースが作成されたときのタイムスタンプが含まれます。作成日を永続的に記録できないサーバーは、未定義のままにする必要があります（つまり、レポート「見つかりませんでした」）。 &amp;lt;！ELEMENT作成日（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5001a824af50b50969330b6c455279fcb16d4902" translate="yes" xml:space="preserve">
          <source>Name:   depth

   Purpose:   Used for representing depth values in XML content (e.g.,
      in lock information).

   Value:   &quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;

   &amp;lt;!ELEMENT depth (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：深さ目的：XMLコンテンツ（たとえば、ロック情報）で深さの値を表すために使用されます。値： &quot;0&quot; | 「1」| &quot;無限大&quot; &amp;lt;！ELEMENT深さ（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7e7ea482bed86ee2dc49b17649f3cd7cddfe06a" translate="yes" xml:space="preserve">
          <source>Name:   displayname

   Purpose:   Provides a name for the resource that is suitable for
      presentation to a user.

   Value:   Any text.

   Protected:   SHOULD NOT be protected.  Note that servers implementing
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have made this a protected property as this is a
      new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   Contains a description of the resource that is
      suitable for presentation to a user.  This property is defined on
      the resource, and hence SHOULD have the same value independent of
      the Request-URI used to retrieve it (thus, computing this property
      based on the Request-URI is deprecated).  While generic clients
      might display the property value to end users, client UI designers
      must understand that the method for identifying resources is still
      the URL.  Changes to DAV:displayname do not issue moves or copies
      to the server, but simply change a piece of meta-data on the
      individual resource.  Two resources can have the same DAV:
      displayname value even within the same collection.

   &amp;lt;!ELEMENT displayname (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：displayname目的：ユーザーへの表示に適したリソースの名前を提供します。値：任意のテキスト。保護される：保護されるべきではない。サーバーは[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;]これは新しい要件であるため、これを保護プロパティにした可能性があります。 COPY / MOVE動作：このプロパティ値は、COPYおよびMOVE操作で保持する必要があります（SHOULD）。説明：ユーザーへの表示に適したリソースの説明が含まれます。このプロパティはリソースで定義されるため、それを取得するために使用されるRequest-URIとは無関係に同じ値を持つ必要があります（したがって、Request-URIに基づいてこのプロパティを計算することは非推奨です）。汎用クライアントはプロパティ値をエンドユーザーに表示する場合がありますが、クライアントUIの設計者は、リソースを識別するためのメソッドが依然としてURLであることを理解する必要があります。 DAV：displaynameを変更しても、サーバーへの移動やコピーは行われず、個々のリソースのメタデータが変更されるだけです。2つのリソースは、同じコレクション内でも同じDAV：displayname値を持つことができます。 &amp;lt;！ELEMENT表示名（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="908d0146c1dea86489e704e923e0d7a5ee16a7b9" translate="yes" xml:space="preserve">
          <source>Name:   error

   Purpose:   Error responses, particularly 403 Forbidden and 409
      Conflict, sometimes need more information to indicate what went
      wrong.  In these cases, servers MAY return an XML response body
      with a document element of 'error', containing child elements
      identifying particular condition codes.

   Description:   Contains at least one XML element, and MUST NOT
      contain text or mixed content.  Any element that is a child of the
      'error' element is considered to be a precondition or
      postcondition code.  Unrecognized elements MUST be ignored.

   &amp;lt;!ELEMENT error ANY &amp;gt;</source>
          <target state="translated">名前：エラー目的：エラー応答、特に403 Forbiddenと409 Conflictは、何が問題だったかを示すために、詳細情報が必要になる場合があります。これらの場合、サーバーは、特定の条件コードを識別する子要素を含む、「エラー」のドキュメント要素を持つXML応答本文を返す場合があります。説明：少なくとも1つのXML要素を含み、テキストまたは混合コンテンツを含むことはできません。「エラー」要素の子である要素は、前提条件または事後条件コードと見なされます。認識されない要素は無視する必要があります。&amp;lt;！ELEMENT error ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2f1ac95ad14a19297b93321befb3877e2c61a0da" translate="yes" xml:space="preserve">
          <source>Name:   exclusive

   Purpose:   Specifies an exclusive lock.


   &amp;lt;!ELEMENT exclusive EMPTY &amp;gt;</source>
          <target state="translated">名前：排他的目的：排他的ロックを指定します。&amp;lt;！ELEMENT排他的空&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1139af3688a412e172379a1792bf370d7f0f7b0c" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlanguage

   Purpose:   Contains the Content-Language header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;14.12 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without
      accept headers.

   Value:   language-tag (language-tag is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;Section&amp;nbsp;3.10 of
      [RFC2616]&lt;/a&gt;) 

   Protected:   SHOULD NOT be protected, so that clients can reset the
      language.  Note that servers implementing [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have
      made this a protected property as this is a new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   The DAV:getcontentlanguage property MUST be defined on
      any DAV-compliant resource that returns the Content-Language
      header on a GET.

   &amp;lt;!ELEMENT getcontentlanguage (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：getcontentlanguage目的：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;Accept-&lt;/a&gt;ヘッダーなしでGETによって返されるため、Content-Languageヘッダー値（[RFC2616]の&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;セクション&lt;/a&gt;14.12から）が含まれます。値：言語タグ（言語タグは&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;[RFC2616]のセクション3.10で&lt;/a&gt;定義されています）保護：クライアントが言語をリセットできるように、保護しないでください。サーバーは[&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt; RFC2518&lt;/a&gt;]これは新しい要件であるため、これを保護プロパティにした可能性があります。 COPY / MOVE動作：このプロパティ値は、COPYおよびMOVE操作で保持する必要があります（SHOULD）。説明：DAV：getcontentlanguageプロパティは、GETでContent-Languageヘッダーを返すDAV準拠リソースで定義する必要があります。 &amp;lt;！ELEMENT getcontentlanguage（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="741fdc043a5b70d84410dff935be0a476ea27e62" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlength

   Purpose:   Contains the Content-Length header returned by a GET
      without accept headers.

   Value:   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;Section&amp;nbsp;14.13 of [RFC2616]&lt;/a&gt;.

   Protected:   This property is computed, therefore protected.

   Description:   The DAV:getcontentlength property MUST be defined on
      any DAV-compliant resource that returns the Content-Length header
      in response to a GET.

   COPY/MOVE behavior:   This property value is dependent on the size of
      the destination resource, not the value of the property on the
      source resource.

   &amp;lt;!ELEMENT getcontentlength (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：getcontentlength目的：AcceptヘッダーなしでGETによって返されるContent-Lengthヘッダーが含まれます。値：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;[RFC2616]のセクション14.13を&lt;/a&gt;参照してください。保護：このプロパティは計算されるため、保護されます。説明：DAV：getcontentlengthプロパティは、GETに応答してContent-Lengthヘッダーを返すDAV準拠リソースで定義する必要があります。コピー/移動の動作：このプロパティ値は、ソースリソースのプロパティの値ではなく、宛先リソースのサイズに依存します。 &amp;lt;！ELEMENT getcontentlength（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="55495eb7b11d239e680b68a767ce90c04bf9b3b4" translate="yes" xml:space="preserve">
          <source>Name:   getcontenttype

   Purpose:   Contains the Content-Type header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;Section&amp;nbsp;14.17
      of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   media-type (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;Section&amp;nbsp;3.7 of [RFC2616]&lt;/a&gt;)

   Protected:   Potentially protected if the server prefers to assign
      content types on its own (see also discussion in &lt;a href=&quot;#section-9.7.1&quot;&gt;Section 9.7.1&lt;/a&gt;). 

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   This property MUST be defined on any DAV-compliant
      resource that returns the Content-Type header in response to a
      GET.

   &amp;lt;!ELEMENT getcontenttype (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：getcontenttype目的：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;Accept&lt;/a&gt; -Header なしのGETによって返されるContent-Typeヘッダー値（[RFC2616]のセクション14.17から）が含まれます。値：メディアタイプ（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;[RFC2616]のセクション3.7で&lt;/a&gt;定義）保護：サーバーが独自にコンテンツタイプを割り当てることを希望する場合、潜在的に保護されます（&lt;a href=&quot;#section-9.7.1&quot;&gt;セクション9.7.1の&lt;/a&gt;説明も参照）。 COPY / MOVE動作：このプロパティ値は、COPYおよびMOVE操作で保持する必要があります（SHOULD）。説明：このプロパティは、GETに応答してContent-Typeヘッダーを返すDAV準拠リソースで定義する必要があります。 &amp;lt;！ELEMENT getcontenttype（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1498b05efb25d9004f005f650420e0059a4a660f" translate="yes" xml:space="preserve">
          <source>Name:   getetag

   Purpose:   Contains the ETag header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;Section&amp;nbsp;14.19 of
      [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   entity-tag (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;)

   Protected:  MUST be protected because this value is created and
      controlled by the server.

   COPY/MOVE behavior:   This property value is dependent on the final
      state of the destination resource, not the value of the property
      on the source resource.  Also note the considerations in
      &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The getetag property MUST be defined on any DAV-
      compliant resource that returns the Etag header.  Refer to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;3.11 of RFC 2616&lt;/a&gt; for a complete definition of the semantics of an
      ETag, and to &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt; for a discussion of ETags in WebDAV.

   &amp;lt;!ELEMENT getetag (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：getetag目的：Accept ヘッダーなしでGETによって返されるETagヘッダー値（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;[RFC2616]のセクション14.19&lt;/a&gt;から）が含まれます。値：entity-tag（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]のセクション3.11で&lt;/a&gt;定義）保護：この値はサーバーによって作成および制御されるため、保護する必要があります。コピー/移動の動作：このプロパティ値は、ソースリソースのプロパティの値ではなく、宛先リソースの最終状態に依存します。&lt;a href=&quot;#section-8.8&quot;&gt;セクション8.8&lt;/a&gt;の考慮事項にも注意してください 。説明：getetagプロパティは、Etagヘッダーを返すDAV準拠のリソースで定義する必要があります。&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;RFC 2616の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;セクション&lt;/a&gt;3.11を参照してくださいETagのセマンティクスの完全な定義については、およびWebDAV でのETag の説明については&lt;a href=&quot;#section-8.6&quot;&gt;セクション8.6&lt;/a&gt;を参照してください。&amp;lt;！ELEMENT getetag（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="11ad3ec496de5f06b2c28a5d5dd7a81ca07caa74" translate="yes" xml:space="preserve">
          <source>Name:   getlastmodified

   Purpose:   Contains the Last-Modified header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;14.29 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET method
      without accept headers.

   Value:   &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC2616]&lt;/a&gt;)

   Protected:   SHOULD be protected because some clients may rely on the
      value for appropriate caching behavior, or on the value of the
      Last-Modified header to which this property is linked. 

   COPY/MOVE behavior:   This property value is dependent on the last
      modified date of the destination resource, not the value of the
      property on the source resource.  Note that some server
      implementations use the file system date modified value for the
      DAV:getlastmodified value, and this can be preserved in a MOVE
      even when the HTTP Last-Modified value SHOULD change.  Note that
      since [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] requires clients to use ETags where provided, a
      server implementing ETags can count on clients using a much better
      mechanism than modification dates for offline synchronization or
      cache control.  Also note the considerations in &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The last-modified date on a resource SHOULD only
      reflect changes in the body (the GET responses) of the resource.
      A change in a property only SHOULD NOT cause the last-modified
      date to change, because clients MAY rely on the last-modified date
      to know when to overwrite the existing body.  The DAV:
      getlastmodified property MUST be defined on any DAV-compliant
      resource that returns the Last-Modified header in response to a
      GET.

   &amp;lt;!ELEMENT getlastmodified (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：getlastmodified目的：Accept-Header なしのGETメソッドによって返されるため、Last-Modifiedヘッダー値（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;[RFC2616]の&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;セクション&lt;/a&gt;14.29から）が含まれます。値： &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;[RFC2616]のセクション3.3.1で&lt;/a&gt;定義））保護：一部のクライアントは、適切なキャッシュ動作の値、またはこのプロパティがリンクされているLast-Modifiedヘッダーの値に依存している可能性があるため、保護する必要があります。コピー/移動の動作：このプロパティ値は、ソースリソースのプロパティの値ではなく、宛先リソースの最終変更日に依存します。一部のサーバー実装では、DAV：getlastmodified値にファイルシステムの日付変更値を使用します。これは、HTTP Last-Modified値が変更された場合でも、MOVEで保持できます。 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;以降]提供されている場合、クライアントはETagを使用する必要があります。ETagを実装するサーバーは、オフライン同期またはキャッシュ制御の変更日よりもはるかに優れたメカニズムを使用してクライアントを信頼できます。&lt;a href=&quot;#section-8.8&quot;&gt;セクション8.8&lt;/a&gt;の考慮事項にも注意してください。説明：リソースの最終変更日は、リソースの本文（GET応答）の変更のみを反映する必要があります（SHOULD）。プロパティの変更は、クライアントが最後に変更された日付に依存して既存の本文をいつ上書きするかを知ることができるため、最後に変更された日付を変更するだけである必要があります（SHOULD NOT）。 DAV：getlastmodifiedプロパティは、GETに応答してLast-Modifiedヘッダーを返すDAV準拠リソースで定義する必要があります。 &amp;lt;！ELEMENT getlastmodified（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="863060182a5c2848f88469f61b18814776f39625" translate="yes" xml:space="preserve">
          <source>Name:   href

   Purpose:   MUST contain a URI or a relative reference.

   Description:   There may be limits on the value of 'href' depending
      on the context of its use.  Refer to the specification text where
      'href' is used to see what limitations apply in each case.

   Value:   Simple-ref


   &amp;lt;!ELEMENT href (#PCDATA)&amp;gt;</source>
          <target state="translated">名前：href目的：URIまたは相対参照を含める必要があります。説明： 'href'の値は、その使用状況によって制限がある場合があります。それぞれの場合に適用される制限を確認するには、「href」が使用されている仕様テキストを参照してください。値：Simple-ref &amp;lt;！ELEMENT href（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="893dbb5e6ea2e164b3fe7cab59b462026c86e341" translate="yes" xml:space="preserve">
          <source>Name:   include

   Purpose:   Any child element represents the name of a property to be
      included in the PROPFIND response.  All elements inside an
      'include' XML element MUST define properties related to the
      resource, although possible property names are in no way limited
      to those property names defined in this document or other
      standards.  This element MUST NOT contain text or mixed content.

   &amp;lt;!ELEMENT include ANY &amp;gt;</source>
          <target state="translated">名前：include目的：すべての子要素は、PROPFIND応答に含まれるプロパティの名前を表します。'include' XML要素内のすべての要素は、リソースに関連するプロパティを定義する必要があります。ただし、可能なプロパティ名は、このドキュメントまたは他の標準で定義されているプロパティ名に決して限定されません。この要素にテキストまたは混合コンテンツを含めることはできません。&amp;lt;！ELEMENT include ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6c0d5c7c18f7351f5e5ec4a0e565194906f570e3" translate="yes" xml:space="preserve">
          <source>Name:   location

   Purpose:   HTTP defines the &quot;Location&quot; header (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-14.30&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;) for use with some status codes (such as 201 and the 300
      series codes).  When these codes are used inside a 'multistatus'
      element, the 'location' element can be used to provide the
      accompanying Location header value. 

   Description:   Contains a single href element with the same value
      that would be used in a Location header.


   &amp;lt;!ELEMENT location (href)&amp;gt;</source>
          <target state="translated">名前：位置目的：HTTPは、いくつかのステータスコード（201や300シリーズコードなど）で使用するための「位置」ヘッダー（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、&lt;a href=&quot;#section-14.30&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;14.30を&lt;/a&gt;参照）を定義します。これらのコードが「multistatus」要素内で使用される場合、「location」要素を使用して、付随するLocationヘッダー値を提供できます。説明：Locationヘッダーで使用されるのと同じ値を持つ単一のhref要素が含まれます。 &amp;lt;！ELEMENTの場所（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="611ed05ab7ed30cc8633acf614bc5f74d180e99e" translate="yes" xml:space="preserve">
          <source>Name:   lockdiscovery

   Purpose:   Describes the active locks on a resource

   Protected:   MUST be protected.  Clients change the list of locks
      through LOCK and UNLOCK, not through PROPPATCH.

   COPY/MOVE behavior:   The value of this property depends on the lock
      state of the destination, not on the locks of the source resource.
      Recall that locks are not moved in a MOVE operation.

   Description:   Returns a listing of who has a lock, what type of lock
      he has, the timeout type and the time remaining on the timeout,
      and the associated lock token.  Owner information MAY be omitted
      if it is considered sensitive.  If there are no locks, but the
      server supports locks, the property will be present but contain
      zero 'activelock' elements.  If there are one or more locks, an
      'activelock' element appears for each lock on the resource.  This
      property is NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT lockdiscovery (activelock)* &amp;gt;</source>
          <target state="translated">名前：lockdiscovery目的：リソースのアクティブなロックについて説明します保護：保護する必要があります。クライアントは、PROPPATCHではなく、LOCKおよびUNLOCKを使用してロックのリストを変更します。 COPY / MOVE動作：このプロパティの値は、ソースリソースのロックではなく、宛先のロック状態に依存します。 MOVE操作ではロックは移動されないことを思い出してください。説明：ロックを持っているユーザー、ロックのタイプ、タイムアウトのタイプとタイムアウトの残り時間、および関連するロックトークンのリストを返します。機密情報と見なされる場合は、所有者情報を省略できます。ロックはないがサーバーがロックをサポートしている場合、プロパティは存在しますが、「activelock」要素は含まれません。 1つ以上のロックがある場合、 'リソースのロックごとにactivelock '要素が表示されます。このプロパティは、書き込みロックに関してロックできません（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）。&amp;lt;！ELEMENT lockdiscovery（activelock）*&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c16989808c9336197d43ba1941662e1c595ca03" translate="yes" xml:space="preserve">
          <source>Name:   lockentry

   Purpose:   Defines the types of locks that can be used with the
      resource.

   &amp;lt;!ELEMENT lockentry (lockscope, locktype) &amp;gt;</source>
          <target state="translated">名前：lockentry目的：リソースで使用できるロックのタイプを定義します。&amp;lt;！ELEMENT lockentry（lockscope、locktype）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5083904af81384e6886493a202104354cd3f8853" translate="yes" xml:space="preserve">
          <source>Name:   lockinfo

   Purpose:   The 'lockinfo' XML element is used with a LOCK method to
      specify the type of lock the client wishes to have created.


   &amp;lt;!ELEMENT lockinfo (lockscope, locktype, owner?)  &amp;gt;</source>
          <target state="translated">名前：lockinfo目的： 'lockinfo' XML要素はLOCKメソッドと共に使用され、クライアントが作成したいロックのタイプを指定します。&amp;lt;！ELEMENT lockinfo（lockscope、locktype、owner？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="852a23c678d8306e5d8708150d7c2bf16c39adbc" translate="yes" xml:space="preserve">
          <source>Name:   lockroot

   Purpose:   Contains the root URL of the lock, which is the URL
      through which the resource was addressed in the LOCK request.

   Description:   The href element contains the root of the lock.  The
      server SHOULD include this in all DAV:lockdiscovery property
      values and the response to LOCK requests.

   &amp;lt;!ELEMENT lockroot (href) &amp;gt;</source>
          <target state="translated">名前：lockroot目的：ロックのルートURLが含まれます。これは、LOCKリクエストでリソースがアドレス指定されたURLです。説明：href要素には、ロックのルートが含まれています。サーバーは、これをすべてのDAV：lockdiscoveryプロパティ値とLOCK要求への応答に含める必要があります（SHOULD）。&amp;lt;！ELEMENT lockroot（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="00e11eedce57a66ee497b17831a568c69036832c" translate="yes" xml:space="preserve">
          <source>Name:   lockscope

   Purpose:   Specifies whether a lock is an exclusive lock, or a shared
      lock.


     &amp;lt;!ELEMENT lockscope (exclusive | shared) &amp;gt;</source>
          <target state="translated">名前：lockscope目的：ロックが排他ロックであるか共有ロックであるかを指定します。&amp;lt;！ELEMENT lockscope（exclusive | shared）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82de61827789e036e8393a1e1b328cd94701a6ea" translate="yes" xml:space="preserve">
          <source>Name:   locktoken

   Purpose:   The lock token associated with a lock.

   Description:   The href contains a single lock token URI, which
      refers to the lock.

   &amp;lt;!ELEMENT locktoken (href) &amp;gt;</source>
          <target state="translated">名前：locktoken目的：ロックに関連付けられたロックトークン。説明：hrefには、ロックを参照する単一のロックトークンURIが含まれています。&amp;lt;！ELEMENT locktoken（href）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="598c85ffd24685cdfcbe4799404f4c9aeaa83551" translate="yes" xml:space="preserve">
          <source>Name:   locktype

   Purpose:   Specifies the access type of a lock.  At present, this
      specification only defines one lock type, the write lock.


   &amp;lt;!ELEMENT locktype (write) &amp;gt;</source>
          <target state="translated">名前：locktype目的：ロックのアクセスタイプを指定します。現時点では、この仕様は1つのロックタイプ、書き込みロックのみを定義しています。&amp;lt;！ELEMENTロックタイプ（書き込み）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e05fdca8059417af4c532004b86578fb46a8667c" translate="yes" xml:space="preserve">
          <source>Name:   multistatus

   Purpose:   Contains multiple response messages.

   Description:   The 'responsedescription' element at the top level is
      used to provide a general message describing the overarching
      nature of the response.  If this value is available, an
      application may use it instead of presenting the individual
      response descriptions contained within the responses.


   &amp;lt;!ELEMENT multistatus (response*, responsedescription?)  &amp;gt;</source>
          <target state="translated">名前：multistatus目的：複数の応答メッセージが含まれます。説明：トップレベルの 'responsedescription'要素は、応答の包括的な性質を説明する一般的なメッセージを提供するために使用されます。この値が使用可能な場合、アプリケーションは、応答に含まれる個々の応答の説明を提示する代わりに、この値を使用できます。 &amp;lt;！ELEMENT multistatus（response *、responsedescription？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e7255f62e0866a1ff69ffde8c78451b0557e060" translate="yes" xml:space="preserve">
          <source>Name:   owner

   Purpose:   Holds client-supplied information about the creator of a
      lock.

   Description:   Allows a client to provide information sufficient for
      either directly contacting a principal (such as a telephone number
      or Email URI), or for discovering the principal (such as the URL 

      of a homepage) who created a lock.  The value provided MUST be
      treated as a dead property in terms of XML Information Item
      preservation.  The server MUST NOT alter the value unless the
      owner value provided by the client is empty.  For a certain amount
      of interoperability between different client implementations, if
      clients have URI-formatted contact information for the lock
      creator suitable for user display, then clients SHOULD put those
      URIs in 'href' child elements of the 'owner' element.

   Extensibility:   MAY be extended with child elements, mixed content,
      text content or attributes.

   &amp;lt;!ELEMENT owner ANY &amp;gt;</source>
          <target state="translated">名前：所有者目的：ロックの作成者に関するクライアント提供の情報を保持します。説明：クライアントは、プリンシパル（電話番号や電子メールURIなど）に直接連絡したり、ロックを作成したプリンシパル（ホームページのURLなど）を発見したりするのに十分な情報を提供できます。提供された値は、XML情報アイテムの保存に関してデッドプロパティとして扱われる必要があります。クライアントから提供された所有者の値が空でない限り、サーバーは値を変更してはなりません（MUST NOT）。異なるクライアント実装間のある程度の相互運用性のために、クライアントがユーザーの表示に適したロック作成者のURI形式の連絡先情報を持っている場合、クライアントはそれらのURIを「所有者の要素。拡張性：子要素、混合コンテンツ、テキストコンテンツまたは属性で拡張できます。 &amp;lt;！ELEMENTオーナーANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a4e49012d04e6acebeb0c6719ce7d291a7d9aa8" translate="yes" xml:space="preserve">
          <source>Name:   prop

   Purpose:   Contains properties related to a resource.

   Description:   A generic container for properties defined on
      resources.  All elements inside a 'prop' XML element MUST define
      properties related to the resource, although possible property
      names are in no way limited to those property names defined in
      this document or other standards.  This element MUST NOT contain
      text or mixed content.

   &amp;lt;!ELEMENT prop ANY &amp;gt;</source>
          <target state="translated">名前：prop目的：リソースに関連するプロパティを含みます。説明：リソースで定義されたプロパティの汎用コンテナ。'prop' XML要素内のすべての要素は、リソースに関連するプロパティを定義する必要がありますが、可能なプロパティ名は、このドキュメントまたは他の標準で定義されているプロパティ名に決して限定されません。この要素にテキストまたは混合コンテンツを含めることはできません。&amp;lt;！ELEMENTプロップANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a17076c9f6d61a5ed9b6362d78be28ae87fb3ec" translate="yes" xml:space="preserve">
          <source>Name:   propertyupdate

   Purpose:   Contains a request to alter the properties on a resource.

   Description:   This XML element is a container for the information
      required to modify the properties on the resource.

   &amp;lt;!ELEMENT propertyupdate (remove | set)+ &amp;gt;</source>
          <target state="translated">名前：propertyupdate目的：リソースのプロパティを変更する要求が含まれています。説明：このXML要素は、リソースのプロパティを変更するために必要な情報のコンテナです。&amp;lt;！ELEMENT propertyupdate（remove | set）+&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f033076f90b712249c25c9cf538723f50fb05452" translate="yes" xml:space="preserve">
          <source>Name:   propfind 

   Purpose:   Specifies the properties to be returned from a PROPFIND
      method.  Four special elements are specified for use with
      'propfind': 'prop', 'allprop', 'include', and 'propname'.  If
      'prop' is used inside 'propfind', it MUST NOT contain property
      values.

   &amp;lt;!ELEMENT propfind ( propname | (allprop, include?) | prop ) &amp;gt;</source>
          <target state="translated">名前：propfind目的：PROPFINDメソッドから返されるプロパティを指定します。「propfind」で使用するために、「prop」、「allprop」、「include」、および「propname」の4つの特別な要素が指定されています。'prop'が 'propfind'内で使用される場合、プロパティ値を含めることはできません。&amp;lt;！ELEMENT propfind（propname |（allprop、include？）| prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b132fa457cc7b2c94116ac2aad40a7507857d840" translate="yes" xml:space="preserve">
          <source>Name:   propname

   Purpose:   Specifies that only a list of property names on the
      resource is to be returned.

   &amp;lt;!ELEMENT propname EMPTY &amp;gt;</source>
          <target state="translated">名前：propname目的：リソースのプロパティ名のリストのみが返されることを指定します。&amp;lt;！ELEMENT propname EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb18d77861af3bb5b094ee60954452e584d7dbd8" translate="yes" xml:space="preserve">
          <source>Name:   propstat

   Purpose:   Groups together a prop and status element that is
      associated with a particular 'href' element.

   Description:   The propstat XML element MUST contain one prop XML
      element and one status XML element.  The contents of the prop XML
      element MUST only list the names of properties to which the result
      in the status element applies.  The optional precondition/
      postcondition element and 'responsedescription' text also apply to
      the properties named in 'prop'.

   &amp;lt;!ELEMENT propstat (prop, status, error?, responsedescription?) &amp;gt;</source>
          <target state="translated">名前：propstat目的：特定の 'href'要素に関連付けられているpropとstatus要素をグループ化します。説明：propstat XML要素には、1つのprop XML要素と1つのステータスXML要素が含まれている必要があります。 prop XML要素のコンテンツは、status要素の結果が適用されるプロパティの名前のみをリストする必要があります。オプションの前提条件/事後条件要素と「応答説明」テキストは、「プロパティ」で指定されたプロパティにも適用されます。 &amp;lt;！ELEMENT propstat（prop、status、error ?, responsedescription？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="54b0bd4bd32a031047ae1be302a66b6e6c5b1f5b" translate="yes" xml:space="preserve">
          <source>Name:   remove

   Purpose:   Lists the properties to be removed from a resource.

   Description:   Remove instructs that the properties specified in prop
      should be removed.  Specifying the removal of a property that does
      not exist is not an error.  All the XML elements in a 'prop' XML
      element inside of a 'remove' XML element MUST be empty, as only
      the names of properties to be removed are required.

   &amp;lt;!ELEMENT remove (prop) &amp;gt;</source>
          <target state="translated">名前：削除目的：リソースから削除するプロパティを一覧表示します。説明：Removeは、propで指定されたプロパティを削除するように指示します。存在しないプロパティの削除を指定してもエラーにはなりません。削除するプロパティの名前のみが必要なため、「remove」XML要素内の「prop」XML要素内のすべてのXML要素は空でなければなりません。 &amp;lt;！ELEMENT remove（prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bf23482b4d15a7ccf582eb373f0c59dfd927c56a" translate="yes" xml:space="preserve">
          <source>Name:   resourcetype

   Purpose:   Specifies the nature of the resource.

   Protected:   SHOULD be protected.  Resource type is generally decided
      through the operation creating the resource (MKCOL vs PUT), not by
      PROPPATCH.

   COPY/MOVE behavior:   Generally a COPY/MOVE of a resource results in
      the same type of resource at the destination.

   Description:   MUST be defined on all DAV-compliant resources.  Each
      child element identifies a specific type the resource belongs to,
      such as 'collection', which is the only resource type defined by
      this specification (see &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;).  If the element contains
      the 'collection' child element plus additional unrecognized
      elements, it should generally be treated as a collection.  If the
      element contains no recognized child elements, it should be
      treated as a non-collection resource.  The default value is empty.
      This element MUST NOT contain text or mixed content.  Any custom
      child element is considered to be an identifier for a resource
      type.

   Example: (fictional example to show extensibility)

       &amp;lt;x:resourcetype xmlns:x=&quot;DAV:&quot;&amp;gt;
           &amp;lt;x:collection/&amp;gt;
           &amp;lt;f:search-results xmlns:f=&quot;http://www.example.com/ns&quot;/&amp;gt;
       &amp;lt;/x:resourcetype&amp;gt;</source>
          <target state="translated">名前：resourcetype目的：リソースの性質を指定します。保護：保護する必要があります。リソースタイプは、通常、PROPPATCHではなく、リソースを作成する操作（MKCOLとPUT）によって決定されます。 COPY / MOVE動作：通常、リソースのCOPY / MOVEは、宛先で同じタイプのリソースになります。説明：すべてのDAV準拠リソースで定義する必要があります。各子要素は、この仕様で定義されている唯一のリソースタイプである「コレクション」など、リソースが属する特定のタイプを識別します（&lt;a href=&quot;#section-14.3&quot;&gt;セクション14.3を&lt;/a&gt;参照）。）。要素に「コレクション」の子要素と追加の認識されない要素が含まれている場合、通常はコレクションとして扱う必要があります。要素に認識された子要素が含まれていない場合は、非コレクションリソースとして扱う必要があります。デフォルト値は空です。この要素にテキストまたは混合コンテンツを含めることはできません。カスタムの子要素は、リソースタイプの識別子と見なされます。例：（拡張性を示す架空の例）&amp;lt;x：resourcetype xmlns：x = &quot;DAV：&quot;&amp;gt; &amp;lt;x：collection /&amp;gt; &amp;lt;f：search-results xmlns：f = &quot;http://www.example.com/ns &quot;/&amp;gt; &amp;lt;/ x：resourcetype&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba963fb29afc5c7063b3f544c4e233040e8f1dab" translate="yes" xml:space="preserve">
          <source>Name:   response

   Purpose:   Holds a single response describing the effect of a method
      on resource and/or its properties.

   Description:   The 'href' element contains an HTTP URL pointing to a
      WebDAV resource when used in the 'response' container.  A
      particular 'href' value MUST NOT appear more than once as the
      child of a 'response' XML element under a 'multistatus' XML
      element.  This requirement is necessary in order to keep
      processing costs for a response to linear time.  Essentially, this
      prevents having to search in order to group together all the
      responses by 'href'.  There are, however, no requirements
      regarding ordering based on 'href' values.  The optional
      precondition/postcondition element and 'responsedescription' text
      can provide additional information about this resource relative to
      the request or result.


   &amp;lt;!ELEMENT response (href, ((href*, status)|(propstat+)),
                       error?, responsedescription? , location?) &amp;gt;</source>
          <target state="translated">名前：応答目的：リソースおよび/またはそのプロパティに対するメソッドの影響を説明する単一の応答を保持します。説明：「href」要素には、「応答」コンテナで使用される場合、WebDAVリソースを指すHTTP URLが含まれます。特定の 'href'値は、 'multistatus' XML要素の下の 'response' XML要素の子として複数回出現してはなりません（MUST NOT）。この要件は、線形時間への応答の処理コストを維持するために必要です。基本的に、これにより、すべての応答を「href」でグループ化するために検索する必要がなくなります。ただし、「href」値に基づく順序付けに関する要件はありません。オプションの前提条件/事後条件要素と 'responsedescription 'テキストは、要求または結果に関連するこのリソースに関する追加情報を提供できます。 &amp;lt;！ELEMENT応答（href、（（href *、status）|（propstat +））、error ?, responsedescription？、location？）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e79aa3cfbb4886f68f0cdccf03d0aaa6df292652" translate="yes" xml:space="preserve">
          <source>Name:   responsedescription

   Purpose:   Contains information about a status response within a
      Multi-Status.

   Description:   Provides information suitable to be presented to a
      user.

   &amp;lt;!ELEMENT responsedescription (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：responsedescription目的：マルチステータス内のステータス応答に関する情報が含まれています。説明：ユーザーに提示するのに適した情報を提供します。 &amp;lt;！ELEMENT応答の説明（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="faf150c453c206be333d64c2eb169ece66eddf4f" translate="yes" xml:space="preserve">
          <source>Name:   set

   Purpose:   Lists the property values to be set for a resource.

   Description:   The 'set' element MUST contain only a 'prop' element.
      The elements contained by the 'prop' element inside the 'set'
      element MUST specify the name and value of properties that are set
      on the resource identified by Request-URI.  If a property already
      exists, then its value is replaced.  Language tagging information
      appearing in the scope of the 'prop' element (in the &quot;xml:lang&quot; 

      attribute, if present) MUST be persistently stored along with the
      property, and MUST be subsequently retrievable using PROPFIND.

   &amp;lt;!ELEMENT set (prop) &amp;gt;</source>
          <target state="translated">名前：set目的：リソースに設定されるプロパティ値を一覧表示します。説明：「set」要素には「prop」要素のみを含める必要があります。「set」要素内の「prop」要素に含まれる要素は、Request-URIで識別されるリソースに設定されるプロパティの名前と値を指定する必要があります。プロパティがすでに存在する場合、その値は置き換えられます。'prop'要素のスコープ（存在する場合は &quot;xml：lang&quot;属性内）に表示​​される言語タグ情報は、プロパティと共に永続的に保存する必要があり、PROPFINDを使用して後で取得できる必要があります。&amp;lt;！ELEMENTセット（prop）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="034ef0121821410e6799f280fbce98e61bb36fec" translate="yes" xml:space="preserve">
          <source>Name:   shared

   Purpose:   Specifies a shared lock.


   &amp;lt;!ELEMENT shared EMPTY &amp;gt;</source>
          <target state="translated">名前：共有目的：共有ロックを指定します。&amp;lt;！ELEMENT共有EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="89e2c86f49074c5456840897eea52e652dab08d2" translate="yes" xml:space="preserve">
          <source>Name:   status

   Purpose:   Holds a single HTTP status-line.

   Value:   status-line (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC2616]&lt;/a&gt;)

   &amp;lt;!ELEMENT status (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：status目的：単一のHTTPステータス行を保持します。値：status-line（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;[RFC2616]のセクション6.1で&lt;/a&gt;定義）！&amp;lt;！ELEMENT status（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6cd030e3b2b200c8abb49cd69f079bd0720dc672" translate="yes" xml:space="preserve">
          <source>Name:   supportedlock

   Purpose:   To provide a listing of the lock capabilities supported by
      the resource.

   Protected:   MUST be protected.  Servers, not clients, determine what
      lock mechanisms are supported. 

   COPY/MOVE behavior:   This property value is dependent on the kind of
      locks supported at the destination, not on the value of the
      property at the source resource.  Servers attempting to COPY to a
      destination should not attempt to set this property at the
      destination.

   Description:   Returns a listing of the combinations of scope and
      access types that may be specified in a lock request on the
      resource.  Note that the actual contents are themselves controlled
      by access controls, so a server is not required to provide
      information the client is not authorized to see.  This property is
      NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT supportedlock (lockentry)* &amp;gt;</source>
          <target state="translated">名前：supportedlock目的：リソースがサポートするロック機能のリストを提供します。保護：保護する必要があります。クライアントではなくサーバーが、サポートされるロックメカニズムを決定します。コピー/移動の動作：このプロパティ値は、ソースリソースでのプロパティの値ではなく、宛先でサポートされるロックの種類に依存します。宛先にコピーしようとするサーバーは、宛先でこのプロパティを設定しようとしないでください。説明：リソースのロックリクエストで指定できるスコープとアクセスタイプの組み合わせのリストを返します。実際のコンテンツ自体はアクセス制御によって制御されるため、サーバーがクライアントに表示を許可されていない情報を提供する必要はありません。このプロパティは、書き込みロックに関してロックできません（&lt;a href=&quot;#section-7&quot;&gt;セクション7&lt;/a&gt;）。&amp;lt;！ELEMENT supportedlock（lockentry）*&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35119527bc63f501789916897c0befe464dc6217" translate="yes" xml:space="preserve">
          <source>Name:   timeout

   Purpose:   The number of seconds remaining before a lock expires.

   Value:   TimeType (defined in &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)


      &amp;lt;!ELEMENT timeout (#PCDATA) &amp;gt;</source>
          <target state="translated">名前：タイムアウト目的：ロックが期限切れになるまでの残り秒数。値：TimeType（&lt;a href=&quot;#section-10.7&quot;&gt;セクション10.7で&lt;/a&gt;定義）&amp;lt;！ELEMENT timeout（#PCDATA）&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89a920056d92541b3e4aaafcac0f2c97ae89ad3" translate="yes" xml:space="preserve">
          <source>Name:   write

   Purpose:   Specifies a write lock.


   &amp;lt;!ELEMENT write EMPTY &amp;gt;</source>
          <target state="translated">名前：書き込み目的：書き込みロックを指定します。&amp;lt;！ELEMENT write EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef928101d810c7b294edc543143c4a9808fc0cd4" translate="yes" xml:space="preserve">
          <source>Navigate to the web site or web app in question and open the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;Developer Tools&lt;/a&gt;.</source>
          <target state="translated">問題のWebサイトまたはWebアプリに移動し、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;開発者ツール&lt;/a&gt;を開きます。</target>
        </trans-unit>
        <trans-unit id="24cfea67414a6051f8ef6f58e4703f34128176fb" translate="yes" xml:space="preserve">
          <source>Navigation directive</source>
          <target state="translated">ナビゲーション指令</target>
        </trans-unit>
        <trans-unit id="6cb820339644262483e0df69ef7b63b3ff7eb0cf" translate="yes" xml:space="preserve">
          <source>Navigation directives</source>
          <target state="translated">ナビゲーションディレクティブ</target>
        </trans-unit>
        <trans-unit id="3d7680d3ffd85eebd63677687a9aa06b50aefc80" translate="yes" xml:space="preserve">
          <source>Navigation directives govern to which location a user can navigate to or submit a form to, for example.</source>
          <target state="translated">ナビゲーションディレクティブは、ユーザがどの場所に移動したり、フォームを送信したりできるかを制御します。</target>
        </trans-unit>
        <trans-unit id="7d198c1bf717002743411eff6ca257f87f502017" translate="yes" xml:space="preserve">
          <source>Navigation to</source>
          <target state="translated">へのナビゲーション</target>
        </trans-unit>
        <trans-unit id="4fd5b390b406ef3a192cb33756658713f813cdd9" translate="yes" xml:space="preserve">
          <source>Navigational upgrades to third-party resources brings a significantly higher potential for breakage, these are not upgraded:</source>
          <target state="translated">サードパーティのリソースへのナビゲーションのアップグレードは、破損のためにかなり高い可能性をもたらし、これらはアップグレードされていません。</target>
        </trans-unit>
        <trans-unit id="1fd128a511cf81f2a11a5b15d991245ba541495b" translate="yes" xml:space="preserve">
          <source>Negotiating an HTTP version</source>
          <target state="translated">HTTP のバージョンを交渉する</target>
        </trans-unit>
        <trans-unit id="9359b43b3679ffebf30c6ff7f3222f0b6df7956c" translate="yes" xml:space="preserve">
          <source>Network Working Group                                      R. Fielding
Request for Comments: 2616                                   UC Irvine
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;                                              J. Gettys
Category: Standards Track                                   Compaq/W3C
                                                              J. Mogul
                                                                Compaq
                                                            H. Frystyk
                                                               W3C/MIT
                                                           L. Masinter
                                                                 Xerox
                                                              P. Leach
                                                             Microsoft
                                                        T. Berners-Lee
                                                               W3C/MIT
                                                             June 1999</source>
          <target state="translated">Network Working Group R. Fielding Request for Comments：2616 UC Irvine Obsoletes：&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; J. Gettysカテゴリー：標準化トラックCompaq / W3C J. Mogul Compaq H. Frystyk W3C / MIT L. Masinter Xerox P. Leach Microsoft T.バーナーズ・リーW3C / MIT 1999年6月</target>
        </trans-unit>
        <trans-unit id="5428bbcea03dea51ffb7eb6864dea642db9e9245" translate="yes" xml:space="preserve">
          <source>Network Working Group                                   J. Gregorio, Ed.
Request for Comments: 5023                                        Google
Category: Standards Track                                B. de hOra, Ed.
                                                         NewBay Software
                                                            October 2007</source>
          <target state="translated">ネットワーク・ワーキング・グループ J.グレゴリオ、Ed.コメントのための要求。5023 Google カテゴリ。標準トラック B.de hOra,Ed.NewBayソフトウェア 2007年10月</target>
        </trans-unit>
        <trans-unit id="4d8ae710cb99c4a7621dd240f2f410770ca46d77" translate="yes" xml:space="preserve">
          <source>Network Working Group                                  L. Dusseault, Ed.
Request for Comments: 4918                                   CommerceNet
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;                                                June 2007
Category: Standards Track</source>
          <target state="translated">ネットワークワーキンググループL. Dusseault、エド。コメントの要求：4918 CommerceNet廃止： 2007年6月&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;カテゴリー：標準化過程</target>
        </trans-unit>
        <trans-unit id="e3623b4b3820bb728eda2dde15946a4290819387" translate="yes" xml:space="preserve">
          <source>Network monitor</source>
          <target state="translated">ネットワークモニタ</target>
        </trans-unit>
        <trans-unit id="e50032eb35aad47bed9d5ff741f087c1986c82ba" translate="yes" xml:space="preserve">
          <source>Network operators sometimes require some authentication, acceptance of terms, or other user interaction before granting access (for example in an internet caf&amp;eacute; or at an airport). They often identify clients who have not done so using their Media Access Control (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MAC&quot;&gt;MAC&lt;/a&gt;) addresses.</source>
          <target state="translated">ネットワークオペレーターは、アクセスを許可する前に、認証、条件の受け入れ、またはその他のユーザー操作を必要とする場合があります（インターネットカフェや空港など）。多くの場合、メディアアクセス制御（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MAC&quot;&gt;MAC&lt;/a&gt;）アドレスを使用して、まだ行っていないクライアントを識別します。</target>
        </trans-unit>
        <trans-unit id="6b43fa182a48c949aed212293ef54b74e65782bb" translate="yes" xml:space="preserve">
          <source>Never assume that a browser or a rendering engine only runs on one type of device. Especially don't make different defaults for different browsers or rendering engines.</source>
          <target state="translated">ブラウザやレンダリングエンジンが特定のデバイスでしか動作しないと決めつけてはいけません。特に、ブラウザやレンダリングエンジンごとに異なるデフォルトを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="2ec7bc9b9c4ccaf3179748dcdf8d87e35784c21d" translate="yes" xml:space="preserve">
          <source>Never use the OS token to define if a browser is on mobile, tablet or desktop. The OS may run on more than one type of (for example, Android runs on tablets as well as phones).</source>
          <target state="translated">ブラウザがモバイル、タブレット、デスクトップのいずれにあるかを定義するために OS トークンを使用しないでください。OSは複数のタイプで動作する場合があります(例えば、Androidは電話だけでなくタブレットでも動作します)。</target>
        </trans-unit>
        <trans-unit id="9f77f8caaa3035ec127bade7a0545aa68e91b610" translate="yes" xml:space="preserve">
          <source>New cookies can also be created via JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, and if the &lt;code&gt;HttpOnly&lt;/code&gt; flag is not set, existing cookies can be accessed from JavaScript as well.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt;プロパティを使用してJavaScript経由で新しいCookieを作成することもできます &lt;code&gt;HttpOnly&lt;/code&gt; フラグが設定されていない場合、JavaScriptから既存のCookieにもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d5dfd3e32cc719743d36b551e2cc31f5efa09bb4" translate="yes" xml:space="preserve">
          <source>New definition; supplants &lt;a href=&quot;https://www.w3.org/TR/cors/&quot;&gt;W3C CORS&lt;/a&gt; specification.</source>
          <target state="translated">新しい定義。&lt;a href=&quot;https://www.w3.org/TR/cors/&quot;&gt;W3C CORS&lt;/a&gt;仕様に取って代わります。</target>
        </trans-unit>
        <trans-unit id="07349da357d41ca5084e50db9d4b1c35940a7768" translate="yes" xml:space="preserve">
          <source>New extension directives ought to consider defining:

   o  What it means for a directive to be specified multiple times,

   o  When the directive does not take an argument, what it means when
      an argument is present,

   o  When the directive requires an argument, what it means when it is
      missing,

   o  Whether the directive is specific to requests, responses, or able
      to be used in either.

   See also &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.</source>
          <target state="translated">新しい拡張ディレクティブでは、次の定義を検討する必要があります。oディレクティブを複数回指定することの意味oディレクティブが引数を取らない場合の意味、引数が存在する場合の意味oディレクティブに引数が必要な場合の意味欠落している場合を意味します。oディレクティブが要求、応答に固有であるか、またはいずれかで使用できるかどうか。&lt;a href=&quot;#section-5.2.3&quot;&gt;セクション5.2.3&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e03ab58c9bd12196de6bace27f6b044aff80f31c" translate="yes" xml:space="preserve">
          <source>New specifications MAY require that the &quot;type&quot; parameter be used to
   identify the Atom Document type.  Producers of Atom Entry Documents
   SHOULD use the &quot;type&quot; parameter regardless of whether or not it is
   mandatory.  Producers of Atom Feed Documents MAY use the parameter.

   Atom processors that do not recognize the &quot;type&quot; parameter MUST
   ignore its value and examine the root element to determine the
   document type.

   Atom processors that do recognize the &quot;type&quot; parameter SHOULD detect
   and report inconsistencies between the parameter's value and the
   actual type of the document's root element.</source>
          <target state="translated">新しい仕様では、「type」パラメータを使用して Atom ドキュメントのタイプを識別することを要求してもよい[MAY]。Atomエントリー文書の作成者は、必須かどうかにかかわらず、「type」パラメータを使用すべきである[SHOULD]。Atomフィードドキュメントの生成者は、このパラメータを使用してもよい[MAY]。type」パラメータを認識しない Atom プロセッサは、その値を無視し、ルート要素を検査して文書タイプを決定しなければならない[MUST]。type」パラメータを認識するAtomプロセッサは、パラメータの値とドキュメントのルート要素の実際のタイプとの間の不整合を検出して報告すべきである[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="a7b12052c0895e1742c7c3344db204110106e883" translate="yes" xml:space="preserve">
          <source>Next, you should configure your server to map the .pac filename extension to the MIME type.</source>
          <target state="translated">次に、.pac ファイル名の拡張子を MIME タイプにマップするようにサーバーを設定します。</target>
        </trans-unit>
        <trans-unit id="f2560cbce63028d4ce27fdd2ae2588b9ae69ca1e" translate="yes" xml:space="preserve">
          <source>Nginx</source>
          <target state="translated">Nginx</target>
        </trans-unit>
        <trans-unit id="cec384f7e83e464f4943c72ce6f108fdb5f1b9ed" translate="yes" xml:space="preserve">
          <source>Nginx configuration</source>
          <target state="translated">Nginx設定</target>
        </trans-unit>
        <trans-unit id="4f024b156ff549e7822c3e7d3365e8b43d1fb094" translate="yes" xml:space="preserve">
          <source>Nicholas Zakas article on cookies</source>
          <target state="translated">クッキーに関するニコラス・ザカスの記事</target>
        </trans-unit>
        <trans-unit id="d49005ff40f6342035c0b550381a16bf3992b810" translate="yes" xml:space="preserve">
          <source>Nicholas Zakas article on cookies and security</source>
          <target state="translated">クッキーとセキュリティに関するニコラスZakasの記事</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="2e029a8ccab5f30d2a37a9fb7c59617e13c16abc" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream&quot;&gt;&lt;code&gt;ReadableStream&lt;/code&gt;&lt;/a&gt; object is used in the request.</source>
          <target state="translated">リクエストでは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream&quot;&gt; &lt;code&gt;ReadableStream&lt;/code&gt; &lt;/a&gt;オブジェクトは使用されません。</target>
        </trans-unit>
        <trans-unit id="17a7d28f373846b5f71d72172ff5a2f4594ba504" translate="yes" xml:space="preserve">
          <source>No cache storage at all</source>
          <target state="translated">キャッシュストレージは一切なし</target>
        </trans-unit>
        <trans-unit id="c55e5b38338e0330c22fc379f2150b6de3dd84ba" translate="yes" xml:space="preserve">
          <source>No caching</source>
          <target state="translated">キャッシングなし</target>
        </trans-unit>
        <trans-unit id="9b1fcbda693f085c4d6d33acbf333e420ba23fca" translate="yes" xml:space="preserve">
          <source>No changes.</source>
          <target state="translated">変化はありません。</target>
        </trans-unit>
        <trans-unit id="d4c0e9228f3e84fb358ddccd2e00420664a85404" translate="yes" xml:space="preserve">
          <source>No common browsers send the &lt;code&gt;Expect&lt;/code&gt; header, but some other clients such as cURL do so by default.</source>
          <target state="translated">一般的なブラウザーは &lt;code&gt;Expect&lt;/code&gt; ヘッダーを送信しませんが、cURLなどの他のクライアントはデフォルトで送信します。</target>
        </trans-unit>
        <trans-unit id="cdd99c30977facc38dbb4433f72792cc98e7b957" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Alt-Svc&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">互換性データが見つかりません。&quot;http.headers.Alt-Svc&quot;（深さ：1）の&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;データをMDN互換性データリポジトリに&lt;/a&gt;投稿してください。</target>
        </trans-unit>
        <trans-unit id="0f9ea7be16970fe67508438505a3982b349d0124" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Feature-Policy.document-domain&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">互換性データが見つかりません。「http.headers.Feature-Policy.document-domain」（深さ：1）の&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;データをMDN互換性データリポジトリに&lt;/a&gt;投稿してください。</target>
        </trans-unit>
        <trans-unit id="087056739c3ab34d873287ef53ff57a465326155" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Sec-WebSocket-Accept&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">互換性データが見つかりません。「http.headers.Sec-WebSocket-Accept」（深さ：1）の&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;データをMDN互換性データリポジトリに&lt;/a&gt;投稿してください。</target>
        </trans-unit>
        <trans-unit id="b9d95fc0c4c68f783d6998d3d7b74901ffbf32e7" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.status.418&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">互換性データが見つかりません。&quot;http.status.418&quot;（深さ：1）の&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;データをMDN互換性データリポジトリに&lt;/a&gt;投稿してください。</target>
        </trans-unit>
        <trans-unit id="cbbe238f0711bff5f6e8bc80d9997d6930718ad5" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http/methods&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">互換性データが見つかりません。&quot;http / methods&quot;（深さ：1）の&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;データをMDN互換性データリポジトリに&lt;/a&gt;投稿してください。</target>
        </trans-unit>
        <trans-unit id="7b939e4151278ce4695f67fb994a918f9a84e18f" translate="yes" xml:space="preserve">
          <source>No custom headers are sent with the HTTP request (such as &lt;code&gt;X-Modified&lt;/code&gt;, etc.)</source>
          <target state="translated">カスタムヘッダーはHTTPリクエストで送信されません（ &lt;code&gt;X-Modified&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="573822ae80155d86cf67051167134df0cef110f2" translate="yes" xml:space="preserve">
          <source>No event listeners are registered on any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt;&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt;&lt;/a&gt; object used in the request; these are accessed using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt;&lt;code&gt;XMLHttpRequest.upload&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">リクエストで使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt; &lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; &lt;/a&gt;オブジェクトにイベントリスナーは登録されません。これらは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt; &lt;code&gt;XMLHttpRequest.upload&lt;/code&gt; &lt;/a&gt;プロパティを使用してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="c8bef9415aed440d614d66a570191aedb63a9755" translate="yes" xml:space="preserve">
          <source>No inheritance with &lt;code&gt;default-src&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; の継承なし</target>
        </trans-unit>
        <trans-unit id="759bb2da44cf0b5255c1bd66673ad4fd56926c2b" translate="yes" xml:space="preserve">
          <source>No multiplexing can be done. Several connections need opening on the same server: and warm TCP connections are more efficient than cold ones.</source>
          <target state="translated">多重化はできません。同じサーバ上で複数のコネクションを開く必要があります。</target>
        </trans-unit>
        <trans-unit id="701e86c07a175edb82d6e91e08c1b08340403b9b" translate="yes" xml:space="preserve">
          <source>No other expectations except &quot;100-continue&quot; are specified currently.</source>
          <target state="translated">現在は「100継続」以外の期待度は指定されていません。</target>
        </trans-unit>
        <trans-unit id="e8f8ea3fe1de09718f410e58fb2b6aa218c2ce1a" translate="yes" xml:space="preserve">
          <source>No range unit is supported, this makes the header equivalent of its own absence and is therefore rarely used, though some browsers, like IE9, it is used to disable or remove the pause buttons in the download manager.</source>
          <target state="translated">範囲単位はサポートされていません、これは、ヘッダが自身の不在と同等になりますので、ほとんど使用されませんが、IE9のようないくつかのブラウザでは、ダウンロードマネージャの一時停止ボタンを無効にしたり、削除するために使用されていますが。</target>
        </trans-unit>
        <trans-unit id="733083ad7466dbb41b8dd82838b716da4b0d421f" translate="yes" xml:space="preserve">
          <source>No support for query strings, etc.</source>
          <target state="translated">クエリ文字列などのサポートはありません。</target>
        </trans-unit>
        <trans-unit id="c586fc9306c6c90357e137cd076d0c1a8ba40b34" translate="yes" xml:space="preserve">
          <source>No transformations or conversions should be made to the resource. The Content-Encoding, Content-Range, Content-Type headers must not be modified by a proxy. A non- transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. The &lt;code&gt;no-transform&lt;/code&gt; directive disallows this.</source>
          <target state="translated">リソースを変換または変換しないでください。 Content-Encoding、Content-Range、Content-Typeヘッダーは、プロキシで変更しないでください。非透過プロキシは、たとえば、キャッシュスペースを節約したり、低速リンク上のトラフィック量を削減したりするために、画像フォーマット間で変換する場合があります。 &lt;code&gt;no-transform&lt;/code&gt; ディレクティブを禁止し、これを。</target>
        </trans-unit>
        <trans-unit id="cbffbe0b8b6d1110e3c62d1a5647e0d5355ab572" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows any URL.</source>
          <target state="translated">いいえ、これを設定しないと、任意のURLを許可しません。</target>
        </trans-unit>
        <trans-unit id="d7968e9f59fc3ea4d8f9120bc13639ba2c96128a" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows anything.</source>
          <target state="translated">いいえ、これを設定しないと何もできません。</target>
        </trans-unit>
        <trans-unit id="43b56bdc9a2f449dd95a29cc4403aabc8d987dfc" translate="yes" xml:space="preserve">
          <source>Node.JS</source>
          <target state="translated">Node.JS</target>
        </trans-unit>
        <trans-unit id="c77a87d79945cb92381e651d3b83555dc60d5cee" translate="yes" xml:space="preserve">
          <source>Nokia N900 Linux mobile, on the Fennec browser</source>
          <target state="translated">ノキアN900 Linuxモバイル,Fennecブラウザ上で</target>
        </trans-unit>
        <trans-unit id="4b8c1db000b37532ee78f68154fa3781e4c83d96" translate="yes" xml:space="preserve">
          <source>Non-DAV-aware proxies will not honor the If header, since they will
   not understand the If header, and HTTP requires non-understood
   headers to be ignored.  When communicating with HTTP/1.1 proxies, the
   client MUST use the &quot;Cache-Control: no-cache&quot; request header so as to
   prevent the proxy from improperly trying to service the request from
   its cache.  When dealing with HTTP/1.0 proxies, the &quot;Pragma: no-
   cache&quot; request header MUST be used for the same reason.

   Because in general clients may not be able to reliably detect non-
   DAV-aware intermediates, they are advised to always prevent caching
   using the request directives mentioned above.</source>
          <target state="translated">なぜなら、DAVを認識していないプロキシはIfヘッダーを理解しないからで、 HTTPは理解されていないヘッダーは無視されることを要求するからである。HTTP/1.1プロキシと通信するとき、クライアントはプロキシがキャッシュからのリクエストを 不適切に処理しようとするのを防ぐために、&quot;Cache-Control:no-cache&quot; リクエストヘッダを使わなければならない[MUST]。HTTP/1.0プロキシを扱うとき、「Pragma:no-cache」リクエストヘッダーが 同じ理由で使用されなければならない[MUST]。一般的に、クライアントはDAVを意識していない中間体を確実に検出できないかもしれないので、 上述のリクエストディレクティブを使って常にキャッシュを防ぐことが推奨される。</target>
        </trans-unit>
        <trans-unit id="4b75bcc6b482971118032246352667713443b845" translate="yes" xml:space="preserve">
          <source>Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after a preflighted request, some browsers currently will report an error message such as the following.</source>
          <target state="translated">現在のところ、すべてのブラウザがプリフライト後のリダイレクトをサポートしているわけではありません。プリフライトされたリクエストの後にリダイレクトが発生した場合、現在のところ一部のブラウザは以下のようなエラーメッセージを報告します。</target>
        </trans-unit>
        <trans-unit id="cf38fd002847999f4fcff82b501a332885b56449" translate="yes" xml:space="preserve">
          <source>Not all types of HTTP requests can be pipelined: only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt; methods, that is &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, can be replayed safely: should a failure happen, the pipeline content can simply be repeated.</source>
          <target state="translated">すべてのタイプのHTTPリクエストをパイプライン処理できるわけではありません。べき&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;等&lt;/a&gt;メソッド、つまり&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; のみです。&lt;/a&gt;安全に再生できるのは、べきのみです。障害が発生した場合、パイプラインのコンテンツを単純に繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="10691f4c6439e42e1fb5e5f7a828b53b02a4fd2a" translate="yes" xml:space="preserve">
          <source>Not many: the choices are listed in an HTML page in the body. Could be served with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">多くはありません：選択肢は本文のHTMLページにリストされています。&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; で提供できますステータスます。</target>
        </trans-unit>
        <trans-unit id="36e6c8b66ebeebd54bd9a904c7fbeea61aee185c" translate="yes" xml:space="preserve">
          <source>Not part of any current specification. The standardized version of this header is &lt;a href=&quot;forwarded&quot;&gt;&lt;code&gt;Forwarded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の仕様の一部ではありません。このヘッダーの標準化されたバージョンは&lt;a href=&quot;forwarded&quot;&gt; &lt;code&gt;Forwarded&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1500ffdc7dad0acff37ead2e9bc7fa9274c76bf3" translate="yes" xml:space="preserve">
          <source>Not part of any current specifications. An explainer of the ideas behind this header can be found in &lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;this document&lt;/a&gt;.</source>
          <target state="translated">現在の仕様の一部ではありません。このヘッダーの背後にあるアイデアの説明者は、&lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;このドキュメントにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4de1afe5413225e5f1765ec1032b7844a5f2454" translate="yes" xml:space="preserve">
          <source>Not part of any specification.</source>
          <target state="translated">仕様の一部ではありません。</target>
        </trans-unit>
        <trans-unit id="a7ef8eb2962577a32c14b0ab70a829a6c4372bb9" translate="yes" xml:space="preserve">
          <source>Not part of any specifications or drafts.</source>
          <target state="translated">仕様書や原案の一部ではありません。</target>
        </trans-unit>
        <trans-unit id="d7da173654def19a4d625df2150ac9e2fae338ac" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests until Firefox 58, see &lt;a href=&quot;https://bugzil.la/446344&quot;&gt;bug 446344&lt;/a&gt;.</source>
          <target state="translated">Firefox 58まで &lt;code&gt;POST&lt;/code&gt; リクエストで送信されません。&lt;a href=&quot;https://bugzil.la/446344&quot;&gt;バグ446344を&lt;/a&gt;参照してください。。</target>
        </trans-unit>
        <trans-unit id="37cdc0eab1650d512c35c0138237e99aeced5b05" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests, see &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;bug 10482384&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; リクエストでは送信されません。&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;バグ10482384を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="50453dd141739f1c493d302dd3803fa4331745be" translate="yes" xml:space="preserve">
          <source>Not tracking.</source>
          <target state="translated">追跡してない</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="e3a2dfaed75d27647860fc3263ef2225f1db15d5" translate="yes" xml:space="preserve">
          <source>Note that 'allprop', despite its name, which remains for backward-
   compatibility, does not return every property, but only dead
   properties and the live properties defined in this specification.

   &amp;gt;&amp;gt;Request

     PROPFIND /container/ HTTP/1.1
     Host: www.example.com
     Depth: 1
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
     &amp;lt;/D:propfind&amp;gt;


   &amp;gt;&amp;gt;Response

     HTTP/1.1 207 Multi-Status
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:multistatus xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type A&amp;lt;/R:BoxType&amp;gt;&amp;lt;/R:bigbox&amp;gt;
             &amp;lt;R:author&amp;gt;&amp;lt;R:Name&amp;gt;Hadrian&amp;lt;/R:Name&amp;gt;&amp;lt;/R:author&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T17:42:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example collection&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:resourcetype&amp;gt;&amp;lt;D:collection/&amp;gt;&amp;lt;/D:resourcetype&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt; 

           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/front.html&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type B&amp;lt;/R:BoxType&amp;gt;
             &amp;lt;/R:bigbox&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T18:27:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example HTML resource&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:getcontentlength&amp;gt;4525&amp;lt;/D:getcontentlength&amp;gt;
             &amp;lt;D:getcontenttype&amp;gt;text/html&amp;lt;/D:getcontenttype&amp;gt;
             &amp;lt;D:getetag&amp;gt;&quot;zzyzx&quot;&amp;lt;/D:getetag&amp;gt;
             &amp;lt;D:getlastmodified
               &amp;gt;Mon, 12 Jan 1998 09:25:56 GMT&amp;lt;/D:getlastmodified&amp;gt;
             &amp;lt;D:resourcetype/&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt;
           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
     &amp;lt;/D:multistatus&amp;gt;

   In this example, PROPFIND was invoked on the resource
   http://www.example.com/container/ with a Depth header of 1, meaning
   the request applies to the resource and its children, and a propfind
   XML element containing the allprop XML element, meaning the request
   should return the name and value of all the dead properties defined
   on the resources, plus the name and value of all the properties
   defined in this specification.  This example illustrates the use of
   relative references in the 'href' elements of the response.

   The resource http://www.example.com/container/ has six properties
   defined on it: 'bigbox' and 'author in the
   &quot;http://ns.example.com/boxschema/&quot; namespace, DAV:creationdate, DAV:
   displayname, DAV:resourcetype, and DAV:supportedlock. 

   The last four properties are WebDAV-specific, defined in &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;.
   Since GET is not supported on this resource, the get* properties
   (e.g., DAV:getcontentlength) are not defined on this resource.  The
   WebDAV-specific properties assert that &quot;container&quot; was created on
   December 1, 1997, at 5:42:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example collection&quot; (DAV:
   displayname), a collection resource type (DAV:resourcetype), and
   supports exclusive write and shared write locks (DAV:supportedlock).

   The resource http://www.example.com/container/front.html has nine
   properties defined on it:

   'bigbox' in the &quot;http://ns.example.com/boxschema/&quot; namespace (another
   instance of the &quot;bigbox&quot; property type), DAV:creationdate, DAV:
   displayname, DAV:getcontentlength, DAV:getcontenttype, DAV:getetag,
   DAV:getlastmodified, DAV:resourcetype, and DAV:supportedlock.

   The DAV-specific properties assert that &quot;front.html&quot; was created on
   December 1, 1997, at 6:27:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example HTML resource&quot; (DAV:
   displayname), a content length of 4525 bytes (DAV:getcontentlength),
   a MIME type of &quot;text/html&quot; (DAV:getcontenttype), an entity tag of
   &quot;zzyzx&quot; (DAV:getetag), was last modified on Monday, January 12, 1998,
   at 09:25:56 GMT (DAV:getlastmodified), has an empty resource type,
   meaning that it is not a collection (DAV:resourcetype), and supports
   both exclusive write and shared write locks (DAV:supportedlock).</source>
          <target state="translated">「allprop」は、下位互換性のために残されているその名前にもかかわらず、すべてのプロパティを返すのではなく、この仕様で定義されているデッドプロパティとライブプロパティのみを返すことに注意してください。 &amp;gt;&amp;gt;リクエストPROPFIND / container / HTTP / 1.1ホスト：www.example.com深さ：1コンテンツタイプ：application / xml; charset = &quot;utf-8&quot; Content-Length：xxxx &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：propfind xmlns：D = &quot;DAV：&quot;&amp;gt; &amp;lt;D：allprop /&amp;gt; &amp;lt;/ D：propfind&amp;gt; &amp;gt;&amp;gt; Response HTTP / 1.1 207 Multi-Status Content-Type：application / xml; charset = &quot;utf-8&quot; Content-Length：xxxx &amp;lt;？xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;？&amp;gt; &amp;lt;D：multistatus xmlns：D = &quot;DAV：&quot;&amp;gt; &amp;lt;D：response&amp;gt;&amp;lt;D：href&amp;gt; / container / &amp;lt;/ D：href&amp;gt; &amp;lt;D：propstat&amp;gt; &amp;lt;D：prop xmlns：R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R：bigbox&amp;gt; &amp;lt;R： BoxType&amp;gt;ボックスタイプA &amp;lt;/ R：BoxType&amp;gt; &amp;lt;/ R：bigbox&amp;gt; &amp;lt;R：author&amp;gt; &amp;lt;R：Name&amp;gt; Hadrian &amp;lt;/ R：Name&amp;gt; &amp;lt;/ R：author&amp;gt; &amp;lt;D：creationdate&amp;gt; 1997-12-01T17 ：42：21-08：00 &amp;lt;/ D：creationdate&amp;gt; &amp;lt;D：displayname&amp;gt;サンプルコレクション&amp;lt;/ D：displayname&amp;gt; &amp;lt;D：resourcetype&amp;gt; &amp;lt;D：collection /&amp;gt; &amp;lt;/ D：resourcetype&amp;gt; &amp;lt;D：supportedlock&amp;gt; &amp;lt; D：lockentry&amp;gt; &amp;lt;D：lockscope&amp;gt; &amp;lt;D：exclusive /&amp;gt; &amp;lt;/ D：lockscope&amp;gt; &amp;lt;D：locktype&amp;gt; &amp;lt;D：write /&amp;gt; &amp;lt;/ D：locktype&amp;gt; &amp;lt;/ D：lockentry&amp;gt; &amp;lt;D：lockentry&amp;gt; &amp;lt;D：lockscope&amp;gt; &amp;lt;D：shared /&amp;gt; &amp;lt;/ D：lockscope&amp;gt; &amp;lt;D：locktype&amp;gt; &amp;lt;D：write /&amp;gt; &amp;lt;/ D：locktype&amp;gt; &amp;lt;/ D：lockentry&amp;gt; &amp;lt;/ D：supportedlock&amp;gt; &amp;lt;/ D：prop&amp;gt; &amp;lt;D：status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D：status&amp;gt; &amp;lt;/ D：propstat&amp;gt; &amp;lt;/ D：response&amp;gt; &amp;lt;D：response&amp;gt; &amp;lt;D：href&amp;gt; /container/front.html &amp;lt;/ D：href&amp;gt; &amp;lt;D：propstat&amp;gt; &amp;lt;D：prop xmlns：R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R：bigbox&amp;gt; &amp;lt;R：BoxType&amp;gt;ボックスタイプB &amp;lt;/ R：BoxType &amp;gt; &amp;lt;/ R：bigbox&amp;gt; &amp;lt;D：creationdate&amp;gt; 1997-12-01T18：27：21-08：00 &amp;lt;/ D：creationdate&amp;gt; &amp;lt;D：displayname&amp;gt;サンプルHTMLリソース&amp;lt;/ D：displayname&amp;gt; &amp;lt;D：getcontentlength&amp;gt; 4525 &amp;lt;/ D：getcontentlength&amp;gt; &amp;lt;D：getcontenttype&amp;gt; text / html &amp;lt;/ D：getcontenttype&amp;gt; &amp;lt;D：getetag&amp;gt; &quot;zzyzx&quot; &amp;lt;/ D：getetag&amp;gt; &amp;lt;D：getlastmodified&amp;gt; 1998年1月12日月曜日09:25 ：56 GMT &amp;lt;/ D：getlastmodified&amp;gt; &amp;lt;D：resourcetype /&amp;gt; &amp;lt;D：supportedlock&amp;gt; &amp;lt;D：lockentry&amp;gt; &amp;lt;D：lockscope&amp;gt; &amp;lt;D：exclusive /&amp;gt; &amp;lt;/ D：lockscope&amp;gt; &amp;lt;D：locktype&amp;gt; &amp;lt;D： write /&amp;gt; &amp;lt;/ D：locktype&amp;gt; &amp;lt;/ D：lockentry&amp;gt; &amp;lt;D：lockentry&amp;gt; &amp;lt;D：lockscope&amp;gt; &amp;lt;D：shared /&amp;gt; &amp;lt;/ D：lockscope&amp;gt; &amp;lt;D：locktype&amp;gt; &amp;lt;D：write /&amp;gt; &amp;lt;/ D：locktype&amp;gt; &amp;lt;/ D：lockentry&amp;gt; &amp;lt;/ D：supportedlock&amp;gt;&amp;lt;/ D：prop&amp;gt; &amp;lt;D：status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D：status&amp;gt; &amp;lt;/ D：propstat&amp;gt; &amp;lt;/ D：response&amp;gt; &amp;lt;/ D：multistatus&amp;gt;この例では、リソースでPROPFINDが呼び出されましたhttp://www.example.com/container/ Depthヘッダーが1で、リクエストがリソースとその子に適用されることを意味し、allprop XMLエレメントを含むpropfind XMLエレメント、つまりリクエストが名前と値を返すことを意味しますリソースで定義されているすべてのデッドプロパティのほか、この仕様で定義されているすべてのプロパティの名前と値。この例は、応答の「href」要素での相対参照の使用を示しています。リソースhttp://www.example.com/container/には、「bigbox」と「「http://ns.example.com/boxschema/」名前空間の作成者、DAV：creationdate、DAV：displayname、DAV：resourcetype、DAV：supportedlock。最後の4つのプロパティはWebDAV固有であり、&lt;a href=&quot;#section-15&quot;&gt;セクション15&lt;/a&gt;。 GETはこのリソースではサポートされていないため、get *プロパティ（たとえば、DAV：getcontentlength）はこのリソースで定義されていません。 WebDAV固有のプロパティは、「コンテナ」が1997年12月1日午後5時42分21秒（GMTの西8時間のタイムゾーン（DAV：creationdate））に作成され、「サンプルコレクション」（DAV ：displayname）、コレクションリソースタイプ（DAV：resourcetype）、および排他的書き込みロックと共有書き込みロック（DAV：supportedlock）をサポートします。リソースhttp://www.example.com/container/front.htmlには、9つのプロパティが定義されています。「http://ns.example.com/boxschema/」名前空間の「bigbox」（「 bigbox &quot;プロパティタイプ）、DAV：creationdate、DAV：表示名、DAV：getcontentlength、DAV：getcontenttype、DAV：getetag、DAV：getlastmodified、DAV：resourcetype、DAV：supportedlock。 DAV固有のプロパティは、「front.html」が1997年12月1日午後6時27分21秒（GMTの西8時間のタイムゾーン）に作成された（DAV：creationdate）には、「HTMLリソースの例&quot;（DAV：displayname）、コンテンツ長は4525バイト（DAV：getcontentlength）、MIMEタイプは&quot; text / html &quot;（DAV：getcontenttype）、エンティティタグは&quot; zzyzx &quot;（DAV：getetag）、最後に変更されました1998年1月12日月曜日の09:25:56 GMT（DAV：getlastmodified）には空のリソースタイプがあり、これはコレクション（DAV：resourcetype）ではなく、排他的書き込みロックと共有書き込みロックの両方をサポートします（ DAV：supportedlock）。1997年12月1日午後6時27分21秒、グリニッジ標準時から8時間西のタイムゾーン（DAV：creationdate）に作成され、「サンプルHTMLリソース」（DAV：displayname）という名前があり、コンテンツの長さは4525です。バイト（DAV：getcontentlength）、MIMEタイプ「text / html」（DAV：getcontenttype）、エンティティタグ「zzyzx」（DAV：getetag）は、1998年1月12日月曜日、09：25に最終変更されました。 ：56 GMT（DAV：getlastmodified）、リソースタイプが空、つまりコレクションではない（DAV：resourcetype）。排他的書き込みロックと共有書き込みロックの両方をサポートします（DAV：supportedlock）。1997年12月1日午後6時27分21秒、グリニッジ標準時から8時間西のタイムゾーン（DAV：creationdate）に作成され、「サンプルHTMLリソース」（DAV：displayname）という名前があり、コンテンツの長さは4525です。バイト（DAV：getcontentlength）、MIMEタイプ「text / html」（DAV：getcontenttype）、エンティティタグ「zzyzx」（DAV：getetag）は、1998年1月12日月曜日、09：25に最終変更されました。 ：56 GMT（DAV：getlastmodified）、リソースタイプが空、つまりコレクションではない（DAV：resourcetype）。排他的書き込みロックと共有書き込みロックの両方をサポートします（DAV：supportedlock）。「zzyzx」（DAV：getetag）のエンティティタグであるtext / html &quot;（DAV：getcontenttype）は、1998年1月12日月曜日、09：25：56 GMT（DAV：getlastmodified）に最終変更され、空のリソースタイプ。これはコレクションではないことを意味し（DAV：resourcetype）、排他的書き込みロックと共有書き込みロックの両方をサポートします（DAV：supportedlock）。「zzyzx」（DAV：getetag）のエンティティタグであるtext / html &quot;（DAV：getcontenttype）は、1998年1月12日月曜日、09：25：56 GMT（DAV：getlastmodified）に最終変更され、空のリソースタイプ。これはコレクションではないことを意味し（DAV：resourcetype）、排他的書き込みロックと共有書き込みロックの両方をサポートします（DAV：supportedlock）。</target>
        </trans-unit>
        <trans-unit id="733da1ea06ac6c1e1c6fc58cd54e3b6560771890" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is actually a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="translated">注意&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;実際に単語「リファラ」のスペルミスです。 &lt;code&gt;Referrer-Policy&lt;/code&gt; ヘッダには、このスペルミスを共有しません。</target>
        </trans-unit>
        <trans-unit id="88907399933c092ee116572f07a09e971f2ea48c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;text/plain&lt;/code&gt; does not mean &lt;em&gt;any kind of textual data&lt;/em&gt;. If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a &lt;code&gt;text/plain&lt;/code&gt; file from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element declaring a CSS files, they will not recognize it as a valid CSS files if presented with &lt;code&gt;text/plain&lt;/code&gt;. The CSS mime type &lt;code&gt;text/css&lt;/code&gt; must be used.</source>
          <target state="translated">&lt;code&gt;text/plain&lt;/code&gt; は、&lt;em&gt;いかなる種類のテキストデータも&lt;/em&gt;意味しないことに注意してください。特定の種類のテキストデータを期待している場合、一致とは見なされない可能性があります。彼らはダウンロードした場合に具体的に &lt;code&gt;text/plain&lt;/code&gt; でのファイル&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; CSSファイルを宣言する要素を提示している場合、彼らは有効なCSSファイルとしてそれを認識しません &lt;code&gt;text/plain&lt;/code&gt; 。CSS MIMEタイプ &lt;code&gt;text/css&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e9dc294e0815213796bc980c17d902a5389831b1" translate="yes" xml:space="preserve">
          <source>Note that certain headers are &lt;em&gt;always&lt;/em&gt; allowed: &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;). These are called the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;simple headers&lt;/a&gt;, and you don't need to specify them explicitly.</source>
          <target state="translated">特定のヘッダーは&lt;em&gt;常に&lt;/em&gt;許可されて&lt;em&gt;いる&lt;/em&gt;ことに注意してください：&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;（ただし、 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 、 &lt;code&gt;multipart/form-data&lt;/code&gt; のいずれかの解析された値のMIMEタイプ（パラメーターを無視）form-data、または &lt;code&gt;text/plain&lt;/code&gt; ）。これらは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;シンプルヘッダー&lt;/a&gt;と呼ばれ、明示的に指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="0dde5258cb287b7e5f1335b4b8968fc964826436" translate="yes" xml:space="preserve">
          <source>Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from &lt;code&gt;foo.example&lt;/code&gt;, but the cookie on line 22 is sent by &lt;code&gt;bar.other&lt;/code&gt;, and would thus not be saved if the user has configured their browser to reject all third-party cookies.</source>
          <target state="translated">CORS応答で設定されたCookieには、通常のサードパーティのCookieポリシーが適用されることに注意してください。上記の例では、ページは &lt;code&gt;foo.example&lt;/code&gt; からロードされますが、22行目のCookieは &lt;code&gt;bar.other&lt;/code&gt; によって送信されるため、ユーザーがすべてのサードパーティのCookieを拒否するようにブラウザーを構成している場合は保存されません。</target>
        </trans-unit>
        <trans-unit id="d2f243d962235cf432887667d07e758583b705da" translate="yes" xml:space="preserve">
          <source>Note that in any access control request, the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header is &lt;strong&gt;always&lt;/strong&gt; sent.</source>
          <target state="translated">どのアクセス制御要求でも、&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;ヘッダーは&lt;strong&gt;常に&lt;/strong&gt;送信されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3c4aaaf9288e658776e9fcfd33685b0df524267a" translate="yes" xml:space="preserve">
          <source>Note that in the case of credentialed requests, the &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; header &lt;strong&gt;must not&lt;/strong&gt; have a wildcard value of &quot;*&quot;. It &lt;strong&gt;must&lt;/strong&gt; mention a valid origin domain. The example above can be seen &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;running here&lt;/a&gt;.</source>
          <target state="translated">認証されたリクエストの場合、 &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; ヘッダーにワイルドカード値「*」を含めることは&lt;strong&gt;できません&lt;/strong&gt;。これは、&lt;strong&gt;必要があり&lt;/strong&gt;、有効な元のドメインに言及します。上記の例は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここで実行されて&lt;/a&gt;いるのを見ることができます。</target>
        </trans-unit>
        <trans-unit id="13d83d306a8b3e2d42d4c3ab70727c3afb42e937" translate="yes" xml:space="preserve">
          <source>Note that inline event handlers are blocked as well:</source>
          <target state="translated">インラインのイベントハンドラもブロックされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="482d5e7da59888db6e881351a22dd4cf2b2344da" translate="yes" xml:space="preserve">
          <source>Note that now, no domain other than &lt;code&gt;http://foo.example&lt;/code&gt; (identified by the ORIGIN: header in the request, as in line 10 above) can access the resource in a cross-site manner. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header should contain the value that was sent in the request's &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">ここで、 &lt;code&gt;http://foo.example&lt;/code&gt; 以外のドメイン（上記の行10のように、要求のORIGIN：ヘッダーで識別される）は、クロスサイトの方法でリソースにアクセスできないことに注意してください。 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; ヘッダーは、要求の中で送信された値が含まれている必要があり &lt;code&gt;Origin&lt;/code&gt; ヘッダを。</target>
        </trans-unit>
        <trans-unit id="ceb9adaebb159a4870cdc204a80a7efec8b3349e" translate="yes" xml:space="preserve">
          <source>Note that referer is actually a misspelling of the word &quot;referrer&quot;. See &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;HTTP referer on Wikipedia&lt;/a&gt; for more details.</source>
          <target state="translated">リファラーは実際には「リファラー」という単語のスペルミスであることに注意してください。詳細については&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;、WikipediaのHTTPリファラー&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="e77f5478415d507325d52c5303120a20756b6b78" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Set-Cookie&lt;/code&gt; response header in the example above also sets a further cookie. In case of failure, an exception&amp;mdash;depending on the API used&amp;mdash;is raised.</source>
          <target state="translated">上記の例の &lt;code&gt;Set-Cookie&lt;/code&gt; 応答ヘッダーは、さらにCookieを設定することに注意してください。失敗した場合、使用するAPIに応じて例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4bd9d3cba4ca919c6212e4317b95019fb2ffe615" translate="yes" xml:space="preserve">
          <source>Note that the HTTP response headers &quot;Etag&quot; and &quot;Last-Modified&quot; (see
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], Sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; and &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;) are defined per URL (not per
   resource), and are used by clients for caching.  Therefore servers
   must ensure that executing any operation that affects the URL
   namespace (such as COPY, MOVE, DELETE, PUT, or MKCOL) does preserve
   their semantics, in particular: 

   o  For any given URL, the &quot;Last-Modified&quot; value MUST increment every
      time the representation returned upon GET changes (within the
      limits of timestamp resolution).

   o  For any given URL, an &quot;ETag&quot; value MUST NOT be reused for
      different representations returned by GET.

   In practice this means that servers

   o  might have to increment &quot;Last-Modified&quot; timestamps for every
      resource inside the destination namespace of a namespace operation
      unless it can do so more selectively, and

   o  similarly, might have to re-assign &quot;ETag&quot; values for these
      resources (unless the server allocates entity tags in a way so
      that they are unique across the whole URL namespace managed by the
      server).

   Note that these considerations also apply to specific use cases, such
   as using PUT to create a new resource at a URL that has been mapped
   before, but has been deleted since then.

   Finally, WebDAV properties (such as DAV:getetag and DAV:
   getlastmodified) that inherit their semantics from HTTP headers must
   behave accordingly.</source>
          <target state="translated">HTTP応答ヘッダー「Etag」および「Last-Modified」に注意してください（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]、セクション&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;および&lt;a href=&quot;#section-14.29&quot;&gt; 14.29を参照）&lt;/a&gt;）は（リソースごとではなく）URLごとに定義され、クライアントがキャッシュに使用します。したがって、サーバーは、URLの名前空間に影響を与える操作（COPY、MOVE、DELETE、PUT、MKCOLなど）を実行しても、そのセマンティクスが保存されることを確認する必要があります。特に、次のようになります。 GETで表現が返されるたびに（タイムスタンプ解決の制限内で）変更されます。 o特定のURLについて、「ETag」値は、GETによって返されるさまざまな表現に再利用してはなりません。実際には、これは、サーバーがネームスペース操作の宛先ネームスペース内のすべてのリソースの「Last-Modified」タイムスタンプを増加させる必要がある可能性があることを意味します。これらのリソースに「ETag」値を再割り当てする必要がある場合があります（サーバーが管理するURL名前空間全体で一意になるようにサーバーがエンティティタグを割り当てる場合を除く）。これらの考慮事項は、PUTを使用して、以前にマップされていたがその後削除されたURLで新しいリソースを作成するなど、特定の使用例にも適用されることに注意してください。最後に、HTTPヘッダーからセマンティクスを継承するWebDAVプロパティ（DAV：getetagやDAV：getlastmodifiedなど）は、それに応じて動作する必要があります。たとえば、PUTを使用して、以前にマップされていたがその後削除されたURLに新しいリソースを作成する場合などです。最後に、HTTPヘッダーからセマンティクスを継承するWebDAVプロパティ（DAV：getetagやDAV：getlastmodifiedなど）は、それに応じて動作する必要があります。たとえば、PUTを使用して、以前にマップされていたがその後削除されたURLに新しいリソースを作成する場合などです。最後に、HTTPヘッダーからセマンティクスを継承するWebDAVプロパティ（DAV：getetagやDAV：getlastmodifiedなど）は、それに応じて動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="524a5391e04da5188d8d6239340a145a47bbb106" translate="yes" xml:space="preserve">
          <source>Note that the server is not obligated to use any compression method. Compression highly depends on server settings and used server modules.</source>
          <target state="translated">なお、サーバは圧縮方式を使用する義務はありません。圧縮はサーバの設定や使用するサーバモジュールに大きく依存します。</target>
        </trans-unit>
        <trans-unit id="8fc871d77bd2a17b1592fb06f1975897a38785b1" translate="yes" xml:space="preserve">
          <source>Note that these redirections break the back button in a browser: you can go back to a page with this header but it instantaneously moves forward again.</source>
          <target state="translated">これらのリダイレクトはブラウザの戻るボタンを壊していることに注意してください:このヘッダーでページに戻ることはできますが、それは瞬時に再び前に進みます。</target>
        </trans-unit>
        <trans-unit id="c19e315f56095fa3fee06607e90fa58ce789809b" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't specify a &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt;; with the example CSP, this site uses the setting specified by the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, which means that scripts can be loaded only from the originating server.</source>
          <target state="translated">この例では&lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; を&lt;/a&gt;指定していないことに注意してください。サンプルCSPでは、このサイトは&lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;ディレクティブで指定された設定を使用します。つまり、スクリプトは元のサーバーからのみロードできます。</target>
        </trans-unit>
        <trans-unit id="877bc59b4de188751558af6e41e4cec35b5f4e71" translate="yes" xml:space="preserve">
          <source>Note that using &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and compression at the hop level is so rare that most servers, like Apache, nginx, or IIS, have no easy way to configure it. Such configuration usually happens at the proxy level.</source>
          <target state="translated">ホップレベルで&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;と圧縮を使用することは非常にまれであるため、Apache、nginx、IISなどのほとんどのサーバーでは、簡単に構成することができません。このような構成は通常、プロキシレベルで行われます。</target>
        </trans-unit>
        <trans-unit id="50344a1423a5adbde9caeb6452a36fbce49d2ef4" translate="yes" xml:space="preserve">
          <source>Note the appropriate headers being sent back in response to the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; preflight as well as to the &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; data. One resource thus handles the preflight as well as the actual request. In the response to the &lt;code&gt;OPTIONS&lt;/code&gt; request, the server notifies the client that the actual request can indeed be made with the &lt;code&gt;POST&lt;/code&gt; method, and header fields such as &lt;code&gt;X-PINGARUNER&lt;/code&gt; can be sent with the actual request. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;プリフライトと&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;データへの応答として返される適切なヘッダーに注意してください。したがって、1つのリソースがプリフライトと実際のリクエストを処理します。 &lt;code&gt;OPTIONS&lt;/code&gt; リクエストへの応答では、サーバーはクライアントに実際のリクエストを &lt;code&gt;POST&lt;/code&gt; メソッドで &lt;code&gt;X-PINGARUNER&lt;/code&gt; ことができ、X-PINGARUNERなどのヘッダーフィールドを実際のリクエストで送信できることを通知します。この例は、&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;ここで実行されています&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f9a467b619f845068306fd652ae12e97054ab19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nosniff&lt;/code&gt; only applies to &quot;&lt;code&gt;script&lt;/code&gt;&quot; and &quot;&lt;code&gt;style&lt;/code&gt;&quot; types. Also applying &lt;code&gt;nosniff&lt;/code&gt; to images turned out to be &lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;incompatible with existing web sites&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;nosniff&lt;/code&gt; は「 &lt;code&gt;script&lt;/code&gt; 」および「 &lt;code&gt;style&lt;/code&gt; 」タイプにのみ適用されます。また、画像に &lt;code&gt;nosniff&lt;/code&gt; を適用する&lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;と、既存のWebサイト&lt;/a&gt;との互換性がなくなります。</target>
        </trans-unit>
        <trans-unit id="b0a73e692e8090c4e69881a90ac391d6c2513e11" translate="yes" xml:space="preserve">
          <source>Note: this user agent was retrieved from an iPhone XR simulator and may be different on device.</source>
          <target state="translated">注:このユーザーエージェントはiPhone XRシミュレータから取得したもので、デバイスによっては異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="d4d54b40413d81662c3ae8fb48a8db7dac1e55e9" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource doesn't exist:</source>
          <target state="translated">要求されたリソースが存在しないことを通知します。</target>
        </trans-unit>
        <trans-unit id="bc2f4cbb79515b85b2c0d07b3e431b778d1e12e4" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource has permanently moved:</source>
          <target state="translated">要求されたリソースが恒久的に移動したことを通知します。</target>
        </trans-unit>
        <trans-unit id="cc6b7b178c03549f9e2a165aa485d916c9c4a3c5" translate="yes" xml:space="preserve">
          <source>Now try to reproduce the failing transaction and check the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;console&lt;/a&gt; if you are seeing a CORS violation error message. It will probably look like this:</source>
          <target state="translated">CORS違反のエラーメッセージが表示されている場合は、失敗したトランザクションを再現し、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;コンソール&lt;/a&gt;を確認してください。おそらく次のようになります。</target>
        </trans-unit>
        <trans-unit id="c64e26807cf49c7d258e3a38b854c3cbcc1da88a" translate="yes" xml:space="preserve">
          <source>Now, if you are logged into your bank account and your cookies are still valid (and there is no other validation), you will transfer money as soon as you load the HTML that contains this image. There are a few techniques that are used to prevent this from happening:</source>
          <target state="translated">さて、銀行口座にログインしていてもクッキーが有効な状態(他に有効なものがない状態)であれば、この画像を含むHTMLを読み込むとすぐに送金されてしまいます。これを防ぐためのテクニックがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="316d446c2137e3fdd66e7c6a93e085285024a055" translate="yes" xml:space="preserve">
          <source>Now, with every new request to the server, the browser will send back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">これで、サーバーへのすべての新しい要求で、ブラウザーは&lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt;ヘッダーを使用して、以前に保存されたすべてのCookieをサーバーに送り返します。</target>
        </trans-unit>
        <trans-unit id="7f7f99421dc23022f9d4dad472dad8c1219a1e24" translate="yes" xml:space="preserve">
          <source>Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. Older browsers (ie6, ie7, and ie8) do not support max-age. For other browsers, if both (&lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Max-Age&lt;/code&gt;) are set, &lt;code&gt;Max-Age&lt;/code&gt; will have precedence.</source>
          <target state="translated">Cookieの有効期限が切れるまでの秒数。ゼロまたは負の数は、Cookieをすぐに期限切れにします。古いブラウザ（ie6、ie7、ie8）はmax-ageをサポートしていません。他のブラウザーでは、両方（ &lt;code&gt;Expires&lt;/code&gt; と &lt;code&gt;Max-Age&lt;/code&gt; ）が設定されている場合、 &lt;code&gt;Max-Age&lt;/code&gt; が優先されます。</target>
        </trans-unit>
        <trans-unit id="3d83594903f329fd61c74db928326d01462cddbd" translate="yes" xml:space="preserve">
          <source>OGG</source>
          <target state="translated">OGG</target>
        </trans-unit>
        <trans-unit id="abdf49e40c006cace12b860c577ebfd2f514568f" translate="yes" xml:space="preserve">
          <source>OGG audio</source>
          <target state="translated">OGGオーディオ</target>
        </trans-unit>
        <trans-unit id="e4b5a3d314e8c7201a4940347e84ecf91f139bbf" translate="yes" xml:space="preserve">
          <source>OGG video</source>
          <target state="translated">OGGビデオ</target>
        </trans-unit>
        <trans-unit id="891db7e7c01ff7470565d35fe04852a76dd5cce8" translate="yes" xml:space="preserve">
          <source>OPR/xyz &lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">OPR / xyz &lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="940af152764ecc453e50e12e715144d6352503d7" translate="yes" xml:space="preserve">
          <source>OPTIONS (RFC 7231)</source>
          <target state="translated">OPTIONS (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="6c906f4846c2cf5d1ef947e89e2af3a972efb9b3" translate="yes" xml:space="preserve">
          <source>OWASP Article: &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">OWASPの記事：&lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="305837b5ab2d13ba142d5f5e5b4aaf80f1816434" translate="yes" xml:space="preserve">
          <source>Observe that final empty line, this separates the data block from the header block. As there is no &lt;code&gt;Content-Length&lt;/code&gt; provided in an HTTP header, this data block is presented empty, marking the end of the headers, allowing the server to process the request the moment it receives this empty line.</source>
          <target state="translated">最後の空の行を確認してください。これにより、データブロックがヘッダーブロックから分離されます。HTTPヘッダーには &lt;code&gt;Content-Length&lt;/code&gt; がないため、このデータブロックは空で表示され、ヘッダーの終わりを示します。これにより、サーバーはこの空の行を受け取った瞬間にリクエストを処理できます。</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="a81ab58e0a7c48e950453b07afbc07c0041ca461" translate="yes" xml:space="preserve">
          <source>Obviously, this method only works with HTML pages (or similar) and cannot be used for images or any other type of content.</source>
          <target state="translated">明らかに、この方法はHTMLページ(またはそれに類するもの)でのみ動作し、画像や他の種類のコンテンツには使用できません。</target>
        </trans-unit>
        <trans-unit id="252f4b9010eb27d3590ba7cf70072cb1ff858d02" translate="yes" xml:space="preserve">
          <source>Of course, there is absolutely no guarantee that another browser will not hijack some of these things (like Chrome hijacked the Safari string in the past). That's why browser detection using the user agent string is unreliable and should be done only with the check of the version number (hijacking of past versions is less likely).</source>
          <target state="translated">もちろん、他のブラウザに乗っ取られないという保証は絶対にありません(過去にChromeがSafariの文字列を乗っ取ったように)。だからこそ、ユーザーエージェント文字列を使ったブラウザ検出は信頼性が低く、バージョン番号の確認のみで行うべきなのだ(過去のバージョンの乗っ取りの可能性は低い)。</target>
        </trans-unit>
        <trans-unit id="728f9313847dcc9ab70ed90ce6b11c13e63d839d" translate="yes" xml:space="preserve">
          <source>Officially standardized, in May 2015, HTTP/2 has had much success. By July 2016, 8.7% of all Web sites&lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; were already using it, representing more than 68% of all requests&lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;. High-traffic Web sites showed the most rapid adoption, saving considerably on data transfer overheads and subsequent budgets.</source>
          <target state="translated">正式に標準化された2015年5月、HTTP / 2は大きな成功を収めました。 2016年7月までに、すべてのWebサイトの8.7％&lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;がすでにそれを使用しており、すべてのリクエストの68％以上を占めています&lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;。トラフィックの多いWebサイトが最も急速に採用され、データ転送のオーバーヘッドとその後の予算を大幅に節約しました。</target>
        </trans-unit>
        <trans-unit id="deebb87fa96ee64c661fcfa4f0b7108c7212c6a5" translate="yes" xml:space="preserve">
          <source>Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was not
   terminated by a line-ending.  An HTTP/1.1 user agent MUST NOT preface
   or follow a request with an extra CRLF.  If terminating the request
   message body with a line-ending is desired, then the user agent MUST
   count the terminating CRLF octets as part of the message body length.

   In the interest of robustness, a server that is expecting to receive
   and parse a request-line SHOULD ignore at least one empty line (CRLF)
   received prior to the request-line. 

   Although the line terminator for the start-line and header fields is
   the sequence CRLF, a recipient MAY recognize a single LF as a line
   terminator and ignore any preceding CR.

   Although the request-line and status-line grammar rules require that
   each of the component elements be separated by a single SP octet,
   recipients MAY instead parse on whitespace-delimited word boundaries
   and, aside from the CRLF terminator, treat any form of whitespace as
   the SP separator while ignoring preceding or trailing whitespace;
   such whitespace includes one or more of the following octets: SP,
   HTAB, VT (%x0B), FF (%x0C), or bare CR.  However, lenient parsing can
   result in security vulnerabilities if there are multiple recipients
   of the message and each has its own unique interpretation of
   robustness (see &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the server
   SHOULD respond with a 400 (Bad Request) response.</source>
          <target state="translated">古いHTTP / 1.0ユーザーエージェントの実装では、POSTリクエストの後に、行末で終了していないメッセージ本文のコンテンツの読み取りに失敗した一部の初期のサーバーアプリケーションの回避策として、追加のCRLFを送信する場合があります。 HTTP / 1.1ユーザーエージェントは、追加のCRLFを使用して要求の前置または後続してはなりません（MUST NOT）。要求メッセージ本文を行末で終了することが望まれる場合、ユーザーエージェントは、終了CRLFオクテットをメッセージ本文の長さの一部としてカウントしなければなりません（MUST）。堅牢性のために、要求行を受信して​​解析することを期待しているサーバーは、要求行の前に受信された少なくとも1つの空行（CRLF）を無視する必要があります（SHOULD）。 start-lineおよびheaderフィールドの行ターミネーターはシーケンスCRLFですが、受信者は単一のLFを行ターミネーターとして認識して、先行するCRを無視してもかまいません（MAY）。request-lineとstatus-lineの文法規則では、コンポーネントの各要素を単一のSPオクテットで区切る必要がありますが、受信者は代わりに空白で区切られた単語の境界で解析し、CRLFターミネーターを除いて、任意の形式の空白を次のように処理できます。前または後の空白を無視するときのSPセパレータ。このような空白には、SP、HTAB、VT（％x0B）、FF（％x0C）、またはベアCRの1つ以上のオクテットが含まれます。ただし、緩やかな解析では、メッセージの受信者が複数存在し、それぞれに独自の堅牢性の解釈がある場合、セキュリティの脆弱性が生じる可能性があります（参照代わりに、受信者は空白で区切られた単語の境界で解析し、CRLFターミネーターを除いて、前後の空白を無視して、任意の形式の空白をSPセパレーターとして扱います。このような空白には、SP、HTAB、VT（％x0B）、FF（％x0C）、またはベアCRの1つ以上のオクテットが含まれます。ただし、緩やかな解析では、メッセージの受信者が複数存在し、それぞれに独自の堅牢性の解釈がある場合、セキュリティの脆弱性が生じる可能性があります（参照代わりに、受信者は空白で区切られた単語の境界で解析し、CRLFターミネーターを除いて、前後の空白を無視して、任意の形式の空白をSPセパレーターとして扱います。このような空白には、SP、HTAB、VT（％x0B）、FF（％x0C）、またはベアCRの1つ以上のオクテットが含まれます。ただし、緩やかな解析では、メッセージの受信者が複数存在し、それぞれに独自の堅牢性の解釈がある場合、セキュリティの脆弱性が生じる可能性があります（参照緩やかな解析では、メッセージの受信者が複数あり、それぞれに独自の堅牢性の解釈がある場合、セキュリティの脆弱性が発生する可能性があります（緩やかな解析では、メッセージの受信者が複数あり、それぞれに独自の堅牢性の解釈がある場合、セキュリティの脆弱性が発生する可能性があります（&lt;a href=&quot;#section-9.5&quot;&gt;セクション9.5&lt;/a&gt;）。サーバーがHTTPリクエストメッセージのみをリッスンしている場合、または開始行からHTTPリクエストメッセージであると思われるものを処理している場合、上記の堅牢性の例外を除いて、HTTPメッセージ文法と一致しないオクテットのシーケンスを受信します。 400（Bad Request）応答で応答する必要があります（SHOULD）。</target>
        </trans-unit>
        <trans-unit id="eccaba534ca9f5591f571f69a93afec9e199b19d" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the fixed string &quot;&lt;code&gt;20100101&lt;/code&gt;&quot;</source>
          <target state="translated">デスクトップでは、 &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; は固定文字列「 &lt;code&gt;20100101&lt;/code&gt; 」です</target>
        </trans-unit>
        <trans-unit id="dc422faa1ec0593c27e5dd94351848b8f4c22acb" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt; is the fixed string &quot;20100101&quot;</source>
          <target state="translated">デスクトップでは、&lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt;は固定文字列「20100101」です</target>
        </trans-unit>
        <trans-unit id="3c55762a68b0fe67eed8220b92fc45172bf563b7" translate="yes" xml:space="preserve">
          <source>On the client side, you can advertise a list of compression schemes that will be sent along in an HTTP request. The &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header is used for negotiating content encoding.</source>
          <target state="translated">クライアント側では、HTTPリクエストで送信される圧縮スキームのリストをアドバタイズできます。&lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;ヘッダは、コンテンツのエンコードを交渉するために使用されます。</target>
        </trans-unit>
        <trans-unit id="20a2d4459ba0ff06a3947af0742918817fc3eb06" translate="yes" xml:space="preserve">
          <source>On the opposite side of the communication channel, is the server which &lt;em&gt;serves&lt;/em&gt; the document as requested by the client. A server presents only as a single machine virtually: this is because it may actually be a collection of servers, sharing the load (load balancing) or a complex piece of software interrogating other computers (like cache, a DB server, e-commerce servers, &amp;hellip;), totally or partially generating the document on demand.</source>
          <target state="translated">通信チャネルの反対側には、クライアントからの要求に応じてドキュメントを&lt;em&gt;提供&lt;/em&gt;するサーバーがあります。サーバーは仮想的に単一のマシンとしてのみ存在します。これは、実際にはサーバーのコレクションであり、負荷を共有している（ロードバランシング）か、他のコンピューターに問い合わせる複雑なソフトウェア（キャッシュ、DBサーバー、eコマースサーバーなど）であるためです。 、&amp;hellip;）、オンデマンドでドキュメントを全体的または部分的に生成します。</target>
        </trans-unit>
        <trans-unit id="f66620c684e8eb3de3262130d1e274b88e19dc70" translate="yes" xml:space="preserve">
          <source>On the other hand, &quot;private&quot; indicates that the response is intended for a single user only and must not be stored by a shared cache. A private browser cache may store the response in this case.</source>
          <target state="translated">一方、&quot;private &quot;は、レスポンスが単一のユーザーのみを対象としており、共有キャッシュに保存されてはならないことを示しています。この場合、プライベートなブラウザキャッシュがレスポンスを保存することがあります。</target>
        </trans-unit>
        <trans-unit id="ea2b9186180061f8add8f4849f50a8d8fdd4125d" translate="yes" xml:space="preserve">
          <source>On the standard track</source>
          <target state="translated">標準トラックで</target>
        </trans-unit>
        <trans-unit id="7a52b249e2a4a19c25945f39f4219130ebc33285" translate="yes" xml:space="preserve">
          <source>Once a Resource has been created and its Member URI is known, that
   URI can be used to retrieve, edit, and delete the Resource.  &lt;a href=&quot;#section-11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; describes extensions to the Atom Syndication Format used in the
   Atom Protocol for editing purposes.</source>
          <target state="translated">リソースが作成され、そのメンバーURIがわかると、そのURIを使用してリソースを取得、編集、および削除できます。 &lt;a href=&quot;#section-11&quot;&gt;セクション&lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;では、編集目的でAtomプロトコルで使用されるAtom配信フォーマットの拡張について説明します。</target>
        </trans-unit>
        <trans-unit id="1157586853a498fecd0d5788bdf7e2636f066412" translate="yes" xml:space="preserve">
          <source>Once a resource is stored in a cache, it could theoretically be served by the cache forever. Caches have finite storage so items are periodically removed from storage. This process is called &lt;em&gt;cache eviction&lt;/em&gt;. On the other side, some resources may change on the server so the cache should be updated. As HTTP is a client-server protocol, servers can't contact caches and clients when a resource changes; they have to communicate an expiration time for the resource. Before this expiration time, the resource is &lt;em&gt;fresh&lt;/em&gt;; after the expiration time, the resource is &lt;em&gt;stale&lt;/em&gt;. Eviction algorithms often privilege fresh resources over stale resources. Note that a stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it forwards this request with a &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; to check if it is in fact still fresh. If so, the server returns a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) header without sending the body of the requested resource, saving some bandwidth.</source>
          <target state="translated">リソースがキャッシュに格納されると、理論的にはキャッシュによって永久に処理されます。キャッシュのストレージは有限であるため、アイテムはストレージから定期的に削除されます。このプロセスは&lt;em&gt;キャッシュエビクション&lt;/em&gt;と呼ばれます。一方、一部のリソースはサーバーで変更される可能性があるため、キャッシュを更新する必要があります。 HTTPはクライアント/サーバープロトコルであるため、リソースが変更されてもサーバーはキャッシュやクライアントに接続できません。リソースの有効期限を伝える必要があります。この有効期限が切れる前は、リソースは&lt;em&gt;新鮮&lt;/em&gt;です。有効期限が切れると、リソースはになり&lt;em&gt;古くなります&lt;/em&gt;ます。立ち退きアルゴリズムは、古いリソースよりも新しいリソースを優先することがよくあります。古くなったリソースは削除または無視されないことに注意してください。キャッシュは古いリソースのリクエストを受信すると、このリクエストを&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;、実際にまだ新しいかどうかを確認します。その場合、サーバーは要求されたリソースの本文を送信せずに&lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt;（Not Modified）ヘッダーを返し、帯域幅を節約します。</target>
        </trans-unit>
        <trans-unit id="d79e1072067e9270a5021d23e2d543ff572b05d8" translate="yes" xml:space="preserve">
          <source>Once a user has overridden the server-chosen language, a site should no longer use language detection and should stick with the explicitly-chosen language. In other words, only entry pages of a site should select the proper language using this header.</source>
          <target state="translated">一旦ユーザがサーバで選択された言語を上書きすると、サイトはもはや言語検出を使わず、明示的に選択された言語に固執すべきです。言い換えれば、サイトのエントリーページだけがこのヘッダを使って適切な言語を選択すべきです。</target>
        </trans-unit>
        <trans-unit id="8571c0f2c52762afed434f53c93e37e6519192e0" translate="yes" xml:space="preserve">
          <source>Once an inbound connection is obtained, the client sends an HTTP
   request message (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) with a request-target derived from the
   target URI.  There are four distinct formats for the request-target,
   depending on both the method being requested and whether the request
   is to a proxy.

     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form</source>
          <target state="translated">インバウンド接続が取得されると、クライアントはHTTPリクエストメッセージ（&lt;a href=&quot;#section-3&quot;&gt;&lt;/a&gt;は、ターゲットURIから派生したリクエストターゲットセクション3）を。リクエストされるメソッドと、リクエストがプロキシに対するものかどうかに応じて、リクエストターゲットには4つの異なる形式があります。request-target = origin-form /絶対形式/権限形式/アスタリスク形式</target>
        </trans-unit>
        <trans-unit id="90dcbb9bf6b3864e512e171d7b57669e95d50401" translate="yes" xml:space="preserve">
          <source>Once the TLS handshake is complete, the original request will be responded to as normal.</source>
          <target state="translated">TLS ハンドシェイクが完了すると、元のリクエストには通常通り応答します。</target>
        </trans-unit>
        <trans-unit id="555084494ae9b3d3ddba4fd675d1b872eb531308" translate="yes" xml:space="preserve">
          <source>Once the connection is established, the user-agent can send the request (a user-agent is typically a web browser, but can be anything else, a crawler, for example). A client request consists of text directives, separated by CRLF (carriage return, followed by line feed), divided into three blocks:</source>
          <target state="translated">接続が確立されると、ユーザーエージェントはリクエストを送ることができます(ユーザーエージェントは一般的にはWebブラウザですが、例えばクローラーなど他の何でも構いません)。クライアントリクエストは、3つのブロックに分割されたCRLF(キャリッジリターン、改行)で区切られたテキストディレクティブで構成されています。</target>
        </trans-unit>
        <trans-unit id="c2dcba3e69f215847ccd37ccdc0e122ddb02db7e" translate="yes" xml:space="preserve">
          <source>Once the preflight request is complete, the real request is sent:</source>
          <target state="translated">プリフライトリクエストが完了すると、本当のリクエストが送信されます。</target>
        </trans-unit>
        <trans-unit id="2f9ae143a5ad6f92b100c0c78400768cc4838d90" translate="yes" xml:space="preserve">
          <source>Once the target URI is determined, a client needs to decide whether a
   network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.

   If the client has a cache [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] and the request can be satisfied
   by it, then the request is usually directed there first.

   If the request is not satisfied by a cache, then a typical client
   will check its configuration to determine whether a proxy is to be
   used to satisfy the request.  Proxy configuration is implementation-
   dependent, but is often based on URI prefix matching, selective
   authority matching, or both, and the proxy itself is usually
   identified by an &quot;http&quot; or &quot;https&quot; URI.  If a proxy is applicable,
   the client connects inbound by establishing (or reusing) a connection
   to that proxy.

   If no proxy is applicable, a typical client will invoke a handler
   routine, usually specific to the target URI's scheme, to connect
   directly to an authority for the target resource.  How that is
   accomplished is dependent on the target URI scheme and defined by its
   associated specification, similar to how this specification defines
   origin server access for resolution of the &quot;http&quot; (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) and
   &quot;https&quot; (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) schemes.

   HTTP requirements regarding connection management are defined in
   &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.</source>
          <target state="translated">ターゲットURIが決定されると、クライアントは、目的のセマンティクスを実現するためにネットワーク要求が必要かどうかを決定する必要があります。必要な場合は、その要求の送信先を決定する必要があります。クライアントにキャッシュ[ &lt;a href=&quot;#section-2.7.1&quot;&gt;セクション2.7.1&lt;/a&gt; ]および「https」（&lt;a href=&quot;#section-2.7.2&quot;&gt;セクション2.7.2&lt;/a&gt;）スキームがある場合。接続管理に関するHTTP要件は、&lt;a href=&quot;#section-6&quot;&gt;セクション6で&lt;/a&gt;定義されてい ます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt; RFC7234&lt;/a&gt;]そしてリクエストはそれによって満たされることができ、それからリクエストは通常​​最初にそこに向けられます。要求がキャッシュで満たされない場合、一般的なクライアントはその構成をチェックして、要求を満たすためにプロキシを使用するかどうかを決定します。プロキシ設定は実装に依存しますが、多くの場合、URIプレフィックスマッチング、選択的権限マッチング、またはその両方に基づいており、プロキシ自体は通常「http」または「https」URIで識別されます。プロキシが適用可能な場合、クライアントはそのプロキシへの接続を確立（または再利用）することにより、インバウンドに接続します。プロキシが適用されない場合、通常のクライアントは、通常ターゲットURIのスキームに固有のハンドラルーチンを呼び出して、ターゲットリソースのオーソリティに直接接続します。これがどのように達成されるかは、ターゲットのURIスキームに依存し、関連する仕様によって定義されます。これは、この仕様が「http」の解決のためのオリジンサーバーアクセスを定義する方法と同様です（</target>
        </trans-unit>
        <trans-unit id="1ffcfdc99522dda87985b6e020ac99791f96f9b5" translate="yes" xml:space="preserve">
          <source>One helpful trick is to use an Apache rewrite, environment variable, and headers to apply &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; to certain URIs. This is useful, for example, to constrain cross-origin requests to &lt;code&gt;GET /api(.*).json&lt;/code&gt; requests without credentials:</source>
          <target state="translated">1つの役立つトリックは、Apacheリライト、環境変数、およびヘッダーを使用して、特定のURIに &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; を適用することです。これは、たとえば、クロスオリジンリクエストを制限して、 &lt;code&gt;GET /api(.*).json&lt;/code&gt; リクエストを認証情報なしでGET /api(.*).jsonリクエスト。</target>
        </trans-unit>
        <trans-unit id="a8582a1553ee6a6943be8472937795233c896987" translate="yes" xml:space="preserve">
          <source>One of &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; (case sensitive).</source>
          <target state="translated">1月」「2月」「3月」「4月」「5月」「6月」「7月」「8月」「9月」「10月」「11月」「12月」のいずれか1つ(大文字と小文字を区別します。</target>
        </trans-unit>
        <trans-unit id="cc3c09e9e2558b885fb3094c63215174af4c22c6" translate="yes" xml:space="preserve">
          <source>One of &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, or &quot;Sun&quot; (case-sensitive).</source>
          <target state="translated">月」「火」「水」「木」「金」「土」「日」のいずれか1つ(大文字・小文字を区別します。</target>
        </trans-unit>
        <trans-unit id="ed1f5145c366e1525cfdac1afb12bea74657baef" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;, for example &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一つの&lt;a href=&quot;../methods&quot;&gt;HTTPリクエストメソッド&lt;/a&gt;の例のために、&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="390c6d9e0ac6e814868f106e3b1a949d7f65c2f1" translate="yes" xml:space="preserve">
          <source>One of the ordered weekday strings:</source>
          <target state="translated">平日のオーダー弦の一つ。</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">1つ以上の</target>
        </trans-unit>
        <trans-unit id="d8241709124a392624ea93bbc5c857f96e735f3e" translate="yes" xml:space="preserve">
          <source>One or more &lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; can be set for the &lt;code&gt;plugin-types&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;plugin-types&lt;/code&gt; には1つ以上の&lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIMEタイプ&lt;/a&gt;を設定できますポリシーに。</target>
        </trans-unit>
        <trans-unit id="301b7fe5870eedf464270ce13c1fa28571750cd1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;default-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; に 1つ以上のソースを許可できますポリシーで。</target>
        </trans-unit>
        <trans-unit id="06bce7998d9ba504b451b0feee8e296f1daee8d8" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;font-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;font-src&lt;/code&gt; には1つ以上のソースを許可できますポリシー。</target>
        </trans-unit>
        <trans-unit id="0c94c5922cba00a6f423d74692c379c4b5a45de3" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;frame-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; ポリシーには1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="d4df1448fbf4125c9dedf0cb65e25a27cddc8034" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;img-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;img-src&lt;/code&gt; ポリシーでは、1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="95bedd54418ece3d0cc9bc840eec50ca73bd04b1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;manifest-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;manifest-src&lt;/code&gt; ポリシーでは、1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="b1ab57ca6a220519b6bf1112428f33a86176cf91" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;media-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;media-src&lt;/code&gt; ポリシーでは、1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="2e69da8927408051c551ec50a1bc254784fcf5e0" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;script-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;script-src&lt;/code&gt; ポリシーには1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="db657b004d9023ddfd0f626de17ba73007526d9f" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;style-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;style-src&lt;/code&gt; ポリシーでは、1つ以上のソースを許可できます。</target>
        </trans-unit>
        <trans-unit id="482d29a7e2a3ad999de3eaccec198f96895c6c4b" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;worker-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;worker-src&lt;/code&gt; ポリシーで1つ以上のソースを許可できます：</target>
        </trans-unit>
        <trans-unit id="03175b17a2f8591861f06a407654d0deac74f4ce" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the child-src policy:</source>
          <target state="translated">子srcポリシーでは、1つ以上のソースを許可することができます。</target>
        </trans-unit>
        <trans-unit id="c2abb90bd1216bb48e062c09ced50f4e78627b20" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the connect-src policy:</source>
          <target state="translated">connect-srcポリシーでは、1つ以上のソースを許可することができます。</target>
        </trans-unit>
        <trans-unit id="dd38d0ca560fb98a1494ecf0e9a7973691560553" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the object-src policy:</source>
          <target state="translated">object-srcポリシーでは、1つ以上のソースを許可することができます。</target>
        </trans-unit>
        <trans-unit id="d617d27a877454aafa7fdb2c25048b068c100553" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;form-action&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;form-action&lt;/code&gt; ポリシーには、1つ以上のソースを設定できます。</target>
        </trans-unit>
        <trans-unit id="614e797f67ee3998c43d2279b0efb9b69d35d0b7" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;frame-ancestors&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; ポリシーには、1つ以上のソースを設定できます。</target>
        </trans-unit>
        <trans-unit id="440e37e5146514a1b09e389a18211dea7ea8dac6" translate="yes" xml:space="preserve">
          <source>Only a few image types are widely recognized enough to be safe for use in a Web page:</source>
          <target state="translated">Webページでの使用が安全であると広く認識されている画像の種類はわずかです。</target>
        </trans-unit>
        <trans-unit id="728dfd233770caccb04ac6af9ed8ff6472ef3733" translate="yes" xml:space="preserve">
          <source>Only from Firefox 11 onwards.</source>
          <target state="translated">Firefox 11以降のみ。</target>
        </trans-unit>
        <trans-unit id="7aa6633a592e629108d330108c9845898ccefcf7" translate="yes" xml:space="preserve">
          <source>Only if freshness information is included</source>
          <target state="translated">鮮度情報が含まれている場合のみ</target>
        </trans-unit>
        <trans-unit id="923411c2bc01cfda42c24f6cd8d7e71d494b59bb" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer in all cases.</source>
          <target state="translated">すべての場合において、文書の原本のみを参照元として送信してください。</target>
        </trans-unit>
        <trans-unit id="504a19ebb593f19f5c15be75bd6a14b10d61cc2c" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), but don't send it to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">プロトコルのセキュリティレベルが同じ（HTTPS&amp;rarr;HTTPS）の場合にのみ、ドキュメントの送信元を参照元として送信します。安全性の低い宛先（HTTPS&amp;rarr;HTTP）には送信しません。</target>
        </trans-unit>
        <trans-unit id="2dee33c23ec83af1e9b47f42ab34f35452828624" translate="yes" xml:space="preserve">
          <source>Only the first parameter is mandatory. Either the second, the third, or both may be left out.</source>
          <target state="translated">最初のパラメータのみ必須です。2 番目、3 番目、または両方を省略することができます。</target>
        </trans-unit>
        <trans-unit id="d6d87b3098d93fe460f69fc84cf084280f871953" translate="yes" xml:space="preserve">
          <source>Open a TCP connection: The TCP connection will be used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.</source>
          <target state="translated">TCP接続を開きます。TCP 接続は、リクエストを送信したり、複数のリクエストを送信したり、応答を受信したりするために使用されます。クライアントは、新しい接続を開くか、既存の接続を再利用するか、サーバへの複数のTCP接続を開くことができます。</target>
        </trans-unit>
        <trans-unit id="075672a8517397eeef73c16b7924c5637eb3e6f7" translate="yes" xml:space="preserve">
          <source>OpenDocument presentation document</source>
          <target state="translated">オープンドキュメントプレゼンテーション文書</target>
        </trans-unit>
        <trans-unit id="9c8c7fbf48609de1ffb436774d400bc486986b1e" translate="yes" xml:space="preserve">
          <source>OpenDocument spreadsheet document</source>
          <target state="translated">OpenDocument スプレッドシート文書</target>
        </trans-unit>
        <trans-unit id="ae259e53c368ebd11d83ff7013840fd030bc4e12" translate="yes" xml:space="preserve">
          <source>OpenDocument text document</source>
          <target state="translated">オープンドキュメントテキスト文書</target>
        </trans-unit>
        <trans-unit id="b15775ed71872d7bda87125462ecf55ba4b4a044" translate="yes" xml:space="preserve">
          <source>OpenType font</source>
          <target state="translated">OpenTypeを行う</target>
        </trans-unit>
        <trans-unit id="19c9c9ed8477a3a275bcf0fa3f27c69151b58b7d" translate="yes" xml:space="preserve">
          <source>Opera</source>
          <target state="translated">Opera</target>
        </trans-unit>
        <trans-unit id="ea83f20e4af1c088f0ff12d9f40107e1fae7cd91" translate="yes" xml:space="preserve">
          <source>Opera 11.10</source>
          <target state="translated">オペラ11.10</target>
        </trans-unit>
        <trans-unit id="94504c9918ec0e2b645287a73d2e76cbf6604f4e" translate="yes" xml:space="preserve">
          <source>Opera UA string</source>
          <target state="translated">オペラUA文字列</target>
        </trans-unit>
        <trans-unit id="4497b69b3e58a8b8c4ab04b8430dd1bf6b9df545" translate="yes" xml:space="preserve">
          <source>Opera for Android</source>
          <target state="translated">Android用Opera</target>
        </trans-unit>
        <trans-unit id="256d43d577a1728bc1dc921d68a8fa6c2b037086" translate="yes" xml:space="preserve">
          <source>Opera/9.80 (Android 2.3.3; Linux; Opera Mobi/ADR-1111101157; U; es-ES) Presto/2.9.201 Version/11.50</source>
          <target state="translated">Opera/9.80 (Android 2.3.3;Linux;Opera Mobi/ADR-1111101157;U;es-ES)Presto/2.9.201 Version/11.50</target>
        </trans-unit>
        <trans-unit id="d21816adfc84e4894b30f5b80678333d5c37dce9" translate="yes" xml:space="preserve">
          <source>Opera/xyz</source>
          <target state="translated">Opera/xyz</target>
        </trans-unit>
        <trans-unit id="08a9921e90aae36fdabfc9ba080c0517a0f9df35" translate="yes" xml:space="preserve">
          <source>Opera/xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">Opera / xyz &lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="793b3dcdefb9f6d9d75d16cae958fafb4b6cc0a0" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt; that convey additional information for the servers.</source>
          <target state="translated">サーバーの追加情報を伝えるオプションの&lt;a href=&quot;headers&quot;&gt;ヘッダー&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b489d6278596ad8cbce00fb97015da3fdf24a162" translate="yes" xml:space="preserve">
          <source>Optional upgrade</source>
          <target state="translated">オプションアップグレード</target>
        </trans-unit>
        <trans-unit id="39c86106a7fb30538fb6bf0bd6b42312db26ab4c" translate="yes" xml:space="preserve">
          <source>Optional. If more than one &lt;code&gt;Warning&lt;/code&gt; header is sent, include a date that matches the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">オプション。複数の場合は &lt;code&gt;Warning&lt;/code&gt; ヘッダが送信され、一致した日付が含ま&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;ヘッダを。</target>
        </trans-unit>
        <trans-unit id="f6070787c35a58d9bea898c231c2152bcd0af813" translate="yes" xml:space="preserve">
          <source>Optional. The name of the protocol used, such as &quot;HTTP&quot;.</source>
          <target state="translated">省略可能です。HTTP&quot; のような、使用するプロトコルの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="38b7579808079b250ea2022859caac9497170a85" translate="yes" xml:space="preserve">
          <source>Optionally, a body containing the fetched resource.</source>
          <target state="translated">オプションで、取得したリソースを含むボディ。</target>
        </trans-unit>
        <trans-unit id="eb46e915c8c19f6af68e7a6bdae7009a1807f316" translate="yes" xml:space="preserve">
          <source>Or a body, for some methods like &lt;code&gt;POST&lt;/code&gt;, similar to those in responses, which contain the resource sent.</source>
          <target state="translated">または、送信されたリソースを含む、応答のメソッドと同様の &lt;code&gt;POST&lt;/code&gt; などの一部のメソッドの本体。</target>
        </trans-unit>
        <trans-unit id="e2b445db4463b9f0e28207704251d3ed52ff3148" translate="yes" xml:space="preserve">
          <source>Or by using the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt;&lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">または、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt; &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;要素で &lt;code&gt;referrerpolicy&lt;/code&gt; 属性を使用します。</target>
        </trans-unit>
        <trans-unit id="5cb1a52345d3e8948ce99c302fcc32162e6809d7" translate="yes" xml:space="preserve">
          <source>Or the de-facto standard versions:</source>
          <target state="translated">デファクトスタンダード版とか</target>
        </trans-unit>
        <trans-unit id="3faf8dc540861f535e93a1016c4c11a4d714285a" translate="yes" xml:space="preserve">
          <source>Order of precedence</source>
          <target state="translated">優先順位</target>
        </trans-unit>
        <trans-unit id="44ab85a252adb7ade8ca36fec4157a862c1f725f" translate="yes" xml:space="preserve">
          <source>Origin</source>
          <target state="translated">Origin</target>
        </trans-unit>
        <trans-unit id="290335c298a77e839fe785e3a86ced4673d12093" translate="yes" xml:space="preserve">
          <source>Origin servers frequently make use of their local file system to
   manage the mapping from effective request URI to resource
   representations.  Most file systems are not designed to protect
   against malicious file or path names.  Therefore, an origin server
   needs to avoid accessing names that have a special significance to
   the system when mapping the request target to files, folders, or
   directories.

   For example, UNIX, Microsoft Windows, and other operating systems use
   &quot;..&quot; as a path component to indicate a directory level above the
   current one, and they use specially named paths or file names to send
   data to system devices.  Similar naming conventions might exist
   within other types of storage systems.  Likewise, local storage
   systems have an annoying tendency to prefer user-friendliness over
   security when handling invalid or unexpected characters,
   recomposition of decomposed characters, and case-normalization of
   case-insensitive names.

   Attacks based on such special names tend to focus on either denial-
   of-service (e.g., telling the server to read from a COM port) or
   disclosure of configuration and source files that are not meant to be
   served.</source>
          <target state="translated">オリジンサーバーは、有効なリクエストURIからリソース表現へのマッピングを管理するために、ローカルファイルシステムを頻繁に利用しています。ほとんどのファイルシステムは、悪意のあるファイル名やパス名から保護するように設計されていません。そのため、オリジンサーバーは、リクエストターゲットをファイル、フォルダ、ディレクトリにマッピングする際に、システムにとって特別な意味を持つ名前にアクセスしないようにする必要があります。例えば、UNIX、Microsoft Windows、その他のオペレーティングシステムでは、現在のディレクトリより上のレベルを示すパスコンポーネントとして「...」を使用しており、システムデバイスにデータを送信するために特別な名前のパスやファイル名を使用しています。同様の命名規則は、他のタイプのストレージシステムにも存在する可能性があります。同様に、ローカルストレージシステムは、無効な文字や予期せぬ文字、分解された文字の再構成、大文字小文字を区別しない名前の大文字小文字の正規化を扱う際に、セキュリティよりも使いやすさを優先する厄介な傾向があります。このような特別な名前に基づく攻撃は、サービス拒否(例えば、サーバにCOMポートからの読み込みを指示する)か、あるいは、提供されることを意図していない設定ファイルやソースファイルの開示に焦点を当てる傾向があります。</target>
        </trans-unit>
        <trans-unit id="39574fdeedd527e498bc8ce3b971e8f064927c65" translate="yes" xml:space="preserve">
          <source>Origin servers often use parameters within the URI as a means of
   identifying system services, selecting database entries, or choosing
   a data source.  However, data received in a request cannot be
   trusted.  An attacker could construct any of the request data
   elements (method, request-target, header fields, or body) to contain
   data that might be misinterpreted as a command, code, or query when
   passed through a command invocation, language interpreter, or
   database interface.

   For example, SQL injection is a common attack wherein additional
   query language is inserted within some part of the request-target or
   header fields (e.g., Host, Referer, etc.).  If the received data is
   used directly within a SELECT statement, the query language might be
   interpreted as a database command instead of a simple string value.
   This type of implementation vulnerability is extremely common, in
   spite of being easy to prevent. 

   In general, resource implementations ought to avoid use of request
   data in contexts that are processed or interpreted as instructions.
   Parameters ought to be compared to fixed strings and acted upon as a
   result of that comparison, rather than passed through an interface
   that is not prepared for untrusted data.  Received data that isn't
   based on fixed parameters ought to be carefully filtered or encoded
   to avoid being misinterpreted.

   Similar considerations apply to request data when it is stored and
   later processed, such as within log files, monitoring tools, or when
   included within a data format that allows embedded scripts.</source>
          <target state="translated">オリジンサーバーは、システムサービスを識別したり、データベースエントリを選択したり、データソースを選択したりする手段として、URI内のパラメータを使用することがよくあります。しかし、リクエストで受け取ったデータは信頼できない。攻撃者はリクエストデータ要素(メソッド、リクエストターゲット、ヘッダーフィールド、ボディ)のいずれかを構築して、コマンド呼び出し、言語インタープリター、データベースインターフェースを介して渡されたときに、コマンド、コード、クエリと誤解される可能性のあるデータを含むようにすることができます。例えば、SQLインジェクションは一般的な攻撃であり、追加のクエリ言語がリクエストターゲットやヘッダーフィールドの一部(ホスト、リファラーなど)に挿入されます。受信したデータがSELECT文の中で直接使用されている場合、クエリ言語が単純な文字列の値ではなく、データベースのコマンドとして解釈される可能性があります。この種の実装の脆弱性は、防ぐのは簡単ですが、非常に一般的です。一般的に、リソースの実装では、処理されたり命令として解釈されたりするコンテキストでのリクエストデータの使用は避けるべきです。パラメータは、信頼されないデータのために準備されていないインタフェースを通過させるのではなく、固定の文字列と比較され、その比較の結果として処理されるべきです。固定パラメータに基づいていない受信データは、誤解されないように慎重にフィルタリングされるか、エンコードされるべきです。同様の考慮事項は、ログファイル、監視ツール、スクリプトを埋め込むことができるデータフォーマットに含まれている場合など、保存された後に処理されるリクエストデータにも適用されます。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="f2f4c2c9ebacb9837f6d36a5f8a3b8e0b622d3aa" translate="yes" xml:space="preserve">
          <source>Other Gecko-based browsers</source>
          <target state="translated">その他の Gecko ベースのブラウザ</target>
        </trans-unit>
        <trans-unit id="a9f706611dc18f06545758348b461f7f0adb2b15" translate="yes" xml:space="preserve">
          <source>Other Range Units (RFC 7233)</source>
          <target state="translated">その他のレンジ単位 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="c3ce9f69b8cfd7c68b552621813174d43df7c2b9" translate="yes" xml:space="preserve">
          <source>Other directives</source>
          <target state="translated">その他の指令</target>
        </trans-unit>
        <trans-unit id="625b9f557aeca38bef04ac2454ddfa89b0a0c358" translate="yes" xml:space="preserve">
          <source>Other headers may be required depending on the requested protocol; for example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket&lt;/a&gt; upgrades allow additional headers to configure details about the WebSocket connection as well as to offer a degree of security in opening the connection. See &lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;Upgrading to a WebSocket connection&lt;/a&gt; for more details.</source>
          <target state="translated">要求されたプロトコルによっては、他のヘッダーが必要になる場合があります。たとえば、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocketの&lt;/a&gt;アップグレードでは、追加のヘッダーでWebSocket接続に関する詳細を構成したり、接続を開く際にある程度のセキュリティを提供したりできます。詳細について&lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;は、WebSocket接続へのアップグレードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="85ebef3f22c7ab64a892270dec3fa2ec5f09eb93" translate="yes" xml:space="preserve">
          <source>Other kinds of images can be found in Web documents. For example, many browsers support ICO images for favicons with the &lt;code&gt;image/x-icon&lt;/code&gt; MIME type.</source>
          <target state="translated">他の種類の画像はWeb文書にあります。たとえば、多くのブラウザは、 &lt;code&gt;image/x-icon&lt;/code&gt; MIMEタイプのファビコンのICOイメージをサポートしています。</target>
        </trans-unit>
        <trans-unit id="7ab593da14a28bf9d35c50c2c46a830c857de1cc" translate="yes" xml:space="preserve">
          <source>Other methods of conveying document type</source>
          <target state="translated">文書の種類を伝える他の方法</target>
        </trans-unit>
        <trans-unit id="996796a4631242928596cc5bcca3b11a2ae12348" translate="yes" xml:space="preserve">
          <source>Other non-standard forms:</source>
          <target state="translated">その他の標準外のフォーム。</target>
        </trans-unit>
        <trans-unit id="c72c6b541f8af743f2c407a4401af9c3f96dae91" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">その他の同様のヘッダー：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b84d6d36913561f68541fe18676efd3d770dbda0" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">その他の同様のヘッダー：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d85834ec62e00c548dc17fc4f00c0165fdd2bae" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">その他の同様のヘッダー：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38408917877ccb7a2526344ef45c30543e381d4f" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">その他の同様のヘッダー：&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6cfd07479f00708fdf4d74f365c52cc07a8f329" translate="yes" xml:space="preserve">
          <source>Others &lt;em&gt;changed&lt;/em&gt; to &lt;code&gt;GET&lt;/code&gt; (body lost).</source>
          <target state="translated">その他 &lt;em&gt;は&lt;/em&gt; &lt;code&gt;GET&lt;/code&gt; （ボディロスト）に&lt;em&gt;変更され&lt;/em&gt;ました。</target>
        </trans-unit>
        <trans-unit id="82d2325236dcdd66d736da750430f95549e17f4d" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">その他は&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;に変更される場合とされない場合があります。&lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87489c6b3237d9c5e336cbbf949df80f405e54e2" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">その他は&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;に変更される場合とされない場合があります。&lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1389ad925826fb57f506c6950b9975e96c5e84ae" translate="yes" xml:space="preserve">
          <source>Over the years, Web pages have become much more complex, even becoming applications in their own right. The amount of visual media displayed, the volume and size of scripts adding interactivity, has also increased: much more data is transmitted over significantly more HTTP requests. HTTP/1.1 connections need requests sent in the correct order. Theoretically, several parallel connections could be used (typically between 5 and 8), bringing considerable overhead and complexity. For example, HTTP pipelining has emerged as a resource burden in Web development.</source>
          <target state="translated">長年の間に、Web ページはより複雑になり、それ自体がアプリケーションになっていることさえあります。表示されるビジュアルメディアの量、インタラクティブ性を追加するスクリプトの量とサイズも増加しています。HTTP/1.1 接続では、正しい順序でリクエストが送信される必要があります。理論的には、複数の並列接続を使用することができ(通常は 5 から 8 の間)、かなりのオーバーヘッドと複雑さをもたらします。例えば、HTTP パイプラインは、Web 開発におけるリソースの負担として浮上してきました。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
