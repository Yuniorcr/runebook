<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="6e87f450714558ddb50d4bdf7e4d02acfacfb264" translate="yes" xml:space="preserve">
          <source>K.3.5.3.4 The scanf_s function (p: 594)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789e700cdb056e52650a78ffa7fdcd4d711d4c90" translate="yes" xml:space="preserve">
          <source>K.3.5.3.5 The snprintf_s function (p: 594-595)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec459a09b0d7bf62927a3c6c03058ef3c475490d" translate="yes" xml:space="preserve">
          <source>K.3.5.3.6 The sprintf_s function (p: 595-596)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68bafb6cc05e813c7f39b2f6b9b895c7d94f70" translate="yes" xml:space="preserve">
          <source>K.3.5.3.7 The sscanf_s function (p: 596)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce73aed86cc95200661f9dc87486af047adc7f7a" translate="yes" xml:space="preserve">
          <source>K.3.5.3.8 The vfprintf_s function (p: 597)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8183f464d0e63241e650e285fcfd517d76535f" translate="yes" xml:space="preserve">
          <source>K.3.5.3.9 The vfscanf_s function (p: 597-598)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f175b171b13547422ef67d14d58ff0f4d5c1b8" translate="yes" xml:space="preserve">
          <source>K.3.5.4.1 The gets_s function (p: 602-603)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c71637fd1d2fa3723fc4985f8e03b0fc94cfb62" translate="yes" xml:space="preserve">
          <source>K.3.6 General utilities &amp;lt;stdlib.h&amp;gt; (p: 604-614)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1853d466f01670eef0dc9469c32e91913106f8ca" translate="yes" xml:space="preserve">
          <source>K.3.6 General utilities &amp;lt;stdlib.h&amp;gt; (p: 604=613)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4a32cc691240ce6a364732f86d836d6c4813f2" translate="yes" xml:space="preserve">
          <source>K.3.6.1.1 The set_constraint_handler_s function (p: 604-605)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc3e9b4cbb40ceb3c08abdf4c641b24ce637bfb" translate="yes" xml:space="preserve">
          <source>K.3.6.1.2 The abort_handler_s function (p: 605)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac51d467d3fe5b75925e89230eac9afbcb4b7a41" translate="yes" xml:space="preserve">
          <source>K.3.6.1.3 The ignore_handler_s function (p: 606)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a153aa31649e584fa3aa0cdd1870196b2aac34" translate="yes" xml:space="preserve">
          <source>K.3.6.2.1 The getenv_s function (p: 606-607)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eb68853eda78c54e6d2165678c810a61fbc5bd" translate="yes" xml:space="preserve">
          <source>K.3.6.3 Searching and sorting utilities (p: 607-609)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2447eeafadd707728e3ec0fc997a1d5e02f947" translate="yes" xml:space="preserve">
          <source>K.3.6.3.1 The bsearch_s function (p: 608-609)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071def6c5848242d761260e18c66053308fb0ffd" translate="yes" xml:space="preserve">
          <source>K.3.6.3.2 The qsort_s function (p: 609)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ec3a9d7c22b9e6186fe1c31ed92f75c98cbbe2" translate="yes" xml:space="preserve">
          <source>K.3.6.4.1 The wctomb_s function (p: 610-611)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ddac74181aa6be43c6ccf7928937489b9d50b89" translate="yes" xml:space="preserve">
          <source>K.3.6.5.1 The mbstowcs_s function (p: 611-612)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91c1ce1c61b8a7a232f5183c909039e8572e046" translate="yes" xml:space="preserve">
          <source>K.3.6.5.2 The wcstombs_s function (p: 612-614)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df68d8d1c1e1666360bf066c633dce5fc1a0439" translate="yes" xml:space="preserve">
          <source>K.3.6/2 constraint_handler_t (p: 604)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6aa26de3d10f8bf918d65cf027777f510ceb7c" translate="yes" xml:space="preserve">
          <source>K.3.7 String handling &amp;lt;string.h&amp;gt; (p: 614-623)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb9450a0c112fff38151036c92a1a03833cb268" translate="yes" xml:space="preserve">
          <source>K.3.7.1.1 The memcpy_s function (p: 614)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20a7f113cd1f6cc8e8aae831f18046426eb292a" translate="yes" xml:space="preserve">
          <source>K.3.7.1.2 The memmove_s function (p: 615)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d625555e2107877cd1d5f55ad0eed51ce8a68" translate="yes" xml:space="preserve">
          <source>K.3.7.1.3 The strcpy_s function (p: 615-616)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2251ec9549ddc8252970829d07a0d8c310083f83" translate="yes" xml:space="preserve">
          <source>K.3.7.1.4 The strncpy_s function (p: 616-617)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b694533bcfa6d5497ab90b2276cd602e2a1648fd" translate="yes" xml:space="preserve">
          <source>K.3.7.2.1 The strcat_s function (p: 617-618)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdd8ef2d792e316ba8b77ea6ae4a2d3c896450e" translate="yes" xml:space="preserve">
          <source>K.3.7.2.2 The strncat_s function (p: 618-620)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f9dbdb888b7bd78da3a33e5f6aa7667c065573" translate="yes" xml:space="preserve">
          <source>K.3.7.3.1 The strtok_s function (p: 620-621)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226e29c2e9550018adeac86096597bdb626096a4" translate="yes" xml:space="preserve">
          <source>K.3.7.4.1 The memset_s function (p: 621-622)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88064689249d73b1be81a192ec57cb2df4443c65" translate="yes" xml:space="preserve">
          <source>K.3.7.4.2 The strerror_s function (p: 622)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f6895eac3cdc318252f73cfac0e3a3a2a9cc23" translate="yes" xml:space="preserve">
          <source>K.3.7.4.3 The strerrorlen_s function (p: 623)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928af0362633d94d337208d234fda61b3518bb57" translate="yes" xml:space="preserve">
          <source>K.3.7.4.4 The strnlen_s function (p: 623)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4e424b9344dca1b563535a7ace77afd12944e9" translate="yes" xml:space="preserve">
          <source>K.3.8.2.1 The asctime_s function (p: 624-625)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8abf30b7c4be7fe8bffde7b550daab381bc2c75" translate="yes" xml:space="preserve">
          <source>K.3.8.2.2 The ctime_s function (p: 626)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f3d062cbb348873b72323b698104245b6ff38f" translate="yes" xml:space="preserve">
          <source>K.3.8.2.3 The gmtime_s function (p: 626-627)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ed769dca80ad59951c175492ffaea07e0233d8" translate="yes" xml:space="preserve">
          <source>K.3.8.2.4 The localtime_s function (p: 627)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7d157f04de69b27b90922ed1097b87d5c8bb3d" translate="yes" xml:space="preserve">
          <source>K.3.9 Extended multibyte and wide character utilities &amp;lt;wchar.h&amp;gt; (p: 627-651)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4f9e3cf15aee80375f906c0dabed65db13bd45" translate="yes" xml:space="preserve">
          <source>K.3.9.1.1 The fwprintf_s function (p: 628)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe744ef500ce54120466e37c6ae2cc5ab29e82c" translate="yes" xml:space="preserve">
          <source>K.3.9.1.10 The vswscanf_s function (p: 635-636)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502880aa89a6a0785946780412fcd03fd17c2051" translate="yes" xml:space="preserve">
          <source>K.3.9.1.11 The vwprintf_s function (p: 636)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53007710566eada762e452a854841fdb8357f580" translate="yes" xml:space="preserve">
          <source>K.3.9.1.12 The vwscanf_s function (p: 637)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1230d58e12da08f4567feadb742924e5021dce" translate="yes" xml:space="preserve">
          <source>K.3.9.1.13 The wprintf_s function (p: 637-638)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273b2411e3d65a8f5f205295c6d177937af70a63" translate="yes" xml:space="preserve">
          <source>K.3.9.1.14 The wscanf_s function (p: 638)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2b3ba5b243bbae4fe51b1dd2b5a202269738ed" translate="yes" xml:space="preserve">
          <source>K.3.9.1.2 The fwscanf_s function (p: 628-629)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137994004c1a46c74c679ef5575866ed172dacc1" translate="yes" xml:space="preserve">
          <source>K.3.9.1.4 The swprintf_s function (p: 630-631)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769eca55c93de86903dbcd6f4cfb2e1b5c689c15" translate="yes" xml:space="preserve">
          <source>K.3.9.1.5 The swscanf_s function (p: 631)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2de648711deea69cabe54f013b996cfc22e72c4" translate="yes" xml:space="preserve">
          <source>K.3.9.1.6 The vfwprintf_s function (p: 632)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bdf25171791eaccda96f73b779a24856e10a2c" translate="yes" xml:space="preserve">
          <source>K.3.9.1.7 The vfwscanf_s function (p: 632-633)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615aa61e42f7a2a8514a38517a0f968377c47558" translate="yes" xml:space="preserve">
          <source>K.3.9.1.8 The vsnwprintf_s function (p: 633-634)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed426e860459b960d0c72d2ca62ac34a360b610" translate="yes" xml:space="preserve">
          <source>K.3.9.1.9 The vswprintf_s function (p: 634-635)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912f92fd26cea409882d5e7bd131cfba6200b2dc" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.1 The wcscpy_s function (p: 639)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3798088857cd174819276ae6461939fbe78cbb8" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.2 The wcsncpy_s function (p: 640-641)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95835affd293c9f755435a3c77b71d7a41747145" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.3 The wmemcpy_s function (p: 641)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5079151e71b60b5eaad760afca1e4a4a984131a" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.4 The wmemmove_s function (p: 642)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cab8b141a42c1ac62a4acd1980c718490ef960" translate="yes" xml:space="preserve">
          <source>K.3.9.2.2.1 The wcscat_s function (p: 642-643)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c29ddef322945428621d4992268500a0e16b3e3" translate="yes" xml:space="preserve">
          <source>K.3.9.2.2.2 The wcsncat_s function (p: 643-644)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14fe494f924665909672135ac7e7ee2d4437e21" translate="yes" xml:space="preserve">
          <source>K.3.9.2.3.1 The wcstok_s function (p: 645-646)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946346a0b8853aefe1afe2d8268c33d063bba612" translate="yes" xml:space="preserve">
          <source>K.3.9.2.4.1 The wcsnlen_s function (p: 646-647)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1414308b8b3e8d11cd6e5001748296bf8efee0b" translate="yes" xml:space="preserve">
          <source>K.3.9.3.1.1 The wcrtomb_s function (p: 647-648)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5669cb4eba38db5e11d7e288f5dd15db05e824" translate="yes" xml:space="preserve">
          <source>K.3.9.3.2.1 The mbsrtowcs_s function (p: 648-649)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae163d88834e13877175d6520c8d15a0f6c1324" translate="yes" xml:space="preserve">
          <source>K.3.9.3.2.2 The wcsrtombs_s function (p: 649-651)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="05261e150dc9a967a52c20f567ceb3e59975f528" translate="yes" xml:space="preserve">
          <source>L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4da84710b41fc09dd78f93b82fe6010bab5fd27" translate="yes" xml:space="preserve">
          <source>LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</source>
          <target state="translated">LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="65a740810ab447ffb984bd6fdf5448611bcca5d2" translate="yes" xml:space="preserve">
          <source>LLP64</source>
          <target state="translated">LLP64</target>
        </trans-unit>
        <trans-unit id="bee2cfeb49f65a60be1386935bbd919b5ec97964" translate="yes" xml:space="preserve">
          <source>LP32</source>
          <target state="translated">LP32</target>
        </trans-unit>
        <trans-unit id="6cb8b2a9a5c6dacaca21f4343040021510d35c97" translate="yes" xml:space="preserve">
          <source>LP64</source>
          <target state="translated">LP64</target>
        </trans-unit>
        <trans-unit id="c02a7203aab12b1608aee47e686511f73e6b3f20" translate="yes" xml:space="preserve">
          <source>L_tmpnamL_tmpnam_s</source>
          <target state="translated">L_tmpnamL_tmpnam_s</target>
        </trans-unit>
        <trans-unit id="bb5a8d6c683cb878ad30ae74289c4617f9c766d3" translate="yes" xml:space="preserve">
          <source>Label declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="bdffb77ae44e48c63c181cf7541184b7bfe75b59" translate="yes" xml:space="preserve">
          <source>Left-to-right</source>
          <target state="translated">Left-to-right</target>
        </trans-unit>
        <trans-unit id="12941d0eb9ed4aeacc52d5f00426e066fee74e7d" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;P&lt;/code&gt; equal the precision if nonzero, &lt;code&gt;6&lt;/code&gt; if the precision is not specified, or &lt;code&gt;1&lt;/code&gt; if the precision is &lt;code&gt;​0​&lt;/code&gt;. Then, if a conversion with style &lt;code&gt;E&lt;/code&gt; would have an exponent of &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab517382cbd282770e322d606f13389dcbdf3466" translate="yes" xml:space="preserve">
          <source>Letters in the floating constants are case-insensitive: &lt;code&gt;0x1.ep+3&lt;/code&gt; and &lt;code&gt;0X1.EP+3&lt;/code&gt; represent the same floating-point value 15.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d356e16a814f46abee48f7e57ea39a420ad47b27" translate="yes" xml:space="preserve">
          <source>Letters in the integer constants are case-insensitive: &lt;code&gt;0xDeAdBaBeU&lt;/code&gt; and &lt;code&gt;0XdeadBABEu&lt;/code&gt; represent the same number (one exception is the long-long-suffix, which is either &lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;, never &lt;code&gt;lL&lt;/code&gt; or &lt;code&gt;Ll&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd574f10b612abb6aa6363ae6df12c662bce8552" translate="yes" xml:space="preserve">
          <source>Libraries often expose system-dependent or configuration-dependent types as typedef names, to present a consistent interface to the users or to other library components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd31a82199f3f82e503f243280cb3a9f1494489" translate="yes" xml:space="preserve">
          <source>Library functions &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; can be used to obtain textual descriptions of the error conditions that correspond to the current &lt;code&gt;errno&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5389e5e41e9f62464b70b3f701dadbe975b06a27" translate="yes" xml:space="preserve">
          <source>Library implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d4e990c7c024f82a53c553c156bc6a7bc23cbf" translate="yes" xml:space="preserve">
          <source>Library interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d05a85e0ee31a873e2f15997f3ffa7b057cefff" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="7ffbe27d06c2711b64360b6cc0af54313ac75e7f" translate="yes" xml:space="preserve">
          <source>Limits of float types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8bc984a49e87697786db72d2563a91679f73c6" translate="yes" xml:space="preserve">
          <source>Limits of floating point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c715c0e0c866487981ad26eed257940f23ee03" translate="yes" xml:space="preserve">
          <source>Limits of integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134491813a15a70cbab566dc7eb0c3a2ec60c077" translate="yes" xml:space="preserve">
          <source>Limits of library types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27dc31140950c016978fcb4c144b7b2d3cbc47c" translate="yes" xml:space="preserve">
          <source>Linkage</source>
          <target state="translated">Linkage</target>
        </trans-unit>
        <trans-unit id="593cb87e6afd7236782ce8a8a54f462eeca0ab07" translate="yes" xml:space="preserve">
          <source>Linkage and libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae789f2aa7564105d4b6d3e1d9bc4ed98eca017" translate="yes" xml:space="preserve">
          <source>Linkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ece15c35c34a025f6be9bbdbfa6cc77ba902760" translate="yes" xml:space="preserve">
          <source>Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8928ef8834eb7e685d440c092e0ed8717e2bf4" translate="yes" xml:space="preserve">
          <source>Loads the data from locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306845665660271f5edceb9cf305119d107a9b6d" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98547f12140b861f02fc92da40524e3b426e7b6" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bea89bc2ce48c930dc7395bbdbef3f7216a1506" translate="yes" xml:space="preserve">
          <source>Loads the data from the locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe7e57b877b99e83abee299be618072a6caad5" translate="yes" xml:space="preserve">
          <source>Loads the execution context &lt;code&gt;env&lt;/code&gt; saved by a previous call to &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt;. This function does not return. Control is transferred to the call site of the macro &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; that set up &lt;code&gt;env&lt;/code&gt;. That &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; then returns the value, passed as the &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b64c37e179f49fcbc2cadc0fb2d42cd79c4fdd9" translate="yes" xml:space="preserve">
          <source>Local monetary numeric formatting parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9581b06704233639536079ebbf71f9ce8dd59501" translate="yes" xml:space="preserve">
          <source>Local variables within a loop body can hide variables declared in the init clause of a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop in C (their scope is nested), but cannot do that in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd96a752e4d0a667d960bbb03aaebef6e74b78fd" translate="yes" xml:space="preserve">
          <source>Locale categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05b84ddd9396cd687847e09cfc17da5a0c633d6" translate="yes" xml:space="preserve">
          <source>Localization support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07f512f68e601c83a418f3dad591a2645430943" translate="yes" xml:space="preserve">
          <source>Localization utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da3037f457bddb5f51efa198af1cd2aac353e26" translate="yes" xml:space="preserve">
          <source>Locates the first occurrence of wide character &lt;code&gt;ch&lt;/code&gt; in the initial &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array or integer array of compatible type, pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b0d4f6d432f44c251e4f26e3648660c648da8e" translate="yes" xml:space="preserve">
          <source>Logical NOT and bitwise NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f46abd6bf4991635a01cfeaf83140bc77bef5fe" translate="yes" xml:space="preserve">
          <source>Logical operators apply standard boolean algebra operations to their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6b5688fee032f7c152783707dfef40897f3389" translate="yes" xml:space="preserve">
          <source>Lookup and Name Spaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ddfc980de5898f0de50c86f7a81aabd47c6d87" translate="yes" xml:space="preserve">
          <source>Lookup and name spaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3769a18de297ff08768c9476ca9be5fa9f7cb3ea" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b664af18997be219e282a2e63c462404e091a65e" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;wc&lt;/code&gt; or unmodified &lt;code&gt;wc&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25b81442907162aaed9c76cdae20e99101d3c89" translate="yes" xml:space="preserve">
          <source>Lvalue conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012efee4bd10b361cdf0f6d26ced01f343831244" translate="yes" xml:space="preserve">
          <source>Lvalue expression is any expression with &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;object type&lt;/a&gt; other than the type &lt;code&gt;void&lt;/code&gt;, which potentially designates an &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be434e8731c552a88d17d1a8a1c5e732a91ef99" translate="yes" xml:space="preserve">
          <source>Lvalue expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff201b988073267d106686cac6aa02d10f555bec" translate="yes" xml:space="preserve">
          <source>Lvalue expressions can be used in the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850947f3d010de98ad370f2f73bc49ca69c2b7c5" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO</source>
          <target state="translated">MATH_ERRNO</target>
        </trans-unit>
        <trans-unit id="74b7d4ceae8b4d3f14a2b48ce0dd4a45027ad623" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b26b4988457eebaa5d41abd9af85e69645b9b63" translate="yes" xml:space="preserve">
          <source>MB_CUR_MAX</source>
          <target state="translated">MB_CUR_MAX</target>
        </trans-unit>
        <trans-unit id="6bfcb6f4e22f270971b8066d4c18f2a3c153409a" translate="yes" xml:space="preserve">
          <source>MB_LEN_MAX</source>
          <target state="translated">MB_LEN_MAX</target>
        </trans-unit>
        <trans-unit id="0beb871a186f42594bcfbcc8916c8146ec93832e" translate="yes" xml:space="preserve">
          <source>MOESI protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1086b9f1dd6c6f26d36bd306a911dfb2aafce8" translate="yes" xml:space="preserve">
          <source>Macro constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3a11a44726526a8271fd69a51140ab465210aa" translate="yes" xml:space="preserve">
          <source>Macro name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="f314f8acf113225093359e0691186dc638458d3f" translate="yes" xml:space="preserve">
          <source>Macros for data types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba899554a515d485fa28c53abcd1d69078a0360c" translate="yes" xml:space="preserve">
          <source>Macros reporting error conditions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ac70ee360a262794e6e975e302e13279210903" translate="yes" xml:space="preserve">
          <source>Main function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c62a0130255054719e58a94558825165817b75" translate="yes" xml:space="preserve">
          <source>Manipulation</source>
          <target state="translated">Manipulation</target>
        </trans-unit>
        <trans-unit id="448d8cbb56aa359da0ecf466971d54b6d58517dd" translate="yes" xml:space="preserve">
          <source>Many additional errno constants are &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html&quot;&gt;defined by POSIX&lt;/a&gt; and by the &lt;a href=&quot;http://en.cppreference.com/w/cpp/error/errno_macros.html&quot;&gt;C++ standard library&lt;/a&gt;, and individual implementations may define even more, e.g. &lt;code&gt;errno(3)&lt;/code&gt; on Linux or &lt;code&gt;intro(2)&lt;/code&gt; on BSD and OS X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6931c181d5bfb62e03fac75baee4578598fdff18" translate="yes" xml:space="preserve">
          <source>Many compilers provide, as a language extension, the opposite of &lt;code&gt;restrict&lt;/code&gt;: an attribute indicating that pointers may alias even if their types differ: &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Common-Type-Attributes.html#index-g_t_0040code_007bmay_005falias_007d-type-attribute-3667&quot;&gt;may_alias (gcc)&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e739ce5fcc5f3f4b42ffb007f279ffff437b04aa" translate="yes" xml:space="preserve">
          <source>Many implementations also provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers of random origin, e.g. if they are implemented as addresses within continuous (&quot;flat&quot;) virtual address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe6902aeefe49078fe8050bd00528c238507028" translate="yes" xml:space="preserve">
          <source>Maps the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE mapping category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20eb57cf8e0dada9d1ba105b859145de9af95dd7" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic cosine is cosh z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26750d755fd0345482bcbffe431aa399db954d60" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic sine is sinh z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84aec3fc0130942848a9f7d933b06ea09b78dbd" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic tangent is tanh z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d307dd0d56fc9ce2efcd46807c5cc26c88385c1" translate="yes" xml:space="preserve">
          <source>Mathematics argument out of domain of function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95535f5fff56fffd3265c38e515a7ce818f8ca34" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://gcc.godbolt.org/z/JGG6uI&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d91c4e0e5a561cc8bcd98fba8637034e652ffe" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/qoD2uP&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cc72619aac7a4cf0bcebd68e5add9be2ee96a0" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/u9lBlY&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4a3f6dac60ae11f5101c8d958bc4cdaa80179b" translate="yes" xml:space="preserve">
          <source>May produce the following output (observed with an older version of gcc):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab548f533a5dfb3713984e2e04a561874b83b35" translate="yes" xml:space="preserve">
          <source>May result in several characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="d880b0db33396f09e94ad458e37bf499710140d0" translate="yes" xml:space="preserve">
          <source>Member access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f75affe1ded2ede961bf4f202b991666893f21" translate="yes" xml:space="preserve">
          <source>Member access and indirection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9ba14f65379b3cac2135b4415ee8ccd2ae4dbf" translate="yes" xml:space="preserve">
          <source>Member access operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3746cba5e08f53ae8a220d752c07da9da06400d" translate="yes" xml:space="preserve">
          <source>Member access operators allow access to the members of their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7e8ffcea9d076b657afb05ac63f6cdb3840618" translate="yes" xml:space="preserve">
          <source>Member access through pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4037494affff8e1187b4614057e3d3856936fa0" translate="yes" xml:space="preserve">
          <source>Member objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b9af79a08c4c809a8587ce76e5d96c65e611a2" translate="yes" xml:space="preserve">
          <source>Memory location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab97ff6f2dba5d3f1cd5aeb9b43d517c7ff39baa" translate="yes" xml:space="preserve">
          <source>Memory model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32fe20c2f36eda870198c7a491e5b2f8a3403333" translate="yes" xml:space="preserve">
          <source>Memory model and Data races</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b03cc66f3ec38d27d0315d16067b31e093e9aea" translate="yes" xml:space="preserve">
          <source>Memory order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dddb5186287e21994356577aa0866b4c1d8ea3" translate="yes" xml:space="preserve">
          <source>Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;discarded the input buffer&lt;/a&gt;, in Visual Studio 2015 and newer, it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;has no effect, buffers are retained&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="3ce8b4533320109cd04f4470828d9c5df9d7e9f9" translate="yes" xml:space="preserve">
          <source>Modifiable lvalue expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3cc44d73da07886ee8baef1ee867321f0ada02" translate="yes" xml:space="preserve">
          <source>Modifying the object references through the returned pointer is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfc8aea76355cffda7dc26e5f6ffed8b15e2998" translate="yes" xml:space="preserve">
          <source>Modifying the string returned by &lt;code&gt;getenv&lt;/code&gt; invokes undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba486ce8a0bc9ff868847c4d17e3966a68af4067" translate="yes" xml:space="preserve">
          <source>Monetary numeric formatting parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="e62a8c15144afd6bef7aa39651c138fe6e1aae25" translate="yes" xml:space="preserve">
          <source>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f8d7e56567813ec670a96434271711fd5ba5ee" translate="yes" xml:space="preserve">
          <source>Most statements in a typical C program are expression statements, such as assignments or function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55336fdb98f11cedfd0e48efbdbb786db1d30e0" translate="yes" xml:space="preserve">
          <source>Moves the file position indicator to the beginning of the given file stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737f5043d52ad9a5bf99e386e8ced8ff5c737ec0" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c9d2fed20c35b9815e377cad73f06efe9e5a37" translate="yes" xml:space="preserve">
          <source>Multicharacter constants were inherited by C from the B programming language. Although not specified by the C standard, compilers implement multicharacter constants as specified in B: the values of each char in the constant initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of &lt;code&gt;'\1'&lt;/code&gt; is &lt;code&gt;0x00000001&lt;/code&gt; and the value of &lt;code&gt;'\1\2\3\4'&lt;/code&gt; is &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aab5fbc4c12aae804f94ed1d461c1801fe8cbc3" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays may be variably modified in every dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454f13662bebbfb41c67ae8683c94844b3620fc0" translate="yes" xml:space="preserve">
          <source>Multiple adjacent bit fields are permitted to be (and usually are) packed together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="3385a32109aa5346add0ca1e71e6f6b9c5a102b4" translate="yes" xml:space="preserve">
          <source>Multiplication, division, and remainder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1863d77d06e578e88a57a55375c7c7a23d1f8f" translate="yes" xml:space="preserve">
          <source>Multiplicative operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0363fa62bd61d022ffc95530b594214943aa388" translate="yes" xml:space="preserve">
          <source>Mutual exclusion locks, such as &lt;a href=&quot;../thread#Mutual_exclusion&quot;&gt;mutexes&lt;/a&gt; or &lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;atomic spinlocks&lt;/a&gt;, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="c3fd46dfa19a7c79969c89f9ce44fe302c2a8a35" translate="yes" xml:space="preserve">
          <source>NaN values never compare equal to themselves or to other NaN values. Copying a NaN may change its bit pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f58f34ad9177ffaac728689bdd4d10c1855a024" translate="yes" xml:space="preserve">
          <source>Names at file scope that are &lt;code&gt;const&lt;/code&gt; and not &lt;code&gt;extern&lt;/code&gt; have external linkage in C (as the default for all file-scope declarations), but internal linkage in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8655490bdfd99b50e55540721bde65050a10ca66" translate="yes" xml:space="preserve">
          <source>Narrow and wide orientation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f5cbdcb5ba2c44829f73b263418c7c018a552d" translate="yes" xml:space="preserve">
          <source>Narrow character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4742e8a9730fb2d9ea65a3e7a57cdd49ba4360" translate="yes" xml:space="preserve">
          <source>Narrows a wide character &lt;code&gt;c&lt;/code&gt; if its multibyte character equivalent in the initial shift state is a single byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f16ffe8ceea800ccba7f7bd10fa080ec5a0a67" translate="yes" xml:space="preserve">
          <source>Nearest integer floating-point operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfaab505f47d58982ff129c9d7d12a74d6eb3cc8" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; appears before &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87491531316873a8136087161a4d5513bf956b22" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282e0a77a7206269a1ec03af267a85cf22416793" translate="yes" xml:space="preserve">
          <source>Negative value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is less than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;lhs&lt;/code&gt; precedes &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8f16b0eb3587cc0715dedcfccca0caab77a9f2" translate="yes" xml:space="preserve">
          <source>Nested arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5ce0ad5f2d33fb3c44feeea906ae1d01efd7ba" translate="yes" xml:space="preserve">
          <source>Nested initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fdd1c5c202bebe38d3641541a2e30d93452185" translate="yes" xml:space="preserve">
          <source>Nested scopes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01117481b3d9ae41aba5fe6ef84e04f5a4c5d0b0" translate="yes" xml:space="preserve">
          <source>No floating-point exceptions are raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16941a37d8867c9031785f74d58aab34ae39bbe3" translate="yes" xml:space="preserve">
          <source>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57a8139ba5f8ff1aec908ab19000c109132ce91" translate="yes" xml:space="preserve">
          <source>No other guarantees are offered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ec929c8a01c87825d8f15fd43b7f0878d5d529" translate="yes" xml:space="preserve">
          <source>No two type-names in the association-list may specify &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible types&lt;/a&gt;. There may be only one association that uses the keyword &lt;code&gt;default&lt;/code&gt;. If &lt;code&gt;default&lt;/code&gt; is not used and none of the type-names are compatible with the type of the controlling expression, the program will not compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411e6d0559351d7469db7694555ed7a0f5389c12" translate="yes" xml:space="preserve">
          <source>Non-VLA &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; can be repeated as long as it names the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193bc621c98ae221eaef288f8d181a1b34a9f35d" translate="yes" xml:space="preserve">
          <source>Non-local jumps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa36cd478bb4344736c7959a40d7f343ded79e2" translate="yes" xml:space="preserve">
          <source>Non-lvalue object expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28af95d5aac585ab47289daeae8748e967982758" translate="yes" xml:space="preserve">
          <source>Non-monetary numeric formatting parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bf8a2db4b645a79c4849be1f959268b928c0e2" translate="yes" xml:space="preserve">
          <source>Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72624912ab07ac9814916ad08bbf7c1a7f1d9b97" translate="yes" xml:space="preserve">
          <source>Non-standard pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da7e44ba455476d241318f01d6d22076a05a3c6" translate="yes" xml:space="preserve">
          <source>Non-zero if the character &lt;code&gt;wc&lt;/code&gt; has the property identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eeb598af710e2098a61e3ed6c93e3c8ce594b9" translate="yes" xml:space="preserve">
          <source>Non-zero value if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac3d852cb68231a437ace85c2c4a8c49a18a927" translate="yes" xml:space="preserve">
          <source>Non-zero value if a non-local jump was just performed. The return value is the same as passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900ee6797efd5e52fdc75d73717ea25ebb3e309c" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character can be printed, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f11f572546e4bec188a078d2a9e68b51039891" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character has a graphical representation character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a7dd58e4b2983a42eee0bbc242681d141522e1" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a blank character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573c2f1c1338c5749b009db6f886cc21167460ad" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a control character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645b6766f8a577c38101f8fb20cfb58a2045c32e" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a lowercase letter, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0261c6f4c85b95254a513c02aebf02ec699cc6" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a numeric character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91aea7f894e54ec23e392ad63a4306e917989bd" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a punctuation character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e557296858a7842a41ea087ef4dc7cb9964a42bf" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a whitespace character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739526fe168a72c3c1f6dcbbb361462f93f70e5d" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an alphabetic character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e542ca374323f362fab4f69485d18e59e7d40ec" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an alphanumeric character, &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c4a5067b4fe1c0dcec7c0fdd14829018a9fafe" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an hexadecimal numeric character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb103ab4ed106f58e123123deeaecdec23cd1314" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an uppercase letter, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bce746578de779ccced60e366fe7c795db125a" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character can be printed, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d84021000de30e2a91876134da9368a351dc2" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character has a graphical representation character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545ec9f1b51fd7624d595a810214fcee5cc4ade5" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a alphabetic character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6061e0221ac50001f9c505509407314da40799b9" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a alphanumeric character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ee7958639648ee011e8faa7e9ae18330b62fbb" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a blank character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc06c5d778a941c31c4589906a0d0c89c4244147" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a control character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764367d8a927867322e0b363e253e0c2282b8d92" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a hexadecimal numeric character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5849ae23f0e34f5e3d8fde24b1da25b1eb7db3" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a punctuation character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9704dceccf4f8acbf2dca35e962fbe869f3c4c3" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a whitespace character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6da9a6888802869d6bd527adae2e52402fbd0a" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an lowercase letter, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c907aa58db4cbc21247085765be4eb83901ffdcd" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an numeric character, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3326d07c04286a9aab352ed3d2e8d2c4220c3858" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an uppercase letter, zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="3519f25b9bca3cbf93a434f74b038988d38b8e81" translate="yes" xml:space="preserve">
          <source>Nonlocal jumps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d16e4909a855dfacd2e348d51095c22d8bb698f" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; has an infinite value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83f615f202b09eda83fd6ba33d8c844ea324845" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; has finite value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac09c0914c09c76af0c3a8e33bdfa6f66790b329" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5100fccd71cf98586e448e0183b50c098a585490" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is negative, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997efa8f5cb082b923297ca535f7828db07ffae3" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is normal, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786a61ba2a7fce5ee3e48a622963070d5717764a" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa9e79a7a436cc1b8582355921944221cf323a2" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;gt;= y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3536a068fcc62c3c7ca3479a475715f9b5a76784" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fd0a4307c1864cd327f9b7321b93655d347dbc" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899df7f07b5332bae826ae9835de0e6583359def" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt;= y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37cb3687139ff48af89d9b130a861b9adcda7b9" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a9098a34d521b830e5b13b1b8cab6cf947a729" translate="yes" xml:space="preserve">
          <source>Nonzero value if the file stream has errors occurred, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a995d52089af1ca1c3e17ca5083742ff6c6d197" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;size&lt;/code&gt; bytes will necessarily be used for buffering: the actual buffer size is usually rounded down to a multiple of 2, a multiple of page size, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463ea1aceb837fc90a032c7ce4723b9fe8359f01" translate="yes" xml:space="preserve">
          <source>Not-a-number is converted to &lt;code&gt;nan&lt;/code&gt; or &lt;code&gt;nan(&lt;i&gt;char_sequence&lt;/i&gt;)&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4dae11725fccb85cb2075cf06771887f92e991d7" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt; to _Bool does not work the same as conversion to other integer types: &lt;code&gt;(bool)0.5&lt;/code&gt; evaluates to &lt;code&gt;1&lt;/code&gt;, whereas &lt;code&gt;(int)0.5&lt;/code&gt; evaluates to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfff64c74e2709b14e6d6fc437e2a178f5ae171" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;restrict&quot;&gt;restrict qualifier&lt;/a&gt; can be used to indicate that two pointers do not alias even if the rules above permit them to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ffe676e9f8865c76efc456731aec7949383f5f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; are not promoted to &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; in this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07c8b6bfea785e0db5f4ccd4474b2a63a1f16b3" translate="yes" xml:space="preserve">
          <source>Note that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, the tag would refer to that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f930f4eef330093e341733bd4324d01868d5ef8c" translate="yes" xml:space="preserve">
          <source>Note that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with &lt;a href=&quot;lifetime&quot;&gt;temporary lifetime&lt;/a&gt;. This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd60bc97c60d5c03e64584095b4acd185f943b90" translate="yes" xml:space="preserve">
          <source>Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01d44e3ef167461171814957b8c751bd69c9afc" translate="yes" xml:space="preserve">
          <source>Note that although each atomic object has its own modification order, it is not a total order; different threads may observe modifications to different atomic objects in different orders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277df4ee826d3c674927bd5ba9abb77722d7d23a" translate="yes" xml:space="preserve">
          <source>Note that complex and imaginary numbers cannot be compared with these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e419ce8ad7d59785de3678604706b11b55c334c" translate="yes" xml:space="preserve">
          <source>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71e9d53dd33e221623d7abb59913618429102cb" translate="yes" xml:space="preserve">
          <source>Note that digraphs &lt;code&gt;&amp;lt;%&lt;/code&gt;, &lt;code&gt;%&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;:&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;, &lt;code&gt;%:&lt;/code&gt;, and &lt;code&gt;%:%:&lt;/code&gt; provide an &lt;a href=&quot;language/operator_alternative&quot;&gt;alternative way to represent standard tokens&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa7d9380a3127548e23d156a232aa2b98f7dde7" translate="yes" xml:space="preserve">
          <source>Note that exact-width integer types are available in &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;stdint.h&amp;gt;&lt;/a&gt; since C99.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050cbe6bb8f2ecec5680c9688cca8a67a8af6dcc" translate="yes" xml:space="preserve">
          <source>Note that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3646902728c68bd16b2c1d2a55d86e6f212f0955" translate="yes" xml:space="preserve">
          <source>Note that in C++, it may be an lvalue expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b596689d61367604b043d07793cc89c0d3cc0cc1" translate="yes" xml:space="preserve">
          <source>Note that in the example above, the compiler can infer that a and b do not alias because b's constness guarantees that it cannot become dependent on a in the body of the function. Equivalently, the programmer could write &lt;code&gt;void f(int n, float * a, float const * restrict b)&lt;/code&gt;, in which case the compiler can reason that objects referenced through b cannot be modified, and so no modified object can be referenced using both b and a. If the programmer were to write &lt;code&gt;void f(int n, float * restrict a, float * b)&lt;/code&gt;, the compiler would be unable to infer non-aliasing of a and b without examining the body of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaafe49e51286eb8b5cfca9bc7d1c5b44fb7fcf6" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for c to point into the array associated with b. Note also that, for these purposes, the &quot;array&quot; associated with a particular pointer means only that portion of an array object which is actually referenced through that pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b852cea839a1b80599bd0edd7be9cf7efce4da" translate="yes" xml:space="preserve">
          <source>Note that pointer to pointer to &lt;code&gt;T&lt;/code&gt; is not convertible to pointer to pointer to &lt;code&gt;const T&lt;/code&gt;; for two types to be compatible, their qualifications must be identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ed914c55a7126dc453874f1a9b4149e50132aa" translate="yes" xml:space="preserve">
          <source>Note that pointer to pointer to &lt;code&gt;T&lt;/code&gt; is not convertible to pointer to pointer to &lt;code&gt;volatile T&lt;/code&gt;; for two types to be compatible, their qualifications must be identical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304781606b6f8eeefe2f140ee18862708a266ab6" translate="yes" xml:space="preserve">
          <source>Note that the contents of such array are modifiable, unlike when accessing a string literal directly with &lt;code&gt;char* str = &quot;abc&quot;;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417346c937dfa81f169a04d968f4db2fc8fe6333" translate="yes" xml:space="preserve">
          <source>Note that the standard library also defines &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names &lt;a href=&quot;../string/wide&quot;&gt;wchar_t&lt;/a&gt;, &lt;a href=&quot;../string/multibyte&quot;&gt;char16_t&lt;/a&gt;, and &lt;a href=&quot;../string/multibyte&quot;&gt;char32_t&lt;/a&gt;(since C11) to represent wide characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724173281ae1d1521f2609a2c1a14d6bf54b76fc" translate="yes" xml:space="preserve">
          <source>Note that this means that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6a22f454209a070f818f1ea2da7aab6744c121" translate="yes" xml:space="preserve">
          <source>Note that type-punning may also be performed through the inactive member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272825862d0d9765b3754c8f08a0652223d11df8" translate="yes" xml:space="preserve">
          <source>Note that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca90d82823999bf34354e86f9433c4064c7150b" translate="yes" xml:space="preserve">
          <source>Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5166123be3426460855c992d1da6919d6a02ca19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#elif cond2&lt;/code&gt; is different from &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#else&lt;/code&gt; followed by &lt;code&gt;#if cond3&lt;/code&gt; because if &lt;code&gt;cond1&lt;/code&gt; is true, the second &lt;code&gt;#if&lt;/code&gt; is skipped and &lt;code&gt;cond3&lt;/code&gt; does not need to be well-formed, while #elif's &lt;code&gt;cond2&lt;/code&gt; must be a valid expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca7ee7ab9924b43dc53d9b7f8ccf0ae16496091" translate="yes" xml:space="preserve">
          <source>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b6534f42776f23d640b14fa30e953bf2bc1b64" translate="yes" xml:space="preserve">
          <source>Note: Some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when __VA_ARGS__ is non-empty, but removes the comma when __VA_ARGS__ is empty: this makes it possible to define macros such as &lt;code&gt;fprintf (stderr, format, ##__VA_ARGS__)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d231be462c294806918af9e22c37b9971c1d8b74" translate="yes" xml:space="preserve">
          <source>Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers &lt;a href=&quot;../types/limits&quot;&gt;&amp;lt;limits.h&amp;gt; and &amp;lt;float.h&amp;gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c92dc308476060211154a0baf7bae96183bba65" translate="yes" xml:space="preserve">
          <source>Note: additional functions whose names begin with either &lt;code&gt;to&lt;/code&gt; or &lt;code&gt;is&lt;/code&gt;, followed by a lowercase letter, may be added to the header &lt;code&gt;ctype.h&lt;/code&gt; in future and should not be defined by programs that include that header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926a7e324c567bbf83cd5f49fda69e0a32e1eb6e" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long double&lt;/code&gt;, and even &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long&lt;/code&gt; name the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589f92f64734a58912f07f2dac91d32f1c36f85e" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long double&lt;/code&gt;, and even &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long&lt;/code&gt; name the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92ba3582f1b92874cad067dae19867ad7796a3" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;unsigned long long int&lt;/code&gt; and &lt;code&gt;long int unsigned long&lt;/code&gt; name the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1622c785b61daa41df5a69c20ba3e7bfde746" translate="yes" xml:space="preserve">
          <source>Note: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;, &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dca76e38dc760fa729353052e71a1192b1a1490" translate="yes" xml:space="preserve">
          <source>Note: besides initializers, brace-enclosed initializer-list may appear in &lt;a href=&quot;compound_literal&quot;&gt;compound literals&lt;/a&gt;, which are expressions of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd0a9d1f8d4e684125f4debf7e7f5433e62ff46" translate="yes" xml:space="preserve">
          <source>Note: bitwise operators are commonly used to manipulate bit sets and bit masks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13c8466c8ce25f60aa85ce07edd1bf30bff1ea5" translate="yes" xml:space="preserve">
          <source>Note: compilers that do not support these pragmas may provide equivalent compile-time options, such as gcc's &lt;code&gt;-fcx-limited-range&lt;/code&gt; and &lt;code&gt;-ffp-contract&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fc6a0060bd483695677ce701ffb0cb3626cc76" translate="yes" xml:space="preserve">
          <source>Note: despite that, imaginary types are distinct and &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;not compatible&lt;/a&gt; with their corresponding real types, which prohibits aliasing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df687f33e33fab93be5f7bb11d3398add8728aa2" translate="yes" xml:space="preserve">
          <source>Note: for unsigned types (after promotion), the expression ~E is equivalent to the maximum value representable by the result type minus the original value of E.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef15aa2f5e33223b513a33e4149b80cb3a815a0e" translate="yes" xml:space="preserve">
          <source>Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as &lt;code&gt;macro(array[x = y, x + 1])&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../atomic/atomic_store&quot;&gt;atomic_store&lt;/a&gt; (p, (struct S){ a, b });&lt;/code&gt;), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421adc1b62de6ce817db839aa0b4d3305034e9df" translate="yes" xml:space="preserve">
          <source>Note: implementations of bounds-checked functions are available as open-source libraries &lt;a href=&quot;https://github.com/rurban/safeclib/&quot;&gt;Safe C&lt;/a&gt; and &lt;a href=&quot;https://code.google.com/archive/p/slibc/&quot;&gt;Slibc&lt;/a&gt;, and as part of Watcom C. There is also an incompatible set of bounds-checked functions available in Visual Studio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50933a8d1b61e11b3841762e3c140d8092ad0792" translate="yes" xml:space="preserve">
          <source>Note: in C++, identifiers with a double underscore anywhere are reserved everywhere; in C, only the ones that begin with a double underscore are reserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570f5c242f1a5f12b3ad8de85028df03f68cbc8a" translate="yes" xml:space="preserve">
          <source>Note: in Unicode, the ASCII character block is known as &lt;a href=&quot;http://www.unicode.org/charts/PDF/U0000.pdf&quot;&gt;&lt;code&gt;U+0000..U+007F&lt;/code&gt; Basic Latin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb6e600b6afadfe5340dc5afe3b0d261da33e62" translate="yes" xml:space="preserve">
          <source>Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef53134c3cebcaaafdb4136521b343492974fcab" translate="yes" xml:space="preserve">
          <source>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;, in particular &lt;a href=&quot;operator_arithmetic#Overflows&quot;&gt;integer overflows&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb10617a2c1ff022c4b25bfccfb70bd51bf019" translate="yes" xml:space="preserve">
          <source>Note: integer promotions are applied only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d59e3724c61dc0f71eb6e96b133ae25c8b0787a" translate="yes" xml:space="preserve">
          <source>Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0&amp;times;(3.0+i&amp;infin;) would evaluate as (2.0+i0.0)&amp;times;(3.0+i&amp;infin;) &amp;rArr; (2.0&amp;times;3.0&amp;ndash;0.0&amp;times;&amp;infin;) + i(2.0&amp;times;&amp;infin;+0.0&amp;times;3.0) &amp;rArr; NaN+i&amp;infin; rather than the correct 6.0+i&amp;infin;. If imaginaries were converted to complex, i2.0&amp;times;(&amp;infin;+i3.0) would evaluate as (0.0+i2.0) &amp;times; (&amp;infin;+i3.0) &amp;rArr; (0.0&amp;times;&amp;infin; &amp;ndash; 2.0&amp;times;3.0) + i(0.0&amp;times;3.0 + 2.0&amp;times;&amp;infin;) &amp;rArr; NaN + i&amp;infin; instead of &amp;ndash;6.0 + i&amp;infin;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6901600afbe537ad0f0d081c7fde500ddbcb33" translate="yes" xml:space="preserve">
          <source>Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;as-if rule&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b41cc846e4a608f128d6ff06686f2a937f04801" translate="yes" xml:space="preserve">
          <source>Note: see &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; for the details on multidimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60474a8a10595bf2fec57f2fb7e2711ea1189b3" translate="yes" xml:space="preserve">
          <source>Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use &lt;code&gt;-finput-charset&lt;/code&gt; to specify the encoding of the source character set, &lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt; to specify the encodings of the execution character set in the string literals and character constants that don't have an encoding prefix(since C11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8092de48b423ebf2bb55c1e6ffcb436a80744e" translate="yes" xml:space="preserve">
          <source>Note: the remainder operator does not work on floating-point types, the library function &lt;code&gt;&lt;a href=&quot;../numeric/math/fmod&quot;&gt;fmod&lt;/a&gt;&lt;/code&gt; provides that functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e53fd79bfcb21f431df2933e62abc3d8109fc8" translate="yes" xml:space="preserve">
          <source>Note: this allows the extreme case in which &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;bytes&lt;/a&gt; are sized 64 bits, all types (including &lt;code&gt;char&lt;/code&gt;) are 64 bits wide, and &lt;code&gt;sizeof&lt;/code&gt; returns 1 for every type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d0bb27ce9ac9378f78496610c1e1579fd2ed42" translate="yes" xml:space="preserve">
          <source>Note: this example assumes the fix for the defect report 488 is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c436bc9bf6e01d60ea1f44d5bf1dc2b2853ddb54" translate="yes" xml:space="preserve">
          <source>Note: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword &lt;a href=&quot;../keyword/_generic&quot;&gt;_Generic&lt;/a&gt; makes it possible to implement these macros in portable manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b1f9ecf4738c61169a1ccdb4d8f106c3c4c226a9" translate="yes" xml:space="preserve">
          <source>Null pointer dereference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a6c19154380d505a46ba69085260f6a4e75ee8" translate="yes" xml:space="preserve">
          <source>Null pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849ec1c6477c10e2f8570a4141fbf7cd8c8c0c3a" translate="yes" xml:space="preserve">
          <source>Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; does nothing when a null pointer is passed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87666d8a93d39bce8a0fcd554a9b474be3904024" translate="yes" xml:space="preserve">
          <source>Null-terminated byte string management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3441a1d943445ee578773b9d59cdc4079e90e21" translate="yes" xml:space="preserve">
          <source>Null-terminated byte strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d16c943af2368f7e7b7123893affbacda8cc1e" translate="yes" xml:space="preserve">
          <source>Null-terminated multibyte string management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c161ff436191775822824d9815e2d14bf3d5ef2c" translate="yes" xml:space="preserve">
          <source>Null-terminated multibyte strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ded827466195b2612fb3d97ec0708621b5721e" translate="yes" xml:space="preserve">
          <source>Null-terminated wide string management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276d3b63150e3a49b557ab66f5dd4439a42688b3" translate="yes" xml:space="preserve">
          <source>Null-terminated wide strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb8aeceec221f4be1d4fb52e961aa048b321072" translate="yes" xml:space="preserve">
          <source>Number of elements in any &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt;&lt;code&gt;a&lt;/code&gt;including VLA(since C99) may be determined with the expression &lt;code&gt;sizeof a / sizeof a[0]&lt;/code&gt;. Note that if &lt;code&gt;a&lt;/code&gt; has pointer type (such as after array-to-pointer conversion of function parameter type adjustment), this expression would simply divide the number of bytes in a pointer type by the number of bytes in the pointed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2d7b79228be3f57fe401384b037bf13631d1bd" translate="yes" xml:space="preserve">
          <source>Number of objects read successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error or end-of-file condition occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebed1a5c0cf52f77e684fdd8dd009684c0c9849" translate="yes" xml:space="preserve">
          <source>Numeric limits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d591b3b3904bb2a1b443dad3db0e4ae55b2fa358" translate="yes" xml:space="preserve">
          <source>Numerics</source>
          <target state="translated">Numerics</target>
        </trans-unit>
        <trans-unit id="d107581a862db99867575e3f41f325fc4140ee10" translate="yes" xml:space="preserve">
          <source>ONCE_FLAG_INIT</source>
          <target state="translated">ONCE_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="9250b2677adf3b8e25990eff290a25954d1357f4" translate="yes" xml:space="preserve">
          <source>OR, if there was such an A, B may observe the result of some modification on M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt; and does not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38678aa96a7a3d61835226ca06fa7805d88fab6b" translate="yes" xml:space="preserve">
          <source>OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ec0b50948d6623513dcb6dc5fd07405ba5e129" translate="yes" xml:space="preserve">
          <source>Object representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd546c805dfba801ad9bca8f668ba26c4e9d94df" translate="yes" xml:space="preserve">
          <source>Object-like macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfc5f703ebd40ea35da590a8ca011ac237834ec" translate="yes" xml:space="preserve">
          <source>Object-like macros replace every occurrence of a defined identifier with replacement-list. Version (1) of the &lt;code&gt;#define&lt;/code&gt; directive behaves exactly like that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ef0bcacbf69dd868b4efa2b4ad1a1cfd8c5096" translate="yes" xml:space="preserve">
          <source>Objects &lt;a href=&quot;declarations&quot;&gt;declared&lt;/a&gt; with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5099cf20d1b82fb2c2137499652f1f1031f14841" translate="yes" xml:space="preserve">
          <source>Objects and Alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6897600ca1b5deb944cea78eba4834175965ad0f" translate="yes" xml:space="preserve">
          <source>Objects and alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e6de102563ef1f886a23d43fdd1616b4a15ba2" translate="yes" xml:space="preserve">
          <source>Objects are created by &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, &lt;a href=&quot;../memory&quot;&gt;allocation functions&lt;/a&gt;, &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;, &lt;a href=&quot;compound_literal&quot;&gt;compound literals&lt;/a&gt;, and by non-lvalue expressions that return &lt;a href=&quot;lifetime&quot;&gt;structures or unions with array members&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fc3d56e7b8dcfb4545c57f0e90ce464f35deb8" translate="yes" xml:space="preserve">
          <source>Objects declared with an external declaration have static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, and as such cannot use &lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt; specifiers. The identifiers introduced by external declarations have &lt;a href=&quot;scope&quot;&gt;file scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7883efd83a4faf633e6a8fe8d16f096fbb6600b9" translate="yes" xml:space="preserve">
          <source>Objects of array type are not &lt;a href=&quot;value_category&quot;&gt;modifiable lvalues&lt;/a&gt;, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93722ae3adb22a6f7e2d4b9abfdd1c6d36e6963a" translate="yes" xml:space="preserve">
          <source>Objects of atomic types are the only objects that are free from &lt;a href=&quot;memory_model&quot;&gt;data races&lt;/a&gt;, that is, they may be modified by two threads concurrently or modified by one and read by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4870394540a93ee5f98cbc8d1dd7b064d314d3e3" translate="yes" xml:space="preserve">
          <source>Objects of struct type do not compare equal automatically, and comparing them with &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;memcmp&lt;/a&gt;&lt;/code&gt; is not reliable because the padding bytes may have any values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af23398ade253364ac33f6e391bd6693462a59e" translate="yes" xml:space="preserve">
          <source>Obtains the file position indicator and the current parse state (if any) for the file stream &lt;code&gt;stream&lt;/code&gt; and stores them in the object pointed to by &lt;code&gt;pos&lt;/code&gt;. The value stored is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2f85ccf0846712f89c782e940eac919f85518a" translate="yes" xml:space="preserve">
          <source>Octal escape sequences have a length limit of three octal digits but terminate at the first character that is not a valid octal digit if encountered sooner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466ab7e2e07a7d7b2048c50a7c31c4a5b1cdc233" translate="yes" xml:space="preserve">
          <source>Of the octal escape sequences, &lt;code&gt;\0&lt;/code&gt; is the most useful because it represents the terminating null character in null-terminated strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a0cf2ed682fb364e5cf8db06f8b7c8f807ebc5" translate="yes" xml:space="preserve">
          <source>On C99 implementations that do not implement &lt;code&gt;I&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt; may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; is used for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9a1e3742f12c5fc4d68c4f1799698f7b87481c" translate="yes" xml:space="preserve">
          <source>On POSIX systems, &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is measured in seconds, and &lt;code&gt;difftime&lt;/code&gt; is equivalent to arithmetic subtraction, but C and C++ allow fractional units for &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce115d98fd1a5e35dda62b8d49f45a8573ea6e22" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08&quot;&gt;environment variables&lt;/a&gt; are also accessible through the global variable &lt;code&gt;environ&lt;/code&gt;, declared as &lt;code&gt;extern char **environ;&lt;/code&gt; in &lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt;, and through the optional third argument, &lt;code&gt;envp&lt;/code&gt;, of &lt;a href=&quot;../language/main_function&quot;&gt;the main function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c15eedd26e0a4296a1da805d0e3e7c292000d81" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the return value can be decomposed using &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html&quot;&gt;WEXITSTATUS and WSTOPSIG&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b83dd9352b620facc9e27430b33eed43bac0b0" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible systems, &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime&lt;/a&gt;&lt;/code&gt; with clock id &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; offers better resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdd32f54ebc59a583e521091168ac838894bb8d" translate="yes" xml:space="preserve">
          <source>On a binary system (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;frexp&lt;/code&gt; may be implemented as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feccd585446b4f56b9ce4cd68a4fbb77a174bb13" translate="yes" xml:space="preserve">
          <source>On a runtime constraint violation, it is called with the following arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce877e2c542fd9b52cb204b343fc97d8d48dd27c" translate="yes" xml:space="preserve">
          <source>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109d9d8a239fad3c18cdb8e2722da494ab0114a2" translate="yes" xml:space="preserve">
          <source>On any given platform, the width of type &lt;code&gt;char16_t&lt;/code&gt; can be greater than 16 bits, but the actual values stored in an object of type &lt;code&gt;char16_t&lt;/code&gt; will always have a width of 16 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b6e8c2a5af3c4767eb6e30ca739f50e4862a4f" translate="yes" xml:space="preserve">
          <source>On any given platform, the width of type &lt;code&gt;char32_t&lt;/code&gt; can be greater than 32 bits, but the actual values stored in an object of type &lt;code&gt;char32_t&lt;/code&gt; will always have a width of 32 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7601ac6abb5fa0c3f055c6b3ad57cb808021d0f1" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;ldexp&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;scalbn&quot;&gt;scalbn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7811a9fc573d545f5f23c802e3d6aa2dbbacd655" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;scalbn&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d996bcb21d063a3ac297cd094f055a12b5180729" translate="yes" xml:space="preserve">
          <source>On entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1054713c9d53c3a28707cf8e527af1dac108b0f" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;errno&lt;/code&gt; variable is set to implementation-defined positive value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e174f6d770fb4beeb3cd8a25511f843e0cde8e" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c16&lt;/code&gt; is not a valid 16-bit code unit), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b654d6228256087914cf81392b2cab324f4ec80" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c32&lt;/code&gt; is not a valid 32-bit wide character), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a268f876a2012546ea2d4db6b6fb087311b2d7" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;wc&lt;/code&gt; is not a valid wide character), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace1968875e711eb68499fe2c40ffcf411eb2bd8" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59034111d1fe69518d421a29472104cf3b1d3e3" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;WEOF&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b861da9d1352751519afe0557d5add29d003824b" translate="yes" xml:space="preserve">
          <source>On failure, returns &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; and sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314b860381766f5828a38837bf58fe936c2ad191" translate="yes" xml:space="preserve">
          <source>On failure, returns &lt;code&gt;WEOF&lt;/code&gt; and sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd79a4ce724e0f85bbc5af6b0ba614e86f4c729" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208512240a47af38827f26924ebcc80cb2c37ad5" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer. The original pointer &lt;code&gt;ptr&lt;/code&gt; remains valid and may need to be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1bf711404d47b14c3829dbfe5bbf1b29d1b2ee4" translate="yes" xml:space="preserve">
          <source>On implementations that support floating-point infinities, these macros always expand to the positive infinities of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8621dd430c2c00cf7cac763e8409cf66e119c807" translate="yes" xml:space="preserve">
          <source>On many implementations, &lt;code&gt;ldexp&lt;/code&gt; is less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a6ebd0b3f331800ebab3eb88281db31bb09676" translate="yes" xml:space="preserve">
          <source>On many implementations, line buffering is only available for terminal input streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae6cfb19aec260bc05f2964584fe1ea9c86a969" translate="yes" xml:space="preserve">
          <source>On many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby / and % where suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a72fd9a6bd6f0514568737340536f59b85bddb" translate="yes" xml:space="preserve">
          <source>On return from a signal handler, the value of any object modified by the signal handler that is not &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; or lock-free atomic(since C11) is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc9c28e074a73d2c245f0186a4c8a7d68bca3b8" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, or once the program terminates (normally or abnormally), the space occupied by the file is reclaimed by the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd2c2923877872be297b89c9fea77391101b399" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ad61f04001b112d42b39173e55ee98d3ddc34c" translate="yes" xml:space="preserve">
          <source>On some platforms this operation is supported by hardware (and, for example, on Intel CPU, &lt;code&gt;FPREM1&lt;/code&gt; leaves exactly 3 bits of precision in the quotient).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a8ce59d8dc85c2962717623b86954b6c06d0f6" translate="yes" xml:space="preserve">
          <source>On strongly-ordered systems &amp;mdash; x86, SPARC TSO, IBM mainframe, etc. &amp;mdash; release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode; only certain compiler optimizations are affected (e.g., the compiler is prohibited from moving non-atomic stores past the atomic store-release or performing non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b723cf592ca1c577d1c9cb505cf08a127e9073" translate="yes" xml:space="preserve">
          <source>On success &lt;code&gt;ch&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4761c7a6227f38804881200e2df99d7b35533a7" translate="yes" xml:space="preserve">
          <source>On success, returns a non-negative value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cde2f20613d1a86893110aa81a3b21249e01dd4" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the leading &lt;code&gt;char16_t&lt;/code&gt; units in a multi-&lt;code&gt;char16_t&lt;/code&gt;-unit sequence (occurs when processing the leading surrogate in a surrogate pair of UTF-16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de169c1c0a0fe1521de636ba13f4679f7d63784d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the leading &lt;code&gt;char32_t&lt;/code&gt; units in a multi-&lt;code&gt;char32_t&lt;/code&gt;-unit sequence (does not occur in UTF-32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fea449bddcfd4112273f907f46291dd9fd0bda" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badf0c0d191b6f202c40872f1028bec7676332e1" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;. The original pointer &lt;code&gt;ptr&lt;/code&gt; is invalidated and any access to it is undefined behavior (even if reallocation was in-place).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d902746b34d07703c051d8b0c20c3a4f074b9dbd" translate="yes" xml:space="preserve">
          <source>On success, returns the written character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654813a474d7f1feaa5498a158649f23b8e604b2" translate="yes" xml:space="preserve">
          <source>On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc8d97258ef37395359f175535e24d679a58e39" translate="yes" xml:space="preserve">
          <source>On the other hand, although unsigned integer overflow in any arithmetic operator (and in integer conversion) is a well-defined operation and follows the rules of modulo arithmetic, overflowing an unsigned integer in a floating-to-integer conversion is undefined behavior: the values of real floating type that can be converted to unsigned integer are the values from the open interval (-1; Unnn_MAX+1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cc73591c77978d68949f41043e92bd28cf120f" translate="yes" xml:space="preserve">
          <source>On the way up the stack, &lt;code&gt;longjmp&lt;/code&gt; does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265fc81eed0f5d614db9f511bddb08d53edda459" translate="yes" xml:space="preserve">
          <source>On thread startup (see &lt;code&gt;&lt;a href=&quot;thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143c95c711e6f4ad6cfeb129df6f450c3084425d" translate="yes" xml:space="preserve">
          <source>One definition rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d4f2dc80f2c24729c95ceecb641056847e9ef6" translate="yes" xml:space="preserve">
          <source>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx&quot;&gt;MSDN&lt;/a&gt;), and thus volatiles may be used for inter-thread synchronization. Standard &lt;code&gt;volatile&lt;/code&gt; semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; handler that runs in the same thread when applied to &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec3094c47e164868d67263abee22b8f36e54dde" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_INFINITE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NAN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NORMAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_SUBNORMAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_ZERO&lt;/a&gt;&lt;/code&gt; or implementation-defined type, specifying the category of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e2e730425995bc27c6162e5d7369f2baf1d499" translate="yes" xml:space="preserve">
          <source>One use case for changing buffer size is when a better size is known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643603d8af84c49b3d031aa1a05216203cedd509" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '&amp;Sigma;' has two lowercase forms, depending on the position in a word: '&amp;sigma;' and '&amp;sigmaf;'. A call to &lt;code&gt;towlower&lt;/code&gt; cannot be used to obtain the correct lowercase form in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8558acb5e44a3b7e7cc83eb1f8384f438a150fd5" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '&amp;szlig;' is (with some exceptions) the two-character string &quot;SS&quot;, which cannot be obtained by &lt;code&gt;towupper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f87f165c312cced9d18c34a873a0ab047c4c9" translate="yes" xml:space="preserve">
          <source>Only if both arguments are NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee3b411f9ce5a9d0dc1557293a5208ceecead35" translate="yes" xml:space="preserve">
          <source>Only modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d343971baedb6cbb3b70f72cc6073ba64f46344b" translate="yes" xml:space="preserve">
          <source>Only new-style (prototyped) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; may be variadic. This is indicated by the parameter of the form &lt;code&gt;...&lt;/code&gt; which must appear last in the parameter list and must follow at least one named parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86c376c389f9f7b37142caaf26ada0ec893ba21" translate="yes" xml:space="preserve">
          <source>Only pointers to &lt;a href=&quot;compatible_type&quot;&gt;object types&lt;/a&gt; may be restrict-qualified (in particular, &lt;code&gt;int restrict *p&lt;/code&gt; and &lt;code&gt;float (* restrict f9)(void)&lt;/code&gt; are errors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01794fe3947565d881ce29925429530cc7001695" translate="yes" xml:space="preserve">
          <source>Only pointers to elements of the same array (including the pointer one past the end of the array) may be subtracted from each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415dfd9db04ea2590afe9bf3ae3000416e96b22e" translate="yes" xml:space="preserve">
          <source>Only the difference between two values returned by different calls to &lt;code&gt;clock&lt;/code&gt; is meaningful, as the beginning of the &lt;code&gt;clock&lt;/code&gt; era does not have to coincide with the start of the program. &lt;code&gt;clock&lt;/code&gt; time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, &lt;code&gt;clock&lt;/code&gt; time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, &lt;code&gt;clock&lt;/code&gt; time may advance faster than wall clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1042f16a7b75cb3732a2bc82be1aa8b169e69f" translate="yes" xml:space="preserve">
          <source>Only the following expressions are allowed as expression-true and expression-false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59eaae4ab6b1ae5533fc854dde2378dc53297f6" translate="yes" xml:space="preserve">
          <source>Only the following undefined behaviors are critical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1e9ef7c7f2fc9fc1d73df732e8087397ce13c0" translate="yes" xml:space="preserve">
          <source>Only two narrow or two wide string literals may be concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237cef659815822d78b56d19a7c946bfbf74be1f" translate="yes" xml:space="preserve">
          <source>Open a file for read/write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3186d8ed0fca34a6a2c7ee13f69f2d2feb00ab05" translate="yes" xml:space="preserve">
          <source>Open a file for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456fb30fb01febdf98b1f26b7ae1bde8ca3ee080" translate="yes" xml:space="preserve">
          <source>Operations on files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0f3287b1169a638056162b8ea1058227dff7945b" translate="yes" xml:space="preserve">
          <source>Operator macros(C95)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819ccd81b85bc3b38f4cc9446e71367abf393235" translate="yes" xml:space="preserve">
          <source>Operator name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="ca7702ea15a52dc62fa45feb4b8c2a5d108ab264" translate="yes" xml:space="preserve">
          <source>Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression &lt;code&gt;a=b=c&lt;/code&gt; is parsed as &lt;code&gt;a=(b=c)&lt;/code&gt;, and not as &lt;code&gt;(a=b)=c&lt;/code&gt; because of right-to-left associativity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab90aabfee646e5feefc6f9a898d668b42d74ce" translate="yes" xml:space="preserve">
          <source>Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="1b3df585822a5aa71af2864093c3784252d8d05a" translate="yes" xml:space="preserve">
          <source>Originally (in C89), support for zero size was added to accommodate code such as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="2c0e832aaebdbd2463766c9b11e2e90be9a8a71c" translate="yes" xml:space="preserve">
          <source>Other macro constants beginning with &lt;code&gt;TIME_&lt;/code&gt; may be provided by the implementation to indicate additional time bases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22490909ecb721f0620f7d5b993ac0c5478e639a" translate="yes" xml:space="preserve">
          <source>Other models are very rare. For example, &lt;b&gt;ILP64&lt;/b&gt; (&lt;b&gt;8/8/8&lt;/b&gt;: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecde2c1ff0650ce54e7e724236337f0082c7af4" translate="yes" xml:space="preserve">
          <source>Other operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6962ff7ae59e4074a7a4c9216963b920264f14d3" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;arg&lt;/code&gt; is not zero), if no errors occur, returns the value &lt;code&gt;x&lt;/code&gt; in the range &lt;code&gt;(-1;-0.5], [0.5; 1)&lt;/code&gt; and stores an integer value in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; such that x&amp;times;2(*exp)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acea718d4290aa47c7e60d4de5b064b3e0d254ed" translate="yes" xml:space="preserve">
          <source>Otherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d06fa77dd61fad7761e2e90c69e32873116c0b" translate="yes" xml:space="preserve">
          <source>Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513439b9a32e69b4c43715e537ce9a1e6779b0d2" translate="yes" xml:space="preserve">
          <source>Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dde40dbcdfe2efbe7a10f92f68991f7314d060d" translate="yes" xml:space="preserve">
          <source>Otherwise, if both operands after promotion have the same signedness (both signed or both unsigned), the operand with the lesser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0234caa7bb771cbb9cfeaa4f48b7d3fa57b9692" translate="yes" xml:space="preserve">
          <source>Otherwise, if expression does not equal zero, nothing happens; no code is emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3706c5ce3b3e68ec6995f2343dcf9619c6c9a406" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c46cf482866181f8c389db5b8ba5d006dbef217" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c951e6e86f63cf6df740a2bc39bcac52344647" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4b77f603fbb12975ab783cf93a88dd4cea1971" translate="yes" xml:space="preserve">
          <source>Otherwise, if type-name is exactly the type of expression, nothing is done (except that if expression has floating type and is represented with greater range and precision than its type indicates -- see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d748298a041a1ef7ff4c527961a3c25f8914c9" translate="yes" xml:space="preserve">
          <source>Otherwise, the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84fe8d54f35cea26d6a3dd2d2efb6c41ee1070a" translate="yes" xml:space="preserve">
          <source>Otherwise, the signedness is different: If the operand with the unsigned type has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e8cf5e29bbd01bcc7643f612cca79fe397b689" translate="yes" xml:space="preserve">
          <source>Otherwise, the value of expression is converted to the type named by type-name, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="f8d5cf51177cbd61e9ad52eaa044095be31080c7" translate="yes" xml:space="preserve">
          <source>Overflows</source>
          <target state="translated">Overflows</target>
        </trans-unit>
        <trans-unit id="b1a324fa062c9e26e00c18e22544ad0506e15306" translate="yes" xml:space="preserve">
          <source>P &amp;gt; X &amp;ge; &amp;minus;4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d009599b4e30148a6c333642990ba0b9350d9a" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0314c3d6e90b3565b95808c2051a435d624960e" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1 &amp;minus; X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0c0a1c20866f175fd10b2aef4d095e149b6f0d" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/abort.html&quot;&gt;specifies&lt;/a&gt; that the abort() function overrides blocking or ignoring the SIGABRT signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fe9927eb40a44c14a8416224896d9dc60256b8" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot;&gt;extends the specification of fflush&lt;/a&gt; by defining its effects on an input stream, as long as that stream represents a file or another seekable device: in that case the POSIX file pointer is repositioned to match the C stream pointer (which effectively undoes any read buffering) and the effects of any &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ungetwc&quot;&gt;ungetwc&lt;/a&gt;&lt;/code&gt; that weren't yet read back from the stream are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bd6e66e13b5cf5b7787df74da03ed895b117e" translate="yes" xml:space="preserve">
          <source>POSIX allows seeking beyond the existing end of file. If an output is performed after this seek, any read from the gap will return zero bytes. Where supported by the filesystem, this creates a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca50ebb591b6d07b87a0ee2add3e84ece52f6b7" translate="yes" xml:space="preserve">
          <source>POSIX also defines a locale named &quot;POSIX&quot;, which is always accessible and is exactly equivalent to the default minimal &quot;C&quot; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa946b2d1792a1779559fdf33adf8c5a87699a3a" translate="yes" xml:space="preserve">
          <source>POSIX also requires that fseek first performs &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt; if there are any unwritten data (but whether the shift state is restored is implementation-defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c9c5859eeb4cbf2e537e662ad97d06d3c60914" translate="yes" xml:space="preserve">
          <source>POSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; and the value returned when the correct result is less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9013b0fb54c48f8c3398535564a8c9fb6d5c1b" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that in case of underflow, &lt;code&gt;arg&lt;/code&gt; is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335c1690cc5b65b3646d4724816b44c455691178" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that the returned pointer, not just the contents of the pointed-to string, may be invalidated by subsequent calls to setlocale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d1a5ec1fed2c0de948f38e67dee82961de1cee" translate="yes" xml:space="preserve">
          <source>POSIX defines &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; as one million, regardless of the actual precision of &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6c8af49b7a4f2c013a891905aeb93eb19a6eba" translate="yes" xml:space="preserve">
          <source>POSIX defines a thread-safe alternative &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html&quot;&gt;gmtime_r&lt;/a&gt;, which is similar to the C11 function &lt;code&gt;gmtime_s&lt;/code&gt;, except that it does not check the validity of its input parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1aad47697533d1cf4d609c8880d8e1a08506a6b" translate="yes" xml:space="preserve">
          <source>POSIX defines a thread-safe alternative &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html&quot;&gt;localtime_r&lt;/a&gt;, which is similar to the C11 function &lt;code&gt;localtime_s&lt;/code&gt;, except that it does not check the validity of its input parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9897e2a366ea005d44ffdc34adfd993a15fa8e" translate="yes" xml:space="preserve">
          <source>POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \n or any other characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8856b5eaf0d4bc59c7900e57d597384a95e21ed" translate="yes" xml:space="preserve">
          <source>POSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when &lt;code&gt;timeptr-&amp;gt;tm_wday&lt;/code&gt; or &lt;code&gt;timeptr-&amp;gt;tm_mon&lt;/code&gt; are not within the expected ranges, or when &lt;code&gt;timeptr-&amp;gt;tm_year&lt;/code&gt; exceeds &lt;code&gt;INT_MAX-1990&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6418fb45609289cd240484b4818996a8aa9857" translate="yes" xml:space="preserve">
          <source>POSIX offered a thread-safe version of rand called rand_r, which is obsolete in favor of the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/drand48.html&quot;&gt;drand48&lt;/a&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32eef0d1950e7650578656de5bd2fcfe9f8d82c9" translate="yes" xml:space="preserve">
          <source>POSIX recommends &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html&quot;&gt;sigaction&lt;/a&gt; instead of &lt;code&gt;signal&lt;/code&gt;, due to its underspecified behavior and significant implementation variations, regarding signal delivery while a signal handler is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c567b9031ff51fb9b1ea5a64cf6d5a57e9f563c1" translate="yes" xml:space="preserve">
          <source>POSIX requires that &lt;code&gt;signal&lt;/code&gt; is thread-safe, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04&quot;&gt;specifies a list of async-signal-safe library functions&lt;/a&gt; that may be called from any signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27534ecaa17f348b7ed18ae38042351411d5d54a" translate="yes" xml:space="preserve">
          <source>POSIX requires that the LC_CTYPE facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2824292b7da5f4c3c882e7cd7f442e03c72c117" translate="yes" xml:space="preserve">
          <source>POSIX requires that the period of the pseudo-random number generator used by &lt;code&gt;rand&lt;/code&gt; be at least 232</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8315c3400a6c02895638e578d86ada429f817006" translate="yes" xml:space="preserve">
          <source>POSIX requires that this function sets &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../error/errno_macros&quot;&gt;EOVERFLOW&lt;/a&gt;&lt;/code&gt; if it fails because the argument is too large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdc1accb0a3117418c3d1604ff7f1bd63b14ca7" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of bytes that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;wcstombs_s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3b8de189c2091db808d59bd3105aa30e6f191e" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of wide characters that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;mbstowcs_s&lt;/code&gt; and for &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f640ef44ff8aceca9d40819362503cdf028c703d" translate="yes" xml:space="preserve">
          <source>POSIX systems additionally define the similarly named function &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html&quot;&gt;tempnam()&lt;/a&gt;&lt;/code&gt;, which offers the choice of a directory (which defaults to the optionally defined macro &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html&quot;&gt;P_tmpdir&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f7145f57c3449a8db7e8e0c0eb5442612d6d1a" translate="yes" xml:space="preserve">
          <source>PRIX&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIX&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0a64e120776de9fbefa5418d4d43b3ba89d70837" translate="yes" xml:space="preserve">
          <source>PRIXFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIXFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9ddbba6bf4dafbb2a873648eda5d9098a39a0f38" translate="yes" xml:space="preserve">
          <source>PRIXLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIXLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18e1b5b3da1f5696ee1b5d766902e3bdf9a229ea" translate="yes" xml:space="preserve">
          <source>PRIXMAX</source>
          <target state="translated">PRIXMAX</target>
        </trans-unit>
        <trans-unit id="781c2eb6dafec442ebfc72f8b7ebae2317fe378f" translate="yes" xml:space="preserve">
          <source>PRIXPTR</source>
          <target state="translated">PRIXPTR</target>
        </trans-unit>
        <trans-unit id="b7d33bb5db43e551d35c482fd09131ad46207a8d" translate="yes" xml:space="preserve">
          <source>PRId&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRId&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b3f9185242ed4fd4aa7fe79711cff60ca67e2f7" translate="yes" xml:space="preserve">
          <source>PRIdFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIdFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f8d0c46ca6bb30380b59f4f101705eefd6490015" translate="yes" xml:space="preserve">
          <source>PRIdLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIdLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc53f81c479d6b89c4ff776e1934d8e02814c41f" translate="yes" xml:space="preserve">
          <source>PRIdMAX</source>
          <target state="translated">PRIdMAX</target>
        </trans-unit>
        <trans-unit id="a17d0b9784580f9889085e64178ec0165b48f47c" translate="yes" xml:space="preserve">
          <source>PRIdPTR</source>
          <target state="translated">PRIdPTR</target>
        </trans-unit>
        <trans-unit id="714fc0bc0af7a9749d04748234fc179ac576a244" translate="yes" xml:space="preserve">
          <source>PRIi&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIi&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ea09c5b25c9c93bc85281625a00cd1a3f3cb84b3" translate="yes" xml:space="preserve">
          <source>PRIiFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIiFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2bc784563d7725f115131118c7018a222c378c5" translate="yes" xml:space="preserve">
          <source>PRIiLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIiLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6358aee55979a62f99273506f52e4e38200b3ace" translate="yes" xml:space="preserve">
          <source>PRIiMAX</source>
          <target state="translated">PRIiMAX</target>
        </trans-unit>
        <trans-unit id="032e31e8a0c90d21725ebd9b9787dd714fdc2aad" translate="yes" xml:space="preserve">
          <source>PRIiPTR</source>
          <target state="translated">PRIiPTR</target>
        </trans-unit>
        <trans-unit id="d58f3f7ece61a2a7733019776f7e3739fcf290b4" translate="yes" xml:space="preserve">
          <source>PRIo&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIo&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1f0b366d2a11133856c82c60391c095a82cda" translate="yes" xml:space="preserve">
          <source>PRIoFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIoFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8e51125962ffd20d71e1b64e858f7cd2fc64c083" translate="yes" xml:space="preserve">
          <source>PRIoLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIoLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="804d9608ba0996c9a1dbcdbe7dc4ff6089c2c1be" translate="yes" xml:space="preserve">
          <source>PRIoMAX</source>
          <target state="translated">PRIoMAX</target>
        </trans-unit>
        <trans-unit id="c416df2e883d4710bb2459e89d0cecd848a9c16f" translate="yes" xml:space="preserve">
          <source>PRIoPTR</source>
          <target state="translated">PRIoPTR</target>
        </trans-unit>
        <trans-unit id="cef6a59a75eb0c565c5c285d0bd5628314f68c33" translate="yes" xml:space="preserve">
          <source>PRIu&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIu&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="60e1df3d0d76c883177df0c85e11dc9f4782c343" translate="yes" xml:space="preserve">
          <source>PRIuFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIuFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c7de01de7367eabf2a6cbb0005c1ee9b3e0ff536" translate="yes" xml:space="preserve">
          <source>PRIuLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIuLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07d19cc5e39483d2b638c9747d236b9f98cf2ba6" translate="yes" xml:space="preserve">
          <source>PRIuMAX</source>
          <target state="translated">PRIuMAX</target>
        </trans-unit>
        <trans-unit id="a53e86b08e7c119ae3fe44531c7aaf0301532d48" translate="yes" xml:space="preserve">
          <source>PRIuPTR</source>
          <target state="translated">PRIuPTR</target>
        </trans-unit>
        <trans-unit id="2d4d67b6d521f879ad2c3fae70c27987e0b2b365" translate="yes" xml:space="preserve">
          <source>PRIx&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIx&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac79b02c9366823911f81b644baaade6a66b7127" translate="yes" xml:space="preserve">
          <source>PRIxFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIxFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="efcc600b2091877d2742f8fc3653c4b5f63f4a12" translate="yes" xml:space="preserve">
          <source>PRIxLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIxLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdaafdc9843631b79c26045d58fabfb0fc7c9663" translate="yes" xml:space="preserve">
          <source>PRIxMAX</source>
          <target state="translated">PRIxMAX</target>
        </trans-unit>
        <trans-unit id="29216749819cc7374de90e9b38698676527b3a0a" translate="yes" xml:space="preserve">
          <source>PRIxPTR</source>
          <target state="translated">PRIxPTR</target>
        </trans-unit>
        <trans-unit id="e2d341dab357c92fea1cc61d3e72cb6281d41c97" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MAX</source>
          <target state="translated">PTRDIFF_MAX</target>
        </trans-unit>
        <trans-unit id="68e5106036965c9d086871ec56706e8f44965f32" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MIN</source>
          <target state="translated">PTRDIFF_MIN</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="73a713f006a51b44d7ffe9f8f32e74c81d8db332" translate="yes" xml:space="preserve">
          <source>Passing a &lt;code&gt;size&lt;/code&gt; which is not an integral multiple of &lt;code&gt;alignment&lt;/code&gt; or a &lt;code&gt;alignment&lt;/code&gt; which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by DR 460). Removal of size restrictions to make it possible to allocate small objects at restrictive alignment boundaries (similar to &lt;a href=&quot;../language/alignas&quot;&gt;&lt;code&gt;alignas&lt;/code&gt;&lt;/a&gt;) has been proposed by &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2072.htm&quot;&gt;n2072&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dfc8d6cd7478d6828f48721c4f4220b682b54b" translate="yes" xml:space="preserve">
          <source>Performs explicit type conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e086fa3837f92effda2f189c65d872aaf2923d5" translate="yes" xml:space="preserve">
          <source>Phase 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330708acff87bb6907139071d5b459ded3e2d04a" translate="yes" xml:space="preserve">
          <source>Phase 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681032fd51c92a246ce412b39048b4ee77dca634" translate="yes" xml:space="preserve">
          <source>Phase 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d44d36dd0ef3c8fc841ed57f6811ad23d3444a" translate="yes" xml:space="preserve">
          <source>Phase 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f56e33fd048af3ea5f5836a9ebc4271647e4f2" translate="yes" xml:space="preserve">
          <source>Phase 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95c8c6e048db1b43f633d810e6911867dafdf1a" translate="yes" xml:space="preserve">
          <source>Phase 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a6e111a7e2e8fab957c5ce32c74294af54929f" translate="yes" xml:space="preserve">
          <source>Phase 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f992983641f78a8c013798273706bbac409bc020" translate="yes" xml:space="preserve">
          <source>Phase 8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dec91782cf447c62f887433fae8bdce01c3fe91" translate="yes" xml:space="preserve">
          <source>Phases of translation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0813d9bb5496f0d5533fee53776e91237df8de" translate="yes" xml:space="preserve">
          <source>Point of declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886d0e716745d04046260e2fd4e01fbcdb9fbe82" translate="yes" xml:space="preserve">
          <source>Pointer arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dad7ddcfc4dd1845430d750452929c090145667" translate="yes" xml:space="preserve">
          <source>Pointer conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220f1fd327711e96e3028b6709d46b742350f010" translate="yes" xml:space="preserve">
          <source>Pointer declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55dbea62d8e8531595e04ca705ad7ec6aa187e" translate="yes" xml:space="preserve">
          <source>Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b701fa737c41b8405d3b3f7760d145e2e7f6091" translate="yes" xml:space="preserve">
          <source>Pointer to object of any type can be &lt;a href=&quot;conversion&quot;&gt;implicitly converted&lt;/a&gt; to pointer to &lt;code&gt;void&lt;/code&gt; (optionally &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;-qualified), and vice versa:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73e3cdae64ac7123b31602d1b60bce60462fac" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;breakset&lt;/code&gt;, or null pointer if no such character exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebaf2a6a20f7b6c7586e0484fcb32649bd4a5f5" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9e35434f828d3a11ae11da261d3e71214675f" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;dest&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such substring is found. If &lt;code&gt;src&lt;/code&gt; points to an empty string, &lt;code&gt;dest&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f47cbf04cda2b8fa15a46ceaeda9392b735c0bd" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such substring is found. If &lt;code&gt;substr&lt;/code&gt; points to an empty string, &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f608798db8c021a3eafbdf2c24587c22140695" translate="yes" xml:space="preserve">
          <source>Pointer to the first element of an array of &lt;code&gt;argc + 1&lt;/code&gt; pointers, of which the last one is null and the previous ones, if any, point to strings that represent the arguments passed to the program from the host environment. If &lt;code&gt;argv[0]&lt;/code&gt; is not a null pointer (or, equivalently, if &lt;code&gt;argc&lt;/code&gt; &amp;gt; 0), it points to a string that represents the program name, which is empty if the program name is not available from the host environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405e5d4054459c9f481d32fb4025569549fc54c2" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4f765e2320d24e28834fd57258bdf60d616f3d" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or null pointer if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e8c4f8ecb8e493cc67d3b4ab6c8ee17ceb8a9d" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the character, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21825601c681d15ea8978fbec39c4ef272eee665" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the wide character, or a null pointer if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f4e8e141903b4f0830a9fbf39082e3c0002128" translate="yes" xml:space="preserve">
          <source>Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, to implement &quot;optional&quot; types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f90edf619ad392e7a9ec083e54442cf600b30c" translate="yes" xml:space="preserve">
          <source>Pointers may appear as operands to the &lt;a href=&quot;operator_member_access#Dereference&quot;&gt;indirection operator&lt;/a&gt; (unary &lt;code&gt;*&lt;/code&gt;), which returns &lt;a href=&quot;value_category&quot;&gt;the lvalue&lt;/a&gt; identifying the pointed-to object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7324a9c3bb73a069fd86296c2d3c8eff5bf1e09e" translate="yes" xml:space="preserve">
          <source>Pointers of every type have a special value known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b1e34071ba74ebd5271bef008fbd99d767fdf6" translate="yes" xml:space="preserve">
          <source>Pointers returned by allocation functions such as &lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; are suitably aligned for any object, which means they are aligned at least as strictly as &lt;code&gt;max_align_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd06e334d5015b6a66d37944bb18db253b12c1c" translate="yes" xml:space="preserve">
          <source>Pointers to char are often &lt;a href=&quot;../string/byte&quot;&gt;used to represent strings&lt;/a&gt;. To represent a valid byte string, a pointer must be pointing at a char that is an element of an array of char, and there must be a char with the value zero at some index greater or equal to the index of the element referenced by the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82bc7e72d8d51c0188462e092d842450c228f3d" translate="yes" xml:space="preserve">
          <source>Pointers to functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b7228167bc78f725c1aa6170713523c3e87add" translate="yes" xml:space="preserve">
          <source>Pointers to objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7fc6a0f3c979a244e510b65787995b7a3b6966" translate="yes" xml:space="preserve">
          <source>Pointers to objects of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type may also appear as the left-hand operands of the &lt;a href=&quot;operator_member_access&quot;&gt;member access through pointer&lt;/a&gt; operator &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee25cfd40679ceda92c701097a34e138aa84fe43" translate="yes" xml:space="preserve">
          <source>Pointers to void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a2c64b9ffad4e941a7b6419408254d9b93a70f" translate="yes" xml:space="preserve">
          <source>Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: &lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;void*&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;qsort&lt;/a&gt;&lt;/code&gt; expects a user-provided callback that accepts two &lt;code&gt;const void*&lt;/code&gt; arguments. &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html&quot;&gt;pthread_create&lt;/a&gt; expects a user-provided callback that accepts and returns &lt;code&gt;void*&lt;/code&gt;. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f8e7db6309cddc0c5732e9a9ba58aaec05d533" translate="yes" xml:space="preserve">
          <source>Pole error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d042fd98c607a113e1de0917255c86503669b3" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17e2690e7349805c990c7c5df9303f661668615" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9ebb96d6456e6e0214a89210dd04cd1b71df2c" translate="yes" xml:space="preserve">
          <source>Positive value if &lt;code&gt;lhs&lt;/code&gt; appears after &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714e8e0d9935902a6887a396fa6d2f712afabcf0" translate="yes" xml:space="preserve">
          <source>Positive value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5624e422d114bf4c07e574d33c43264c084cff" translate="yes" xml:space="preserve">
          <source>Positive value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is greater than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;rhs&lt;/code&gt; precedes &lt;code&gt;lhs&lt;/code&gt; in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d014f6e89348741eecc9997521bd010438349e" translate="yes" xml:space="preserve">
          <source>Possible implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78bac5dbecd72e3a2b6b9a7c6387b18bbb07e9b" translate="yes" xml:space="preserve">
          <source>Possible implementation of &lt;code&gt;mbstate_t&lt;/code&gt; is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef4f19dbc69bc7fa8ed2879ac59a6eb92531a56" translate="yes" xml:space="preserve">
          <source>Possible output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9c60d34af113296884c65c8010519328c83df3" translate="yes" xml:space="preserve">
          <source>Post-increment or post-decrement on any &lt;a href=&quot;atomic&quot;&gt;atomic variable&lt;/a&gt; is an atomic read-modify-write operation with memory order &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3a2228beca8f49314c3fcd02a2b8475fe33e8f" translate="yes" xml:space="preserve">
          <source>Power functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="b631d34d72f3f492d653422060a77dea90b29f64" translate="yes" xml:space="preserve">
          <source>Precedence and associativity are independent from &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="75f2e4344f7133573ec1e2a5657aee298b86d10a" translate="yes" xml:space="preserve">
          <source>Predefined macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d39c88b86cfe3e69119f388e37457f6bed869ac" translate="yes" xml:space="preserve">
          <source>Prefix increment and decrement&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-1&quot;&gt;[note 1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690b8706d3e1f79bde61f6dc644048c260a4aafe" translate="yes" xml:space="preserve">
          <source>Preprocessor</source>
          <target state="translated">Preprocessor</target>
        </trans-unit>
        <trans-unit id="ce3857451491e15e8d99cfffd90e6c5e20f4c044" translate="yes" xml:space="preserve">
          <source>Preprocessor constant expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4bbb5e0cb36ae9eddced10ea643518cae66105" translate="yes" xml:space="preserve">
          <source>Previous signal handler on success or &lt;code&gt;&lt;a href=&quot;sig_err&quot;&gt;SIG_ERR&lt;/a&gt;&lt;/code&gt; on failure (setting a signal handler can be disabled on some implementations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a96ec019494d5b8b041c1d2468061ae66e35d5" translate="yes" xml:space="preserve">
          <source>Primary</source>
          <target state="translated">Primary</target>
        </trans-unit>
        <trans-unit id="610cd0ab8c3ab5b15fdfa49aabc7a8429ee0623d" translate="yes" xml:space="preserve">
          <source>Primary expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d83338b8e29ac2309be82d56e0443145d5a534" translate="yes" xml:space="preserve">
          <source>Primary expressions are any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce18cda82bbb1e06990b3ba51b5b40df45c3c20c" translate="yes" xml:space="preserve">
          <source>Print values of different types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e9f4fd305f45da337a63f599fbf41cad195960" translate="yes" xml:space="preserve">
          <source>Prints a textual description of the error code currently stored in the system variable &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a6c2836b46a115435b7695c9816a4e27a3157a" translate="yes" xml:space="preserve">
          <source>Prior calls to &lt;code&gt;&lt;a href=&quot;mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; on the same mutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02d18eb0ae73b3f5f87b9eaefbf171bf1d769ca" translate="yes" xml:space="preserve">
          <source>Prior to C89, identifiers with external linkage had file scope even when introduced within a block, and because of that, a C89 compiler is not required to diagnose the use of an extern identifier that has gone out of scope (such use is undefined behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c91f3ac0bca552bc66a0adc8d50ababbf7f598" translate="yes" xml:space="preserve">
          <source>Prior to calling &lt;code&gt;va_arg&lt;/code&gt;, &lt;code&gt;ap&lt;/code&gt; must be initialized by a call to either &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;, with no intervening call to &lt;code&gt;va_end&lt;/code&gt;. Each invocation of the &lt;code&gt;va_arg&lt;/code&gt; macro modifies &lt;code&gt;ap&lt;/code&gt; to point to the next variable argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ad15707a1e4cd404656343899e47440f38d804" translate="yes" xml:space="preserve">
          <source>Processor time used by the program so far or &lt;code&gt;(&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;)(-1)&lt;/code&gt; if that information is unavailable or its value cannot be represented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128779d84202e0cb35769444f642fedc1fdb08eb" translate="yes" xml:space="preserve">
          <source>Program support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8d9313490c82ca81623307ec10d5f0ca9c7e23" translate="yes" xml:space="preserve">
          <source>Program support utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74641b834d4b980ea6b99d6f71d4205f5d04af" translate="yes" xml:space="preserve">
          <source>Program termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97dcfa91ab18288057a7525c537ab15fcda3ba9" translate="yes" xml:space="preserve">
          <source>Programs are allowed to undefine and perhaps redefine the &lt;code&gt;imaginary&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f47783eb436bfec79c2ae8a4b06844533f9db1" translate="yes" xml:space="preserve">
          <source>Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7bc81b09fe84b88c2bd0e91a6086f7a1dfafed" translate="yes" xml:space="preserve">
          <source>Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb46876475b9a3c594329ae7d4c2bd309d10edc" translate="yes" xml:space="preserve">
          <source>Pseudo-random integer value between &lt;code&gt;​0​&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt;, inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5a7109434fde15be7042621fb38dd5bd8bc899" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb1858154779be9095d34bc86481decea9864b5" translate="yes" xml:space="preserve">
          <source>Qualifiers</source>
          <target state="translated">Qualifiers</target>
        </trans-unit>
        <trans-unit id="16bebbd20f166f2a5ea26c1b0af5de0e236903be" translate="yes" xml:space="preserve">
          <source>Queries size of the object or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d55ee059891ac401548250f745320d7d227a13e" translate="yes" xml:space="preserve">
          <source>Queries the alignment requirement of its operand type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd72c18ecc72527ffc7db119290d9fafdfaada3" translate="yes" xml:space="preserve">
          <source>RAND_MAX</source>
          <target state="translated">RAND_MAX</target>
        </trans-unit>
        <trans-unit id="5bc0e782fee69e248da319d61fadfbdb19817a87" translate="yes" xml:space="preserve">
          <source>RSIZE_MAX</source>
          <target state="translated">RSIZE_MAX</target>
        </trans-unit>
        <trans-unit id="ff0c33f8fb105a6ed44c92c4e5ae8502e2bdba20" translate="yes" xml:space="preserve">
          <source>Range allows for a positive leap second. Two leap seconds in the same minute are not allowed (the C90 range 0..61 was a defect)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a2342a836fe9c8230bf65e4558f0b9e4f68cf9" translate="yes" xml:space="preserve">
          <source>Range error due to overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de112ad2a3e15627f3e2c881b1c1bf4687ea0fa6" translate="yes" xml:space="preserve">
          <source>Range error due to underflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53c2d131febb348823fab8a8a7d0f0c49482130" translate="yes" xml:space="preserve">
          <source>Range of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37101c7690c8bed05343fdcf031f4dd86381216e" translate="yes" xml:space="preserve">
          <source>Reaching the end of a function other than &lt;code&gt;main&lt;/code&gt; is equivalent to &lt;code&gt;return;&lt;/code&gt;. For &lt;code&gt;main&lt;/code&gt;, see &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;. Reaching the end of any other value-returning function is undefined behavior, but only if the result of the function is used in an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b10874047f0d31d06ba0f678394a1558eb74c90" translate="yes" xml:space="preserve">
          <source>Reads at most &lt;code&gt;count - 1&lt;/code&gt; characters from the given file stream and stores them in the character array pointed to by &lt;code&gt;str&lt;/code&gt;. Parsing stops if end-of-file occurs or a newline character is found, in which case &lt;code&gt;str&lt;/code&gt; will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a053a84cc889b5d3c92765d188b2591de5606290" translate="yes" xml:space="preserve">
          <source>Reads at most &lt;code&gt;count - 1&lt;/code&gt; wide characters from the given file stream and stores them in &lt;code&gt;str&lt;/code&gt;. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case &lt;code&gt;str&lt;/code&gt; will contain that wide newline character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577d417b88723fd8d0664a0440d1fc3c6b1a5869" translate="yes" xml:space="preserve">
          <source>Reads data from the a variety of sources, interprets it according to &lt;code&gt;format&lt;/code&gt; and stores the results into given locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c3f38917027942bdf2defee55f33a1a1676ada" translate="yes" xml:space="preserve">
          <source>Reads data from the a variety of sources, interprets it according to &lt;code&gt;format&lt;/code&gt; and stores the results into locations defined by &lt;code&gt;vlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa138f75335cb58d8db30ce0ee0a0de2de7beb5" translate="yes" xml:space="preserve">
          <source>Reads the next character from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2040213b573097b00ae3d44f08b595fececd40" translate="yes" xml:space="preserve">
          <source>Reads the next character from the given input stream. &lt;code&gt;getc()&lt;/code&gt; may be implemented as a macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72999a3c575875931a086d20314e99d122ec063" translate="yes" xml:space="preserve">
          <source>Reads the next wide character from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84d93c4e41037a71622e042bcd5082f7de2ea49" translate="yes" xml:space="preserve">
          <source>Reads the next wide character from the given input stream. &lt;code&gt;getwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a8038f3d0bac711fcdfd004cb5474cff9c4e23" translate="yes" xml:space="preserve">
          <source>Reads up to &lt;code&gt;count&lt;/code&gt; objects into the array &lt;code&gt;buffer&lt;/code&gt; from the given input stream &lt;code&gt;stream&lt;/code&gt; as if by calling &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object, and storing the results, in the order obtained, into the successive positions of &lt;code&gt;buffer&lt;/code&gt;, which is reinterpreted as an array of &lt;code&gt;unsigned char&lt;/code&gt;. The file position indicator for the stream is advanced by the number of characters read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9266667148dc51fc79e9429ea568b4ab14d9de2c" translate="yes" xml:space="preserve">
          <source>Real floating point conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bbe45c6a09f891e695a4039d8a9ca160c174cc" translate="yes" xml:space="preserve">
          <source>Real floating types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b665fb83dd46a743ece6ac7788ff25eeb048fd90" translate="yes" xml:space="preserve">
          <source>Real floating-integer conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a32b612aa6c59a4802452532b040a4e7a646411" translate="yes" xml:space="preserve">
          <source>Real floating-point numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - / * and various mathematical functions from &lt;a href=&quot;../numeric/math&quot;&gt;math.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92febfb20f305a4d8914c7caffc977ee875c316b" translate="yes" xml:space="preserve">
          <source>Real function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6047f2f13b3af12ce60b06fad6bafa995c0fecd" translate="yes" xml:space="preserve">
          <source>Real-complex conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b2234d9f5d07a67c20fac09814d91d258d8ed6" translate="yes" xml:space="preserve">
          <source>Real-imaginary conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5716cadec080cabf5f5ba082ba735d204bed3d" translate="yes" xml:space="preserve">
          <source>Real-only functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5c7e6d49217d70be43ccd48aabc9abb7c3602d" translate="yes" xml:space="preserve">
          <source>Reallocates the given area of memory. It must be previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt; and not yet freed with a call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt;. Otherwise, the results are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="084f870de5376a14cc6b9d5dd50fedb1c1d6123f" translate="yes" xml:space="preserve">
          <source>Regardless of the value of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;, any floating-point expression may be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b43a841c03f3265698cc1a93eb64dd11cbde0b" translate="yes" xml:space="preserve">
          <source>Regardless of whether inlining takes place, the following semantics of inline functions are guaranteed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91af7cb71f0bd495564c453ecaf3465fbea46d68" translate="yes" xml:space="preserve">
          <source>Registers the function pointed to by &lt;code&gt;func&lt;/code&gt; to be called on normal program termination (via &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; or returning from &lt;code&gt;main()&lt;/code&gt;). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c363bab80721525fb8f92a805ae0e41c65ed700c" translate="yes" xml:space="preserve">
          <source>Registers the function pointed to by &lt;code&gt;func&lt;/code&gt; to be called on quick program termination (via &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6715560f0ec6bebb7d9cfaefb747366461ac444" translate="yes" xml:space="preserve">
          <source>Regular &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; aligns memory suitable for any object type (which, in practice, means that it is aligned to &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;)&lt;/code&gt;). This function is useful for over-aligned allocations, such as to SSE, cache line, or VM page boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fa22a00ce265dc796c706bf3adebe616b0341c" translate="yes" xml:space="preserve">
          <source>Relational operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810fdc44728dd00b9265817c5479d56e97a6735e" translate="yes" xml:space="preserve">
          <source>Relational operators are not defined for complex types (there is no notion of &quot;less than&quot;)  &lt;a href=&quot;conversion&quot;&gt;Implicit conversions&lt;/a&gt; are defined between complex types and other arithmetic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dad4e24547281740bab0b6424d17e8db7bf9901" translate="yes" xml:space="preserve">
          <source>Relationship with volatile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c5cb0dd39fd5f8960a126f776dbc3b14c78315" translate="yes" xml:space="preserve">
          <source>Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation's atomicity is guaranteed (see &lt;a href=&quot;memory_order#Relaxed_ordering&quot;&gt;Relaxed ordering&lt;/a&gt; below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332a6fa800dab748056c239b8ee0efb205f4447c" translate="yes" xml:space="preserve">
          <source>Relaxed ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58453a35482a76c4a6c848eaa246de1ef9209c7" translate="yes" xml:space="preserve">
          <source>Release sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d1207cbd03d1b413657584c3395f5bd0ed2f5e" translate="yes" xml:space="preserve">
          <source>Release-Acquire ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39c9974a3cea1d56e06409a4e0aafdeca8e0911" translate="yes" xml:space="preserve">
          <source>Release-Consume ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="cb03fda356568db4d5e3e86bde6f95f62a88efdc" translate="yes" xml:space="preserve">
          <source>Renormalizes local calendar time expressed as a &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; object and also converts it to time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are ignored. The values in &lt;code&gt;time&lt;/code&gt; are not checked for being out of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54f3dfed1488935d7c52054cea01eb56aeaf7df" translate="yes" xml:space="preserve">
          <source>Replacing text macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360bc539904b3901915f57b0aead8cb40373f0de" translate="yes" xml:space="preserve">
          <source>Representation</source>
          <target state="translated">Representation</target>
        </trans-unit>
        <trans-unit id="f58188a9fa856b68ed7f26e3ac08aa0d1104663c" translate="yes" xml:space="preserve">
          <source>Reserved identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1beabd25888481ef7e7320f042c946ece8ae71" translate="yes" xml:space="preserve">
          <source>Resets the error flags and the &lt;code&gt;EOF&lt;/code&gt; indicator for the given file stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6dde473741ea38e3e837590483812eb679e2c0c" translate="yes" xml:space="preserve">
          <source>Restricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="299a15e6a23badee14ff1ded59c353807a27199b" translate="yes" xml:space="preserve">
          <source>Result too large</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6883e0e7dc8792ea7ee4d1fd3e70a87b3885efd" translate="yes" xml:space="preserve">
          <source>Return from the function &lt;code&gt;func&lt;/code&gt; is equivalent to calling &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; with the argument equal to the return value of &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e60c61a2cb501fef535f6480a136abd92b092b" translate="yes" xml:space="preserve">
          <source>Returning from the &lt;a href=&quot;../language/main_function&quot;&gt;the main function&lt;/a&gt;, either by a &lt;code&gt;return&lt;/code&gt; statement or by reaching the end of the function, executes &lt;code&gt;exit()&lt;/code&gt;, passing the argument of the return statement (or &lt;code&gt;​0​&lt;/code&gt; if implicit return was used) as &lt;code&gt;exit_code&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c6de90b23169d6f174b12ffb8d2aaeca2a0c12" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;y&lt;/code&gt;, no longer a part of a dependency tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2809a59ee9f0296bb53a75fbb2a47dc36322d0c1" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;ch&lt;/code&gt; on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0963a3c6426ccf7883b34bb28e1079108f6d44" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d34cc53c91cb0ef88db625515c39c82b4e81a1" translate="yes" xml:space="preserve">
          <source>Returns a pseudo-random integer value between &lt;code&gt;​0​&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt; (0 and &lt;code&gt;RAND_MAX&lt;/code&gt; included).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4030079cb9790be4a62baca1ff6ddcb26790ee" translate="yes" xml:space="preserve">
          <source>Returns pointer to the beginning of the next token or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if there are no more tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e65f5a894dd95dc019d600d1dbfddceab4bb9d5" translate="yes" xml:space="preserve">
          <source>Returns pointer to the beginning of the next token or null pointer if there are no more tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e63a227541857b3a0da5079dc8797dd3c7c831" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the type &lt;a href=&quot;compatible_type#Type_names&quot;&gt;named&lt;/a&gt; by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663871df15b2f6ee9e26e55a41663284ec4550db" translate="yes" xml:space="preserve">
          <source>Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by &lt;code&gt;&lt;a href=&quot;clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b17bbf99a58a2143f7c445a6dd4cc3aa96f5b1" translate="yes" xml:space="preserve">
          <source>Returns the current calendar time encoded as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object, and also stores it in the &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;arg&lt;/code&gt; (unless &lt;code&gt;arg&lt;/code&gt; is a null pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b69ea241d835183fed16fae52dc52cb37b02021" translate="yes" xml:space="preserve">
          <source>Returns the current rounding direction of floating-point arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6b322504672a6970700b3e04757f1b29aeb267" translate="yes" xml:space="preserve">
          <source>Returns the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a00730c0bc95f0373e8ebb17b29d4645a75f3e2" translate="yes" xml:space="preserve">
          <source>Returns the identifier of the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30459c10ad5105d0ab1705279ee5b1a61d5f35d" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters found in the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e911e9f618600fcec443b1b3eb7fe87250c3b0c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd874c8f829aec557cab43dde4fea18e303b214e" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cfb1d10d156ad85db1a941437a837070c48ee2" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters found in wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94aa99483b81e6bfe86ca5ad316ad9be3e71bd24" translate="yes" xml:space="preserve">
          <source>Returns the value held in thread-specific storage for the current thread identified by &lt;code&gt;tss_key&lt;/code&gt;. Different threads may get different values identified by the same key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a31eb193820e7907fcfa74092de98c9c00c383" translate="yes" xml:space="preserve">
          <source>Returns zero on success. Otherwise &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned and the error indicator of the file stream is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3464f71d8a112c06004b412c38cc0c5da3a86307" translate="yes" xml:space="preserve">
          <source>Right-to-Left</source>
          <target state="translated">Right-to-Left</target>
        </trans-unit>
        <trans-unit id="fe82ba6f5d66b495587b08ed97ce387d2c4f2f77" translate="yes" xml:space="preserve">
          <source>Right-to-left</source>
          <target state="translated">Right-to-left</target>
        </trans-unit>
        <trans-unit id="bb11a8e3f8712e36e7cd9d1c615a4e3dbb03336a" translate="yes" xml:space="preserve">
          <source>Rules</source>
          <target state="translated">Rules</target>
        </trans-unit>
        <trans-unit id="e0e1e9bb21dd6bf2ca9e0ec4ae5e68aeafe63a3a" translate="yes" xml:space="preserve">
          <source>SCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX</source>
          <target state="translated">SCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX</target>
        </trans-unit>
        <trans-unit id="0c1c4579f2c3ffdd09da47704048a8f99de86d92" translate="yes" xml:space="preserve">
          <source>SCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN</source>
          <target state="translated">SCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN</target>
        </trans-unit>
        <trans-unit id="6d04b55aadc6ab9c5bbc2aa7259245c75e68b744" translate="yes" xml:space="preserve">
          <source>SCNd&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNd&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3dd91f84d0faf1a7978dad2e71c905da0953b4bb" translate="yes" xml:space="preserve">
          <source>SCNdFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNdFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31c5cc7de51ea969f267e338f9664c295f050b1c" translate="yes" xml:space="preserve">
          <source>SCNdLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNdLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="954af9691203e55c28f455fe350cb91ac544605d" translate="yes" xml:space="preserve">
          <source>SCNdMAX</source>
          <target state="translated">SCNdMAX</target>
        </trans-unit>
        <trans-unit id="130aefc4b4c263044102a86d820fa5fa1b1267bc" translate="yes" xml:space="preserve">
          <source>SCNdPTR</source>
          <target state="translated">SCNdPTR</target>
        </trans-unit>
        <trans-unit id="27443f5d3060bebbc97c2ae3ad46791875b6f35f" translate="yes" xml:space="preserve">
          <source>SCNi&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNi&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3333b86b76b7339b77825f7f7d8a7feabb8e8fb0" translate="yes" xml:space="preserve">
          <source>SCNiFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNiFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ec5adaf2b1bc307dc3d7f5c6e0e39ce1b1461a0" translate="yes" xml:space="preserve">
          <source>SCNiLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNiLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="322b1af9a53c72c177fbf3ea5885fc063c2ee978" translate="yes" xml:space="preserve">
          <source>SCNiMAX</source>
          <target state="translated">SCNiMAX</target>
        </trans-unit>
        <trans-unit id="1bca168cd6b75e54e9556697d1fefb33e9be5462" translate="yes" xml:space="preserve">
          <source>SCNiPTR</source>
          <target state="translated">SCNiPTR</target>
        </trans-unit>
        <trans-unit id="7ec6b9b949b7e74e362fe8e3617e5f1254b8993a" translate="yes" xml:space="preserve">
          <source>SCNo&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNo&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2aa75357781bdcd5db86111157ab4458a8d31f7" translate="yes" xml:space="preserve">
          <source>SCNoFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNoFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48241bcacb32921016825bbe262366c64825ba9f" translate="yes" xml:space="preserve">
          <source>SCNoLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNoLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dd57c71f9af34a05df64b2cb0852af74079c8e77" translate="yes" xml:space="preserve">
          <source>SCNoMAX</source>
          <target state="translated">SCNoMAX</target>
        </trans-unit>
        <trans-unit id="6ee478f14171bc68088d3a2d62f00688c4e93a83" translate="yes" xml:space="preserve">
          <source>SCNoPTR</source>
          <target state="translated">SCNoPTR</target>
        </trans-unit>
        <trans-unit id="82d2cfea406b75d643446d58e315fa444c32a554" translate="yes" xml:space="preserve">
          <source>SCNu&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNu&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9291e6fe3e56533e850c78bc70f169efe028e26" translate="yes" xml:space="preserve">
          <source>SCNuFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNuFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2482617647b1a07313a59631c1399e21f866b25" translate="yes" xml:space="preserve">
          <source>SCNuLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNuLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77a1bea67b77d4f2b90e2e18413d19c05eb1afcf" translate="yes" xml:space="preserve">
          <source>SCNuMAX</source>
          <target state="translated">SCNuMAX</target>
        </trans-unit>
        <trans-unit id="66f3921dcb65715e758f659e948b555986f1dc25" translate="yes" xml:space="preserve">
          <source>SCNuPTR</source>
          <target state="translated">SCNuPTR</target>
        </trans-unit>
        <trans-unit id="ff05862f1b9f3256053ef1a0a82cfa0412a700b5" translate="yes" xml:space="preserve">
          <source>SCNx&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNx&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da030e2b848d9fb4ff0dfef8744f6ff50635067a" translate="yes" xml:space="preserve">
          <source>SCNxFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNxFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc927540afddc8460a68daa198c325339d793206" translate="yes" xml:space="preserve">
          <source>SCNxLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNxLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d951cfaf38ab5146110920c0c300a03b43579d0" translate="yes" xml:space="preserve">
          <source>SCNxMAX</source>
          <target state="translated">SCNxMAX</target>
        </trans-unit>
        <trans-unit id="b28ed0a5c405253f7f22d9a0ed2013840fd1e090" translate="yes" xml:space="preserve">
          <source>SCNxPTR</source>
          <target state="translated">SCNxPTR</target>
        </trans-unit>
        <trans-unit id="cbc7e0a19e1921df2bb4f7d98a66cf6142b0f475" translate="yes" xml:space="preserve">
          <source>SEEK_SETSEEK_CURSEEK_END</source>
          <target state="translated">SEEK_SETSEEK_CURSEEK_END</target>
        </trans-unit>
        <trans-unit id="a4987582417fa8d350d09c41eb8cd2418585e91d" translate="yes" xml:space="preserve">
          <source>SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</source>
          <target state="translated">SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</target>
        </trans-unit>
        <trans-unit id="e85f8b5c7eac9f932a93cbf9d03712194c0da0e2" translate="yes" xml:space="preserve">
          <source>SIGTERM</source>
          <target state="translated">SIGTERM</target>
        </trans-unit>
        <trans-unit id="c14418b849b6f44f556b64e716d39aa40f64e3c9" translate="yes" xml:space="preserve">
          <source>SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc45828951839d51ed09a34e9ec04114252f1c0" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MAX</source>
          <target state="translated">SIG_ATOMIC_MAX</target>
        </trans-unit>
        <trans-unit id="ed5fe11c179ff72e658bdf95049d44be1deebeae" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MIN</source>
          <target state="translated">SIG_ATOMIC_MIN</target>
        </trans-unit>
        <trans-unit id="11ba97d97359684906853156cac74443ad3705c5" translate="yes" xml:space="preserve">
          <source>SIG_DFL, SIG_IGN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6895a2910b6ef7a004e7772ca3f499a19fa27cde" translate="yes" xml:space="preserve">
          <source>SIG_DFLSIG_IGN</source>
          <target state="translated">SIG_DFLSIG_IGN</target>
        </trans-unit>
        <trans-unit id="acd6ee1f7bbae2aab00eb4fc3df100932eee5d46" translate="yes" xml:space="preserve">
          <source>SIG_ERR</source>
          <target state="translated">SIG_ERR</target>
        </trans-unit>
        <trans-unit id="6a03d61729004eed59186d910c6f0d01251b936b" translate="yes" xml:space="preserve">
          <source>SIG_IGN</source>
          <target state="translated">SIG_IGN</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="f658d226c6fe78d6a8dff531bcacf40e2b82dbda" translate="yes" xml:space="preserve">
          <source>Saves the current execution context into a variable &lt;code&gt;env&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt;. This variable can later be used to restore the current execution context by &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; function. That is, when a call to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; function is made, the execution continues at the particular call site that constructed the &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt; variable passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;. In that case &lt;code&gt;setjmp&lt;/code&gt; returns the value passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8cb9831326bba5b8e845dacab2bf2c27219923" translate="yes" xml:space="preserve">
          <source>Scalar</source>
          <target state="translated">Scalar</target>
        </trans-unit>
        <trans-unit id="a87679692caea6ead71e379f9146a196d7bfddd5" translate="yes" xml:space="preserve">
          <source>Scalar initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39320a9f36bca32338b46a710d9f674ca8c85e52" translate="yes" xml:space="preserve">
          <source>Scans the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt; for any character from the null-terminated byte string pointed to by &lt;code&gt;breakset&lt;/code&gt;, and returns a pointer to that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="3db912730b0dad4321d1c1f89eb58d808eb4c08d" translate="yes" xml:space="preserve">
          <source>Secondly, at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 7&lt;/a&gt;, a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and length just enough to contain the contents of the string literal plus one the null terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67609798fbc2f2d41baabfcff17da535b38c95d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4af47f21571f745f8bc1033920738fd1a86f78" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../types/limits#Limits_of_floating_point_types&quot;&gt;Limits of floating point types&lt;/a&gt; and &lt;a href=&quot;../numeric/math&quot;&gt;the math.h library&lt;/a&gt; for additional details, limits, and properties of the floating-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2a23d9725e4c4c211bef7fda4afecef5d8b573" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;alignof&quot;&gt;_Alignof operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62757d365bd7c24673f3de3c59fbbed524a89d9f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae75906653d2fa403026e65c694b5401b8148c28" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;declarations#Definitions&quot;&gt;definitions&lt;/a&gt; for the distinction between declarations and definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ff3d4f4d908d809ad3b6c697189968274bfca6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; for the rules that apply when no initializer is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22e07bda2dfc046f8aeed40779417a19213efb3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; for the details on the inline function definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85940fba0b167a19873e97d57805ad06ca5d7693" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7a520c9cedd35e00fc92d55ac979ee32a59534" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; for other details on the mechanics of a function call and &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; for returning from functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6b5138553cd15e71903a00bd710d67d09bcf8e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_precedence&quot;&gt;operator precedence&lt;/a&gt; for the details on the relative precedence of this operator and assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e738ab18c45f344ea0712ae4eecc83588fd51176" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sizeof&quot;&gt;sizeof operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37908cf859f75e007cff4ce8e59a97477f1164a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;storage_duration&quot;&gt;storage duration and linkage&lt;/a&gt; for the meaning of the keyword &lt;code&gt;extern&lt;/code&gt; with declarations at file scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f464fbea422f7bdf32a4ab54125c7cacbc7faa98" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;struct_initialization&quot;&gt;struct initialization&lt;/a&gt; for the rules about initialization of structs and unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a39f25186b95688add0e351acfec65c4480665" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;struct_initialization&quot;&gt;struct initialization&lt;/a&gt; for the rules regarding the initializers for structs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f65cbb0f97afb41bc0f53b0764e58a00b92b93" translate="yes" xml:space="preserve">
          <source>Seeds the pseudo-random number generator used by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; with the value &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1921a75e80a596c9a940068df630bd1b9feed6" translate="yes" xml:space="preserve">
          <source>Selection statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b86ee2bb16d1ad0e234de6e693444935ff7d48" translate="yes" xml:space="preserve">
          <source>Sends signal sig to the program. The signal handler, specified using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt;, is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cf851b8491eff8f5a5c736de201846803398a1" translate="yes" xml:space="preserve">
          <source>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c02107bfafa471d5b3be0bbb231a73bba241c" translate="yes" xml:space="preserve">
          <source>Sequentially-consistent ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab164f69a79c1434887771d963b350ec3424a69" translate="yes" xml:space="preserve">
          <source>Sets the error handler for signal &lt;code&gt;sig&lt;/code&gt;. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38e10aa0cf505b2d63a5565466d97ffcb80790e" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator and the multibyte parsing state (if any) for the file stream &lt;code&gt;stream&lt;/code&gt; according to the value pointed to by &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b3106e4fea3b14ec09212e58533017616bc0a5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt; to the value pointed to by &lt;code&gt;offset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5b6bf739a1d461326235edc3699165eed07554" translate="yes" xml:space="preserve">
          <source>Sets the internal buffer to use for stream operations. It should be at least &lt;code&gt;BUFSIZ&lt;/code&gt; characters long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac092b9a8bc6f10b53fdabf06fa851cf4ba6610" translate="yes" xml:space="preserve">
          <source>Sets the value of the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt; for the current thread to &lt;code&gt;val&lt;/code&gt;. Different threads may set different values to the same key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb85c2a6b05326373aa3e511f26f008dc789209" translate="yes" xml:space="preserve">
          <source>Several C compilers transform suitable memory-copying loops to &lt;code&gt;memcpy&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26bd0ea0f59b8ae2c73c9e1a142bd1fcfdbf81d" translate="yes" xml:space="preserve">
          <source>Several cleanup steps are performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096f451fac0362d4ca2620596aca61e92e355777" translate="yes" xml:space="preserve">
          <source>Several functions and macro constants for signal management are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c981f0807d02ebbc26c384c66d0564818dc020b9" translate="yes" xml:space="preserve">
          <source>Several varieties of expressions are known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5575c5d9e043f683dd305316e592c565f74bdc3a" translate="yes" xml:space="preserve">
          <source>Shift operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d2b7d5e16389ceda6305019182d49f160f8021" translate="yes" xml:space="preserve">
          <source>Show style used to print a NaN and IEEE format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bad6e8d0146ce897984d12435d02c17a86f56b" translate="yes" xml:space="preserve">
          <source>Show style used to print an infinity and IEEE format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdf422b3a4d436294c0ed604e530965527b4c41" translate="yes" xml:space="preserve">
          <source>Show the start of calendar time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f540f093bfd59e9a1bc4024dc293411a421fcad3" translate="yes" xml:space="preserve">
          <source>Show the start of the epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa2fd65f221fb441668eabd3b7d043130d5f61e" translate="yes" xml:space="preserve">
          <source>Shows the given error message and renders the program ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577457386419e49cc011db96f147d3e3e75e3f09" translate="yes" xml:space="preserve">
          <source>Signal handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda1c34f3e7ae5e716370d772211709548003ec4" translate="yes" xml:space="preserve">
          <source>Signal handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d946cd91c48d2465b1861bb4f63d569ff6618d1" translate="yes" xml:space="preserve">
          <source>Signal types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="83cbfd47b41a4ebb43e27ff9728af42d399bbda3" translate="yes" xml:space="preserve">
          <source>Signed integers : maximum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46aa2d10272ed1c7e156088e86d214a184422894" translate="yes" xml:space="preserve">
          <source>Signed integers : minimum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7add2e2fdaaac8a1396e22391085b13ed07cb9bd" translate="yes" xml:space="preserve">
          <source>Signed overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545d7834dd5b3ef1208d058079bb06e221ffb73e" translate="yes" xml:space="preserve">
          <source>Similar to struct, an unnamed member of a union whose type is a union without name is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c852d4b05ad6891a383f208151dde2146be732" translate="yes" xml:space="preserve">
          <source>Similar to struct, the behavior of the program is undefined if union is defined without any named members (including those obtained via anonymous nested structs or unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5468859643416fa0525930a9d474c24454c8fa" translate="yes" xml:space="preserve">
          <source>Similar to union, an unnamed member of a struct whose type is a struct without name is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd698e68713f1475dde3342a6ef031b284b2fe4" translate="yes" xml:space="preserve">
          <source>Similar to union, the behavior of the program is undefined if struct is defined without any named members (including those obtained via anonymous nested structs or unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdd4fe02838702cd6d96abf35e5bb32e0186abc" translate="yes" xml:space="preserve">
          <source>Simple assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b49109eb327d8d709c75e5626429f1b9dd9338" translate="yes" xml:space="preserve">
          <source>Since its stored value is initialized only once, an object with static storage duration can profile the invocations of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01023f649513952abe496b73748117186e5a306e" translate="yes" xml:space="preserve">
          <source>Single character is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f240da1d0f429d9b1906f5ac8b6dd8cc37d07d" translate="yes" xml:space="preserve">
          <source>Single digit is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1089a09be10396c011527de780e9b49cb3308d4a" translate="yes" xml:space="preserve">
          <source>Size in bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a653b7c543b492f6dd8c827ee1d1c68606cdc09a" translate="yes" xml:space="preserve">
          <source>Size-of&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-2&quot;&gt;[note 2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95dfd3d7d9a56268258c71284328df821c466067" translate="yes" xml:space="preserve">
          <source>Sizes of basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d962452bf23cfce358191ab2ce40997d4a7521" translate="yes" xml:space="preserve">
          <source>So that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined. (see e.g. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html&quot;&gt;gcc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6819c0f3ad693fb07ef3b17c21244653c494395" translate="yes" xml:space="preserve">
          <source>So the following complete program is valid C89:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c9d0ae4abd29c89694111dd04361b1e80cda44" translate="yes" xml:space="preserve">
          <source>So, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9df2c45a088ba26a758203f898adda0b9c99e0" translate="yes" xml:space="preserve">
          <source>Some atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba520fb2c503cdc25ec5b9b6f3a0f079c16b72d8" translate="yes" xml:space="preserve">
          <source>Some implementations handle &lt;code&gt;timeptr-&amp;gt;tm_mday==0&lt;/code&gt; as meaning the last day of the preceding month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d9a9a13766d236996c1d2bb4d126a13661dd61" translate="yes" xml:space="preserve">
          <source>Some locales offer additional character classes that detect non-ASCII digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8327d50eb27e2d33c783ff01dfd4bd720a5528" translate="yes" xml:space="preserve">
          <source>Some operations on floating-point numbers are affected by and modify the state of &lt;a href=&quot;../numeric/fenv&quot;&gt;the floating-point environment&lt;/a&gt; (most notably, the rounding direction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062d4ec3477261e4a029a283ebcf5e673c0c76e" translate="yes" xml:space="preserve">
          <source>Source file inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6281d436020e1e1aaac5be2a0ebe96a8e81a1643" translate="yes" xml:space="preserve">
          <source>Specifies range and precision of floating-point values obtained from floating-point constants and from all operations (operators, implicit conversions of operands) except assignment, cast, and library function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d2be3e15b5590b58922d853dd8def45b15e89" translate="yes" xml:space="preserve">
          <source>Specifies that the function does not return to its point of invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="5328552aac39954649b5d41d7c9d3dceb11e3086" translate="yes" xml:space="preserve">
          <source>Standard approach to preventing multiple inclusion of the same header is by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Include_guard&quot;&gt;include guards&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fa3463255f2929660b130be625bf2bf442a8eb" translate="yes" xml:space="preserve">
          <source>Standard arithmetic operators &lt;code&gt;+, -, *, /&lt;/code&gt; can be used with real, complex, and imaginary types in any combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa6210a01fc681b9801585337a1d40189cc03c1" translate="yes" xml:space="preserve">
          <source>Standard practice is to use the result of a call to &lt;code&gt;&lt;a href=&quot;../../chrono/time&quot;&gt;time&lt;/a&gt;(0)&lt;/code&gt; as the seed. However, &lt;code&gt;time()&lt;/code&gt; returns a &lt;code&gt;&lt;a href=&quot;../../chrono/time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; value, and &lt;code&gt;time_t&lt;/code&gt; is not guaranteed to be an integral type. In practice, though, every major implementation defines &lt;code&gt;time_t&lt;/code&gt; to be an integral type, and this is also what POSIX requires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf04f0f0d8ad2fb9946955b63cb23b446e2134b" translate="yes" xml:space="preserve">
          <source>Standard pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="d49483b8d2a411e4c07e5e138e5500c326175b6d" translate="yes" xml:space="preserve">
          <source>Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5591101f4957e3ec27936a1851a20e9327ccd528" translate="yes" xml:space="preserve">
          <source>Static initializer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cd462a941be3973f35bf4451b31c03d2b288c9" translate="yes" xml:space="preserve">
          <source>Static storage duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054b352055da9aba89fd42abb819a5be6e8dda75" translate="yes" xml:space="preserve">
          <source>Storage duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfda33bc2c68aa23641b6a374ebf0b31534902ce" translate="yes" xml:space="preserve">
          <source>Storage duration and Linkage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a6aea0529d546364a8c661d3d4c05e1e722645" translate="yes" xml:space="preserve">
          <source>Storage-class specifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f29340218ac4df7a30edf8029fb655d93da2f2" translate="yes" xml:space="preserve">
          <source>Storage-class specifiers appear in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. At most one specifier may be used, except that &lt;code&gt;_Thread_local&lt;/code&gt; may be combined with &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;extern&lt;/code&gt; to adjust linkage(since C11). The storage-class specifiers determine two independent properties of the names they declare:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c8de79d80c307a781d904e913db38ce10a7cf2" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f6100e0a3a4d2dd982d5c58873c4de7dc2134d" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f5e1a47da510fa4386d462c1aa32523fb29a1e" translate="yes" xml:space="preserve">
          <source>Strict aliasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26b1bbd9eee2dfd3f5c0a081017d1db1f7dfe02" translate="yes" xml:space="preserve">
          <source>String examination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d094087a6682f2883c0e2a5f324321ae7f6ef95c" translate="yes" xml:space="preserve">
          <source>String literals are &lt;b&gt;not modifiable&lt;/b&gt; (and in fact may be placed in read-only memory such as &lt;code&gt;.rodata&lt;/code&gt;). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d113a02479dcd3262a9b7b816910df94ea4083" translate="yes" xml:space="preserve">
          <source>String literals can be used to &lt;a href=&quot;array_initialization&quot;&gt;initialize arrays&lt;/a&gt;, and if the size of the array is one less the size of the string literal, the null terminator is ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="85aec181db33cf00bdd54f1cb9ce01b7d7ff51de" translate="yes" xml:space="preserve">
          <source>Strings library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50144303ba816c6227872493fae52a6111ce6e9" translate="yes" xml:space="preserve">
          <source>Struct and union initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5f7c969886addc36643f3c8d0fcf398dacad9" translate="yes" xml:space="preserve">
          <source>Struct and union objects with array members (either direct or members of nested struct/union members) that are designated by &lt;a href=&quot;value_category&quot;&gt;non-lvalue expressions&lt;/a&gt;, have</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2054b477c350696a3482d27f31c7c82e09f51cdc" translate="yes" xml:space="preserve">
          <source>Struct declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de20aa2876654859a7823f0531a18a6b124938c" translate="yes" xml:space="preserve">
          <source>Struct members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4926985eb4091c3107b5920cf2b4c09a3d99de88" translate="yes" xml:space="preserve">
          <source>Structure and union member access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272728ee96c53fab74b3b727d2572a254ed8e08d" translate="yes" xml:space="preserve">
          <source>Structure and union member access through pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9dcf8956ae1c0d6f55e5d5d3036df614ef80f7" translate="yes" xml:space="preserve">
          <source>Structure holding a calendar date and time broken down into its components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6829a88eb9844dcc19a2c6962557c4417821a67d" translate="yes" xml:space="preserve">
          <source>Structure holding an interval broken down into seconds and nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1206016193c83a65cb929069fe8c573d05b83bd9" translate="yes" xml:space="preserve">
          <source>Structure/Union</source>
          <target state="translated">Structure/Union</target>
        </trans-unit>
        <trans-unit id="b1bd6eaaf0ebc0fa2da36cbd85120b995ab0f777" translate="yes" xml:space="preserve">
          <source>Subscript</source>
          <target state="translated">Subscript</target>
        </trans-unit>
        <trans-unit id="f9b527d9bda6aa5482f9a99c0dadede2f93f0385" translate="yes" xml:space="preserve">
          <source>Successive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3728d9b3ae40693e7dfcd90d79f3156adfcd6ad" translate="yes" xml:space="preserve">
          <source>Suffix/postfix increment and decrement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10698a431939209ee6970ff65cfdea1f722da147" translate="yes" xml:space="preserve">
          <source>Support for zero size is deprecated as of C11 DR 400.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="e3f57ed7e444bdff9887253d716ac7e573551461" translate="yes" xml:space="preserve">
          <source>T1, using an lvalue expression (typically, dereferencing a pointer) of a different type T2 is undefined behavior, unless:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b891eebe5bb2352df82dc8af5d22dfa5983cdbb" translate="yes" xml:space="preserve">
          <source>T2 and T1 are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf14ef848bbe7cf30f4f086c03a47a07d50b7c3b" translate="yes" xml:space="preserve">
          <source>T2 is a character type (char, signed char, or unsigned char).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9acb2dd9854b692972eac6ab63684c3439d4d54" translate="yes" xml:space="preserve">
          <source>T2 is a signed or unsigned version of a type that is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with T1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22213a71b43410f67e1bcaf848e74cd92aa863de" translate="yes" xml:space="preserve">
          <source>T2 is an aggregate type or union type type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3222042b89208ab9a488469183bcb236029e898" translate="yes" xml:space="preserve">
          <source>T2 is cvr-qualified version of a type that is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with T1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa822a5894e63ba6a65478d203534aaa7258110c" translate="yes" xml:space="preserve">
          <source>TMP_MAXTMP_MAX_S</source>
          <target state="translated">TMP_MAXTMP_MAX_S</target>
        </trans-unit>
        <trans-unit id="82df224f71dc6745757dbb4235c8881c1d18f43f" translate="yes" xml:space="preserve">
          <source>TSS_DTOR_ITERATIONS</source>
          <target state="translated">TSS_DTOR_ITERATIONS</target>
        </trans-unit>
        <trans-unit id="14ae799bf325e27219d4ab3dc8ddcea9a6895d3c" translate="yes" xml:space="preserve">
          <source>Tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period &amp;pi;i, and has poles of the first order along the real line, at coordinates (&amp;pi;(1/2 + n), 0). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.  Mathematical definition of the tangent is tan z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d5a28c86c89a046431264e4a80d7f157a3ec1" translate="yes" xml:space="preserve">
          <source>Temporary lifetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1c120671c6b185751a3483c14ffff80c213d47" translate="yes" xml:space="preserve">
          <source>Tentative definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6859d39f71cebf21461938215c02df2587c3222c" translate="yes" xml:space="preserve">
          <source>Tentative definitions were invented to standardize various pre-C89 approaches to forward declaring identifiers with internal linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333aeb3f88a64f1c35827b76c34a5ecfa422bdf4" translate="yes" xml:space="preserve">
          <source>Terminates current function and returns specified value to the caller function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445afbe9b171a445fd57b5067266d572c8745658" translate="yes" xml:space="preserve">
          <source>Ternary conditional&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-3&quot;&gt;[note 3]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ae5ac48fe369a69211c19f055bfcf5a33c86967b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../numeric/tgmath&quot;&gt;type-generic math macros&lt;/a&gt; from &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, introduced in C99, were implemented in compiler-specific manner. Generic selections, introduced in C11, gave the programmers the ability to write similar type-dependent code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84abb4fe9ca223ed7f80490baed684f4ff9ad4ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement, when encountered anywhere in statement, exits the switch statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e9226ba1bb77688811e391a403b3c92b5c71cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; used anywhere within the loop_statement transfers control to iteration_expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a3e9a3da878c7d9d43e6d58c8263ef19784399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;declarations&quot;&gt;type specifier&lt;/a&gt; for a struct is identical to the &lt;a href=&quot;union&quot;&gt; &lt;code&gt;union&lt;/code&gt;&lt;/a&gt; type specifier except for the keyword used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7fea41c467944fca863f8d470daa88608715a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;declarations&quot;&gt;type specifier&lt;/a&gt; for a union is identical to the &lt;a href=&quot;struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; type specifier except for the keyword used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca50bbf10496221d648429763c6c788f42208573" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt; of subexpressions in an array initializer is indeterminately sequenced in C (but not in C++ since c++11):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76526eba2549f1ba1dbcfaec438e36835c80f656" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt; of the subexpressions in any initializer is indeterminately sequenced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ddf054b9d98118850acc7743563e5e0b4e9519" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html&quot;&gt;POSIX version of lgamma&lt;/a&gt; is not thread-safe: each execution of the function stores the sign of the gamma function of &lt;code&gt;arg&lt;/code&gt; in the static external variable &lt;code&gt;signgam&lt;/code&gt;. Some implementations provide &lt;code&gt;lgamma_r&lt;/code&gt;, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d7bc66a49b20e8a34f3db4a41996210816f021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; specifier is formally listed as a storage-class specifier in the C language grammar, but it is used to declare type names and does not specify storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc44a80beef5758e5f19639b3d3e0f4a9b3c9e40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types&quot;&gt;types&lt;/a&gt;&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, and &lt;code&gt;signed char&lt;/code&gt; use one byte for both storage and &lt;a href=&quot;object&quot;&gt;value representation&lt;/a&gt;. The number of bits in a byte is accessible as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5580629e543718292e7f034670f977aad2737a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the cast expression is always non-lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e7d677d59314533c3183efd27477692b57ab2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; types do not provide inter-thread synchronization, memory ordering, or atomicity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dafadbf8ca29d1023c3269e8fbe7224a999675b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#define&lt;/code&gt; directives define the identifier as a macro, that is they instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70381beffacc10871e5b37c4ec262605e4cc6a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#undef&lt;/code&gt; directive undefines the identifier, that is it cancels the previous definition of the identifier by &lt;code&gt;#define&lt;/code&gt; directive. If the identifier does not have an associated macro, the directive is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20222cee5dd37e389f85b67fab4f0c2de44ee010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; header provides generic file operation support and supplies functions with narrow character input/output capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a1a18ed73b3be37e1a913f7ef79ffbc39baeea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; header supplies functions with wide character input/output capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac2b700ba018b88fda0accdeb14d96e93bc0cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; macros expand into integral expressions that can be used as arguments to the &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; function (and, therefore, as the values to return from the &lt;a href=&quot;../language/main_function&quot;&gt;main function&lt;/a&gt;), and indicate program execution status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5615a09c39393c229b9c18967835ce479d5d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt;, &lt;code&gt;FP_ZERO&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NAN&lt;/code&gt; macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200966c346b96b643933a6da4012101e743e905a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HUGE_VALF&lt;/code&gt;, &lt;code&gt;HUGE_VAL&lt;/code&gt; and &lt;code&gt;HUGE_VALL&lt;/code&gt; macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ca89171bb30d49ea70bf6004b7252bcefb680f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;I&lt;/code&gt; macro expands to either &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;. If the implementation does not support imaginary types, then the macro always expands to &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ab0f1b6c9b80608c46a2c86f5289d67f530aca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIG_DFL&lt;/code&gt; and &lt;code&gt;SIG_IGN&lt;/code&gt; macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dc2deef955b4751fa64fbac9a725409e234d9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Complex_I&lt;/code&gt; macro expands to a value of type &lt;code&gt;const float _Complex&lt;/code&gt; with the value of the imaginary unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ba0bf621e8b3660d5038c597e3fa4d89a776c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Imaginary_I&lt;/code&gt; macro expands to a value of type &lt;code&gt;const float _Imaginary&lt;/code&gt; with the value of the imaginary unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6102e49c22b9639171dd7168842805c8b42deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Noreturn&lt;/code&gt; keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;). If the function declared &lt;code&gt;_Noreturn&lt;/code&gt; returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c12a492195d08d7680b31380fcd02cca76d818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Noreturn&lt;/code&gt; specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b441eccd09a0d3b90efa2fbf5cf4c48ac62ce5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; label of a &lt;a href=&quot;switch&quot;&gt;switch statement&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b82034e3bfd61c7426ddb432f33a7f8ce1c6f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; statement causes a jump, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, to the end of the loop body (it may only appear within the loop body of &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, and &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loops).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4450351bba8998fd3f9dc09c3bd22850aee0cfaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cproj&lt;/code&gt; function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5731587eb746d1dad2e49fe74c5697f79eced509" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; version of &lt;code&gt;round&lt;/code&gt; behaves as if implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b177cd6cc2404dd925704b969516edf40ab372" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; is always associated with the closest preceding &lt;code&gt;if&lt;/code&gt; (in other words, if statement_true is also an if statement, then that inner if statement must contain an &lt;code&gt;else&lt;/code&gt; part as well):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb840778c4247edccecb50773383d04f6d851f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gets()&lt;/code&gt; function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on &lt;code&gt;stdin&lt;/code&gt;). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. &lt;code&gt;&lt;a href=&quot;fgets&quot;&gt;fgets()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;gets_s()&lt;/code&gt; are the recommended replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12de6802a92d23201c2059da142ae2e1863d0973" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt; statement causes an unconditional jump (transfer of control) to the statement prefixed by the named label (which must appear in the same function as the goto statement), except when this jump would enter the scope of a &lt;a href=&quot;array&quot;&gt;variable-length array&lt;/a&gt; or another &lt;a href=&quot;declarations&quot;&gt;variably-modified type&lt;/a&gt;.(since C99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f985b573ca6ee1aec3cd2f6f2f5e14e4f8be04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; keyword was adopted from C++, but in C++, if a function is declared inline, it must be declared inline in every translation unit, and also every definition of an inline function must be exactly the same (in C, the definitions may be different, as long as the behavior of the program does not depend on the differences). On the other hand, C++ allows non-const function-local statics and all function-local statics from different definitions of an inline function are the same in C++ but distinct in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f74231bbb34168db7edcaa806299c71b6dbaf84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jmp_buf&lt;/code&gt; type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type &lt;code&gt;jmp_buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd606079755e7ec046b2b8c9fc11be616e24a10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localeconv&lt;/code&gt; function obtains a pointer to a static object of type &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;lconv&lt;/a&gt;&lt;/code&gt;, which represents numeric and monetary formatting rules of the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c7934dd60a79d64a61f1a71e362826f86656fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373830865d083f56e567e0e35241e9449625781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function has several special properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbff63dfe1a1c3feb8eb0a4f936a30dc7d837b81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b46a4ac460c3056896a6a86b5876ca421322fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;puts&lt;/code&gt; function appends the newline character to the output, while &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;fputs&lt;/a&gt;&lt;/code&gt; function does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337b4f14f91f70ec7af782682bbdfecfe5ad1f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalbln&lt;/code&gt; function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than 32767, the standard-guaranteed &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;. In particular, for the 80-bit &lt;code&gt;long double&lt;/code&gt;, the factor is 32828.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b60c9e939da9755686b6ae70e02cdd28175c2b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setlocale&lt;/code&gt; function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to &lt;code&gt;setlocale&lt;/code&gt;. If &lt;code&gt;locale&lt;/code&gt; is a null pointer, &lt;code&gt;setlocale&lt;/code&gt; queries the current C locale without modifying it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c145771552ff7f32cdea974ba3f62f25963eacf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtok_s&lt;/code&gt; function differs from the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html&quot;&gt;strtok_r&lt;/a&gt; function by guarding against storing outside of the string being tokenized, and by checking runtime constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de369af2c72028e52c81811c4f3e7e9a5b513874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_arg&lt;/code&gt; macro expands to an expression of type &lt;code&gt;T&lt;/code&gt; that corresponds to the next parameter from the &lt;code&gt;va_list&lt;/code&gt;&lt;code&gt;ap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d83c342cc7c3f40c89a420acc1bb2923f355ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_copy&lt;/code&gt; macro copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8d7607bf53e5be070f8a32b172032dad9d0e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_end&lt;/code&gt; macro performs cleanup for an &lt;code&gt;ap&lt;/code&gt; object initialized by a call to &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;. &lt;code&gt;va_end&lt;/code&gt; may modify &lt;code&gt;ap&lt;/code&gt; so that it is no longer usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf2761b4814114335aeebc1afaaa2a8836f144f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_start&lt;/code&gt; macro enables access to the variable arguments following the named argument &lt;code&gt;parmN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c178f303930e7ee937bb808b750bf972f0b2a5fc" translate="yes" xml:space="preserve">
          <source>The C language standard precisely specifies the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;observable behavior&lt;/a&gt; of C language programs, except for the ones in the following categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f4aadd45c8227a1e5fe1c8762201aa5167faca" translate="yes" xml:space="preserve">
          <source>The C numerics library includes common mathematical functions and types, as well as support for random number generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e780c2a081b6a90a3aa1a960aa33b566068175d" translate="yes" xml:space="preserve">
          <source>The C programming language, as of C99, supports Boolean arithmetic with the built-in type &lt;code&gt;_Bool&lt;/code&gt; (see &lt;a href=&quot;../keyword/_bool&quot;&gt;_Bool&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; is included, the Boolean type is also accessible as &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cf31e6418ffa7bd54cc5caaf9ef7aef1d4f2fc" translate="yes" xml:space="preserve">
          <source>The C programming language, as of C99, supports complex number math with the three built-in types &lt;code&gt;double _Complex&lt;/code&gt;, &lt;code&gt;float _Complex&lt;/code&gt;, and &lt;code&gt;long double _Complex&lt;/code&gt; (see &lt;a href=&quot;../keyword/_complex&quot;&gt;_Complex&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; is included, the three complex number types are also accessible as &lt;code&gt;double complex&lt;/code&gt;, &lt;code&gt;float complex&lt;/code&gt;, &lt;code&gt;long double complex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9206fd8248380fd0f85f54859dca51cdbeca995" translate="yes" xml:space="preserve">
          <source>The C source file is processed by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c05c2fc68c4375f5795f99eafaae38d20bf38bf" translate="yes" xml:space="preserve">
          <source>The C standard and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html&quot;&gt;POSIX&lt;/a&gt; specify that the behavior of &lt;code&gt;sprintf&lt;/code&gt; and its variants is undefined when an argument overlaps with the destination buffer. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72051079cc7c159c96ecf4a92232342192ed7cf8" translate="yes" xml:space="preserve">
          <source>The C type system consists of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8074f7033d870355bda79f918df527e49c8242e" translate="yes" xml:space="preserve">
          <source>The GNU implementation does not set &lt;code&gt;errno&lt;/code&gt; regardless of &lt;code&gt;math_errhandling&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234938443728dc9d7125d6292e796aa03d968ac4" translate="yes" xml:space="preserve">
          <source>The IEEE floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where the value &lt;code&gt;n&lt;/code&gt; is the integral value nearest the exact value &lt;code&gt;x/y&lt;/code&gt;. When |n-x/y| = &amp;frac12;, the value &lt;code&gt;n&lt;/code&gt; is chosen to be even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b803be3dc347d1eccfd895e8d543b98d468b36e" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent for this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html&quot;&gt;pthread_getspecific&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ac40d670ed9e92eedac0ca36c0b3bbedb25f3" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html&quot;&gt;nanosleep&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bdcc83ffc873a59df67fe1a0a4c21ca59a202f" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html&quot;&gt;pthread_key_create&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8057c66e8f1a020e1895762b7801c3addb6dd201" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_delete.html&quot;&gt;pthread_key_delete&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a295799725a341b45bc58d7c8960eaf5ce5fec1" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html&quot;&gt;pthread_once&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa65f453f8c26d94c2ad562a800ebd758dd6c8f9" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html&quot;&gt;pthread_setspecific&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01db62988e96524ed4b93590032fdc4c530cd1a4" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html&quot;&gt;sched_yield&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc82f43c11aee6b47eca6fd2fdfa83714c8150a7" translate="yes" xml:space="preserve">
          <source>The POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime(CLOCK_REALTIME, ts)&lt;/a&gt; may also be used to populate a &lt;code&gt;timespec&lt;/code&gt; with the time since the Epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1488e3e1725ba2ff4aa290f686cae3ecf80e21d5" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; (i.e. &lt;code&gt;|n|&lt;/code&gt;), if it is representable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b870be9a37a18d5d977d3678831f3407339e51cf" translate="yes" xml:space="preserve">
          <source>The actual sleep time may be longer than requested because it is rounded up to the timer granularity and because of scheduling and context switching overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dccc6d6e38ae33ba63d77fc8c1bc45b9948ef1cb" translate="yes" xml:space="preserve">
          <source>The address-of expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32b2d5a5486bdd69de221fdc12f25b0be6957e5" translate="yes" xml:space="preserve">
          <source>The address-of operator produces the &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator ((1)), the result is a pointer to function. If the operand is an object ((2)), the result is a pointer to object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc98c9b63b9736f29b37a9e7b0e581bccc94736d" translate="yes" xml:space="preserve">
          <source>The alignas specifier can only be used when declaring objects that aren't &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, and don't have the &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59dc253d6a5bb752ae635b9ca51e2fcb9241e5f" translate="yes" xml:space="preserve">
          <source>The alignment requirement of a type can be queried with &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781837e5b78f423a72b4bc7bbfde9fb961de52a5" translate="yes" xml:space="preserve">
          <source>The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed300236670f94b994460867ddba4af778962013" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;unsigned char&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the argument is first converted to a character string as if by &lt;b&gt;%ls&lt;/b&gt; with a &lt;code&gt;wchar_t[2]&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ee03c9d30db3c49bc902c4761239a61037963b" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt; as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/btowc&quot;&gt;btowc&lt;/a&gt;&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the &lt;code&gt;wint_t&lt;/code&gt; argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a753299662a50197ee1d3a69bb98a71d11bbe16" translate="yes" xml:space="preserve">
          <source>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f455787098090bbe7c33c66341af1a7971f3ca1" translate="yes" xml:space="preserve">
          <source>The argument list must be explicitly present in the declarator, it cannot be inherited from a typedef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022dd1e74282e977a770275328ad528abb79d79a" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; with zero-initialized conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a03b5940fa2b2b9a645f3d15e3a9855662e07fb" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of an array of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b05a6da792283284c41c232a974b5b2326fa339" translate="yes" xml:space="preserve">
          <source>The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45daeed08fd1b34a79c05358cadd45843dd504f7" translate="yes" xml:space="preserve">
          <source>The array subscrpt expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355acf6afa9301915d8cd9dac99ab246ee45808d" translate="yes" xml:space="preserve">
          <source>The atomic type is always lock-free</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536d76525e91daaed4f4bc6b42df12034fa6894d" translate="yes" xml:space="preserve">
          <source>The atomic type is never lock-free</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e69c089e66d80032f7e2daa041a7a95fc0d073" translate="yes" xml:space="preserve">
          <source>The atomic type is sometimes lock-free</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336ca1df89222546331425468429bcda23c8fd42" translate="yes" xml:space="preserve">
          <source>The behavior is defined only if both the original pointer and the result pointer are pointing at elements of the same array or one past the end of that array. Note that executing p-1 when p points at the first element of an array is undefined behavior and may fail on some platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864d90a43c91a3621584b295cefd86053c305ae4" translate="yes" xml:space="preserve">
          <source>The behavior is defined only if the result fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec443138fd336406f248f42bf21ac1d7e076e0f5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;count&lt;/code&gt; is less than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e516f8007cc4db73318a3053ef3fe4d2d126e19" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated byte strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464b76a8eef218307890a469421e1b605b19821f" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44460391a952d80167639892da39becaef08fba" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated wide strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030b1e4cf2a993b1e587ef118c94940c56309bb2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;signal&lt;/code&gt; is used in a multithreaded program. It is not required to be thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ceaef11d2a001b1146f5d2f6c38318a06571ed8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;str&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d4e477144a2395707732bc17a24147fe7e896c" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if a program calls &lt;code&gt;exit&lt;/code&gt; more than once, or if it calls &lt;code&gt;exit&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67b69e471b8334cea03a7df26c2882cba3a66f9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of either object pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The behavior is undefined if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e475a2a1f05af2371821b459cc739d41d58ee8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60450559905e4180b5cef68256d2d590f345857e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. If the objects overlap (which is a violation of the &lt;a href=&quot;../../language/restrict&quot;&gt;&lt;code&gt;restrict&lt;/code&gt;&lt;/a&gt; contract)(since C99), the behavior is undefined. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b37b54681ba09fd24715f9d29de73e8a5e8418" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if &lt;code&gt;dest&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2a0a38cb7447232fbdae70ad38ac84b4d28210" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efaa775646413dc1eb435407761f438970dafeea" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if after &lt;code&gt;free()&lt;/code&gt; returns, an access is made through the pointer &lt;code&gt;ptr&lt;/code&gt; (unless another allocation function happened to result in a pointer value equal to &lt;code&gt;ptr&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85852f38e8d11e132a731807df08363f7f17a86" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any member of &lt;code&gt;*time_ptr&lt;/code&gt; is outside its normal range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af17aa3f7eb917ebddf9d38f3434181934549811" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if both &lt;code&gt;str&lt;/code&gt; points to a character array which lacks the null character and &lt;code&gt;strmax&lt;/code&gt; points to a value which is greater than the size of that character array. As with all bounds-checked functions, &lt;code&gt;strtok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008e4a5353c52dcd24272f648cad15962d104e69" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if both &lt;code&gt;str&lt;/code&gt; points to a character array which lacks the null character and the size of that character array &amp;lt; &lt;code&gt;strsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;strsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strnlen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee63aeb51a37188d9cff4ebe130f87a96cfb80c5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if during a call to a function registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt;, the function exits with &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3103509bcd3b3e891e4c0da3613abac99ee6b6b3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;breakset&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34477ca142dfd7d1700ccb91181e2da44fd64c72" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc5f824746d76b13715d628ae49c18dcc2acb80" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;delim&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15e4f68c0b2a3d550a9b7890a88323ed3a7236a" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;substr&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20a9dd22a45ec31e734ddcf820693b4431349ff" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1e07260891d0ab894f95c0b06ac5577fbbab08" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; is not a pointer to a character array or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaab6c269f8944718df63cc4ed6bf2f8b08bc9eb" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calendar year indicated by &lt;code&gt;time_ptr-&amp;gt;tm_year&lt;/code&gt; has more than 4 digits or is less than the year 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d041d8280012db2104d0eb03dc0684c091737b" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the character arrays overlap, if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a character array (including if &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer), if the size of the array pointed to by &lt;code&gt;dest&lt;/code&gt; is less than &lt;code&gt;count&lt;/code&gt;, or if the size of the array pointed to by &lt;code&gt;src&lt;/code&gt; is less than &lt;code&gt;count&lt;/code&gt; and it does not contain a null character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d2f718c56694cd9534bf4c29b0ab70be38ce63" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298da5846442305076841ee50dee7b6ae3356104" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array does not have enough space for the contents of both &lt;code&gt;dest&lt;/code&gt; and the first &lt;code&gt;count&lt;/code&gt; characters of &lt;code&gt;src&lt;/code&gt;, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; is not a pointer to a null-terminated byte string or &lt;code&gt;src&lt;/code&gt; is not a pointer to a character array,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28cb485893574495bdf940a49f55dbd8d7217ce" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75927258cde7082c64c027c4137cbfc360391f60" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null wide character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89165e7d0691f8d76d7152c55b7488221f33af2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the memory area referred to by &lt;code&gt;ptr&lt;/code&gt; has already been deallocated, that is, &lt;code&gt;free()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; has already been called with &lt;code&gt;ptr&lt;/code&gt; as the argument and no calls to &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; resulted in a pointer equal to &lt;code&gt;ptr&lt;/code&gt; afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b10348058d0a2ba715c0cfc12ae65b467b766d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx&quot;&gt;Windows&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e920f35d17562e2f2c62c1d1cb89e0ef3eeaf9fc" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex does not support timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9969863afbf60da7e0947d726f32b67bec85c235" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex is not already locked by the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8050092f4075b9f24a7942c1f67f47f42cdc86" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex is not locked by the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941cde7772bbee68273ed590270aac59a2bc53fd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(dest)+&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(src)+1&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strcat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263f0f4483b4a7bc7d4194e3da7a06121b2ba20c" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed793d65b7434e6b81723078feaa75210ac493c6" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memmove_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b938301c208a4793d708319d12f33de3dfa6cd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memset_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a1acae375ffdabbc69e06b63682cf50c84ab57" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(dest,destsz)+strnlen(src,count)+1&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(src,count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;count&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d359b3ad713a42a7d0327609bd82b3064bd7d82" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;count&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae42ff9c041c331d2deb113dec62bdb1035816b1" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt;= &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d8fb77eabde35598fe8c80befa5c3efd1b6afe" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the strings overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a6656344e41c13f8d13ac7fd15d646c6fa9124" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the thread was previously detached or joined by another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed5428768cfa36ac6293011047aff1244867289" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; and is not equal to &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f89fd8214ddc7bd79349aaaba1184a91c6c5dd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; or is not equal to &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62957e5d410463c4be1ca4d979ecd30927255d8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ptr&lt;/code&gt; does not equal a value returned earlier by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;aligned_alloc()&lt;/code&gt;(since C11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adacf118e6e6367d1ffb7672550f2db2bee36eb9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of the pointer &lt;code&gt;stream&lt;/code&gt; is used after &lt;code&gt;fclose&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f347bb381347a2491ac53b9f03f07354d7781e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if writing to &lt;code&gt;buf&lt;/code&gt; occurs past the end of the array, which can happen when the size of the buffer pointed to by &lt;code&gt;buf&lt;/code&gt; is less than the number of characters in the error message which in turn is less than &lt;code&gt;bufsz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fbd235d00d2e7ae40b8381a871adbf84afa4db" translate="yes" xml:space="preserve">
          <source>The behavior is undefined when access occurs past the end of either array &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;. The behavior is undefined when either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is the null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aca785b489f09f6c1637e42931dd57a5d5c8595" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;atomic_compare_exchange_strong&lt;/code&gt; is as if the following was executed atomically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a245d62483a4a65fcb760aef3d8efe0051b97" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;ctime&lt;/code&gt; may be undefined for the values of time_t that result in the string longer than 25 characters (e.g. year 10000).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d3d7bae89495ba6eac9a99c281bbee52c30a78" translate="yes" xml:space="preserve">
          <source>The behavior of a function call to a function without a prototype is undefined if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb71e9af2c3c638a873dc06af2ae73a07596ef8" translate="yes" xml:space="preserve">
          <source>The behavior of the function call expression depends on whether the prototype of the function being called is &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; at the point of call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08434d32154e6b925a05a299485361cd8506034" translate="yes" xml:space="preserve">
          <source>The binary additive arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7176da4edb44fdfb24d715e7d3669be25b36085b" translate="yes" xml:space="preserve">
          <source>The binary multiplicative arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9db240d6b226db38cdd0681f0d0a825ae1eca5f" translate="yes" xml:space="preserve">
          <source>The binary operator % yields the remainder of the division of the first operand by the second (after usual arithmetic conversions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382ff6ecf838a6a209cbbe60826d1c97f46b4d1f" translate="yes" xml:space="preserve">
          <source>The binary operator * performs multiplication of its operands (after usual arithmetic conversions) following the usual arithmetic definitions, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc810453dd079897ee4b630ce3e654a70d7cfd5" translate="yes" xml:space="preserve">
          <source>The binary operator / divides the first operand by the second (after usual arithmetic conversions) following the usual arithmetics definitions, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b53aa8540cf3072f1caa4828d4f3227016694d" translate="yes" xml:space="preserve">
          <source>The bitwise arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b023ae87ef451cdf626ad0291435d5b825d5fd03" translate="yes" xml:space="preserve">
          <source>The bitwise shift operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f53b6f7139db25eee0ab1b3b913b97aac5e329d" translate="yes" xml:space="preserve">
          <source>The body of a function is provided in a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;. Each function must be defined only once in a program, unless the function is &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95d90f3b77a1b8a8d232cc7c475465a557b79bc" translate="yes" xml:space="preserve">
          <source>The body of a switch statement may have an arbitrary number of &lt;code&gt;case:&lt;/code&gt; labels, as long as the values of all constant_expressions are unique (after &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt; to the &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;promoted type&lt;/a&gt; of expression). At most one &lt;code&gt;default:&lt;/code&gt; label may be present (although nested switch statements may use their own &lt;code&gt;default:&lt;/code&gt; labels or have &lt;code&gt;case:&lt;/code&gt; labels whose constants are identical to the ones used in the enclosing switch).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea016ec910e6873dfc79ae24437a3c519704144a" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may set &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd808c844289be1c901eea1e57131ddc87294a7" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475e90afca51fa257232622941ddac8c0e483026" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of the expression &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt;. The macro does not evaluate x and y twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac907543c60c06a9a51c071f27b11749c7308d57" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55246b361f4bd424491e57d0679d399ec77fce75" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4ee1790c20fb3a8e3bfbcd260344fefc700848" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;&quot;)&lt;/code&gt; is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN()&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750d6f52d6633c563f387f35bc618f9f38ab304c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;n-char-sequence&quot;)&lt;/code&gt;, where &lt;code&gt;n-char-sequence&lt;/code&gt; is a sequence of digits, Latin letters, and underscores, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN(n-char-sequence)&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd0944bb87ba05c9b4df8e88949d3edad0b9ff6" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;string&quot;)&lt;/code&gt;, where &lt;code&gt;string&lt;/code&gt; is neither an n-char-sequence nor an empty string, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598cc8bc5da5b0fb6d667fdb74683a23070d43fe" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;getenv_s&lt;/code&gt; with a null pointer for &lt;code&gt;value&lt;/code&gt; and zero for &lt;code&gt;valuesz&lt;/code&gt; is used to determine the size of the buffer required to hold the entire result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0a943ad67969e22cbc79ab2e94f2ba315815da" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270c05d2c8f07be7812f6368dba8b69f41c5dd8c" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c893ac9cadbf00f7e9ef1a77d5a304aa079fc5b5" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b194103418cca6cbbfda4929c3c1041036b43cf0" translate="yes" xml:space="preserve">
          <source>The cast to void is sometimes useful to silence compiler warnings about unused results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb15aa2e205da76a53c99fdb5dd46d7ca6c8252c" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4035fa4f0afd21a7666c6150be01fe027d08712b" translate="yes" xml:space="preserve">
          <source>The characters of the C-strings pointed to by &lt;code&gt;grouping&lt;/code&gt; and &lt;code&gt;mon_grouping&lt;/code&gt; are interpreted according to their numeric values. When the terminating &lt;code&gt;'\0'&lt;/code&gt; is encountered, the last value seen is assumed to repeat for the remainder of digits. If &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; is encountered, no further digits are grouped. the typical grouping of three digits at a time is &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389756ed6e9c288a5d7721af8a052706a08051ec" translate="yes" xml:space="preserve">
          <source>The choices made by each implementation about the sizes of the fundamental types are collectively known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639291a4f3c29237da353a25b118487f41eb6c93" translate="yes" xml:space="preserve">
          <source>The comma operator expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4d04275fd3986990614e795bf7dee50a7571a4" translate="yes" xml:space="preserve">
          <source>The comma operator may be lvalue in C++, but never in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fc3f2fb9c171bbd01b3b6dc85f4ee9561d08bf" translate="yes" xml:space="preserve">
          <source>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7dee580f11aef5ebe6c5e769d0ef339e265bedd" translate="yes" xml:space="preserve">
          <source>The compiler is free to ignore any or all aliasing implications of uses of &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b3b0d4b525dd97c5a4869a198616c5154957d5" translate="yes" xml:space="preserve">
          <source>The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055be4235172d10af24ff6290ec130255293bd45" translate="yes" xml:space="preserve">
          <source>The completion of this function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6dbfec61e3424ffae4ae18efa158e9aeaf2271e" translate="yes" xml:space="preserve">
          <source>The complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; in the interval [0; &amp;infin;) along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c5651398368fa9194c75ad0cd42b27eaccd0a5" translate="yes" xml:space="preserve">
          <source>The complex exponential function ez</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a8bb4e0bd6e80ede57c9b2a0ef2ec124631eca" translate="yes" xml:space="preserve">
          <source>The compound assignment operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df263ae0e0ab175c4cedd3b99f705f4c1dd852a" translate="yes" xml:space="preserve">
          <source>The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbd0a48bc1fb7914fb073b18a7045d1a7fe29e4" translate="yes" xml:space="preserve">
          <source>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or an iteration statement):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abc060166b36e799feb998e7f4939e28b8ecdbf" translate="yes" xml:space="preserve">
          <source>The conditional operator expression has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c8621167c53476a1a98fe938c3c174cc4134ee" translate="yes" xml:space="preserve">
          <source>The conditional operator is never an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;, although it may return objects of struct/union type. The only other expressions that may return stucts are &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadd419c227bb685e0a0582aff80f1b5ba7a551d" translate="yes" xml:space="preserve">
          <source>The conditional preprocessing block starts with &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; directive, then optionally includes any number of &lt;code&gt;#elif&lt;/code&gt; directives, then optionally includes at most one &lt;code&gt;#else&lt;/code&gt; directive and is terminated with the &lt;code&gt;#endif&lt;/code&gt; directive. Any inner conditional preprocessing blocks are processed separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff37d62089a6b5f6e494aef62b9015866607221" translate="yes" xml:space="preserve">
          <source>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message (if provided) as part of the error message (except that characters not in &lt;a href=&quot;translation_phases&quot;&gt;basic source character set&lt;/a&gt; aren't required to be displayed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7733c072d8eb0d24e0b88f6986f86f0fb8a35998" translate="yes" xml:space="preserve">
          <source>The controlling-expression and the expressions of the selections that are not chosen are never evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eba86b24f08a5313c7cce0d40bb40425a6f3985" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;l[&lt;/code&gt; perform multibyte-to-wide character conversion as if by calling &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;&lt;code&gt;mbrtowc()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d720fad8838ce447569443ee37666195d1db03" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%[&lt;/code&gt;, without specifying the destination array size, is as unsafe as &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac471b8f3e3680d0aea88efb3834381526f7e2d3" translate="yes" xml:space="preserve">
          <source>The conversions &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; output &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;INFINITY&lt;/code&gt;, &lt;code&gt;NAN&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d126e7074c1cecdf337f1c334c8340ee765b367" translate="yes" xml:space="preserve">
          <source>The conversions not listed here are not allowed. In particular,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8e08acb16e81fb66cf54c1031e76e0b8784b0f" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the &lt;a href=&quot;../types/integer&quot;&gt;fixed-width integer types&lt;/a&gt; (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNdMAX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNuMAX&lt;/code&gt;&lt;/a&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0aa617af0af8a4ff0e8b9f43a4c9fad55a2792" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the fixed-width character types (&lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9b4026c72463dbf7e53d38e204b4285cee0558" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a72dc1f2a9cfd3fbe819a915b266b2d90a2d9e5" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a730e98fa4ae44b9e24fcf843d261fd0bdf207" translate="yes" xml:space="preserve">
          <source>The correct result can be represented as &lt;code&gt;int&lt;/code&gt; on all known implementations. For overflow to occur, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; must be less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; must be greater than &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942cf9ae9a6d3badc39db24111513090bfb3dd85" translate="yes" xml:space="preserve">
          <source>The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333d83e6dc8a3ed3cddeaf85bad80a985040ae63" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df76dc533f4832695e4faabdf4a21cf982bfbb46" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd990c0fc482fb45b1d3492d0748ec8b63e5c22" translate="yes" xml:space="preserve">
          <source>The current rounding mode affects the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430695fef50ce6b9934160789eacb1237ee74fd7" translate="yes" xml:space="preserve">
          <source>The current rounding mode does NOT affect the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f32fa1d98982e1738b953b2dd2b57c9e693298" translate="yes" xml:space="preserve">
          <source>The current rounding mode, reflecting the effects of the most recent &lt;code&gt;fesetround&lt;/code&gt;, can also be queried with &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ddc6fce10286bba6c1f8beb847e588ed427ba1" translate="yes" xml:space="preserve">
          <source>The current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd998795c1cd4032dd66b9872287706842aa61a2" translate="yes" xml:space="preserve">
          <source>The data storage (memory) available to a C program is one or more contiguous sequences of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8994a846037bbc39e1e65a3a929f7e6a5d07984" translate="yes" xml:space="preserve">
          <source>The decimal point specified by &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; has no effect on the syntax of floating constants: the decimal point character is always the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79072e7b56ba6659da6f87106f63e08064df5b7" translate="yes" xml:space="preserve">
          <source>The declaration of a variadic function uses an ellipsis as the last parameter, e.g. &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;language/variadic&quot;&gt;variadic arguments&lt;/a&gt; for additional detail on the syntax and automatic argument conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b207b37e6bcac2f107504e9d723a780830b61a" translate="yes" xml:space="preserve">
          <source>The default behavior of all atomic operations in the &lt;a href=&quot;../language/atomic&quot;&gt;language&lt;/a&gt; and the library provides for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4587bcdbb1b6bc9e3b5e438494b4e72f8dd1c68a" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627832562bf8dd374b20ff048dfc37aaca313b99" translate="yes" xml:space="preserve">
          <source>The definition of the macro &lt;code&gt;assert&lt;/code&gt; depends on another macro, &lt;code&gt;NDEBUG&lt;/code&gt;, which is not defined by the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb40399c9bd04128464837d331638d1fc355f39" translate="yes" xml:space="preserve">
          <source>The description is formed by concatenating the following components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db81ed6a406de31b6ca65d95bdd037c70cc38728" translate="yes" xml:space="preserve">
          <source>The destructor, if available, is not invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb97a7284cd296528abb21877065aef28175aa34" translate="yes" xml:space="preserve">
          <source>The destructor, if one was registered by &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;, is not called (they are only called at thread exit, either by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of &lt;code&gt;tss_id&lt;/code&gt; performed all necessary cleanup, before the call to &lt;code&gt;tss_delete&lt;/code&gt; is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2599aff3e1997c8bce0ea2079154bc10d116fd7" translate="yes" xml:space="preserve">
          <source>The double version of fmod behaves as if implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33813bc0fb85e40f1c26903767c91afaf907f09" translate="yes" xml:space="preserve">
          <source>The effect of calling &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; on a bit field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529673770ff976d50ee9f358bf474740d57d7b6c" translate="yes" xml:space="preserve">
          <source>The element type of the composite type is the composite type of the two element types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50a1fc3f7b297bdcca890f9bac6d5dd553d12f8" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824493ebacf0d3370672a682b01bf74e21675169" translate="yes" xml:space="preserve">
          <source>The encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;commandline options&lt;/a&gt;&lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b539c63cb55edb7e1383ca8e128aa52c2118d3c" translate="yes" xml:space="preserve">
          <source>The end of every declarator that is not part of another declarator is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b400103ba5ae8e95fc269d363832185de644a92" translate="yes" xml:space="preserve">
          <source>The entire program may have zero or one external definition of every identifier (other than an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function)(since C99) with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a14859a09bf56dbf34fa38ebabd0a0cfc01622" translate="yes" xml:space="preserve">
          <source>The equality operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61830cacc4ca90b758c92dfcb68fdc8c2624ac72" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt; or the &lt;a href=&quot;for&quot;&gt;for loop&lt;/a&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac201da533f6480e174bf7db981da799dd3201b" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the &lt;a href=&quot;do&quot;&gt;do-while loop&lt;/a&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4a670e9ee4d8164f867b068f256b475e0334b4" translate="yes" xml:space="preserve">
          <source>The evaluations of expression that designates the function to be called and all arguments are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; with respect to each other (but there is a sequence point before the body of the function begins executing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a06ff6d6b5a3ba4276cee42336251cadd1cd73" translate="yes" xml:space="preserve">
          <source>The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (&lt;code&gt;SCHED_FIFO&lt;/code&gt; in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, &lt;code&gt;yield&lt;/code&gt; has no effect).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afa03179e588e1c757bb671479e9343d010308a" translate="yes" xml:space="preserve">
          <source>The exponent contains at least two digits, more digits are used only if necessary. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbac353ed3f45f6cc4a964a51c439a96d66dd22" translate="yes" xml:space="preserve">
          <source>The exponent has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04028f66e9c71c2bd75f830dc82f30f80377d676" translate="yes" xml:space="preserve">
          <source>The exponential function is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9f12f2ca6ab5279914c37234b56437596c602d" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt; (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d8b1cc309b61a3a19bc6577131254cb18609f3" translate="yes" xml:space="preserve">
          <source>The expression following &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if or #elif&lt;/a&gt; must expand to.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
