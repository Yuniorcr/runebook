<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="e9543acb0a3b6ae140b676bdd75a9f04b94c736b" translate="yes" xml:space="preserve">
          <source>CONFIGURATION SECTION Syntax</source>
          <target state="translated">CONFIGURATION SECTION 構文</target>
        </trans-unit>
        <trans-unit id="fd14e0768d8e03137017ff03d76cc74754b47cbb" translate="yes" xml:space="preserve">
          <source>CONSTANT Attribute Syntax</source>
          <target state="translated">CONSTANT属性構文</target>
        </trans-unit>
        <trans-unit id="45f863a18c883ddde1c38a1609e1083371a910f8" translate="yes" xml:space="preserve">
          <source>CONTINUE Syntax</source>
          <target state="translated">CONTINUE 構文</target>
        </trans-unit>
        <trans-unit id="57c118d0153aad86aee87fdaf7399dce402a08bd" translate="yes" xml:space="preserve">
          <source>CONTROL FOOTING(S) [2]</source>
          <target state="translated">コントロールフーチング [2</target>
        </trans-unit>
        <trans-unit id="a0b77db4412f953dc79ec3e8dadb8c3312edb9f0" translate="yes" xml:space="preserve">
          <source>CONTROL HEADING(S) [2]</source>
          <target state="translated">制御見出し [2</target>
        </trans-unit>
        <trans-unit id="a0fe3388635d6d014a065ee11d0aee898e490bea" translate="yes" xml:space="preserve">
          <source>COS Function Syntax</source>
          <target state="translated">COS関数構文</target>
        </trans-unit>
        <trans-unit id="e2bf90245c3eae70b50309837f6647c1f83fdf58" translate="yes" xml:space="preserve">
          <source>COUNT</source>
          <target state="translated">COUNT</target>
        </trans-unit>
        <trans-unit id="46a355610c958a2df7dbd1b4d7bf89438582b10c" translate="yes" xml:space="preserve">
          <source>CURRENCY-SYMBOL Function Syntax</source>
          <target state="translated">CURRENCY-SYMBOL 関数構文</target>
        </trans-unit>
        <trans-unit id="7ab87c3b533221867b4462ee901838685c51bd46" translate="yes" xml:space="preserve">
          <source>CURRENT-DATE Function Syntax</source>
          <target state="translated">CURRENT-DATE 関数構文</target>
        </trans-unit>
        <trans-unit id="a2b6abc7961dcf84b76adf0da7d0e3cb7258497a" translate="yes" xml:space="preserve">
          <source>Called Program</source>
          <target state="translated">呼び出されたプログラム</target>
        </trans-unit>
        <trans-unit id="08e86dd2cb3e588792e5a1445c80be0d6ca86b4d" translate="yes" xml:space="preserve">
          <source>Called program not found</source>
          <target state="translated">呼び出されたプログラムが見つかりません</target>
        </trans-unit>
        <trans-unit id="79de0a0be26f9fe0196ab734446be6015cb155b5" translate="yes" xml:space="preserve">
          <source>Calling Program</source>
          <target state="translated">コーリングプログラム</target>
        </trans-unit>
        <trans-unit id="4aa75fa92437b6df595f9667af7d64254448be0b" translate="yes" xml:space="preserve">
          <source>Care must be taken that &amp;lt;</source>
          <target state="translated">注意が必要です&amp;lt;</target>
        </trans-unit>
        <trans-unit id="232276f2c2caa7b4c6621023fcbe761e2f25eb06" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a&lt;code&gt;SEQUENTIAL&lt;/code&gt;file created by a program that wrote five 6-character records to it. The &quot;A&quot;, &quot;B&quot;, &amp;hellip; values reflect the records that were written to the file:</source>
          <target state="translated">このようなファイルを読み取るプログラムは、ファイルを作成したプログラムが使用した長さとまったく同じ長さのレコードを記述することに注意する必要があります。たとえば、次の例は、6文字のレコードを5つ書き込むプログラムによって作成された &lt;code&gt;SEQUENTIAL&lt;/code&gt; ファイルの内容を示しています。「A」、「B」、&amp;hellip;の値は、ファイルに書き込まれたレコードを反映しています。</target>
        </trans-unit>
        <trans-unit id="0d6ab5c40892951a44701a3cbbc3363615028003" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the programs that created the file. It won&amp;rsquo;t end well if the GnuCOBOL runtime library interprets a four-byte ASCII character string as a record length when it transfers data from the file into the program!</source>
          <target state="translated">このようなファイルを読み取るプログラムは、ファイルを作成したプログラムで使用されたものと正確に同じ長さのレコードを記述することに注意する必要があります。ファイルからプログラムにデータを転送するときに、GnuCOBOLランタイムライブラリが4バイトのASCII文字列をレコード長として解釈する場合、これは正常に終了しません。</target>
        </trans-unit>
        <trans-unit id="008af863881dc7149313286a97c8945b993a34fe" translate="yes" xml:space="preserve">
          <source>Case-folding may also be turned on and off within the program source code using the CDF&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;statement (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;).</source>
          <target state="translated">ケース・折りたたみもCDF使用してプログラムのソースコードの中にオン・オフすることができる &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; （参照文を&lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SETを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="98accb26910de4948b37b8fbb0b408fbd1a965e0" translate="yes" xml:space="preserve">
          <source>Caution. Although this document is for version 2.2 of the compiler, it also includes a description of the functions of the RWCS (Report Writer module) which is not included in the compiler version 2.2. Please see availability notes on this at 1.3.13.</source>
          <target state="translated">注意事項 このドキュメントはコンパイラのバージョン2.2用ですが、コンパイラのバージョン2.2には含まれていないRWCS(Report Writerモジュール)の機能の説明も含まれています。これについては1.3.13を参照してください。</target>
        </trans-unit>
        <trans-unit id="fb48ed86295c01e223491405da96e0725331ba29" translate="yes" xml:space="preserve">
          <source>Changes made by a subprogram to the value of an argument specified on the&lt;code&gt;USING&lt;/code&gt;clause will &quot;be visible&quot; to the calling program only if&lt;code&gt;BY REFERENCE&lt;/code&gt;was explicitly specified or implicitly assumed for the argument on the subprogram&amp;rsquo;s procedure division header</source>
          <target state="translated">サブプログラムによって &lt;code&gt;USING&lt;/code&gt; 句で指定された引数の値に加えられた変更は、 &lt;code&gt;BY REFERENCE&lt;/code&gt; が明示的に指定された場合、またはサブプログラムの手続き部のヘッダーの引数に暗黙的に想定された場合にのみ、呼び出し側プログラムに表示されます。</target>
        </trans-unit>
        <trans-unit id="1cf367703f62db4730492b29e986ff87aabe8968" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph&amp;rsquo;s&lt;code&gt;CURRENCY SYMBOL&lt;/code&gt;setting will</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMESを&lt;/a&gt;参照）段落の &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 設定で通貨記号を変更すると、</target>
        </trans-unit>
        <trans-unit id="3290313e1574c3d689ba9eb70ce2b545abfe41ec" translate="yes" xml:space="preserve">
          <source>Changing the current directory</source>
          <target state="translated">カレントディレクトリの変更</target>
        </trans-unit>
        <trans-unit id="6dd47dabb9df79c85d4c9bbf8e536ca75ef3576e" translate="yes" xml:space="preserve">
          <source>Character positions in this list do not affect the actual binary storage values used for the characters &amp;mdash; binary values will still be those of the&lt;code&gt;NATIVE&lt;/code&gt;character set.</source>
          <target state="translated">このリストの文字位置は、文字に使用される実際のバイナリストレージ値には影響しません。バイナリ値は、 &lt;code&gt;NATIVE&lt;/code&gt; 文字セットの値のままです。</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="06ba9f8b51464a92c09ba8adb0428ae07c0698c2" translate="yes" xml:space="preserve">
          <source>Class-Condition Syntax</source>
          <target state="translated">クラス条件の構文</target>
        </trans-unit>
        <trans-unit id="6dcfeb045a3fd680afc99e0a6405f85f4b06bc0e" translate="yes" xml:space="preserve">
          <source>Class-Definition-Clause</source>
          <target state="translated">Class-Definition-Clause</target>
        </trans-unit>
        <trans-unit id="88225646933261b2af20b61cd0a15701c0f8d989" translate="yes" xml:space="preserve">
          <source>Clearly, even a non-programmer could at least conceptually understand what was going on! Over time, languages like FORTRAN evolved more robust variable names, and COBOL introduced a more formula-based syntactical capability for arithmetic operations, but FORTRAN was never as readable as COBOL.</source>
          <target state="translated">明らかに、ノンプログラマーであっても、少なくとも何が起こっているのかを概念的に理解することができました。時が経つにつれて、FORTRANのような言語はより堅牢な変数名を進化させ、COBOLは算術演算のためのより公式ベースの構文機能を導入しましたが、FORTRANはCOBOLほど可読性が高いものではありませんでした。</target>
        </trans-unit>
        <trans-unit id="732a5387092d26a94fef7e2ce8d5d9519c238b19" translate="yes" xml:space="preserve">
          <source>Closed with lock</source>
          <target state="translated">ロック付きクローズ</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="594422a8373a45016503112a0d76d479ebc2de36" translate="yes" xml:space="preserve">
          <source>Collating Sequence</source>
          <target state="translated">シーケンスの照合</target>
        </trans-unit>
        <trans-unit id="1d0c8304baedcf8e3a78982c2e7c0b04622bf2a0" translate="yes" xml:space="preserve">
          <source>Color</source>
          <target state="translated">Color</target>
        </trans-unit>
        <trans-unit id="5ff247b294c4c4680923f6b83955ad2dd9bcc50b" translate="yes" xml:space="preserve">
          <source>Colors may also be specified using a numeric non-edited identifier whose value is in the range 0-7.</source>
          <target state="translated">色は、値が0~7の範囲にある非編集の数値識別子を使用して指定することもできます。</target>
        </trans-unit>
        <trans-unit id="3da9b0a1bd95ee2ff92f0876a9bc1660e1b7f92d" translate="yes" xml:space="preserve">
          <source>Column 7 serves as an indicator in which one of five possible values will appear &amp;mdash; space,&lt;code&gt;D&lt;/code&gt;(or&lt;code&gt;d&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;(dash),&lt;code&gt;/&lt;/code&gt;or&lt;code&gt;*&lt;/code&gt; The meanings of these characters are as follows:</source>
          <target state="translated">列7は、スペース、 &lt;code&gt;D&lt;/code&gt; （または &lt;code&gt;d&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; （ダッシュ）、 &lt;code&gt;/&lt;/code&gt; または &lt;code&gt;*&lt;/code&gt; ）の5つの​​可能な値のいずれかが表示されるインジケーターとして機能します。これらの文字の意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f92afaa3e8bfcd3ea4fa0e30b81b8a7e79d9e878" translate="yes" xml:space="preserve">
          <source>Column headings describing the fields within the detail group(s)</source>
          <target state="translated">詳細グループ内のフィールドを記述する列の見出し</target>
        </trans-unit>
        <trans-unit id="ef3b24c82e2e70a56915cb2e013177a3e224de2a" translate="yes" xml:space="preserve">
          <source>Combined Condition Syntax</source>
          <target state="translated">複合条件構文</target>
        </trans-unit>
        <trans-unit id="11bac06e449288d8a0080c4c6a977a78a032bea7" translate="yes" xml:space="preserve">
          <source>Comment Type</source>
          <target state="translated">タイプ</target>
        </trans-unit>
        <trans-unit id="94ef186c06d95cc1077474be4d410b632a210905" translate="yes" xml:space="preserve">
          <source>Comments that may be treated as code, typically for debugging purposes</source>
          <target state="translated">コードとして扱われる可能性のあるコメント、通常はデバッグ目的で使用されます。</target>
        </trans-unit>
        <trans-unit id="2fd8ee31128a27c3741cf64157f9abf402269ba4" translate="yes" xml:space="preserve">
          <source>Compatible Binary Integer</source>
          <target state="translated">互換性のある二進整数</target>
        </trans-unit>
        <trans-unit id="da8cf05ee405cd9a986668c8c46c9a8e120fd720" translate="yes" xml:space="preserve">
          <source>Compilation Group</source>
          <target state="translated">コンパイルグループ</target>
        </trans-unit>
        <trans-unit id="96cd345d12b5b7ca5ae139bb77e1a9c53007e491" translate="yes" xml:space="preserve">
          <source>Compilation Unit</source>
          <target state="translated">コンパイルユニット</target>
        </trans-unit>
        <trans-unit id="e859ddacb886ecaac3920b7f115299577527697c" translate="yes" xml:space="preserve">
          <source>Compilations may be performed to generate dynamically-loadable modules (or dynamically-loadable libraries, as they are frequently called). These compilations are performed by using the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">動的にロード可能なモジュール（または頻繁に呼び出されるため、動的にロード可能なライブラリ）を生成するためにコンパイルを実行できます。これらのコンパイルは &lt;code&gt;-m&lt;/code&gt; スイッチを使用して実行されます</target>
        </trans-unit>
        <trans-unit id="6218c92ed166d6dee1c3823d57775cd989a17afa" translate="yes" xml:space="preserve">
          <source>Compile this program as follows (the assumption is made that you are executing the&lt;code&gt;cobc&lt;/code&gt;command from the directory in which the above program source code (subvsindex.cbl) exists.</source>
          <target state="translated">このプログラムを次のようにコンパイルします（上記のプログラムソースコード（subvsindex.cbl）が存在するディレクトリから &lt;code&gt;cobc&lt;/code&gt; コマンドを実行していることを前提としています）。</target>
        </trans-unit>
        <trans-unit id="c4e180aae5f5ffed0f5284c8c7daee050f8017a2" translate="yes" xml:space="preserve">
          <source>Compiler directives are</source>
          <target state="translated">コンパイラのディレクティブは</target>
        </trans-unit>
        <trans-unit id="746fe304b6da04f2948db99dc5a6735e74cebf7a" translate="yes" xml:space="preserve">
          <source>Complete GnuCOBOL Program Syntax</source>
          <target state="translated">完全なGnuCOBOLプログラム構文</target>
        </trans-unit>
        <trans-unit id="e0f7f8b906be02847bd6c0bc57ead1c617c67102" translate="yes" xml:space="preserve">
          <source>Complex-Syntax-Clause</source>
          <target state="translated">Complex-Syntax-Clause</target>
        </trans-unit>
        <trans-unit id="8e66b8e5477316fe83d734c891de408f9f788241" translate="yes" xml:space="preserve">
          <source>Computer scientists will compare the two techniques implemented by the&lt;code&gt;SEARCH&lt;/code&gt;and&lt;code&gt;SEARCH ALL&lt;/code&gt;statements as follows:</source>
          <target state="translated">コンピュータサイエンティストは、 &lt;code&gt;SEARCH&lt;/code&gt; ステートメントと &lt;code&gt;SEARCH ALL&lt;/code&gt; ステートメントによって実装された2つの手法を次のように比較します。</target>
        </trans-unit>
        <trans-unit id="333d34a78170ebdea1656c8398a11eab37b54584" translate="yes" xml:space="preserve">
          <source>Condition names are Boolean (i.e. TRUE / FALSE) data items that receive their TRUE and FALSE values based upon the values of the non 88-level data item whose definition they immediately follow.</source>
          <target state="translated">条件名は、定義の直後に続く非88レベルのデータ項目の値に基づいてTRUEとFALSEの値を受け取るブール値(すなわちTRUE/FALSE)のデータ項目です。</target>
        </trans-unit>
        <trans-unit id="c87464dfce9a9aff3851d0944fefb1558383352f" translate="yes" xml:space="preserve">
          <source>Condition names are always defined subordinate to another (non 88-level) data item. That data item must be an elementary item. Whenever the parent data item assumes one of the values specified on the 88-level item&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause, &amp;lt;</source>
          <target state="translated">条件名は常に、別の（88レベル以外の）データ項目に従属して定義されます。そのデータ項目は基本項目でなければなりません。親データアイテムが88レベルのアイテムの &lt;code&gt;VALUE&lt;/code&gt; （&lt;a href=&quot;#VALUE&quot;&gt;VALUEを&lt;/a&gt;参照）句で指定された値の1つを想定する場合は常に、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="027a11b37533ca20669bb17281d210c5767e61eb" translate="yes" xml:space="preserve">
          <source>Condition names do not occupy any storage.</source>
          <target state="translated">条件名はストレージを占有しません。</target>
        </trans-unit>
        <trans-unit id="300654fa157f6c6e091010b7777c8e3f6af9ccc2" translate="yes" xml:space="preserve">
          <source>Conflicting attribute</source>
          <target state="translated">競合属性</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="fdb2d9eaefe67e778b752e4f472db4c9da926388" translate="yes" xml:space="preserve">
          <source>Consider including a trailing descriptor of the nature of all data items in their names. The following chart presents a variety of such descriptors the author has encountered and used through the years.</source>
          <target state="translated">すべてのデータ項目の名前には、その性質を表す末尾の記述子を含めることを検討してください。次の図は、筆者が長年にわたって遭遇し、使用してきたさまざまな記述子を示しています。</target>
        </trans-unit>
        <trans-unit id="49ad35a272291924fe1567effd78bef2707d1787" translate="yes" xml:space="preserve">
          <source>Consider including an acronym to be inserted into the name of any data item defined directly or indirectly subordinate to an 01-level item, typically to be specified after any section-level tag, if you&amp;rsquo;re using them. For example, consider the names used in the following structure:</source>
          <target state="translated">01レベルのアイテムに直接または間接的に従属して定義されているデータアイテムの名前に挿入する頭字語を含めることを検討してください。通常は、セクションレベルのタグの後に指定します。たとえば、次の構造で使用されている名前を考えてみます。</target>
        </trans-unit>
        <trans-unit id="474092c4530711a5712f2088d0c7006e1c6ea236" translate="yes" xml:space="preserve">
          <source>Consider using&lt;code&gt;SET ENVIRONMENT&lt;/code&gt;(see &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;) in lieu of&lt;code&gt;DISPLAY&lt;/code&gt;to set environment variables as it is much simpler.</source>
          <target state="translated">使用を検討して &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; を（参照&lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENTを&lt;/a&gt;する代わりに） &lt;code&gt;DISPLAY&lt;/code&gt; それがはるかに簡単であるように環境変数を設定します。</target>
        </trans-unit>
        <trans-unit id="cd60aa178f4b05c8b4e18662c70566d29b29c05b" translate="yes" xml:space="preserve">
          <source>Console output when run (user input follows the colons on the prompts for input):</source>
          <target state="translated">実行時のコンソール出力(ユーザー入力は入力プロンプトのコロンに続く)。</target>
        </trans-unit>
        <trans-unit id="482dcfb6a26e7cc8dbfee8b9c6882a08cb82b778" translate="yes" xml:space="preserve">
          <source>Constants defined in this way become undefined once an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;is encountered in the input source.</source>
          <target state="translated">この方法で定義された定数は、 &lt;code&gt;END PROGRAM&lt;/code&gt; または &lt;code&gt;END FUNCTION&lt;/code&gt; が入力ソースで検出されると未定義になります。</target>
        </trans-unit>
        <trans-unit id="97f677ffe8002bb978e6196b88b1b9221d3315cd" translate="yes" xml:space="preserve">
          <source>Consult the documentation on the</source>
          <target state="translated">のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ee9d7834b4e03028e401f780d9d177af07cb943c" translate="yes" xml:space="preserve">
          <source>Contain a leading numeric component (for example:&lt;code&gt;2000-Update-Customer&lt;/code&gt;, AND&amp;hellip;</source>
          <target state="translated">先頭の数値コンポーネントを含む（例： &lt;code&gt;2000-Update-Customer&lt;/code&gt; 、AND&amp;hellip;）</target>
        </trans-unit>
        <trans-unit id="d504f89e29051ac2c61a4e1307b823272b01fbfa" translate="yes" xml:space="preserve">
          <source>Contained Subprograms</source>
          <target state="translated">含まれているサブプログラム</target>
        </trans-unit>
        <trans-unit id="32b3d87c6ceda12546f190f2210a22df0cdf6e15" translate="yes" xml:space="preserve">
          <source>Contrast this function with the&lt;code&gt;BYTE-LENGTH&lt;/code&gt;(see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) and&lt;code&gt;LENGTH-AN&lt;/code&gt;(see &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;) functions.</source>
          <target state="translated">で、この機能を対比 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; （参照&lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;バイト長の&lt;/a&gt;）と &lt;code&gt;LENGTH-AN&lt;/code&gt; （参照&lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;関数）。</target>
        </trans-unit>
        <trans-unit id="c13b5b85342bf60c0e7b3cad62d98a00d84bed25" translate="yes" xml:space="preserve">
          <source>Contrast this with the&lt;code&gt;LENGTH&lt;/code&gt;(see &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">これを &lt;code&gt;LENGTH&lt;/code&gt; （&lt;a href=&quot;#LENGTH&quot;&gt;LENGTHを&lt;/a&gt;参照）関数と比較してください。</target>
        </trans-unit>
        <trans-unit id="d864d1d594bb58da63124b3e532077a2280da211" translate="yes" xml:space="preserve">
          <source>Control Break</source>
          <target state="translated">制御ブレーク</target>
        </trans-unit>
        <trans-unit id="e707dbac72bfee188a71125817eb3d24f8da1780" translate="yes" xml:space="preserve">
          <source>Control Field</source>
          <target state="translated">コントロールフィールド</target>
        </trans-unit>
        <trans-unit id="960257afeb12f77fa6f8f055108e92a370b0072a" translate="yes" xml:space="preserve">
          <source>Control Footing</source>
          <target state="translated">コントロールフーチング</target>
        </trans-unit>
        <trans-unit id="b37055601ddd24b634819c08af5e0ee3aec0c2f5" translate="yes" xml:space="preserve">
          <source>Control Heading</source>
          <target state="translated">制御見出し</target>
        </trans-unit>
        <trans-unit id="3089ab53c60beb89e389be8470443c8bae92e074" translate="yes" xml:space="preserve">
          <source>Control Hierarchy</source>
          <target state="translated">制御階層</target>
        </trans-unit>
        <trans-unit id="1bef2ffd2d898c95784379f9d8d159b85d5b9c39" translate="yes" xml:space="preserve">
          <source>Control will return back to the&lt;code&gt;PERFORM&lt;/code&gt; where &amp;mdash; if&lt;code&gt;WITH TEST AFTER&lt;/code&gt;was specified &amp;mdash; &amp;lt;</source>
          <target state="translated">コントロールに戻ります &lt;code&gt;PERFORM&lt;/code&gt; 場合-どこ &lt;code&gt;WITH TEST AFTER&lt;/code&gt; 指定されました- &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6b631a4ffc81ee3a9a3caa199af3dfcb4b9eebb2" translate="yes" xml:space="preserve">
          <source>Control will then proceed to the statement following the&lt;code&gt;END-EVALUATE&lt;/code&gt;or the first statement that follows the next period if there is no&lt;code&gt;END-EVALUATE&lt;/code&gt; If,however, the &amp;lt;</source>
          <target state="translated">次に、制御は &lt;code&gt;END-EVALUATE&lt;/code&gt; に続くステートメントに進むか、 &lt;code&gt;END-EVALUATE&lt;/code&gt; がない場合は次のピリオドに続く最初のステートメントに進みます。ただし、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6821ab076fc8e4c97eea6b8244b17e70476d24ee" translate="yes" xml:space="preserve">
          <source>Controlling the pagination of reports, including:</source>
          <target state="translated">レポートのページ分割を制御します。</target>
        </trans-unit>
        <trans-unit id="7dd804bb2edf5c6b71e08057b1fe7806375aa80d" translate="yes" xml:space="preserve">
          <source>Copybook</source>
          <target state="translated">Copybook</target>
        </trans-unit>
        <trans-unit id="e2aa0e7c3bd507e669da6cc819890494774937c3" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for the identification division. These will be rare as you almost never encounter copied code in the identification division.</source>
          <target state="translated">識別部門のために意図されたコードを含むコピーブック。識別部門でコピーされたコードに遭遇することはほとんどないので、これらは稀でしょう。</target>
        </trans-unit>
        <trans-unit id="ae4bb1674f81c29f3e27ad4dcb083e8655d69118" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for use in the environment division. These copybooks are generally used for predefined&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) or&lt;code&gt;FILE-CONTROL&lt;/code&gt;(see &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;) syntax,</source>
          <target state="translated">環境部門での使用を目的としたコードを含むコピーブック。これらのコピーブックは、一般的に事前に定義するために使用される &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （参照&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMESの&lt;/a&gt;）または &lt;code&gt;FILE-CONTROL&lt;/code&gt; （参照&lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;入出力セクション&lt;/a&gt;）構文</target>
        </trans-unit>
        <trans-unit id="2518777d2abfc517966e28f0596ae3116363bcc5" translate="yes" xml:space="preserve">
          <source>Copybooks that contain data definitions.</source>
          <target state="translated">データ定義を含むコピーブック。</target>
        </trans-unit>
        <trans-unit id="752aff643f4fc290408c7437031076a71eebc79b" translate="yes" xml:space="preserve">
          <source>Copybooks that contain executable instructions.</source>
          <target state="translated">実行可能な命令が含まれているコピーブック</target>
        </trans-unit>
        <trans-unit id="b6a8b5660c828f3b2c93bf54e7099762c731d4dd" translate="yes" xml:space="preserve">
          <source>Copying files</source>
          <target state="translated">ファイルのコピー</target>
        </trans-unit>
        <trans-unit id="154784820baffd42626a2bcde20aa0381aaae095" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.</source>
          <target state="translated">Copyright&amp;copy;2000、2001、2002、2007、2008 Free Software Foundation、Inc.</target>
        </trans-unit>
        <trans-unit id="cb54a4d008dbbbce9c32d6cda871fb64051a8eba" translate="yes" xml:space="preserve">
          <source>Could be abbreviated as:</source>
          <target state="translated">略すこともできます。</target>
        </trans-unit>
        <trans-unit id="8e7fb87ed35f3e95693d0d85ac2e5bb078a3fccb" translate="yes" xml:space="preserve">
          <source>Creating a directory</source>
          <target state="translated">ディレクトリの作成</target>
        </trans-unit>
        <trans-unit id="364920436a8c309c1b52c0fc8087c58a7ed12784" translate="yes" xml:space="preserve">
          <source>Creating, Opening, Closing, Reading and Writing byte-stream files</source>
          <target state="translated">バイトストリームファイルの作成、オープン、クロージング、読み込み、書き込み</target>
        </trans-unit>
        <trans-unit id="03cc92b2de6a93842702049006d74479339df02c" translate="yes" xml:space="preserve">
          <source>Current date in Gregorian form</source>
          <target state="translated">グレゴリオ暦での現在の日付</target>
        </trans-unit>
        <trans-unit id="1ff8e9efb80c4e62bf5d39a66f9af66f72010f2d" translate="yes" xml:space="preserve">
          <source>Current date in Julian form</source>
          <target state="translated">ユリウス形式の現在の日付</target>
        </trans-unit>
        <trans-unit id="38570a962a72c984faa65f99b9fe8bbed297680c" translate="yes" xml:space="preserve">
          <source>Current programming philosophy would prefer the use of the&lt;code&gt;EVALUATE&lt;/code&gt;statement to that of this form of the&lt;code&gt;GO TO&lt;/code&gt;statement.</source>
          <target state="translated">現在のプログラミング哲学では、この形式の &lt;code&gt;GO TO&lt;/code&gt; ステートメントの使用よりも、 &lt;code&gt;EVALUATE&lt;/code&gt; ステートメントの使用を優先しています。</target>
        </trans-unit>
        <trans-unit id="176c3c5df0bbd0c7ccd68b1562b9f4c3348a64ae" translate="yes" xml:space="preserve">
          <source>Currently, the only allowable value for the flags argument is 0. This argument may be specified either as a numeric literal or as a&lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt;data item.</source>
          <target state="translated">現在、flags引数の唯一の許容値は0です。この引数は、数値リテラルまたは &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; データ項目として指定できます。</target>
        </trans-unit>
        <trans-unit id="93fe007c4c23a7d4870c091f49c3529c51d38ef8" translate="yes" xml:space="preserve">
          <source>Cyan (Turquoise): COB-COLOR-CYAN</source>
          <target state="translated">シアン(ターコイズ)。コブカラーシアン</target>
        </trans-unit>
        <trans-unit id="d2b0ee310620d9febc825ce9071e2fb5b6a37cd7" translate="yes" xml:space="preserve">
          <source>D/d</source>
          <target state="translated">D/d</target>
        </trans-unit>
        <trans-unit id="cacf54f34dffa98ab8fe95ec01049b87cf34a8a2" translate="yes" xml:space="preserve">
          <source>DATA DIVISION Syntax</source>
          <target state="translated">データ分割構文</target>
        </trans-unit>
        <trans-unit id="ef1ab2c530e1e7a4a273bb9ed22fe35098c7702a" translate="yes" xml:space="preserve">
          <source>DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, DAY-OF-INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DUPLICATES, DYNAMIC</source>
          <target state="translated">data、data-pointer、date、date-compiled、date-modified、date-of-integer、date-to-yyyymmdd、date-written、day、day、day-of-integer、day-of-week、day-to-yyyyddd、de、デバッグ、小数点、宣言文、デフォルト、delete、区切り、区切り文字、依存、降順、デスティネーション、 detail、disable、disc、disk、display、display-of、divide、division、down、duplicates、dynamic、dynamic。</target>
        </trans-unit>
        <trans-unit id="9a7769dbf47324c33f9163090c128fdce266a34c" translate="yes" xml:space="preserve">
          <source>DATE-OF-INTEGER Function Syntax</source>
          <target state="translated">DATE-OF-INTEGER 関数構文</target>
        </trans-unit>
        <trans-unit id="de2d56241f31b520010f3bce0b98db0bbbf5b2cb" translate="yes" xml:space="preserve">
          <source>DATE-TO-YYYYMMDD Function Syntax</source>
          <target state="translated">DATE-TO-YYYYMMDD 関数構文</target>
        </trans-unit>
        <trans-unit id="39bcedb8c2b80fd139b489090f66d6091874fd22" translate="yes" xml:space="preserve">
          <source>DAY-OF-INTEGER Function Syntax</source>
          <target state="translated">DAY-OF-INTEGER 関数構文</target>
        </trans-unit>
        <trans-unit id="2bf1dfe2e631bd8b0d7dad6f48c0cacb9a884526" translate="yes" xml:space="preserve">
          <source>DAY-TO-YYYYDDD Function Syntax</source>
          <target state="translated">DAY-TO-YYYYDDD 関数構文</target>
        </trans-unit>
        <trans-unit id="025121e8c60ec006f18d8b8d88589c258c15c1d7" translate="yes" xml:space="preserve">
          <source>DDDDEEEEEE</source>
          <target state="translated">DDDDEEEEEE</target>
        </trans-unit>
        <trans-unit id="86bb1aaff76c60b46fc6063e792d77c4344339b1" translate="yes" xml:space="preserve">
          <source>DECLARATIVES Syntax</source>
          <target state="translated">DECLARATIVES 構文</target>
        </trans-unit>
        <trans-unit id="143eef2ea0db77ce833000c49d3c0b7fd423279e" translate="yes" xml:space="preserve">
          <source>DELETE Syntax</source>
          <target state="translated">DELETE 構文</target>
        </trans-unit>
        <trans-unit id="3a15730e7f841dfe68e53a32b12047839a2d3fb6" translate="yes" xml:space="preserve">
          <source>DETAIL GROUP(S) [2]</source>
          <target state="translated">詳細グループ [2</target>
        </trans-unit>
        <trans-unit id="4f10c1a7a81f590cb0c5833f5f9e81467169d145" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON COMMAND-LINE Syntax</source>
          <target state="translated">コマンドラインで表示する構文</target>
        </trans-unit>
        <trans-unit id="adda0092f73a761f60d98ab42f5c7b4bba54e2d5" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON ENVIRONMENT-NAME Syntax</source>
          <target state="translated">環境名を表示する構文</target>
        </trans-unit>
        <trans-unit id="dc0e227d85b3e8e67592171973f030e41c7ab926" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON device Syntax</source>
          <target state="translated">DISPLAY UPON デバイスの構文</target>
        </trans-unit>
        <trans-unit id="6145b9122a8e41c787d9431bd205fd12fd53c5a1" translate="yes" xml:space="preserve">
          <source>DISPLAY screen-data-item Syntax</source>
          <target state="translated">DISPLAY screen-data-item 構文</target>
        </trans-unit>
        <trans-unit id="c274523a24ad6574ea39bdfb176f7732c4c4c3d8" translate="yes" xml:space="preserve">
          <source>DIVIDE BY GIVING Syntax</source>
          <target state="translated">DIVIDE BY GIVING 構文</target>
        </trans-unit>
        <trans-unit id="1719d6e667413941c4bdcd1de4638431f43816ff" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO GIVING Syntax</source>
          <target state="translated">DIVIDE INTO GIVING構文</target>
        </trans-unit>
        <trans-unit id="b020f4b6ba07306586627a0af3f4509d6885ff83" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO Syntax</source>
          <target state="translated">構文を分割します。</target>
        </trans-unit>
        <trans-unit id="542d08c7255dff568bdff9294205546046c0a7c5" translate="yes" xml:space="preserve">
          <source>Data Item</source>
          <target state="translated">データ項目</target>
        </trans-unit>
        <trans-unit id="b5ab5631945fc781f3a554ec97b7ea5c28882fb6" translate="yes" xml:space="preserve">
          <source>Data Retrieved</source>
          <target state="translated">データを取得しました。</target>
        </trans-unit>
        <trans-unit id="86ce25bf2c845338976617d76d9424c933ce8444" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&amp;lt;</source>
          <target state="translated">このフォームのデータ記述は、実際にはストレージを割り当てません。単に名前（&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e82b1d0242f8c91a364756e74c764b6e3af9b59f" translate="yes" xml:space="preserve">
          <source>Data items declared with the&lt;code&gt;ANY LENGTH&lt;/code&gt;attribute have no fixed compile-time length. Such items may only be defined in the linkage section of a subprogram as they may only serve as subroutine argument descriptions. These items must have a&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause that specifies exactly one A, X or 9 symbol.</source>
          <target state="translated">&lt;code&gt;ANY LENGTH&lt;/code&gt; 属性を使用して宣言されたデータ項目には、コンパイル時の長さが固定されていません。これらの項目は、サブルーチンの引数の説明としてのみ機能するため、サブプログラムのリンケージセクションでのみ定義できます。これらの項目は、持っている必要があり &lt;code&gt;PICTURE&lt;/code&gt; を（参照&lt;a href=&quot;#PICTURE&quot;&gt;PICTUREを&lt;/a&gt;）句を指定正確に一つのA、Xまたは9シンボルという。</target>
        </trans-unit>
        <trans-unit id="8ff9e95bc3e45b129ac52c4861ceb28707b8b1d0" translate="yes" xml:space="preserve">
          <source>Data items declared with&lt;code&gt;BASED&lt;/code&gt;are allocated no storage at compilation time. At run-time, the&lt;code&gt;ALLOCATE&lt;/code&gt;(see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) or&lt;code&gt;SET ADDRESS&lt;/code&gt;(see &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;) statements are used to allocate space for and (optionally) initialize such items.</source>
          <target state="translated">&lt;code&gt;BASED&lt;/code&gt; で宣言されたデータ項目には、コンパイル時にストレージが割り当てられません。実行時に、 &lt;code&gt;ALLOCATE&lt;/code&gt; （参照&lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;）または &lt;code&gt;SET ADDRESS&lt;/code&gt; （参照&lt;a href=&quot;#SET-ADDRESS&quot;&gt;設定したアドレスを&lt;/a&gt;、そのようなアイテムを初期化ステートメントはのためのスペースを割り当て、（任意に）するために使用されます）。</target>
        </trans-unit>
        <trans-unit id="3884223bd8738175ccb76e30292953182185f26d" translate="yes" xml:space="preserve">
          <source>Data items defined in a calling program may be passed to either type of called program (subroutine or user-defined function) as arguments.</source>
          <target state="translated">呼び出し元のプログラムで定義されたデータ項目は、呼び出し元のプログラムの種類(サブルーチンまたはユーザー定義関数)のいずれかに引数として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8b6be4a0a08f89796b4ca060304e3df78e6642bf" translate="yes" xml:space="preserve">
          <source>Data items defined in the screen section describe input, output or combination screen layouts to be used with&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) statements. These screen layouts may define the entire available screen area or any subset of it.</source>
          <target state="translated">画面セクションで定義されたデータ項目は、 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; ステートメント（&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-itemを&lt;/a&gt;参照）または &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; ステートメント（&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data- item&lt;/a&gt;）ステートメント。これらの画面レイアウトは、使用可能な画面領域全体またはそのサブセットを定義できます。</target>
        </trans-unit>
        <trans-unit id="5b209ac3623f15088290faf41d529558938a6bd3" translate="yes" xml:space="preserve">
          <source>Data items defined within the working-storage section are automatically initialized once &amp;mdash; as the program in which the data is defined is loaded into memory. Subprograms may be loaded into memory more than once (see the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;)), in which case initialization will happen each time they are loaded. See &lt;a href=&quot;#Data-Initialization&quot;&gt;Data Initialization&lt;/a&gt;, for a discussion of the initialization rules.</source>
          <target state="translated">作業用ストレージセクション内で定義されたデータ項目は、データが定義されているプログラムがメモリに読み込まれると、自動的に1回初期化されます。サブプログラムは、複数回のメモリにロードすることができる（参照 &lt;code&gt;CANCEL&lt;/code&gt; （参照文を&lt;a href=&quot;#CANCEL&quot;&gt;キャンセル&lt;/a&gt;する場合の初期化は、彼らがロードされるたびに起こるのだろう、））。初期化規則の説明については、&lt;a href=&quot;#Data-Initialization&quot;&gt;データの初期化を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4eb8574d2d5270d2d786dec0a24f5040d14d6919" translate="yes" xml:space="preserve">
          <source>Data items that have the&lt;code&gt;UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNSIGNED&lt;/code&gt; を持つデータ項目</target>
        </trans-unit>
        <trans-unit id="b9af005425ba8ce8de1a932e2c2f2ab684e4ed8c" translate="yes" xml:space="preserve">
          <source>Data items with an explicit&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause in their definition will be initialized to that specific value.</source>
          <target state="translated">明示的に持つデータ項目 &lt;code&gt;VALUE&lt;/code&gt; （参照&lt;a href=&quot;#VALUE&quot;&gt;値を&lt;/a&gt;その定義で）句は、その特定の値に初期化されます。</target>
        </trans-unit>
        <trans-unit id="25d47c3faf24644ac0e22641a7e663390a36c7aa" translate="yes" xml:space="preserve">
          <source>Data items with level numbers 01 (Constants), 66, 78 and 88 may be used in the screen section; they have the same syntax, rules and usage as they do in the other data division sections.</source>
          <target state="translated">レベル番号01(定数)、66、78、88のデータ項目は、画面セクションで使用することができます。</target>
        </trans-unit>
        <trans-unit id="3f037b50f5ed4565ce4707a24021f4f6ad083ed5" translate="yes" xml:space="preserve">
          <source>Data-pointer contains an address that is out of bounds</source>
          <target state="translated">データポインタに範囲外のアドレスが含まれています。</target>
        </trans-unit>
        <trans-unit id="874809dfddadcc0363d1a9a37ac20f4611145b1a" translate="yes" xml:space="preserve">
          <source>Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.</source>
          <target state="translated">宣言的手続きは、DECLARATIVESの範囲外で定義された他の手続きを参照してはならない。</target>
        </trans-unit>
        <trans-unit id="d14e2f78a3303228220a36dc985b5fd5e385137b" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the PICTURE</source>
          <target state="translated">数量 &lt;code&gt;9&lt;/code&gt; および画像内の &lt;code&gt;S&lt;/code&gt; の有無によって定義されます</target>
        </trans-unit>
        <trans-unit id="1e681574ae7448c8ae4c05d776be5265b2dc953d" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">量によって定義される &lt;code&gt;9&lt;/code&gt; との存在下または非存在下 &lt;code&gt;S&lt;/code&gt; で &lt;code&gt;PICTURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3721726af464447c08ddb23c2de0ce50d614e3dd" translate="yes" xml:space="preserve">
          <source>Defines an implied digit position that will be considered to be a zero when the data item is referenced at run-time. This symbol is used to allow data items that will contain very large values to be allocated using less storage by assuming a certain number of trailing zeros (one per&lt;code&gt;P&lt;/code&gt; to exist at the end of values.</source>
          <target state="translated">実行時にデータ項目が参照されるときにゼロと見なされる暗黙の桁位置を定義します。この記号を使用すると、非常に大きな値を含むデータ項目を、特定の数の後続ゼロ（ &lt;code&gt;P&lt;/code&gt; ごとに1つが値の終わりに存在すると想定）を仮定することにより、少ないストレージを使用して割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="d2dadb60fe73f669fa3a07340c506372af50e9c1" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphabetic character &lt;code&gt;A&lt;/code&gt;&lt;code&gt;Z&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;&lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1つの英字 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;Z&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; のために予約されているストレージを定義します。</target>
        </trans-unit>
        <trans-unit id="cc276340305e669eb0c75e2233fed96937f0eb10" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphanumeric character (any character).</source>
          <target state="translated">英数字1文字(任意の文字)用に予約されたストレージを定義します。</target>
        </trans-unit>
        <trans-unit id="9157b25b7fe6ae0f7d0e3ba566a50c8e263af1e0" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single character in the computer&amp;rsquo;s &amp;rsquo;</source>
          <target state="translated">コンピュータの 'の単一の文字用に予約されたストレージを定義します</target>
        </trans-unit>
        <trans-unit id="94ae1e544866ccd53a2d46a1a530f0a06f98b727" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single numeric digit character &lt;code&gt;0&lt;/code&gt;&lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">1桁の数字 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; のために予約されているストレージを定義します。</target>
        </trans-unit>
        <trans-unit id="4c35955c5a43713921be58f39b4f9f08b952ef23" translate="yes" xml:space="preserve">
          <source>Defining a control hierarchy (via&lt;code&gt;CONTROLS ARE&lt;/code&gt; that does not match the actual sequence in which data will be processed is a great way to guarantee a &quot;broken&quot; report. I&amp;rsquo;ll show you an example in a later section.</source>
          <target state="translated">（データが処理される実際のシーケンスと一致しない &lt;code&gt;CONTROLS ARE&lt;/code&gt; を介して）コントロール階層を定義することは、「壊れた」レポートを保証する優れた方法です。後のセクションで例を示します。</target>
        </trans-unit>
        <trans-unit id="86f4d7d5ec62e8d3cd6d42936730cd899552e6b1" translate="yes" xml:space="preserve">
          <source>Deleting directories (folders)</source>
          <target state="translated">ディレクトリ(フォルダ)の削除</target>
        </trans-unit>
        <trans-unit id="184170aedafad0bad24b165d0963d2623119dff1" translate="yes" xml:space="preserve">
          <source>Deleting files</source>
          <target state="translated">ファイルの削除</target>
        </trans-unit>
        <trans-unit id="a300dcf45b8bb3ac35bf8bf6fa05fb9627dec545" translate="yes" xml:space="preserve">
          <source>Depending upon which source format mode the compiler is in, you will need to follow various rules for the format mode currently in effect. These rules are presented in the upcoming paragraphs.</source>
          <target state="translated">コンパイラがどのソース・フォーマット・モードにあるかによって、現在有効なフォーマット・モードのさまざまなルールに従う必要があります。これらのルールは次の段落で説明します。</target>
        </trans-unit>
        <trans-unit id="e1d3403c95ff976211a614c7aff47a8b06f0d474" translate="yes" xml:space="preserve">
          <source>Depends on number of&lt;code&gt;9&lt;/code&gt; in the&lt;code&gt;PICTURE&lt;/code&gt;and the&lt;code&gt;binary-size&lt;/code&gt;setting of the configuration file used to compile the program</source>
          <target state="translated">数に依存 &lt;code&gt;9&lt;/code&gt; に &lt;code&gt;PICTURE&lt;/code&gt; と &lt;code&gt;binary-size&lt;/code&gt; 設定ファイルの設定は、プログラムをコンパイルするために使用しました</target>
        </trans-unit>
        <trans-unit id="8f554af0cabf84f3acc6bcb170a806e225d3ade1" translate="yes" xml:space="preserve">
          <source>Depends on&lt;code&gt;PICTURE&lt;/code&gt; One character per X, A, 9, period, $, Z, 0, *, S (if&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;specified), +, - or B symbol in&lt;code&gt;PICTURE&lt;/code&gt; Add 2 more bytes if the&lt;code&gt;DB&lt;/code&gt;or&lt;code&gt;CR&lt;/code&gt;editing symbol is used</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; に依存&amp;ndash; X、A、9、ピリオド、$、Z、0、*、Sごとに1文字（ &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; が指定されている場合）、 &lt;code&gt;PICTURE&lt;/code&gt; 内の+、-、またはB記号 &lt;code&gt;DB&lt;/code&gt; または &lt;code&gt;CR&lt;/code&gt; 編集記号の場合、さらに2バイト追加使用されている</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a7bc7ee00f8b51dc232f39ec929df41c6a0ebda7" translate="yes" xml:space="preserve">
          <source>Despite what the name of this routine might make you believe, this routine is more than just a simple &quot;rename&quot; &amp;mdash; it will actually move the file supplied as the 1st argument to the file specified as the 2nd argument. Think of it as a two-step sequence, first copying the &amp;lt;</source>
          <target state="translated">このルーチンの名前はあなたに信じさせるかもしれませんが、このルーチンは単なる &quot;名前の変更&quot;だけではありません。これは実際、第1引数として指定されたファイルを第2引数として指定されたファイルに移動します。 2ステップのシーケンスと考えてください。最初に&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6dc01a0b93964e7ed3110112972c2448074cd5a5" translate="yes" xml:space="preserve">
          <source>Despite what you&amp;rsquo;ve seen here, the more complex the programming logic being implemented, the more concise the Java code will appear to be, even compared to 2002-standard COBOL. That conciseness comes with a price though &amp;mdash; program code readability. Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. COBOL programs can, however, be quite understandable by non-programmers. This is actually a side-effect of the &quot;wordiness&quot; of the language, where COBOL statements use natural English words to describe their actions. This inherent readability has come in handy many times throughout my career when I&amp;rsquo;ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.</source>
          <target state="translated">ここで見てきたことにもかかわらず、実装されているプログラミングロジックが複雑になるほど、2002標準のCOBOLと比較しても、Javaコードは簡潔になります。ただし、その簡潔さには代償が伴います。プログラムコードの読みやすさです。 Java（またはCまたはC ++またはC＃）プログラムは、通常、訓練を受けたプログラマーのみが理解できます。ただし、COBOLプログラムは、プログラマー以外の人にも理解できる場合があります。これは、実際には言語の「言葉遣い」の副作用であり、COBOLステートメントは自然な英語の単語を使用してその動作を説明します。この固有の読みやすさは、サポートしているCOBOLプログラムコードを読んで不明瞭なビジネス（または法的）プロセスを学ぶ必要があったときに、キャリア全体で何度も重宝しています。</target>
        </trans-unit>
        <trans-unit id="7d18a0bca02af71f36038a10035b4fe89b253e6e" translate="yes" xml:space="preserve">
          <source>Detail Group</source>
          <target state="translated">詳細グループ</target>
        </trans-unit>
        <trans-unit id="fc513aa1c1486f07867ac9c63a186583402ee0ec" translate="yes" xml:space="preserve">
          <source>Detail Report</source>
          <target state="translated">詳細レポート</target>
        </trans-unit>
        <trans-unit id="c352d575e112605537ad32d24ea8d1abed42a987" translate="yes" xml:space="preserve">
          <source>Determining how many arguments were passed to a subroutine</source>
          <target state="translated">サブルーチンに渡された引数の数を決定する</target>
        </trans-unit>
        <trans-unit id="a5a74a6df09278b88cb6ea23b7d7f2570c33babf" translate="yes" xml:space="preserve">
          <source>Device</source>
          <target state="translated">Device</target>
        </trans-unit>
        <trans-unit id="b4bdf8d06c8ee9447b53a8835fd50fd6f2691a97" translate="yes" xml:space="preserve">
          <source>Did you notice that there are two each of&lt;code&gt;Year&lt;/code&gt;&lt;code&gt;Month&lt;/code&gt;and&lt;code&gt;Day&lt;/code&gt;data names defined? That&amp;rsquo;s perfectly legal, provided that each can be uniquely&lt;code&gt;qualified&lt;/code&gt;so as to be distinct from the other. Take for example the&lt;code&gt;Year&lt;/code&gt;items. One is defined as part of the&lt;code&gt;From-Date&lt;/code&gt;data item while the other is defined as part of the &quot;To-Date&quot; data item. In COBOL, we would actually code references to these two data items as either&lt;code&gt;Year OF From-Date&lt;/code&gt;and&lt;code&gt;Year OF To-Date&lt;/code&gt;or&lt;code&gt;Year IN From-Date&lt;/code&gt;and&lt;code&gt;Year IN To-Date&lt;/code&gt;(COBOL allows either&lt;code&gt;IN&lt;/code&gt;or&lt;code&gt;OF&lt;/code&gt;to be used). Since these references would clarify any confusion to us as to which&lt;code&gt;Year&lt;/code&gt;might be referenced, the GnuCOBOL compiler won&amp;rsquo;t be confused either.</source>
          <target state="translated">あなたは、それぞれの2があることに気づきました &lt;code&gt;Year&lt;/code&gt; &lt;code&gt;Month&lt;/code&gt; と &lt;code&gt;Day&lt;/code&gt; データ名定義されましたか？それぞれが他と区別されるように一意に &lt;code&gt;qualified&lt;/code&gt; できる場合、それは完全に合法です。たとえば、 &lt;code&gt;Year&lt;/code&gt; アイテムを見てみましょう。 1つは &lt;code&gt;From-Date&lt;/code&gt; データ項目の一部として定義され、もう1つは「To-Date」データ項目の一部として定義されます。 COBOLでは、これら2つのデータ項目への参照を実際には、 &lt;code&gt;Year OF From-Date&lt;/code&gt; と &lt;code&gt;Year OF To-Date&lt;/code&gt; または &lt;code&gt;Year IN From-Date&lt;/code&gt; と &lt;code&gt;Year IN To-Date&lt;/code&gt; （COBOLでは &lt;code&gt;IN&lt;/code&gt; または &lt;code&gt;OF&lt;/code&gt; 使用される）。これらの参照は、どの &lt;code&gt;Year&lt;/code&gt; が参照されるかについての混乱を明確にするので、GnuCOBOLコンパイラーも混乱しないでしょう。</target>
        </trans-unit>
        <trans-unit id="3dae4df8e307eadc33cccfbf09afcf7803b28a27" translate="yes" xml:space="preserve">
          <source>Did you notice the output showing the contents of &quot;Arg1&quot; after the subroutine was called? Those contents were unchanged! The subroutine</source>
          <target state="translated">サブルーチンが呼ばれた後のArg1の内容が出力されているのに気付きましたか?内容は変わっていませんでした。サブルーチン</target>
        </trans-unit>
        <trans-unit id="6db57f7358d87d80d9ffe675eab1fa80c2597c75" translate="yes" xml:space="preserve">
          <source>Direct program execution syntax is as follows:</source>
          <target state="translated">プログラムの直接実行構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f3a08a300c1fa7c7b7c3869e07803b1ee488a676" translate="yes" xml:space="preserve">
          <source>Directly executable form</source>
          <target state="translated">直接実行可能な形式</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="50a314209c54751015d5ea87733dbccc98864d31" translate="yes" xml:space="preserve">
          <source>Division by zero</source>
          <target state="translated">ゼロによる除算</target>
        </trans-unit>
        <trans-unit id="3c91054f46891fec1cae6331f29fdbccb03d6a39" translate="yes" xml:space="preserve">
          <source>Divisions</source>
          <target state="translated">Divisions</target>
        </trans-unit>
        <trans-unit id="768a18bcfd50a4cdbad454ea5c1997d92ec2f9ed" translate="yes" xml:space="preserve">
          <source>Do not specify the &quot;.so&quot; or &quot;.dll&quot; extension on the program name. The</source>
          <target state="translated">プログラム名に「.so」や「.dll」の拡張子を指定しないでください。プログラム名に</target>
        </trans-unit>
        <trans-unit id="fa34cf297b7f3240b7cd6005ab3bf76a3b53feb2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother worrying about it at compile-time. Use the&lt;code&gt;INITIALIZE&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) to initialize all data item occurrences in a table (at run-time) to their data-type-specific default values (numerics: 0, alphabetic and alphanumerics: spaces).</source>
          <target state="translated">コンパイル時に気にする必要はありません。使用 &lt;code&gt;INITIALIZE&lt;/code&gt; を（参照&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZEを&lt;/a&gt;そのデータ型固有のデフォルト値（0、アルファベットと英数字：スペース数値）に（実行時に）テーブル内のすべてのデータ項目の発生を初期化します）。</target>
        </trans-unit>
        <trans-unit id="a1aca23a3aa1e9e5ee434e5c251ba724ccb58be9" translate="yes" xml:space="preserve">
          <source>Down-Arrow was pressed</source>
          <target state="translated">ダウンアローが押された</target>
        </trans-unit>
        <trans-unit id="c121671e83c83f33db959abee0785d1ae6b8351f" translate="yes" xml:space="preserve">
          <source>During the presentation of the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;groups, any necessary&lt;code&gt;PAGE FOOTING&lt;/code&gt;and&lt;code&gt;PAGE HEADING&lt;/code&gt;groups will be presented as well.</source>
          <target state="translated">&lt;code&gt;CONTROL FOOTING&lt;/code&gt; グループのプレゼンテーション中に、必要な &lt;code&gt;PAGE FOOTING&lt;/code&gt; および &lt;code&gt;PAGE HEADING&lt;/code&gt; グループも同様に表示されます。</target>
        </trans-unit>
        <trans-unit id="a70150b4c0486379b53b2bc61cc3b9e1cb791978" translate="yes" xml:space="preserve">
          <source>Dynamic Subprogram</source>
          <target state="translated">動的副プログラム</target>
        </trans-unit>
        <trans-unit id="6eb0f764570bb14c352993b6d496277e64157960" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable</source>
          <target state="translated">Dynamically-loadable</target>
        </trans-unit>
        <trans-unit id="1348d390510adbb26537a28adfa74ec9b8165ca8" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable executable form</source>
          <target state="translated">動的にロード可能な実行形式</target>
        </trans-unit>
        <trans-unit id="eb8d20220991838c8009592b6e63139e1b78c3ba" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules may be removed from memory via the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;).</source>
          <target state="translated">動的にロード可能なモジュールを介してメモリから除去することができる &lt;code&gt;CANCEL&lt;/code&gt; （参照文&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="901bdca5f99ca3f0f8c3c45d17df5cd4768b3649" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules will be named &quot;xxxxxxxx.dll&quot; on a Windows system, &quot;xxxxxxxx.so&quot; on a Unix system or &quot;xxxxxxxx.dylib&quot; on an OSX system, where &quot;xxxxxxxx&quot; exactly matches, including the usage of upper- and lower-case letters, the primary entry-point name &lt;code&gt;PROGRAM-ID&lt;/code&gt;or&lt;code&gt;FUNCTION-ID&lt;/code&gt; or an alternate entry point name defined via the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) of any one of the GnuCOBOL programs included in that module.</source>
          <target state="translated">動的にロード可能なモジュールは、Windowsシステムでは「xxxxxxxx.dll」、UNIXシステムでは「xxxxxxxx.so」、OSXシステムでは「xxxxxxxx.dylib」という名前になります。「xxxxxxxx」は、そして、小文字を、プライマリエントリポイント名 &lt;code&gt;PROGRAM-ID&lt;/code&gt; や &lt;code&gt;FUNCTION-ID&lt;/code&gt; または介して定義された別のエントリ・ポイント名 &lt;code&gt;ENTRY&lt;/code&gt; の文は、（参照&lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;そのモジュールに含まれるGnuCOBOLプログラムのいずれかの）を。</target>
        </trans-unit>
        <trans-unit id="1ba95e0268763043cd1e34a29d8c36e35ba2d644" translate="yes" xml:space="preserve">
          <source>Dynamically-loaded subprograms are executed (from a COBOL syntax point of view) just like any other subprograms. What makes them unique, however, is that they are loaded into memory only when they are actually used the first time during the execution of a program.</source>
          <target state="translated">動的にロードされたサブプログラムは、他のサブプログラムと同様に(COBOL構文の観点から)実行される。しかし、それらをユニークなものにしているのは、プログラムの実行中に初めて実際に使用されたときにのみメモリにロードされるということである。</target>
        </trans-unit>
        <trans-unit id="030dcb4209a1709b74f2d59ef6da0355f006e9c6" translate="yes" xml:space="preserve">
          <source>E Function Syntax</source>
          <target state="translated">E 関数構文</target>
        </trans-unit>
        <trans-unit id="765a70eecffa68061065b3955fd85a92329d8392" translate="yes" xml:space="preserve">
          <source>E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, ENTRY, ENTRY-CONVENTION, ENVIRONMENT, ENVIRONMENT-NAME, ENVIRONMENT-VALUE, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ESCAPE, ESI, EVALUATE, EXCEPTION, EXCEPTION-FILE, EXCEPTION-FILE-N, EXCEPTION-LOCATION, EXCEPTION-LOCATION-N, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCLUSIVE, EXIT, EXP, EXP10, EXPANDS, EXTEND, EXTERN, EXTERNAL</source>
          <target state="translated">e,ebcdic,ec,echo,egi,else,emi,empty-check,enable,end,end-accept,end-add,end-call,end-chain,end-compute,end-delete,end-display,end-divide,end-evaluate,end-if,end-multiply,end-of-page,end-perform,end-read,end-receive,end-return,end-rewrite,end-search,end-start,end-string,end-subtract,end-unstring,end-write,entry.エントリ型、環境、環境名、環境値、eo、eool、eoop、eos、イコール、イコール、消去、エラー、エスケープ、esi、評価、例外、例外ファイル、例外ファイル-n、例外ロケーション、例外ロケーション-n、例外オブジェクト、例外ステートメント、例外状態、排他的、exclusive、exit、exp、exp10、expands、extend、extern、extern、外部</target>
        </trans-unit>
        <trans-unit id="5effca06a41a1d22ea816cb82b7101e0e5ef5985" translate="yes" xml:space="preserve">
          <source>EC-ARGUMENT-FUNCTION</source>
          <target state="translated">EC-ARGUMENT-FUNCTION</target>
        </trans-unit>
        <trans-unit id="6f64130193ed68a9cf43ad043a1db86b51b7732f" translate="yes" xml:space="preserve">
          <source>EC-BOUND-ODO</source>
          <target state="translated">EC-BOUND-ODO</target>
        </trans-unit>
        <trans-unit id="7758bece637db0db2aa2eaf68b0a5ca23becb2f7" translate="yes" xml:space="preserve">
          <source>EC-BOUND-PTR</source>
          <target state="translated">EC-BOUND-PTR</target>
        </trans-unit>
        <trans-unit id="35ce6218474a39cc348cc1b04f5cfeb6a7093fba" translate="yes" xml:space="preserve">
          <source>EC-BOUND-REF-MOD</source>
          <target state="translated">EC-BOUND-REF-MOD</target>
        </trans-unit>
        <trans-unit id="b180672a32ac9f504a398165500845e145ddac86" translate="yes" xml:space="preserve">
          <source>EC-BOUND-SUBSCRIPT</source>
          <target state="translated">EC-BOUND-SUBSCRIPT</target>
        </trans-unit>
        <trans-unit id="47bd90096a9329462194bb3efc2ec0777c1cc384" translate="yes" xml:space="preserve">
          <source>EC-DATA-INCOMPATIBLE</source>
          <target state="translated">EC-DATA-INCOMPATIBLE</target>
        </trans-unit>
        <trans-unit id="599ae453fdf489e4c5507f42fe19ed6e9f07ec45" translate="yes" xml:space="preserve">
          <source>EC-I-O</source>
          <target state="translated">EC-I-O</target>
        </trans-unit>
        <trans-unit id="37a26c3979aa50c34cd4c0ac08b0ca77f51e47c2" translate="yes" xml:space="preserve">
          <source>EC-I-O-AT-END</source>
          <target state="translated">EC-I-O-AT-END</target>
        </trans-unit>
        <trans-unit id="7695dbca75bfb201f44d69c5f1d6236c16575ead" translate="yes" xml:space="preserve">
          <source>EC-I-O-EOP</source>
          <target state="translated">EC-I-O-EOP</target>
        </trans-unit>
        <trans-unit id="f5e8f83ff584e8d475c4cd5b0545216bba034cd9" translate="yes" xml:space="preserve">
          <source>EC-I-O-FILE-SHARING</source>
          <target state="translated">EC-I-O-FILE-SHARING</target>
        </trans-unit>
        <trans-unit id="6f67df493e29d40d1c466d3532abcf2151feb116" translate="yes" xml:space="preserve">
          <source>EC-I-O-IMP</source>
          <target state="translated">EC-I-O-IMP</target>
        </trans-unit>
        <trans-unit id="2bedcca397988fdafc22d2b1db2fe596c55b7abc" translate="yes" xml:space="preserve">
          <source>EC-I-O-INVALID-KEY</source>
          <target state="translated">EC-I-O-INVALID-KEY</target>
        </trans-unit>
        <trans-unit id="d37a719c5ec9cc280a3423d35c359f53361556cf" translate="yes" xml:space="preserve">
          <source>EC-I-O-LOGIC-ERROR</source>
          <target state="translated">EC-I-O-LOGIC-ERROR</target>
        </trans-unit>
        <trans-unit id="22c38171abcae25c72623446be7e409f53d9f1cb" translate="yes" xml:space="preserve">
          <source>EC-I-O-PERMANENT-ERROR</source>
          <target state="translated">EC-I-O-PERMANENT-ERROR</target>
        </trans-unit>
        <trans-unit id="e57f56d25192a637896e66e92bcae79d33a72575" translate="yes" xml:space="preserve">
          <source>EC-I-O-RECORD-OPERATION</source>
          <target state="translated">EC-I-O-RECORD-OPERATION</target>
        </trans-unit>
        <trans-unit id="f232808a3899bdcf8d909765f6e715db467fc08e" translate="yes" xml:space="preserve">
          <source>EC-IMP-ACCEPT</source>
          <target state="translated">EC-IMP-ACCEPT</target>
        </trans-unit>
        <trans-unit id="5b7c6f8d33dccc651230c71c804f70a23dfd3fb3" translate="yes" xml:space="preserve">
          <source>EC-IMP-DISPLAY</source>
          <target state="translated">EC-IMP-DISPLAY</target>
        </trans-unit>
        <trans-unit id="0348c4c249e24b62ec6318d07a0918b290c97136" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW</source>
          <target state="translated">EC-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="39873e8196f86a467a7a5394f6dae0df7cb7ec49" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-STRING</source>
          <target state="translated">EC-OVERFLOW-STRING</target>
        </trans-unit>
        <trans-unit id="a912b54889e1360e1822bf001ecc4bcce0057de1" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-UNSTRING</source>
          <target state="translated">EC-OVERFLOW-UNSTRING</target>
        </trans-unit>
        <trans-unit id="642796743342819c46389d927083877ea07d115a" translate="yes" xml:space="preserve">
          <source>EC-PROGRAM-NOT-FOUND</source>
          <target state="translated">EC-PROGRAM-NOT-FOUND</target>
        </trans-unit>
        <trans-unit id="fbeac2b7df577454ec16676f61d4d1c2dd9e4b66" translate="yes" xml:space="preserve">
          <source>EC-RANGE-INSPECT-SIZE</source>
          <target state="translated">EC-RANGE-INSPECT-SIZE</target>
        </trans-unit>
        <trans-unit id="44603209bfd2fe1e4c13a73d2183c6926c88fa44" translate="yes" xml:space="preserve">
          <source>EC-SIZE</source>
          <target state="translated">EC-SIZE</target>
        </trans-unit>
        <trans-unit id="d4c83319eed34736080dc026b83369dc0ab0f9e0" translate="yes" xml:space="preserve">
          <source>EC-SIZE-OVERFLOW</source>
          <target state="translated">EC-SIZE-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="995fc7c1e9f2389fb223769d4efff5b6078bcd23" translate="yes" xml:space="preserve">
          <source>EC-SIZE-TRUNCATION</source>
          <target state="translated">EC-SIZE-TRUNCATION</target>
        </trans-unit>
        <trans-unit id="2b0855452a33f27ee0e3591f258c880264670a28" translate="yes" xml:space="preserve">
          <source>EC-SIZE-ZERO-DIVIDE</source>
          <target state="translated">EC-SIZE-ZERO-DIVIDE</target>
        </trans-unit>
        <trans-unit id="74425f6db6d6bbce95e0144ef83b5f7377196c52" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-ALLOC</source>
          <target state="translated">EC-STORAGE-NOT-ALLOC</target>
        </trans-unit>
        <trans-unit id="2bcce8379324db20847e97d1dbdd7613e1e978ce" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-AVAIL</source>
          <target state="translated">EC-STORAGE-NOT-AVAIL</target>
        </trans-unit>
        <trans-unit id="af80c9b4c454f7d961a11331ae6fb9445df82b42" translate="yes" xml:space="preserve">
          <source>EMPTY-CHECK Attribute Syntax</source>
          <target state="translated">EMPTY-CHECK 属性構文</target>
        </trans-unit>
        <trans-unit id="f84802327b6f04b6ca9f5ad265dd6839e26a2682" translate="yes" xml:space="preserve">
          <source>ENTER key pressed</source>
          <target state="translated">ENTERキーを押す</target>
        </trans-unit>
        <trans-unit id="1737c25f7adeb7b4b0cf8beddc7007f6c44cee3c" translate="yes" xml:space="preserve">
          <source>ENTRY Syntax</source>
          <target state="translated">ENTRY 構文</target>
        </trans-unit>
        <trans-unit id="c8d3810b7c62cddd57ba48b6b05b3d7aaeb1d1c3" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument</source>
          <target state="translated">ENTRY-Argument</target>
        </trans-unit>
        <trans-unit id="56bc597bd92048db144c774480c4ac8ebc388d8a" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument Syntax</source>
          <target state="translated">エントリ引数構文</target>
        </trans-unit>
        <trans-unit id="aeefff7bdd0630e9dbc6edcccf44b29d8e1b5f66" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT DIVISION Syntax</source>
          <target state="translated">環境部門の構文</target>
        </trans-unit>
        <trans-unit id="10be88097f9b48fa4b8f5918ab59b09ba828e0cf" translate="yes" xml:space="preserve">
          <source>ERASE Clause Syntax</source>
          <target state="translated">ERASE 節構文</target>
        </trans-unit>
        <trans-unit id="5dad113e5d1b8f3e62a36027129de407d3e20ed5" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Object Syntax</source>
          <target state="translated">EVALUATE 選択オブジェクト構文</target>
        </trans-unit>
        <trans-unit id="5a83d6a3d7ae8bc96fedf1c772fbc996a4a470be" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Subject Syntax</source>
          <target state="translated">EVALUATE 選択科目構文</target>
        </trans-unit>
        <trans-unit id="692ff2f950c444cebee2d4c4c60df5cc939b8fd9" translate="yes" xml:space="preserve">
          <source>EVALUATE Syntax</source>
          <target state="translated">EVALUATE 構文</target>
        </trans-unit>
        <trans-unit id="469cc380359b81f762280d15538dfac8966996c9" translate="yes" xml:space="preserve">
          <source>EXCEPTION-FILE Function Syntax</source>
          <target state="translated">EXCEPTION-FILE 関数構文</target>
        </trans-unit>
        <trans-unit id="479aad1c99b2dd0808d2f3ab8cbcb8f9343aaefd" translate="yes" xml:space="preserve">
          <source>EXCEPTION-LOCATION Function Syntax</source>
          <target state="translated">EXCEPTION-LOCATION 関数構文</target>
        </trans-unit>
        <trans-unit id="33912bed8a51a3f75c3314cf3a0622c55f3ea0f0" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATEMENT Function Syntax</source>
          <target state="translated">EXCEPTION-STATEMENT 関数構文</target>
        </trans-unit>
        <trans-unit id="e953091eafe979edb67d0cb82e5a7cfb2279431b" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATUS Function Syntax</source>
          <target state="translated">EXCEPTION-STATUS 関数構文</target>
        </trans-unit>
        <trans-unit id="2d0d9c09a42e3d4ca8de4f760e2a0e18040ed305" translate="yes" xml:space="preserve">
          <source>EXIT Syntax</source>
          <target state="translated">EXIT 構文</target>
        </trans-unit>
        <trans-unit id="d686d0c0c789b999f85984848eb8e9e113877d1c" translate="yes" xml:space="preserve">
          <source>EXP Function Syntax</source>
          <target state="translated">EXP 関数構文</target>
        </trans-unit>
        <trans-unit id="82ec30d94a7c621453c959d12251cec86e515836" translate="yes" xml:space="preserve">
          <source>EXP10 Function Syntax</source>
          <target state="translated">EXP10 関数構文</target>
        </trans-unit>
        <trans-unit id="f6c4ca6abf37447285ca9c9057e5a05661c09827" translate="yes" xml:space="preserve">
          <source>EXTERN the program name is treated as an external reference.</source>
          <target state="translated">EXTERN プログラム名は外部参照として扱われます。</target>
        </trans-unit>
        <trans-unit id="03fa72b305c4462fb55710bd2cd41b8ac8239e43" translate="yes" xml:space="preserve">
          <source>EXTERNAL Attribute Syntax</source>
          <target state="translated">EXTERNAL 属性構文</target>
        </trans-unit>
        <trans-unit id="76da433919c17ebd8d966fabcaa51186d16cbb3c" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;</source>
          <target state="translated">各&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ab7a12a52c6f9b3787b7205827450dfa5e210ea2" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;&amp;lt;</source>
          <target state="translated">各&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="212df151f4df6b415b0184ea3c628ccc78c3a454" translate="yes" xml:space="preserve">
          <source>Each 01-level data item described within a subprogram&amp;rsquo;s linkage section should correspond to an argument passed on a&lt;code&gt;CALL&lt;/code&gt;statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) or an argument on a function call to the subprogram.</source>
          <target state="translated">渡された引数に対応する必要があり、それぞれ01レベルのデータ項目は、サブプログラムの連結部内記載 &lt;code&gt;CALL&lt;/code&gt; ステートメント（参照&lt;a href=&quot;#CALL&quot;&gt;CALLを&lt;/a&gt;）またはサブプログラムの関数呼び出しに引数。</target>
        </trans-unit>
        <trans-unit id="50184d6f70a255b3866145aa336ae939da7ab9ab" translate="yes" xml:space="preserve">
          <source>Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the&lt;code&gt;DECLARATIVES.&lt;/code&gt;and&lt;code&gt;END DECLARATIVES.&lt;/code&gt;lines may be omitted.</source>
          <target state="translated">各Event-Handler-Routineは、特定のランタイムイベントをトラップするための個別のセクションになります。そのようなセクションがコーディングされていない場合は、 &lt;code&gt;DECLARATIVES.&lt;/code&gt; と &lt;code&gt;END DECLARATIVES.&lt;/code&gt; 行は省略できます。</target>
        </trans-unit>
        <trans-unit id="0b25dfd77ca9db15d2164fe35f200c91c7b2bda7" translate="yes" xml:space="preserve">
          <source>Each character, in turn, within the &quot;from&quot; string will be searched for in the target range of the inspect subject. Each located occurrence will be replaced by the corresponding character of the &quot;to&quot; string.</source>
          <target state="translated">from」文字列内の各文字が、検査対象の対象範囲内で順番に検索される。検出された各出現は、「to」文字列の対応する文字に置き換えられる。</target>
        </trans-unit>
        <trans-unit id="97de2fc8d281d19be767cf651c3cbc1b7509f469" translate="yes" xml:space="preserve">
          <source>Each data item has 7 added to it ten</source>
          <target state="translated">各データ項目には7が追加されています。</target>
        </trans-unit>
        <trans-unit id="83ca16f4859e7d91cc156f672d81b61c4963b390" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;COUNT&lt;/code&gt;</source>
          <target state="translated">各宛先フィールドには、オプションの &lt;code&gt;COUNT&lt;/code&gt; を含めることができます</target>
        </trans-unit>
        <trans-unit id="ce3fcdc8c9dc594c99b3c39bb2ebb465ca20a452" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;DELIMITER&lt;/code&gt;</source>
          <target state="translated">各宛先フィールドには、オプションの &lt;code&gt;DELIMITER&lt;/code&gt; を含めることができます</target>
        </trans-unit>
        <trans-unit id="824ef1a5b203c9da09868c95374d778cb8131338" translate="yes" xml:space="preserve">
          <source>Each division may consist of a variety of sections and each section consists of one or more paragraphs. A paragraph consists of sentences, each of which consists of one or more statements.</source>
          <target state="translated">各分割は、様々なセクションから構成されていてもよく、各セクションは、1つ以上の段落から構成されている。段落は文で構成され、各段落は1つまたは複数の文で構成される。</target>
        </trans-unit>
        <trans-unit id="e2bd01ccaa12000bd7c8aa2fcbf0347999187549" translate="yes" xml:space="preserve">
          <source>Each file specified on the&lt;code&gt;cobc&lt;/code&gt;command constitutes a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; コマンドで指定された各ファイルは、 '</target>
        </trans-unit>
        <trans-unit id="00f5259fa9f0d932f10e8397b1eec6feeb68f182" translate="yes" xml:space="preserve">
          <source>Each occurrence is referenced using the subscript syntax (a numeric literal, arithmetic expression or numeric identifier enclosed within parenthesis) shown above.</source>
          <target state="translated">各オカレンスは、上記の添え字構文(括弧内に囲まれた数値リテラル、算術式または数値識別子)を用いて参照されます。</target>
        </trans-unit>
        <trans-unit id="2246e9f359281d69c5119e3504fc16ed25bac66e" translate="yes" xml:space="preserve">
          <source>Each occurrence that is set to a value of zero prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be cleared. Each occurrence set to 1 prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be set.</source>
          <target state="translated">&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 前にゼロの値に設定されている各オカレンスにより、対応するスイッチがクリアされます。 &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 前に各オカレンスを1に設定すると、対応するスイッチが設定されます。</target>
        </trans-unit>
        <trans-unit id="47a2c92912290d0b93c63c77a2120c44882c45e8" translate="yes" xml:space="preserve">
          <source>Each of &amp;lt;</source>
          <target state="translated">&amp;lt;のそれぞれ</target>
        </trans-unit>
        <trans-unit id="a97f6698ca0ef433fb7ac939df954fa715d8f25a" translate="yes" xml:space="preserve">
          <source>Each of the &amp;lt;</source>
          <target state="translated">各&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7287503eaa543018b27e0323b8db19263aedff48" translate="yes" xml:space="preserve">
          <source>Each of the 1st eight occurrences of the array will be set to either 0 or 1 &amp;mdash; 1 if the corresponding switch is set, 0 otherwise.</source>
          <target state="translated">配列の最初の8つのオカレンスはそれぞれ、対応するスイッチが設定されている場合は0または1 &amp;mdash; 1に設定され、それ以外の場合は0に設定されます。</target>
        </trans-unit>
        <trans-unit id="c09592cadb2ed51d0f1c709d0f7fdfe9b96c7560" translate="yes" xml:space="preserve">
          <source>Each of the folders named on the&lt;code&gt;COBCPY&lt;/code&gt;compilation-time environment variable</source>
          <target state="translated">&lt;code&gt;COBCPY&lt;/code&gt; コンパイル時環境変数で指定された各フォルダー</target>
        </trans-unit>
        <trans-unit id="324c91e30099fbc60529755c27c3efdd05d14a69" translate="yes" xml:space="preserve">
          <source>Each of the following symbols behave like a&lt;code&gt;9&lt;/code&gt; until such point as all digits in the numeric value are exhausted and leading zeros are about to be inserted. In effect, these editing symbols define what should happen to those leading zero.</source>
          <target state="translated">以下の各記号は、数値のすべての桁がなくなり、先行ゼロが挿入されるまで、 &lt;code&gt;9&lt;/code&gt; のように動作します。実際、これらの編集記号は、先行ゼロがどうなるかを定義します。</target>
        </trans-unit>
        <trans-unit id="d9d2be1b968bb484ea3bd99238ffa88f1a9b097c" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of a series of specific paragraphs &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;and&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">これらの各セクションは、一連の特定の段落 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; および &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; などで構成されます）。これらの各段落は特定の目的を果たします。いずれかの段落が機能するためにコードが不要な場合は、段落全体を省略できます。</target>
        </trans-unit>
        <trans-unit id="49fb2845c3cf679efe7de1449e9eb5da506280b3" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including it&amp;rsquo;s header, may be omitted.</source>
          <target state="translated">これらの各セクションは、特定の目的を果たすコードで構成されています。これらのセクションの1つが機能する目的でコードが不要な場合は、ヘッダーを含むセクション全体を省略できます。</target>
        </trans-unit>
        <trans-unit id="e5476f035d3a01cedf662032e9a562423f2c27af" translate="yes" xml:space="preserve">
          <source>Each of those files is assumed to be already sorted according to the specifications set forth on the&lt;code&gt;MERGE&lt;/code&gt;statement&amp;rsquo;s&lt;code&gt;KEY&lt;/code&gt;</source>
          <target state="translated">これらの各ファイルは、 &lt;code&gt;MERGE&lt;/code&gt; ステートメントの &lt;code&gt;KEY&lt;/code&gt; に記載されている仕様に従ってすでにソートされていると想定されています</target>
        </trans-unit>
        <trans-unit id="39b6b7cca90aab953adf3ec432fdd03b2921cced" translate="yes" xml:space="preserve">
          <source>Each page of a report is divided into as many as five (5) areas, as shown in the following diagram.</source>
          <target state="translated">報告書の各ページは、次の図のように5つの領域に分かれています。</target>
        </trans-unit>
        <trans-unit id="e972c979eeb51709c3026fa1585338428e0bcde2" translate="yes" xml:space="preserve">
          <source>Each program consists of up to four &amp;rsquo;</source>
          <target state="translated">各プログラムは最大4つで構成されています '</target>
        </trans-unit>
        <trans-unit id="41ad41c5b7c7e05b20b0cee772dbf1deebed0213" translate="yes" xml:space="preserve">
          <source>Each report referenced on a&lt;code&gt;REPORT IS&lt;/code&gt;clause (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) must be described with a report description &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 句（&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Descriptionを&lt;/a&gt;参照）で参照される各レポートは、レポートの説明 &lt;code&gt;RD&lt;/code&gt; で説明する必要があります。</target>
        </trans-unit>
        <trans-unit id="c43f0748874dff6862d449d932e3f73e50432ff7" translate="yes" xml:space="preserve">
          <source>Each set of counting instructions contains the following information:</source>
          <target state="translated">各カウント指示のセットには、以下の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="1713797d1fd5be38aa62ec74f40cb5e4ea9a66cb" translate="yes" xml:space="preserve">
          <source>Each set of replacement instructions contains the following information:</source>
          <target state="translated">各交換手順書のセットには、以下の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="ec64521d31f73aadd610d57e3314c5c0cb07d6c8" translate="yes" xml:space="preserve">
          <source>Each specified switch must have at least one of a&lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;ON STATUS&lt;/code&gt;or an&lt;code&gt;OFF STATUS&lt;/code&gt;option defined for it, otherwise there will be no way to reference the switch from within a GnuCOBOL program.</source>
          <target state="translated">指定された各スイッチには、 &lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;ON STATUS&lt;/code&gt; または &lt;code&gt;OFF STATUS&lt;/code&gt; オプションの少なくとも1つが定義されている必要があります。そうでない場合、GnuCOBOLプログラム内からスイッチを参照する方法はありません。</target>
        </trans-unit>
        <trans-unit id="e559cbff67ac689ef745772d42537a3b513d5011" translate="yes" xml:space="preserve">
          <source>Each symbolic character name will be associated with the corresponding &amp;lt;</source>
          <target state="translated">各記号文字名は、対応する&amp;lt;に関連付けられます。</target>
        </trans-unit>
        <trans-unit id="4c00430742f8eba1eaf3bd142512606b4b7f5494" translate="yes" xml:space="preserve">
          <source>Each time a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed against a detail report group defined for this&lt;code&gt;RD&lt;/code&gt; the RWCS will check the contents of each &amp;lt;</source>
          <target state="translated">たび &lt;code&gt;GENERATE&lt;/code&gt; 文は（参照&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）このために定義された詳細レポートグループに対して実行される &lt;code&gt;RD&lt;/code&gt; RWCSがそれぞれの内容を確認します&amp;lt;</target>
        </trans-unit>
        <trans-unit id="48545f108d6d890063854ad082ddb7636b0f7c42" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;directive must be terminated by an&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt;</source>
          <target state="translated">各 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; ディレクティブは &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; で終了する必要があります</target>
        </trans-unit>
        <trans-unit id="3fecee34669e35b4e24782aec546eab94e861c5a" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;RD&lt;/code&gt;will have the following allocated for it:</source>
          <target state="translated">各 &lt;code&gt;RD&lt;/code&gt; には以下が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="558bbf35a31701a51f5e603c87d6e37860e5bac5" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;WHEN&lt;/code&gt;clause (other than the&lt;code&gt;WHEN OTHER&lt;/code&gt;</source>
          <target state="translated">各 &lt;code&gt;WHEN&lt;/code&gt; 句（ &lt;code&gt;WHEN OTHER&lt;/code&gt; 以外）</target>
        </trans-unit>
        <trans-unit id="db708aa4613d2d89fc52c61a7a68b8e5310b35b1" translate="yes" xml:space="preserve">
          <source>Early versions of Micro Focus COBOL allowed programmers to access various runtime library routines by using a single two-digit hexadecimal number as the entry-point name. These were known as call-by-number routines. Over time, Micro Focus COBOL evolved, replacing most of the call-by-number routines with ones accessible using a more conventional call-by-name technique.</source>
          <target state="translated">Micro Focus COBOLの初期バージョンでは、プログラマーは、エントリーポイント名として2桁の16進数を1つ使うことで、様々なランタイム・ライブラリ・ルーチンにアクセスすることができた。これらは、コール・バイ・ナンバー・ルーチンとして知られていました。時が経つにつれ、Micro Focus COBOLは進化し、ほとんどのコールバイナンバー・ルーチンを、より伝統的なコールバイネーム技術を使ってアクセスできるものに置き換えた。</target>
        </trans-unit>
        <trans-unit id="60914652372d8aacfba426f94ef0a27b6bd64788" translate="yes" xml:space="preserve">
          <source>Effortlessly providing arithmetic accuracy to 31 digits, with performance approaching that of well-written assembly-language programs. Don&amp;rsquo;t think this isn&amp;rsquo;t critically important to banks, investment houses and any business interested in tracking revenues, expenses and profits (duh - like ALL of them).</source>
          <target state="translated">計算精度を31桁まで簡単に提供し、パフォーマンスがよく書かれたアセンブリ言語プログラムのパフォーマンスに近づきます。これは、銀行、投資会社、および収益、費用、利益の追跡に関心のあるすべてのビジネスにとって、それほど重要ではないと考えてはいけません。</target>
        </trans-unit>
        <trans-unit id="eb8c33f1bd7b54199aabb312bdff6ad20c4a00e4" translate="yes" xml:space="preserve">
          <source>Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (&quot;screenio.cpy&quot;) defines COB-COLOR-xxxxxx names for the various colors so they may be specified as a more meaningful name rather than a number. The eight colors, by number, with the constant names defined in screenio.cpy, are as follows:</source>
          <target state="translated">画面上の任意の行/列の位置の背景色(スクリーン)と前景色(テキスト)の両方に、8つの異なる色を指定することができる。色は数字で指定されるが、すべてのGnuCOBOL配布物に付属のコピーブック(「screenio.cpy」)には、様々な色のためのCOB-COLOR-xxxxxx名が定義されているので、数字ではなく、より意味のある名前として指定することができる。screenio.cpyで定義された定数名を持つ8色は、以下の通りである。</target>
        </trans-unit>
        <trans-unit id="0de188972590d50f27e84d7799cae74d5422d21a" translate="yes" xml:space="preserve">
          <source>Either a statement that begins with a non decision-making verb and specifies an unconditional action to be taken or a conditional verb such as&lt;code&gt;IF&lt;/code&gt;or&lt;code&gt;EVALUATE&lt;/code&gt; delimited by its explicit scope terminator (such as&lt;code&gt;END-IF&lt;/code&gt;or&lt;code&gt;END-EVALUATE&lt;/code&gt;. An imperative statement can consist of a sequence of imperative statements.</source>
          <target state="translated">非意思決定動詞で始まり、実行する無条件のアクションを指定するステートメント、または明示的なスコープ終了記号（ &lt;code&gt;END-IF&lt;/code&gt; や &lt;code&gt;END-EVALUATE&lt;/code&gt; など）で区切られた &lt;code&gt;IF&lt;/code&gt; や &lt;code&gt;EVALUATE&lt;/code&gt; などの条件付き動詞。命令型ステートメントは、一連の命令文で構成されます。</target>
        </trans-unit>
        <trans-unit id="30ea0da285c9a0b0bf611b3900abc0d992ef03bb" translate="yes" xml:space="preserve">
          <source>Either a&lt;code&gt;BEFORE&lt;/code&gt;phrase, an&lt;code&gt;AFTER&lt;/code&gt;phrase or both may be specified. They may be specified in any order.</source>
          <target state="translated">どちらの &lt;code&gt;BEFORE&lt;/code&gt; 句、 &lt;code&gt;AFTER&lt;/code&gt; の句またはその両方を指定することができます。それらは任意の順序で指定できます。</target>
        </trans-unit>
        <trans-unit id="0caa91b8f1f5f36fcf7fbe55099f1de176c8fde9" translate="yes" xml:space="preserve">
          <source>Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.</source>
          <target state="translated">最初の2つの引数のどちらか、または両方は、英数字リテラル、グループ項目、またはアルファベットまたは英数字データを格納するのに適した要素項目です。2つの引数の長さが不平等な場合、短い方の引数はスペースで右にパディングされているとみなされます。</target>
        </trans-unit>
        <trans-unit id="858e7defec8698672940f8ce436c406862616ecb" translate="yes" xml:space="preserve">
          <source>Either the name of an identifier or a procedure in the program. GnuCOBOL limits user-defined names to a maximum of 31 characters taken from the set of numeric digits, upper- and lower-case letters, hyphens and underscores. A user-defined name may neither begin nor end with a hyphen or underscore. User-defined names used as file names may additionally not begin with a digit although - unlike many other programming languages - user-defined names used as identifiers or procedure names may.</source>
          <target state="translated">プログラム内の識別子またはプロシージャの名前。GnuCOBOLでは、ユーザー定義名は、数字、大文字と小文字、ハイフン、アンダースコアのセットから最大31文字までに制限されています。ユーザ定義名は、ハイフンやアンダースコアで始まったり、終わったりすることはできません。フ ァ イ ル名 と し て用い る ユーザー定義名は、 他の多くのプ ロ グ ラ ミ ン グ言語 と は異な り 、 識別子や手 順名 と し て用い る ユーザー定義名は桁で始ま る こ と があ り ますが、 フ ァ イ ル名 と し て用い る ユーザー定義名は桁で始ま る こ と はあ り ません。</target>
        </trans-unit>
        <trans-unit id="7567d0d8aa3c2f98c0119f54054a4094bbdf6b09" translate="yes" xml:space="preserve">
          <source>Either the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &amp;lt;</source>
          <target state="translated">どちらの &lt;code&gt;USAGE&lt;/code&gt; （参照&lt;a href=&quot;#USAGE&quot;&gt;USAGEを&lt;/a&gt;）の&amp;lt;</target>
        </trans-unit>
        <trans-unit id="12419b0638b06653e626b1a31d9f95a7e8c75d0a" translate="yes" xml:space="preserve">
          <source>Elementary Item</source>
          <target state="translated">初級項目</target>
        </trans-unit>
        <trans-unit id="f61c9f064c3d39237a20a4d7d3d38cc92ed48b49" translate="yes" xml:space="preserve">
          <source>End of file reached if reading forward or beginning-of-file reached if reading backward</source>
          <target state="translated">前方読みの場合はファイルの終端に、後方読みの場合はファイルの先頭に達しています。</target>
        </trans-unit>
        <trans-unit id="eb4a1c1bc69354df732a1fb660f7766fbc1365bb" translate="yes" xml:space="preserve">
          <source>End of page</source>
          <target state="translated">ページの終わり</target>
        </trans-unit>
        <trans-unit id="1f90eed9e128990aa3916d4821f0afedd06fce42" translate="yes" xml:space="preserve">
          <source>Entry-point</source>
          <target state="translated">Entry-point</target>
        </trans-unit>
        <trans-unit id="318f6eeac5e0a5f73cec3c1a7fec998a2d2b42bf" translate="yes" xml:space="preserve">
          <source>Entry-point Name</source>
          <target state="translated">エントリーポイント名</target>
        </trans-unit>
        <trans-unit id="f15859f3eeefa48c8447da8cc8be18ae2f96c167" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL &quot;SYSTEM&quot;) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL プログラム内で作成または変更された環境変数は、そのプログラムによって生成されたサブシェルプロセス (すなわち CALL &quot;SYSTEM&quot;)で利用できますが、GnuCOBOL プログラムを起動したシェルやコンソールウィンドウではわかりません。</target>
        </trans-unit>
        <trans-unit id="d9b239553d90073cbc48e1842b57308d0f503d32" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e.&lt;code&gt;CALL 'SYSTEM'&lt;/code&gt;(see &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;)) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOLプログラム内から作成または変更された環境変数は、そのプログラムによって生成されたすべてのサブシェルプロセス（つまり、 &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; （&lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEMを&lt;/a&gt;参照））で使用できますが、GnuCOBOLプログラムを開始したシェルまたはコンソールウィンドウには認識されません。</target>
        </trans-unit>
        <trans-unit id="a831ca77884d7fa1627dca65d5bcf5b32460e5b1" translate="yes" xml:space="preserve">
          <source>Erased areas will have their foreground and background colors set to the attributes of the field containing the&lt;code&gt;ERASE&lt;/code&gt;clause.</source>
          <target state="translated">消去された領域の前景色と背景色は、 &lt;code&gt;ERASE&lt;/code&gt; 句を含むフィールドの属性に設定されます。</target>
        </trans-unit>
        <trans-unit id="5da25ad570031cfc548ccf057713182fe2696bf6" translate="yes" xml:space="preserve">
          <source>Error Type</source>
          <target state="translated">エラーの種類</target>
        </trans-unit>
        <trans-unit id="091e812df524f11e726f776aeeac24e5d0a26bc7" translate="yes" xml:space="preserve">
          <source>Esc was pressed</source>
          <target state="translated">Escが押された</target>
        </trans-unit>
        <trans-unit id="1d5c1c82e60d938ff99b4032766d8759f53965f9" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE</source>
          <target state="translated">FALSEに評価します。</target>
        </trans-unit>
        <trans-unit id="7718b010814db3432233ea3bdf4b33cc8999b495" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE</source>
          <target state="translated">FALSE AND (FALSE AND TRUE)に評価され、FALSE に評価されます。</target>
        </trans-unit>
        <trans-unit id="e61648f7d13955bbfcf9bc100110e4859aa8fce4" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE</source>
          <target state="translated">FALSE と評価される AND FALSE と評価される TRUE を評価します。</target>
        </trans-unit>
        <trans-unit id="dcd13fd025cd8853636d96d1e4febe9db19f5d33" translate="yes" xml:space="preserve">
          <source>Evaluates to NOT (FALSE) which evaluates to TRUE</source>
          <target state="translated">TRUE を評価する NOT (FALSE)に評価します。</target>
        </trans-unit>
        <trans-unit id="382d1cb13ed9d55b2c9159d78c596a71f0163e66" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE</source>
          <target state="translated">真に評価します。</target>
        </trans-unit>
        <trans-unit id="f75486ff1410d50667eeed0386b80ad55880746c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE (since AND has precedence over OR) - this is identical to the previous example</source>
          <target state="translated">TRUE を評価します(AND は OR よりも優先されるので)-これは先ほどの例と同じです。</target>
        </trans-unit>
        <trans-unit id="4d6d770c334405188a688baa0a731edb1fd48f77" translate="yes" xml:space="preserve">
          <source>Even without the&lt;code&gt;DEBUGGING MODE&lt;/code&gt;clause, it is still possible to compile debugging lines. Debugging lines may also be compiled by specifying the&lt;code&gt;-fdebugging-line&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;DEBUGGING MODE&lt;/code&gt; 句がなくても、デバッグ行をコンパイルすることは可能です。 &lt;code&gt;-fdebugging-line&lt;/code&gt; スイッチを指定して、デバッグ行をコンパイルすることもできます</target>
        </trans-unit>
        <trans-unit id="91552a3314a03734e404c7b97ca06f17613df4cd" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;</source>
          <target state="translated">毎</target>
        </trans-unit>
        <trans-unit id="9f42753b88c31f07e6bcdfda34cbd05a816f1808" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="77e9bb85e78385998b2213a27bb8d8376a21fddb" translate="yes" xml:space="preserve">
          <source>Every data item at the same&lt;code&gt;level&lt;/code&gt;of a hierarchy diagram such as the one you see here (if you were to make one, which you rarely &amp;mdash; if ever &amp;mdash; will, once you get used to this concept) must have the same level number.</source>
          <target state="translated">ここに表示されているものなど、階層図の同じ &lt;code&gt;level&lt;/code&gt; にあるすべてのデータ項目（作成する場合、この概念に慣れたら、めったに&amp;mdash;作成することはありません）は、同じレベル番号を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="464315bf9feceba501caec897c0b6079a97e791c" translate="yes" xml:space="preserve">
          <source>Every entry-point has a name. That name must be unique for all programs that comprise an executable program. Entry-point names are defined using a subroutine&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;paragraph, a user-defined function&amp;rsquo;s&lt;code&gt;FUNCTION-ID&lt;/code&gt;paragraph or via&lt;code&gt;ENTRY&lt;/code&gt;(see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) statements coded in a subprogram&amp;rsquo;s procedure division.</source>
          <target state="translated">すべてのエントリポイントには名前があります。この名前は、実行可能プログラムを構成するすべてのプログラムで一意である必要があります。エントリポイント名は、サブルーチンの &lt;code&gt;PROGRAM-ID&lt;/code&gt; 段落、ユーザー定義関数の &lt;code&gt;FUNCTION-ID&lt;/code&gt; 段落を使用して、またはサブプログラムの手続き部にコーディングされた &lt;code&gt;ENTRY&lt;/code&gt; （&lt;a href=&quot;#ENTRY&quot;&gt;ENTRYを&lt;/a&gt;参照）ステートメントを介して定義されます。</target>
        </trans-unit>
        <trans-unit id="22c250c80a48d66257ba552ab395682e38c843f2" translate="yes" xml:space="preserve">
          <source>Every new level uses a level number that is strictly greater than the one used in the parent (next higher) level.</source>
          <target state="translated">すべての新しいレベルでは、親レベル (次の上位レベル)で使用されるレベル番号よりも厳密に大きいレベル番号が使用されます。</target>
        </trans-unit>
        <trans-unit id="e22c344c08f0a674fec53d0ccadbf31f6f3afb87" translate="yes" xml:space="preserve">
          <source>Every non-FILLER elementary item subordinate to &amp;lt;</source>
          <target state="translated">&amp;lt;に従属するFILLER以外のすべての基本項目</target>
        </trans-unit>
        <trans-unit id="004439041e706926e609b461ee10ab7fd206e801" translate="yes" xml:space="preserve">
          <source>Every program has at least one entry-point &amp;mdash; known as the primary entry-point &amp;mdash; which corresponds to the first executable statement in the procedure division following the declaratives area, if any.</source>
          <target state="translated">すべてのプログラムには、少なくとも1つのエントリポイント（プライマリエントリポイントと呼ばれる）があり、宣言領域に続く手続き部の最初の実行可能ステートメントに対応します。</target>
        </trans-unit>
        <trans-unit id="1601a99f6446d942e939a06dabeb60be03814480" translate="yes" xml:space="preserve">
          <source>Every report has the same basic structure, as shown here, even though not all reports will have all of the groups shown. In fact, it is a very unusual report indeed that actually has every one of these groups:</source>
          <target state="translated">すべてのレポートは、ここに示されているように基本的な構造は同じですが、すべてのレポートに示されているすべてのグループがあるわけではありません。実際には、これらのグループがすべて表示されているレポートは非常に珍しいものです。</target>
        </trans-unit>
        <trans-unit id="cec461b13ba9e76a1b658d70ba02bcb163ba81a4" translate="yes" xml:space="preserve">
          <source>Every report that employs control breaks has a natural hierarchy of those control breaks based upon the manner in which the data the report is being generated from is sorted. This concept is best understood using an example which assumes a COBOL program to process sales data collected from every computerized cash register across a chain of stores having multiple departments is being developed.</source>
          <target state="translated">コントロール・ブレークを使用するすべてのレポートは、レポートが生成されるデータのソート方法に基づいて、それらのコントロール・ブレークの自然な階層構造を持っている。この概念は、複数の部門を持つ店舗のチェーンにまたがるすべてのコンピュータ化されたレジから収集された売上データを処理するCOBOLプログラムが開発されていると仮定した例を用いて最もよく理解される。</target>
        </trans-unit>
        <trans-unit id="b56d93d247b7135e025b8bb06d8e4f1f8158cab1" translate="yes" xml:space="preserve">
          <source>Every time this program is executed, it will produce the same output, because the same sequence of pseudo-random numbers will be generated:</source>
          <target state="translated">このプログラムが実行されるたびに、同じ擬似乱数列が生成されるので、同じ出力が得られます。</target>
        </trans-unit>
        <trans-unit id="631a83a57af68e8b556c535abcfba9d122280242" translate="yes" xml:space="preserve">
          <source>Executable File</source>
          <target state="translated">実行可能ファイル</target>
        </trans-unit>
        <trans-unit id="c4aff9d44d0a696a912102a8ff52dc1f8917cec9" translate="yes" xml:space="preserve">
          <source>Executing a&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt;will influence subsequent&lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt;statements (which will then return the value you displayed), but will not influence subsequent&lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt;statements &amp;mdash; these will continue to return the original program execution parameters.</source>
          <target state="translated">&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; を実行すると、後続の &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; ステートメントに影響します（これにより、表示された値が返されます）が、後続の &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; ステートメントには影響しません。これらは、引き続き元のプログラム実行パラメーターを返します。</target>
        </trans-unit>
        <trans-unit id="b5eccd53038d68d6fe98e6c74bbc70fbdda0f1d8" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">ステートメント &lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt; すると、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3202330dc255528350ed15988600d69cebe769e" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">ステートメント &lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt; すると、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="699332aeb03074ecdaa898353c6db354128e04e0" translate="yes" xml:space="preserve">
          <source>Execution Thread</source>
          <target state="translated">実行スレッド</target>
        </trans-unit>
        <trans-unit id="f7b699c1f1fca94c3574d70d8a9956ade47096d2" translate="yes" xml:space="preserve">
          <source>Execution of the calling program is suspended and control will transfer to the called program, as follows:</source>
          <target state="translated">呼び出し元のプログラムの実行が中断され、以下のように呼び出し元のプログラムに制御が移る。</target>
        </trans-unit>
        <trans-unit id="c1fdde2e7a98a43a8969fd6782e1df3e5e50ec04" translate="yes" xml:space="preserve">
          <source>Execution will begin at the first executable statement following the subprograms entry-point. The entry point will be either the first executable statement following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present (if the subprogram was invoked using its primary entry-point name) or the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) naming the entry-point specified on the&lt;code&gt;CALL&lt;/code&gt;if the subprogram was invoked using an alternate entry point.</source>
          <target state="translated">実行は、サブプログラムのエントリポイントに続く最初の実行可能なステートメントから始まります。エントリポイントは、任意の後の最初の実行文のいずれかになります &lt;code&gt;DECLARATIVES&lt;/code&gt; を（参照&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVESを&lt;/a&gt;（サブプログラムが呼び出された場合、その主エントリポイント名を使用して）以下または最初の実行文を存在するかもしれない） &lt;code&gt;ENTRY&lt;/code&gt; 文は、（参照&lt;a href=&quot;#ENTRY&quot;&gt;ENTRYを&lt;/a&gt;）命名しますサブプログラムが代替エントリポイントを使用して呼び出された場合、 &lt;code&gt;CALL&lt;/code&gt; で指定されたエントリポイント。</target>
        </trans-unit>
        <trans-unit id="df928d8218fa60aea80b123d18575cb29a66dc2a" translate="yes" xml:space="preserve">
          <source>Execution will begin with the first executable statement in the procedure division following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present.</source>
          <target state="translated">実行は、存在する可能性のある &lt;code&gt;DECLARATIVES&lt;/code&gt; （&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVESを&lt;/a&gt;参照）に続く手続き部の最初の実行可能ステートメントから始まります。</target>
        </trans-unit>
        <trans-unit id="813d8ff4c4f053c1fe5a4302c6f9c49604c7c000" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program at the point where the returned value of the function is needed. At that point, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register will be used for the function&amp;rsquo;s value.</source>
          <target state="translated">関数の戻り値が必要な時点で、呼び出し元のプログラムの実行が再開されます。その時点で、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターの値が関数の値に使用されます。</target>
        </trans-unit>
        <trans-unit id="6604bac134b018c911ef4c369060da53971d99cd" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program with the first executable statement following the&lt;code&gt;CALL&lt;/code&gt;that invoked the subprogram.</source>
          <target state="translated">実行は、サブプログラムを呼び出した &lt;code&gt;CALL&lt;/code&gt; に続く最初の実行可能ステートメントを使用して、呼び出し側プログラムで再開されます。</target>
        </trans-unit>
        <trans-unit id="1c4f897e49f43d61c8c285a5f8b529c6df7d4952" translate="yes" xml:space="preserve">
          <source>Expiration of the&lt;code&gt;TIMEOUT&lt;/code&gt;timer &amp;mdash; this will be treated as if the Enter key had been pressed with no data being entered.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; タイマーの期限切れ&amp;mdash;これは、データが入力されていない状態でEnterキーが押されたかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="1ba54893e49d5a98fdd72b1731cb837c15733eae" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE, FILE-CONTROL, FILE-ID, FILLER, FINAL, FIRST, FIXED, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</source>
          <target state="translated">f、factorial、factory、false、fd、file、file-control、file-id、filler、final、first、fixed、float-binary-128、float-binary-32、float-binary-64、float-decimal-16、float-decimal-34、float-extended、float-infinity、float-long、float-not-a-number。float-short,フットイング,for,foreground-color,foreground-color,foreground-color,forever,format,format,formatted-current-date,formatted-date,formatted-date-time,formatted-time,formfeed,fraction-part,free,from,full,function,function-id,function-pointer</target>
        </trans-unit>
        <trans-unit id="c388ca73e917511c83a42c7c3347b5330aa45cac" translate="yes" xml:space="preserve">
          <source>F1&amp;ndash;F64, respectively, were pressed</source>
          <target state="translated">F1〜F64がそれぞれ押された</target>
        </trans-unit>
        <trans-unit id="03de1b80d9ce6c956e045a67ec26864bd9ba86c4" translate="yes" xml:space="preserve">
          <source>FACTORIAL Function Syntax</source>
          <target state="translated">FACTORIAL 関数構文</target>
        </trans-unit>
        <trans-unit id="c9236dbf1d5f35b60810d9900ebae017d4554e9f" translate="yes" xml:space="preserve">
          <source>FALSE Clause Syntax</source>
          <target state="translated">FALSE 節構文</target>
        </trans-unit>
        <trans-unit id="237f463d19c40eb262085170910a45a2579d4007" translate="yes" xml:space="preserve">
          <source>FILE SECTION Syntax</source>
          <target state="translated">FILE SECTION 構文</target>
        </trans-unit>
        <trans-unit id="6dfe1492af3adfd94529936ae7572256a4829765" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item</source>
          <target state="translated">FILE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="a00fbabfeb0e3333ddad8f67452398d7a56df6cc" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item Syntax</source>
          <target state="translated">FILE-SECTION-データ項目構文</target>
        </trans-unit>
        <trans-unit id="3e19d8cecb7e5bc7a9e28e9032b126d8e079e6f9" translate="yes" xml:space="preserve">
          <source>FOREGROUND-COLOR Attribute Syntax</source>
          <target state="translated">FOREGROUND-COLOR 属性構文</target>
        </trans-unit>
        <trans-unit id="d5452f4037c6aa0b6e742313c3d7af9ddb944ba1" translate="yes" xml:space="preserve">
          <source>FRACTION-PART Function Syntax</source>
          <target state="translated">FRACTION-PART 関数構文</target>
        </trans-unit>
        <trans-unit id="6a87ce926e3fdeec20b1a39152e04f9b4879b7c9" translate="yes" xml:space="preserve">
          <source>FREE Syntax</source>
          <target state="translated">無料構文</target>
        </trans-unit>
        <trans-unit id="42879485a7a11418680abc60f6ddfab84a32360f" translate="yes" xml:space="preserve">
          <source>FROM Clause Syntax</source>
          <target state="translated">FROM句構文</target>
        </trans-unit>
        <trans-unit id="2f45ea6b6316a4f10231808ddaece8cd1888d793" translate="yes" xml:space="preserve">
          <source>FULL Attribute Syntax</source>
          <target state="translated">FULL 属性構文</target>
        </trans-unit>
        <trans-unit id="19aa8d076903fa405aac265ff791623484d35537" translate="yes" xml:space="preserve">
          <source>Fails due to rule #1</source>
          <target state="translated">ルール#1のために失敗</target>
        </trans-unit>
        <trans-unit id="c8f41e04860a699d459755ee5bc85c6fd14d5b99" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2a</source>
          <target state="translated">ルール#2aにより失敗</target>
        </trans-unit>
        <trans-unit id="ff00be8ee320bab1c7ba44d9360894c017495313" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2b</source>
          <target state="translated">ルール#2bにより失敗</target>
        </trans-unit>
        <trans-unit id="75efda3b01e99fcd496782dcc687d25e00babfe5" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3a</source>
          <target state="translated">ルール#3aにより失敗</target>
        </trans-unit>
        <trans-unit id="050c309a1409aa9e640bd99affba7737a0884c7e" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3b</source>
          <target state="translated">ルール#3bにより失敗</target>
        </trans-unit>
        <trans-unit id="296fa1d7af3bb7cac562c31b466a3232f2bb3696" translate="yes" xml:space="preserve">
          <source>Fails due to rule #5</source>
          <target state="translated">ルール#5のため失敗</target>
        </trans-unit>
        <trans-unit id="8ba4b7cd854379dc43efe678aa9fc863d5f197f9" translate="yes" xml:space="preserve">
          <source>Fails due to rule #6</source>
          <target state="translated">ルール#6のため失敗</target>
        </trans-unit>
        <trans-unit id="1c882dc98a68cae48a636d1057fb89ac7d36d44d" translate="yes" xml:space="preserve">
          <source>Failure Reason</source>
          <target state="translated">失敗の理由</target>
        </trans-unit>
        <trans-unit id="c35c802e8500c8d21fd613e5ef4507f4da40a451" translate="yes" xml:space="preserve">
          <source>Fatal screen I/O error</source>
          <target state="translated">致命的なスクリーンI/Oエラー</target>
        </trans-unit>
        <trans-unit id="e19ab926093727a391692498a7ce5cfb742d2ae9" translate="yes" xml:space="preserve">
          <source>Field Outlining</source>
          <target state="translated">フィールドアウトライン</target>
        </trans-unit>
        <trans-unit id="3e7ab145eda1bc068c4891bdc4d2491b7ca3babf" translate="yes" xml:space="preserve">
          <source>Figurative Constants</source>
          <target state="translated">比喩的定数</target>
        </trans-unit>
        <trans-unit id="daa8d8ba501862c2b07978aab870f1b814a865ba" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &amp;lt;</source>
          <target state="translated">ファイルの場所の文字列は、（実行時に）データファイルへのパスとファイル名を識別するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0f3e89f8a70a0298352574b5f3d10f8e9f6307ef" translate="yes" xml:space="preserve">
          <source>File Location Strings will be discussed shortly.</source>
          <target state="translated">ファイルロケーション文字列については近日中に説明します。</target>
        </trans-unit>
        <trans-unit id="30ee6392d050dffb23e534b9b1e788b586e3c285" translate="yes" xml:space="preserve">
          <source>File already open</source>
          <target state="translated">すでに開いているファイル</target>
        </trans-unit>
        <trans-unit id="1f1c6a46840542ee93667be29fe00c4a2ca6e55e" translate="yes" xml:space="preserve">
          <source>File not available</source>
          <target state="translated">ファイルが利用できません</target>
        </trans-unit>
        <trans-unit id="a22e9c3b6a9f5c70de4f76a464810ecba1fb97c3" translate="yes" xml:space="preserve">
          <source>File not found</source>
          <target state="translated">ファイルが見つかりません</target>
        </trans-unit>
        <trans-unit id="d5a01ba68e46b606375d0915c493efcb6d3e3101" translate="yes" xml:space="preserve">
          <source>File not open</source>
          <target state="translated">ファイルが開かない</target>
        </trans-unit>
        <trans-unit id="aa73a3bd94b48e7abeca430b784ba4827580e7e5" translate="yes" xml:space="preserve">
          <source>File section data buffers (and therefore all 01-level record layouts defined in the file section) are initialized to all binary zeros when the program is loaded into storage.</source>
          <target state="translated">ファイルセクションのデータバッファ(したがって、ファイルセクションで定義されたすべての01レベルのレコードレイアウト)は、プログラムがストレージにロードされると、すべてのバイナリゼロに初期化されます。</target>
        </trans-unit>
        <trans-unit id="2b5ebf13d43a94cfe869d3ece0ff8aa5a1595ced" translate="yes" xml:space="preserve">
          <source>File sharing failure</source>
          <target state="translated">ファイル共有の失敗</target>
        </trans-unit>
        <trans-unit id="d6b7a316c213638a85b3dd6184fc41aa5cc4fb7b" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">ファイル共有を使用して制御される &lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f47df965cafac62967f207b6e7f09ae5add8b8f" translate="yes" xml:space="preserve">
          <source>File-Based SORT Syntax</source>
          <target state="translated">ファイルベースのSORT構文</target>
        </trans-unit>
        <trans-unit id="d87ff91def81de51380ccde36991f463b59063af" translate="yes" xml:space="preserve">
          <source>File/Sort-Description Syntax</source>
          <target state="translated">構文ファイル/ソート記述</target>
        </trans-unit>
        <trans-unit id="7083473fe7c031e4e4634ba20b9fb70b80346024" translate="yes" xml:space="preserve">
          <source>Files assigned to&lt;code&gt;PRINTER&lt;/code&gt;or&lt;code&gt;CONSOLE&lt;/code&gt;should be specified as&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PRINTER&lt;/code&gt; または &lt;code&gt;CONSOLE&lt;/code&gt; に割り当てられたファイルは、 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; として指定する必要があります</target>
        </trans-unit>
        <trans-unit id="edea6aacf2ec3d63ce72d8e95db88b7bd15eacd7" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description &lt;code&gt;SD&lt;/code&gt; while every other file is described with a File Description &lt;code&gt;FD&lt;/code&gt;. Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">ソート/マージ作業ファイルとして使用することを目的としたファイルは、ソート/マージファイル記述 &lt;code&gt;SD&lt;/code&gt; で記述する必要があります。他のすべてのファイルは、ファイル記述 &lt;code&gt;FD&lt;/code&gt; で記述します。ほとんどの場合、これらの説明の後には少なくとも1つのレコードの説明が続きます。</target>
        </trans-unit>
        <trans-unit id="367feea21d15dacc3ac862c7a57bd856bad73096" translate="yes" xml:space="preserve">
          <source>Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.</source>
          <target state="translated">最後に、COBOLは、表にあるデータのインプレースソートを実行する機能を持っています。</target>
        </trans-unit>
        <trans-unit id="a6001a209721116a31aff91d01e445326ed01374" translate="yes" xml:space="preserve">
          <source>Finally, here&amp;rsquo;s the report the program generates!</source>
          <target state="translated">最後に、これがプログラムが生成するレポートです！</target>
        </trans-unit>
        <trans-unit id="f8e1fd8ed05817c2c1238d06570433fc37097c39" translate="yes" xml:space="preserve">
          <source>Finally,the&lt;code&gt;REPORT FOOTING&lt;/code&gt;group, if any, will be presented.</source>
          <target state="translated">最後に、もしあれば、 &lt;code&gt;REPORT FOOTING&lt;/code&gt; グループが表示されます。</target>
        </trans-unit>
        <trans-unit id="8a928ac89796afd20a583c169e78e1d2e97f3cee" translate="yes" xml:space="preserve">
          <source>First, the &quot;Hard Way&quot;:</source>
          <target state="translated">まずは「硬派な道」。</target>
        </trans-unit>
        <trans-unit id="69a656c5968fc19e26398c39c1d42930578021ec" translate="yes" xml:space="preserve">
          <source>First/Last Digit</source>
          <target state="translated">最初/最後の桁</target>
        </trans-unit>
        <trans-unit id="c698ef5e7b0a316052b55cd8ba9f275dd3cc64d1" translate="yes" xml:space="preserve">
          <source>Fixed Format Mode</source>
          <target state="translated">固定フォーマットモード</target>
        </trans-unit>
        <trans-unit id="fb6455fd910bbce0c221e84e30d7a80946a5a47c" translate="yes" xml:space="preserve">
          <source>Floating-point values using &quot;Enn&quot; notation such as 9.92E25, representing 9.92 x 10^25 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the -14th power). Both the mantissa (the number before the E) and the exponent (the number after the E) may be explicitly specified as positive (with a +), negative (with a -) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of precision.</source>
          <target state="translated">9.92E25は9.92×10^25(25乗に10乗)を表し、5.7E-14は5.7×10^-14(-14乗に10乗)を表すなど、&quot;Enn &quot;表記を使用した浮動小数点値。仮数(E の前の数)と指数(E の後の数)は、両方とも明示的に正(+付き)、負(-付き)、または符号なし(したがって暗黙のうちに正)として指定できます。浮動小数点リテラルの値は、-1.7 x 10^308 から +1.7 x 10^308 の範囲内で、精度は小数点以下15桁以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5988bca9b2f3443b9ecd1f06fab806eb243168de" translate="yes" xml:space="preserve">
          <source>Footing Area</source>
          <target state="translated">フーディングエリア</target>
        </trans-unit>
        <trans-unit id="e40c95fbb3b9dc7a620c19bde2435c717bde7695" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the&lt;code&gt;NEXT PAGE&lt;/code&gt;option in its&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">脚注領域-これの例外は、レポート脚注レポートグループの &lt;code&gt;LINE&lt;/code&gt; （&lt;a href=&quot;#LINE&quot;&gt;LINEを&lt;/a&gt;参照）句に &lt;code&gt;NEXT PAGE&lt;/code&gt; オプションが含まれている場合です。そのような場合、レポートのフッターは、レポートの最後のページに単独で表示されます。</target>
        </trans-unit>
        <trans-unit id="a3127f980dbd36611f50532c041a2233802b3eff" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if CONVERT were not specified).</source>
          <target state="translated">他のすべてのデータ型では、フィールドのサイズが項目のサイズに設定されます (CONVERT を指定しなかった場合と同じです)。</target>
        </trans-unit>
        <trans-unit id="c1fcb175d336c0714548be23a006f2304e931f29" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &amp;lt;</source>
          <target state="translated">ソースアイテムごとに、送信アイテムのコンテンツが文字ごとに&amp;lt;にコピーされます。</target>
        </trans-unit>
        <trans-unit id="cf9156cf449643f9bda337a140c24f2f1504f039" translate="yes" xml:space="preserve">
          <source>For example, You will not expect to see any difference whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">例えば、1、100、500、1000の値の間には何の違いも期待できませんが、250000000と5000000000のような値の間には違いがあるはずです。</target>
        </trans-unit>
        <trans-unit id="3368f51d3762d71c83916eebf4457e0236b996e5" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD('!')&lt;/code&gt;returns 34 because &quot;!&quot; is the 34th ASCII character. If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.</source>
          <target state="translated">たとえば、プログラムが標準のASCII照合シーケンスを使用しているとすると、 &lt;code&gt;ORD('!')&lt;/code&gt; は34を返します。34番目のASCII文字です。この関数を使用してASCII文字を数値に変換する場合は、結果から1を引く必要があります。</target>
        </trans-unit>
        <trans-unit id="55a9ee5de13cdf67bb331bd003f29ecf42021db7" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt;returns 2 because the 2nd character in the argument list (the ASCII character &amp;rsquo;z&amp;rsquo;) occurs after &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;!&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">たとえば、プログラムが標準のASCII照合シーケンスを使用しているとすると、 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; は2を返します。これは、引数リストの2番目の文字（ASCII文字 'z'）が後に発生するためです。 「Z」と「！」プログラム照合シーケンス。各&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0b8897a3e322f2447e1c9d83730f3c7e2254e611" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt;returns 3 because the 3rd character in the argument list (the ASCII character &amp;rsquo;!&amp;rsquo;) occurs before &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;z&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">たとえば、プログラムが標準のASCII照合シーケンスを使用しているとすると、 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; は3を返します。これは、引数リストの3番目の文字（ASCII文字 '！'）がプログラム照合シーケンスの「Z」と「z」。各&amp;lt;</target>
        </trans-unit>
        <trans-unit id="749e13e172aac64f618104a47c4a2c7a40595730" translate="yes" xml:space="preserve">
          <source>For example, if &amp;lt;</source>
          <target state="translated">たとえば、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="24697a3ba1d925f052573a7696493b003e3077cd" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set &amp;mdash; an exclamation-point (&quot;!&quot;). If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.</source>
          <target state="translated">たとえば、プログラムが（デフォルトの）ASCII文字セットを使用している場合、CHAR（34）はASCII文字セットの34番目の文字、感嘆符（ &quot;！&quot;）を返します。この関数を使用して数値を対応するASCII文字に変換する場合は、数値より1大きい引数値を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="86d303a32d15849fb5f8b370e6bee4a9d77d8625" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s assume we&amp;rsquo;re sorting a series of financial transactions. The SORT statement might look like this:</source>
          <target state="translated">たとえば、一連の金融取引を並べ替えているとします。SORTステートメントは次のようになります。</target>
        </trans-unit>
        <trans-unit id="fb00a63cdc6f6eb78d00ce4dd102beadda021aab" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you need to allocate a data item that contains however many millions of dollars of revenue your company has in gross revenues this year:</source>
          <target state="translated">たとえば、会社の今年の総収入が何百万ドルにも及ぶ収入を含むデータアイテムを割り当てる必要があるとします。</target>
        </trans-unit>
        <trans-unit id="baad68c9ee59c08b3b83b0d9b5e6c9c54362d8ca" translate="yes" xml:space="preserve">
          <source>For example, observe the following data structure which defines a 4 column by 3 row grid of characters:</source>
          <target state="translated">例えば、4列×3行の文字のグリッドを定義する以下のデータ構造を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3aafb29761d15f601ec670e73bfded28362456c7" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &quot;Hexadecimal&quot;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &quot;Hexadecimal&quot; class:</source>
          <target state="translated">例えば、以下では、&quot;Hexadecimal &quot;と呼ばれるクラスを定義しています。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="dab6ce21e23d5e22f729efd782034eee11b18ef5" translate="yes" xml:space="preserve">
          <source>For files in the&lt;code&gt;SEQUENTIAL&lt;/code&gt;access mode, the last input-output statement executed against &amp;lt;</source>
          <target state="translated">&lt;code&gt;SEQUENTIAL&lt;/code&gt; アクセスモードのファイルの場合、&amp;lt;に対して実行された最後の入出力ステートメント</target>
        </trans-unit>
        <trans-unit id="0033fcaf736090140a9ae955ceeeed639d0db017" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements &quot;read&quot; better. Take this, for example:</source>
          <target state="translated">重要な計算では、 &lt;code&gt;COMPUTE&lt;/code&gt; ステートメントの方が「読み取り」がよくなります。たとえば、次のようにします。</target>
        </trans-unit>
        <trans-unit id="4b25cf83aa9b241d27a0438f702e22b38e6a5771" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">重要な計算の場合、 &lt;code&gt;COMPUTE&lt;/code&gt; ステートメントは、基本的な算術ステートメントの同等のチェーンよりも高速に実行される可能性があります。たとえば、上記のCOMPUTEステートメントは、GnuCOBOLを使用しているコンピューターでは、MULTIPLY-ADD-DIVIDEシーケンスよりも約25％高速に実行されます。</target>
        </trans-unit>
        <trans-unit id="483a043da3e58761a7a31d92b7cee03f34d3a0e9" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the &quot;sequence number area&quot; of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &quot;xxmmyy&quot; are required on every altered line of a program &amp;mdash; &quot;xx&quot; is the initials of the programmer while &quot;mmyy&quot; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">しばらくの間（1970年代後半に戻る）、COBOLステートメントの「シーケンス番号領域」（列1〜6）が変更インジケータ領域として使用されるようになりました。プログラマーは、プログラムで変更したすべての行の列1から6にコードを配置します。著者はCOBOLショップで働いており、プログラムの変更されたすべての行に「xxmmyy」形式の変更インジケーターが必要です。「xx」はプログラマーのイニシャル、「mmyy」は日付の月と2桁の年です変更が行われました。これには、COBOLプログラムの上部またはその近くにコメントブロックが付随していることが多く、行われた変更とその変更をマークするために使用された変更インジケーターに関する一般的なドキュメントが提供されます。</target>
        </trans-unit>
        <trans-unit id="e2dea5e1669c0a9fe3c1fbcb48cb6bd943c60b26" translate="yes" xml:space="preserve">
          <source>For the sake of brevity, this document lists the data in three columns.</source>
          <target state="translated">簡潔にするために、このドキュメントではデータを3つの列に分けてリストアップしています。</target>
        </trans-unit>
        <trans-unit id="ba325520d21c79af4680da537a3249fca4c6eeab" translate="yes" xml:space="preserve">
          <source>For the values specified on a&lt;code&gt;PAGE LIMIT&lt;/code&gt;clause to be valid, all of the following must be true:</source>
          <target state="translated">&lt;code&gt;PAGE LIMIT&lt;/code&gt; 句で指定された値が有効であるためには、以下のすべてが真でなければなりません。</target>
        </trans-unit>
        <trans-unit id="efdae81d538ace29e7236aee7c1c96a4ee6706e5" translate="yes" xml:space="preserve">
          <source>For trivial computations, on the other hand, I prefer the inherent readability of a statement such as this:</source>
          <target state="translated">些細な計算のためには、一方で、私はこのような文の本質的な可読性を好む。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="09bebf0bea412802e3fbb625d9294d89526d28f2" translate="yes" xml:space="preserve">
          <source>Format 1 of the&lt;code&gt;REPLACE&lt;/code&gt;statement can be used to make changes to program source code in much the same way as the&lt;code&gt;REPLACING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; ステートメントの形式1を使用して、 &lt;code&gt;REPLACING&lt;/code&gt; とほぼ同じ方法でプログラムのソースコードを変更できます。</target>
        </trans-unit>
        <trans-unit id="e143df1aa83eabbe82d17220703bff1e6c2ae88e" translate="yes" xml:space="preserve">
          <source>Free Format Mode</source>
          <target state="translated">フリーフォーマットモード</target>
        </trans-unit>
        <trans-unit id="fbc349f93c5e079ef91504e8bcea3293322299f8" translate="yes" xml:space="preserve">
          <source>From the sequence of &amp;lt;</source>
          <target state="translated">&amp;lt;のシーケンスから</target>
        </trans-unit>
        <trans-unit id="ffd07c1bac910139b31da58ed3629443089db490" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &quot;pen&quot; is about to &quot;write&quot; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">ペン」が現在のページのどこに「書こうとしているか」を完全に認識し、古いページを閉じるためのページフッターや新しいページを始めるためのページヘッダーの自動生成とともに、新しいページへのイジェクトを自動的に強制的に行います。</target>
        </trans-unit>
        <trans-unit id="3a8b63681a5465651b7dd860e482efb9e8de5eee" translate="yes" xml:space="preserve">
          <source>Full-line comments</source>
          <target state="translated">フルラインコメント</target>
        </trans-unit>
        <trans-unit id="a21a4b632492cfc3397cd22cf7495b9aac4c3cd0" translate="yes" xml:space="preserve">
          <source>Full-line comments with form-feed</source>
          <target state="translated">フォームフィードによる全行コメント</target>
        </trans-unit>
        <trans-unit id="a09ae3cf11bf198bd67625dda3216ea87527262f" translate="yes" xml:space="preserve">
          <source>Function argument error</source>
          <target state="translated">関数引数エラー</target>
        </trans-unit>
        <trans-unit id="fe94fb61bab790759d07739129a3829c99d0ddcc" translate="yes" xml:space="preserve">
          <source>GENERATE Syntax</source>
          <target state="translated">GENERATE 構文</target>
        </trans-unit>
        <trans-unit id="ce7e9bdff283283e8c751261303522d7a587ceec" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</source>
          <target state="translated">生成、取得、与える、グローバル、go、goback、大きい、グリッド、グループ、グループ利用</target>
        </trans-unit>
        <trans-unit id="3f77fc06eaeeaf7f12de14c907a75f7348ac4dc4" translate="yes" xml:space="preserve">
          <source>GLOBAL Attribute Syntax</source>
          <target state="translated">GLOBAL 属性構文</target>
        </trans-unit>
        <trans-unit id="be6aeb1acd05ec878a2af6fecff181b13e85aa9a" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON Syntax</source>
          <target state="translated">構文に依存するに移動します。</target>
        </trans-unit>
        <trans-unit id="64f22d3218b9eaee10fe86a76b0f4f7308747bfe" translate="yes" xml:space="preserve">
          <source>GOBACK Syntax</source>
          <target state="translated">GOBACK構文</target>
        </trans-unit>
        <trans-unit id="508368112dc00f3cf1200af84f7e4f2f7a3b1cbd" translate="yes" xml:space="preserve">
          <source>GROUP-INDICATE Attribute Syntax</source>
          <target state="translated">GROUP-INDICATE 属性構文</target>
        </trans-unit>
        <trans-unit id="c9af09d3388e8d49bb54cf04c1c03cad69919dbf" translate="yes" xml:space="preserve">
          <source>Generally, these routines are intended to match those available in Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.</source>
          <target state="translated">一般的に、これらのルーチンは、Micro Focus COBOL、ACUCOBOL、およびGnuCOBOL用に直接利用可能なものと一致するように意図されている。</target>
        </trans-unit>
        <trans-unit id="9d41e5d8aa938481797b811e06ef4d213ca2b12d" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &amp;lt;</source>
          <target state="translated">ユーザー定義の置換可能な項目を表す一般的な用語は、構文図では完全に小文字で表示されます。このようなアイテムがテキストで参照されている場合、&amp;lt;として表示されます</target>
        </trans-unit>
        <trans-unit id="a9457bdd27c6a3d78025d6c377d1adcbbc659a08" translate="yes" xml:space="preserve">
          <source>Getting file information (size and last-modification date/time)</source>
          <target state="translated">ファイル情報(サイズと最終修正日時)の取得</target>
        </trans-unit>
        <trans-unit id="75e08852c633c9bcebe7ab91746503bd91ff4946" translate="yes" xml:space="preserve">
          <source>Getting the length (in bytes) of an argument passed to a subroutine</source>
          <target state="translated">サブルーチンに渡された引数の長さ(バイト数)を取得します。</target>
        </trans-unit>
        <trans-unit id="838fcc5009c91a67ccafcd3d8a98dceb9843f0c5" translate="yes" xml:space="preserve">
          <source>Giving a table an initial, compile-time value is one of the trickier aspects of COBOL data definition. There are basically three standard techniques and a fourth that people familiar with other COBOL implementations but new to GnuCOBOL may find interesting. So, here are the three</source>
          <target state="translated">テーブルにコンパイル時の初期値を与えることは、COBOLデータ定義の厄介な側面の一つである。基本的には、3つの標準的な技術と、他のCOBOL実装には慣れているがGnuCOBOLには慣れていない人が興味を持つかもしれない4つ目の技術がある。以下に3つの技術を紹介する。</target>
        </trans-unit>
        <trans-unit id="dacd5d80181f68a262558fbeed5d04078293a6de" translate="yes" xml:space="preserve">
          <source>GnuCOBOL</source>
          <target state="translated">GnuCOBOL</target>
        </trans-unit>
        <trans-unit id="b879a384bcf6b18e0b722cf0970e253d133c9742" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Sample Programs</source>
          <target state="translated">GnuCOBOLサンプルプログラム</target>
        </trans-unit>
        <trans-unit id="e9fc1fe76cf391a32dad55a122f4e0a0353992f7" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the&lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt;clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOLは、 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 節が指定されていない場合でも、指定されているかのように常に動作します。</target>
        </trans-unit>
        <trans-unit id="9e90bf626298379ff7d3f8b411b399e5608f6660" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers&lt;code&gt;ASCII&lt;/code&gt;</source>
          <target state="translated">GnuCOBOLは &lt;code&gt;ASCII&lt;/code&gt; を考慮します</target>
        </trans-unit>
        <trans-unit id="ade20b6aef56cd0ff2aed2427da9159fa14af39b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines compilation variables when certain conditions are true.</source>
          <target state="translated">GnuCOBOLでは、特定の条件が真の場合のコンパイル変数を定義しています。</target>
        </trans-unit>
        <trans-unit id="12cf00b4626858f857b18dd724c1c9875f678c7e" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 standard, such as the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions.</source>
          <target state="translated">GnuCOBOLは、COBOLのANSI 85標準の大部分を完全にサポートし（唯一の主要な除外は通信モジュールです）、 &lt;code&gt;SCREEN SECTION&lt;/code&gt; （&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTIONを&lt;/a&gt;参照）、テーブルベースの &lt;code&gt;SORT&lt;/code&gt; （&lt;a href=&quot;#Table-SORT&quot;&gt;テーブルSORT&lt;/a&gt;）とユーザー定義関数。</target>
        </trans-unit>
        <trans-unit id="97e9d0710dd9b847b88301b5ded4630f6ebd6cf5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &quot;portable&quot; distribution.</source>
          <target state="translated">GnuCOBOLは、Microsoftが無料でダウンロードできるVisual Studio Expressパッケージを利用してCコンパイラーとリンカー/ローダーを提供する真にネイティブなWindowsアプリケーションとしても構築されています。このアプローチは、「ポータブル」ディストリビューションには適していません。</target>
        </trans-unit>
        <trans-unit id="763499a319b22b6d28fecd96e5e4577d44422e38" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-x&lt;/code&gt; スイッチでコンパイルされたGnuCOBOLプログラム</target>
        </trans-unit>
        <trans-unit id="20252ad5ff4fe084533d45067eda2369ad4e5568" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the&lt;code&gt;CALL&lt;/code&gt;statement.</source>
          <target state="translated">GnuCOBOLランタイム画面管理は、意味のある値を受け取るために、このルーチンを呼び出す前に初期化されている必要があります。つまり、 &lt;code&gt;CALL&lt;/code&gt; ステートメントを実行する前に、 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; ステートメント（&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-itemを&lt;/a&gt;参照）または &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; ステートメント（&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-itemを&lt;/a&gt;参照）を実行しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="bca9afd1bdb28fa197bd33fb7a24153cdc7c56b4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL は、システムにネイティブなビッグエンディアン形式またはリトルエンディアン形式のいずれかを使用して、 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; および &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; データ項目を格納します。</target>
        </trans-unit>
        <trans-unit id="3b9f975d574fd7cc4ea7de4b02075b1a7eaf9bfc" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOLは、ビッグエンディアン形式またはリトルエンディアン形式のいずれかを使用して、システムにネイティブな &lt;code&gt;FLOAT-LONG&lt;/code&gt; および &lt;code&gt;FLOAT-SHORT&lt;/code&gt; データ項目を格納します。</target>
        </trans-unit>
        <trans-unit id="6ab3cffbe92c165a46df6ca158ad1c4a6a0c158c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL subprograms may be created as either static or dynamic subprograms, as desired by the programmer.</source>
          <target state="translated">GnuCOBOLサブプログラムは、プログラマが望むように、静的サブプログラムまたは動的サブプログラムとして作成することができます。</target>
        </trans-unit>
        <trans-unit id="183088592eb0fa2ad8ba5f34425e030453ebfcc8" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOLは、 &lt;code&gt;SCREEN SECTION&lt;/code&gt; （&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTIONを&lt;/a&gt;参照）で以下の視覚属性仕様をサポートしています。</target>
        </trans-unit>
        <trans-unit id="6684809df42a659397430ece5dce09f5dd77386c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the&lt;code&gt;-conf&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOLはコンパイラー構成ファイルを使用して、コンパイルプロセスを制御するさまざまなオプションを定義します。これらの構成ファイルは &lt;code&gt;-conf&lt;/code&gt; スイッチを使用して指定されます</target>
        </trans-unit>
        <trans-unit id="3bd06fc3f53a54465c3ccaa768b1a3b1875dd413" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL implementations, supports a number of reserved words that may be used to represent a specific literal value. These are known as figurative constants. See &lt;a href=&quot;#Figurative-Constants&quot;&gt;Figurative Constants&lt;/a&gt;, for more information.</source>
          <target state="translated">GnuCOBOLは、他のCOBOL実装と同様に、特定のリテラル値を表すために使用できるいくつかの予約語をサポートしています。これらは表意定数として知られています。詳細については、&lt;a href=&quot;#Figurative-Constants&quot;&gt;表意定数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e2bb4d252c23fe267cb78311b78a5c392a8eb567" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &quot;template&quot; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">優れたプログラマーは、何十年もの間、さまざまなタイプのプログラム用に独自のスケルトン「テンプレート」プログラムを維持してきました。テンプレートをテキストエディタにロードするだけで、プログラムを開始できます&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bb1297cd4586126018027c7f1e1612420c22c4d" translate="yes" xml:space="preserve">
          <source>Green: COB-COLOR-GREEN</source>
          <target state="translated">グリーンです。コブカラーグリーン</target>
        </trans-unit>
        <trans-unit id="7c42686edc5c14ca17081cedfebfa14c924ebc58" translate="yes" xml:space="preserve">
          <source>Group Item</source>
          <target state="translated">グループ項目</target>
        </trans-unit>
        <trans-unit id="abf442e977221f7e251a5aee4a674647ed69f44a" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;section in the declaratives area of the procedure division will place information documenting why the&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;procedure was invoked. Consult the&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">グループ項目&amp;mdash; 手続き部の宣言領域の &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; セクションによって生成されたデバッグ情報が、 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; プロシージャが呼び出された理由を文書化する情報を配置するグループ項目。相談する &lt;code&gt;DECLARATIVES&lt;/code&gt; （参照&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVESを&lt;/a&gt;このレジスタの構造に関する情報のため）のドキュメントを。</target>
        </trans-unit>
        <trans-unit id="810a65e9b0bdcfef9d822c231c10d01c65b32ddf" translate="yes" xml:space="preserve">
          <source>Group items (those without&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">グループアイテム（ &lt;code&gt;PICTURE&lt;/code&gt; のないもの）</target>
        </trans-unit>
        <trans-unit id="89a17ef0f66b4296a009bd40714a7d880bc71878" translate="yes" xml:space="preserve">
          <source>HEADING, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUE, HIGH-VALUES</source>
          <target state="translated">見出し、最高代数、ハイライト、高値、高値</target>
        </trans-unit>
        <trans-unit id="30cfc7dc90ba24ab43e38507c7e4463f0560ba02" translate="yes" xml:space="preserve">
          <source>HIGHEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">HIGHEST-ALGEBRAIC 関数構文</target>
        </trans-unit>
        <trans-unit id="d60066848e06a51085c8e2354e105347e3c601c8" translate="yes" xml:space="preserve">
          <source>HIGHLIGHT Attribute Syntax</source>
          <target state="translated">HIGHLIGHT 属性構文</target>
        </trans-unit>
        <trans-unit id="8c6979d233b84b4e040cc3b6f33204115bd4f223" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the&lt;code&gt;-&lt;/code&gt; there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items.</source>
          <target state="translated">左および/または右の少なくとも一方のスペースがあった &lt;code&gt;-&lt;/code&gt; 何の曖昧さがなかっただろう-コンパイラが個々に使用することを余儀なくされていた &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;D&lt;/code&gt; のデータ項目を。</target>
        </trans-unit>
        <trans-unit id="87a433cf0bc677c32d39cd5b979920082688b536" translate="yes" xml:space="preserve">
          <source>Heading Area</source>
          <target state="translated">見出しエリア</target>
        </trans-unit>
        <trans-unit id="cbbb9cee65c6576a367576c2ac65ada91311b34f" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the&lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">見出し領域&amp;mdash;これの例外は、レポート見出しレポートグループに &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; （&lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUPを&lt;/a&gt;参照）オプションが含まれている場合です。そのような場合、レポートの見出しは、レポートの最初のページ（そのページの任意の場所）に単独で表示されます。</target>
        </trans-unit>
        <trans-unit id="9a3fc3dac7c2610f19172d33b654b99f82029bf8" translate="yes" xml:space="preserve">
          <source>Here are a few examples:</source>
          <target state="translated">いくつかの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="a58d0be2a26b29065720289affde96b396953bc6" translate="yes" xml:space="preserve">
          <source>Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).</source>
          <target state="translated">ここでは、演算の優先順位が算術式の結果にどのように影響するかについて、いくつかの例を紹介します(議論を簡単にするために、すべての例では数値リテラルを使用しています)。</target>
        </trans-unit>
        <trans-unit id="ce8b7658bf191725329e97e66717da8863c93fce" translate="yes" xml:space="preserve">
          <source>Here are the facts &amp;mdash; draw your own conclusions as to which approach is more appropriate under which circumstances.</source>
          <target state="translated">事実は次のとおりです。どの状況でどのアプローチがより適切であるかについて、独自の結論を導き出します。</target>
        </trans-unit>
        <trans-unit id="71e41b379565b9db9a0898e306e44094c8f202bb" translate="yes" xml:space="preserve">
          <source>Here are the meanings of the three options:</source>
          <target state="translated">3つの選択肢の意味をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8db79160667581172099438ddb7cbe10fdc25a56" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named &quot;testprog&quot;, which is designed to simply announce if SWITCH-1 is on:</source>
          <target state="translated">ここでは、&quot;testprog &quot;という名前のプログラムの中で、SWITCH-1がオンになっているかどうかを単純にアナウンスするように設計されたコードの関連部分を紹介します。</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">その結果をご紹介します。</target>
        </trans-unit>
        <trans-unit id="6bcf44b499d0088da0556d2de36d212cd7d4aaa3" translate="yes" xml:space="preserve">
          <source>Here are the rules about GnuCOBOL dynamically-loadable modules:</source>
          <target state="translated">ここでは、GnuCOBOLで動的にロード可能なモジュールについてのルールを説明します。</target>
        </trans-unit>
        <trans-unit id="d98760fd5f7d0d451fc2f1b70dda01b46952cd2b" translate="yes" xml:space="preserve">
          <source>Here are two different &quot;Hello World&quot; applications &amp;mdash; one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">2つの異なる「Hello World」アプリケーションがあります。1つはJavaで記述され、もう1つはGnuCOBOLで記述されています。まず、Javaバージョン：</target>
        </trans-unit>
        <trans-unit id="2486c63ce113fa9dfa91ee5ea183529c4d50239f" translate="yes" xml:space="preserve">
          <source>Here are two examples of using&lt;code&gt;cobcrun&lt;/code&gt; First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">次に、 &lt;code&gt;cobcrun&lt;/code&gt; を使用する2つの例を示します。まず、Unix、OSX、またはWindows / Cygwinシステムでの使用です。</target>
        </trans-unit>
        <trans-unit id="88f0b25a36a42c34f75db34b7878e30378e348fc" translate="yes" xml:space="preserve">
          <source>Here is a sample program that illustrates the EVALUATE statement.</source>
          <target state="translated">EVALUATE文を説明するサンプルプログラムです。</target>
        </trans-unit>
        <trans-unit id="b44351443986b8d6208b8077f937b80d2c5d797f" translate="yes" xml:space="preserve">
          <source>Here is an example of a main program (DEMOFACT) that calls both a subprogram (SUB) and a user-defined function (FUNC) to compute the factorial value of a number.</source>
          <target state="translated">ここでは、サブプログラム(SUB)とユーザ定義関数(FUNC)の両方を呼び出して数値の階乗値を計算するメインプログラム(DEMOFACT)の例を示します。</target>
        </trans-unit>
        <trans-unit id="fce56f05dd0a684307248e0509281b28f6150e2a" translate="yes" xml:space="preserve">
          <source>Here is an example. The following two GnuCOBOL statements both display the same result (27):</source>
          <target state="translated">以下に例を示します。以下の2つのGnuCOBOL文は、どちらも同じ結果を表示します(27)。</target>
        </trans-unit>
        <trans-unit id="b6e578854c806b2cf1a7f51f1181b4443af68716" translate="yes" xml:space="preserve">
          <source>Here is how the main program and the three subprograms could be compiled if the three subprograms are to be dynamic:</source>
          <target state="translated">ここでは、3つのサブプログラムを動的にする場合に、メインプログラムと3つのサブプログラムをどのようにコンパイルするかを説明します。</target>
        </trans-unit>
        <trans-unit id="b8a4250afe2b9b703be52c8963f7c7e83af93bec" translate="yes" xml:space="preserve">
          <source>Here is how these four programs would be compiled if the three subprograms are to be static:</source>
          <target state="translated">3つのサブプログラムを静的にする場合、これら4つのプログラムをどのようにコンパイルするかは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3885b22c6e4bdc48af657c6fedb7ca8f97433747" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">これは、プログラムが読み取るデータです。そのCPUに対するベンチマークのスコアは、PassMarkベンチマークソフトウェアによって&lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; Webサイトに報告されているため、各レコードは特定の1つのCPUに対する集計されたベンチマークスコアリングを反映しています。データは4つのフィールドで構成されます。フィールドは、単一のコンマによって互いに分離されます。フィールドの説明は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b01180e30ff342f12b30bea352d08df8ee331a14" translate="yes" xml:space="preserve">
          <source>Here is the listing of a GnuCOBOL program that uses 01-level constants to display the length (in bytes) of the various picture-less usage types.</source>
          <target state="translated">ここでは、01レベルの定数を使用して、様々なピクチャレスの使用タイプの長さ(バイト数)を表示するGnuCOBOLプログラムのリストを示します。</target>
        </trans-unit>
        <trans-unit id="73247c417733995d371c239937b20d07507d4db9" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy &lt;code&gt;CONTROLS ARE&lt;/code&gt; relates to the&lt;code&gt;SORT&lt;/code&gt;</source>
          <target state="translated">これは、レポートを作成するプログラムです。データがどのようにソートされるか、および制御階層 &lt;code&gt;CONTROLS ARE&lt;/code&gt; が &lt;code&gt;SORT&lt;/code&gt; にどのように関係するかに注意してください</target>
        </trans-unit>
        <trans-unit id="e5a81b08e879fde5dd2a59dae3f46849e9f50742" translate="yes" xml:space="preserve">
          <source>Here we see that PROG2 is nested inside of PROG1 because there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating them. This means that data items or files defined within PROG1 can be used within PROG2 simply by attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in PROG1 when they are defined.</source>
          <target state="translated">ここでは、PROG2がPROG1内にネストされていることがわかります。これは、それらを分離する &lt;code&gt;END PROGRAM&lt;/code&gt; マーカーがないためです。つまり、PROG1内で定義されたデータ項目またはファイルは、定義されたときにPROG1で &lt;code&gt;GLOBAL&lt;/code&gt; （&lt;a href=&quot;#GLOBAL&quot;&gt;GLOBALを&lt;/a&gt;参照）属性をアタッチするだけで、PROG2内で使用できます。</target>
        </trans-unit>
        <trans-unit id="9e665b8afaa854f3affd19ae081739fadefc957c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a demonstration:</source>
          <target state="translated">ここにデモンストレーションがあります：</target>
        </trans-unit>
        <trans-unit id="1bb3a890739a2d89878b41828136b7843797b0c4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a more practical view of the difference. Let&amp;rsquo;s say that a table has 1,000 entries in it. With a sequential search, on average, you&amp;rsquo;ll have to check 500 of them to find an entry and you&amp;rsquo;ll have to look at all 1,000 of them to find that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">違いのより実用的なビューを次に示します。テーブルに1,000のエントリがあるとします。順次検索では、平均して、500個をチェックしてエントリを見つける必要があり、1,000個すべてを調べてエントリが存在しないことを見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="5e93bdc7d9e913c109cf4064444cedee83b88ddb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample of a GnuCOBOL program that CALLs a C subprogram.</source>
          <target state="translated">以下は、Cサブプログラムを呼び出すGnuCOBOLプログラムのサンプルです。</target>
        </trans-unit>
        <trans-unit id="bce0f5ae6fe98feb4beb66b9de11f14f54d3934d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small example:</source>
          <target state="translated">ここに小さな例があります：</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b4f96988044521adc26ab35ce61bb5f09db1123c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the output of the compilation process as well as the program&amp;rsquo;s execution. The example assumes a Windows system with a GnuCOBOL build that uses the GNU C compiler on that system; the technique works equally well regardless of which C compiler and which operating system you&amp;rsquo;re using.</source>
          <target state="translated">これは、コンパイルプロセスの出力とプログラムの実行です。この例では、システムでGNU Cコンパイラを使用するGnuCOBOLビルドを備えたWindowsシステムを想定しています。この手法は、使用しているCコンパイラやオペレーティングシステムに関係なく、同じように機能します。</target>
        </trans-unit>
        <trans-unit id="411f51a5654b397be9062ca82d9069ac5e760156" translate="yes" xml:space="preserve">
          <source>Hexadecimal Alphanumeric Literal</source>
          <target state="translated">16進数英数字リテラル</target>
        </trans-unit>
        <trans-unit id="0622237faae035a0d62bd2b8400c09913d5beb12" translate="yes" xml:space="preserve">
          <source>Hexadecimal Numeric Literal</source>
          <target state="translated">16進数数値リテラル</target>
        </trans-unit>
        <trans-unit id="9b5d84e4c523dc629848bb4349e680f8bf34c64b" translate="yes" xml:space="preserve">
          <source>Hexadecimal numeric literals</source>
          <target state="translated">16進数リテラル</target>
        </trans-unit>
        <trans-unit id="fc83f87e3f62574b840ab2334e64d62930fb1c3c" translate="yes" xml:space="preserve">
          <source>Historically in the early 60&amp;rsquo;s programs were first punched on to paper tape and by the mid 60&amp;rsquo;s that was replaced almost totally, by punched cards although paper tape was still used by programmers for the odd few changes to their sources held on magnetic tape or disk as a portable paper tape punch could be put in your pocket. Now the problem with punched cards were there was 2,000 cards per box and that they could and did, get dropped. So, cc (column) 1 through 6 had the card sequence number in and that way if a box was dropped they could be feed in to a card sorter to be fixed. This was after the cards was cleaned up so that they were all in the same direction which one corner cut out helped.</source>
          <target state="translated">歴史的に、60年代前半のプログラムは最初に紙テープにパンチされ、60代半ばまでにほぼ完全に置き換えられました。紙テープは、磁気テープまたはディスクに保持されているソースへの奇妙な少数の変更のためにプログラマーによってまだ使用されていました。携帯用の紙テープパンチをポケットに入れられます。現在、パンチされたカードの問題は、ボックスごとに2,000枚のカードがあり、それらがドロップできることでした。したがって、cc（列）1から6にはカードのシーケンス番号があり、ボックスがドロップされた場合、カードソーターにフィードして修正することができます。これは、カードが片付けられ、1つの角が切り取られて同じ方向になるようにカードがクリーンアップされた後です。</target>
        </trans-unit>
        <trans-unit id="82581b08d1abc17171e1f2f9cf9815374d6d8df7" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to it&amp;rsquo;s proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">歴史的に、パンチカードを使用してCOBOLプログラムソースをCOBOLコンパイラーに送信した時代には、COBOLステートメントのこの部分は6桁のシーケンス番号用に予約されていました。この領域の内容はCOBOLコンパイラーによって無視されますが、カードデッキが床に落とされた場合に実際に80文字のカードをパンチするプログラムがカードソーターマシンを介して実行され、適切なシーケンスに復元されるように存在していました。 。もちろん、これは今日必要ではありません。本当のことを言えば、それは長い間必要ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="dbfbb76720b9c478938cb351772ad799b84f9efe" translate="yes" xml:space="preserve">
          <source>I also ran the tests multiple times, just to make sure I had consistent results (I did). Like I mentioned earlier, this is not a rigorous, scientific benchmark of numeric performance; it&amp;rsquo;s just a quick-and-dirty comparison.</source>
          <target state="translated">また、一貫した結果が得られたことを確認するために、テストを複数回実行しました（そうしました）。前に述べたように、これは数値パフォーマンスの厳密で科学的なベンチマークではありません。これは、簡単な比較です。</target>
        </trans-unit>
        <trans-unit id="555eb23964b638ebb4898ef46762a788413b2a7a" translate="yes" xml:space="preserve">
          <source>I always include a numeric prefix to all procedure names I define, for the reasons stated earlier.</source>
          <target state="translated">前述の理由から、私は定義するすべてのプロシージャ名には常に数字の接頭辞を付けています。</target>
        </trans-unit>
        <trans-unit id="df6a4fe99929dd991e0202127b86aa20cecf96af" translate="yes" xml:space="preserve">
          <source>I changed the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause on the sample program from this:</source>
          <target state="translated">サンプルプログラムの &lt;code&gt;CONTROLS ARE&lt;/code&gt; 句を次のように変更しました。</target>
        </trans-unit>
        <trans-unit id="8d7255df40c7e6bd55c76738ac87c79c48b55013" translate="yes" xml:space="preserve">
          <source>I do not use&lt;code&gt;THRU&lt;/code&gt;on any&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt;or&lt;code&gt;SORT&lt;/code&gt;statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">私が作業しているショップのプログラミング標準で &lt;code&gt;THRU&lt;/code&gt; が要求されない限り、 &lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; または &lt;code&gt;SORT&lt;/code&gt; ステートメントでTHRUを使用しません。これについての私の推論は、誤って &lt;code&gt;THRU&lt;/code&gt; のスコープに新しい手順を導入するのは簡単すぎるためです。</target>
        </trans-unit>
        <trans-unit id="1fbc97a4457717dc23d1ecc1bf25f471eabb9c4f" translate="yes" xml:space="preserve">
          <source>I like to use procedure division paragraphs and sections as follows:</source>
          <target state="translated">私は、以下のような手順分割パラグラフやセクションを使うのが好きです。</target>
        </trans-unit>
        <trans-unit id="80ed72858cef207934e285ac054f1c8a269fc88f" translate="yes" xml:space="preserve">
          <source>I-O status &quot;1x&quot;</source>
          <target state="translated">I-O ステータス &quot;1x&quot;</target>
        </trans-unit>
        <trans-unit id="e7876f32dd29146c722eec80cdba831c36ef9026" translate="yes" xml:space="preserve">
          <source>I-O status &quot;2x&quot;</source>
          <target state="translated">I-O ステータス &quot;2x&quot;</target>
        </trans-unit>
        <trans-unit id="76b397e0ec9019d1f6c9d9402f9be35add987c62" translate="yes" xml:space="preserve">
          <source>I-O status &quot;3x&quot;</source>
          <target state="translated">I-O ステータス &quot;3x&quot;</target>
        </trans-unit>
        <trans-unit id="6eff1612faad7c99ae78ea1e6080ebc0dc3c4df1" translate="yes" xml:space="preserve">
          <source>I-O status &quot;4x&quot;</source>
          <target state="translated">I-O ステータス &quot;4x&quot;</target>
        </trans-unit>
        <trans-unit id="67e793587f319a335dc7c63a71a23c530563d185" translate="yes" xml:space="preserve">
          <source>I-O status &quot;5x&quot;</source>
          <target state="translated">I-Oステータス &quot;5倍&quot;</target>
        </trans-unit>
        <trans-unit id="b8524f001cba70110ae60dee01287daded416b11" translate="yes" xml:space="preserve">
          <source>I-O status &quot;6x&quot;</source>
          <target state="translated">I-O ステータス &quot;6x&quot;</target>
        </trans-unit>
        <trans-unit id="be335b5a5eadd43e4b4e63cf77557e87542095cf" translate="yes" xml:space="preserve">
          <source>I-O status &quot;9x&quot;</source>
          <target state="translated">I-O ステータス &quot;9x&quot;</target>
        </trans-unit>
        <trans-unit id="0f12b2d4b4f8188676296a19fede62525110b1c0" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL MULTIPLE FILE Syntax</source>
          <target state="translated">I-O-CONTROL MULTIPLE FILE 構文</target>
        </trans-unit>
        <trans-unit id="6f75dae5c47d389ce684040629f1e36258a6ce54" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL SAME AREA Syntax</source>
          <target state="translated">I-O-CONTROL SAME AREA 構文</target>
        </trans-unit>
        <trans-unit id="9c32595038680ec5b76e6c8935109525fa67eebc" translate="yes" xml:space="preserve">
          <source>ID, IDENTIFICATION, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INHERITS, INITIAL, INITIALISE, INITIALISED, INITIALIZE, INITIALIZED, INITIATE, INPUT, INPUT-OUTPUT, INSPECT, INSTALLATION, INTEGER, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTERFACE, INTERFACE-ID, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, I-O, I-O-CONTROL, IS</source>
          <target state="translated">id、識別、if、無視、無視、実装、in、index、インデックス、インデックス付き、示す、継承、初期化、初期化、初期化、初期化、初期化、初期化、開始、入力、入出力、検査、インストール、整数、integer、integer-of-boolean、integer-of-date、integer-of-day、integer-of-formatted-date、integer-part、interface、interface-id、interface-id、interface-in、interface-in、in into、intrinsic、invoke、i-o、i-o-control、isです。</target>
        </trans-unit>
        <trans-unit id="9b9c55248e0c5e189619271ca0ded3b5bd005453" translate="yes" xml:space="preserve">
          <source>IDENTIFICATION DIVISION Syntax</source>
          <target state="translated">識別部構文</target>
        </trans-unit>
        <trans-unit id="b825b4511a0db8bbe7c5d10a6be13d4b3f73d3e5" translate="yes" xml:space="preserve">
          <source>IF Syntax</source>
          <target state="translated">IF構文</target>
        </trans-unit>
        <trans-unit id="8a579c7bbbf6cdd11286272217a8b94f74b4f75a" translate="yes" xml:space="preserve">
          <source>INITIALIZE Syntax</source>
          <target state="translated">INITIALIZE 構文</target>
        </trans-unit>
        <trans-unit id="f22feedf7bc3a1ceec5b7c202882c8aa6f0e185d" translate="yes" xml:space="preserve">
          <source>INITIATE Syntax</source>
          <target state="translated">INITIATE 構文</target>
        </trans-unit>
        <trans-unit id="4f5b873e331f2e93c7e38f36475cf57cbfec3d6a" translate="yes" xml:space="preserve">
          <source>INPUT-OUTPUT SECTION Syntax</source>
          <target state="translated">INPUT-OUTPUT SECTION 構文</target>
        </trans-unit>
        <trans-unit id="baa55ae57b9d3c323f03e28edc87f8c479cca623" translate="yes" xml:space="preserve">
          <source>INSPECT Syntax</source>
          <target state="translated">INSPECT 構文</target>
        </trans-unit>
        <trans-unit id="078ab307f07f53957c6ec7a0918c5e4474c21ea5" translate="yes" xml:space="preserve">
          <source>INTEGER Function Syntax</source>
          <target state="translated">INTEGER 関数構文</target>
        </trans-unit>
        <trans-unit id="2c22d504f0b728c455886a880af6cd5a9ad23315" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DATE Function Syntax</source>
          <target state="translated">INTEGER-OF-DATE 関数構文</target>
        </trans-unit>
        <trans-unit id="c56815bbf474260cef47707dfeb34754b39ce7d9" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DAY Function Syntax</source>
          <target state="translated">INTEGER-OF-DAY 関数構文</target>
        </trans-unit>
        <trans-unit id="8690212db49eea2a08db459f36ed19a01dcc1797" translate="yes" xml:space="preserve">
          <source>INTEGER-PART Function Syntax</source>
          <target state="translated">INTEGER-PART 関数構文</target>
        </trans-unit>
        <trans-unit id="b7b5138514830769db3bcc33e44ecf17e41dd72e" translate="yes" xml:space="preserve">
          <source>INVALID KEY Syntax</source>
          <target state="translated">INVALID キー構文</target>
        </trans-unit>
        <trans-unit id="1e0e983b66f7b85304dc35598bdbe112fd3d5cf6" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a&lt;code&gt;JUSTIFIED&lt;/code&gt;(see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">識別されたサブストリングは、識別された順序で各宛先フィールドに移動されます。宛先フィールドに移動された値は、サブストリングの長さが宛先フィールドの長さを超える場合は切り捨てられ、宛先フィールドの長さがサブストリング長を超える場合はスペースが埋め込まれます。切り捨てと埋め込みの両方は、宛先フィールドの &lt;code&gt;JUSTIFIED&lt;/code&gt; （&lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIEDを&lt;/a&gt;参照）句の有無によって制御されます。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="85fdddf7199ca1a02d1e410b6661de3c0d82e8ec" translate="yes" xml:space="preserve">
          <source>If &amp;lt;</source>
          <target state="translated">&amp;lt;の場合</target>
        </trans-unit>
        <trans-unit id="a4c0ae6969ecd1edf278dc7c43adf6ccf840a59b" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">CALL &quot;リテラル &quot;を使用した場合、サブルーチンはコンパイル時に呼び出されたプログラムの位置を特定してリンクすることしかできません。</target>
        </trans-unit>
        <trans-unit id="fb834ae0ee1fee06659da54155901a048c8ab107" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">CALL &quot;リテラル &quot;を使用した場合、コンパイル時にサブルーチンは呼び出し元のプログラムとリンクして配置されますが、コンパイラのスイッチ設定やオペレーティングシステムの機能に応じて、実行時に動的に配置されてロードされることもあります。</target>
        </trans-unit>
        <trans-unit id="1c0a19ff2f39be755da80b6e4db03b3261af8ab0" translate="yes" xml:space="preserve">
          <source>If COB_SET_TRACE is set to Y, then tracing will always occur regardless of the presence of READY TRACE or RESET TRACE so in effect they will have no action on program execution.</source>
          <target state="translated">COB_SET_TRACEがYに設定されている場合、READY TRACEやRESET TRACEの存在に関わらず、トレースは常に発生するので、事実上、これらはプログラムの実行には何の影響も与えない。</target>
        </trans-unit>
        <trans-unit id="fca0edd85d905b4998e39dbc0abfe08d59abf9e2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE LAST OFF.&lt;/code&gt;will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a&lt;code&gt;REPLACE OFF.&lt;/code&gt;had been coded.</source>
          <target state="translated">置換モードが現在アクティブな場合、 &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 現在の置換仕様をスタックの最上部からポップされたものに置き換えます。スタックに置換仕様がない場合、効果は &lt;code&gt;REPLACE OFF.&lt;/code&gt; コーディングされていました。</target>
        </trans-unit>
        <trans-unit id="3aa454bf040b4488335636d3825b242cd96c6894" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE OFF.&lt;/code&gt;will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no&lt;code&gt;REPLACE&lt;/code&gt;had ever been encountered, until such time as another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered.</source>
          <target state="translated">置換モードが現在アクティブな場合、 &lt;code&gt;REPLACE OFF.&lt;/code&gt; 置換モードを非アクティブにし、スタック上の置換仕様を破棄します。以降、コンパイラーは、別のFormat 1 &lt;code&gt;REPLACE&lt;/code&gt; が検出されるまで、 &lt;code&gt;REPLACE&lt;/code&gt; が検出されなかったかのように動作します。</target>
        </trans-unit>
        <trans-unit id="f9f8b4a7fa7d08d0000f216b49dbe0fdb7aba40b" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 REPLACE statement will be ignored.</source>
          <target state="translated">置換モードが現在アクティブでない場合、フォーマット2 REPLACE文は無視されます。</target>
        </trans-unit>
        <trans-unit id="02d270f35c2331a3f0b66309eedab53f64314826" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="eab9e954d4363fe95501767a50e10db235e4192f" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc1c32024a481de06916a31d66dbe9f8f79db74e" translate="yes" xml:space="preserve">
          <source>If a &amp;rsquo;</source>
          <target state="translated">もし '</target>
        </trans-unit>
        <trans-unit id="edb4a54100b677ae4d121fffad6d12711ca6c737" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the&lt;code&gt;CANCEL&lt;/code&gt;statement is subsequently re-executed, all data division storage for that module will once again be in it&amp;rsquo;s initial state.</source>
          <target state="translated">&lt;code&gt;CANCEL&lt;/code&gt; ステートメントによってアンロードされた動的にロード可能なモジュールがその後再実行されると、そのモジュールのすべてのデータ分割ストレージは再び初期状態になります。</target>
        </trans-unit>
        <trans-unit id="df6f3afc62331cf6c1dea91965aa4ef057173188" translate="yes" xml:space="preserve">
          <source>If a numeric literal or&lt;code&gt;PIC 9&lt;/code&gt;identifier is specified as an argument, decimal points, if any, will be removed and negative signs in&lt;code&gt;PIC S9&lt;/code&gt;fields or numeric literals will be inserted as defined by the&lt;code&gt;SIGN IS&lt;/code&gt;(see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if&lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt;were in effect.</source>
          <target state="translated">数値リテラルまたは &lt;code&gt;PIC 9&lt;/code&gt; 識別子が引数として指定されている場合、小数点があれば削除され、 &lt;code&gt;PIC S9&lt;/code&gt; フィールドまたは数値リテラルの負符号が &lt;code&gt;SIGN IS&lt;/code&gt; （&lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN ISを&lt;/a&gt;参照）句の定義に従って挿入されます（またはフィールドの不在）。数値リテラルは、 &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; が有効であるかのように処理されます。</target>
        </trans-unit>
        <trans-unit id="57490b79cb430dd4450134ac2677f6cf11e26604" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will be assumed.</source>
          <target state="translated">レポートデータ項目の記述が含まれている場合は &lt;code&gt;SOURCE&lt;/code&gt; （参照&lt;a href=&quot;#SOURCE&quot;&gt;ソース&lt;/a&gt;）、 &lt;code&gt;SUM&lt;/code&gt; は、（参照&lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;又は） &lt;code&gt;VALUE&lt;/code&gt; （参照&lt;a href=&quot;#VALUE&quot;&gt;値&lt;/a&gt;）句が、全く持っていない &lt;code&gt;COLUMN&lt;/code&gt; の句、 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 仮定されます。</target>
        </trans-unit>
        <trans-unit id="71da1ffb9548582f3fa4c8e682811f42638458f2" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &quot;current screen line&quot; will be assumed.</source>
          <target state="translated">画面データ項目の記述が含まれている場合 &lt;code&gt;FROM&lt;/code&gt; （参照&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）、 &lt;code&gt;TO&lt;/code&gt; （参照&lt;a href=&quot;#TO&quot;&gt;TOを&lt;/a&gt;）、 &lt;code&gt;USING&lt;/code&gt; （参照&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）または &lt;code&gt;VALUE&lt;/code&gt; （参照&lt;a href=&quot;#VALUE&quot;&gt;値&lt;/a&gt;）句が、全くLINE句を持っていない、「現在のスクリーン線」が仮定されます。</target>
        </trans-unit>
        <trans-unit id="48d3ea6a5c04f441a3bbe9ad4aa57d07cef44e81" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">画面データ項目の記述が含まれている場合 &lt;code&gt;FROM&lt;/code&gt; （参照&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）、 &lt;code&gt;TO&lt;/code&gt; （参照&lt;a href=&quot;#TO&quot;&gt;TOを&lt;/a&gt;）、 &lt;code&gt;USING&lt;/code&gt; （参照&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）または &lt;code&gt;VALUE&lt;/code&gt; （参照&lt;a href=&quot;#VALUE&quot;&gt;値&lt;/a&gt;）句が、全く持っていない &lt;code&gt;COLUMN&lt;/code&gt; の句を、新たなスクリーン・フィールドは、座標列で開始します前のフィールドの最後の文字。</target>
        </trans-unit>
        <trans-unit id="1ecf4f102cec092a989e853dbb05716d18d10735" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a&lt;code&gt;USING&lt;/code&gt;clause specified on it&amp;rsquo;s procedure division header.</source>
          <target state="translated">サブプログラムが引数を期待しない場合は、その手続き部ヘッダーに &lt;code&gt;USING&lt;/code&gt; 句を指定しないでください。</target>
        </trans-unit>
        <trans-unit id="92b7f84efc871dae3988a9b29ad470f6b8703091" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;CONVERTING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONVERTING&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="2032d4dadae8be3fe061169d553c0926d6a379ee" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;DEFAULT&lt;/code&gt;clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 句が指定されている場合、フィールドリストの初期化されていない残りのメンバーは、そのクラスのデフォルトに従って初期化されます（数値および数値編集はゼロに初期化され、その他はすべてSPACESに初期化されます）。</target>
        </trans-unit>
        <trans-unit id="7156dc318e4e3f5aa0881e3dc01f136733e5ac30" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">場合は &lt;code&gt;GO TO&lt;/code&gt; はの範囲内で実行されます...</target>
        </trans-unit>
        <trans-unit id="e12db606ad57abcf661cf0d99d8020cc167d9db0" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;LINAGE&lt;/code&gt;clause is also specified, Values specified for&lt;code&gt;LINAGE IS&lt;/code&gt;and&lt;code&gt;FOOTING AT&lt;/code&gt;will be ignored. The values of&lt;code&gt;LINES AT BOTTOM&lt;/code&gt;and&lt;code&gt;LINES AT TOP&lt;/code&gt; if any, will be honoured.</source>
          <target state="translated">&lt;code&gt;LINAGE&lt;/code&gt; 句も指定されている場合、LINAGE &lt;code&gt;LINAGE IS&lt;/code&gt; および &lt;code&gt;FOOTING AT&lt;/code&gt; に指定された値は無視されます。 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; および &lt;code&gt;LINES AT TOP&lt;/code&gt; があれば、その値が優先されます。</target>
        </trans-unit>
        <trans-unit id="b64062bb86b4cc026b65a0da4120142c176e5547" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REMAINDER&lt;/code&gt;clause is specified, the value of the one and only &amp;lt;</source>
          <target state="translated">&lt;code&gt;REMAINDER&lt;/code&gt; 句が指定されている場合、唯一の&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c8a9ba4a49154db62b70c94627e9f9a09a50f6f3" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REPLACING&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list that was not already initialized by a&lt;code&gt;VALUE&lt;/code&gt;clause, if any, will be initialized to the specified &amp;lt;</source>
          <target state="translated">場合 &lt;code&gt;REPLACING&lt;/code&gt; 句が指定されている上 &lt;code&gt;INITIALIZE&lt;/code&gt; 文で、すでにによって初期化されなかったフィールドリストの各予選メンバー &lt;code&gt;VALUE&lt;/code&gt; の句は、もしあれば、指定に初期化されます&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5b838d7717f95d20a08cd03498f7882a18db7072" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;TALLYING&lt;/code&gt;clause is coded, &amp;lt;</source>
          <target state="translated">場合は &lt;code&gt;TALLYING&lt;/code&gt; 句がコード化され、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="42850d1581077257d5fcf6cbd3d76feb45a57582" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;.</source>
          <target state="translated">場合 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; （参照&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVESの&lt;/a&gt;）部分が存在し、この環境変数が「Y」、「Y」または「1」の値に設定されていない限り、その中のコードは無効になります。</target>
        </trans-unit>
        <trans-unit id="936f63734566944fcd01e49ee30a1e66bbeaea72" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;VALUE&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list having a compile-time&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in it&amp;rsquo;s definition will be initialized to that value. Field list members with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify for this treatment as follows:</source>
          <target state="translated">&lt;code&gt;INITIALIZE&lt;/code&gt; ステートメントで &lt;code&gt;VALUE&lt;/code&gt; 句が指定されている場合、その定義でコンパイル時の &lt;code&gt;VALUE&lt;/code&gt; （&lt;a href=&quot;#VALUE&quot;&gt;VALUEを&lt;/a&gt;参照）が指定されているフィールドリストの各修飾メンバーは、その値に初期化されます。 &lt;code&gt;VALUE&lt;/code&gt; 句を含むフィールドリストメンバーは、次のようにこの処理の対象となります。</target>
        </trans-unit>
        <trans-unit id="bbb21152f55feeb2156f854427c62c771c0ef692" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;</source>
          <target state="translated">すべて&amp;lt;</target>
        </trans-unit>
        <trans-unit id="82152df9872b03795b0f65167d26e2e94749c462" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.</source>
          <target state="translated">引数識別子の格納サイズが、その中に格納されるトークン値よりも小さい場合、トークン値の右端の余剰文字は、その値が移動される際に切り捨てられます。そのような引数識別子に対するJUSTIFIED RIGHT句は無視されます。</target>
        </trans-unit>
        <trans-unit id="bccb47600312a31302d4243c123c27cac5d4e303" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with &quot;0&quot; characters from the systems native character set.</source>
          <target state="translated">引数のサイズがトークン値よりも大きい場合、トークン値は左寄せの方法で引数の識別子に移動します。</target>
        </trans-unit>
        <trans-unit id="14f8fa4ce97209c48ec71484cb50b99ef2bd0709" translate="yes" xml:space="preserve">
          <source>If an argument lacks a&lt;code&gt;BY&lt;/code&gt;clause, the most-recently encountered&lt;code&gt;BY&lt;/code&gt;specification on that&lt;code&gt;CALL&lt;/code&gt;statement will be assumed. If the first argument specified on a&lt;code&gt;CALL&lt;/code&gt;lacks a&lt;code&gt;BY&lt;/code&gt;clause,&lt;code&gt;BY REFERENCE&lt;/code&gt;will be assumed.</source>
          <target state="translated">引数に &lt;code&gt;BY&lt;/code&gt; 句がない場合、その &lt;code&gt;CALL&lt;/code&gt; ステートメントで最後に検出された &lt;code&gt;BY&lt;/code&gt; 指定が想定されます。 &lt;code&gt;CALL&lt;/code&gt; で指定された最初の引数に &lt;code&gt;BY&lt;/code&gt; 句がない場合、 &lt;code&gt;BY REFERENCE&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="05823b59c6e317b0d6f6bda99166cee75a4f73b6" translate="yes" xml:space="preserve">
          <source>If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.</source>
          <target state="translated">値が 1 より小さいか 256 より大きい引数が指定された場合、すべての 0 ビットの値に対応するプログラム照合順序の文字を返す。</target>
        </trans-unit>
        <trans-unit id="2b8c1834ab8abb452a19e34dee7da8437a78703c" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, it&amp;rsquo;s value will serve as the path and filename to the data file.</source>
          <target state="translated">環境変数が見つかった場合、その値はデータファイルへのパスとファイル名として機能します。</target>
        </trans-unit>
        <trans-unit id="bcab58a3e462d384fa130cd4e9016e959b6a71b4" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;ASSIGN&lt;/code&gt;clause is coded without a &amp;lt;&amp;lt;</source>
          <target state="translated">&lt;code&gt;ASSIGN&lt;/code&gt; 句が&amp;lt;&amp;lt;なしでコーディングされている場合</target>
        </trans-unit>
        <trans-unit id="c44efa18b320631b1a96a201bad730ca80153f8d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides</source>
          <target state="translated">もし &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 文または &lt;code&gt;EXIT SECTION&lt;/code&gt; ステートメント常駐</target>
        </trans-unit>
        <trans-unit id="87612bdd6bb75a44b81526c8c27d9968de497f3d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides in a paragraph</source>
          <target state="translated">場合は &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 文または &lt;code&gt;EXIT SECTION&lt;/code&gt; の文は段落内に存在します</target>
        </trans-unit>
        <trans-unit id="3f0242e3af04c028a1ddce44867fb3964faf61b9" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;INITIATE&lt;/code&gt;is followed by a&lt;code&gt;TERMINATE&lt;/code&gt;with no intervening&lt;code&gt;GENERATE&lt;/code&gt;(see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">場合 &lt;code&gt;INITIATE&lt;/code&gt; が続いている &lt;code&gt;TERMINATE&lt;/code&gt; ない介在なしで &lt;code&gt;GENERATE&lt;/code&gt; （参照&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）文（すべてもちろん、同じレポートに関連する）、何のレポートグループは、出力ファイルに提示されません。</target>
        </trans-unit>
        <trans-unit id="1989e1692cf63856050ee6de069649854e1b7eed" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;</source>
          <target state="translated">&amp;lt;がある場合</target>
        </trans-unit>
        <trans-unit id="ded48aebbdbbf018e482c90608c9d4d54578f860" translate="yes" xml:space="preserve">
          <source>If any of the paragraphs within one of the sections are coded, the section header itself must be coded.</source>
          <target state="translated">セクション内のいずれかの段落がコード化されている場合は、セクションヘッダー自体がコード化されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="098c66a7cc7db43fe1a5e65ab50d6051cee41a88" translate="yes" xml:space="preserve">
          <source>If at least one&lt;code&gt;GENERATE&lt;/code&gt;statement of this form is executed against a report, the report is said to be a &amp;rsquo;</source>
          <target state="translated">このフォームの少なくとも1つの &lt;code&gt;GENERATE&lt;/code&gt; ステートメントがレポートに対して実行された場合、レポートは「</target>
        </trans-unit>
        <trans-unit id="bbb1f438e0e2ddccdd230dea44836bc244c52259" translate="yes" xml:space="preserve">
          <source>If both optional sections of this division are coded, they must be coded in the sequence shown.</source>
          <target state="translated">この分割の両方のオプションセクションが符号化されている場合、それらは示された順序で符号化されなければならない。</target>
        </trans-unit>
        <trans-unit id="e41dfd24c49449dc06a287d66915bfb31196edfa" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">両方のステートメントタイプが &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落でコーディングされている場合、それらのステートメントがコーディングされている順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="776f3c5eecbcd34d511d3925b8b352f3fe294871" translate="yes" xml:space="preserve">
          <source>If both the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">&lt;code&gt;TALLYING&lt;/code&gt; 句と &lt;code&gt;REPLACING&lt;/code&gt; 句の両方を指定する場合は、示されている順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="49551f9075c0114086955d559a1442bce3fdaf10" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">実行の制御がステートメントで指定されたプロシージャに移され、 &lt;code&gt;GO TO&lt;/code&gt; が&amp;hellip;のスコープ内で実行された場合</target>
        </trans-unit>
        <trans-unit id="25bbb2134d570b993f324faa68838566a3259e83" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are NOT stored in the same directory as your program, set this environment variable to the folder in which the copybooks may be found (IBM mainframe programmers will recognize this as &quot;SYSLIB&quot;).</source>
          <target state="translated">プログラムが必要とするコピーブックがプログラムと同じディレクトリに保存されていない場合、この環境変数をコピーブックが見つかる可能性のあるフォルダに設定します(IBMメインフレームのプログラマーはこれを &quot;SYSLIB &quot;と認識します)。</target>
        </trans-unit>
        <trans-unit id="325de08baac6d6bd1b4e1ebed585b6caa542bf6a" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &quot;secure&quot; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">必要に応じて、入力フィールドとして使用される画面フィールドを「セキュア」フィールドとして定義することができ、入力された各文字は(実際に入力されたかどうかにかかわらず)アスタリスク(*)文字として表示されます。しかし、キーが押された実際の文字は、プログラムのフィールドに保存されます。これは、パスワードやアカウント番号のフィールドに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="e8c0e23858d8c34351be31b2e2dd7ef0f308a47c" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the&lt;code&gt;.&lt;/code&gt;and&lt;code&gt;,&lt;/code&gt;editing symbols by specifying&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">必要に応じて、の役割を逆にすることができます &lt;code&gt;.&lt;/code&gt; そして &lt;code&gt;,&lt;/code&gt; 指定してシンボルを編集 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; をして &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （参照&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;段落を）。</target>
        </trans-unit>
        <trans-unit id="cfeb571780980c15ef5118f06fd533dfd406e005" translate="yes" xml:space="preserve">
          <source>If either condition has a value of TRUE, the result of&lt;code&gt;OR&lt;/code&gt;</source>
          <target state="translated">いずれかの条件の値がTRUEの場合、 &lt;code&gt;OR&lt;/code&gt; の結果</target>
        </trans-unit>
        <trans-unit id="bc1c6b979e9c37d992caa4fdb32b5bbe5b97b0db" translate="yes" xml:space="preserve">
          <source>If either the&lt;code&gt;TALLYING&lt;/code&gt;or&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, the&lt;code&gt;CONVERTING&lt;/code&gt;clause cannot be used.</source>
          <target state="translated">&lt;code&gt;TALLYING&lt;/code&gt; 句または &lt;code&gt;REPLACING&lt;/code&gt; 句のいずれかが指定されている場合、 &lt;code&gt;CONVERTING&lt;/code&gt; 句は使用できません。</target>
        </trans-unit>
        <trans-unit id="65d896699ba7417f38fac49a744a6351011f2338" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, &amp;lt;</source>
          <target state="translated">イベント（A）が発生した場合、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c6ea8276245b74726b44312b8cbb459b9ea45f59" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, none of the destination field contents (or the contents of their&lt;code&gt;DELIMITER&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">イベント（A）が発生した場合、宛先フィールドの内容（またはそれらの &lt;code&gt;DELIMITER&lt;/code&gt; または&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c766138e5b6a0fb5e159fe3be6df3cb65c15aa94" translate="yes" xml:space="preserve">
          <source>If excess space is allocated, the returned value will be padded with spaces (to the right).</source>
          <target state="translated">余剰スペースが確保されている場合は、返された値はスペース(右側)でパディングされます。</target>
        </trans-unit>
        <trans-unit id="dcf599fa35195bfeb7d750a1aa7ddb9854348d4d" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statements will take any action.</source>
          <target state="translated">メインプログラムによって実行される場合、 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; ステートメントも &lt;code&gt;EXIT FUNCTION&lt;/code&gt; ステートメントもアクションを実行しません。</target>
        </trans-unit>
        <trans-unit id="adc22a801c0d5cf9afd2251ba837acc24c7e7595" translate="yes" xml:space="preserve">
          <source>If executed within a main program,&lt;code&gt;GOBACK&lt;/code&gt;will act as a&lt;code&gt;STOP RUN&lt;/code&gt;statement.</source>
          <target state="translated">メインプログラム内で実行される場合、 &lt;code&gt;GOBACK&lt;/code&gt; は &lt;code&gt;STOP RUN&lt;/code&gt; ステートメントとして機能します。</target>
        </trans-unit>
        <trans-unit id="0c913e686677f4f2542ed04551fc54a61ca3b586" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function),&lt;code&gt;GOBACK&lt;/code&gt;behaves like an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;or&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement, respectively.</source>
          <target state="translated">サブプログラム（つまり、サブルーチンまたはユーザー定義関数）内で実行される場合、 &lt;code&gt;GOBACK&lt;/code&gt; はそれぞれ &lt;code&gt;EXIT PROGRAM&lt;/code&gt; または &lt;code&gt;EXIT FUNCTION&lt;/code&gt; ステートメントのように動作します。</target>
        </trans-unit>
        <trans-unit id="37a5ec4ba4f6eb14fb6bc4cdf6c2b834a2e18251" translate="yes" xml:space="preserve">
          <source>If insufficient space is allocated, the returned value will be truncated.</source>
          <target state="translated">空き容量が不足している場合は切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="20788d6df5c521759ffd6da038d7efacbc53537c" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;C&quot;, the value will be centred</source>
          <target state="translated">大文字の「C」で始まる場合は、値が中心になります。</target>
        </trans-unit>
        <trans-unit id="cce45705eb2edf3ee981ccb8a02325faa9873b7a" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;L&quot;, the value will be left-justified, space-filled to the right</source>
          <target state="translated">大文字の &quot;L &quot;で始まる場合、値は左寄せになり、右にスペースを空けて表示されます。</target>
        </trans-unit>
        <trans-unit id="49095cec719464061ddd1eea1650a1e60b0b3522" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;R&quot;, the value will be right-justified, space-filled to the left</source>
          <target state="translated">大文字の &quot;R &quot;で始まる場合、値は右寄せで左にスペースを空けて表示されます。</target>
        </trans-unit>
        <trans-unit id="e6e9d41a84edd6ab6b611b8a64b21d8cc9efa7ef" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &quot;R&quot;</source>
          <target state="translated">他の何かで始まる場合や、それがない場合は、それが存在し、大文字の &quot;R &quot;で始まる場合と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="ddfddaec4eb6defafd4236c3804acb2833a56ffc" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">動的サブルーチンの場合、GnuCOBOLランタイムシステムは、サブプログラムのエントリポイントを含む動的にロード可能なモジュールがすでに配置されているかどうかを確認します。もしそうなら、それ以上の「場所」アクティビティは必要ありません。そうでない場合は、動的にロード可能なモジュールが検索されます（動的にロード可能なモジュールの&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;検索を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a084bcee5f6f297e9fac72fc57197692e67653da" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">動的なユーザー定義関数の場合、GnuCOBOLランタイムシステムは、関数のエントリポイントを含む動的にロード可能なモジュールが既に配置されているかどうかを確認します。そうであれば、それ以上の「場所」アクティビティは必要ありません。そうでない場合は、動的にロード可能なモジュールが検索されます（動的にロード可能なモジュールの&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;検索を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d0f43ca29a675e226a37e6b6d8088cdbc37ebd39" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">静的サブルーチンの場合は、 &lt;code&gt;CALL&lt;/code&gt; を発行する実行可能プログラムの一部になっています（&lt;a href=&quot;#CALL&quot;&gt;CALLを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="caa175b4499a85fc8b3c0efe4a0f73f3d1c1c886" translate="yes" xml:space="preserve">
          <source>If it is a static user-defined function, it will already be part of the executable file containing the calling program.</source>
          <target state="translated">それが静的なユーザー定義関数である場合、それはすでに呼び出し元のプログラムを含む実行ファイルの一部になっています。</target>
        </trans-unit>
        <trans-unit id="84a0f01c66da97418e3aa21d01e0ef5b3ae55060" translate="yes" xml:space="preserve">
          <source>If more than one section is needed in the data division (a common situation), the sections must be coded in the sequence they are presented above.</source>
          <target state="translated">データ分割で複数のセクションが必要な場合(一般的な状況)、セクションは上記で提示された順序でコード化されなければならない。</target>
        </trans-unit>
        <trans-unit id="08575c4d82cf8b371a6f7d53f268979ac88898e9" translate="yes" xml:space="preserve">
          <source>If necessary, &amp;lt;</source>
          <target state="translated">必要に応じて、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f63584104f0c3fb031bde71d0b6dcee112c103e0" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">どちらの段落もコーディングされていない場合は、 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; ヘッダー自体は省略できますが、それ以外の場合は通常必要です。</target>
        </trans-unit>
        <trans-unit id="112a01f52ed19b32bc288508d6054c95da8fdd85" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;</source>
          <target state="translated">ない場合&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c520e3d4aae69229f5d030660491f8d24e39ce90" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;がない場合</target>
        </trans-unit>
        <trans-unit id="cccae1dc6e8637e1b5c5c2fbf5052d3f0ccf07fa" translate="yes" xml:space="preserve">
          <source>If no &amp;rsquo;</source>
          <target state="translated">いいえの場合</target>
        </trans-unit>
        <trans-unit id="80ec6de7e7c7e7960f42ef9bf764d5e364ff0ae6" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">データ分割セクションが必要ない場合は、 &lt;code&gt;DATA DIVISION.&lt;/code&gt; ヘッダー自体は省略できます。</target>
        </trans-unit>
        <trans-unit id="e5c8083a19d4bf6b791a2ad3bee37fd9780d046a" translate="yes" xml:space="preserve">
          <source>If no data will be described in one of the data division sections, that section header may be omitted.</source>
          <target state="translated">データ分割部のいずれかにデータを記述しない場合は、その部分のヘッダを省略してもよい。</target>
        </trans-unit>
        <trans-unit id="4ea37cd62fe13ae475efaf0fa631e7d1254a22ce" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the &quot;config&quot; file used to compile the program had a &quot;filename-mapping&quot; value of &quot;no&quot;, then the File Locator String value will serve as the path and filename to the data file.</source>
          <target state="translated">環境変数が見つからなかった場合、またはプログラムをコンパイルするために使用された &quot;config &quot;ファイルの値が &quot;no &quot;であった場合、File Locator Stringの値がデータファイルのパスとファイル名として機能します。</target>
        </trans-unit>
        <trans-unit id="97d63005403252ba6869749f325e5b668c7826c7" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;ADVANCING&lt;/code&gt;clause is specified on a&lt;code&gt;WRITE&lt;/code&gt;to a line-advancing file,&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;will be assumed; on other than line-advancing files,&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;will be assumed.</source>
          <target state="translated">行 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; ファイルへの &lt;code&gt;WRITE&lt;/code&gt; で &lt;code&gt;ADVANCING&lt;/code&gt; 句が指定されていない場合、AFTER ADVANCING 1 LINEが想定されます。行 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; ファイル以外では、BEFORE ADVANCING 1 LINEが想定されます。</target>
        </trans-unit>
        <trans-unit id="6c0dd54af0bcfe6aba553419a7f8fa41175966da" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;AFTER&lt;/code&gt;is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; を指定しない場合、対象範囲の最初の文字位置は検査対象の文字位置＃1になります。</target>
        </trans-unit>
        <trans-unit id="15393df0a9af6eb90b29b75caf239e68d67158ac" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;BEFORE&lt;/code&gt;is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">&lt;code&gt;BEFORE&lt;/code&gt; を指定しない場合、ターゲット範囲の最後の文字位置が検査対象の最後の文字位置になります。</target>
        </trans-unit>
        <trans-unit id="1a0d2b27d4ce9b801ffdc741e7e7060c7a514405" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 句が指定されていない場合、コンピューターに固有の文字セット（通常はASCII）によって暗黙指定された照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="938ef54a5b2f3a79dc5e586019fcecd25b200f27" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FIRST&lt;/code&gt;&lt;code&gt;LAST&lt;/code&gt;or&lt;code&gt;KEY&lt;/code&gt;clause is specified,&lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt;will be assumed, where &quot;xxx&quot; is the defined&lt;code&gt;RELATIVE KEY&lt;/code&gt;of (if &amp;lt;</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; &lt;code&gt;LAST&lt;/code&gt; または &lt;code&gt;KEY&lt;/code&gt; 句が指定されていない場合、 &lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt; が想定されます。ここで、「xxx」は、定義された &lt;code&gt;RELATIVE KEY&lt;/code&gt; です（&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3c134ddd26a13c987732536178ffc2d3596e0cc0" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FROM&lt;/code&gt;clause is specified,&lt;code&gt;FROM CONSOLE&lt;/code&gt;is assumed.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句が指定されていない場合、 &lt;code&gt;FROM CONSOLE&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="a936605766c63b6943b34a949cbfd95d11891a47" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">いいえの場合 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 句が指定されていない、それは、単一の任意の長さのページで構成されているかのように、全体のレポートが生成されます。</target>
        </trans-unit>
        <trans-unit id="8df6bcbeab6aa11894e4fe7cbd9a91d3d00317e5" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;UPON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; がない場合</target>
        </trans-unit>
        <trans-unit id="fe6ea8dfb325db99c6308c46b06bda141821bb43" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; がない場合</target>
        </trans-unit>
        <trans-unit id="acc316a6b22ed428d8859027514f370adf001d62" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire&lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt;header may be omitted from the program.</source>
          <target state="translated">構成セクションで提供される機能のいずれもプログラムで必要とされない場合は、 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 全体。ヘッダーはプログラムから省略できます。</target>
        </trans-unit>
        <trans-unit id="38302bf8e20435daf87449711673f45dc0fc7efa" translate="yes" xml:space="preserve">
          <source>If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.</source>
          <target state="translated">1つのセクション内のいずれの段落もコード化されていない場合は、セクションヘッダー自体を省略してもよい。</target>
        </trans-unit>
        <trans-unit id="c20690aa244c08791983cf1b27135cf3c295161b" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">データ部内のどのセクションもコーディングされていない場合（非常にありそうもないが、理論的には可能な状況）、 &lt;code&gt;DATA DIVISION.&lt;/code&gt; ヘッダー自体は省略できます。</target>
        </trans-unit>
        <trans-unit id="0a6df96501f79aab798f69106ec9e2b97487e708" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the&lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">環境部門内のどのセクションもコーディングされていない場合は、 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; ヘッダー自体は省略できます。</target>
        </trans-unit>
        <trans-unit id="3f3504ace1fcbbfe8785eaf44906c2e8b0fac8ce" translate="yes" xml:space="preserve">
          <source>If references to table elements are going to be performed many, many times (tens or hundreds of thousands of times or more) during program execution, you will probably see a noticeable reduction in program execution time if you use indexing versus subscripting.</source>
          <target state="translated">プログラムの実行中にテーブル要素への参照が何回も何十万回も(何万回、何十万回以上)も実行される場合、添字と添字を比較してインデックスを使用すると、おそらくプログラムの実行時間が大幅に短縮されるでしょう。</target>
        </trans-unit>
        <trans-unit id="8e464aa3baae37e1c17db766f8597a99a293b6e4" translate="yes" xml:space="preserve">
          <source>If references to table elements are not going to be performed many, many times it probably won&amp;rsquo;t make much difference whether you use indexing or subscripting.</source>
          <target state="translated">テーブル要素への参照があまり実行されない場合、インデックス付けと添え字付けのどちらを使用しても、多くの場合、それほど大きな違いはありません。</target>
        </trans-unit>
        <trans-unit id="2d7b2b72b6ddc84fee15212248b1a81b23f1b096" translate="yes" xml:space="preserve">
          <source>If rule (A) is violated, the compiler will reject the&lt;code&gt;SEARCH ALL&lt;/code&gt; If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a&lt;code&gt;SEARCH ALL&lt;/code&gt;against the table will probably be incorrect.</source>
          <target state="translated">ルール（A）が違反した場合、コンパイラは拒否します &lt;code&gt;SEARCH ALL&lt;/code&gt; ルール（B）および/または（C）が違反している場合は、コンパイラによって発行された何のメッセージが、の実行時の結果は存在しません &lt;code&gt;SEARCH ALL&lt;/code&gt; に対してテーブルはおそらく正しくありません。</target>
        </trans-unit>
        <trans-unit id="953965bec96dd86973cb12584b0c3f4d8e27d9dc" translate="yes" xml:space="preserve">
          <source>If set to &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) will physically unload a subprogram dynamically-loadable module.</source>
          <target state="translated">「Y」、「Y」または「1」に設定した場合、 &lt;code&gt;CANCEL&lt;/code&gt; （参照文を&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;物理サブプログラム、動的にロード可能なモジュールをアンロードします）。</target>
        </trans-unit>
        <trans-unit id="e304fe2f130a29229fe3b203d139f3c8d0b1b8a9" translate="yes" xml:space="preserve">
          <source>If set to a value of &quot;Y&quot;, any run-time warnings (such as noting the implicit closing of open files when a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option is executed) will be displayed. Any other value for this environment variable (including not setting the variable at all) will suppress such messages.</source>
          <target state="translated">「Y」の値に設定するには、（例えば、開いているファイルの暗黙の決算に注目として任意の実行時の警告場合 &lt;code&gt;GOBACK&lt;/code&gt; の声明（参照&lt;a href=&quot;#GOBACK&quot;&gt;GOBACKを&lt;/a&gt;）または &lt;code&gt;STOP&lt;/code&gt; の声明（参照&lt;a href=&quot;#STOP&quot;&gt;STOPを&lt;/a&gt;持つ） &lt;code&gt;RUN&lt;/code&gt; のオプションが実行される）が表示されます。この環境変数の他の値（変数をまったく設定しないことを含む）は、そのようなメッセージを抑制します。</target>
        </trans-unit>
        <trans-unit id="2bc077c4c98b87e839493508304c45c1d8484f6d" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &quot;p&quot;, this variable will force a file commit every time a file is written to (ensuring that data is immediately written to the file rather than retained in memory until a future commit occurs). This will slow-down update access to files, but will provide for better integrity in the event of a program failure.</source>
          <target state="translated">大文字または小文字の &quot;p &quot;の値に設定されている場合、この変数は、ファイルが書き込まれるたびにファイルのコミットを強制します(将来のコミットが発生するまでメモリにデータが保持されるのではなく、即座にファイルに書き込まれることを保証します)。これにより、ファイルへの更新アクセスが遅くなりますが、プログラムの障害が発生した場合の整合性を向上させることができます。</target>
        </trans-unit>
        <trans-unit id="1ff6dd80412acb65fea091eeee45227f17f79745" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &quot;Esc&quot; key.</source>
          <target state="translated">空白以外の値に設定すると、この変数により、 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; ステートメント（&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-itemを&lt;/a&gt;参照）が「Esc」キーを検出できるようになります。</target>
        </trans-unit>
        <trans-unit id="02c873d8dea11df102afae708aa8d02b69151e6b" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written.</source>
          <target state="translated">null以外の値に設定した場合、この環境変数は、すべての &lt;code&gt;-ftrace&lt;/code&gt; スイッチと &lt;code&gt;-ftraceall&lt;/code&gt; スイッチの出力が書き込まれるファイルを指定します。</target>
        </trans-unit>
        <trans-unit id="422d3cddd2d7b811c88085d18de9df66cdccb313" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this variable will cause all dynamically-loadable libraries to be loaded when the program begins execution (rather than searching for and loading the module upon first use).</source>
          <target state="translated">NULLではない値に設定されている場合、この変数はプログラムの実行開始時にすべての動的にロード可能なライブラリをロードします (最初の使用時にモジュールを検索してロードするのではなく)。</target>
        </trans-unit>
        <trans-unit id="d8aab5d7cf6334fa7d1d64a36e03690790d2311f" translate="yes" xml:space="preserve">
          <source>If set to anything else, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) logically unloads a module so that subsequent use will re-initialize the module as if it had actually been reloaded, but the overhead of actually reloading the module will be avoided.</source>
          <target state="translated">以外の値を設定した場合、 &lt;code&gt;CANCEL&lt;/code&gt; （参照文を&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;その後の使用が再初期化モジュールますので、それが実際に再ロードされていたが、実際にモジュールを再ロードするオーバーヘッドが回避されるかのように論理的にモジュールをアンロード）。</target>
        </trans-unit>
        <trans-unit id="ffb03e9553a2471b244e5697186cb21ecae1836a" translate="yes" xml:space="preserve">
          <source>If set to either&lt;code&gt;UPPER&lt;/code&gt;or&lt;code&gt;LOWER&lt;/code&gt; this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The&lt;code&gt;UPPER&lt;/code&gt;and&lt;code&gt;LOWER&lt;/code&gt;values of the environment variable are actually case-insensitive.</source>
          <target state="translated">&lt;code&gt;UPPER&lt;/code&gt; または &lt;code&gt;LOWER&lt;/code&gt; のいずれかに設定されている場合、この環境変数は、動的にロード可能なモジュールの検索を開始する前に、参照されるエントリポイント名を大文字または小文字に内部的に変換します。環境変数の &lt;code&gt;UPPER&lt;/code&gt; 値と &lt;code&gt;LOWER&lt;/code&gt; 値は、実際には大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="75ff3ad897d4389bd5d4346a9d0cead6b649265f" translate="yes" xml:space="preserve">
          <source>If specified, &amp;lt;</source>
          <target state="translated">指定した場合、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc641baf619f0e3d0d10496e69f3b55fd6e604c8" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="80f8927587ac8a416163b826212188d6cd97481c" translate="yes" xml:space="preserve">
          <source>If the DISPLAY verb is executing, then the size is the same as if the CONVERT phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an ACCEPT statement is used.</source>
          <target state="translated">DISPLAY 動詞が実行されている場合、数値項目以外は CONVERT フレーズを指定しなかった場合と同じサイズになります。数値項目の場合、サイズはその項目の桁数に整数でない場合は1を加え、符号付きの場合は1を加えた値になります。残りのケースは、ACCEPT文を使用した場合のサイズをカバーしています。</target>
        </trans-unit>
        <trans-unit id="fd1fa5d5fdcea9b7c73d25c9d04a3be93ca9dd38" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the</source>
          <target state="translated">使用している GnuCOBOL ビルドが Berkeley Database (BDB)パッケージを使用してインデックス化されたファイル I/O を使用するように設定されている場合、レコードロックは</target>
        </trans-unit>
        <trans-unit id="aa11e579492cde59f0f2b4460dae0515f472c0c0" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (;) as the delimiter character.</source>
          <target state="translated">使用しているGnuCOBOLコンパイラがWindowsネイティブ環境を利用するように構築されている場合は、セミコロン(;)を区切り文字として使用してください。</target>
        </trans-unit>
        <trans-unit id="e8e174d71b0a53ce0abb721ccafcd0e36830ee7a" translate="yes" xml:space="preserve">
          <source>If the LINAGE clause is</source>
          <target state="translated">LINAGE句が</target>
        </trans-unit>
        <trans-unit id="876792b175fdff61a6c190841827c8f95e62bf94" translate="yes" xml:space="preserve">
          <source>If the SIZE phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the CONVERT phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">SIZE フレーズを使用しない場合、フィールドの長さは、受諾または表示される項目のサイズが既定値となります。CONVERT フレーズが使用されている場合、フィールドのサイズは、項目のデータ型と使用されている動詞に依存します。</target>
        </trans-unit>
        <trans-unit id="a1a846b486d6a849fb5aee6dc27f07a8ed92c919" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">ファイルをコピーしようとする試みは、（例えば、それまたは宛先ディレクトリが存在しない）、失敗した場合は、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスタが（参照&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスタを&lt;/a&gt;）128に設定されます。正常に完了すると、0に設定されます。</target>
        </trans-unit>
        <trans-unit id="da68db930b7285a3ca3007bae8464343ac79a0ea" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">ファイルを削除しようとする試みは、（例えば、それは存在しない）、失敗した場合は、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスタが（参照&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスタを&lt;/a&gt;）128に設定されます。正常に完了すると、0に設定されます。</target>
        </trans-unit>
        <trans-unit id="6d499ade6d8bd513045d21fd97b496bc7d59e814" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">ファイルを移動しようとする試みは、（例えば、それは存在しない）、失敗した場合は、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスタが（参照&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスタを&lt;/a&gt;）128に設定されます。正常に完了すると、0に設定されます。</target>
        </trans-unit>
        <trans-unit id="9cc49a6a7bfb3aab04847a284111d2050a7803d8" translate="yes" xml:space="preserve">
          <source>If the binary item occupies four bytes of storage, the binary item is allocated at the next word boundary.</source>
          <target state="translated">バイナリ項目がストレージの4バイトを占有している場合、次のワード境界でバイナリ項目が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="c9eb3b2ff78316af9e06d9ecdca03186e9054272" translate="yes" xml:space="preserve">
          <source>If the binary item occupies one byte of storage, no synchronization is performed.</source>
          <target state="translated">バイナリ項目がストレージの1バイトを占有している場合、同期化は行われません。</target>
        </trans-unit>
        <trans-unit id="29ee50f202c57db2b363fa927e6f5d81d5d2accb" translate="yes" xml:space="preserve">
          <source>If the binary item occupies two bytes of storage, the binary item is allocated at the next half-word boundary.</source>
          <target state="translated">バイナリ項目がストレージの2バイトを占有している場合、バイナリ項目は次のハーフワード境界に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="78d1c026459ef474eb28e2011cf978cfda3d3820" translate="yes" xml:space="preserve">
          <source>If the calling program included a&lt;code&gt;RETURNING&lt;/code&gt;clause on the&lt;code&gt;CALL&lt;/code&gt;statement that invoked the subprogram, the value of the&lt;code&gt;RETURNING&lt;/code&gt;data item in the subroutine is moved to that data item. If there was no&lt;code&gt;RETURNING&lt;/code&gt;specified in the subroutine, the value of the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register is moved to that data item.</source>
          <target state="translated">呼び出し側プログラムがサブプログラムを呼び出した &lt;code&gt;CALL&lt;/code&gt; ステートメントに &lt;code&gt;RETURNING&lt;/code&gt; 句を含んでいた場合、サブルーチン内の &lt;code&gt;RETURNING&lt;/code&gt; データ項目の値はそのデータ項目に移動されます。サブルーチンで &lt;code&gt;RETURNING&lt;/code&gt; が指定されていなかった場合、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターの値がそのデータ項目に移動されます。</target>
        </trans-unit>
        <trans-unit id="237f820b1887571d0c11ce781473f803467fad98" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file (see &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;Compiler Configuration Files&lt;/a&gt;) you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to Microfocus COBOL rules &amp;mdash; namely, everything before the last &quot;-&quot; in the File Locator String will be ignored; the characters after the last &quot;-&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name. This is the default behaviour for every config file except &quot;ibm&quot;.</source>
          <target state="translated">プログラムのコンパイルに使用したコンパイラー「config」ファイル（「&lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;コンパイラー構成ファイル」を&lt;/a&gt;参照）が「mf」を「assign-clause」値として指定した場合、ファイルロケーター文字列はMicrofocus COBOL規則に従って解釈されます。ファイルロケータ文字列の最後の「-」は無視されます。最後の「-」の後の文字は、環境変数名のベースとして扱われます。ファイルロケータ文字列に「-」文字がない場合、ファイルロケータ文字列全体が環境変数名のベースとして機能します。これは、「ibm」を除くすべての構成ファイルのデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="be7c428b2bd6fcf64ba18d7fc20a33ae78ee6418" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you are using has &quot;relaxed-syntax-check&quot; set to &quot;yes&quot;, the&lt;code&gt;FILE-CONTROL&lt;/code&gt;and&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraphs may be specified without the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header having been coded.</source>
          <target state="translated">使用しているコンパイラの「config」ファイルで「relaxed-syntax-check」が「yes」に設定されている場合、 &lt;code&gt;FILE-CONTROL&lt;/code&gt; および &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落は、 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; なしで指定できます。ヘッダーがコーディングされています。</target>
        </trans-unit>
        <trans-unit id="fe92b0755173ad538d05379125cea0810a360175" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you used to compile the program with had a &quot;filename-mapping&quot; value of &quot;yes&quot;, the GnuCOBOL runtime system will first attempt to identify a currently-defined environment variable whose value will serve as the data file&amp;rsquo;s path and filename, as follows:</source>
          <target state="translated">プログラムのコンパイルに使用したコンパイラの「config」ファイルの「filename-mapping」値が「yes」である場合、GnuCOBOLランタイムシステムは、最初に現在定義されている環境変数を識別しようとし、その値がデータファイルの次のようなパスとファイル名：</target>
        </trans-unit>
        <trans-unit id="ada8d4fd5949881c69e3976ea553cf9ce6a69ad2" translate="yes" xml:space="preserve">
          <source>If the compiler is already in the specified mode, this statement will have no effect.</source>
          <target state="translated">コンパイラがすでに指定されたモードに入っている場合、このステートメントは何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="e079882ba26c2f94b1fe1a9df7387534f553e034" translate="yes" xml:space="preserve">
          <source>If the condition associated with a variable is false, the variable is not defined during compilations.</source>
          <target state="translated">変数に関連付けられた条件が false の場合、コンパイル時に変数は定義されません。</target>
        </trans-unit>
        <trans-unit id="3a326fe6a76a0eaf9c6262d498515fe5ffc5ef03" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of TRUE, the group will be presented.</source>
          <target state="translated">condition-nameの値がTRUEの場合、グループが表示されます。</target>
        </trans-unit>
        <trans-unit id="8c023cec5138da702e62deee764a0698dddd5f75" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the&lt;code&gt;PERFORM&lt;/code&gt;scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the&lt;code&gt;PERFORM&lt;/code&gt;</source>
          <target state="translated">カウンターの値がゼロより大きい場合、 &lt;code&gt;PERFORM&lt;/code&gt; スコープ内のステートメントが実行され、その後、カウンターは繰り返しごとに1ずつ減分されます。そのカウンターがゼロに達すると、繰り返しは停止し、制御は &lt;code&gt;PERFORM&lt;/code&gt; に続く次のステートメントに分類されます</target>
        </trans-unit>
        <trans-unit id="139a2f116480a978d8a516ae3f69011cef95b11e" translate="yes" xml:space="preserve">
          <source>If the data item in which the&lt;code&gt;SUM&lt;/code&gt;clause appears has been assigned it&amp;rsquo;s own identifier name, and that name is not&lt;code&gt;FILLER&lt;/code&gt; then that data item is referred to as a sum counter.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 句が含まれるデータ項目に独自の識別子名が割り当てられており、その名前が &lt;code&gt;FILLER&lt;/code&gt; ではない場合、そのデータ項目は合計カウンタと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="d6641aac6877a23c3a650b80aa0141134bfbab68" translate="yes" xml:space="preserve">
          <source>If the date is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.</source>
          <target state="translated">日付が有効な場合、0値が返されます。そうでない場合は、1または2の値が返され、問題がそれぞれ年または日にあることを示します。</target>
        </trans-unit>
        <trans-unit id="7b011773af10dd8c1b119874aa6b6d6a7bdffaf9" translate="yes" xml:space="preserve">
          <source>If the file defined by the &amp;lt;</source>
          <target state="translated">&amp;lt;によって定義されたファイル</target>
        </trans-unit>
        <trans-unit id="8308b61ce7bcbfc94d926cc1722564983504a579" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; the record to be rewritten will be the one retrieved by the most-recently executed&lt;code&gt;READ&lt;/code&gt;of the file. If the file has&lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;or&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; no&lt;code&gt;READ&lt;/code&gt;is required before a record may be rewritten &amp;mdash; the&lt;code&gt;RELATIVE KEY&lt;/code&gt;or&lt;code&gt;RECORD KEY&lt;/code&gt;definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">ファイルに &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; がある場合、書き換えられるレコードは、最後に実行されたファイルの &lt;code&gt;READ&lt;/code&gt; によって取得されたレコードになります。ファイルに &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; または &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; が含まれている場合、レコードを書き換える前に &lt;code&gt;READ&lt;/code&gt; は必要ありません。ファイルの &lt;code&gt;RELATIVE KEY&lt;/code&gt; または &lt;code&gt;RECORD KEY&lt;/code&gt; の定義はそれぞれ、更新するレコードを指定します。</target>
        </trans-unit>
        <trans-unit id="979f0a1fc8e50fd115ef1c5a2607d25c8a146e66" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">ファイルがある場合は &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （参照&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;または） &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; を（参照&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXEDを&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="a1d7d6e295ed262b048e40c65c57cc69c1a22916" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">ファイルに &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; がある場合（&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIALを&lt;/a&gt;参照）：</target>
        </trans-unit>
        <trans-unit id="e57bb4b94ad8d138b6e068547fa0dd3393b0fc4d" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt;</source>
          <target state="translated">ファイルの &lt;code&gt;SELECT&lt;/code&gt; に &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; が含まれている場合</target>
        </trans-unit>
        <trans-unit id="b0edb822a1ecdc41221997c63041ba9a3c222689" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt;</source>
          <target state="translated">ファイルの &lt;code&gt;SELECT&lt;/code&gt; に &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; が含まれている場合</target>
        </trans-unit>
        <trans-unit id="9ac3ef7c53e5a1a9ebd82e6132c731fb366bb269" translate="yes" xml:space="preserve">
          <source>If the function issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">機能の問題場合は &lt;code&gt;STOP&lt;/code&gt; の声明（参照&lt;a href=&quot;#STOP&quot;&gt;STOPを&lt;/a&gt;持つ） &lt;code&gt;RUN&lt;/code&gt; のオペレーティングシステムまたは任意の実行シェルにオプション、プログラムの実行が停止すると、制御が戻るには、メインプログラムを呼び出しました。</target>
        </trans-unit>
        <trans-unit id="768fc6ac0826962232769e54ee3d27933dbe814a" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">関数が呼び出したプログラムに制御が戻っを戻したい場合は、いずれかを使用して、そうします &lt;code&gt;GOBACK&lt;/code&gt; の声明（参照&lt;a href=&quot;#GOBACK&quot;&gt;GOBACKを&lt;/a&gt;）または &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 文を（参照&lt;a href=&quot;#EXIT&quot;&gt;EXITを&lt;/a&gt;）。現時点では：</target>
        </trans-unit>
        <trans-unit id="30455ee292f12916879ea7b27b16596593857296" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &quot;A&quot; or &quot;X&quot; positions specified in its PICTURE clause.</source>
          <target state="translated">項目が英数字で編集されている場合は、その項目のPICTURE句で指定された &quot;A &quot;または &quot;X &quot;の位置の数だけサイズが設定されます。</target>
        </trans-unit>
        <trans-unit id="5a3ac59ecad83c4e62bbb64e4efcc1980153a8fd" translate="yes" xml:space="preserve">
          <source>If the item is numeric or numeric edited, then the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed.</source>
          <target state="translated">項目が数値または数値編集の場合、サイズは項目内の桁数に整数でない場合は1を加え、符号付きの場合は1を加えた値となります。</target>
        </trans-unit>
        <trans-unit id="0bf6190961c1d912062042b050c89a336fba6e4f" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &amp;lt;</source>
          <target state="translated">キーと値が一致する場合、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8718b549db26737624f77d41114ec5bbc3bc5cfc" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &quot;first&quot; to &quot;current&quot; range of the table, so a new &quot;last&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">キー(複数)が値(複数)より大きい場合、検索されるテーブルエントリは、テーブルの「最初」から「現在」の範囲内でしか発生しないので、新しい「最後」ポインタの値が設定されます(それは「現在」ポインタに設定されます)。</target>
        </trans-unit>
        <trans-unit id="f855f7c7ead100cd07565ea01cc7a9230a155db1" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &quot;current&quot; to &quot;last&quot; range of the table, so a new &quot;first&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">キー(複数)が値(複数)よりも小さい場合、検索されているテーブル項目は、テーブルの &quot;current &quot;から &quot;last &quot;の範囲内にしか存在しないので、新しい &quot;first &quot;ポインタの値が設定されます(それは &quot;current &quot;ポインタに設定されます)。</target>
        </trans-unit>
        <trans-unit id="75791070ef3413617c60c665e733867b07b700c6" translate="yes" xml:space="preserve">
          <source>If the length of &amp;lt;</source>
          <target state="translated">&amp;lt;の長さ</target>
        </trans-unit>
        <trans-unit id="f678ec7b4d2b5c8286ebadce4169b6ec51506464" translate="yes" xml:space="preserve">
          <source>If the length of the &quot;from&quot; string</source>
          <target state="translated">from&quot; 文字列の長さが</target>
        </trans-unit>
        <trans-unit id="163af06aed58d0ce62be6ce917a711c8bc398a55" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are different than the old &quot;first&quot; and &quot;last&quot; pointers, there&amp;rsquo;s more left to be searched, so return to step (A) and continue.</source>
          <target state="translated">新しい「最初」と「最後」のポインターが古い「最初」と「最後」のポインターと異なる場合は、まだ検索する必要があるため、ステップ（A）に戻って続行します。</target>
        </trans-unit>
        <trans-unit id="20cd460d91c2dd82c32020553b0991e55b5ca84b" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are the same as the old &quot;first&quot; and &quot;last&quot; pointers, the table has been exhausted and the entry being searched for cannot be found; &amp;lt;</source>
          <target state="translated">新しい「最初の」および「最後の」ポインターが古い「最初の」および「最後の」ポインターと同じである場合、テーブルが使い果たされており、検索されているエントリーが見つかりません。&amp;lt;</target>
        </trans-unit>
        <trans-unit id="99b9a44588304e8fd897153b6442bc44498ed178" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">オプションの &lt;code&gt;ALL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7bdbfa412dd855282c99935345311e80faa35ff" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ELSE&lt;/code&gt;clause is present and conditional-expression evaluates to false, then (and only then) &amp;lt;</source>
          <target state="translated">オプションの &lt;code&gt;ELSE&lt;/code&gt; 句が存在し、conditional-expressionがfalseと評価された場合（そしてそのときのみ）&amp;lt;</target>
        </trans-unit>
        <trans-unit id="214f8446472e76c131789cea52e9df99ff6d7324" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;WITH FILLER&lt;/code&gt;</source>
          <target state="translated">オプションの &lt;code&gt;WITH FILLER&lt;/code&gt; の場合</target>
        </trans-unit>
        <trans-unit id="0e0c98a1a847d99310eeb35f540d53fc5e523af7" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the&lt;code&gt;-fsyntax-extension&lt;/code&gt;switch</source>
          <target state="translated">プログラムが &lt;code&gt;-fsyntax-extension&lt;/code&gt; スイッチを使用してコンパイルされている場合</target>
        </trans-unit>
        <trans-unit id="3f250bad0b5b4ae9aea9503229c333bf1801f01f" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. If&lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt;is null (in other words, the replacement text is specified as&lt;code&gt;====&lt;/code&gt;, all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">置換文字列が複数項目フレーズであるか、完全に削除される場合は、 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt; オプションを使用する必要があります。場合は &lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt; つまり、置換テキストは次のように指定されている（nullである &lt;code&gt;====&lt;/code&gt; 、検索文字列のすべての遭遇の発生が削除されます。</target>
        </trans-unit>
        <trans-unit id="b864101b1cf94817be38b70b043aacccfa75cd6e" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">ルーチンが成功すると、値0が &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターに戻されます（&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスターを&lt;/a&gt;参照）。引数の問題（長さが負または0であるなど）が原因でルーチンが失敗した場合、128の値が返されます。最後に、最初の引数の値がゼロ以外の場合、ルーチンは129の値で失敗します。</target>
        </trans-unit>
        <trans-unit id="5a1b44b26b84f05f8af22b9e038aef3fc238f233" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &amp;lt;</source>
          <target state="translated">検索インデックスの値がテーブルのエントリ数よりも大きい場合、検索は失敗したと見なされ、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="94565d23be2bb0fc7d85c959aef69eff52cd9069" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).</source>
          <target state="translated">検索インデックスがテーブル内のエントリ数以下の値を持つようになった場合、検索処理はステップ(A)に戻る。</target>
        </trans-unit>
        <trans-unit id="63b646dd35f2ad5b466ac70be0367ce3e11e5b92" translate="yes" xml:space="preserve">
          <source>If the specified argument does not exist, or an invalid argument number is specified, a value of 0 is returned.</source>
          <target state="translated">指定した引数が存在しない場合、または無効な引数番号を指定した場合は 0 を返す。</target>
        </trans-unit>
        <trans-unit id="a1c8f712007564d99604775da06766bbac9f03bb" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">指定された条件名はFALSEの値がある場合は &lt;code&gt;GENERATE&lt;/code&gt; 文を（参照&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）レポートグループが提示されるようになり、そのグループのプレゼンテーションが抑制されます。</target>
        </trans-unit>
        <trans-unit id="66774ceedbe10981e42302c55639170b0ed0f28a" translate="yes" xml:space="preserve">
          <source>If the structure contains the following grid of characters:</source>
          <target state="translated">構造体に以下のグリッド文字が含まれている場合。</target>
        </trans-unit>
        <trans-unit id="5be0ca5096c1af0f623320b98f1b64f052b51144" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the&lt;code&gt;INITIAL&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its&lt;code&gt;PROGRAM-ID&lt;/code&gt;clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">呼び出されるサブプログラムがGnuCOBOLプログラムであり、その &lt;code&gt;PROGRAM-ID&lt;/code&gt; 句で &lt;code&gt;INITIAL&lt;/code&gt; （&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISIONを&lt;/a&gt;参照）属性が指定されている場合、サブプログラムのすべてのデータ分割データは、サブプログラムが実行されるたびに初期状態に復元されます。サブプログラム内のどのエントリポイントが参照されているかに関係なく、実行されます。</target>
        </trans-unit>
        <trans-unit id="1ad68b7c421e5be7cfd3f061b145123e5b308674" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">サブプログラムの問題場合は &lt;code&gt;STOP&lt;/code&gt; の声明（参照&lt;a href=&quot;#STOP&quot;&gt;STOPを&lt;/a&gt;持つ） &lt;code&gt;RUN&lt;/code&gt; のオペレーティングシステムまたは任意の実行シェルにオプション、プログラムの実行が停止すると、制御が戻るには、メインプログラムを呼び出しました。</target>
        </trans-unit>
        <trans-unit id="3fddc95876d626c2ec7bbbe309cf154f2991a624" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; or it&amp;rsquo;s equivalent.</source>
          <target state="translated">サブプログラムが値を返す場合、値が返されるデータ項目も、 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; またはそれと同等の &lt;code&gt;USAGE&lt;/code&gt; （&lt;a href=&quot;#USAGE&quot;&gt;USAGEを&lt;/a&gt;参照）を使用して、サブプログラムのリンケージセクションで定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="3977b529e0e7ac10b11afc507f2c9eb5bfc68f03" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">サブプログラムは、呼び出し元プログラムに制御が戻っを戻したい場合は、いずれかを使用して、そうします &lt;code&gt;GOBACK&lt;/code&gt; の声明（参照&lt;a href=&quot;#GOBACK&quot;&gt;GOBACKを&lt;/a&gt;）または &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 文を（参照&lt;a href=&quot;#EXIT&quot;&gt;EXITを&lt;/a&gt;）。現時点では：</target>
        </trans-unit>
        <trans-unit id="fb4435d664648be40b4a8cc4319cd6f4b4970f02" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or&lt;code&gt;ENTRY&lt;/code&gt;statement included a&lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the&lt;code&gt;CALL-CONVENTION&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave&lt;code&gt;RETURN-CODE&lt;/code&gt;unchanged.</source>
          <target state="translated">サブプログラムの手続き部のヘッダーまたは &lt;code&gt;ENTRY&lt;/code&gt; ステートメントに &lt;code&gt;RETURNING&lt;/code&gt; が含まれている場合（&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスターを&lt;/a&gt;参照）。この動作は、 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; （&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMESを&lt;/a&gt;参照）機能を使用して変更し、 &lt;code&gt;RETURN-CODE&lt;/code&gt; を変更しないでおくことができます。</target>
        </trans-unit>
        <trans-unit id="4fca4d357c4da52ecdfe09ff7f3b59313032d58e" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of 35 to be passed back. Supplying less than two arguments will generate a 128&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value.</source>
          <target state="translated">サブルーチンが成功すると、値0が &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターに戻されます（&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスターを&lt;/a&gt;参照）。ファイルで必要な統計を取得できない場合、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスター値35が返されます。2つ未満の引数を指定すると、128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスター値が生成されます。</target>
        </trans-unit>
        <trans-unit id="2e2d3e910dfeb525715cdc365898fd54399a43c4" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of -1 to be passed back.</source>
          <target state="translated">サブルーチンが成功すると、値0が &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターに戻されます（&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスターを&lt;/a&gt;参照）。失敗すると、-1の &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスター値が戻されます。</target>
        </trans-unit>
        <trans-unit id="d1bb984fa6207ca92b69374fdf44a4d8170a10b1" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the&lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt;clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">フィールドに格納されている値が受信フィールドと同じ長さである場合、そのフィールドの説明に &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 句が存在するかどうかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="e5b69bef404018740f53a3d7738badc9ff4e4531" translate="yes" xml:space="preserve">
          <source>If the value of &amp;lt;</source>
          <target state="translated">&amp;lt;の値</target>
        </trans-unit>
        <trans-unit id="a8941ef78769624061ef92939b2c773736817ccd" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &quot;+&quot; character will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">フィールドに移動された数値が正の値(0以上)の場合は「+」文字が挿入されます。値が負(0未満)の場合は、&quot;-&quot;文字が挿入されます。</target>
        </trans-unit>
        <trans-unit id="fa45922afd3a1788e3ef11576266d429b5817fba" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">フィールドに移動した数値の値が正(0以上)の場合はスペースが挿入されます。値が負(0未満)の場合は、「-」文字が挿入されます。</target>
        </trans-unit>
        <trans-unit id="48dd00b4185648ad98a04dd28fc9dd3c41fb5dc5" translate="yes" xml:space="preserve">
          <source>If the value specified for the &amp;lt;</source>
          <target state="translated">&amp;lt;に指定された値が</target>
        </trans-unit>
        <trans-unit id="0831d72b5b85932627f6976dfb6259ade2e7b74e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt;switch or&lt;code&gt;-fintrinsics=ALL&lt;/code&gt;switch is specified to the compiler or the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph specifies either&lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt;or&lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; then references to&lt;code&gt;WHEN-COMPILED&lt;/code&gt;(without a leading&lt;code&gt;FUNCTION&lt;/code&gt;keyword will always reference this intrinsic function and there will be no way to access the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register.</source>
          <target state="translated">場合 &lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt; スイッチまたは &lt;code&gt;-fintrinsics=ALL&lt;/code&gt; のスイッチはコンパイラまたはに指定されている &lt;code&gt;REPOSITORY&lt;/code&gt; （参照&lt;a href=&quot;#REPOSITORY&quot;&gt;リポジトリ&lt;/a&gt;段落の指定のいずれか） &lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt; または &lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; に、その後の参照を &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 招くことなく（ &lt;code&gt;FUNCTION&lt;/code&gt; キーワードは常にこの組み込み関数を参照し、 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 特殊レジスターにアクセスする方法はありません。</target>
        </trans-unit>
        <trans-unit id="3b420486302df3f6e207a4313dfd931a759d89b7" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">もし &lt;code&gt;-ftrace&lt;/code&gt; のスイッチ</target>
        </trans-unit>
        <trans-unit id="3349b7269aaccc8bb1cc998766e4a46beb55bde2" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ACCESS MODE&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">&amp;lt; の &lt;code&gt;ACCESS MODE&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="2e5d9e90a43cf87c9978ea30182b2bcd04cc6c52" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is absent after the&lt;code&gt;TO&lt;/code&gt; the contents of &amp;lt;</source>
          <target state="translated">&amp;lt;の &lt;code&gt;TO&lt;/code&gt; の後に &lt;code&gt;ADDRESS OF&lt;/code&gt; 句がない場合</target>
        </trans-unit>
        <trans-unit id="26199d3754ff366a5846d65d208ee2e6de9686ad" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ALL&lt;/code&gt;keyword was specified on the&lt;code&gt;VALUE&lt;/code&gt;clause, all members of the field list with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify.</source>
          <target state="translated">場合は &lt;code&gt;ALL&lt;/code&gt; のキーワードが上で指定された &lt;code&gt;VALUE&lt;/code&gt; の句、とフィールドリストのすべてのメンバー &lt;code&gt;VALUE&lt;/code&gt; の条項が対象となります。</target>
        </trans-unit>
        <trans-unit id="df5d251bac8a9bff6db280d0993ff1dbfac8f41c" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONSTANT&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="0c81429e41c0cb12a035faac7aa149969b981744" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CRT STATUS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRT STATUS&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="bdf79d6d2d1dddc9f4d79dc6b3151fcff14428de" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">ファイルの &lt;code&gt;FD&lt;/code&gt; に &lt;code&gt;RECORD CONTAINS&lt;/code&gt; または &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 句が含まれ、その句によってレコードサイズを変更できる場合、サイズ</target>
        </trans-unit>
        <trans-unit id="7cd7e97ca9d4f2995a04bb967f17ad631843750e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size of &amp;lt;</source>
          <target state="translated">ファイルの &lt;code&gt;FD&lt;/code&gt; に &lt;code&gt;RECORD CONTAINS&lt;/code&gt; または &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 句が含まれていて、その句によりレコードサイズを変更できる場合、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8342745452a46e82129819210173c072a362af42" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">場合 &lt;code&gt;LINAGE&lt;/code&gt; （参照&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;ファイル/ソート-説明&lt;/a&gt;）句があります</target>
        </trans-unit>
        <trans-unit id="67faed20b65d381e0f35f57376ea02fccee28463" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LOCK ON&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="9a4cf245f7ab4d128cf1a215befd46fe8ca30464" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;clause</source>
          <target state="translated">もし &lt;code&gt;LOCK ON&lt;/code&gt; 句</target>
        </trans-unit>
        <trans-unit id="5348e096005262a0ab82c3168003e7e7371e7dae" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PERFORM&lt;/code&gt;specifies or implies&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</source>
          <target state="translated">&lt;code&gt;PERFORM&lt;/code&gt; が &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;を指定または暗示する場合</target>
        </trans-unit>
        <trans-unit id="dd5a2104ff28017a6be9e284824ff9c6d67e6603" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">サブプログラムの &lt;code&gt;PROGRAM-ID&lt;/code&gt; （&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISIONを&lt;/a&gt;参照）句に &lt;code&gt;INITIAL&lt;/code&gt; が含まれていた場合</target>
        </trans-unit>
        <trans-unit id="68679aad3ae2e21817a3db3c1cd8a4c87162b63f" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a&lt;code&gt;NEXT GROUP&lt;/code&gt;clause does not contain a&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause, only the&lt;code&gt;PLUS integer-1&lt;/code&gt;option may be specified.</source>
          <target state="translated">&lt;code&gt;NEXT GROUP&lt;/code&gt; 句を含むレポートグループに &lt;code&gt;PAGE LIMITS&lt;/code&gt; 句が含まれていない &lt;code&gt;RD&lt;/code&gt; （&lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTIONを&lt;/a&gt;参照）の場合、 &lt;code&gt;PLUS integer-1&lt;/code&gt; オプションのみを指定できます。</target>
        </trans-unit>
        <trans-unit id="6326e274617c726298b0f2a259364a71ec08cb9a" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;REMAINDER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REMAINDER&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="d46ae7e0403a69183623c2c0c30c04ac183c02a4" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RESET&lt;/code&gt;option is coded,&lt;code&gt;FINAL&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">場合は &lt;code&gt;RESET&lt;/code&gt; のオプションがコード化され、 &lt;code&gt;FINAL&lt;/code&gt; または&amp;lt;</target>
        </trans-unit>
        <trans-unit id="38a1fbfcc2ff5f0f55dba89a7b49d153d656d7e5" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies&lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; record locking will be disabled.</source>
          <target state="translated">場合 &lt;code&gt;SELECT&lt;/code&gt; （参照&lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;文またはファイル） &lt;code&gt;OPEN&lt;/code&gt; を（参照&lt;a href=&quot;#OPEN&quot;&gt;OPENを&lt;/a&gt;）指定 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; レコードロックは無効になります。</target>
        </trans-unit>
        <trans-unit id="4469b431cec5ac5fa31a45bf59859b62ee522aee" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;of a file is coded with a&lt;code&gt;FILE STATUS&lt;/code&gt;clause,&lt;code&gt;OPEN&lt;/code&gt;failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">ファイルの &lt;code&gt;SELECT&lt;/code&gt; が &lt;code&gt;FILE STATUS&lt;/code&gt; 句でコーディングされている場合、 &lt;code&gt;OPEN&lt;/code&gt; の失敗（共有の失敗によって引き起こされたものを含む）がプログラムによって検出され、正常な回復（または少なくとも正常な終了）が可能になります。ただし、そのような句がコーディングされていない場合は、実行時メッセージが発行され、プログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="d43773d0d9856113d341b49d71c616d3ba81cd29" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;clause</source>
          <target state="translated">もし &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; の句</target>
        </trans-unit>
        <trans-unit id="cc7da6fe4678bd908df6708f4cd87c152a905cc1" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause is coded on anything but a numeric data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause will be ignored.</source>
          <target state="translated">場合 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 句を使って何が、数字データ項目でコード化された &lt;code&gt;USAGE&lt;/code&gt; （参照&lt;a href=&quot;#USAGE&quot;&gt;USAGEを&lt;/a&gt;バイナリ形式のデータのように指定し保存）、 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 句は無視されます。</target>
        </trans-unit>
        <trans-unit id="3d2f7b6539018dd97bf4f7ebf6332805f3b4ccf8" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the&lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">トークンの数が引数の数よりも少ない場合、余分な引数は、 &lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; （&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZEを&lt;/a&gt;参照）ステートメントが実行されたかのように初期化されます。</target>
        </trans-unit>
        <trans-unit id="061529f2e81b4789d20b56f0ff94bb58b24306f6" translate="yes" xml:space="preserve">
          <source>If there are more tokens than there are arguments, the excess tokens will be discarded.</source>
          <target state="translated">トークンが議論よりも多い場合は、余ったトークンは破棄されます。</target>
        </trans-unit>
        <trans-unit id="f2d936a65b86a2841ae9003e465d423ea6c6934c" translate="yes" xml:space="preserve">
          <source>If there are multiple cash registers in a particular department of a specific store, the data needs to be further sorted so that the cash registers are ordered in sequence of their register number.</source>
          <target state="translated">また、特定の店舗の特定の部署に複数のレジがある場合には、レジ番号順に並ぶようにデータをさらにソートする必要がある。</target>
        </trans-unit>
        <trans-unit id="3972fbb29cfb0307f762dc829ca3e5c79c5963a7" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt; the one with the longest length will define the size of the record buffer into which a&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a&lt;code&gt;RETURN&lt;/code&gt;statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">所与のために存在する複数のレコード記述がある場合は &lt;code&gt;FD&lt;/code&gt; または &lt;code&gt;SD&lt;/code&gt; 先のレコードバッファのサイズを規定する最長の長さを有するもの &lt;code&gt;READ&lt;/code&gt; 文は、（参照&lt;a href=&quot;#READ&quot;&gt;READを&lt;/a&gt;）または &lt;code&gt;RETURN&lt;/code&gt; のステートメント（参照&lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;データを配信するが）から読み出しますファイルからの &lt;code&gt;WRITE&lt;/code&gt; の声明（参照&lt;a href=&quot;#WRITE&quot;&gt;WRITEを&lt;/a&gt;）または &lt;code&gt;RELEASE&lt;/code&gt; の声明（参照&lt;a href=&quot;#RELEASE&quot;&gt;RELEASEを&lt;/a&gt;）文は、ファイルに書き込まれるデータを取得します。</target>
        </trans-unit>
        <trans-unit id="75eb31de9a88419e99f8f2249dfa222651219fe7" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the&lt;code&gt;ALL&lt;/code&gt;option is specified, the&lt;code&gt;ALL&lt;/code&gt;option will be ignored.</source>
          <target state="translated">ピクチャー句がなく、 &lt;code&gt;ALL&lt;/code&gt; オプションが指定されている場合、 &lt;code&gt;ALL&lt;/code&gt; オプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="0c755b4b694e7c4beb9b1c5901a6f3a6e90065fa" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &amp;lt;</source>
          <target state="translated">画像句が指定されていない場合、画面データ項目のサイズは&amp;lt;</target>
        </trans-unit>
        <trans-unit id="be6e32115bff0c291e8d3c6d6525390722099349" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;C-D&lt;/code&gt;data item, then are there&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items? If not, the&lt;code&gt;COMPUTE&lt;/code&gt;statement is in error. If there are, however, then code will be generated to subtract the value of&lt;code&gt;D&lt;/code&gt;from&lt;code&gt;C&lt;/code&gt;and add 1 to the result.</source>
          <target state="translated">&lt;code&gt;C-D&lt;/code&gt; データ項目がない場合、 &lt;code&gt;C&lt;/code&gt; および &lt;code&gt;D&lt;/code&gt; データ項目はありますか？そうでない場合、 &lt;code&gt;COMPUTE&lt;/code&gt; ステートメントにエラーがあります。ただし、ある場合は、 &lt;code&gt;C&lt;/code&gt; から &lt;code&gt;D&lt;/code&gt; の値を減算して結果に1を加えるコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="6dbb73155f0ea4fd82ba811977b3d699fc88a4ae" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;CONTROL&lt;/code&gt;clause, the report will contain no control breaks; this implies that there can be no&lt;code&gt;CONTROL HEADING&lt;/code&gt;or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report groups defined for this&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONTROL&lt;/code&gt; 句がない場合、レポートにはコントロールブレークが含まれません。これは、この &lt;code&gt;RD&lt;/code&gt; に定義された &lt;code&gt;CONTROL HEADING&lt;/code&gt; または &lt;code&gt;CONTROL FOOTING&lt;/code&gt; のレポートグループがないことを意味します</target>
        </trans-unit>
        <trans-unit id="a351d89c95027f7701058bc9f942df00ed507cdc" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;INITIAL&lt;/code&gt;clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 句が指定されていない場合、ターゲット範囲は検査対象全体です。</target>
        </trans-unit>
        <trans-unit id="f81540f4079ee51c4206d96a7efc736809a22ed7" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;RESET&lt;/code&gt;option coded, the sum counter will be reset back to zero after each time the control footing containing the&lt;code&gt;SUM&lt;/code&gt;clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; オプションがコーディングされていない場合、 &lt;code&gt;SUM&lt;/code&gt; 句を含む制御脚注が表示されるたびに、合計カウンターはゼロにリセットされます。これは、予想される典型的な動作です。</target>
        </trans-unit>
        <trans-unit id="d5e252dc91e0d99f464bda7bc7cffd6140f7edd1" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;UPON&lt;/code&gt;clause specified, the value of &amp;lt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 句が指定されていない場合、&amp;lt;の値</target>
        </trans-unit>
        <trans-unit id="3241679c69995dc4a256fad0940c95e8635b9f3e" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the&lt;code&gt;UPON&lt;/code&gt;clause is meaningless.</source>
          <target state="translated">レポートの定義に詳細グループが1つしかない場合、 &lt;code&gt;UPON&lt;/code&gt; 句は意味がありません。</target>
        </trans-unit>
        <trans-unit id="c11b35162c1c669848bde8fb8b4adb40363c054b" translate="yes" xml:space="preserve">
          <source>If this format of the&lt;code&gt;GO TO&lt;/code&gt;statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">この形式の &lt;code&gt;GO TO&lt;/code&gt; ステートメントが、文内の一連の命令ステートメント（「&lt;a href=&quot;#Imperative-Statement&quot;&gt;命令ステートメント」を&lt;/a&gt;参照）に現れる場合は、それが</target>
        </trans-unit>
        <trans-unit id="87568d2d981805ff51bcc79d09c4d6bfd7b2a8ef" translate="yes" xml:space="preserve">
          <source>If this is NOT set to a value, all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written to STDERR, where it may be piped via a &quot;2&amp;gt; filename&quot; on the command that executes the program.</source>
          <target state="translated">これが値に設定されていない場合、すべての &lt;code&gt;-ftrace&lt;/code&gt; スイッチと &lt;code&gt;-ftraceall&lt;/code&gt; スイッチの出力はSTDERRに書き込まれ、プログラムを実行するコマンドの &quot;2&amp;gt; filename&quot;を介してパイプされることがあります。</target>
        </trans-unit>
        <trans-unit id="e41eac2db71cda7170c71b8ec2c30d7834407d0c" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to /usr/local/share/gnucobol/config.</source>
          <target state="translated">これが *nix で定義されていない場合は /usr/local/share/gnucobol/config がデフォルトになります。</target>
        </trans-unit>
        <trans-unit id="023cf0ecfd0afc5f6ae392348d069495edac90d8" translate="yes" xml:space="preserve">
          <source>If used with&lt;code&gt;PIC X&lt;/code&gt; allocates one byte of storage per&lt;code&gt;X&lt;/code&gt; range of values is 0 to max storable in that many bytes. If used with&lt;code&gt;PIC 9&lt;/code&gt; range of values depends on number of&lt;code&gt;9&lt;/code&gt; in PICTURE</source>
          <target state="translated">使用している場合で &lt;code&gt;PIC X&lt;/code&gt; が割り当てあたりのストレージの1バイトの &lt;code&gt;X&lt;/code&gt; の値の範囲は、そのバイト数で最大保存可能に0です。 &lt;code&gt;PIC 9&lt;/code&gt; と共に使用する場合、値の範囲はPICTURE の &lt;code&gt;9&lt;/code&gt; の数に依存します</target>
        </trans-unit>
        <trans-unit id="5b48ea3221a5bd190b3da00947706eadb4325c47" translate="yes" xml:space="preserve">
          <source>If used, &amp;lt;</source>
          <target state="translated">使用する場合、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92f6ebb3f39d6efd118da1f36149fda0df27506" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the &quot;C&quot; programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">C」プログラミング言語に慣れている場合は、以下のシンプルなGnuCOBOLプログラムが、添え字とインデックスの違いを調べるのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="66062304bf503c5649ee5c39992874bd53f8d855" translate="yes" xml:space="preserve">
          <source>If you are planning on using static-linked subroutine libraries, set this variable to the path of the directory containing your libraries.</source>
          <target state="translated">スタティックリンクされたサブルーチンライブラリを使用する場合は、この変数にライブラリを含むディレクトリのパスを設定してください。</target>
        </trans-unit>
        <trans-unit id="01f92f2645932d2e7b72a1c8110cdcfbd8882f1a" translate="yes" xml:space="preserve">
          <source>If you are sorting &amp;lt;</source>
          <target state="translated">並べ替える場合&amp;lt;</target>
        </trans-unit>
        <trans-unit id="02aa6a4a695c82943ebf8b43c9d16d82122de6f1" translate="yes" xml:space="preserve">
          <source>If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)</source>
          <target state="translated">固定フォーマットモードを使用している場合、英数字リテラルは72列目まで実行することができます。その後、リテラルは、別の引用符またはアポストロフィ(リテラルの最初に使用されていたもの)をコード化することで、11列目以降の任意の場所で次の行に続けることができます。継続行にはハイフン(-)を入れなければなりません。</target>
        </trans-unit>
        <trans-unit id="67c575e7eebaede09fa7a3ba7a66b085e2b666ab" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no&lt;code&gt;S&lt;/code&gt;in its&lt;code&gt;PICTURE&lt;/code&gt; the absolute value of the negative number will actually be stored.</source>
          <target state="translated">あなたは何も持っていないパック10進数フィールドに負の数を保存しようとすると &lt;code&gt;S&lt;/code&gt; その中に &lt;code&gt;PICTURE&lt;/code&gt; を負の数の絶対値が実際に格納されます。</target>
        </trans-unit>
        <trans-unit id="33f09798c9350fe782168c79a484ebfce1dfd921" translate="yes" xml:space="preserve">
          <source>If you have used other versions of COBOL before (particularly mainframe implementations), you&amp;rsquo;ve possibly seen subroutine calls made passing a procedure name as an argument &amp;mdash; that is not possible in GnuCOBOL; instead, you need to know how to use this form of the&lt;code&gt;SET&lt;/code&gt;statement.</source>
          <target state="translated">以前に他のバージョンのCOBOL（特にメインフレームの実装）を使用したことがある場合は、サブルーチン呼び出しが引数としてプロシージャ名を渡して行われるのを見たことがあるかもしれません&amp;mdash; GnuCOBOLでは不可能です。代わりに、この形式の &lt;code&gt;SET&lt;/code&gt; ステートメントの使用方法を知っている必要があります。</target>
        </trans-unit>
        <trans-unit id="8575747ffb34e15317f4825a1a6d194e243908c5" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend &quot;Murach&amp;rsquo;s Structured COBOL&quot;, by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. Mike Murach and his various writing partners have been writing outstanding COBOL textbooks for decades, and this text is no exception. It&amp;rsquo;s an excellent book for those familiar with the concepts of programming in other languages, but unfamiliar with COBOL.</source>
          <target state="translated">本を手にしたい場合は、Mike Murach、Anne Prince、Raul Menendez（2000）による「Murach's Structured COBOL」（ISBN 9781890774059）を強くお勧めします。MikeMurachと彼のさまざまなライティングパートナーは、数十年、このテキストも例外ではありません。これは、他の言語でのプログラミングの概念に精通しているが、COBOLには不慣れな人にとっては優れた本です。</target>
        </trans-unit>
        <trans-unit id="a983cec50cc8adb2cb72101e62421b49b40c3f8f" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &amp;lt;</source>
          <target state="translated">2文字、5桁、3文字の形式のデータ項目にスペースを割り当てる必要がある場合は、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3d7ab34ba2edb8344ca5cd05ed4f78d8ca295856" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;REPLACING&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">&lt;code&gt;REPLACING&lt;/code&gt; 初期化を複数に適用する必要がある場合&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be77805ea73d60e3aa2532f09cd1417a0b5f725" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;VALUE&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 初期化を複数の&amp;lt; に適用する必要がある場合</target>
        </trans-unit>
        <trans-unit id="09b277bb04315e13de2ea2c1d6215f972f449420" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt;</source>
          <target state="translated">テーブルへの参照を修飾する必要がある場合は、 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt; &lt;i&gt;identifier-1&lt;/i&gt; &amp;gt; OF &amp;lt; &lt;i&gt;identifier-2&lt;/i&gt; &amp;gt;（subscript（s））のようにコーディングしてください。&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ea477a1b93e894e00c5029bde5c4700835a658bc" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &quot;subscript&quot; many more times than once, the run-time overhead of converting that occurrence value to an index (via&lt;code&gt;SET Index&lt;/code&gt; will be worth the coding effort.</source>
          <target state="translated">計算された発生数を一度だけ使用する必要がある場合は、計算された発生数データ項目を添え字として使用することもできます。ただし、計算された「添え字」を複数回使用する必要がある場合は、その出現値をインデックスに変換する実行時のオーバーヘッド（ &lt;code&gt;SET Index&lt;/code&gt; を介して）をコーディングする価値があります。</target>
        </trans-unit>
        <trans-unit id="1b1aec7f2d01b9337cb99ecf14cbd063323c6bfc" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; it will be ignored.</source>
          <target state="translated">ソート/マージ作業ファイルの &lt;code&gt;SELECT&lt;/code&gt; で特定のファイル名を指定した場合、それは無視されます。</target>
        </trans-unit>
        <trans-unit id="db4b705d51633a3053f41836b85c013703781c0c" translate="yes" xml:space="preserve">
          <source>If you specify&lt;code&gt;FINAL&lt;/code&gt; it must be the first control break named in the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FINAL&lt;/code&gt; を指定する場合は、 &lt;code&gt;RD&lt;/code&gt; で指定された最初のコントロールブレークである必要があります。</target>
        </trans-unit>
        <trans-unit id="bd75b97fc760ccc29226f53558113a860ab9c393" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the&lt;code&gt;-O&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOLプログラムからパフォーマンスの最後のすべてのビットを絞りたい場合は、 &lt;code&gt;-O&lt;/code&gt; スイッチを調査することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="d6f238b944da72a8958154ef52736f8bf20193b7" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the&lt;code&gt;P&lt;/code&gt; were&lt;code&gt;9&lt;/code&gt;:</source>
          <target state="translated">1億2800万の値をそのフィールドに格納する場合は、 &lt;code&gt;P&lt;/code&gt; が &lt;code&gt;9&lt;/code&gt; であるかのように実行します。</target>
        </trans-unit>
        <trans-unit id="f960091ad57764e902ba6a62fa5a1b8ba304ce95" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the&lt;code&gt;END-verb&lt;/code&gt;structures in those programs.</source>
          <target state="translated">既存のコードをGnuCOBOLに移植する場合、そのコードが使用する可能性のあるあらゆる言語およびコーディング標準に準拠できる対応機能が見つかります。ただし、新しいGnuCOBOLプログラムを作成する場合は、それらのプログラムで &lt;code&gt;END-verb&lt;/code&gt; 構造を使用するよう強くアドバイスします。</target>
        </trans-unit>
        <trans-unit id="84f76abe3e8dfd99557f1d9c28b5a29519b7cdd8" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;),&lt;code&gt;REWRITE&lt;/code&gt;statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;),&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">GnuCOBOLビルドがBerkeley Database（BDB）パッケージを使用する場合、この環境変数を使用して、プログラムによって開かれるすべての非SORTファイルに関連付けられるロック管理ファイルが格納されるフォルダーを指定します。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （参照&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXEDを&lt;/a&gt;）ファイルも、それが存在する場合は、フォルダに割り当てられた彼らのデータファイルが定義され、この変数は、上のレコードロック機能が有効になります持って...、この環境変数によって指さなければならない &lt;code&gt;READ&lt;/code&gt; 文の（参照&lt;a href=&quot;#READ&quot;&gt;READを&lt;/a&gt;）、 &lt;code&gt;REWRITE&lt;/code&gt; の声明（参照&lt;a href=&quot;#REWRITE&quot;&gt;REWRITEを&lt;/a&gt;）と &lt;code&gt;WRITE&lt;/code&gt; 文は（参照&lt;a href=&quot;#WRITE&quot;&gt;WRITEを&lt;/a&gt;）。 DB_HOMEを使用しても、 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; ではロックは機能しません（参照&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIALを&lt;/a&gt;、） &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; （参照&lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIALを&lt;/a&gt; GnuCOBOLで）またはORGANIZATION RELATIVEファイルは、Windows / MinGWのために作成構築します。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; ロックはWindows / MinGW + BDBで機能し、すべてのロックはUNIX GnuCOBOLビルドですべてのファイル組織で機能します。</target>
        </trans-unit>
        <trans-unit id="5d5c76b0afd98975a32ec5cfb6a7e9651011522c" translate="yes" xml:space="preserve">
          <source>If your program is using Free Format Mode, there&amp;rsquo;s less need to continue long alphanumeric literals because statements may be as long as 255 characters.</source>
          <target state="translated">プログラムがフリーフォーマットモードを使用している場合、ステートメントは最大255文字になる可能性があるため、長い英数字リテラルを継続する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="9ec069692353086fbfea33bd5148cbb40a61d28b" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (:) as the delimiter.</source>
          <target state="translated">しかし、GnuCOBOLコンパイラがUnix、OSX、Linux環境用に作られている場合、またはCygwinまたはMinGW Unixエミュレータを使用しているWindows環境用に作られている場合は、区切り文字としてコロン(:)を使用してください。</target>
        </trans-unit>
        <trans-unit id="732d00d8a979e2d6acfa93077091ec5aa45575e1" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the&lt;code&gt;SUM&lt;/code&gt;counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the&lt;code&gt;RESET&lt;/code&gt;option.</source>
          <target state="translated">ただし、コントロール階層の上位にあるコントロールブレークのコントロールフーティングが表示されている場合にのみ &lt;code&gt;SUM&lt;/code&gt; カウンターをリセットする場合は、 &lt;code&gt;RESET&lt;/code&gt; オプションでその上位のコントロールブレークを指定します。</target>
        </trans-unit>
        <trans-unit id="2cd8cc804f2a5ff93a10ce1b74fdd3576f5a7e3f" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler &quot;config&quot; file you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to according to IBM COBOL rules &amp;mdash; namely, the File Locator String is expected to be of the form &quot;S-xxx&quot; or &quot;AS-xxx&quot;, in which case the &quot;xxx&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name.</source>
          <target state="translated">一方、プログラムのコンパイルに使用したコンパイラの「config」ファイルが「mf」を「assign-clause」値として指定した場合、ファイルロケータ文字列は、IBM COBOL規則に従って解釈されます。ファイルロケータ文字列は「S-xxx」または「AS-xxx」の形式であることが想定されています。この場合、「xxx」は環境変数名のベースとして扱われます。ファイルロケータ文字列に「-」文字がない場合、ファイルロケータ文字列全体が環境変数名のベースとして機能します。</target>
        </trans-unit>
        <trans-unit id="14a1e778d3d526022a292de2dd1ee46c48882f7a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;AFTER ADVANCING&lt;/code&gt;</source>
          <target state="translated">もし &lt;code&gt;AFTER ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2484c7b62fe9d88e48bcea28b9bbba49a4a0abff" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;FIRST&lt;/code&gt;was specified, the logical record pointer will point to the first record in the file.</source>
          <target state="translated">場合 &lt;code&gt;FIRST&lt;/code&gt; が指定された、論理レコードポインタはファイルの最初のレコードを指しています。</target>
        </trans-unit>
        <trans-unit id="7863a8759644caaed13a6998607dcd0f2e23acf3" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;KEY&lt;/code&gt;was specified or implied, the logical record pointer will be specified to the</source>
          <target state="translated">&lt;code&gt;KEY&lt;/code&gt; が指定または暗黙指定されている場合、論理レコードポインターは</target>
        </trans-unit>
        <trans-unit id="1552ccf0c116c7d239331a720f9d74cec693c257" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;LAST&lt;/code&gt;was specified, the logical record pointer will point to the last record in the file.</source>
          <target state="translated">場合 &lt;code&gt;LAST&lt;/code&gt; が指定された、論理レコードポインタはファイルの最後のレコードを指します。</target>
        </trans-unit>
        <trans-unit id="8278b8c8384858282c9b205d0ba2082757d20698" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;9 and contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 9に &lt;code&gt;S&lt;/code&gt; が含まれている場合</target>
        </trans-unit>
        <trans-unit id="8061e9cae2be0636e69237bf17be3f7098f0542a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd6edca65a7476c700085fccd1713df6568c8bd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with a level number numerically less than&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; がオブジェクトのレベル番号を表す場合、サブジェクトデータオブジェクトとオブジェクトデータアイテムの間に、レベル番号が &lt;code&gt;n&lt;/code&gt; 未満の他のデータアイテムを定義することはできません。</target>
        </trans-unit>
        <trans-unit id="d3c3a4ef34b214c7901c86d04f87249a39615cfd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with level number&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items unless they too are&lt;code&gt;REDEFINES&lt;/code&gt;of the subject.</source>
          <target state="translated">もし &lt;code&gt;n&lt;/code&gt; 、オブジェクトのレベル番号を表していないレベルの数と、次に他のデータ項目 &lt;code&gt;n&lt;/code&gt; 彼らはあまりにもない限り被写体とオブジェクトデータ項目との間に画定されてもよい &lt;code&gt;REDEFINES&lt;/code&gt; 被験者の。</target>
        </trans-unit>
        <trans-unit id="41e3512adad8c7a49c2bc5818c26857faf073355" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of&lt;code&gt;-fnotrunc&lt;/code&gt;switch also made a difference:</source>
          <target state="translated">しかし、 &lt;code&gt;-fnotrunc&lt;/code&gt; スイッチの使用も違いを発見したときの私の驚きを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="ba2d2155230191737321736ab1c421252a9d474f" translate="yes" xml:space="preserve">
          <source>Imperative Statement</source>
          <target state="translated">強制的な声明</target>
        </trans-unit>
        <trans-unit id="093f2fea111647ab73586789136bb3d0d4a0950c" translate="yes" xml:space="preserve">
          <source>Implementation-defined accept condition</source>
          <target state="translated">実装で定義された受け入れ条件</target>
        </trans-unit>
        <trans-unit id="3d29bb9dbd4be0c211a42d389e2c3292fd50b3aa" translate="yes" xml:space="preserve">
          <source>Implementation-defined display condition</source>
          <target state="translated">実装で定義された表示条件</target>
        </trans-unit>
        <trans-unit id="3d3ffee367a47df22f0329d2161f7179c7140f49" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to CITY as&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;</source>
          <target state="translated">この問題を修正するために、CITYへの参照を &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; として修飾することができます。</target>
        </trans-unit>
        <trans-unit id="1132a1566c2ed19e4f36c07a65dd3752e2bf4c83" translate="yes" xml:space="preserve">
          <source>In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.</source>
          <target state="translated">複数の演算子とオペランドで構成される複雑な式では、より高い優先順位を持つ演算が、より低い優先順位を持つ演算よりも先に計算されるように、演算の優先順位が適用されます。</target>
        </trans-unit>
        <trans-unit id="67cd2a991339c0db61eccf443f46cb731b97b13e" translate="yes" xml:space="preserve">
          <source>In either instance, program &quot;A&quot; is referred to as the &amp;rsquo;</source>
          <target state="translated">どちらの場合も、プログラム「A」は「</target>
        </trans-unit>
        <trans-unit id="b68b4bcf151b57e71e554fe7952a0e73619a414f" translate="yes" xml:space="preserve">
          <source>In general, each picture symbol represents either a single character in storage or a single decimal digit. There are a few exceptions, and they will be discussed as needed.</source>
          <target state="translated">一般的に、各ピクチャシンボルは、保存されている1文字または10進数の1桁を表します。いくつかの例外があり、必要に応じて説明します。</target>
        </trans-unit>
        <trans-unit id="2411df7c12420101004e143cb3943a4101a56bf7" translate="yes" xml:space="preserve">
          <source>In general, table references such as example #1 (constant subscript) generate the smallest, simplest and fastest object code while table references such as example #2 (numeric data item subscript) generate the largest, most-complicated and slowest object code.</source>
          <target state="translated">一般的に、例1(定数添字)のようなテーブル参照は、最小で最も単純かつ最速のオブジェクト・コードを生成し、例2(数値データ項目添字)のようなテーブル参照は、最大で最も複雑かつ最速のオブジェクト・コードを生成します。</target>
        </trans-unit>
        <trans-unit id="9f3d74011ccc810b1770ab4e3dfbc7f8f1fdf305" translate="yes" xml:space="preserve">
          <source>In highest to lowest order of precedence, here is a discussion of each category of operation:</source>
          <target state="translated">ここでは、優先順位の高い順から低い順に、それぞれの操作カテゴリについて説明します。</target>
        </trans-unit>
        <trans-unit id="37e03fd035bc729f5e1bac261783ab6dc96b9a08" translate="yes" xml:space="preserve">
          <source>In order for &amp;lt;</source>
          <target state="translated">のために&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6bb3bbadc2d27138c4c9dae5d396fb6f7ddc8694" translate="yes" xml:space="preserve">
          <source>In order for a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="36616f50c54eeaba783ad05be353c37e7580b497" translate="yes" xml:space="preserve">
          <source>In order for this clause to take effect at execution time, the user must move the cursor into the field having this clause in its definition.</source>
          <target state="translated">この句が実行時に有効になるためには、ユーザはこの句の定義にあるフィールドにカーソルを移動させなければならない。</target>
        </trans-unit>
        <trans-unit id="d4cc191768c1993e9df309f3f21d935b4723ece5" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">このステートメントが機能するためには、 &lt;code&gt;-ftrace&lt;/code&gt; スイッチのいずれかを使用して、トレースコードがコンパイル済みプログラムに生成されている必要があります。</target>
        </trans-unit>
        <trans-unit id="d5716d69487d7213f5a154886aec1d579f1359df" translate="yes" xml:space="preserve">
          <source>In order for&lt;code&gt;AND&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AND&lt;/code&gt; のために</target>
        </trans-unit>
        <trans-unit id="12840b41d70472b409489727335424ef0070e853" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;EMPTY-CHECK&lt;/code&gt;</source>
          <target state="translated">機能するためには、この属性は、GnuCOBOL実装の構築に使用された基礎となる「curses」パッケージによってサポートされている必要があります。現時点では、「PDCurses」パッケージ（ネイティブWindowsまたはMinGWビルドに使用）は &lt;code&gt;EMPTY-CHECK&lt;/code&gt; をサポートしていません</target>
        </trans-unit>
        <trans-unit id="17d285867c49f9dd90eb1f27cf9c7a60d1e38df8" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;FULL&lt;/code&gt;</source>
          <target state="translated">機能するためには、この属性は、GnuCOBOL実装の構築に使用された基礎となる「curses」パッケージによってサポートされている必要があります。現時点では、「PDCurses」パッケージ（ネイティブWindowsまたはMinGWビルドに使用）は &lt;code&gt;FULL&lt;/code&gt; をサポートしていません</target>
        </trans-unit>
        <trans-unit id="0a81aca05eb7b3e3ebeefcb93bfd42b8a77e381a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;LENGTH-CHECK&lt;/code&gt;</source>
          <target state="translated">機能するためには、この属性は、GnuCOBOL実装の構築に使用された基礎となる「curses」パッケージによってサポートされている必要があります。現時点では、「PDCurses」パッケージ（ネイティブWindowsまたはMinGWビルドに使用）は &lt;code&gt;LENGTH-CHECK&lt;/code&gt; をサポートしていません</target>
        </trans-unit>
        <trans-unit id="de32275ede835ac63170073ab2d665b3951078da" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;REQUIRED&lt;/code&gt;</source>
          <target state="translated">機能するためには、この属性は、GnuCOBOL実装の構築に使用された基礎となる「curses」パッケージによってサポートされている必要があります。現時点では、「PDCurses」パッケージ（ネイティブWindowsまたはMinGWビルドに使用）は &lt;code&gt;REQUIRED&lt;/code&gt; サポートしていません</target>
        </trans-unit>
        <trans-unit id="8ea48fcaef90024e13873585a7560dd9b545d9d4" translate="yes" xml:space="preserve">
          <source>In order to take effect, the user must first move the cursor into the field having this clause in its definition.</source>
          <target state="translated">有効にするためには、ユーザーはまず、定義にこの句があるフィールドにカーソルを移動しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c1ff1f707da403375eb5aac3df8097ce50066a1d" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons &lt;code&gt;;&lt;/code&gt; are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand&lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; but it&amp;rsquo;s another story entirely when trying to comprehend&lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt;(instead of&lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;. The compiler accepts it, but too much of this would make</source>
          <target state="translated">上記の例では、2つの添え字値の間の区切り文字としてコンマが使用されています。セミコロン &lt;code&gt;;&lt;/code&gt; スペースと同様に、添え字の区切り文字も有効です！このような状況でのコンマまたはセミコロンの区切り文字の使用は技術的にオプションですが、慣例により、ほとんどのCOBOLプログラマーはどちらか一方を使用します。区切り文字なし（スペース以外）の使用は、構文的には正しいものの、推奨されません。これを行うと、プログラマーにとって扱いにくいコードが作成される可能性があるためです。 &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; 3）を読んで理解することはそれほど難しいことではありませんが、GRID-CHARACTER（I + 1 J / 3）を理解しようとするときはまったく別の話です（ &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; ではなく）3）。コンパイラはそれを受け入れますが、これが多すぎると、</target>
        </trans-unit>
        <trans-unit id="ab0a8c97ecdd65110e9781dbe9e9bcdabaa33882" translate="yes" xml:space="preserve">
          <source>In the absence of the&lt;code&gt;OVERRIDE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OVERRIDE&lt;/code&gt; がない場合</target>
        </trans-unit>
        <trans-unit id="be9ad81756c2c029daadb7f85dc6de13011d4872" translate="yes" xml:space="preserve">
          <source>In the case of the former, the&lt;code&gt;USING&lt;/code&gt;clause on the procedure division header should describe the argument via the&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">前者の場合、手続き部のヘッダーの &lt;code&gt;USING&lt;/code&gt; 句は &lt;code&gt;BY REFERENCE&lt;/code&gt; を介して引数を説明する必要があります</target>
        </trans-unit>
        <trans-unit id="3683f2272e68eee3328548bbf75c6cbed2e45e7d" translate="yes" xml:space="preserve">
          <source>In the late 70&amp;rsquo;s cards was also on its way out to the point where P.C&amp;rsquo;s started being used (and no they were not made by IBM), so these columns could be used for other purposes including cc 73 - 80 instead of indicating the 8 character program name which was the maximum size allowed on a IBM system.</source>
          <target state="translated">70年代後半には、PCが使用されるようになるまで（そして、IBMによって作成されたわけではありません）、カードはcc 73から80を含む他の目的に使用できるようになりました。 IBMシステムで許可されている最大サイズである8文字のプログラム名。</target>
        </trans-unit>
        <trans-unit id="82849a227b43e92353f440e6cf481dde7d3eb800" translate="yes" xml:space="preserve">
          <source>In this case, the&lt;code&gt;EXIT&lt;/code&gt;statement takes no other run-time action.</source>
          <target state="translated">この場合、 &lt;code&gt;EXIT&lt;/code&gt; ステートメントは他の実行時アクションを実行しません。</target>
        </trans-unit>
        <trans-unit id="2a9d1dc97c6798126e8a06dda35c75cc92d21220" translate="yes" xml:space="preserve">
          <source>In this context,&lt;code&gt;VALUE&lt;/code&gt;specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">このコンテキストでは、 &lt;code&gt;VALUE&lt;/code&gt; は、コンパイラーによって生成されたプログラムオブジェクトコード内のデータ項目が占めるストレージに割り当てられる初期コンパイル時の値を指定します。</target>
        </trans-unit>
        <trans-unit id="84cb1e4aa0b378b3db93b48860594751f6ae285f" translate="yes" xml:space="preserve">
          <source>In this example, all six&lt;code&gt;A&lt;/code&gt;items will be initialized to &quot;?&quot;, all six&lt;code&gt;B&lt;/code&gt;items will be initialized to &quot;%&quot; and all six&lt;code&gt;N&lt;/code&gt;items will be initialized to 10. It&amp;rsquo;s not clear exactly how many times this sort of initialization will be useful, but it&amp;rsquo;s there if you need it.</source>
          <target state="translated">この例では、6つの &lt;code&gt;A&lt;/code&gt; アイテムすべてが「？」に初期化され、6つの &lt;code&gt;B&lt;/code&gt; アイテムすべてが「％」に初期化され、6つの &lt;code&gt;N&lt;/code&gt; アイテムすべてが10に初期化されます。この種類の初期化が何回行われるかは正確にはわかりません便利ですが、必要に応じて表示されます。</target>
        </trans-unit>
        <trans-unit id="2879e2f56bb5d870554e86f04a4bf9ebe7fb4ed9" translate="yes" xml:space="preserve">
          <source>In this example, the IF statement actually has a scope that can include two sets of associated statements &amp;ndash; one set to be executed when the&lt;code&gt;IF&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is TRUE and another if it is FALSE.</source>
          <target state="translated">この例では、IF文は、実際には、関連する書類の二組を含むことができる範囲を有している-一組を実行するときに &lt;code&gt;IF&lt;/code&gt; （参照&lt;a href=&quot;#IF&quot;&gt;IFを&lt;/a&gt;、それがFALSEである場合）の条件がTRUEと別です。</target>
        </trans-unit>
        <trans-unit id="b671b6f79a2badfb5c4ccb993eb5f1ff2485bd4c" translate="yes" xml:space="preserve">
          <source>In which case 9 characters of storage will be reserved. The values 000000000 through 999999999 will represent the gross-revenues. But, if only the millions are tracked (meaning the last six digits are always going to be 0), you could define the field as:</source>
          <target state="translated">この場合、9文字のストレージが予約されます。000000000 から 999999999 までの値が総収入を表します。しかし、もし数百万だけが追跡されている場合(最後の6桁が常に0になることを意味します)、このフィールドを次のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="6178a2fcb450efe4624273996659b2d5392d26b6" translate="yes" xml:space="preserve">
          <source>Include the reserved word&lt;code&gt;FINAL&lt;/code&gt;</source>
          <target state="translated">予約語 &lt;code&gt;FINAL&lt;/code&gt; を含める</target>
        </trans-unit>
        <trans-unit id="4587868819f3914fb0d960b2a017af52903b843c" translate="yes" xml:space="preserve">
          <source>Including an&lt;code&gt;ON SIZE ERROR&lt;/code&gt;clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">算術ステートメントに &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 句を含めると、プログラムは算術ステートメントの失敗をトラップし（受信フィールドに対して大きすぎる結果を生成するか、ゼロで除算しようとします）、&amp;lt;を実行して正常に処理します。</target>
        </trans-unit>
        <trans-unit id="2ec9e5e5288405f63d74272e4e8bcad544b64e15" translate="yes" xml:space="preserve">
          <source>Incompatible data exception</source>
          <target state="translated">互換性のないデータの例外</target>
        </trans-unit>
        <trans-unit id="e0049c7018b06d02f3c0ba2245a0ee83c74d7cc7" translate="yes" xml:space="preserve">
          <source>Inconsistent filename</source>
          <target state="translated">矛盾したファイル名</target>
        </trans-unit>
        <trans-unit id="e5d727021f58d38c370cf7243256d9dff80ee53f" translate="yes" xml:space="preserve">
          <source>Independent Subprograms</source>
          <target state="translated">独立したサブプログラム</target>
        </trans-unit>
        <trans-unit id="0e0834dadd433c69c101f415ef11e7aef2f4805a" translate="yes" xml:space="preserve">
          <source>Indexed files are processed using the following statements:</source>
          <target state="translated">インデックス化されたファイルは、以下のステートメントを使用して処理されます。</target>
        </trans-unit>
        <trans-unit id="9353f9003cee9268ec86b3a1ea7f4d4ecb16eb1c" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;INDEX&lt;/code&gt;to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">インデックス付けは、明示的または暗黙的に定義された &lt;code&gt;USAGE&lt;/code&gt; （&lt;a href=&quot;#USAGE&quot;&gt;USAGEを&lt;/a&gt;参照）の &lt;code&gt;INDEX&lt;/code&gt; でデータ項目を利用してテーブルの要素を参照し、目的のオカレンスを選択するプロセスです。</target>
        </trans-unit>
        <trans-unit id="a6c6b82216692a3106690069e47ca45a2e70d92d" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a&lt;code&gt;VALUE&lt;/code&gt;clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">次のように、テーブルの親として機能するグループ項目に &lt;code&gt;VALUE&lt;/code&gt; 句を含めることにより、コンパイル時に小さなテーブルを初期化します。</target>
        </trans-unit>
        <trans-unit id="24b3196c683087c1c3199428c0580a1c1d58213b" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the&lt;code&gt;REDEFINES&lt;/code&gt;(see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">&lt;code&gt;REDEFINES&lt;/code&gt; （&lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINESを&lt;/a&gt;参照）句を使用して、コンパイル時にほぼすべてのサイズのテーブルを初期化します。</target>
        </trans-unit>
        <trans-unit id="2fec9ecf2a45eb0fd0af8f70fdb0cee7e4377f3b" translate="yes" xml:space="preserve">
          <source>Inline PERFORM Syntax</source>
          <target state="translated">インラインPERFORM構文</target>
        </trans-unit>
        <trans-unit id="bc36d8128c5a1e8ca8d8c4f2854d174a361c1c90" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&quot;_&quot;) will be assumed.</source>
          <target state="translated">入力フィールドは、任意の文字を塗りつぶし文字として使用することができます。これらの塗りつぶし文字は入力フィールドのサイズを視覚的に示すものであり、入力フィールドがプログラムによって処理されるときに自動的にスペースに変換される。入力フィールドにそのような文字が定義されていない場合、アンダースコア(&quot;_&quot;)が想定されます。</target>
        </trans-unit>
        <trans-unit id="d4fe42447823ec3b9e2e9421bf9fdef259cf35f1" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window &lt;code&gt;CONSOLE&lt;/code&gt; or from the system-standard input (pipe 0 =&lt;code&gt;STDIN&lt;/code&gt;&lt;code&gt;SYSIN&lt;/code&gt;or&lt;code&gt;SYSIPT&lt;/code&gt; and will be saved in &amp;lt;</source>
          <target state="translated">入力は、コンソールウィンドウ &lt;code&gt;CONSOLE&lt;/code&gt; またはシステム標準入力（パイプ0 = &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;SYSIN&lt;/code&gt; または &lt;code&gt;SYSIPT&lt;/code&gt; )から読み取られ、&amp;lt;に保存されます。</target>
        </trans-unit>
        <trans-unit id="11b11dadbac78c35efb5d86e561bfcff60c6701b" translate="yes" xml:space="preserve">
          <source>Integer and non-integer operands may be freely intermixed</source>
          <target state="translated">整数と非整数のオペランドは自由に混在させることができます。</target>
        </trans-unit>
        <trans-unit id="8626f5223c37139c00a44d21c18f768de6e8df20" translate="yes" xml:space="preserve">
          <source>Integers such as 1, 56, 2192 or -54.</source>
          <target state="translated">1、56、2192、-54などの整数。</target>
        </trans-unit>
        <trans-unit id="d47bc2c05ec93f214d2f93848b03eba3a04ff0c4" translate="yes" xml:space="preserve">
          <source>Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any DBMS, Transaction Processing platforms, Queue-Management facilities and other programming languages.</source>
          <target state="translated">XML、SOA、MQ、ほとんどのDBMS、トランザクション処理プラットフォーム、キュー管理機能、その他のプログラミング言語など、COBOL以外のインフラストラクチャとの統合が可能です。</target>
        </trans-unit>
        <trans-unit id="8b3eb3d9c05dbc205b027a6d0771b0af833c1b89" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the command shell &quot;window&quot;.</source>
          <target state="translated">プログラムとユーザ間の相互作用は、標準入力、標準出力、標準エラーストリームを使用して行われます。プログラムによって実行されるスクリーンセクションのI/Oは、コマンドシェルの「ウィンドウ」内で行われます。</target>
        </trans-unit>
        <trans-unit id="4004bbedc882730cd7377c55c8a60c3d77d841f3" translate="yes" xml:space="preserve">
          <source>Intrinsic Function</source>
          <target state="translated">本質的機能</target>
        </trans-unit>
        <trans-unit id="3afb87dd54b38fa7410a22ca94bf84568bc6f936" translate="yes" xml:space="preserve">
          <source>Is there a data item named&lt;code&gt;C-D&lt;/code&gt;defined? If so, use its value for the character sequence&lt;code&gt;C-D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C-D&lt;/code&gt; という名前のデータ項目が定義されていますか？その場合、その値を文字シーケンス &lt;code&gt;C-D&lt;/code&gt; に使用します。</target>
        </trans-unit>
        <trans-unit id="b2a3023db707fff296813396a984d683cabd59f0" translate="yes" xml:space="preserve">
          <source>It is also possible to create source files where GnuCOBOL programs are nested inside each other. Take for example these four GnuCOBOL programs:</source>
          <target state="translated">また、GnuCOBOLプログラムが互いに入れ子になっているソースファイルを作成することも可能です。例えば、以下の4つのGnuCOBOLプログラムを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="84300e8f98a0f3852c30d9579e7c60614ed0dbd3" translate="yes" xml:space="preserve">
          <source>It is expected that:</source>
          <target state="translated">と予想されています。</target>
        </trans-unit>
        <trans-unit id="6c528e93ea46610dc90b04c262c6d8a0c4d80f39" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; スイッチの使用を選択することにより、サブプログラムだけでなく、すべてのGnuCOBOLプログラムの実行可能モジュールを生成できます。</target>
        </trans-unit>
        <trans-unit id="fd71df406ad79246a83a283db27a4507793dc703" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the&lt;code&gt;-ffold-call&lt;/code&gt;switch</source>
          <target state="translated">ただし、 &lt;code&gt;-ffold-call&lt;/code&gt; スイッチを指定することにより、すべてのライブラリー名を自動的に大文字に変換することができます。</target>
        </trans-unit>
        <trans-unit id="0f5ff5b5b0cc8eb3a5f026f5c68c2c34d3dd2e58" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all&lt;code&gt;COPY&lt;/code&gt;statements to &amp;rsquo;fold&amp;rsquo; the names of all copybooks to upper-case by specifying the&lt;code&gt;-ffold-copy&lt;/code&gt;switch</source>
          <target state="translated">ただし、 &lt;code&gt;-ffold-copy&lt;/code&gt; スイッチを指定することにより、すべての &lt;code&gt;COPY&lt;/code&gt; ステートメントですべてのコピーブックの名前を大文字に自動的に「折りたたむ」ことができます。</target>
        </trans-unit>
        <trans-unit id="8d95a0b3b4408000436885116c035d2b4d4eb090" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the &quot;curses&quot; package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">使用している &quot;curses&quot; パッケージがサポートしていれば、フィールドの上端、左端、下端に境界線を描くことが可能です。</target>
        </trans-unit>
        <trans-unit id="7d7394694e1e1adbaef5eeee92d5a9373e538bc3" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatability as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">CBL_OCルーチンをCBL_GCに変更することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4bc4bb06183a156efac27d1054572b8c27c65421" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that if the</source>
          <target state="translated">の場合は言及する価値があります。</target>
        </trans-unit>
        <trans-unit id="18a80c8fa72d80aad7d81f986d63eacc53ab4b98" translate="yes" xml:space="preserve">
          <source>It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">プログラムで定義されたレコードサイズに基づいて開始文字位置を計算するだけで、ファイル内の任意のレコードを直接見つけて処理することが可能であるように思われます。しかし、そうであっても、レコードは純粋に連続した方法でこれらのファイルに読み書きされなければなりません。レコード番号100を読み込む(または書き込む)唯一の方法は、最初にレコード番号1から99までのレコードを読み込む(または書き込む)ことです。</target>
        </trans-unit>
        <trans-unit id="6d1a9ad994fd74f3ea9c0abfcfff5c67eb069908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the&lt;code&gt;SET UP/DOWN&lt;/code&gt;statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a&lt;code&gt;SET Index&lt;/code&gt;statement.</source>
          <target state="translated">それが直接指標データ項目に対して任意の演算を実行することは不可能です（VIA単純なインクリメント又はデクリメント操作以外の &lt;code&gt;SET UP/DOWN&lt;/code&gt; のステートメント（参照&lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt;））。テーブル参照の有効オカレンス数を計算するために重要な計算が必要な状況では、計算の受け取りフィールドとして従来の編集されていない数値データ項目を使用する必要があります。その計算された値は、 &lt;code&gt;SET Index&lt;/code&gt; ステートメントを介してインデックスデータ項目に保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="48149098c4b72f980cb6ef484a18559b6952ecbd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably a true that an IT professional can no longer afford to allow COBOL to be the</source>
          <target state="translated">ITプロフェッショナルがCOBOLになることを許可する余裕がなくなったのは、おそらく本当でしょう。</target>
        </trans-unit>
        <trans-unit id="02387685edacc74ddafb8999ab4d02ea233cee8c" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &amp;lt;&amp;lt;</source>
          <target state="translated">構文図内の大/小文字混合で表示される項目は、その位置に表示される可能性がある他の構文要素の複雑な句を表します。一部のCOBOL構文は非常に複雑になり、このような規則を使用すると、構文図の複雑さが大幅に軽減されます。このようなアイテムがテキストで参照されている場合、それらは&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="56625773bdd51fd820fa786a2e0f16b75e88d894" translate="yes" xml:space="preserve">
          <source>JUST, JUSTIFIED</source>
          <target state="translated">ただ、正当化された</target>
        </trans-unit>
        <trans-unit id="362a2940964523b043977ef5c326c0da3c417c71" translate="yes" xml:space="preserve">
          <source>JUSTIFIED Attribute Syntax</source>
          <target state="translated">JUSTIFIED 属性構文</target>
        </trans-unit>
        <trans-unit id="69d7203c7ddac97c0f7dbb23cc2fe036c4f8c92f" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does&lt;code&gt;AND&lt;/code&gt;take precedence over&lt;code&gt;OR&lt;/code&gt;in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">算術式で乗算が加算より優先されるのと同様に、結合された条件で &lt;code&gt;AND&lt;/code&gt; が &lt;code&gt;OR&lt;/code&gt; より優先されます。必要に応じて、括弧を使用してこの優先順位を変更してください。例えば：</target>
        </trans-unit>
        <trans-unit id="7d13eab767d2368877889bd7045a0a16db421d69" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &quot;procedural&quot; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">COBOLが伝統的にオブジェクトやクラスなどをサポートしていないからといって、コンピューティングへの「手続き的」アプローチが価値がないというわけではありません。</target>
        </trans-unit>
        <trans-unit id="eab1ffaceb7e528d02f388bc4a44de1ac999f956" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more&lt;code&gt;KEY&lt;/code&gt;clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">テーブルに1つ以上の &lt;code&gt;KEY&lt;/code&gt; 句があるからといって、データが実際に</target>
        </trans-unit>
        <trans-unit id="c2d43141ba675c34b7c1d27c2a20a48306114ad6" translate="yes" xml:space="preserve">
          <source>Justifying a field left-, right- or center-aligned</source>
          <target state="translated">フィールドの左揃え、右揃え、中央揃えの正当化</target>
        </trans-unit>
        <trans-unit id="84f38d3f20c7775e2217cde20dd53b4fca4c4de9" translate="yes" xml:space="preserve">
          <source>KEPT, KEY, KEYBOARD</source>
          <target state="translated">キープ、キー、キーボード</target>
        </trans-unit>
        <trans-unit id="a1abb8bae6a20d6d2a3d297fadb85dbb06f153f7" translate="yes" xml:space="preserve">
          <source>Key invalid</source>
          <target state="translated">キーが無効</target>
        </trans-unit>
        <trans-unit id="0dca24f2a9944795f9d4824194f21fc80ddaa094" translate="yes" xml:space="preserve">
          <source>Key not found</source>
          <target state="translated">キーが見つからない</target>
        </trans-unit>
        <trans-unit id="b27d585a06f48010c011f378dec6cda9ce6fe385" translate="yes" xml:space="preserve">
          <source>LABEL. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINAGE-COUNTER, LINE, LINE-COUNTER, LINES, LINKAGE, LOCALE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME, LOCALE-TIME-FROM-SECONDS, LOCAL-STORAGE, LOCK, LOG, LOG10, LOWER, LOWER-CASE, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUE, LOW-VALUES</source>
          <target state="translated">LABEL.last,lc_all,lc_collate,lc_ctype,lc_messages,lc_monetary,lc_numeric,lc_time,leading,left,left-justify,leftline,length,length-an,length-check,less,limit,limits,linage,linage-counter,line.line-counter、line、linkage、locale、locale-compare、local-date、local-time、local-time-from-seconds、local-storage、lock、log、log10、lower、小文字、最低代数、lowlight、低値、低値、低値</target>
        </trans-unit>
        <trans-unit id="f7adab25c99ba32828c8334645ed0e592317c0dd" translate="yes" xml:space="preserve">
          <source>LEFTLINE Attribute Syntax</source>
          <target state="translated">LEFTLINE 属性構文</target>
        </trans-unit>
        <trans-unit id="131342f51da66f70ac3d8ad3a42ad6266e7cfe09" translate="yes" xml:space="preserve">
          <source>LENGTH Function Syntax</source>
          <target state="translated">LENGTH 関数構文</target>
        </trans-unit>
        <trans-unit id="d74d405b72ac688357a94ddb91f3bd1d36b38a48" translate="yes" xml:space="preserve">
          <source>LENGTH OF Syntax</source>
          <target state="translated">構文の長さ</target>
        </trans-unit>
        <trans-unit id="a6c3bbbb104612f77a62807c2c1de5109220484e" translate="yes" xml:space="preserve">
          <source>LENGTH-AN Function Syntax</source>
          <target state="translated">LENGTH-AN 関数構文</target>
        </trans-unit>
        <trans-unit id="954f779688b59664bc2c0157a1a346f68764ce28" translate="yes" xml:space="preserve">
          <source>LENGTH-CHECK Attribute Syntax</source>
          <target state="translated">LENGTH-CHECK 属性構文</target>
        </trans-unit>
        <trans-unit id="700c1989f8b190ed7e6537ef207d774a560d050f" translate="yes" xml:space="preserve">
          <source>LINE (REPORT SECTION) Clause Syntax</source>
          <target state="translated">LINE(レポートセクション)節構文</target>
        </trans-unit>
        <trans-unit id="e8f4389c48575a281e9f925b390e924cf0c4233d" translate="yes" xml:space="preserve">
          <source>LINE (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">LINE(SCREEN SECTION)節の構文</target>
        </trans-unit>
        <trans-unit id="e4f2ff384d74fc8578647b7045a783150209d9b6" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item</source>
          <target state="translated">LINKAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="6c615d91fc665579223c013c286410416b6e1014" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">リンケージセクション-データ項目構文</target>
        </trans-unit>
        <trans-unit id="de80fa7cc22fe7bc720ec1f880b19a375e416fad" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="7aaab284fb19784decbd8f8b27788cee676e6312" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">LOCAL-STORAGE-SECTION-データ項目の構文</target>
        </trans-unit>
        <trans-unit id="43137ffee30418f0ee2f9cddfdfde852be8ee37f" translate="yes" xml:space="preserve">
          <source>LOCALE-COMPARE Function Syntax</source>
          <target state="translated">LOCALE-COMPARE 関数構文</target>
        </trans-unit>
        <trans-unit id="b1fca96794478203376fc5f182a5206a1cd9879a" translate="yes" xml:space="preserve">
          <source>LOCALE-DATE Function Syntax</source>
          <target state="translated">LOCALE-DATE 関数構文</target>
        </trans-unit>
        <trans-unit id="bb3ee280b5397e14e50725a5217c3a5d3ba477ce" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME Function Syntax</source>
          <target state="translated">LOCALE-TIME 関数構文</target>
        </trans-unit>
        <trans-unit id="5471c4a61062a5428ab007db0990af8c067fcb5d" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME-FROM-SECONDS Function Syntax</source>
          <target state="translated">LOCALE-TIME-FROM-SECONDS 関数構文</target>
        </trans-unit>
        <trans-unit id="37c5bf8af77ce9710567f4d33ea9e7df839040cc" translate="yes" xml:space="preserve">
          <source>LOG Function Syntax</source>
          <target state="translated">LOG 関数構文</target>
        </trans-unit>
        <trans-unit id="9192c8decf1f9c720375df3f6fa03e112ff20e88" translate="yes" xml:space="preserve">
          <source>LOG10 Function Syntax</source>
          <target state="translated">LOG10 関数構文</target>
        </trans-unit>
        <trans-unit id="ee7e6e2ad53ef8f056736d307514898fdd404c69" translate="yes" xml:space="preserve">
          <source>LOWER-CASE Function Syntax</source>
          <target state="translated">LOWER-CASE 関数構文</target>
        </trans-unit>
        <trans-unit id="439e85988349d2d4d56bcd162fc79031cbfe5293" translate="yes" xml:space="preserve">
          <source>LOWEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">LOWEST-ALGEBRAIC 関数構文</target>
        </trans-unit>
        <trans-unit id="a8456caa490bee9c2c0be989a83696a4f186cc13" translate="yes" xml:space="preserve">
          <source>LOWLIGHT Attribute Syntax</source>
          <target state="translated">LOWLIGHT 属性構文</target>
        </trans-unit>
        <trans-unit id="b77f5ed95a31f852095a500e8931cb13a5b9471b" translate="yes" xml:space="preserve">
          <source>Language DIVISION, SECTION and paragraph section headers must begin in Area A, as must the level numbers 01, 77 in data description entries and the &quot;FD&quot; and &quot;SD&quot; file and SORT description headers.</source>
          <target state="translated">言語DIVISION、SECTIONおよび段落セクションのヘッダは、データ記述エントリのレベル番号01、77、および &quot;FD &quot;および &quot;SD &quot;ファイルおよびSORT記述ヘッダと同様に、エリアAで開始しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1882dc6a1967f34bbac58b9f9a979e4a9b63398b" translate="yes" xml:space="preserve">
          <source>Later, when you wish to compile a calling program and combine any needed assembly language subroutines in (as static subroutines &amp;mdash; see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;), use a command such as this:</source>
          <target state="translated">後で、呼び出し側プログラムをコンパイルし、必要なアセンブリ言語サブルーチンを（静的サブルーチンとして- &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;動的サブプログラムと静的サブプログラムを&lt;/a&gt;参照）結合する場合は、次のようなコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="66985c4b56238cdffd3d626011e0ae9656911e65" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.</source>
          <target state="translated">先頭および/または末尾のスペースは、記号の前および/または後にスペースを入れても構いません。</target>
        </trans-unit>
        <trans-unit id="0ff8a66126e2608d00693ba8dd0efcf5b6c8473c" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.</source>
          <target state="translated">通貨記号、記号、CR、DB文字の前後にスペースを入れても構いません。</target>
        </trans-unit>
        <trans-unit id="13235fcc87f3e6e8669414dd697a803db485fc34" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.</source>
          <target state="translated">先頭および/または末尾のスペースは、符号の前および/または後のスペース、CRおよびDB文字と同様に許可されています。</target>
        </trans-unit>
        <trans-unit id="6d1192545a490f725efd7534bb1ad77133927978" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &quot;written&quot; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&quot;reuse&quot; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &quot;code re-usability&quot; is one of the arguments used to justify the existence of the &quot;modern&quot; languages.</source>
          <target state="translated">凡例によると、実際にはCOBOLで記述されたプログラムは1つしかなく、その後「記述」されたすべてのプログラムは単にそのプログラムの派生物でした。これは明らかに（おそらく）悪い冗談として意図されていますが、それでも、多くのプログラマーが新しいプログラムを作成するときに既存のCOBOLプログラムを「再利用」するという非常に単純な真実に近いものです。これが他の言語で書かれたプログラムで発生するのを妨げるものは確かにありませんが、COBOLショップで発生するようです。 「コードの再利用性」が「現代」の言語の存在を正当化するために使用される議論の1つであることは皮肉なことです。</target>
        </trans-unit>
        <trans-unit id="0b3fb64877d0da3cc80aa54b2402a8b8eaf24bde" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a different problem. Surely a program that asks a user to input a positive integer, generates the sum of all positive integers from 1 to that number and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?</source>
          <target state="translated">別の問題を見てみましょう。確かに、ユーザーに正の整数の入力を求め、1からその数までのすべての正の整数の合計を生成し、その結果を出力するプログラムは、COBOLよりもJavaでコーディングした方がはるかに短く、理解しやすいでしょう。</target>
        </trans-unit>
        <trans-unit id="26e5808de92654f265239c37c8e3bd7a273163fd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &quot;wordy&quot; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is actually optional. Clearly, &quot;Hello World&quot; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">Javaよりも「長文」のCOBOLの方がはるかに多いことを見てみましょう。2つのプログラムの文字を数えます。Javaプログラムには95があります（キャリッジリターンとインデントは含まれません）。COBOLプログラムには89（改行とインデントは含まない）があります。技術的には、 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; ため、65でしかなかった可能性があります。ヘッダーは実際にはオプションです。明らかに、「Hello World」は、COBOLの場合よりもJavaの場合の方が簡潔に見えません。</target>
        </trans-unit>
        <trans-unit id="963bbbacb61f8751db91170e221a486a9a4d3b42" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &quot;grid&quot; defined by the above structure has these values:</source>
          <target state="translated">上記の構造で定義された3x4の「グリッド」に次の値があるとします。</target>
        </trans-unit>
        <trans-unit id="807ef358de181fc6f5a56bc69f36677531a8d93e" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification &lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;with a single argument)</source>
          <target state="translated">レベル1（最高）&amp;mdash;単項符号仕様 &lt;code&gt;+&lt;/code&gt; および &lt;code&gt;-&lt;/code&gt; 単一の引数付き）</target>
        </trans-unit>
        <trans-unit id="c0776e45f0a30777bc589139ec70ff962e33c83c" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation &lt;code&gt;**&lt;/code&gt;or&lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">レベル2 &amp;mdash;べき乗 &lt;code&gt;**&lt;/code&gt; または &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d3eb2924374b17ead104f2e6704337373d534b" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication &lt;code&gt;*&lt;/code&gt; and division &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">レベル3 &amp;mdash;乗算 &lt;code&gt;*&lt;/code&gt; および除算 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c7a53b8aaf3b4d3d4c40f9ab98b835416a16f8" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition &lt;code&gt;+&lt;/code&gt; or subtraction &lt;code&gt;+&lt;/code&gt;</source>
          <target state="translated">レベル4 &amp;mdash;加算 &lt;code&gt;+&lt;/code&gt; または減算 &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5597f96dc9d80c27ec5e33857991562ca948cabc" translate="yes" xml:space="preserve">
          <source>Level Number</source>
          <target state="translated">レベル番号</target>
        </trans-unit>
        <trans-unit id="3052fa9dd47259fbdfdaada2330b8f6e3cbdd9ac" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 all have special uses &amp;mdash; See &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;, for details.</source>
          <target state="translated">レベル番号66、77、78、88にはすべて特別な用途があります。詳細については、「&lt;a href=&quot;#Special-Data-Items&quot;&gt;特別なデータ項目&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="c40b4c76be763282435e76a210c233701e5f2f23" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 identify special properties of a data description entry.</source>
          <target state="translated">レベル番号66、77、78、88は、データ記述エントリの特別なプロパティを識別します。</target>
        </trans-unit>
        <trans-unit id="f058b290679bb97e2e65e2ade8e908cf0471986c" translate="yes" xml:space="preserve">
          <source>Level numbers in the range 1 through 49 indicate the position of a data item in the hierarchical structure of a logical record. Level numbers in the range 1 through 9 can be written either as a single digit or as a zero followed by the significant digit.</source>
          <target state="translated">1 から 49 までの範囲のレベル番号は、論理レコードの階層構造におけるデータ項目の位置を示します。1 から 9 までの範囲のレベル番号は、1 つの数字として、またはゼロの後に有効数字を続けて書くことができます。</target>
        </trans-unit>
        <trans-unit id="0d0db8c2b020268e4b2e48ddcbb42e59195d905a" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU Free Documentation License.</source>
          <target state="translated">GNUフリー・ドキュメンテーション・ライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="1c7be671b82e536f670976ec80f415fa5dd43afc" translate="yes" xml:space="preserve">
          <source>Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">行順ファイルと同様に、これらのファイルには、正確なバイナリデータフィールドが含まれるように定義しないでください。これらのフィールドの内容には、誤ってレコードの終わりのシーケンスが値の一部として含まれる可能性があるため、ランタイムシステムがファイルを読み取るときに混乱します。 、そしてその値を実際のレコード終了シーケンスとして解釈します。</target>
        </trans-unit>
        <trans-unit id="57489ee4e43a2ed5c736dd719377be4582a70ea3" translate="yes" xml:space="preserve">
          <source>Like most other implementations of the COBOL language, GnuCOBOL utilizes a run-time library. When the first program executed in a given execution sequence is a GnuCOBOL program, any run-time library initialization will be performed by the compiled COBOL code in a manner that is transparent to the C-language programmer. If, however, a C program is the first to execute, the burden of performing GnuCOBOL run-time library initialization falls upon the C program. See &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C Main Programs Calling GnuCOBOL Subprograms&lt;/a&gt;, for an example of how to do this.</source>
          <target state="translated">COBOL言語の他のほとんどの実装と同様に、GnuCOBOLはランタイムライブラリを利用します。特定の実行シーケンスで実行される最初のプログラムがGnuCOBOLプログラムである場合、ランタイムライブラリの初期化は、C言語のプログラマーには透過的な方法で、コンパイルされたCOBOLコードによって実行されます。ただし、Cプログラムが最初に実行される場合、GnuCOBOLランタイムライブラリの初期化を実行する負担はCプログラムにあります。これを行う方法の例については、「&lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;CメインプログラムによるGnuCOBOLサブプログラムの呼び出し」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="57fb879374ae97e5eb278f255c02c63fea22e809" translate="yes" xml:space="preserve">
          <source>Line Sequential files are processed using the following statements:</source>
          <target state="translated">ラインシーケンシャルファイルは、以下のステートメントを使用して処理されます。</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="44ac976e13987b2e461319b6b07bf2f1d2977574" translate="yes" xml:space="preserve">
          <source>Little-Endian</source>
          <target state="translated">Little-Endian</target>
        </trans-unit>
        <trans-unit id="226d589b5f25caf9198d123daff4d9daae8eba87" translate="yes" xml:space="preserve">
          <source>Little-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the left-most byte. For example, a four-byte binary item having a value of decimal 20 would be little-endian allocated as 14000000 (shown in hexadecimal notation).</source>
          <target state="translated">リトルエンディアンデータの割り当てでは、バイナリ項目を構成するバイトを、最下位のバイトが左端のバイトになるように割り当てます。例えば、10進数20の値を持つ4バイトのバイナリ項目は、14000000としてリトルエンディアンに割り当てられます(16進数表記)。</target>
        </trans-unit>
        <trans-unit id="835de5c115f7b3e75f88f1bf5d8aaf4ad47e0bd8" translate="yes" xml:space="preserve">
          <source>Local-storage cannot be used in nested subprograms.</source>
          <target state="translated">ネストされたサブプログラムでは、ローカルストレージは使用できません。</target>
        </trans-unit>
        <trans-unit id="a5e093ebdd409890bed85c2fed42792048e3ee67" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, is de-allocated.</source>
          <target state="translated">ローカルストレージがある場合は、割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="3690da6677c866b7070485f97c20dfa1fc2058b7" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, will be allocated and initialized.</source>
          <target state="translated">ローカルストレージがあれば、割り当てられ、初期化されます。</target>
        </trans-unit>
        <trans-unit id="029c39972ba6042647e3f70b02f4bd91260e9fb3" translate="yes" xml:space="preserve">
          <source>Locator</source>
          <target state="translated">Locator</target>
        </trans-unit>
        <trans-unit id="8d02c4cdcb2b9946ab2619bfecc5df1af1b12a02" translate="yes" xml:space="preserve">
          <source>Locks acquired vie multiple record locking remain in-effect until the program holding the lock&amp;hellip;</source>
          <target state="translated">複数のレコードロックを介して取得されたロックは、プログラムがロックを保持するまで有効のままです&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="be9a3c255cc059f59d89184276ee44ce2ff74a47" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MAX, MEAN, MEDIAN, MEMORY, MERGE, MESSAGE, METHOD, METHOD-ID, MIDRANGE, MIN, MINUS, MOD, MODE, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULES, MODULE-SOURCE, MODULE-TIME, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTIPLE, MULTIPLY</source>
          <target state="translated">磁気テープ、マニュアル、最大値、平均値、中央値、メモリ、マージ、メッセージ、メソッド、メソッドID、ミッドレンジ、最小値、最小値、モード、モジュール発信者ID、モジュール日付、モジュールフォーマットされた日付、モジュールID、モジュールパス、モジュール、モジュールソース、モジュール時間、通貨十進数ポイント、通貨千分の一区切り、移動、複数、乗算</target>
        </trans-unit>
        <trans-unit id="57e71373c55e995e80f24e3f2087d0a7b5dbbec9" translate="yes" xml:space="preserve">
          <source>MAX Function Syntax</source>
          <target state="translated">MAX 関数構文</target>
        </trans-unit>
        <trans-unit id="0abf13bfa8b362e60f0cf8bd2bacaab30d7f67c9" translate="yes" xml:space="preserve">
          <source>MEAN Function Syntax</source>
          <target state="translated">MEAN 関数構文</target>
        </trans-unit>
        <trans-unit id="31a496c910f49ef35450cbdb8cbc4374b9f67273" translate="yes" xml:space="preserve">
          <source>MEDIAN Function Syntax</source>
          <target state="translated">MEDIAN 関数構文</target>
        </trans-unit>
        <trans-unit id="daee7fdd946c270a9b400d0cb5b7e42fe5872e0c" translate="yes" xml:space="preserve">
          <source>MERGE Syntax</source>
          <target state="translated">MERGE 構文</target>
        </trans-unit>
        <trans-unit id="c8035dd19f4b057f89b85a604ee1af37d346e31e" translate="yes" xml:space="preserve">
          <source>MIDRANGE Function Syntax</source>
          <target state="translated">MIDRANGE 関数構文</target>
        </trans-unit>
        <trans-unit id="b3922fba0ffbf0d82c96e71393fb62e945ccf5b9" translate="yes" xml:space="preserve">
          <source>MIN Function Syntax</source>
          <target state="translated">MIN 関数構文</target>
        </trans-unit>
        <trans-unit id="6df76c53746f58160bf9ed45943e438821905bb2" translate="yes" xml:space="preserve">
          <source>MOD Function Syntax</source>
          <target state="translated">MOD 関数構文</target>
        </trans-unit>
        <trans-unit id="fb9072e5497502c8b0c9f0cc92c12083bdb2cecc" translate="yes" xml:space="preserve">
          <source>MODULE-CALLER-ID Function Syntax</source>
          <target state="translated">MODULE-CALLER-ID 関数構文</target>
        </trans-unit>
        <trans-unit id="77023dbd5e71addbd6ecdf7b0de7955c05a7cbcc" translate="yes" xml:space="preserve">
          <source>MODULE-DATE Function Syntax</source>
          <target state="translated">MODULE-DATE 関数構文</target>
        </trans-unit>
        <trans-unit id="e4f1aeb1a72fe45f289846eea035900277d6474e" translate="yes" xml:space="preserve">
          <source>MODULE-FORMATTED-DATE Function Syntax</source>
          <target state="translated">MODULE-FORMATTED-DATE 関数構文</target>
        </trans-unit>
        <trans-unit id="e4708a13b25aed7fbcdde2ed7eb4f478e4e5a0d2" translate="yes" xml:space="preserve">
          <source>MODULE-ID Function Syntax</source>
          <target state="translated">MODULE-ID 関数構文</target>
        </trans-unit>
        <trans-unit id="9c157b8be74a13e0253ff0fdbcddcca6237613e4" translate="yes" xml:space="preserve">
          <source>MODULE-PATH Function Syntax</source>
          <target state="translated">MODULE-PATH 関数構文</target>
        </trans-unit>
        <trans-unit id="6aeac5d8bb6edf96b2cc15b2e1900d618339fe87" translate="yes" xml:space="preserve">
          <source>MODULE-SOURCE Function Syntax</source>
          <target state="translated">MODULE-SOURCE 関数構文</target>
        </trans-unit>
        <trans-unit id="9ba6dae63e2adfd381389ee805e05d8f98957c6a" translate="yes" xml:space="preserve">
          <source>MODULE-TIME Function Syntax</source>
          <target state="translated">MODULE-TIME 関数構文</target>
        </trans-unit>
        <trans-unit id="f73ead11798a2b39d355bdb9cc3ee0afd6c73ca2" translate="yes" xml:space="preserve">
          <source>MONETARY-DECIMAL-POINT Function Syntax</source>
          <target state="translated">MONETARY-DECIMAL-POINT 関数構文</target>
        </trans-unit>
        <trans-unit id="f959bf7a22a6fa8fd96fe2dd391a08fa5dd22aa0" translate="yes" xml:space="preserve">
          <source>MONETARY-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">数千万円単位のセパレータ 関数構文</target>
        </trans-unit>
        <trans-unit id="ec0648f1ef8e6f8e156101c88dcd2b9563d62924" translate="yes" xml:space="preserve">
          <source>MOVE CORRESPONDING Syntax</source>
          <target state="translated">MOVE CORRESPONDING 構文</target>
        </trans-unit>
        <trans-unit id="569fe924e80927234226e1da480e2aaeb896476b" translate="yes" xml:space="preserve">
          <source>MULTIPLY BY Syntax</source>
          <target state="translated">MULTIPLY BY 構文</target>
        </trans-unit>
        <trans-unit id="3ad347c2697684ef0953e3a767d0bc1635d31d5a" translate="yes" xml:space="preserve">
          <source>MULTIPLY GIVING Syntax</source>
          <target state="translated">マルチプルギビング構文</target>
        </trans-unit>
        <trans-unit id="412299ff020a7154d245c3b0f04152fc824d367f" translate="yes" xml:space="preserve">
          <source>Magenta: COB-COLOR-MAGENTA</source>
          <target state="translated">マゼンタです。cob-color-magenta</target>
        </trans-unit>
        <trans-unit id="4ad990da0619f2f6612747fd3b18ae051e2e5eca" translate="yes" xml:space="preserve">
          <source>Main Program</source>
          <target state="translated">メインプログラム</target>
        </trans-unit>
        <trans-unit id="62df8b8e9bbaa8bb9f1517aa2bf38f13fc37e36a" translate="yes" xml:space="preserve">
          <source>Main program</source>
          <target state="translated">メインプログラム</target>
        </trans-unit>
        <trans-unit id="154c8bfc5f3e601547791b40d3a205f6ed780b67" translate="yes" xml:space="preserve">
          <source>Main programs compiled in this manner should be executed as follows:</source>
          <target state="translated">このようにしてコンパイルされたメインプログラムは、以下のように実行してください。</target>
        </trans-unit>
        <trans-unit id="ad9766c462696f99f3025a340a18914544b7bff9" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &quot;pass back&quot; a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register.</source>
          <target state="translated">終了時にオペレーティングシステムに戻りコード値を「パスバック」したいメインプログラムは、RETURNINGを使用しません。これは、 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊レジスターに値を移動するだけで行われます。</target>
        </trans-unit>
        <trans-unit id="7a5053f6a0e7ffe3e98db384f4662350eb992d81" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the&lt;code&gt;END-OF-PAGE&lt;/code&gt;</source>
          <target state="translated">ページ上部のヘッダー、ページ下部のフッターなどの印刷ページの領域の管理、「全ページ」の状況への対処などは、プログラマーとGnuCOBOLランタイムライブラリが共同で担当するようになりました。以下のようなツール &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 特殊レジスタ（参照&lt;a href=&quot;#Special-Registers&quot;&gt;特殊レジスタを&lt;/a&gt;）と &lt;code&gt;END-OF-PAGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535d01a3bb7e25e935da4ad3d0028806321932cc" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">ページ上部のヘッダー、ページ下部のフッター、「全ページ」など、印刷されたページ上の領域の管理は、プログラマーの完全な責任です。</target>
        </trans-unit>
        <trans-unit id="5d904664fde10f48cc22ff0d5ed913f64ac37406" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of&lt;code&gt;VALUE&lt;/code&gt;and&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a&lt;code&gt;VALUE&lt;/code&gt;clause on a data item subordinate to an&lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">多くのCOBOLコンパイラーは、同じデータ項目での &lt;code&gt;VALUE&lt;/code&gt; と &lt;code&gt;OCCURS&lt;/code&gt; （&lt;a href=&quot;#OCCURS&quot;&gt;OCCURSを&lt;/a&gt;参照）の使用を許可していません。さらに、 &lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOLに従属するデータ項目での &lt;code&gt;VALUE&lt;/code&gt; 句は許可されませんが、これらの制限はありません！</target>
        </trans-unit>
        <trans-unit id="cec330cac6c061d7cea06b901961f17d2342ed88" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &quot;overhead&quot; verbiage of any program&amp;hellip;</source>
          <target state="translated">多くのシステムには、プログラムのコーディング作業を容易にするためのプログラム開発ツールがあります。COBOLに集中するこれらのツールは、あらゆるプログラムの &quot;オーバーヘッド&quot;表現の多くにテンプレートを提供できます&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bea0e296af322cedefa66548ccd5635e5218df89" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &quot;less-expensive&quot; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">多くの場合、これらの企業は、真にミッションクリティカルなアプリケーションをサポートするために必要なシステム/ネットワークエンジニアリング、運用管理、監視、およびリスク管理（つまり、災害復旧）インフラストラクチャのコストが非常に高いため、「安価な」ソリューションは実際にはありません。 't;これらの場合、メインフレームが最良のオプションであり続ける可能性があるため、COBOLを活用し、企業はアプリケーションベースの少なくとも一部に別のソリューションを求めています。</target>
        </trans-unit>
        <trans-unit id="5c7162a608e9a76bc0cf997699b25c2bb027fd85" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What IS difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">自由形式のソースコードが有効な場合、変更のマーク付けはより困難になります。加えられた変更を一般的に説明するプログラムのトップのコメントブロックを作成することは、自由形式であっても難しくありません。ただし、難しいのは、ステートメントごとのマークアップのスキームを考え出すことであり、プログラムに途方もなく過剰な数のソース行を導入しません。この問題に対する適切な答えがあるかどうかはわかりません（読者が持っている場合は、お知らせください）。一般に、COBOLソースに自由形式の規則を使用しているショップは、プログラムの上部にコメントブロックを最小限に抑え、プログラム全体に小さなコメントブロックを配置して、大きな変更が加えられた領域に注目する傾向があることに気付きました。</target>
        </trans-unit>
        <trans-unit id="44df495b9a46d581843f66787d274a1a7bcc6fc8" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">GnuCOBOLの数値用法とC言語のデータ型の等価物とのマッチングは、以下の表を参照してください。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f15a625eabeb2b9b8fbf957ba6acb6ea6384e8c2" translate="yes" xml:space="preserve">
          <source>Meaning if 0</source>
          <target state="translated">0の場合の意味</target>
        </trans-unit>
        <trans-unit id="0b296b5b70a4eb122d3023d41ac6ce6b7484aab3" translate="yes" xml:space="preserve">
          <source>Meaning if 1</source>
          <target state="translated">1の場合の意味</target>
        </trans-unit>
        <trans-unit id="f99e481919f7772162edf428466c40acaa045b03" translate="yes" xml:space="preserve">
          <source>Most &amp;lt;</source>
          <target state="translated">ほとんど&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f9aaebcdc913ba77329c6f07dbfd334a3e319cb4" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using&lt;code&gt;WITH TEST BEFORE&lt;/code&gt;explicitly or implicitly have developed the habit of using &quot;&amp;gt;&quot; rather than &quot;=&quot; on&lt;code&gt;UNTIL&lt;/code&gt;clauses. This would make the sample code:</source>
          <target state="translated">ほとんどのCOBOLプログラマーは、 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; を明示的または暗黙的に使用する場合、 &lt;code&gt;UNTIL&lt;/code&gt; 句で「=」ではなく「&amp;gt;」を使用する習慣を身につけました。これはサンプルコードを作成します：</target>
        </trans-unit>
        <trans-unit id="af302c911fcda5124147255d68b3ea18b4163a54" translate="yes" xml:space="preserve">
          <source>Most of the call-by-number routines have evolved into even more powerful call-by-name routines, many of which are supported by GnuCOBOL.</source>
          <target state="translated">ほとんどの call-by-number ルーチンは、さらに強力な call-by-name ルーチンへと進化し、その多くは GnuCOBOL でサポートされています。</target>
        </trans-unit>
        <trans-unit id="817d5274cb3dad555ae670d47cd2b238950e0a1b" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &amp;lt;</source>
          <target state="translated">他のほとんどのCOBOL実装は、複数の浮動編集記号の複数の出現の使用を拒否します。たとえば、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="bd8dc228cac7dc6165d9a7427a86371a364ab9e9" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &quot;copy&quot;)</source>
          <target state="translated">ファイルの移動(破壊的な「コピー」)</target>
        </trans-unit>
        <trans-unit id="8068c142bfb974eaa19e904ed221669dae03ee9c" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statements. The final program in such a source code file need not have an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;END PROGRAM&lt;/code&gt; または &lt;code&gt;END FUNCTION&lt;/code&gt; ステートメントによって互いに分離された複数のプログラム。このようなソースコードファイルの最後のプログラムには、 &lt;code&gt;END PROGRAM&lt;/code&gt; または &lt;code&gt;END FUNCTION&lt;/code&gt; ステートメントを含める必要はありません。</target>
        </trans-unit>
        <trans-unit id="02160c2d59fcbe5c753ac574ebfed903f459af79" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C:\Pgms\myprog.exe&quot;, &quot;THIS IS A&quot; and &quot;TEST&quot;. When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token&amp;rsquo;s value.</source>
          <target state="translated">スペースで区切られた複数のトークンは、引用符で囲むことにより、単一のトークンとして扱うことができます。たとえば、コマンドラインから生成された唯一の3つのトークンがある &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; 、 &quot;THIS IS A&quot;と&quot;TEST&quot; - &quot;\ PGMS \ MYPROG.EXE Cが&quot;。引用文字を使用してマルチワードトークンを作成すると、引用文字自体がトークンの値から削除されます。</target>
        </trans-unit>
        <trans-unit id="0c9327341de5e837b95068cae1399d3901498283" translate="yes" xml:space="preserve">
          <source>Multiple-item search strings can be specified using the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. For example, to replace all occurrences of&lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify&lt;code&gt;==UPON PRINTER==&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt; オプションを使用して、複数項目の検索文字列を指定できます。たとえば、 &lt;code&gt;UPON PRINTER&lt;/code&gt; のすべての出現を置き換えるには、 &lt;code&gt;==UPON PRINTER==&lt;/code&gt; 指定します。</target>
        </trans-unit>
        <trans-unit id="512c7a9b64ee7852d8007b60e8e382406285cb64" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;/&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">複数の &lt;code&gt;/&lt;/code&gt; 記号をコーディングできます。</target>
        </trans-unit>
        <trans-unit id="1bb573db89249b4de6d85f0d6303b423ef55f890" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;0&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">複数の &lt;code&gt;0&lt;/code&gt; シンボルをコーディングできます。</target>
        </trans-unit>
        <trans-unit id="4e4e78bcc251379bcccaef2662ec5c92b786e53d" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;B&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">複数の &lt;code&gt;B&lt;/code&gt; シンボルをコーディングできます。</target>
        </trans-unit>
        <trans-unit id="4272ab5411f12b91ef6d0e34934e3b2c6d362159" translate="yes" xml:space="preserve">
          <source>Multiply the result of this function times the desired principal amount to determine the amount of each period&amp;rsquo;s payment.</source>
          <target state="translated">この関数の結果に希望の元本金額を掛けて、各期間の支払い額を決定します。</target>
        </trans-unit>
        <trans-unit id="257327ddfd98406ae03a0f3e1b7b410f8b01fe5e" translate="yes" xml:space="preserve">
          <source>My familiarity with COBOL may be prejudicing my opinion, but it doesn&amp;rsquo;t appear to me that the Java code is any simpler than the COBOL code. In case you&amp;rsquo;re interested in character counts, the Java code comes in at 278 (not counting indentation characters). The COBOL code is 298 (274 without the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header).</source>
          <target state="translated">COBOLに精通していることは私の意見を害するかもしれませんが、JavaコードがCOBOLコードよりも単純であるようには思えません。文字カウントに関心がある場合は、Javaコードは278にあります（インデント文字はカウントしません）。COBOLコードは298（ &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; ヘッダーなしの274 ）です。</target>
        </trans-unit>
        <trans-unit id="8841ca9cf4a3d6697ad899f49ceee826a96da464" translate="yes" xml:space="preserve">
          <source>N/A (no GnuCOBOL equivalent)</source>
          <target state="translated">N/A (GnuCOBOL と同等のものはありません)</target>
        </trans-unit>
        <trans-unit id="456048850e9d09e5cbfde5c2a6be5799c526a49a" translate="yes" xml:space="preserve">
          <source>NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</source>
          <target state="translated">name,national,national-edited,national-of,native,ゼロから最も近い、ゼロから最も遠い、ゼロに最も近い、ゼロに最も近い、ゼロに最も近い、負の、入れ子になった、次の、no,no-echo,none,normal,not,nothing,null,nulls,number,number,number-of-call-parameters,numbers,numeric,numeric-decimal-point,numeric-edited,numeric-thousands-separator,numval,numval-c,numval-f</target>
        </trans-unit>
        <trans-unit id="23579a7244afbe343b0ef7777f40fe65dd6d391f" translate="yes" xml:space="preserve">
          <source>NEXT-GROUP Clause Syntax</source>
          <target state="translated">NEXT-GROUP節構文</target>
        </trans-unit>
        <trans-unit id="4fd04833b3755cfdf59219f364a4c19cf95dcc36" translate="yes" xml:space="preserve">
          <source>NO-ECHO Attribute Syntax</source>
          <target state="translated">NO-ECHO 属性構文</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="a9ea4f7a4f03a9c52a7aa0d54a54e0ee6d21feed" translate="yes" xml:space="preserve">
          <source>NOTE that CBL_GC_PRINTABLE replaces this although it is currently still supported for legacy reasons.</source>
          <target state="translated">注:CBL_GC_PRINTABLEはこれに取って代わるものですが、レガシーな理由で現在もサポートされています。</target>
        </trans-unit>
        <trans-unit id="1c7a5d29d866f9947d87ce89b623e7dcee44fb1b" translate="yes" xml:space="preserve">
          <source>NUMERIC-DECIMAL-POINT Function Syntax</source>
          <target state="translated">目標値-小数点 関数構文</target>
        </trans-unit>
        <trans-unit id="0f7032d6214932877eaeb90684d8b5e91b84fe2d" translate="yes" xml:space="preserve">
          <source>NUMERIC-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">目標数-千人-セパレータ 関数構文</target>
        </trans-unit>
        <trans-unit id="24a2cb0031362dfda9217165484fefd16498a931" translate="yes" xml:space="preserve">
          <source>NUMVAL Function Syntax</source>
          <target state="translated">NUMVAL 関数構文</target>
        </trans-unit>
        <trans-unit id="31988bddc5cc6a4166042e84de6cbd874cb74a99" translate="yes" xml:space="preserve">
          <source>NUMVAL-C Function Syntax</source>
          <target state="translated">NUMVAL-C 関数構文</target>
        </trans-unit>
        <trans-unit id="ae21c526020f5a22401b17f7aa4bfb1762439159" translate="yes" xml:space="preserve">
          <source>NUMVAL-F Function Syntax</source>
          <target state="translated">NUMVAL-F 関数構文</target>
        </trans-unit>
        <trans-unit id="057d3c3f4e6e8dc1ec58c53e9789c01dd0b62e89" translate="yes" xml:space="preserve">
          <source>National Character set</source>
          <target state="translated">国民性セット</target>
        </trans-unit>
        <trans-unit id="4245f0ee71bd17093500ac16c41a1dd1b33008e5" translate="yes" xml:space="preserve">
          <source>Native Binary Integer</source>
          <target state="translated">ネイティブ二進整数</target>
        </trans-unit>
        <trans-unit id="3f00afda761d5e13a699220ac15df2aa008259c3" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary32</source>
          <target state="translated">ネイティブ IEEE 754 Binary32</target>
        </trans-unit>
        <trans-unit id="38d71bfaf2af5e86c02dd007bae5cd22e8350547" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary64 Floating-point</source>
          <target state="translated">ネイティブ IEEE 754 Binary64 浮動小数点</target>
        </trans-unit>
        <trans-unit id="4775cd57bf8ad48397acf03e156ee31bbc505817" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal128 Floating-point</source>
          <target state="translated">ネイティブ IEEE 754 Decimal128 浮動小数点</target>
        </trans-unit>
        <trans-unit id="1579bca067a63e4a82df0092b6bb19e611a1879b" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal64 Floating-point</source>
          <target state="translated">ネイティブ IEEE 754 Decimal64 浮動小数点</target>
        </trans-unit>
        <trans-unit id="663645109bc4810ff83f3fcb9242af60d6271f15" translate="yes" xml:space="preserve">
          <source>Native unsigned (X) or signed (9) Binary</source>
          <target state="translated">ネイティブ符号なし(X)または符号付き(9)バイナリ</target>
        </trans-unit>
        <trans-unit id="0bb1805002fe928c11731e2fe434c6710e0546aa" translate="yes" xml:space="preserve">
          <source>Negated Condition Syntax</source>
          <target state="translated">否定条件構文</target>
        </trans-unit>
        <trans-unit id="b258f825a32604b32cf66b5f27af5bbeed3d0dbd" translate="yes" xml:space="preserve">
          <source>Negative Values Allowed?:</source>
          <target state="translated">負の値は許可されていますか?</target>
        </trans-unit>
        <trans-unit id="569eabdf4b8f2757a51f46ddb9444a185ebc7cb4" translate="yes" xml:space="preserve">
          <source>Negative values are returned for system dependand error codes and -1 if the function is not available on the current system.</source>
          <target state="translated">システムに依存するエラーコードには負の値が返され、現在のシステムでこの関数が利用できない場合は -1 が返されます。</target>
        </trans-unit>
        <trans-unit id="fac968968fa4c7a06b3ca207e37616b4cf010c7c" translate="yes" xml:space="preserve">
          <source>Neither &amp;lt;</source>
          <target state="translated">どちらでもない</target>
        </trans-unit>
        <trans-unit id="dcdcf73a59a8f2ad5bc285a8314df00761fcb686" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the input procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">別のファイルベースの &lt;code&gt;SORT&lt;/code&gt; ステートメントも &lt;code&gt;MERGE&lt;/code&gt; ステートメントも、別のソートまたはマージ作業ファイルを使用しない限り、入力プロシージャ内で実行できません。</target>
        </trans-unit>
        <trans-unit id="24fe46648b02cf0f40c1f64b86fe9a8a1b238380" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">別のファイルベースの &lt;code&gt;SORT&lt;/code&gt; ステートメントも &lt;code&gt;MERGE&lt;/code&gt; ステートメントも、別のソートまたはマージ作業ファイルを使用しない限り、出力プロシージャ内で実行できません。</target>
        </trans-unit>
        <trans-unit id="1a3ec78fb2431caff148e7bb1cf8ea0ff18e700c" translate="yes" xml:space="preserve">
          <source>Neither a file-based&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) nor another&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">ファイルベースの &lt;code&gt;SORT&lt;/code&gt; ステートメント（&lt;a href=&quot;#File_002dBased-SORT&quot;&gt;ファイルベースのSORTを&lt;/a&gt;参照）または別の &lt;code&gt;MERGE&lt;/code&gt; ステートメントは、それらのステートメントが異なるソートまたはマージ作業ファイルを使用しない限り、出力プロシージャを構成するプロシージャのスコープ内で実行できません。</target>
        </trans-unit>
        <trans-unit id="cc989bf49db06aa48ebb1422a2de0e6c00423d9d" translate="yes" xml:space="preserve">
          <source>Neither the presence of an encoded digit (see above) nor an actual&lt;code&gt;+&lt;/code&gt;or&lt;code&gt;-&lt;/code&gt;character embedded within the data item&amp;rsquo;s storage prevents the data item from being used as a source field in arithmetic operations.</source>
          <target state="translated">エンコードされた数字（上記を参照）の存在も、データ項目のストレージに埋め込まれた実際の &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; 文字も、データ項目が算術演算のソースフィールドとして使用されることを妨げません。</target>
        </trans-unit>
        <trans-unit id="f5e391e55efc04c3c0f99e29e799c743a6b88a5c" translate="yes" xml:space="preserve">
          <source>Neither the value of &amp;lt;</source>
          <target state="translated">&amp;lt;の値も</target>
        </trans-unit>
        <trans-unit id="a8d23bd6a6b56505c754a0566832b43e6c7deddd" translate="yes" xml:space="preserve">
          <source>Neither&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;may be used within a&lt;code&gt;USE GLOBAL&lt;/code&gt;routine in&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;EXIT PROGRAM&lt;/code&gt; も &lt;code&gt;EXIT FUNCTION&lt;/code&gt; も、 &lt;code&gt;DECLARATIVES&lt;/code&gt; の &lt;code&gt;USE GLOBAL&lt;/code&gt; ルーチン内では使用できません（&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVESを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2ef44da87cf7da408056f5b8df3aee8b08f3e63d" translate="yes" xml:space="preserve">
          <source>Nested Subprograms</source>
          <target state="translated">入れ子になったサブプログラム</target>
        </trans-unit>
        <trans-unit id="02345bc4e59618249ddd33b89a552e74eefc9cca" translate="yes" xml:space="preserve">
          <source>New programs requiring a stand-alone elementary item should be coded to use a level number of 01 rather than 77.</source>
          <target state="translated">単体の初級項目を必要とする新しいプログラムは、77ではなく01のレベル番号を使用するようにコード化されるべきである。</target>
        </trans-unit>
        <trans-unit id="cb2f4a912a9c59ceb0b74adc342b766667a643e7" translate="yes" xml:space="preserve">
          <source>Next, the&lt;code&gt;CONTROL HEADING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">次に、各&amp;lt;の &lt;code&gt;CONTROL HEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="1a6b2761c5a03cb41776cc1a48760cf197b63fc7" translate="yes" xml:space="preserve">
          <source>No data is available on screen ACCEPT</source>
          <target state="translated">画面上にデータがありません ACCEPT</target>
        </trans-unit>
        <trans-unit id="22f4fdea4baac33f85e6d27a113ce40e1b051a05" translate="yes" xml:space="preserve">
          <source>No more than 36 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it. If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the&lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt;in the&lt;code&gt;common.h&lt;/code&gt;file (found in the&lt;code&gt;libcob&lt;/code&gt;folder) before you run&lt;code&gt;make&lt;/code&gt;to build the compiler and run-time library.</source>
          <target state="translated">特に異なる引数の制限が指定されてGnuCOBOLコンパイラーがビルドされた場合を除き、36個を超える引数はサブルーチンに渡されません。GnuCOBOLソースコードにアクセスできる場合は、 &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; を実行してコンパイラーとランタイムライブラリをビルド &lt;code&gt;make&lt;/code&gt; 前に、 &lt;code&gt;common.h&lt;/code&gt; ファイル（ &lt;code&gt;libcob&lt;/code&gt; フォルダーにあります）のCOB_MAX_FIELD_PARAMSの値を変更して、この制限を調整できます。</target>
        </trans-unit>
        <trans-unit id="9d5b904086ff2a2ac1ab9032a0b17994d3c8146f" translate="yes" xml:space="preserve">
          <source>No report content will actually presented to the report file as a result of a successful&lt;code&gt;INITIATE&lt;/code&gt;statement &amp;mdash; that will not occur until the first&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed.</source>
          <target state="translated">いいえレポートの内容は、実際に成功の結果として、レポートファイルに提示されません &lt;code&gt;INITIATE&lt;/code&gt; 最初まで発生しません-ステートメントの &lt;code&gt;GENERATE&lt;/code&gt; （参照文を&lt;a href=&quot;#GENERATE&quot;&gt;GENERATEが&lt;/a&gt;）が実行されます。</target>
        </trans-unit>
        <trans-unit id="841e2fb51fda0ae1893e020320984500822af311" translate="yes" xml:space="preserve">
          <source>No rounding is performed. If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the&lt;code&gt;ACCEPT&lt;/code&gt;(see &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;) statement) and the results of the operation are undefined.</source>
          <target state="translated">丸めは実行されません。値を希望の形式で正確に表現できない場合は、EC-SIZE-TRUNCATION条件（例外コード1005）が設定され（ &lt;code&gt;ACCEPT&lt;/code&gt; （&lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Infoを&lt;/a&gt;参照）ステートメントで取得できます）、操作の結果未定義です。</target>
        </trans-unit>
        <trans-unit id="eae4ac248869b9a9f5a910afc02caead622a3640" translate="yes" xml:space="preserve">
          <source>No special meaning &amp;mdash; this is the normal character that will appear in this area.</source>
          <target state="translated">特別な意味はありません。これは、この領域に表示される通常の文字です。</target>
        </trans-unit>
        <trans-unit id="0cfdaae490927c423f2c8197638d2a8e5c4b9c06" translate="yes" xml:space="preserve">
          <source>No storage is allocated for data defined in the linkage section; the data descriptions there are merely defining storage areas that will be passed to the subprogram by a calling program. Therefore, any discussion of the default initialization of such data is irrelevant. It</source>
          <target state="translated">リンクセクションで定義されたデータにはストレージは割り当てられていません;そこでのデータ記述は、呼び出しプログラムによってサブプログラムに渡されるストレージ領域を定義しているに過ぎません。したがって、そのようなデータのデフォルトの初期化についてのいかなる議論も無関係である。それは</target>
        </trans-unit>
        <trans-unit id="7438d13425aae9891e97195f6fa784ef1702eda9" translate="yes" xml:space="preserve">
          <source>No two of those files may be referenced on a&lt;code&gt;SAME RECORD AREA&lt;/code&gt;(see &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt;),&lt;code&gt;SAME SORT AREA&lt;/code&gt;or&lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;SAME RECORD AREA&lt;/code&gt; （&lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREAを&lt;/a&gt;参照）、 &lt;code&gt;SAME SORT AREA&lt;/code&gt; 、または &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; ステートメントでこれらのファイルを2つ参照することはできません。</target>
        </trans-unit>
        <trans-unit id="de44dc71aad924a999900997ea794d8dd652830f" translate="yes" xml:space="preserve">
          <source>No two records in the table may have the same&lt;code&gt;KEY&lt;/code&gt;field values. If the table has multiple&lt;code&gt;KEY&lt;/code&gt;definitions, then no two records in the table may have the same</source>
          <target state="translated">テーブル内の2つのレコードが同じ &lt;code&gt;KEY&lt;/code&gt; フィールド値を持つことはできません。テーブルに複数の &lt;code&gt;KEY&lt;/code&gt; 定義がある場合、テーブル内の2つのレコードが同じであってはなりません。</target>
        </trans-unit>
        <trans-unit id="a81a89d7fe3f234fdfe59b26feaf85b577259ebb" translate="yes" xml:space="preserve">
          <source>No two report groups in the same report &lt;code&gt;RD&lt;/code&gt; may named with the same &amp;lt;</source>
          <target state="translated">同じレポート &lt;code&gt;RD&lt;/code&gt; 内の2つのレポートグループに同じ&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d7e5774021597c332a13e1b5235f812224be797b" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;INVALID KEY&lt;/code&gt;or&lt;code&gt;NOT INVALID KEY&lt;/code&gt;clause may be specified for a file who&amp;rsquo;s&lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">ノー &lt;code&gt;INVALID KEY&lt;/code&gt; または &lt;code&gt;NOT INVALID KEY&lt;/code&gt; の句だファイルに指定することができる &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf0db7b3bb9f408f9b74f8f298755ddc3e66b9b8" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause may be part of the definition of either the subject or object data items. Either or both, however, may be group items that</source>
          <target state="translated">全く &lt;code&gt;OCCURS&lt;/code&gt; （参照が&lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;）句は、対象又は対象データ項目のいずれかの定義の一部であってもよいです。ただし、どちらかまたは両方が、</target>
        </trans-unit>
        <trans-unit id="ca1b683a95bedaa03b1b7fa72858ee0c6ecd486e" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause may be defined on the object data item, and no data items subordinate to the object data item may have&lt;code&gt;VALUE&lt;/code&gt;clauses, with the exception of level-88 condition names.</source>
          <target state="translated">いいえ &lt;code&gt;VALUE&lt;/code&gt; （参照&lt;a href=&quot;#VALUE&quot;&gt;値&lt;/a&gt;）句は、オブジェクトデータ項目に定義されてもよいし、オブジェクトデータ項目に従属ないデータ項目が有していなくてもよい &lt;code&gt;VALUE&lt;/code&gt; のレベル88条件名を除いて、句。</target>
        </trans-unit>
        <trans-unit id="25fc4526232d80ffb715ab31181b4409345c2f9b" translate="yes" xml:space="preserve">
          <source>Non-integer fixed point values such as 1.317 or -2.95.</source>
          <target state="translated">1.317や-2.95のような非整数の定点値。</target>
        </trans-unit>
        <trans-unit id="e2c9b438099e818e760bdec714a929f4ed0713ad" translate="yes" xml:space="preserve">
          <source>None of &amp;lt;</source>
          <target state="translated">&amp;lt;なし</target>
        </trans-unit>
        <trans-unit id="b822fcd670cee5b981bb06fc3472b35bc909a687" translate="yes" xml:space="preserve">
          <source>None of them may be open at the time the&lt;code&gt;MERGE&lt;/code&gt;is executed.</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; の実行時に、それらのいずれも開いていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="e27f545e660688ab7b2fa768237fd2139f657e72" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support file sharing and record-locking options. Whether they do or not depends upon the operating system they were built for and the build options that were used when the specific GnuCOBOL implementation was generated.</source>
          <target state="translated">すべての GnuCOBOL 実装がファイル共有とレコードロックオプションをサポートしているわけではありません。対応しているかどうかは、対応しているオペレーティングシステムと、特定の GnuCOBOL 実装が生成されたときに使用されたビルドオプションに依存します。</target>
        </trans-unit>
        <trans-unit id="306e41cc992ba155fc93cf3121e83571aae63d84" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support locking. Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated. When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored. There will be no compiler message issued. Buffer syncing, if needed, will still occur.</source>
          <target state="translated">すべての GnuCOBOL 実装がロックをサポートしているわけではありません。対応しているかどうかは、対応しているオペレーティングシステムや GnuCOBOL の生成時に使用されたビルドオプションに依存します。これらの GnuCOBOL 実装を使用しているプログラムが UNLOCK を発行した場合、それは無視されます。コンパイラメッセージも発行されません。バッファ同期が必要な場合でも、バッファ同期は行われます。</target>
        </trans-unit>
        <trans-unit id="e9c1ce73c055e69ee3402cf0e4efbc368e26f9fc" translate="yes" xml:space="preserve">
          <source>Not all divisions are needed in every program, but they must be specified in the order shown when they</source>
          <target state="translated">すべてのプログラムですべての部門が必要なわけではありませんが、それらの部門は、それらが</target>
        </trans-unit>
        <trans-unit id="70ba7f89a0cdff0df48d89a63760a916d2a3530e" translate="yes" xml:space="preserve">
          <source>Not specifying an &amp;lt;</source>
          <target state="translated">&amp;lt;を指定しない</target>
        </trans-unit>
        <trans-unit id="dc309739aae3a8f2ebf82a717d61d549c5be4bac" translate="yes" xml:space="preserve">
          <source>Note how the COBOL program ensures that a null end-of-string terminator is present on both string arguments.</source>
          <target state="translated">COBOLプログラムが、両方の文字列引数にヌル文字の文字列終端終端が存在することを保証する方法に注目してください。</target>
        </trans-unit>
        <trans-unit id="9c109c67ad2b3a941d3d17742fa522392c11f75b" translate="yes" xml:space="preserve">
          <source>Note how the word&lt;code&gt;FUNCTION&lt;/code&gt;is part of the syntax when you use an intrinsic function. You can use intrinsic functions without having to include the reserved word&lt;code&gt;FUNCTION&lt;/code&gt;via settings in the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph. You may accomplish the same thing by specifying the&lt;code&gt;-fintrinsics&lt;/code&gt;switch</source>
          <target state="translated">組み込み関数を使用する場合、 &lt;code&gt;FUNCTION&lt;/code&gt; という単語が構文の一部であることに注意してください。 &lt;code&gt;REPOSITORY&lt;/code&gt; （&lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORYを&lt;/a&gt;参照）段落の設定を介して予約語 &lt;code&gt;FUNCTION&lt;/code&gt; を含めることなく、組み込み関数を使用できます。 &lt;code&gt;-fintrinsics&lt;/code&gt; スイッチを指定して、同じことを行うことができます</target>
        </trans-unit>
        <trans-unit id="d04e9fec76c5812c7a9b640cbfeccc8e41ebd984" translate="yes" xml:space="preserve">
          <source>Note how the&lt;code&gt;cobcrun&lt;/code&gt;command does not allow a path to be specified with the program name &amp;mdash; the directory in which the programs dynamically loadable module exists must either be the current directory or must be defined in the current PATH.</source>
          <target state="translated">&lt;code&gt;cobcrun&lt;/code&gt; コマンドでは、プログラム名でパスを指定できないことに注意してください。プログラムの動的にロード可能なモジュールが存在するディレクトリは、現在のディレクトリであるか、現在のPATHで定義されている必要があります。</target>
        </trans-unit>
        <trans-unit id="ec332543bc6a4b8ecabc6857c2e09711a937c08d" translate="yes" xml:space="preserve">
          <source>Note that bit 0 is the right-most bit in the binary value.</source>
          <target state="translated">ビット 0 はバイナリ値の右端のビットであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2539952aecc19d7b3a92ef3357fabc279c56a247" translate="yes" xml:space="preserve">
          <source>Note that even though we told GnuCOBOL that the 1st argument was to be&lt;code&gt;BY VALUE&lt;/code&gt; it was treated as if it were&lt;code&gt;BY REFERENCE&lt;/code&gt;anyway. String (char array) arguments passed from C callers to GnuCOBOL subprograms will be modifiable by the subprogram. It&amp;rsquo;s best to pass a copy of such data if you want to ensure that the subprogram doesn&amp;rsquo;t change it.</source>
          <target state="translated">GnuCOBOLに第1引数を &lt;code&gt;BY VALUE&lt;/code&gt; とするように指示したにもかかわらず、それはとにかく &lt;code&gt;BY REFERENCE&lt;/code&gt; であるかのように扱われたことに注意してください。Cの呼び出し元からGnuCOBOLサブプログラムに渡される文字列（char配列）引数は、サブプログラムによって変更可能です。サブプログラムがデータを変更しないようにする場合は、そのようなデータのコピーを渡すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="871c018f1f8ef5bab7bedbfc57441be80385c284" translate="yes" xml:space="preserve">
          <source>Note that the OUTPUT phrase changes the way in which the default field size is computed. See that heading above for details. Also note that the OUTPUT phrase affects only the way items are displayed on the screen; the internal format of accepted data is not affected.</source>
          <target state="translated">OUTPUT句は、デフォルトのフィールドサイズの計算方法を変更することに注意してください。詳細は上の見出しを参照してください。また、OUTPUT句は画面上での項目の表示方法にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="1fbd4eeb5f6972ceb99cdf3aac9f4be0886c77cb" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine starts with CBL_OC is deprecated, as is HOSTED but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">CBL_OC で始まるこのルーチンのレガシー名は、HOSTED と同様に非推奨ですが、まだ動作することに注意してください。問題を最小限に抑えるために、CBL_OC で始まるすべての libary ルーチン名を CBL_GC に置き換えることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7a40b40bf40810b907f7cf0d8aaaa83843011c4d" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine that starts with CBL_OC is deprecated, as is NANOSLEEP but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">CBL_OC で始まるこのルーチンのレガシー名は、NANOSLEEP と同様に非推奨ですが、まだ動作することに注意してください。問題を最小限に抑えるために、CBL_OC で始まるすべての libary ルーチン名を CBL_GC に置き換えることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="efe51ebdd06327d81c22d954a952f012e8b5debd" translate="yes" xml:space="preserve">
          <source>Note that the value returned by this function is not the number of</source>
          <target state="translated">この関数が返す値は</target>
        </trans-unit>
        <trans-unit id="f3452b747551a3e31882fb7b479a113ecf58accb" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &quot;+.&quot;.</source>
          <target state="translated">これらのエラーには、以下のものが含まれますが、これらに限定されないことに注意してください:引数(文字列)の長さがゼロであったり、スペースしか含まれていなかったり、有効な文字が含まれているが文字列 &quot;+&quot;のように不完全であったりします。</target>
        </trans-unit>
        <trans-unit id="cc0412d45415b86da0a43a8c1ca6e6dc158f2456" translate="yes" xml:space="preserve">
          <source>Note that what constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;specifications in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph.</source>
          <target state="translated">「文字」を構成するもの（またはその方法では大文字と小文字も）は、 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; （&lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTERを&lt;/a&gt;参照）段落の &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 仕様の使用によって影響を受ける可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d3c2b08b61d1a38bbeee29bc320c48df653d057" translate="yes" xml:space="preserve">
          <source>Note that you cannot supply the CONVERT phrase in the Screen Section. Thus the size of a Screen Section field is always the size of its screen entry unless the SIZE phrase is specified.</source>
          <target state="translated">画面セクションで CONVERT フレーズを指定することはできないことに注意してください。したがって、SIZE フレーズが指定されていない限り、スクリーンセクションフィールドのサイズは常にそのスクリーンエントリのサイズになります。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="28b8e9bdefe3979b0685c44999ad9084995ed4c9" translate="yes" xml:space="preserve">
          <source>Now observe the following code, which will execute the&lt;code&gt;150-Process-Hex-Value&lt;/code&gt;procedure if&lt;code&gt;Entered-Value&lt;/code&gt;contains nothing but valid hexadecimal digits:</source>
          <target state="translated">&lt;code&gt;Entered-Value&lt;/code&gt; に有効な16進数字のみが含まれている場合、 &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; プロシージャを実行する次のコードを確認します。</target>
        </trans-unit>
        <trans-unit id="d9e0e91f86531814b287253e68ce747a1135f32c" translate="yes" xml:space="preserve">
          <source>Now that you know</source>
          <target state="translated">あなたが知っている今</target>
        </trans-unit>
        <trans-unit id="d0861e2e052b3dc839be9fe7e44875aa59ec9523" translate="yes" xml:space="preserve">
          <source>Now there can be no confusion as to which CITY is being changed. Fortunately, you don&amp;rsquo;t need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted. This allows&lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt;to do the job nicely.</source>
          <target state="translated">これで、どのCITYが変更されるかについて混乱することはありません。幸いなことに、それほど具体的である必要はありません。COBOLでは、中間の不要な修飾レベルを省略できます。これにより、 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; にMOVE 'フィラデルフィア'がうまく機能するようになります。</target>
        </trans-unit>
        <trans-unit id="219877a3941189d29da78605ffc816ab5f2a7b89" translate="yes" xml:space="preserve">
          <source>Now, assume that another program reads this file, but describes 10-character records rather than 6. Here are the records</source>
          <target state="translated">さて、別のプログラムがこのファイルを読み、6文字ではなく10文字のレコードを記述しているとします。 以下にレコードを示します。</target>
        </trans-unit>
        <trans-unit id="9b0d34c0dc28860109b36ba3a6f8a912103ad454" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-ADDRESS to &quot;Philadelphia&quot;. Clearly,&lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt;cannot work because the compiler will be unable to determine which of the two CITY fields you are referring to.</source>
          <target state="translated">ここで、従業員のMAILING-ADDRESSのCITY部分を「フィラデルフィア」に設定する問題に対処しましょう。明らかに、 &lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt; は機能しません。コンパイラーが2つのCITYフィールドのどちらを参照しているかを判別できないためです。</target>
        </trans-unit>
        <trans-unit id="ce50db412280505597bf9414695fbcc5fc0e3f7b" translate="yes" xml:space="preserve">
          <source>Now, the roles of the two languages in the previous section will be reversed, having a C main program execute a GnuCOBOL subprogram.</source>
          <target state="translated">ここで、前節の2つの言語の役割を逆にして、CのメインプログラムにGnuCOBOLのサブプログラムを実行させることにします。</target>
        </trans-unit>
        <trans-unit id="f60c8b64229a047f941675b68f85587ecce4b520" translate="yes" xml:space="preserve">
          <source>Numeric Data Item</source>
          <target state="translated">数値データ項目</target>
        </trans-unit>
        <trans-unit id="c9fbc7f3c5ecccd87db3e696a9c121879251fe81" translate="yes" xml:space="preserve">
          <source>Numeric Edited</source>
          <target state="translated">数値編集</target>
        </trans-unit>
        <trans-unit id="63ddf527a277f4c347e2246f00b1c4f8cda03669" translate="yes" xml:space="preserve">
          <source>Numeric Edited Data Item</source>
          <target state="translated">数値編集データ項目</target>
        </trans-unit>
        <trans-unit id="a24a22f9b40fcfe4d2691a6016ec524613059e17" translate="yes" xml:space="preserve">
          <source>Numeric Literal</source>
          <target state="translated">数値リテラル</target>
        </trans-unit>
        <trans-unit id="be2d608e3fa3ed6ad269186745305eb23ec33b56" translate="yes" xml:space="preserve">
          <source>Numeric data items will be initialized to a value of&lt;code&gt;ZERO&lt;/code&gt;</source>
          <target state="translated">数値データ項目は &lt;code&gt;ZERO&lt;/code&gt; 値に初期化されます</target>
        </trans-unit>
        <trans-unit id="289405511920b64e6183e96801f299b0a1170932" translate="yes" xml:space="preserve">
          <source>Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings. Windows Cygwin/NCurses builds recognize numeric keypad inputs properly. Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.</source>
          <target state="translated">GnuCOBOLのWindows MinGW/PDCursesビルドでは、数字のロック設定に関わらず、テンキーが認識できません。Windows の Cygwin/NCurses ビルドでは、テンキー入力を正しく認識します。この文書の準備中にテストしたわけではありませんが、PDCurses を使用したネイティブの Windows ビルドは MinGW ビルドと同じように動作し、NCurses を使用したネイティブの Unix ビルドは Cygwin ビルドと同じように動作することを期待しています。</target>
        </trans-unit>
        <trans-unit id="8eeea7541c21f9801d7c1875ed5f9c434348ce35" translate="yes" xml:space="preserve">
          <source>Numeric literals may be split across lines just as alphanumeric literals are, using either of the above techniques and both reserved and user-defined words can be split across lines too (using the first technique). The continuation of numeric literals and user-defined/reserved words is provided merely to provide compatibility with older COBOL versions and programs, but should not be used with new programs &amp;mdash; it just makes for ugly-looking programs.</source>
          <target state="translated">数値リテラルは、上記の手法のいずれかを使用して、英数字リテラルと同じように行に分割できます。予約語とユーザー定義語の両方を行に分割することもできます（最初の手法を使用）。数値リテラルとユーザー定義/予約語の継続は、以前のCOBOLバージョンおよびプログラムとの互換性を提供するためだけに提供されていますが、新しいプログラムでは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="6f2932e8faff18c0314f3a04f9aec75edec07a2f" translate="yes" xml:space="preserve">
          <source>OBJECT, OBJECT-COMPUTER, OBJECT-REFERENCE, OCCURS, OF, OFF, OMITTED, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, OVERFLOW, OVERLINE, OVERRIDE</source>
          <target state="translated">オブジェクト、オブジェクトコンピュータ、オブジェクト参照、発生、of、off、省略、on、only、open、optional、options、or、ord、order、ord-max、ord-min、organization、organization、other、output、overflow、overline、override</target>
        </trans-unit>
        <trans-unit id="2e78bec2d3800e6a21f1a284d7a3afd18c2fcd63" translate="yes" xml:space="preserve">
          <source>OBJECT-COMPUTER Syntax</source>
          <target state="translated">OBJECT-COMPUTER 構文</target>
        </trans-unit>
        <trans-unit id="cec1574213ff5c57fb26687d05dd766be420fc2b" translate="yes" xml:space="preserve">
          <source>OCCURS &amp;hellip; DEPENDING ON data item out of bounds</source>
          <target state="translated">OCCURS&amp;hellip;DEPENDING ONデータ項目が範囲外</target>
        </trans-unit>
        <trans-unit id="b800486653c7a1c77e853e0c004749a0fd2748a9" translate="yes" xml:space="preserve">
          <source>OCCURS (All Other Sections Clause Syntax</source>
          <target state="translated">OCCURS (他のすべてのセクションの節の構文)</target>
        </trans-unit>
        <trans-unit id="dd0b3221d40b5306dd784b27996de5c44ec57b1a" translate="yes" xml:space="preserve">
          <source>OCCURS (REPORT SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (REPORT SECTION)節構文</target>
        </trans-unit>
        <trans-unit id="6b31ee2b7fdf9b827a81f695d24c794e1825c9ac" translate="yes" xml:space="preserve">
          <source>OCCURS (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">OCCURS(SCREEN SECTION)節構文</target>
        </trans-unit>
        <trans-unit id="12163d548f84d0d3a65be49f9405b588882fb830" translate="yes" xml:space="preserve">
          <source>ON EXCEPTION Syntax</source>
          <target state="translated">ON EXCEPTION 構文</target>
        </trans-unit>
        <trans-unit id="fae727086e90c1747900d70ffd7f8b15f8dbda95" translate="yes" xml:space="preserve">
          <source>ON OVERFLOW Syntax</source>
          <target state="translated">ON OVERFLOW 構文</target>
        </trans-unit>
        <trans-unit id="66bebaca5aeeed104d7154b3d0f92463c9dd8dd1" translate="yes" xml:space="preserve">
          <source>ON SIZE ERROR Syntax</source>
          <target state="translated">ON SIZE ERROR 構文</target>
        </trans-unit>
        <trans-unit id="36dfa4bed24bebe94e869396499f245644973c4a" translate="yes" xml:space="preserve">
          <source>OPEN Syntax</source>
          <target state="translated">OPEN 構文</target>
        </trans-unit>
        <trans-unit id="cf0fe9af8bea7d1e731289cfef0c8038f4bc83dd" translate="yes" xml:space="preserve">
          <source>ORD Function Syntax</source>
          <target state="translated">ORD 関数構文</target>
        </trans-unit>
        <trans-unit id="9ad6006b98ba7b9576a4512aa283c527f6a05c6a" translate="yes" xml:space="preserve">
          <source>ORD-MAX Function Syntax</source>
          <target state="translated">ORD-MAX 関数構文</target>
        </trans-unit>
        <trans-unit id="09ee84df5eb17ff7d1f3553b1cbd5d58418d7791" translate="yes" xml:space="preserve">
          <source>ORD-MIN Function Syntax</source>
          <target state="translated">ORD-MIN 関数構文</target>
        </trans-unit>
        <trans-unit id="08b26f9634d2a732e998aa2218316415ad38194c" translate="yes" xml:space="preserve">
          <source>ORGANIZATION INDEXED Clause Syntax</source>
          <target state="translated">ORGANIZATION INDEX 句構文</target>
        </trans-unit>
        <trans-unit id="2df4622dcdea677d5d9a83663b8cbf91c2189a6b" translate="yes" xml:space="preserve">
          <source>ORGANIZATION LINE SEQUENTIAL Clause Syntax</source>
          <target state="translated">ORGANIZATION LINE SEQUENTIAL 節構文</target>
        </trans-unit>
        <trans-unit id="86ee1da50c2e8a0ec7111d29363f3c837bd97118" translate="yes" xml:space="preserve">
          <source>ORGANIZATION RELATIVE Clause Syntax</source>
          <target state="translated">ORGANIZATION RELATIVE 節構文</target>
        </trans-unit>
        <trans-unit id="750186647b33c3656503302d8eccc530bc37f0af" translate="yes" xml:space="preserve">
          <source>ORGANIZATION SEQUENTIAL Clause Syntax</source>
          <target state="translated">ORGANIZATION SEQUENTIAL 節構文</target>
        </trans-unit>
        <trans-unit id="578fbcff15d7037e9429c12a53b4d74f6a1577f1" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will be used to CALL the subprogram.</source>
          <target state="translated">OS/2 &quot;OPTLINK &quot;の規約は、サブプログラムをCALLするために使用されます。</target>
        </trans-unit>
        <trans-unit id="c666501d06dc9305a9b7b68de3b3d3562fd28b49" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will not be used to CALL the subprogram.</source>
          <target state="translated">OS/2 &quot;OPTLINK &quot;の規約は、サブプログラムをCALLするために使用されません。</target>
        </trans-unit>
        <trans-unit id="c8e1209593b1149f5f3f8ee76008515520f2193a" translate="yes" xml:space="preserve">
          <source>OVERLINE Attribute Syntax</source>
          <target state="translated">OVERLINE 属性構文</target>
        </trans-unit>
        <trans-unit id="4924a4d3bf56aa4a828e65f5066f009ce7e62b7d" translate="yes" xml:space="preserve">
          <source>Observe the definitions of data items &quot;Q&quot; and &quot;Y&quot;&amp;hellip;</source>
          <target state="translated">データ項目「Q」と「Y」の定義を確認してください&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="46c20583dd7802c40938fc2ba6c6048df2b3e1e9" translate="yes" xml:space="preserve">
          <source>Observe the following example, which illustrates a fourth manner in which tables may be initialized in GnuCOBOL:</source>
          <target state="translated">以下の例は、GnuCOBOLでテーブルを初期化する4つ目の方法を示しています。</target>
        </trans-unit>
        <trans-unit id="cec634d4f1c842c1c34e5d70b1e1bba15a325f09" translate="yes" xml:space="preserve">
          <source>Of course, arithmetic expression operands may be numeric data items (any USAGE except POINTER or PROGRAM POINTER) as well as numeric literals.</source>
          <target state="translated">もちろん、算術式オペランドは、数値リテラルだけでなく、数値データ項目(POINTERまたはPROGRAM POINTER以外の任意のUSAGE)であってもよい。</target>
        </trans-unit>
        <trans-unit id="78a794760583154700dfa158ef52ff59305ad6d4" translate="yes" xml:space="preserve">
          <source>Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms &amp;rsquo;</source>
          <target state="translated">もちろん、古い標準との後方互換性を維持するという長年のCOBOLの伝統に沿って、プログラマー（そしてもちろん、準拠するCOBOLコンパイラー）はどちらのモードでも作業できます。同じプログラムで前後に切り替えることも可能です。用語 '</target>
        </trans-unit>
        <trans-unit id="c2e2ad12fe5d5be1ef373c4a92ce471d2c101183" translate="yes" xml:space="preserve">
          <source>Of course, whatever software you are using to deliver the printed document to the printer with must allow the ASCII form-feed character to pass through to the printer.</source>
          <target state="translated">もちろん、印刷された文書をプリンタに配信するために使用しているどのようなソフトウェアであっても、ASCIIフォームフィード文字がプリンタに通過できるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="debcb349f44f33085c8c31a98daa95f7f75004d5" translate="yes" xml:space="preserve">
          <source>Of those currency symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by the currency symbol in-effect for the program (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;). Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces.</source>
          <target state="translated">先頭のゼロが存在する文字位置に対応する通貨記号のうち、最も右側の「0」の値は、プログラムで有効な通貨記号に置き換えられます（&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMESを&lt;/a&gt;参照）。この記号で説明されている位置を占める残りの先行ゼロ値は、スペースで置き換えられます。</target>
        </trans-unit>
        <trans-unit id="6b4cb7a0fee3f3079461060f2f2b75e5bfc06ee6" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;+&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a &quot;+&quot; if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">先行ゼロが存在する文字位置に対応する &lt;code&gt;+&lt;/code&gt; 記号のうち、最も右側のデータ項目の値がゼロ以上の場合は「0」値が「+」に、そうでない場合は「-」に置き換えられます。この記号で説明されている位置を占める残りの先行ゼロ値は、スペースで置き換えられます。同じ&amp;lt;で &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;-&lt;/code&gt; の両方を使用することはできません</target>
        </trans-unit>
        <trans-unit id="bbf75e8475f5c8168cfdefa614e07198b0695e55" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;-&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a space if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">それらのうち &lt;code&gt;-&lt;/code&gt; 先行ゼロが存在する文字位置に対応する記号では、データ項目の値がゼロ以上の場合、右端の「0」値がスペースに置き換えられ、それ以外の場合は「-」になります。この記号で説明されている位置を占める残りの先行ゼロ値は、スペースで置き換えられます。同じ&amp;lt;で &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;-&lt;/code&gt; の両方を使用することはできません</target>
        </trans-unit>
        <trans-unit id="8b1fab1aa655192e46dd089ef5dc5c15017129e0" translate="yes" xml:space="preserve">
          <source>On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the</source>
          <target state="translated">UNIX (OSX,Windows/Cygwin,Windows/MinGW を含む)システムでは、ロケールは</target>
        </trans-unit>
        <trans-unit id="7a4815ab2f080a81cd2be95835f85ca49905ca48" translate="yes" xml:space="preserve">
          <source>On Unix, OSX, or Windows/Cygwin builds, the&lt;code&gt;-x&lt;/code&gt;switch switch will generate an executable binary file, usually with no particular extension unless one is explicitly requested of the compiler via the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">Unix、OSX、またはWindows / Cygwinビルドでは、 &lt;code&gt;-x&lt;/code&gt; スイッチスイッチは実行可能なバイナリファイルを生成します。通常、 &lt;code&gt;-o&lt;/code&gt; スイッチを介してコンパイラに明示的に要求されない限り、特定の拡張子はありません。</target>
        </trans-unit>
        <trans-unit id="baa101f65e9944384124638ea3189587789c566a" translate="yes" xml:space="preserve">
          <source>On Windows systems, single-quote, or apostrophe characters (&amp;rsquo;) will be treated just like any other data character and will NOT delineate argument strings.</source>
          <target state="translated">Windowsシステムでは、単一引用符またはアポストロフィ文字（ '）は、他のデータ文字と同じように扱われ、引数文字列を記述しません。</target>
        </trans-unit>
        <trans-unit id="4540801fc126e86f0e453dd121110c00baa3a3f3" translate="yes" xml:space="preserve">
          <source>On a UNIX system this means the programs may be executed from a command shell such as bash, csh, ksh and so forth. When a GnuCOBOL program runs on a Windows system, it runs within a console window (i.e. &quot;cmd.exe&quot;). OSX versions of GnuCOBOL programs run within a &quot;terminal.app&quot; window.</source>
          <target state="translated">UNIXシステムでは、これはプログラムがbash、csh、kshなどのコマンドシェルから実行されることを意味します。Windowsシステム上でGnuCOBOLプログラムを実行する場合、コンソールウィンドウ(例:&quot;cmd.exe&quot;)内で実行されます。OSX版のGnuCOBOLプログラムは「terminal.app」ウィンドウ内で動作します。</target>
        </trans-unit>
        <trans-unit id="29e07a8440be1b45abe631d62a1c13d7f8e27480" translate="yes" xml:space="preserve">
          <source>On a Unix system, the shell environment will be established using the default shell program. This is also true when using a GnuCOBOL build created with and for OSX or the Cygwin Unix emulator.</source>
          <target state="translated">Unix システムでは、シェル環境はデフォルトのシェルプログラムを使用して確立されます。これは、OSXやCygwin Unixエミュレータで作成されたGnuCOBOLビルドを使用している場合にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="09cea21f0e62fb9defc06b78067faf5ba65df913" translate="yes" xml:space="preserve">
          <source>On a Windows system, the&lt;code&gt;TMP&lt;/code&gt;environment variable is normally set for you when you logon. If you wish to use a different temporary folder, you may set&lt;code&gt;TMPDIR&lt;/code&gt;yourself and have no fear of disrupting other Windows software that relies on TMP.</source>
          <target state="translated">Windowsシステムでは、 &lt;code&gt;TMP&lt;/code&gt; 環境変数は通常、ログオン時に設定されます。別の一時フォルダを使用したい場合は、 &lt;code&gt;TMPDIR&lt;/code&gt; を自分で設定でき、TMPに依存する他のWindowsソフトウェアを妨害する恐れはありません。</target>
        </trans-unit>
        <trans-unit id="49c811f291ecda0c24fa5479b92e28877266432a" translate="yes" xml:space="preserve">
          <source>On a system supporting only one format of binary storage (generally, that would be big-endian), the terms &amp;rsquo;most-efficient&amp;rsquo; and &amp;rsquo;native format&amp;rsquo; are synonymous.</source>
          <target state="translated">バイナリストレージの1つの形式のみをサポートするシステム（通常、これはビッグエンディアンになります）では、「最も効率的な」および「ネイティブ形式」という用語は同義です。</target>
        </trans-unit>
        <trans-unit id="8cf55637bf6e9946a839f557065a9756657be924" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after any control break occurs.</source>
          <target state="translated">任意の制御ブレークが発生した後の詳細グループの最初のプレゼンテーションで。</target>
        </trans-unit>
        <trans-unit id="e5bea69f1d184e8b4396de7835faab7aa40b288f" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after every new page is started.</source>
          <target state="translated">新しいページが始まるたびに詳細グループの最初のプレゼンテーションで</target>
        </trans-unit>
        <trans-unit id="17545f79b06e402b5aa4758aadea0e8d4f7b4497" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group following the&lt;code&gt;INITIATE&lt;/code&gt;(see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) of the report.</source>
          <target state="translated">レポートの &lt;code&gt;INITIATE&lt;/code&gt; （&lt;a href=&quot;#INITIATE&quot;&gt;INITIATEを&lt;/a&gt;参照）に続く詳細グループの最初のプレゼンテーション。</target>
        </trans-unit>
        <trans-unit id="621bb9957748f1c9660b66609e36e16b3f8976de" translate="yes" xml:space="preserve">
          <source>Once GnuCOBOL programs have been compiled into either directly-executable programs (created via the&lt;code&gt;-x&lt;/code&gt;switch) or dynamically-loadable libraries (created via the&lt;code&gt;-m&lt;/code&gt;switch), those programs may be executed from any shell environment. The exact manner in which the two are executed will differ, as described in the upcoming sections.</source>
          <target state="translated">GnuCOBOLプログラムが直接実行可能なプログラム（ &lt;code&gt;-x&lt;/code&gt; スイッチを介して作成）または動的にロード可能なライブラリ（ &lt;code&gt;-m&lt;/code&gt; スイッチを介して作成）にコンパイルされると、これらのプログラムは任意のシェル環境から実行できます。次のセクションで説明するように、2つが実行される正確な方法は異なります。</target>
        </trans-unit>
        <trans-unit id="77004179f0b5866728a6a173ab6e2cd8c6678cae" translate="yes" xml:space="preserve">
          <source>Once a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement is encountered in the currently-compiling source file, Replace Mode becomes active, and the change(s) specified by that statement will be automatically made on all subsequent source statements the compiler reads from the file.</source>
          <target state="translated">現在コンパイル中のソースファイルでFormat 1 &lt;code&gt;REPLACE&lt;/code&gt; ステートメントが検出されると、Replace Modeがアクティブになり、そのステートメントで指定された変更が、コンパイラーがファイルから読み取る後続のすべてのソースステートメントで自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="dc16e338caa3250507aeb7e1c7c59077ca7fc160" translate="yes" xml:space="preserve">
          <source>Once a dynamically-loadable module is actually loaded into memory, even if it is subsequently unloaded (via the&lt;code&gt;CANCEL&lt;/code&gt;statement), it&amp;rsquo;s list of entry-points remain available to the GnuCOBOL run-time library and subsequent re-executions of any of those entry points will be able to bypass the search (rule #4) as well as the &quot;first-execution rule&quot; (rule #3).</source>
          <target state="translated">動的にロード可能なモジュールが実際にメモリにロードされると、その後（ &lt;code&gt;CANCEL&lt;/code&gt; ステートメントを介して）アンロードされた場合でも、そのエントリポイントのリストは、GnuCOBOLランタイムライブラリで引き続き利用可能であり、その後、それらのエントリを再実行できます。ポイントは、検索（ルール＃4）と「初回実行ルール」（ルール＃3）をバイパスすることができます。</target>
        </trans-unit>
        <trans-unit id="59e918dab4bdf59a27422aa9bebbbdf5591d8385" translate="yes" xml:space="preserve">
          <source>Once a field list has been determined, each item in that field list will be initialized as if an individual&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) statement to that effect had been coded. The rules for initialization are as follows:</source>
          <target state="translated">フィールドリストが決定されると、そのフィールドリストの各項目は、その効果に対する個々の &lt;code&gt;MOVE&lt;/code&gt; （&lt;a href=&quot;#MOVE&quot;&gt;MOVEを&lt;/a&gt;参照）ステートメントがコーディングされているかのように初期化されます。初期化のルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="286757838794003214e83168a9d3c53442e79df6" translate="yes" xml:space="preserve">
          <source>Once an environment variable name base (let&amp;rsquo;s refer to it as &quot;bbbb&quot;) has been determined, the runtime system will look for the first one of the following environment variables that exists, in this sequence:</source>
          <target state="translated">環境変数名のベース（ &quot;bbbb&quot;と呼びましょう）が決定されると、ランタイムシステムは、次の環境変数の最初の1つをこの順序で探します。</target>
        </trans-unit>
        <trans-unit id="e625244fde391b91510dca176749dade404d9a46" translate="yes" xml:space="preserve">
          <source>Once class &quot;Hexadecimal&quot; has been defined, program code could then use a statement such as&lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt;to determine if the value of characters in a data item are valid according to that class.</source>
          <target state="translated">クラス「16進数」が定義されると、プログラムコードは &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; などのステートメントを使用して、データアイテムの文字の値がそのクラスに従って有効かどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="0585d2910d0c3575c9ce966ec284963466eee0b8" translate="yes" xml:space="preserve">
          <source>Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the&lt;code&gt;DATE-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;) or&lt;code&gt;DAY-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;) function.</source>
          <target state="translated">いったんその形式になると、 &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; （&lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGERを&lt;/a&gt;参照）または &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; （&lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGERを&lt;/a&gt;参照）を使用して日付に変換される前に、内部日付に対して数学演算を実行できます。） 関数。</target>
        </trans-unit>
        <trans-unit id="3d181d18b6a5fa0a6fa8cff3acb56941d7cd3053" translate="yes" xml:space="preserve">
          <source>Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt; If the optional&lt;code&gt;INTO&lt;/code&gt;</source>
          <target state="translated">ファイルから読み取られると、新しく取得されたレコードデータは、ファイルの &lt;code&gt;FD&lt;/code&gt; の直後に続く01レベルのレコード構造に保存されます。オプションの &lt;code&gt;INTO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed7991d9259d5488ffed54f05830f63330c16c88" translate="yes" xml:space="preserve">
          <source>Once the &amp;lt;</source>
          <target state="translated">一度</target>
        </trans-unit>
        <trans-unit id="76eaa092cafda97efbcf2f6303d6984802250d02" translate="yes" xml:space="preserve">
          <source>Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; at work, see the discussions of the&lt;code&gt;CBL_ERROR_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and&lt;code&gt;CBL_EXIT_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</source>
          <target state="translated">このようにして手続き部コード領域のアドレスが取得されると、そのアドレスは、必要に応じて、サブルーチン（通常はCで記述）に渡すことができます。作業中の &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; の例については、 &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; 組み込みシステムサブルーチン（&lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROCを&lt;/a&gt;参照）および &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; 組み込みシステムサブルーチン（&lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROCを&lt;/a&gt;参照）の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="e7b3e993beace23677f33388c1750dc84928bf9a" translate="yes" xml:space="preserve">
          <source>Once the dynamically-loadable module has been successfully loaded, any of the entry-points contained within it are now available for reference.</source>
          <target state="translated">動的にロード可能なモジュールが正常にロードされると、その中に含まれるエントリポイントが参照可能になります。</target>
        </trans-unit>
        <trans-unit id="bf655804b96355c58d780ad7c184b2358e70ed87" translate="yes" xml:space="preserve">
          <source>Once the input procedure terminates, the input phase is complete.</source>
          <target state="translated">入力手順が終了すると、入力フェーズが終了します。</target>
        </trans-unit>
        <trans-unit id="3fd5f8ce1885cd5e6704d4107925ee0fa79ae370" translate="yes" xml:space="preserve">
          <source>Once the list of control breaks has been determined, the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">コントロール・ブレークのリストは、決定された後 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; それぞれについての&amp;lt;</target>
        </trans-unit>
        <trans-unit id="da82fa2addff5a8b53971b5198ac5b3f2dbaf44c" translate="yes" xml:space="preserve">
          <source>Once the module has been located (if location was needed), it will be loaded into memory (if not already loaded).</source>
          <target state="translated">モジュールが配置されると(配置が必要な場合)、それはメモリにロードされます(まだロードされていない場合)。</target>
        </trans-unit>
        <trans-unit id="4ea7f4222f4e79b517953879f7a0910e37dccbb7" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, or the last &amp;lt;</source>
          <target state="translated">出力プロシージャが終了すると、または最後の&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ff0f3a202fb5e56e9e5055a0c22a464e320087b3" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, the sort is complete.</source>
          <target state="translated">出力手続きが終了すると、ソートが完了します。</target>
        </trans-unit>
        <trans-unit id="aa2d27ad2b6a5bb2d485b2b3cf531800fdf57d2a" translate="yes" xml:space="preserve">
          <source>Once the sort stage is complete, a copy of the sorted data will be written to each &amp;lt;</source>
          <target state="translated">並べ替えステージが完了すると、並べ替えられたデータのコピーが各&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a952da0c3633e235f52bb16ddddf1c8394a97156" translate="yes" xml:space="preserve">
          <source>Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the &quot;CHAINING&quot; arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.</source>
          <target state="translated">トークンが識別されると、最初の(コマンド)は破棄され、残りはプログラムの実行開始時に &quot;CHAINING &quot;引数に格納され、2番目のトークンは第1引数に、3番目のトークンは第2引数に、などとなります。</target>
        </trans-unit>
        <trans-unit id="fc842de35b43065fcc2486b3f9cd1a54afa40e68" translate="yes" xml:space="preserve">
          <source>Once you have defined an alphabet name, that alphabet name may be used on specifications in&lt;code&gt;CODE-SET&lt;/code&gt;&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; or&lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt;clauses elsewhere in the program.</source>
          <target state="translated">アルファベット名を定義すると、そのアルファベット名は、プログラムの他の場所にある &lt;code&gt;CODE-SET&lt;/code&gt; &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; または &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; 句の仕様で使用できます。</target>
        </trans-unit>
        <trans-unit id="1db8d869f5e31c2a114146e31c6c3bb19304efe6" translate="yes" xml:space="preserve">
          <source>Once you know the answer to questions 1-4, you may easily determine the answers to the remaining questions as follows:</source>
          <target state="translated">問1~4の答えがわかれば、以下のように残りの問題の答えを簡単に決めることができます。</target>
        </trans-unit>
        <trans-unit id="d64e944e7805a2994fd1366f274fdd6a314f0fc1" translate="yes" xml:space="preserve">
          <source>Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &amp;lt;</source>
          <target state="translated">プログラムを徹底的にテストしたら、プログラムを実行するたびに異なるシーケンスを生成する必要があります。これを実現する1つの可能な方法は、&amp;lt;</target>
        </trans-unit>
        <trans-unit id="54f89a5962f679ffd2d3e844b0b1ce85b6df3297" translate="yes" xml:space="preserve">
          <source>One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</source>
          <target state="translated">これらの環境変数の1つは、一時ファイルを作成するのに適切なディレクトリ/フォルダーに設定する必要があります。これらは、示されている順序でチェックされます。これはで使用される &lt;code&gt;SORT&lt;/code&gt; の声明（参照&lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;）と &lt;code&gt;MERGE&lt;/code&gt; 文は（参照&lt;a href=&quot;#MERGE&quot;&gt;MERGEを&lt;/a&gt;）一時作業ファイルを作成します。アプリケーションが必要とする可能性のある一時ファイルにもこのフォルダを使用できます。</target>
        </trans-unit>
        <trans-unit id="f6463f11b8fdf738c63c7b961b5112c2ffeb1404" translate="yes" xml:space="preserve">
          <source>One or more consecutive lines on a report that serve a common informational purpose or function. For example, lines of text that are displayed at the top or bottom of every printed page of a report.</source>
          <target state="translated">報告書上の1行以上の連続した行で、共通の情報提供の目的または機能を果たすもの。例えば、レポートの各印刷ページの上部または下部に表示されるテキストの行。</target>
        </trans-unit>
        <trans-unit id="6c681ed8f13156a1b9ed27937daab32b1e788722" translate="yes" xml:space="preserve">
          <source>Only after this processing has occurred will the detail report group specified on the&lt;code&gt;GENERATE&lt;/code&gt;be presented.</source>
          <target state="translated">この処理が行われた後にのみ、 &lt;code&gt;GENERATE&lt;/code&gt; で指定された詳細レポートグループが表示されます。</target>
        </trans-unit>
        <trans-unit id="003eead4533ce41b48b2d118ad6982ea6215902b" translate="yes" xml:space="preserve">
          <source>Only data items whose&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as&lt;code&gt;DISPLAY&lt;/code&gt;may be used in&lt;code&gt;NUMERIC&lt;/code&gt;or any of the&lt;code&gt;ALPHABETIC&lt;/code&gt;class conditions.</source>
          <target state="translated">その唯一のデータ項目 &lt;code&gt;USAGE&lt;/code&gt; （参照&lt;a href=&quot;#USAGE&quot;&gt;USAGEに&lt;/a&gt;）明示的または暗黙的として定義されている &lt;code&gt;DISPLAY&lt;/code&gt; で使用することができる &lt;code&gt;NUMERIC&lt;/code&gt; または任意の &lt;code&gt;ALPHABETIC&lt;/code&gt; クラス条件。</target>
        </trans-unit>
        <trans-unit id="d711ce7b6238bc52f8a6bcb50fdf5f00798177b9" translate="yes" xml:space="preserve">
          <source>Only files intended for use as work files for either the&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or&lt;code&gt;MERGE&lt;/code&gt;(see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</source>
          <target state="translated">いずれか一方のみのための作業ファイルとして使用することを意図したファイル &lt;code&gt;SORT&lt;/code&gt; （参照&lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;）または &lt;code&gt;MERGE&lt;/code&gt; （参照&lt;a href=&quot;#MERGE&quot;&gt;MERGEを&lt;/a&gt;）文がSDでコーディングする必要があります-他のすべては、FDを使用して定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="5e7f05d01153592a3701f9579ca1ebed0c7e36f8" translate="yes" xml:space="preserve">
          <source>Only numeric data can be moved to a numeric or numeric-edited &amp;lt;</source>
          <target state="translated">数値または数値編集された&amp;lt;に移動できるのは数値データのみです。</target>
        </trans-unit>
        <trans-unit id="1a023314ae52d9ab2ebf57a5486f828683de142e" translate="yes" xml:space="preserve">
          <source>Only one of the &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;の1つだけ</target>
        </trans-unit>
        <trans-unit id="6e90f6903d2acd5d4289ceddbb76ae736395dc5d" translate="yes" xml:space="preserve">
          <source>Only one user-defined error procedure may be in effect at any time.</source>
          <target state="translated">ユーザー定義のエラープロシージャは、いつでも1つだけ有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="27fae19fb8fcab28fe3712f2fe8be9894d412e8a" translate="yes" xml:space="preserve">
          <source>Only one user-defined exit procedure may be in effect at any time.</source>
          <target state="translated">ユーザー定義の終了手順は、いつでも1つだけ有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="8276bb34bd3b8954c5e1d44b6e4b6663af21c5d2" translate="yes" xml:space="preserve">
          <source>Only the final clause specified within this paragraph should be terminated with a period.</source>
          <target state="translated">この段落内で指定された最終節のみ、期間をもって終了させること。</target>
        </trans-unit>
        <trans-unit id="19093a1f09bb5bb1f9ea7e1e012a0f82b409bbd3" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will NOT behave as a&lt;code&gt;mkdir -p&lt;/code&gt;(Unix) or&lt;code&gt;mkdir /p&lt;/code&gt;(Windows).</source>
          <target state="translated">指定したパスの最下位レベルのディレクトリ（最後）のみを作成できます。その他のディレクトリはすべて存在している必要があります。このサブルーチンは、 &lt;code&gt;mkdir -p&lt;/code&gt; （UNIX）または &lt;code&gt;mkdir /p&lt;/code&gt; （Windows）としては動作しません。</target>
        </trans-unit>
        <trans-unit id="18a2770fd2028b8848e5939f9beca76f8630c1c6" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path will be deleted, and that directory must be empty to be deleted.</source>
          <target state="translated">指定したパス内の最下位のディレクトリ(最後の)のみが削除され、そのディレクトリは空でなければ削除されません。</target>
        </trans-unit>
        <trans-unit id="1aec312e1ee36a7183965a81eb1e3cb89dc201e9" translate="yes" xml:space="preserve">
          <source>Only those as-yet uninitialized list members meeting the criteria set forth for the specified &amp;lt;</source>
          <target state="translated">指定された&amp;lt;に対して設定された基準を満たす、まだ初期化されていないリストメンバーのみ</target>
        </trans-unit>
        <trans-unit id="e4d4f39f5c6f13114530b1c856be188e28a33feb" translate="yes" xml:space="preserve">
          <source>Opening a file with this sharing option indicates you are willing to allow other programs to&lt;code&gt;OPEN&lt;/code&gt;the file for input while you have it open. If they attempt any other&lt;code&gt;OPEN&lt;/code&gt; theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</source>
          <target state="translated">この共有オプションでファイルを開くと、他のプログラムができるようにするために喜んであることを示し &lt;code&gt;OPEN&lt;/code&gt; あなたがそれを開いている間、入力用のファイルを。他の &lt;code&gt;OPEN&lt;/code&gt; を試行すると、ファイルステータス37で失敗します。もちろん、他の誰かが最初にファイルにアクセスし、共有オプションを使用してファイル共有制限を課してファイルを開いた場合、プログラムは失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b290988bf20769fb3be0ec9ad35e8ff883c8e032" translate="yes" xml:space="preserve">
          <source>Optionally, the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">オプションで、 &lt;code&gt;-o&lt;/code&gt; スイッチ</target>
        </trans-unit>
        <trans-unit id="447171bcea279a3f9260c4de4e227c2d6dd68c76" translate="yes" xml:space="preserve">
          <source>Or it could simply utilize the condition name XL as follows:</source>
          <target state="translated">あるいは、以下のように単に条件名のXLを利用することもできます。</target>
        </trans-unit>
        <trans-unit id="370e4c255f90d246d5721bdc9fd05e213464a25e" translate="yes" xml:space="preserve">
          <source>Or, on a Native Windows or Windows/MinGW system:</source>
          <target state="translated">または、ネイティブWindowsやWindows/MinGWのシステムで。</target>
        </trans-unit>
        <trans-unit id="ba479d2e9dd775cad43c293e560fad3af36bde42" translate="yes" xml:space="preserve">
          <source>Other programming language provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</source>
          <target state="translated">他のプログラミング言語は、プログラマがプログラムの一部に対して独自の単語(名前)を作成する機能を提供しているが、COBOLは、他の言語と比較すると、ユーザ定義の単語を作成できるという点でやや特殊である。</target>
        </trans-unit>
        <trans-unit id="8bbcce1456c742787b1580fde33b8148c8987df5" translate="yes" xml:space="preserve">
          <source>Out of key range</source>
          <target state="translated">キーレンジ外</target>
        </trans-unit>
        <trans-unit id="a553d2153badfb1db45ee73715be9107f08adc68" translate="yes" xml:space="preserve">
          <source>Output from the command (if any) will appear in the command window in which the GnuCOBOL program was executed.</source>
          <target state="translated">コマンドからの出力は(もしあれば)、GnuCOBOLプログラムが実行されたコマンドウィンドウに表示されます。</target>
        </trans-unit>
        <trans-unit id="bf18ec4bed8c30a9b19eac1b32547e33a663188d" translate="yes" xml:space="preserve">
          <source>Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the&lt;code&gt;COMPUTE&lt;/code&gt;statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</source>
          <target state="translated">長年にわたり、効率性と使用の算術精度を超える多くの議論があった &lt;code&gt;COMPUTE&lt;/code&gt; 文を（参照&lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTEを&lt;/a&gt;）4つのつではなく、基本的な算術演算ステートメント。</target>
        </trans-unit>
        <trans-unit id="0e6ac5f3f6d5399374fefa09919d1c279a782632" translate="yes" xml:space="preserve">
          <source>Overflow condition</source>
          <target state="translated">オーバーフロー条件</target>
        </trans-unit>
        <trans-unit id="9caea4b058bdda37551cfd4b0757e6365f49b9e6" translate="yes" xml:space="preserve">
          <source>PACKED-DECIMAL, PADDING, PAGE, PAGE-COUNTER, PARAGRAPH, PERFORM, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, PRESENT-VALUE, PREVIOUS, PRINT, PRINTER, PRINTER-1, PRINTING, PROCEDURE, PROCEDURE-POINTER, PROCEDURES, PROCEED, PROGRAM, PROGRAM-ID, PROGRAM-POINTER, PROHIBITED, PROMPT, PROPERTY, PROTECTED, PROTOTYPE, PURGE</source>
          <target state="translated">padding,ページ,ページカウンタ,段落,実行,pf,ph,pi,pic,picture,plus,ポインタ,位置,正,接頭辞,現在,現在値,前,印刷,プリンタ,プリンタ-1,印刷,プロシージャ,プロシージャポインタ,プロシージャ,進行,プログラム,プログラムID,プログラムポインタ,禁止,プロンプト,プロパティ,保護された,プロトタイプ,パージ</target>
        </trans-unit>
        <trans-unit id="d48971351ade6fc5f890bc67a75e3fa21b22ca7e" translate="yes" xml:space="preserve">
          <source>PAGE FOOTING [1]</source>
          <target state="translated">ページの足元 [1]</target>
        </trans-unit>
        <trans-unit id="74d126652169159b5d6e6ea5e735209263036ae6" translate="yes" xml:space="preserve">
          <source>PAGE HEADING [1]</source>
          <target state="translated">ページ見出し [1]</target>
        </trans-unit>
        <trans-unit id="a7aa2c13f70d4d267a113972d52fc8706a2f0e22" translate="yes" xml:space="preserve">
          <source>PI Function Syntax</source>
          <target state="translated">PI関数の構文</target>
        </trans-unit>
        <trans-unit id="b3194ebbb74c1fdb2502a50c00eae2deeb0fe962" translate="yes" xml:space="preserve">
          <source>PIC 9(4) &amp;mdash; This is the default data item allocated for use by the&lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no&lt;code&gt;CRT STATUS&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</source>
          <target state="translated">PIC 9（4）&amp;mdash;これは、 &lt;code&gt;CRT STATUS&lt;/code&gt; （&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMESを&lt;/a&gt;参照）句が指定されていない場合、 &lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt; ステートメント（&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-itemを&lt;/a&gt;参照）で使用するために割り当てられたデフォルトのデータ項目です。 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
