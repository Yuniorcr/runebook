<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="ac9629aacf5a541205c4ec779ff11edb1576409e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;context&lt;/code&gt; is specified, the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; が指定されていない場合、デフォルトのコンテキスト &lt;code&gt;&quot;&quot;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="ed97555002c32aa9440a97e73ca69137e2f1b0fe" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;epmd&lt;/code&gt; (TCP port mapper daemon) is used, also command-line option &lt;code&gt;-no_epmd&lt;/code&gt; is to be specified, which makes Erlang skip the &lt;code&gt;epmd&lt;/code&gt; startup, both as an OS process and as an Erlang ditto.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; （TCPポートマッパーデーモン）を使用しない場合は、コマンドラインオプション &lt;code&gt;-no_epmd&lt;/code&gt; も指定する必要があります。これにより、Erlang はOSプロセスとしてもErlang &lt;code&gt;epmd&lt;/code&gt; としてもepmdの起動をスキップします。</target>
        </trans-unit>
        <trans-unit id="a8006619350a5226e5dc4b2683c9eea3a8bdbda4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;extended_info&lt;/code&gt; is present in the file and &lt;code&gt;{verify,true}&lt;/code&gt; is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was &lt;code&gt;public&lt;/code&gt; and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;, which extends the information in the file with the number of objects written.</source>
          <target state="translated">ファイルに &lt;code&gt;extended_info&lt;/code&gt; が存在せず、 &lt;code&gt;{verify,true}&lt;/code&gt; が指定されている場合、書き込まれたオブジェクトの数は、ダンプが開始されたときの元のテーブルのサイズと比較されます。これにより、テーブルが &lt;code&gt;public&lt;/code&gt; あり、テーブルがファイルにダンプされている間にオブジェクトが追加または削除された場合、検証が失敗する可能性があります。この問題を回避するには、同時に更新されている間にダンプされたファイルを検証しないか &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; オプション{extended_info、[object_count]}を &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; に使用して、書き込まれたオブジェクトの数でファイル内の情報を拡張します。</target>
        </trans-unit>
        <trans-unit id="8a45ca5e05cc70fae2783d55cbff20b1f8725403" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;name&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; を指定しない場合（または &lt;code&gt;&quot;&quot;&lt;/code&gt; の場合）、通知はすべての管理ターゲットに送信されます。</target>
        </trans-unit>
        <trans-unit id="32886c8cd8eda5943ea7814b65ec8cd639317821" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;tracer&lt;/code&gt; is specified, the calling process receives all the trace messages.</source>
          <target state="translated">&lt;code&gt;tracer&lt;/code&gt; が指定されていない場合、呼び出しプロセスはすべてのトレースメッセージを受信します。</target>
        </trans-unit>
        <trans-unit id="8acb8279a4661a4f996c3af79ec9be1db1d63648" translate="yes" xml:space="preserve">
          <source>If no BEAM file contains debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">デバッグ情報を含むBEAMファイルがない場合は、タプルのリストが返されます。各タプルの最初の要素は、以下のいずれかです。</target>
        </trans-unit>
        <trans-unit id="44e5f3c4af2c18aaf89a34918cf838e205862cec" translate="yes" xml:space="preserve">
          <source>If no BOM is found, the function returns &lt;code&gt;{latin1,0}&lt;/code&gt;.</source>
          <target state="translated">BOMが見つからない場合、関数は &lt;code&gt;{latin1,0}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e07f0cc9e55f8b5cf0585baaee7cd300085bb99c" translate="yes" xml:space="preserve">
          <source>If no CPU topology is available when flag &lt;code&gt;+sbt&lt;/code&gt; is processed and &lt;code&gt;BindType&lt;/code&gt; is any other type than &lt;code&gt;u&lt;/code&gt;, the runtime system fails to start. CPU topology can be defined using flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt;. Notice that flag &lt;code&gt;+sct&lt;/code&gt; can have to be passed before flag &lt;code&gt;+sbt&lt;/code&gt; on the command line (if no CPU topology has been automatically detected).</source>
          <target state="translated">フラグ &lt;code&gt;+sbt&lt;/code&gt; が処理され、 &lt;code&gt;BindType&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; 以外のタイプであるときにCPUトポロジーが使用できない場合、ランタイムシステムは起動に失敗します。CPUトポロジは、フラグ &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt; を使用して定義できます。コマンドラインでフラグ &lt;code&gt;+sct&lt;/code&gt; をフラグ &lt;code&gt;+sbt&lt;/code&gt; の前に渡す必要があることに注意してください（CPUトポロジが自動的に検出されていない場合）。</target>
        </trans-unit>
        <trans-unit id="dccd7290f5c52ab540d1d1066d43a3aaf228c19a" translate="yes" xml:space="preserve">
          <source>If no argument is provided, Debugger starts in global mode.</source>
          <target state="translated">引数を指定しない場合、デバッガはグローバルモードで起動します。</target>
        </trans-unit>
        <trans-unit id="1fe7b07f514dd69941a31088b490f38f80374e4c" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ブートスクリプトが指定されていない場合、デフォルトは &lt;code&gt;ROOT/bin/start&lt;/code&gt; です。 &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="b11dd24d2508db0b969937d6f16c64e7e9a757da" translate="yes" xml:space="preserve">
          <source>If no command-line flag is entered, the &lt;code&gt;Mnesia&lt;/code&gt; directory becomes the current working directory on the node where the Erlang shell is started.</source>
          <target state="translated">コマンドラインフラグが入力されていない場合、 &lt;code&gt;Mnesia&lt;/code&gt; ディレクトリは、Erlangシェルが起動されているノードの現在の作業ディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="19b61bf39702f61088362c4f3caf5fec39790a79" translate="yes" xml:space="preserve">
          <source>If no configuration exists for a server, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead, and specify all necessary options in the &lt;code&gt;Options&lt;/code&gt; parameter.</source>
          <target state="translated">サーバーの構成が存在しない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; を使用して、必要なすべての &lt;code&gt;Options&lt;/code&gt; パラメーターで指定します。</target>
        </trans-unit>
        <trans-unit id="a0a2525519fce3b84f0628d21fec24d0d54a30b8" translate="yes" xml:space="preserve">
          <source>If no configuration file is specified with command &lt;code&gt;ct_run&lt;/code&gt;, a warning is displayed. If &lt;code&gt;Common Test&lt;/code&gt; has been run from the same directory earlier, the same configuration file(s) are used again. If &lt;code&gt;Common Test&lt;/code&gt; has not been run from this directory before, no configuration files are available.</source>
          <target state="translated">コマンド &lt;code&gt;ct_run&lt;/code&gt; で構成ファイルが指定されていない場合、警告が表示されます。場合は &lt;code&gt;Common Test&lt;/code&gt; 以前と同じディレクトリから実行された、同じ設定ファイル（複数可）が再び使用されています。以前にこのディレクトリから &lt;code&gt;Common Test&lt;/code&gt; を実行したことがない場合、使用可能な構成ファイルはありません。</target>
        </trans-unit>
        <trans-unit id="905acdf151b0fff2093942d03e8fda7ba4d6ef97" translate="yes" xml:space="preserve">
          <source>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned &lt;code&gt;pid&lt;/code&gt; for this process is to be used as input to all other API functions in this module.</source>
          <target state="translated">接続参照が指定されていない場合、接続が設定され、新しい接続が返されます。SSHチャネルプロセスが開始され、SFTPサーバーとの通信を処理します。このプロセスで返される &lt;code&gt;pid&lt;/code&gt; は、このモジュールの他のすべてのAPI関数への入力として使用されます。</target>
        </trans-unit>
        <trans-unit id="a012950e61dc5d03cdb78960de0564c38b5541f9" translate="yes" xml:space="preserve">
          <source>If no encoder module is given, the default is used (which is pretty).</source>
          <target state="translated">エンコーダモジュールが指定されていない場合は、デフォルトが使用されます(これはきれいです)。</target>
        </trans-unit>
        <trans-unit id="9348a769518853e44d89b99ac342c57ff1b5e15b" translate="yes" xml:space="preserve">
          <source>If no error occurs, the second phase is performed. This phase calls the user defined &lt;code&gt;set&lt;/code&gt; function for all variables.</source>
          <target state="translated">エラーが発生しない場合は、2番目のフェーズが実行されます。このフェーズでは、すべての変数に対してユーザー定義の &lt;code&gt;set&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3b135a2849366f4513f0e061b53465a7e3a779a4" translate="yes" xml:space="preserve">
          <source>If no exports are listed by an &lt;code&gt;export&lt;/code&gt; option (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details), then if &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under &lt;code&gt;merge/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; オプションでエクスポートがリストされていない場合（詳細については、 &lt;code&gt;merge_sources/3&lt;/code&gt; を参照）、 &lt;code&gt;Name&lt;/code&gt; が入力モジュールの1つの名前でもある場合、そのモジュールがエクスポートされます。それ以外の場合は、最初にリストされているモジュールがエクスポートされます。Cf. &lt;code&gt;merge/3&lt;/code&gt; の下の例。</target>
        </trans-unit>
        <trans-unit id="186696412f510e31ad8ed3a38fb86c31cd6ca5ca" translate="yes" xml:space="preserve">
          <source>If no extra options are specified with flag/option &lt;code&gt;step&lt;/code&gt;, breakpoints are set automatically on the test cases that are to be executed by &lt;code&gt;Common Test&lt;/code&gt;, and those functions only. If step option &lt;code&gt;config&lt;/code&gt; is specified, breakpoints are also initially set on the configuration functions in the suite, that is, &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, &lt;code&gt;end_per_group/2&lt;/code&gt;, &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2&lt;/code&gt;.</source>
          <target state="translated">flag / option &lt;code&gt;step&lt;/code&gt; で追加のオプションが指定されていない場合、ブレークポイントは、 &lt;code&gt;Common Test&lt;/code&gt; によって実行されるテストケースとそれらの関数のみに自動的に設定されます。ステップオプションの場合は &lt;code&gt;config&lt;/code&gt; 指定され、ブレークポイントはまた、最初のスイート内の構成機能に設定されている、即ち、 &lt;code&gt;init_per_suite/1&lt;/code&gt; 、 &lt;code&gt;end_per_suite/1&lt;/code&gt; 、 &lt;code&gt;init_per_group/2&lt;/code&gt; 、 &lt;code&gt;end_per_group/2&lt;/code&gt; 、 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 及び &lt;code&gt;end_per_testcase/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e1803a2624ccbd4e21f90db6095850fb9331a7" translate="yes" xml:space="preserve">
          <source>If no formatter information is specified for a handler, Logger uses &lt;code&gt;logger_formatter&lt;/code&gt; as default. See the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page for more information about this module.</source>
          <target state="translated">ハンドラーにフォーマッター情報が指定されていない場合、ロガーはデフォルトで &lt;code&gt;logger_formatter&lt;/code&gt; を使用します。このモジュールの詳細については、 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; のマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="534f259af2115bebe106710668093e3ef6ffd155" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">グラフタイプが指定されていない場合、 &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; 作成にはdigraph：new / 0が使用されます。それ以外の場合は、引数 &lt;code&gt;GraphType&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; の 2番目の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="4eb03e181763fc340f89dd2fee8a41ea21ee5c23" translate="yes" xml:space="preserve">
          <source>If no guard sequence is evaluated as true, an &lt;code&gt;if_clause&lt;/code&gt; run-time error occurs. If necessary, the guard expression &lt;code&gt;true&lt;/code&gt; can be used in the last branch, as that guard sequence is always true.</source>
          <target state="translated">どのガードシーケンスもtrueと評価されない場合、 &lt;code&gt;if_clause&lt;/code&gt; ランタイムエラーが発生します。ガードシーケンスは常にtrueであるため、必要に応じて、最後のブランチでガード式 &lt;code&gt;true&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="b9f6b9adc1152f1b0fd0e1ed73ad8eec4e1f624e" translate="yes" xml:space="preserve">
          <source>If no log with the specified name exist on the specified node, &lt;code&gt;no_such_log&lt;/code&gt; is returned.</source>
          <target state="translated">指定したノードに指定した名前のログが存在しない場合は、 &lt;code&gt;no_such_log&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="8f6ab79d1d5e9e2cd8b43d5f286fe816764eabff" translate="yes" xml:space="preserve">
          <source>If no match is found for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt; will be the empty string (&lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Tag&lt;/code&gt; に一致するものが見つからない場合、 &lt;code&gt;Result&lt;/code&gt; は空の文字列（ &lt;code&gt;[]&lt;/code&gt; ）になります。</target>
        </trans-unit>
        <trans-unit id="668861363db131d12510c671297ba7af08f41273" translate="yes" xml:space="preserve">
          <source>If no more event handlers exist after the deletion, &lt;code&gt;error_logger&lt;/code&gt; is removed as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is stopped.</source>
          <target state="translated">削除後にイベントハンドラーがなくなると、 &lt;code&gt;error_logger&lt;/code&gt; がロガーハンドラーとして削除され、 &lt;code&gt;error_logger&lt;/code&gt; プロセスが停止します。</target>
        </trans-unit>
        <trans-unit id="97bba64e22bb5e3d712c27f199cd41bb5ed00da4" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor bridge is not registered.</source>
          <target state="translated">名前が記載されていない場合、スーパーバイザーブリッジは登録されていません。</target>
        </trans-unit>
        <trans-unit id="145b04378100b2af31635cfab7037e102fc50e14" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor is not registered.</source>
          <target state="translated">名前が記載されていない場合は、監督者は登録されていません。</target>
        </trans-unit>
        <trans-unit id="962cccbaba0fe2900b8b208ab74fd43b13540b3f" translate="yes" xml:space="preserve">
          <source>If no object with key &lt;code&gt;Key&lt;/code&gt; exists, the function exits with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">キー &lt;code&gt;Key&lt;/code&gt; を持つオブジェクトが存在しない場合、関数は理由 &lt;code&gt;badarg&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="f3ace922192dd1a66ce93d65f216be69e6bdcfa0" translate="yes" xml:space="preserve">
          <source>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and &lt;code&gt;select&lt;/code&gt; is used to traverse the table, that is:</source>
          <target state="translated">オプションが指定されていない場合、読み取りロックが取得され、各チャンクで100の結果が返され、 &lt;code&gt;select&lt;/code&gt; を使用してテーブルをトラバースします。</target>
        </trans-unit>
        <trans-unit id="be43c0999b074d475f47490047515316aff57a56" translate="yes" xml:space="preserve">
          <source>If no or an unknown version is given, the &lt;strong&gt;best&lt;/strong&gt; version is used (which is v3).</source>
          <target state="translated">バージョンがない、または不明なバージョンが指定されている場合は、&lt;strong&gt;最適な&lt;/strong&gt;バージョン（v3）が使用されます。</target>
        </trans-unit>
        <trans-unit id="bc0db3920bc02374e1ab1e1eb3ced79753b79531" translate="yes" xml:space="preserve">
          <source>If no output comes from the Erlang shell, but the Erlang machine still seems to be alive, an &quot;ALIVE&quot; message is written to the log; it is a time stamp and is written, by default, after 15 minutes of inactivity. Also, if output from Erlang is logged, but more than 5 minutes (default) has passed since last time we got anything from Erlang, a time stamp is written in the log. The &quot;ALIVE&quot; messages look as follows:</source>
          <target state="translated">もしErlangシェルから何も出力されていないのにErlangマシンがまだ生きているように見える場合、&quot;ALIVE &quot;メッセージがログに書き込まれます。また、Erlangからの出力がログに記録されていて、最後にErlangから何かを受け取ってから5分以上経過している場合(デフォルト)、タイムスタンプがログに書き込まれます。ALIVE &quot;メッセージは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="609daf9d4941227cdd07f7a145c9f4b97a9dd23d" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロセスメタデータが存在しない場合、関数は &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="129f0fba3cda34f511f81ef498c5983a08b6fef4" translate="yes" xml:space="preserve">
          <source>If no service name is specified, a brief listing of all Erlang services is presented. If a service name is supplied, all options for that service are presented.</source>
          <target state="translated">サービス名が指定されていない場合、すべてのErlangサービスの簡単なリストが表示されます。サービス名が指定された場合、そのサービスのすべてのオプションが表示されます。</target>
        </trans-unit>
        <trans-unit id="f74a0bc86a24e556d294700bf2367dba448274f4" translate="yes" xml:space="preserve">
          <source>If no specific browser start command is specified, Firefox is the default browser on Unix platforms, and Internet Explorer on Windows. If &lt;code&gt;Common Test&lt;/code&gt; fails to start a browser automatically, or &lt;code&gt;none&lt;/code&gt; is specified as the value for &lt;code&gt;-browser&lt;/code&gt; (that is, &lt;code&gt;-browser none&lt;/code&gt;), start your favourite browser manually and type the URL that &lt;code&gt;Common Test&lt;/code&gt; displays in the shell.</source>
          <target state="translated">特定のブラウザー開始コマンドが指定されていない場合、FirefoxがUNIXプラットフォームのデフォルトのブラウザーで、Internet ExplorerがWindowsのデフォルトのブラウザーです。 &lt;code&gt;Common Test&lt;/code&gt; がブラウザーを自動的に開始できない場合、または &lt;code&gt;-browser&lt;/code&gt; の値として &lt;code&gt;none&lt;/code&gt; が指定されている場合（つまり、 &lt;code&gt;-browser none&lt;/code&gt; ）、お気に入りのブラウザーを手動で開始し、 &lt;code&gt;Common Test&lt;/code&gt; がシェルに表示するURLを入力します。</target>
        </trans-unit>
        <trans-unit id="3bd56a176fb29e1e8248ad526f6f69316f9b58af" translate="yes" xml:space="preserve">
          <source>If no such fun is registered, &lt;code&gt;beam_lib&lt;/code&gt; instead searches for an &lt;code&gt;.erlang.crypt&lt;/code&gt; file, see the next section.</source>
          <target state="translated">そのようなfunが登録されていない場合、 &lt;code&gt;beam_lib&lt;/code&gt; は代わりに &lt;code&gt;.erlang.crypt&lt;/code&gt; ファイルを検索します。次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="d1d762df86c391a1b492c91b19c8e6c06437bbda" translate="yes" xml:space="preserve">
          <source>If no user configuration file is specified and Erlang is started in non-distributed or short name distributed mode, Erlang uses default configuration settings and a native lookup method that works correctly under most circumstances. Erlang reads no information from system &lt;code&gt;inet&lt;/code&gt; configuration files (such as &lt;code&gt;/etc/host.conf&lt;/code&gt; and &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;) in these modes, except for &lt;code&gt;/etc/resolv.conf&lt;/code&gt; and &lt;code&gt;/etc/hosts&lt;/code&gt; that is read and monitored for changes on Unix platforms for the internal DNS client &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">ユーザー構成ファイルが指定されておらず、Erlangが非分散モードまたは短縮名分散モードで開始されている場合、Erlangはデフォルトの構成設定と、ほとんどの状況で正しく機能するネイティブルックアップメソッドを使用します。Erlang は、これらのモードでシステムの &lt;code&gt;inet&lt;/code&gt; 構成ファイル（ &lt;code&gt;/etc/host.conf&lt;/code&gt; や &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; など）から情報を読み取りません。ただし、 &lt;code&gt;/etc/hosts&lt;/code&gt; &lt;code&gt;/etc/resolv.conf&lt;/code&gt; と/ etc / hostsは読み取られ、変更が監視されます。内部DNSクライアントのUnixプラットフォームでは &lt;code&gt;inet_res(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13936c5aba4f403aada92256e268f1fefbc0b6d4" translate="yes" xml:space="preserve">
          <source>If no value for &lt;code&gt;Retries&lt;/code&gt; is specified, &lt;code&gt;infinity&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Retries&lt;/code&gt; の値が指定されていない場合は、 &lt;code&gt;infinity&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="94c3223fb92528e085bdc89d88a03ccfd3c590d9" translate="yes" xml:space="preserve">
          <source>If none of the above are available for your architecture/compiler, you are recommended to build and install &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; before building Erlang/OTP. The &lt;code&gt;libatomic_ops&lt;/code&gt; library provides native atomic memory operations for a variety of architectures and compilers. When building Erlang/OTP you need to inform the build system of where the &lt;code&gt;libatomic_ops&lt;/code&gt; library is installed using the &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt;&lt;code&gt;configure&lt;/code&gt; switch.</source>
          <target state="translated">上記のいずれもアーキテクチャ/コンパイラで利用できない場合は、Erlang / OTP をビルドする前に &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; をビルドしてインストールすることをお勧めします。 &lt;code&gt;libatomic_ops&lt;/code&gt; ライブラリは、アーキテクチャとコンパイラのさまざまなネイティブアトミックメモリ操作を提供します。Erlang / OTPをビルドする場合、 &lt;code&gt;libatomic_ops&lt;/code&gt; &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt; &lt;code&gt;configure&lt;/code&gt; スイッチを使用してlibatomic_opsライブラリがインストールされている場所をビルドシステムに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="9440ff5a97925b9c13d62c177e03518391502a24" translate="yes" xml:space="preserve">
          <source>If none of the first three clauses match, the fourth clause match as a variable always matches.</source>
          <target state="translated">最初の3つの節のどれもマッチしない場合、変数としての第4節のマッチは常にマッチします。</target>
        </trans-unit>
        <trans-unit id="f62e5b4dade736a66aa048e49499435f1f4d7fdc" translate="yes" xml:space="preserve">
          <source>If none of the strings in &lt;code&gt;Pattern&lt;/code&gt; is found, the atom &lt;code&gt;nomatch&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 内の文字列が見つからない場合、アトム &lt;code&gt;nomatch&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="aeb11b61b9cc24cd2031d9dda015e2462ccc0499" translate="yes" xml:space="preserve">
          <source>If none of the strings in a pattern is found, an empty list is returned.</source>
          <target state="translated">パターン内の文字列が見つからない場合は、空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="652472f45cf3561f5b3dd17763a17700dfcd88cc" translate="yes" xml:space="preserve">
          <source>If not empty, a scheduler internal auxiliary work is scheduled to be done.</source>
          <target state="translated">空でなければ、スケジューラの内部補助作業が予定されています。</target>
        </trans-unit>
        <trans-unit id="9937b44a2ec57528d4de1534b4257202ba316ad9" translate="yes" xml:space="preserve">
          <source>If not implemented, the CTH acts as if this function returned a call to &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">実装されていない場合、CTHは、この関数が &lt;code&gt;make_ref/0&lt;/code&gt; の呼び出しを返したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="c288cca9f0fb59e5fd99ac4b40424bd7ecc21978" translate="yes" xml:space="preserve">
          <source>If not present, audit trail logging is not used.</source>
          <target state="translated">存在しない場合、監査証跡ロギングは使用されません。</target>
        </trans-unit>
        <trans-unit id="29e29374c41854c469f97e992cbb29625d1d3ef4" translate="yes" xml:space="preserve">
          <source>If not, this is the atom &lt;code&gt;all&lt;/code&gt; which implies that the &lt;code&gt;UtilDesc&lt;/code&gt; contains information about all CPUs.</source>
          <target state="translated">そうでない場合、これは &lt;code&gt;UtilDesc&lt;/code&gt; にすべてのCPUに関する情報が含まれていることを意味するアトム &lt;code&gt;all&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f15293549ba601ce95a5307be4274cf3a235ee45" translate="yes" xml:space="preserve">
          <source>If not, this is the sum of the percentage shares of the CPU cycles spent in all states identified as busy.</source>
          <target state="translated">そうでない場合は、ビジー状態であると識別されたすべての状態で使用されたCPUサイクルの割合の合計です。</target>
        </trans-unit>
        <trans-unit id="a5425f5051ad47a7b173e5435c9b894080331b92" translate="yes" xml:space="preserve">
          <source>If nothing else is stated, it is presumed that the &lt;code&gt;otptest&lt;/code&gt; user has an entry in the &lt;strong&gt;authorized_keys&lt;/strong&gt; file of &lt;strong&gt;tarlop&lt;/strong&gt; (allowed to log in over &lt;code&gt;ssh&lt;/code&gt; without entering a password). Also, &lt;strong&gt;tarlop&lt;/strong&gt; is a known host in the &lt;code&gt;known_hosts&lt;/code&gt; file of the user &lt;code&gt;otptest&lt;/code&gt;. This means that host-verification can be done without user-interaction.</source>
          <target state="translated">他に何も述べられていない場合、と推測される &lt;code&gt;otptest&lt;/code&gt; ユーザがエントリがある&lt;strong&gt;のauthorized_keys&lt;/strong&gt;のファイル&lt;strong&gt;tarlopを&lt;/strong&gt;（オーバーでログインを許可 &lt;code&gt;ssh&lt;/code&gt; のパスワードを入力せずに）。また、&lt;strong&gt;tarlop&lt;/strong&gt;は、ユーザー &lt;code&gt;otptest&lt;/code&gt; の &lt;code&gt;known_hosts&lt;/code&gt; ファイルにある既知のホストです。つまり、ホストの検証は、ユーザーの操作なしで実行できます。</target>
        </trans-unit>
        <trans-unit id="85b52863c7b73a113224224b8a0c4d01a407b7d9" translate="yes" xml:space="preserve">
          <source>If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.</source>
          <target state="translated">テーブルが固定されている間にオブジェクトが追加されていた場合、テーブルが解放されたときにハッシュリストが成長し始め、一定期間テーブルへのアクセスが大幅に遅くなります。</target>
        </trans-unit>
        <trans-unit id="828acc15f06ea3d0ebf75bc3294946979fd85c6d" translate="yes" xml:space="preserve">
          <source>If on the other hand the Version argument is an integer, it means that this is the expected version of the message and the decoder for that version should be used.</source>
          <target state="translated">一方、引数Versionが整数の場合は、これが期待されるメッセージのバージョンであり、そのバージョン用のデコーダを使用する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="7ee7ad00a53993074166a752357e3a491c2d6eb1" translate="yes" xml:space="preserve">
          <source>If one &lt;strong&gt;really&lt;/strong&gt; wants to monitor when the driver gets unloaded, this message distorts the picture, because no unloading was done. Option &lt;code&gt;unloaded_only&lt;/code&gt; creates a monitor similar to an &lt;code&gt;unloaded&lt;/code&gt; monitor, but never results in this message.</source>
          <target state="translated">1の場合は&lt;strong&gt;本当に&lt;/strong&gt;ドライバーがアンロードされますときに監視したい何のアンロードが行われなかったため、このメッセージは、画像を歪めます。オプションは &lt;code&gt;unloaded_only&lt;/code&gt; に似てモニターを作成 &lt;code&gt;unloaded&lt;/code&gt; モニターを、このメッセージにつながることはありません。</target>
        </trans-unit>
        <trans-unit id="c5ebea37f196f871b2a70d380f83941fc18ead49" translate="yes" xml:space="preserve">
          <source>If one UTF character is split over two consecutive binaries in the &lt;code&gt;Data&lt;/code&gt;, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring.</source>
          <target state="translated">1つのUTF文字が &lt;code&gt;Data&lt;/code&gt; 内の2つの連続するバイナリに分割されている場合、変換は成功します。つまり、範囲全体が入力として指定されている限り、エラーは発生せずに、バイナリの範囲から文字をデコードできます。</target>
        </trans-unit>
        <trans-unit id="90ed92af5805bd230adc121faf96993bce08b918" translate="yes" xml:space="preserve">
          <source>If one of the &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</source>
          <target state="translated">&lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; フラグの1つが設定されていて、ランタイムシステムがダーティスケジューラをサポートしていない場合、ランタイムシステムはNIFライブラリのロードを拒否します。</target>
        </trans-unit>
        <trans-unit id="da2865f4d243741aece7d05e455898a782a870b4" translate="yes" xml:space="preserve">
          <source>If one of the nodes cannot process monitors, for example, C or Java nodes, and the &lt;code&gt;gen_server&lt;/code&gt; process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole &lt;code&gt;Timeout&lt;/code&gt;, which may be infinity.</source>
          <target state="translated">ノードの1つがモニターを処理できない場合（CノードやJavaノードなど）、要求の送信時に &lt;code&gt;gen_server&lt;/code&gt; プロセスが開始されず、2秒以内に開始される場合、この関数は &lt;code&gt;Timeout&lt;/code&gt; 全体を待機します。</target>
        </trans-unit>
        <trans-unit id="2ff50154efe11e68e30a0801c8327e55b0714e5d" translate="yes" xml:space="preserve">
          <source>If one or more carriers could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">システムの応答性を損なうことなく1つ以上のキャリアを完全にスキャンできなかった場合、 &lt;code&gt;UnscannedSize&lt;/code&gt; はスキップする必要があったバイト数です。</target>
        </trans-unit>
        <trans-unit id="9b3b6b44750cd929fb5194f2e7f17a52f91bfeb2" translate="yes" xml:space="preserve">
          <source>If only one access file exists, setting this parameter to &lt;code&gt;none&lt;/code&gt; can ease the burden on the server as the server then stops looking for access files.</source>
          <target state="translated">アクセスファイルが1つしか存在しない場合、このパラメーターを &lt;code&gt;none&lt;/code&gt; に設定すると、サーバーがアクセスファイルの検索を停止するため、サーバーの負担を軽減できます。</target>
        </trans-unit>
        <trans-unit id="78efdbd37020ca2e2d25f04642dce2c0495aa809" translate="yes" xml:space="preserve">
          <source>If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:</source>
          <target state="translated">1文字だけが\pまたは\Pで指定される場合、その文字で始まるすべての一般的なカテゴリプロパティを含む。この場合、否定がない場合、エスケープシーケンスの中の中括弧は任意である。以下の2つの例は、同じ効果を持つ。</target>
        </trans-unit>
        <trans-unit id="d1f740d3ae5b1c6572bd4172c4f16e8373ec6b45" translate="yes" xml:space="preserve">
          <source>If only one value is present, it is the current value. &lt;code&gt;fix_alloc&lt;/code&gt; memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</source>
          <target state="translated">値が1つしかない場合は、それが現在の値です。 &lt;code&gt;fix_alloc&lt;/code&gt; メモリブロックタイプは、2つの値で表されます。最初の値はメモリプールサイズで、2番目の値は使用済みメモリサイズです。</target>
        </trans-unit>
        <trans-unit id="c5da55d1092af23b098acf7d69c8679113b881cd" translate="yes" xml:space="preserve">
          <source>If only the module name (i.e. not the full name of the &lt;code&gt;.beam&lt;/code&gt; file) is given to this function, the &lt;code&gt;.beam&lt;/code&gt; file is found by calling &lt;code&gt;code:which(Module)&lt;/code&gt;. If no &lt;code&gt;.beam&lt;/code&gt; file is found, the error reason &lt;code&gt;non_existing&lt;/code&gt; is returned. If the module is already cover compiled with &lt;code&gt;compile_beam/1&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; file will be picked from the same location as the first time it was compiled. If the module is already cover compiled with &lt;code&gt;compile/1,2&lt;/code&gt;, there is no way to find the correct &lt;code&gt;.beam&lt;/code&gt; file, so the error reason &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; is returned.</source>
          <target state="translated">この関数にモジュール名のみ（つまり、 &lt;code&gt;.beam&lt;/code&gt; ファイルの完全な名前ではない）だけが指定されている場合、 &lt;code&gt;code:which(Module)&lt;/code&gt; を呼び出すと、 &lt;code&gt;.beam&lt;/code&gt; ファイルが見つかります。何場合 &lt;code&gt;.beam&lt;/code&gt; ファイルが見つからない、エラー理由 &lt;code&gt;non_existing&lt;/code&gt; が返されます。モジュールがすでに &lt;code&gt;compile_beam/1&lt;/code&gt; でコンパイル済みの場合、 &lt;code&gt;.beam&lt;/code&gt; ファイルは、最初にコンパイルされたときと同じ場所から選択されます。モジュールがすでに &lt;code&gt;compile/1,2&lt;/code&gt; でカバーコンパイルされている場合、正しい &lt;code&gt;.beam&lt;/code&gt; ファイルを見つける方法がないため、エラー理由 &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="84bdcab65ed9e153d52722d8ccf698faa98c0614" translate="yes" xml:space="preserve">
          <source>If only undefined options are requested the resulting list can be empty.</source>
          <target state="translated">未定義のオプ シ ョ ンのみを要求 し た場合は、 結果の リ ス ト は空にな る こ と がで き ます。</target>
        </trans-unit>
        <trans-unit id="c3d6b0c4be9ac174bfcec9988c3498fdbe5d2f55" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">オプション &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;Opts&lt;/code&gt; に存在する場合、 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; によるデバッグがアクティブになります。</target>
        </trans-unit>
        <trans-unit id="769611976869b84c5779bcf180081ddcd9ad1bfa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;c&lt;/code&gt; is used with &lt;code&gt;oldshell&lt;/code&gt; on Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; will restart the shell process rather than interrupt it.</source>
          <target state="translated">オプション &lt;code&gt;c&lt;/code&gt; がUnixの &lt;code&gt;oldshell&lt;/code&gt; で使用される場合、 &lt;code&gt;Ctrl-C&lt;/code&gt; はシェルプロセスを中断するのではなく再起動します。</target>
        </trans-unit>
        <trans-unit id="096a0eaa955fff41e809fc817940102bc82e3b7a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compact&lt;/code&gt; is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option &lt;code&gt;decimals&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;compact&lt;/code&gt; が指定されている場合、リストの最後の後続ゼロは切り捨てられます。このオプションは、オプション &lt;code&gt;decimals&lt;/code&gt; と共にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="e006a20906cf19e410666b42e37a9c3e19a3e41a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compressed&lt;/code&gt; is provided, the external term format is compressed. The compressed format is automatically recognized by &lt;code&gt;binary_to_term/1&lt;/code&gt; as from Erlang/OTP R7B.</source>
          <target state="translated">&lt;code&gt;compressed&lt;/code&gt; オプションが提供されている場合、外部用語形式は圧縮されます。圧縮形式は、Erlang / OTP R7Bからのものとして、 &lt;code&gt;binary_to_term/1&lt;/code&gt; によって自動的に認識されます。</target>
        </trans-unit>
        <trans-unit id="5de3ee850f4f14cadbc9c1e776ec192b168f5ad1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;decimals&lt;/code&gt; is specified, the returned value contains at most &lt;code&gt;Decimals&lt;/code&gt; number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;decimals&lt;/code&gt; が指定されている場合、戻り値には、小数点以下最大で &lt;code&gt;Decimals&lt;/code&gt; 桁の数字が含まれます。数値が256バイトの内部静的バッファーに収まらない場合、関数は &lt;code&gt;badarg&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="4d32ea21453f7c1a1069cac8907bb379c47719c1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;eof&lt;/code&gt; is specified also, the messages &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;exit_status&lt;/code&gt; appear in an unspecified order.</source>
          <target state="translated">オプション &lt;code&gt;eof&lt;/code&gt; も指定されている場合、メッセージ &lt;code&gt;eof&lt;/code&gt; および &lt;code&gt;exit_status&lt;/code&gt; が不特定の順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="32ae7856c177425822832835b7fef1768d20a52e" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;force&lt;/code&gt; has been passed, but the driver of the port does not allow forcing through a busy port.</source>
          <target state="translated">オプション &lt;code&gt;force&lt;/code&gt; が渡されたが、ポートのドライバーがビジー状態のポートを強制することを許可していない場合。</target>
        </trans-unit>
        <trans-unit id="441c9bb025fc2889c41f42aea8b90d9817c38b34" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the formatting is automatically done when stopping &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;format&lt;/code&gt; が &lt;code&gt;ttb:stop/1&lt;/code&gt; に指定されている場合、フォーマットは &lt;code&gt;ttb&lt;/code&gt; の停止時に自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="5d2376aceac49d07a344ae2362a017172221e3a6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the trace logs are automatically formatted after tracing is stopped.</source>
          <target state="translated">オプションの &lt;code&gt;format&lt;/code&gt; が &lt;code&gt;ttb:stop/1&lt;/code&gt; に指定されている場合、トレースが停止すると、トレースログは自動的にフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="06c4d5d9e31e528aa6774014ad6ec78d401b5e9f" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;info&lt;/code&gt; is combined with option &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is returned if a flush was needed, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">オプションの場合は &lt;code&gt;info&lt;/code&gt; オプションと組み合わせた &lt;code&gt;flush&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; フラッシュが必要になった場合にはそうでない場合は、返される &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6534bbbe7210a2a4f9c6ad85ccdb4879fb04d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;kill_ports&lt;/code&gt; is used, monitor trigging is crucial, as the ports are not guaranteed to be killed until the driver is unloaded. Thus, a monitor must be triggered for at least the &lt;code&gt;pending_driver&lt;/code&gt; case.</source>
          <target state="translated">オプション &lt;code&gt;kill_ports&lt;/code&gt; を使用する場合、ドライバーがアンロードされるまでポートが強制終了されることが保証されていないため、モニターのトリガーは重要です。したがって、少なくとも &lt;code&gt;pending_driver&lt;/code&gt; のケースではモニターをトリガーする必要があります。</target>
        </trans-unit>
        <trans-unit id="6aa1db8f0800b8eada993c86c8a59c1d17dfb52c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, all other options return &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt;, respectively.</source>
          <target state="translated">オプションの場合 &lt;code&gt;linked_in_driver&lt;/code&gt; または &lt;code&gt;permanent&lt;/code&gt; 戻り &lt;code&gt;true&lt;/code&gt; 、他のすべてのオプションを返す &lt;code&gt;linked_in_driver&lt;/code&gt; または &lt;code&gt;permanent&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="c57ff6b7c6782f60fe59ca940f65912e4d479346" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;monitor&lt;/code&gt; is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</source>
          <target state="translated">オプション &lt;code&gt;monitor&lt;/code&gt; を指定すると、新しく作成されたプロセスが監視され、pidとモニターの参照の両方が返されます。</target>
        </trans-unit>
        <trans-unit id="04d4436e947c7fe2bfe4be7b9ccd10a7ac2337af" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;no_dot_erlang&lt;/code&gt; is specified, the instruction to load the &lt;code&gt;.erlang&lt;/code&gt; file during boot is &lt;strong&gt;not&lt;/strong&gt; included.</source>
          <target state="translated">オプション &lt;code&gt;no_dot_erlang&lt;/code&gt; が指定されている場合、起動中に &lt;code&gt;.erlang&lt;/code&gt; ファイルをロードする命令&lt;strong&gt;は&lt;/strong&gt;含まれ&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dd0a5200f0c674efc5a1ca9a83309cd9b7fe26b6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;noexec&lt;/code&gt; is specified, the function returns the same values as for &lt;code&gt;silent&lt;/code&gt; but no &lt;code&gt;relup&lt;/code&gt; file is created.</source>
          <target state="translated">オプション &lt;code&gt;noexec&lt;/code&gt; が指定されている場合、関数は &lt;code&gt;silent&lt;/code&gt; と同じ値を返しますが、 &lt;code&gt;relup&lt;/code&gt; ファイルは作成されません。</target>
        </trans-unit>
        <trans-unit id="3c2f80ddb4accdf1246a3219780f43c13b4e27f2" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;purge&lt;/code&gt; is specified, all old code that can be soft-purged is purged after all other checks are successfully completed. This can be useful to reduce the time needed by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;purge&lt;/code&gt; が指定されている場合、他のすべてのチェックが正常に完了した後、ソフトパージできるすべての古いコードがパージされます。これは、 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt; に必要な時間を短縮するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f207e9cbf62b31891d035fb3346f08b4121c927b" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;restart_emulator&lt;/code&gt; is specified, a low-level instruction to restart the emulator is appended to the &lt;code&gt;relup&lt;/code&gt; file. This ensures that a complete reboot of the system is done when the system is upgraded or downgraded.</source>
          <target state="translated">オプション &lt;code&gt;restart_emulator&lt;/code&gt; が指定されている場合、エミュレータを再起動するための低レベルの命令が &lt;code&gt;relup&lt;/code&gt; ファイルに追加されます。これにより、システムがアップグレードまたはダウングレードされたときに、システムが完全に再起動されます。</target>
        </trans-unit>
        <trans-unit id="ef31277dfcdd9b3fea33e70696e85cc6a58e6495" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;scientific&lt;/code&gt; is specified, the float is formatted using scientific notation with &lt;code&gt;Decimals&lt;/code&gt; digits of precision.</source>
          <target state="translated">オプション場合 &lt;code&gt;scientific&lt;/code&gt; 指定され、フロートを有する科学的表記法を使用してフォーマットされた &lt;code&gt;Decimals&lt;/code&gt; 精度の桁。</target>
        </trans-unit>
        <trans-unit id="68354b12f57b501c10eb39d65b11549593ad808d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;src_tests&lt;/code&gt; is specified, a warning is issued if the source code for a module is missing or is newer than the object code.</source>
          <target state="translated">オプション &lt;code&gt;src_tests&lt;/code&gt; が指定されている場合、モジュールのソースコードが見つからないか、オブジェクトコードよりも新しい場合、警告が発行されます。</target>
        </trans-unit>
        <trans-unit id="3b698628086185a232f3b1c8c64f2b5821c29478" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;sync&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it ensures that the content of the file is written to the disk before &lt;code&gt;tab2file&lt;/code&gt; returns. Defaults to &lt;code&gt;{sync, false}&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;sync&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、 &lt;code&gt;tab2file&lt;/code&gt; が戻る前に、ファイルのコンテンツがディスクに書き込まれることが保証されます。デフォルトは &lt;code&gt;{sync, false}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="16c1274c0980810787faf4c8323f084b49c5a2fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;ungreedy&lt;/code&gt; is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior.</source>
          <target state="translated">オプション &lt;code&gt;ungreedy&lt;/code&gt; が設定されている場合（Perlでは使用できないオプション）、量指定子はデフォルトでは貪欲ではありませんが、疑問符を付けることで個々の量指定子を貪欲にすることができます。つまり、デフォルトの動作を反転させます。</target>
        </trans-unit>
        <trans-unit id="6ebecfa9ef794349da407c48663db38e0205dfc1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;url_base&lt;/code&gt; is set, an extra attribute named &lt;code&gt;url&lt;/code&gt; is added to each &lt;code&gt;testsuite&lt;/code&gt; and &lt;code&gt;testcase&lt;/code&gt; XML element. The value is constructed from &lt;code&gt;url_base&lt;/code&gt; and a relative path to the test suite or test case log, respectively, for example:</source>
          <target state="translated">オプションの場合 &lt;code&gt;url_base&lt;/code&gt; が設定され、余分な属性という名前の &lt;code&gt;url&lt;/code&gt; それぞれに追加された &lt;code&gt;testsuite&lt;/code&gt; と &lt;code&gt;testcase&lt;/code&gt; XML要素。値は、 &lt;code&gt;url_base&lt;/code&gt; およびテストスイートまたはテストケースログへの相対パスからそれぞれ構成されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="7a53503422cb0ac19329aceb31af878b5ec300e5" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;warnings_as_errors&lt;/code&gt; is specified, warnings are treated as errors.</source>
          <target state="translated">オプション &lt;code&gt;warnings_as_errors&lt;/code&gt; が指定されている場合、警告はエラーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="41ac36f3b8b38269747bee1634966538895f2ee4" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{debug,Dbgs}&lt;/code&gt; is present, the corresponding &lt;code&gt;sys&lt;/code&gt; function is called for each item in &lt;code&gt;Dbgs&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{debug,Dbgs}&lt;/code&gt; が存在する場合、対応する &lt;code&gt;sys&lt;/code&gt; 関数が &lt;code&gt;Dbgs&lt;/code&gt; の各アイテムに対して呼び出されます。 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e804aab039286890448ffee48895432a1b352c17" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{handshake, hello}&lt;/code&gt; が指定されている場合、クライアントのhelloメッセージの受信後にハンドシェイクが一時停止され、成功の応答は &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; ではなく{ok、SslSocket、Ext}に &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。その後、handshake_continue &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ハンドシェイクが続行またはキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="9802b121f3f842baa16ccec18f6827e8efefe976" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_event&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">オプション &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; が存在する場合、 &lt;code&gt;gen_event&lt;/code&gt; プロセスはメッセージを &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; ミリ秒待機し、メッセージが受信されない場合、プロセスは自動的に休止状態になります（ &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; を呼び出すことにより）。</target>
        </trans-unit>
        <trans-unit id="80d6ad9348d486b54eb01008ea70fa22ab22a998" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">オプション &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; が存在する場合、 &lt;code&gt;gen_server&lt;/code&gt; プロセスは &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; ミリ秒の間メッセージを待ち、メッセージが受信されない場合、プロセスは自動的に休止状態になります（ &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; を呼び出すことにより）。</target>
        </trans-unit>
        <trans-unit id="1afccf80e87b972a02a03ba25b3fcfd4c6d492f1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. A directory in the path can be specified with a wildcard &lt;code&gt;*&lt;/code&gt;, this is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{path,[Dir]}&lt;/code&gt; が指定されている場合、このパスは現在のパスに追加されます。パス内のディレクトリはワイルドカード &lt;code&gt;*&lt;/code&gt; で指定できます。これは、一致するすべてのディレクトリに展開されます。例： &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="521a357383f837ccbed508cea165f5ba1a72a4ba" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories, for example, &lt;code&gt;lib/*/ebin&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{path,[Dir]}&lt;/code&gt; が指定されている場合、このパスは現在のパスに追加されます。ワイルドカード &lt;code&gt;*&lt;/code&gt; は、 &lt;code&gt;lib/*/ebin&lt;/code&gt; など、一致するすべてのディレクトリに展開されます。</target>
        </trans-unit>
        <trans-unit id="319e803f0c4dc5797ff076e88abf3ae72c4731f8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt;spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; が存在する場合、 &lt;code&gt;SOpts&lt;/code&gt; はオプションリストとして &lt;code&gt;spawn_opt&lt;/code&gt; BIFに渡され、BIFは &lt;code&gt;gen_server&lt;/code&gt; プロセスを生成するために使用されます。 &lt;code&gt;spawn_opt/2&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f134a5284d4d1605e5d535d5f02614e7f9564b83" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">オプション &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; が &lt;code&gt;Opts&lt;/code&gt; に存在する場合、 &lt;code&gt;SpawnOpts&lt;/code&gt; はオプションリストとして &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; に渡されます。これは、 &lt;code&gt;gen_statem&lt;/code&gt; プロセスを生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c971670358afb5846db5d77c2b0b19aad5a3c579" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{timeout,Time}&lt;/code&gt; が &lt;code&gt;Opts&lt;/code&gt; に存在する場合、 &lt;code&gt;gen_statem&lt;/code&gt; は初期化に &lt;code&gt;Time&lt;/code&gt; ミリ秒を費やすことが許可されているか、終了して終了関数が &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="341a32ddba103c08ae86b78ec53524b7702998b8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it is terminated and the start function returns &lt;code&gt;{error,timeout}&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{timeout,Time}&lt;/code&gt; が存在する場合、 &lt;code&gt;gen_server&lt;/code&gt; プロセスは初期化に &lt;code&gt;Time&lt;/code&gt; ミリ秒を費やすことが許可されているか、終了して終了関数が &lt;code&gt;{error,timeout}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a928786d0e9ca7308ebc039e35ade6afdfb8bc1d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="translated">オプション &lt;code&gt;{tls, tls_options()}&lt;/code&gt; が存在する場合、FTPセッションは &lt;code&gt;tls&lt;/code&gt; （ &lt;code&gt;ftps&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt; を参照）を介して転送されます。リスト &lt;code&gt;tls_options()&lt;/code&gt; は空にすることができます。関数 &lt;code&gt;ssl:connect/3&lt;/code&gt; は、制御接続とデータセッションの両方を保護するために使用されます。</target>
        </trans-unit>
        <trans-unit id="20a3a531905a20d30fd9f374cce827942989f5e9" translate="yes" xml:space="preserve">
          <source>If option&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">オプション &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; が存在する場合、 &lt;code&gt;gen_statem&lt;/code&gt; プロセスはメッセージを &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; ミリ秒待機し、メッセージが受信されない場合、プロセスは自動的に休止状態になります（ &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; を呼び出すことにより）。</target>
        </trans-unit>
        <trans-unit id="2fd0a104622064a3e02a4f4c3eca0f47d309b91b" translate="yes" xml:space="preserve">
          <source>If or when &lt;code&gt;monitor/2&lt;/code&gt; is extended, other possible values for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;Info&lt;/code&gt; in the monitor message will be introduced.</source>
          <target state="translated">&lt;code&gt;monitor/2&lt;/code&gt; が拡張されている場合、または拡張されている場合、モニターメッセージ内の &lt;code&gt;Tag&lt;/code&gt; 、 &lt;code&gt;Object&lt;/code&gt; 、および &lt;code&gt;Info&lt;/code&gt; の他の可能な値が導入されます。</target>
        </trans-unit>
        <trans-unit id="a47b00202aed4c182ff58ce236e280bf55db7d71" translate="yes" xml:space="preserve">
          <source>If other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have the driver loaded, this option has no effect.</source>
          <target state="translated">他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がドライバをロードしている場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="56b3ce2063e2924ca7e8faa87611f5b6c2819567" translate="yes" xml:space="preserve">
          <source>If parameter &lt;code&gt;Dates&lt;/code&gt; is specified, the reports are filtered according to the date when they occurred. If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateFrom, from}&lt;/code&gt;, reports that occurred after &lt;code&gt;DateFrom&lt;/code&gt; are displayed.</source>
          <target state="translated">パラメータ &lt;code&gt;Dates&lt;/code&gt; が指定されている場合、レポートはそれらが発生した日付に従ってフィルタリングされます。場合 &lt;code&gt;Dates&lt;/code&gt; フォーム有する &lt;code&gt;{DateFrom, from}&lt;/code&gt; 、後に発生したレポート &lt;code&gt;DateFrom&lt;/code&gt; が表示されています。</target>
        </trans-unit>
        <trans-unit id="6511239690521e295477c51f44e7169510af0e54" translate="yes" xml:space="preserve">
          <source>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">可能であれば、テーブルを反復処理する前に、同じトランザクション内のレコードの書き込みや削除は避けてください。</target>
        </trans-unit>
        <trans-unit id="3eb1eeddf032eb186133fc7df8919fb2d11d384d" translate="yes" xml:space="preserve">
          <source>If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application.</source>
          <target state="translated">可能であれば、クライアントは接続を生きたままにしておき、設定や現在の状況に応じてパイプラインの有無に関わらず持続的接続を使用します。HTTP/1.1 の仕様では、持続的接続で送信するのが理想的なリクエストの数についてのガイドラインを提供していません。これはアプリケーションに大きく依存します。</target>
        </trans-unit>
        <trans-unit id="6eb80024b1f8a5a58791d40e0d60ce7a9e24c7b7" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</source>
          <target state="translated">可能であれば、コメントは同一行内で先行するセパレータ文字の前に移動させるべきです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="11f459fa45ff86ea26d4123b486b2667eb195a88" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</source>
          <target state="translated">可能であれば、コメントは、次の行にセパレータを配置するのではなく、同じ行の後続のセパレータ文字の前に移動させるべきです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e22a764d95b33db30751234a49a657e83e7510e" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; module to extract the compiler options and the abstract code format from the Beam file and compile that instead.</source>
          <target state="translated">可能であれば、 &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; モジュールを使用して、Beamファイルからコンパイラオプションと抽象コード形式を抽出し、代わりにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="aede57d6ae41eb953c1c470da89fb0e057e8b902" translate="yes" xml:space="preserve">
          <source>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</source>
          <target state="translated">優先順位がclientの場合、ネゴシエートされたプロトコルは、クライアントの優先順位リストに最初に表示されるプロトコルであり、サーバのアドバタイズドされたリストにも表示されます。</target>
        </trans-unit>
        <trans-unit id="51ff54d9c737f36da2074bfa07dabdd6029e6f8a" translate="yes" xml:space="preserve">
          <source>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</source>
          <target state="translated">優先順位がserverの場合、ネゴシエートされたプロトコルはserver advertised listに最初に表示されるプロトコルで、これはclient preference listにも表示されます。</target>
        </trans-unit>
        <trans-unit id="6739d735ae41522a99fdf3833670c2cb63d21a98" translate="yes" xml:space="preserve">
          <source>If present, this option specifies the options for the &lt;strong&gt;audit trail logging&lt;/strong&gt;. The &lt;code&gt;disk_log&lt;/code&gt; module is used to maintain a wrap log. If present, the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; options are mandatory.</source>
          <target state="translated">存在する場合、このオプションは&lt;strong&gt;監査証跡ログの&lt;/strong&gt;オプションを指定します。 &lt;code&gt;disk_log&lt;/code&gt; モジュールは、ラップログを維持するために使用されます。存在する場合、 &lt;code&gt;dir&lt;/code&gt; および &lt;code&gt;size&lt;/code&gt; オプションは必須です。</target>
        </trans-unit>
        <trans-unit id="c374078c3ce837fa7c145904897f0747ce0fa052" translate="yes" xml:space="preserve">
          <source>If process metadata exists for the current process, this function behaves as if it was implemented as follows:</source>
          <target state="translated">現在のプロセスにプロセスメタデータが存在する場合、この関数は以下のように実装されているかのように動作します。</target>
        </trans-unit>
        <trans-unit id="6453efa6a699c594656266a7d0d5934c8aa65586" translate="yes" xml:space="preserve">
          <source>If pseudo function triggering the translation is &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single tuple. If the pseudo function is &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single list.</source>
          <target state="translated">変換をトリガーする疑似関数が &lt;code&gt;ets:fun2ms/1&lt;/code&gt; の場合、funの先頭には単一の変数または単一のタプルが含まれている必要があります。疑似関数が &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; の場合、funのヘッドには単一の変数または単一のリストが含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="3bbf5cb920ce0732e8a77fc0ab511fa8e53d27bc" translate="yes" xml:space="preserve">
          <source>If quantifier is {0,n}, where n &amp;gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier.</source>
          <target state="translated">数量詞が{0、n}の場合（n&amp;gt; 0）、{0,1}であるかのように扱われます。実行時に、アサーションの有無にかかわらず、残りのパターンマッチが試行され、順序は数量詞の貪欲さに依存します。</target>
        </trans-unit>
        <trans-unit id="a4e6534fccad96b9c365841e907e49b7cde2c28d" translate="yes" xml:space="preserve">
          <source>If records are written and deleted during the traversal, use the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;write&lt;/code&gt; lock. Or the function &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; when using &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">走査中にレコードが書き込まれ、削除される場合は、 &lt;code&gt;write&lt;/code&gt; ロックを指定して関数 &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; を使用します。または、 &lt;code&gt;first&lt;/code&gt; および &lt;code&gt;next&lt;/code&gt; を使用する場合は、関数 &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="169c4bd14dbb4d6e16657fce0c0a61cc8e3f8798" translate="yes" xml:space="preserve">
          <source>If reloading is not requested, it can still be useful to specify option &lt;code&gt;monitor&lt;/code&gt;, as forced unloads (driver option &lt;code&gt;kill_ports&lt;/code&gt; or option &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;) trigger a transient state where driver loading cannot be performed until all closing ports are closed. Thus, as &lt;code&gt;try_unload&lt;/code&gt; can, in almost all situations, return &lt;code&gt;{ok, pending_driver}&lt;/code&gt;, always specify at least &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; in production code (see the monitor discussion earlier).</source>
          <target state="translated">強制アンロード（ドライバーオプション &lt;code&gt;kill_ports&lt;/code&gt; またはオプション &lt;code&gt;kill_ports&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; ）が一時的な状態をトリガーし、閉じているすべてのポートが閉じるまでドライバーのロードを実行できないため、再読み込みが要求されない場合でも、オプション &lt;code&gt;monitor&lt;/code&gt; を指定すると便利です。したがって、 &lt;code&gt;try_unload&lt;/code&gt; はほとんどすべての状況で &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 返すことができる &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 本番用コードでは常に少なくとも{monitor、pending_driver}を指定します（前述のモニターの説明を参照）。</target>
        </trans-unit>
        <trans-unit id="55c076ea86b99a552c3ee63a0beaa5dfb25c1e33" translate="yes" xml:space="preserve">
          <source>If resolver option &lt;code&gt;inet6&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, an IPv6 address is looked up.</source>
          <target state="translated">リゾルバーオプション &lt;code&gt;inet6&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、IPv6アドレスが検索されます。</target>
        </trans-unit>
        <trans-unit id="71218f752e39cbf302806385e7e620598fcd4560" translate="yes" xml:space="preserve">
          <source>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</source>
          <target state="translated">特定のノードで制限モードが有効になっている場合、このノードに接続するリモートシェルも制限モードで実行されます。</target>
        </trans-unit>
        <trans-unit id="81be79c2e31a4efcff85293a46775d5d0aa9c619" translate="yes" xml:space="preserve">
          <source>If run with option &lt;code&gt;caseless&lt;/code&gt;, this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop.</source>
          <target state="translated">オプション &lt;code&gt;caseless&lt;/code&gt; で実行すると、このパターンは「男、計画、運河：パナマ！」などのフレーズに一致します。PCREとPerlの両方でうまく機能します。非所有文字のシーケンスへのバックトラックを回避するために、所有的量指定子* +の使用に注意してください。これがないと、PCREは典型的なフレーズと一致するのにはるかに長い時間（10倍以上）を要し、Perlは非常に時間がかかるため、ループに入ったと考えます。</target>
        </trans-unit>
        <trans-unit id="56762a0f1f42178490b0db9862f2814f477e1842" translate="yes" xml:space="preserve">
          <source>If set before start, the &lt;code&gt;epmd&lt;/code&gt; daemon behaves as if option &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified at startup. Consequently, if this option is set before starting the Erlang virtual machine, the automatically started &lt;code&gt;epmd&lt;/code&gt; accepts the &lt;code&gt;-kill&lt;/code&gt; and &lt;code&gt;-stop&lt;/code&gt; commands without restrictions.</source>
          <target state="translated">起動前に設定すると、 &lt;code&gt;epmd&lt;/code&gt; デーモンは、起動時にオプション &lt;code&gt;-relaxed_command_check&lt;/code&gt; が指定されたかのように動作します。したがって、Erlang仮想マシンを起動する前にこのオプションが設定されている場合、自動的に起動される &lt;code&gt;epmd&lt;/code&gt; は、制限なしに &lt;code&gt;-kill&lt;/code&gt; および &lt;code&gt;-stop&lt;/code&gt; コマンドを受け入れます。</target>
        </trans-unit>
        <trans-unit id="9f59dad82faaa4c2914703b6f2eec0c0bd7bf03c" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; を休止状態に設定した場合、セクション &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt; で処理されます</target>
        </trans-unit>
        <trans-unit id="60eef1c452cfc1dd1bd601c01baa121d5df8c903" translate="yes" xml:space="preserve">
          <source>If set in binary mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;{binary, true}&lt;/code&gt;), the I/O server sends binary data (encoded in UTF-8) as answers to the &lt;code&gt;get_line&lt;/code&gt;, &lt;code&gt;get_chars&lt;/code&gt;, and, if possible, &lt;code&gt;get_until&lt;/code&gt; requests (for details, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt;) in the User's Guide). The immediate effect is that &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; return UTF-8 binaries instead of lists of characters for the affected I/O device.</source>
          <target state="translated">バイナリモード（ &lt;code&gt;binary&lt;/code&gt; または &lt;code&gt;{binary, true}&lt;/code&gt; ）に設定されている場合、I / Oサーバーは、バイナリデータ（UTF-8でエンコードされた）を &lt;code&gt;get_line&lt;/code&gt; 、 &lt;code&gt;get_chars&lt;/code&gt; 、および &lt;code&gt;get_until&lt;/code&gt; リクエスト（詳細については、ユーザーガイドの &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; セクション）。即時の影響は、影響を受けるI / Oデバイスの文字のリストではなく、 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; がUTF-8バイナリを返すことです。</target>
        </trans-unit>
        <trans-unit id="60e11f2d401fbb6a7bc13e95b2d0df9464865aea" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">セットは、現在のイベントを延期する場合は、セクションを参照 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2642f766dbab3720562602e51b82a07e9e8906" translate="yes" xml:space="preserve">
          <source>If set the scheduler id is to be included by the tracer.</source>
          <target state="translated">設定した場合、トレーサに含めるスケジューラIDを指定します。</target>
        </trans-unit>
        <trans-unit id="b36ae2f0946222aa466ec9f357bec978063329ec" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">設定されている場合、トレースポイントには、トレースイベントに関する追加データが含まれています。追加データとは、どの &lt;code&gt;TraceTag&lt;/code&gt; がトリガーされたかによって異なります。 &lt;code&gt;extra&lt;/code&gt; に記載のトレースタプルで5番目の要素へのトレースデータが対応する &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="537421ac5bc876e1157770197d20f5be1d7bdfa8" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include a time stamp.</source>
          <target state="translated">設定されている場合は、トレーサーにタイムスタンプを含めるように要求されています。</target>
        </trans-unit>
        <trans-unit id="ebb92b7f506965bd75353ec4f02388501a5389c5" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include the output of a match specification that was run.</source>
          <target state="translated">セットされている場合、トレーサは、実行されたマッチ指定の出力を含めるように要求されています。</target>
        </trans-unit>
        <trans-unit id="c658f8f2f205584d1fb8b1c5da7c1178ed36dd48" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, error reports are not displayed.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; に設定すると、エラーレポートは表示されません。</target>
        </trans-unit>
        <trans-unit id="310d96f77be1e1791ce6fea41e63aca706ddcee9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; a header field is added to logger_formatter's part of &lt;code&gt;Metadata&lt;/code&gt;. The value of this field is a string similar to the header created by the old &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; event handlers. It can be included in the log event by adding the list &lt;code&gt;[logger_formatter,header]&lt;/code&gt; to the template. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、ヘッダーフィールドが &lt;code&gt;Metadata&lt;/code&gt; の logger_formatterの部分に追加されます。このフィールドの値は、古い &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; イベントハンドラーによって作成されたヘッダーと同様の文字列です。テンプレートにリスト &lt;code&gt;[logger_formatter,header]&lt;/code&gt; を追加することで、ログイベントに含めることができます。詳細については、 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; タイプの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="4ce4e9a3ec15985becd6d1fc4438e42ee9f02d87" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, all newlines in the message are replaced with &lt;code&gt;&quot;, &quot;&lt;/code&gt;, and white spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、メッセージ内のすべての改行が &lt;code&gt;&quot;, &quot;&lt;/code&gt; 置き換えられ、改行が削除された直後の空白文字が続きます。 &lt;code&gt;template&lt;/code&gt; パラメータによって追加された改行は置き換えられないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d7bc2e449028a1b238287b1e7e1da57633ce0aa2" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;ct_master logs&lt;/code&gt; are written on a primitive HTML format, not using the &lt;code&gt;Common Test&lt;/code&gt; CSS style sheet.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、 &lt;code&gt;ct_master logs&lt;/code&gt; は、 &lt;code&gt;Common Test&lt;/code&gt; CSSスタイルシートを使用せずに、プリミティブHTML形式で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="c67db27336a237041f3f770706b8f2027a618516" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts &lt;code&gt;++&lt;/code&gt;-operators between string literals and macros where it looks like concatenation was intended. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定した場合、これにより、 &lt;code&gt;epp_dodger&lt;/code&gt; はソースコードを適切と思われるように修復しようとします。現在、文字列リテラルとマクロの間に &lt;code&gt;++&lt;/code&gt; 演算子が挿入されており、連結が意図されているように見えます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="553412c0540657c6dfbc0cf5ff30e8dae32d51db" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, use the server preference for cipher selection. If set to &lt;code&gt;false&lt;/code&gt; (the default), use the client preference.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定されている場合は、暗号の選択にサーバー設定を使用します。 &lt;code&gt;false&lt;/code&gt; （デフォルト）に設定されている場合は、クライアント設定を使用します。</target>
        </trans-unit>
        <trans-unit id="845d16e801c4d035d7da73e779db3b12f92e8193" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, workarounds for known server deviations from the HTTP-standard are enabled.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、HTTP標準からのサーバーの既知の逸脱に対する回避策が有効になります。</target>
        </trans-unit>
        <trans-unit id="4e5151c0c30a4e7bb11fe24669fcb768cff8dff0" translate="yes" xml:space="preserve">
          <source>If set to anything else than &lt;code&gt;0&lt;/code&gt;, it makes all times displayed by &lt;code&gt;run_erl&lt;/code&gt; to be in UTC (GMT, CET, MET, without Daylight Saving Time), rather than in local time. This does not affect data coming from Erlang, only the logs output directly by &lt;code&gt;run_erl&lt;/code&gt;. Application SASL can be modified accordingly by setting the Erlang application variable &lt;code&gt;utc_log&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外に設定すると、 &lt;code&gt;run_erl&lt;/code&gt; によって表示されるすべての時刻は、現地時間ではなくUTC（GMT、CET、MET、夏時間なし）になります。これはErlangからのデータには影響せず、 &lt;code&gt;run_erl&lt;/code&gt; によって直接出力されるログにのみ影響します。Erlangアプリケーション変数 &lt;code&gt;utc_log&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定することにより、アプリケーションSASLを適宜変更できます。</target>
        </trans-unit>
        <trans-unit id="54ecba8897a2d3cf6ca4714afe4059ed1a0bc69c" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously.</source>
          <target state="translated">false(デフォルト値)に設定すると、一度に1つのログインのみが処理されます。true に設定されている場合は、同時に無制限の回数のログインが許可されます。</target>
        </trans-unit>
        <trans-unit id="f7e5e755a8f0aa4316d9b9f5d9dcea02be971e72" translate="yes" xml:space="preserve">
          <source>If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file.</source>
          <target state="translated">NoPassword &quot;以外に設定されている場合、すべてのAPIコールでパスワードが必要となります。DummyPasswordに設定されている場合は、他のAPIコールを行う前にパスワードを変更する必要があります。認証データの安全性を確保するために、ウェブサーバの起動後にパスワードを変更する必要があります。それ以外の場合は、設定ファイルにクリアテキストで記述されます。</target>
        </trans-unit>
        <trans-unit id="cbc8baf201837b9902d99d9c6ceeaafc45b233fd" translate="yes" xml:space="preserve">
          <source>If several fields are to be assigned the same value, the following construction can be used:</source>
          <target state="translated">複数のフィールドに同じ値を割り当てる場合は、以下のような構成にすることができます。</target>
        </trans-unit>
        <trans-unit id="21ef3b935d35dcc97954564f91b02dc29963a181" translate="yes" xml:space="preserve">
          <source>If so, or if possibly needed in future versions, then you should consider using &lt;code&gt;gen_statem&lt;/code&gt; over &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">その場合、または将来のバージョンで必要になる可能性がある場合は、 &lt;code&gt;gen_statem&lt;/code&gt; なく &lt;code&gt;gen_server&lt;/code&gt; を使用することを検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="33f2cb0ac87e42cdbdf8827c536efd85bb8b5ca2" translate="yes" xml:space="preserve">
          <source>If some of the found BEAM files contain &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then those modules are checked and a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">見つかった一部のBEAMファイルに &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; が含まれている場合、それらのモジュールがチェックされ、タプルのリストが返されます。各タプルの最初の要素は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="6a5a8a25ced47d4519279df0ad60d300b9fdd3ac" translate="yes" xml:space="preserve">
          <source>If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.</source>
          <target state="translated">いくつかの変数が設定に存在していたが、この関数を使用してロードされなかった場合、それらの変数はエイリアスと共に設定テーブルから削除されます。</target>
        </trans-unit>
        <trans-unit id="908c252e088323e888f147ff16d100c7706161d0" translate="yes" xml:space="preserve">
          <source>If something goes wrong, the function can also return an error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">何かがうまくいかない場合、関数はエラータプル &lt;code&gt;{error,Error}&lt;/code&gt; 返すこともできます。</target>
        </trans-unit>
        <trans-unit id="70476ad38abe74628a91e231b10da869d250c572" translate="yes" xml:space="preserve">
          <source>If specified by its filename, the filename can include a path and the &lt;code&gt;.erl&lt;/code&gt; extension can be omitted. The object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to it, and then in the current path.</source>
          <target state="translated">ファイル名で指定する場合、ファイル名にパスを含めることができ、 &lt;code&gt;.erl&lt;/code&gt; 拡張子は省略できます。オブジェクトコード &lt;code&gt;Module.beam&lt;/code&gt; は、最初にソースコードと同じディレクトリで検索され、次にその隣の &lt;code&gt;ebin&lt;/code&gt; ディレクトリ、次に現在のパスで検索されます。</target>
        </trans-unit>
        <trans-unit id="50b19f1c8b9a65cb742065615e51dec1da364a91" translate="yes" xml:space="preserve">
          <source>If specified by its module name, the object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path. The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in the same directory as the object code, then in an &lt;code&gt;src&lt;/code&gt; directory next to it.</source>
          <target state="translated">モジュール名で指定されている場合、オブジェクトコード &lt;code&gt;Module.beam&lt;/code&gt; が現在のパスで検索されます。ソースコード &lt;code&gt;Module.erl&lt;/code&gt; は、最初にオブジェクトコードと同じディレクトリで検索され、次にその隣の &lt;code&gt;src&lt;/code&gt; ディレクトリで検索されます。</target>
        </trans-unit>
        <trans-unit id="a8d0b6cf013a5c0d8770719696ef065b65aefbe7" translate="yes" xml:space="preserve">
          <source>If starting the test with a general verbosity level of 50 (&lt;code&gt;?STD_VERBOSITY&lt;/code&gt;):</source>
          <target state="translated">一般的な詳細レベル50（ &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; ）でテストを開始する場合：</target>
        </trans-unit>
        <trans-unit id="bff20119788e7f9fcb0386bb0ba5f7207f1771ed" translate="yes" xml:space="preserve">
          <source>If starting the test with:</source>
          <target state="translated">でテストを開始する場合。</target>
        </trans-unit>
        <trans-unit id="26a65a58a274c5e83de124292f3254f1ac090467" translate="yes" xml:space="preserve">
          <source>If status was &lt;code&gt;alive&lt;/code&gt;, node &lt;code&gt;A&lt;/code&gt; answers with another status message containing either &lt;code&gt;true&lt;/code&gt;, which means that the connection is to continue (the old connection from this node is broken), or &lt;code&gt;false&lt;/code&gt;, which means that the connection is to be closed (the connection attempt was a mistake.</source>
          <target state="translated">状態だった場合は &lt;code&gt;alive&lt;/code&gt; 、ノード &lt;code&gt;A&lt;/code&gt; のいずれか含む別のステータスメッセージと答え &lt;code&gt;true&lt;/code&gt; の接続が継続していることを意味し（このノードからの古い接続が切断された）、または、 &lt;code&gt;false&lt;/code&gt; 接続がクローズされることを意味し、（接続試みは間違いでした。</target>
        </trans-unit>
        <trans-unit id="7b9b70b7cbd405f4ef48bddbc33725b6c4cf3c30" translate="yes" xml:space="preserve">
          <source>If sticky locks are used, the code must first be changed as follows:</source>
          <target state="translated">スティッキーロックを使用する場合は、まず以下のようにコードを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="c7eb71447bfe22582a45b3625c21c45102fb30a5" translate="yes" xml:space="preserve">
          <source>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</source>
          <target state="translated">正規表現で副式が指定されている場合、一致する副式は結果のリストにも返されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0b8ddaa042ba6e6a6e6f3aa8c56ca060f0b33630" translate="yes" xml:space="preserve">
          <source>If successful</source>
          <target state="translated">成功した場合</target>
        </trans-unit>
        <trans-unit id="211664819a4310bd77112b972f6e1afd6ef67b18" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state in an &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple.</source>
          <target state="translated">成功した場合、関数は更新された内部状態を &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; タプルで返す必要があります。</target>
        </trans-unit>
        <trans-unit id="4e8c6ee9fde6d55757690d169dc69ff0e99e718e" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state.</source>
          <target state="translated">成功した場合、この関数は更新された内部状態を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="932989b7c1361152a0b0809cc73761645d677b31" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; exists but the corresponding child process is running or is about to be restarted, the function returns &lt;code&gt;{error,running}&lt;/code&gt; or &lt;code&gt;{error,restarting}&lt;/code&gt;, respectively. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">成功した場合、関数は &lt;code&gt;ok&lt;/code&gt; を返します。 &lt;code&gt;Id&lt;/code&gt; で識別される子仕様は存在するが、対応する子プロセスが実行中または再起動されようとしている場合、関数はそれぞれ &lt;code&gt;{error,running}&lt;/code&gt; または &lt;code&gt;{error,restarting}&lt;/code&gt; 返します。 &lt;code&gt;Id&lt;/code&gt; で識別される子仕様が存在しない場合、関数は &lt;code&gt;{error,not_found}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="2a7459c85147eae0af4289577e8d8cb1033070c0" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is no child specification with the specified &lt;code&gt;Id&lt;/code&gt;, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">成功した場合、関数は &lt;code&gt;ok&lt;/code&gt; を返します。指定された &lt;code&gt;Id&lt;/code&gt; を持つ子仕様がない場合、関数は &lt;code&gt;{error,not_found}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="6c554336fd49d3d6148f3873055df50396396c91" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;{ok,State}&lt;/code&gt; or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial internal state of the event handler.</source>
          <target state="translated">成功した場合、関数は &lt;code&gt;{ok,State}&lt;/code&gt; または &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; 返します。ここで、 &lt;code&gt;State&lt;/code&gt; はイベントハンドラーの初期内部状態です。</target>
        </trans-unit>
        <trans-unit id="2203259483f235e1b092ade2119d4c07d6241b2e" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map or if it does not contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">成功した場合、この関数は &lt;code&gt;*map_out&lt;/code&gt; を新しいマップに設定し、 &lt;code&gt;true&lt;/code&gt; を返します。戻り値の &lt;code&gt;false&lt;/code&gt; の場合 &lt;code&gt;map_in&lt;/code&gt; はそれが含まれていない場合のマップではないか、 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba18cbb490e9c8d2f3b6ef180516f04715f3defa" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map.</source>
          <target state="translated">成功した場合、この関数は &lt;code&gt;*map_out&lt;/code&gt; を新しいマップに設定し、 &lt;code&gt;true&lt;/code&gt; を返します。 &lt;code&gt;map_in&lt;/code&gt; がマップでない場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c57bdf287994755b6e44fdfc60facab5a9f11a53" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; there are any duplicate keys.</source>
          <target state="translated">成功した場合、この関数は &lt;code&gt;*map_out&lt;/code&gt; を新しいマップに設定し、 &lt;code&gt;true&lt;/code&gt; を返します。重複するキーがある場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="235077c5f09d774b9f3db45cd19ec2e827847cd9" translate="yes" xml:space="preserve">
          <source>If such a clause cannot be found, a &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">そのような句が見つからない場合、 &lt;code&gt;function_clause&lt;/code&gt; ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="283f86d98b5d92d6ad1ce6bfc63055da78218576" translate="yes" xml:space="preserve">
          <source>If such a clause is found, the corresponding clause body is evaluated. That is, the expressions in the body are evaluated sequentially and the value of the last expression is returned.</source>
          <target state="translated">そのような節が見つかった場合、対応する節ボディが評価されます。つまり、ボディ内の式が順次評価され、最後の式の値が返されます。</target>
        </trans-unit>
        <trans-unit id="b2fcf16676aca666b69b183aa34b448a75829f94" translate="yes" xml:space="preserve">
          <source>If synchronization is not possible, an error report is sent to the error logger (see also &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">同期が不可能な場合は、エラーレポートがエラーロガーに送信されます（ &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt; も参照してください）。</target>
        </trans-unit>
        <trans-unit id="36f347d7b778b3a4f6fb90496e2acb23c2a7a864" translate="yes" xml:space="preserve">
          <source>If syntax errors are discovered in these files they are reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; at start-up.</source>
          <target state="translated">これらのファイルで構文エラーが発見された場合、起動時に &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; の関数 &lt;code&gt;config_err/2&lt;/code&gt; で報告されます。</target>
        </trans-unit>
        <trans-unit id="e5db19b0c235be5b01f2325198c01dc60d89585f" translate="yes" xml:space="preserve">
          <source>If tagged allocations are not enabled on any of the specified allocator types, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">指定されたアロケータタイプのいずれかでタグ付き割り当てが有効になっていない場合、呼び出しは &lt;code&gt;{error, not_enabled}&lt;/code&gt; 失敗します。</target>
        </trans-unit>
        <trans-unit id="430e9485ed1c99e4dac7dca3da3dfa4aa8c39ab8" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; cannot be compiled (does not represent a valid match specification), a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;MatchSpec&lt;/code&gt; という用語をコンパイルできない場合（有効な一致指定を表していない場合）、 &lt;code&gt;badarg&lt;/code&gt; 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="b34a1091c99e6fe485396a9633ee9cf35b5e6022" translate="yes" xml:space="preserve">
          <source>If test suites or help modules include header files stored in other locations than the test directory, these include directories can be specified by using flag &lt;code&gt;-include&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, or option &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. Also, an include path can be specified with an OS environment variable, &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt;.</source>
          <target state="translated">テストスイートまたはヘルプモジュールに、テストディレクトリ以外の場所に格納されているヘッダーファイルが含まれている場合、これらのインクルードディレクトリは、フラグ &lt;code&gt;-include&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 、またはオプション &lt;code&gt;include&lt;/code&gt; と &lt;code&gt;ct:run_test/1&lt;/code&gt; を使用して指定できます。また、インクルードパスはOS環境変数 &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt; で指定できます。</target>
        </trans-unit>
        <trans-unit id="c9279b9016abb718b19436b545788de84fa2134f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, BEAM files that contain no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 外部参照サーバのです &lt;code&gt;functions&lt;/code&gt; 、全く含まないBEAMファイルの &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 無視されます。</target>
        </trans-unit>
        <trans-unit id="c813a10d16024092b88cb717d0c880a3632b14a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, and the BEAM file contains no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, the error message &lt;code&gt;no_debug_info&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 外部参照サーバのです &lt;code&gt;functions&lt;/code&gt; 、およびBEAMファイルは一切含まれていない &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 、エラーメッセージ &lt;code&gt;no_debug_info&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="0b9197e338e3401c234d140df6601d7f0bd0de9f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">場合は &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ある &lt;code&gt;handle_event_function&lt;/code&gt; 、状態は任意の用語することができます。状態変更（ &lt;code&gt;NextState =/= State&lt;/code&gt; ）の後、延期されたすべてのイベントが再試行されます。</target>
        </trans-unit>
        <trans-unit id="74c7a5f40b37419e0dfdb9c000a09ebaefa7ede7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be of this type. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">場合は &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ある &lt;code&gt;state_functions&lt;/code&gt; 、状態はこのタイプでなければなりません。状態変更（ &lt;code&gt;NextState =/= State&lt;/code&gt; ）の後、延期されたすべてのイベントが再試行されます。</target>
        </trans-unit>
        <trans-unit id="720d616c478f9b1d1e0e376e567468c7cbccb10c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; が設定されている &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 、データを介してドライバに強制することができ &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; ドライバーはそれがビジー状態であることを通知した場合であっても。</target>
        </trans-unit>
        <trans-unit id="b5b8a260b0935e82c1c23c647ce2490c52e709f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_control/3&lt;/code&gt; is a binary, the driver will be passed a pointer to the contents of the binary and the binary will not be copied. If the &lt;code&gt;Data&lt;/code&gt; argument is an iolist (list of binaries and lists), all binaries in the iolist will be copied.</source>
          <target state="translated">&lt;code&gt;port_control/3&lt;/code&gt; の &lt;code&gt;Data&lt;/code&gt; 引数がバイナリの場合、ドライバにはバイナリの内容へのポインタが渡され、バイナリはコピーされません。場合は &lt;code&gt;Data&lt;/code&gt; 引数はiolistという（バイナリとリストのリスト）で、iolistというのすべてのバイナリがコピーされます。</target>
        </trans-unit>
        <trans-unit id="9f73654015166f98aadbf7b3b123e17e68232e9b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HEART_COMMAND&lt;/code&gt; environment variable is to be set in the &lt;code&gt;start&lt;/code&gt; script in &lt;strong&gt;Starting Erlang&lt;/strong&gt;, and if the value is to be set to the path of the Solaris &lt;code&gt;reboot&lt;/code&gt; command, that is:</source>
          <target state="translated">場合 &lt;code&gt;HEART_COMMAND&lt;/code&gt; の環境変数がに設定される &lt;code&gt;start&lt;/code&gt; でスクリプト&lt;strong&gt;アーランを開始し&lt;/strong&gt;、その値は、Solarisのパスに設定する場合は &lt;code&gt;reboot&lt;/code&gt; コマンド、それは次のようになります。</target>
        </trans-unit>
        <trans-unit id="944e73a76d9846f1844b61fadd1ef6be5fa46f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Item&lt;/code&gt; is a string &quot;&amp;lt;X.Y.Z&amp;gt;&quot; as returned from &lt;code&gt;pid_to_list/1&lt;/code&gt;, the process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">場合は &lt;code&gt;Item&lt;/code&gt; 文字列であるから返される「&amp;lt;XYZ&amp;gt;」 &lt;code&gt;pid_to_list/1&lt;/code&gt; 、工程 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; トレースされます。</target>
        </trans-unit>
        <trans-unit id="61eca5d5aa872cbcbe9a56199f7268cf843102ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Mod&lt;/code&gt; argument is given, the result contains a &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for module &lt;code&gt;Mod&lt;/code&gt; only, otherwise the result contains one &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for all modules returned from &lt;code&gt;code:all_loaded()&lt;/code&gt; except &lt;code&gt;cprof&lt;/code&gt; itself.</source>
          <target state="translated">場合 &lt;code&gt;Mod&lt;/code&gt; 引数が指定され、結果が含ま &lt;code&gt;ModAnalysis&lt;/code&gt; のモジュールのためのタプル &lt;code&gt;Mod&lt;/code&gt; のみを、そうでなければ結果は、いずれかが含ま &lt;code&gt;ModAnalysis&lt;/code&gt; のから返されたすべてのモジュールのタプル &lt;code&gt;code:all_loaded()&lt;/code&gt; 以外 &lt;code&gt;cprof&lt;/code&gt; 自体。</target>
        </trans-unit>
        <trans-unit id="692d7ddeb29364bd451d87d06edbd7eec80bea02" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has been set, a &lt;code&gt;NewAtomCacheRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">場合 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 次のため &lt;code&gt;AtomCacheRef&lt;/code&gt; が設定されている、 &lt;code&gt;NewAtomCacheRef&lt;/code&gt; 次の形式では、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="04c0254fa6d70d431ad5a486ddf123ee44618a15" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has not been set, a &lt;code&gt;CachedAtomRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">場合 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 次のため &lt;code&gt;AtomCacheRef&lt;/code&gt; が設定されていない、 &lt;code&gt;CachedAtomRef&lt;/code&gt; 次の形式では、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5abbbca51e0d96970bfc6e932a6073fa6c1b8d91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WrapSize&lt;/code&gt; is specified as &lt;code&gt;{time, WrapTime}&lt;/code&gt;, the current file is closed when it has been open more than &lt;code&gt;WrapTime&lt;/code&gt; milliseconds, regardless of it being empty or not.</source>
          <target state="translated">場合 &lt;code&gt;WrapSize&lt;/code&gt; をとして指定されている &lt;code&gt;{time, WrapTime}&lt;/code&gt; それはよりオープン以上であった場合、現在のファイルが閉じられ &lt;code&gt;WrapTime&lt;/code&gt; のかかわらず、それが空かどうかという、ミリ。</target>
        </trans-unit>
        <trans-unit id="3bce9200cd49c0302061751c509bff17706e1d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;collector_pid&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; a new &lt;code&gt;et_collector&lt;/code&gt; will be started with the following parameter settings: &lt;code&gt;parent_pid&lt;/code&gt;, &lt;code&gt;event_order&lt;/code&gt;, &lt;code&gt;trace_global&lt;/code&gt;, &lt;code&gt;trace_pattern&lt;/code&gt;, &lt;code&gt;trace_port&lt;/code&gt;, &lt;code&gt;trace_max_queue&lt;/code&gt;, &lt;code&gt;trace_client&lt;/code&gt;, &lt;code&gt;dict_insert&lt;/code&gt; and &lt;code&gt;dict_delete&lt;/code&gt;. The new &lt;code&gt;et_viewer&lt;/code&gt; will register itself as an &lt;code&gt;et_collector&lt;/code&gt; subscriber.</source>
          <target state="translated">&lt;code&gt;collector_pid&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; 場合、新しい &lt;code&gt;et_collector&lt;/code&gt; は次のパラメーター設定で開始されます： &lt;code&gt;parent_pid&lt;/code&gt; 、 &lt;code&gt;event_order&lt;/code&gt; 、 &lt;code&gt;trace_global&lt;/code&gt; 、 &lt;code&gt;trace_pattern&lt;/code&gt; 、 &lt;code&gt;trace_port&lt;/code&gt; 、 &lt;code&gt;trace_max_queue&lt;/code&gt; 、 &lt;code&gt;trace_client&lt;/code&gt; 、 &lt;code&gt;dict_insert&lt;/code&gt; 、 &lt;code&gt;dict_delete&lt;/code&gt; 。新しい &lt;code&gt;et_viewer&lt;/code&gt; は、それ自体を &lt;code&gt;et_collector&lt;/code&gt; サブスクライバーとして登録します。</target>
        </trans-unit>
        <trans-unit id="1705267e03ee01724d59b40bc5f0214567319c46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; and/or &lt;code&gt;per_cpu&lt;/code&gt; option is given, this is the CPU number, or a list of the CPU numbers.</source>
          <target state="translated">場合 &lt;code&gt;detailed&lt;/code&gt; および/または &lt;code&gt;per_cpu&lt;/code&gt; のオプションが与えられ、これは、CPUの数、またはCPU番号のリストです。</target>
        </trans-unit>
        <trans-unit id="e77d603a3001a1e9c1762cdeaacfe7bfa22a3f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; option is given, this is a list of &lt;code&gt;{State, Share}&lt;/code&gt; tuples, where each tuple contains information about a processor state that has been identified as a busy processor state (see below). The atom &lt;code&gt;State&lt;/code&gt; is the name of the state, and the float &lt;code&gt;Share&lt;/code&gt; represents the percentage share of the CPU cycles spent in this state since the last call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;detailed&lt;/code&gt; オプションが指定されている場合、これは &lt;code&gt;{State, Share}&lt;/code&gt; タプルのリストです。各タプルには、ビジー状態のプロセッサ状態として識別されたプロセッサ状態に関する情報が含まれます（以下を参照）。アトム &lt;code&gt;State&lt;/code&gt; は状態の名前であり、float &lt;code&gt;Share&lt;/code&gt; は、最後の &lt;code&gt;util/0&lt;/code&gt; または &lt;code&gt;util/1&lt;/code&gt; の呼び出し以降にこの状態で費やされたCPUサイクルのシェアを表します。</target>
        </trans-unit>
        <trans-unit id="01f6b148b35fa3a772ed4cf02b8f14d1a3fb663b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;excl_lib&lt;/code&gt; option is set to &lt;code&gt;otp_root&lt;/code&gt; then reltool will not copy anything from the Erlang/OTP installation ($OTP_ROOT) into the target structure. The goal is to create a &quot;slim&quot; release which can be used together with an existing Erlang/OTP installation. The target structure will therefore only contain a &lt;code&gt;lib&lt;/code&gt; directory with the applications that were found outside of $OTP_ROOT (typically your own applications), and a &lt;code&gt;releases&lt;/code&gt; directory with the generated &lt;code&gt;.rel,&lt;/code&gt;&lt;code&gt;.script&lt;/code&gt; and &lt;code&gt;.boot&lt;/code&gt; files.</source>
          <target state="translated">場合 &lt;code&gt;excl_lib&lt;/code&gt; オプションがに設定されている &lt;code&gt;otp_root&lt;/code&gt; reltoolターゲット構造へのErlang / OTPのインストール（$ OTP_ROOT）から何かをコピーしません。目標は、既存のErlang / OTPインストールと一緒に使用できる「スリム」リリースを作成することです。ターゲット構造は、そのためだけ含まれています &lt;code&gt;lib&lt;/code&gt; $ OTP_ROOT（通常は、独自のアプリケーション）の外側に、そして発見されたアプリケーションとディレクトリを &lt;code&gt;releases&lt;/code&gt; 、生成したディレクトリを &lt;code&gt;.rel,&lt;/code&gt; &lt;code&gt;.script&lt;/code&gt; と &lt;code&gt;.boot&lt;/code&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="be47c608e84207db441f123dc3b022c3bdfe3832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fprof&lt;/code&gt; server is not running, this function returns immediately with the same return value.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; サーバーが実行されていない場合、この関数は同じ戻り値ですぐに戻ります。</target>
        </trans-unit>
        <trans-unit id="4cfc64c80cf0754288971ed2f55082185d9efbaf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_event&lt;/code&gt; is to be able to receive other messages than events, the callback function &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_event&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; がイベント以外のメッセージを受信できるようにする場合は、それらを処理するためにコールバック関数 &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; 実装する必要があります。他のメッセージの例は、 &lt;code&gt;gen_event&lt;/code&gt; が（スーパーバイザ以外の）他のプロセスにリンクされ、終了信号をトラップする場合の終了メッセージです。</target>
        </trans-unit>
        <trans-unit id="5aad944a4a47c5bc78a9273e949274df0e9ed557" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is not part of a supervision tree, a stop function can be useful, for example:</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; が監視ツリーの一部ではない場合、停止機能が役立ちます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="4832a13c9684cb02c06fa828f9150cd6ab481d33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_server&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; が監視ツリーの一部である場合、停止機能は必要ありません。 &lt;code&gt;gen_server&lt;/code&gt; は自動的にスーパーバイザで終了します。これが正確にどのように行われるかは、スーパーバイザに設定された &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; によって定義されます。</target>
        </trans-unit>
        <trans-unit id="3b4cc7e563bc4ab43d392728008910f94dfb10ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is to be able to receive other messages than requests, the callback function &lt;code&gt;handle_info(Info, State)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_server&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">場合 &lt;code&gt;gen_server&lt;/code&gt; が要求以外のメッセージを受信できるようにすることです、コールバック関数 &lt;code&gt;handle_info(Info, State)&lt;/code&gt; それらを処理するために実装する必要があります。他のメッセージの例は、 &lt;code&gt;gen_server&lt;/code&gt; が（スーパーバイザ以外の）他のプロセスにリンクされており、終了信号をトラップしている場合の終了メッセージです。</target>
        </trans-unit>
        <trans-unit id="2f9738619fd7812022c1fdbad1b01a2e041bfacc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason=shutdown&lt;/code&gt; if the following conditions apply:</source>
          <target state="translated">場合は &lt;code&gt;gen_server&lt;/code&gt; のプロセスが監督・ツリーの一部であり、終了するためにその上司が注文されて、この機能を使用して呼び出され &lt;code&gt;Reason=shutdown&lt;/code&gt; 次の条件が適用される場合：</target>
        </trans-unit>
        <trans-unit id="deb0cd9df07520473713789c264957ed22e0fd37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is successfully created and initialized, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the &lt;code&gt;gen_server&lt;/code&gt; process. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">場合 &lt;code&gt;gen_server&lt;/code&gt; のプロセスが正常に作成され、初期化され、関数が戻る &lt;code&gt;{ok,Pid}&lt;/code&gt; 、ここで、 &lt;code&gt;Pid&lt;/code&gt; のPIDである &lt;code&gt;gen_server&lt;/code&gt; のプロセス。指定された &lt;code&gt;ServerName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="7b56e5a9d7d5389ddf0dc35b8aa333d9d01bbefc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return &lt;code&gt;{continue,Continue}&lt;/code&gt; in place of the time-out or hibernation value, which will immediately invoke the &lt;code&gt;handle_continue/2&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; プロセスが初期化の直後にアクションを実行する必要がある場合、またはコールバックの実行を複数のステップに分割する必要がある場合、タイムアウト値または休止値の代わりに &lt;code&gt;{continue,Continue}&lt;/code&gt; 返すことができます。これにより、 &lt;code&gt;handle_continue/2&lt;/code&gt; が直ちに呼び出されます。 2コールバック。</target>
        </trans-unit>
        <trans-unit id="490e75ed674d410c271a45a56872f3c49ab0b58b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is not part of a supervision tree, it can be stopped using &lt;code&gt;gen_statem:stop&lt;/code&gt;, preferably through an API function:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; が監視ツリーの一部でない場合は、gen_statem &lt;code&gt;gen_statem:stop&lt;/code&gt; を使用して、できればAPI関数を使用して停止できます。</target>
        </trans-unit>
        <trans-unit id="36f4edf0379e907c933af357c419f98ac2861c66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason = shutdown&lt;/code&gt; if both the following conditions apply:</source>
          <target state="translated">場合 &lt;code&gt;gen_statem&lt;/code&gt; が監督・ツリーの一部であり、終了するためにその上司が注文されて、この機能を使用して呼び出され &lt;code&gt;Reason = shutdown&lt;/code&gt; 次の両方の条件に該当する場合：</target>
        </trans-unit>
        <trans-unit id="ac199e9236c5ed4f285d3986ed2287bb9a4c55ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_statem&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; が監視ツリーの一部である場合、停止機能は必要ありません。 &lt;code&gt;gen_statem&lt;/code&gt; は自動的にスーパーバイザで終了します。これが正確にどのように行われるかは、スーパーバイザに設定された &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; によって定義されます。</target>
        </trans-unit>
        <trans-unit id="622dc023e6ca738739a4198b61e3fabf701c009b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is successfully created and initialized, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of that process.</source>
          <target state="translated">場合 &lt;code&gt;gen_statem&lt;/code&gt; が正常に作成され、初期化され、この関数の戻り &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;Pid&lt;/code&gt; ある &lt;code&gt;pid()&lt;/code&gt; の &lt;code&gt;gen_statem&lt;/code&gt; 。指定された &lt;code&gt;ServerName&lt;/code&gt; を持つプロセスがすでに存在する場合、この関数は &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はその &lt;code&gt;pid()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b7d4b7b9947ceb2e1f75b847cb2c2cefc610ce87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inform request behaviour&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">場合 &lt;code&gt;inform request behaviour&lt;/code&gt; 設定オプションに設定されている &lt;code&gt;user&lt;/code&gt; または &lt;code&gt;{user, integer()}&lt;/code&gt; 、この通知要求に対する応答（確認応答）をすると、この関数のリターンを送信します。</target>
        </trans-unit>
        <trans-unit id="f12a4aa7db27654fb06f0356ee419770a3c5990d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;main/1&lt;/code&gt; function in the script returns successfully, the exit status for the script is &lt;code&gt;0&lt;/code&gt;. If an exception is generated during execution, a short message is printed and the script terminates with exit status &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">スクリプトの &lt;code&gt;main/1&lt;/code&gt; 関数が正常に戻る場合、スクリプトの終了ステータスは &lt;code&gt;0&lt;/code&gt; です。実行中に例外が生成されると、短いメッセージが出力され、スクリプトは終了ステータス &lt;code&gt;127&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="6df86c1718762f44b04c0cb308484d1d6c310a34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;max_sessions&lt;/code&gt; option is set to &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;parallel_login&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the maximum number of simultaneous login attempts at any time is limited to &lt;code&gt;N-K&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; is the number of authenticated connections present at this daemon.</source>
          <target state="translated">場合 &lt;code&gt;max_sessions&lt;/code&gt; オプションに設定されている &lt;code&gt;N&lt;/code&gt; と &lt;code&gt;parallel_login&lt;/code&gt; がに設定されている &lt;code&gt;true&lt;/code&gt; 、任意の時点での同時ログイン試行の最大数が制限される &lt;code&gt;N-K&lt;/code&gt; 、 &lt;code&gt;K&lt;/code&gt; は、このデーモンに存在する認証された接続の数です。</target>
        </trans-unit>
        <trans-unit id="279c740df4997832935268858ff97ba56a5fb972" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;parse_transform&lt;/code&gt; is not applied to a module that calls this pseudo function, the call fails in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; module exports a function with this name, but it is never to be called except when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including header file &lt;code&gt;ms_transform.hrl&lt;/code&gt;, compiled code never calls the function, but the function call is replaced by a literal match specification.</source>
          <target state="translated">この疑似関数を呼び出すモジュールに &lt;code&gt;parse_transform&lt;/code&gt; が適用されていない場合、呼び出しは実行時に失敗します（ &lt;code&gt;badarg&lt;/code&gt; を使用）。 &lt;code&gt;ets&lt;/code&gt; モジュールは、この名前の関数をエクスポートしますが、それはシェルで機能を使用する場合を除き、呼び出されることはありません。ヘッダーファイル &lt;code&gt;ms_transform.hrl&lt;/code&gt; を &lt;code&gt;parse_transform&lt;/code&gt; が適切に適用されている場合、コンパイルされたコードが関数を呼び出すことはありませんが、関数呼び出しはリテラル一致指定に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="91c8b62af5511bc181fbe7c0815f7318805644f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;per_cpu&lt;/code&gt; is not given, the value(s) presented are the average of all CPUs.</source>
          <target state="translated">&lt;code&gt;per_cpu&lt;/code&gt; が指定されていない場合、表示される値はすべてのCPUの平均です。</target>
        </trans-unit>
        <trans-unit id="2c4b5f09b562c0e8df5ab61a0939a3cca6eab6e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;qlc&lt;/code&gt; module at compile time can determine that some constant is free of integers, it does not matter which one of &lt;code&gt;==/2&lt;/code&gt; or &lt;code&gt;=:=/2&lt;/code&gt; is used:</source>
          <target state="translated">場合 &lt;code&gt;qlc&lt;/code&gt; コンパイル時にモジュールは、いくつかの定数は整数の自由であると判断することができ、それは問題ではその一つではないん &lt;code&gt;==/2&lt;/code&gt; または &lt;code&gt;=:=/2&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="345d6310f85895e6842a34eabfe92151229e6b95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It it only to contain low-level instructions.</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; ファイルが比較的単純な場合は、手動で作成できます。それは低レベルの命令を含むだけです。</target>
        </trans-unit>
        <trans-unit id="c30c579f26aae9f62a722f68b38557366dc19832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;restart_new_emulator&lt;/code&gt; の命令は、スクリプト、に見出される &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 戻る &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。これは、 &lt;code&gt;restart_new_emulator&lt;/code&gt; では、残りのアップグレード手順を実行する前に、新しいバージョンのエミュレーターを起動する必要があるためです。これは、 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; によってのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="a3734548d24c8fafceb3c3b7a48423c44c0a982c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;restart_new_emulator&lt;/code&gt; の命令は、スクリプト、に見出される &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; 戻る &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。これは、 &lt;code&gt;restart_new_emulator&lt;/code&gt; では、残りのアップグレード手順を実行する前に、新しいバージョンのエミュレーターを起動する必要があるためです。これは、 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; によってのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="52741bb5942e459f72dab152ca12b8b26eff70c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/3,4&lt;/code&gt; function is used, all management targets are selected, as defined in RFC2273. The &lt;code&gt;Receiver&lt;/code&gt; parameter defines where the agent should send information about the delivery of inform requests.</source>
          <target state="translated">&lt;code&gt;send_notification/3,4&lt;/code&gt; 関数が使用される場合、RFC2273で定義されているように、すべての管理ターゲットが選択されます。 &lt;code&gt;Receiver&lt;/code&gt; エージェントが通知要求の配信に関する情報を送信する必要があり、パラメータを定義。</target>
        </trans-unit>
        <trans-unit id="4e603d462637bea7ebad3ed1b02ae3e6befcd5e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/5&lt;/code&gt; function is used, an &lt;code&gt;NotifyName&lt;/code&gt; must be provided. This parameter is used as an index in the &lt;code&gt;snmpNotifyTable&lt;/code&gt;, and the management targets defined by that single entry is used.</source>
          <target state="translated">場合 &lt;code&gt;send_notification/5&lt;/code&gt; 機能を使用している、 &lt;code&gt;NotifyName&lt;/code&gt; が提供されなければなりません。このパラメーターは &lt;code&gt;snmpNotifyTable&lt;/code&gt; のインデックスとして使用され、その単一のエントリによって定義された管理ターゲットが使用されます。</target>
        </trans-unit>
        <trans-unit id="13bd2cdf7f65d1258410067e1dbfa02e06ec92b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt; で &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; が有効になっていない場合は、有効にします。</target>
        </trans-unit>
        <trans-unit id="275e62491f49fb1a70d7127de6210ff8d9a19127" translate="yes" xml:space="preserve">
          <source>If the ASN.1 module has been compiled with option &lt;code&gt;maps&lt;/code&gt;, the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; are represented as maps.</source>
          <target state="translated">ASN.1モジュールがオプション &lt;code&gt;maps&lt;/code&gt; でコンパイルされている場合、タイプ &lt;code&gt;SEQUENCE&lt;/code&gt; および &lt;code&gt;SET&lt;/code&gt; はマップとして表されます。</target>
        </trans-unit>
        <trans-unit id="722c5c772253cfa0375f5705288b0321c521aa8d" translate="yes" xml:space="preserve">
          <source>If the AckStatus is ok, it is indicating that this is a true acknowledgement of the transaction reply.</source>
          <target state="translated">AckStatusがOKであれば、それはこれがトランザクションリプライの真の確認であることを示している。</target>
        </trans-unit>
        <trans-unit id="d0f84b01e010783659e66100fe954814d18e563f" translate="yes" xml:space="preserve">
          <source>If the AckStatus is {error, Reason}, it is an indication that the acknowledgement or even the reply (for which this is an acknowledgement) was not delivered, but there is no point in waiting any longer for it to arrive. This happens when:</source>
          <target state="translated">AckStatus が {error,Reason}である場合、これは確認応答や応答(これが確認応答である)が届かなかったことを示していますが、これ以上到着を待っても意味がありません。これは次のような場合に起こります。</target>
        </trans-unit>
        <trans-unit id="88faac2c33abe1fdc3fc1b10f5136c262bb64e7a" translate="yes" xml:space="preserve">
          <source>If the BEAM file contains &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">BEAMファイルに &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; が含まれている場合、タプルのリストが返されます。各タプルの最初の要素は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="52ebbcd03e14972b092b8f0cc1bbe4c3dd868b59" translate="yes" xml:space="preserve">
          <source>If the BEAM file does not contain debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">BEAM ファイルにデバッグ情報が含まれていない場合は、タプルのリストが返されます。各タプルの最初の要素は、以下のいずれかです。</target>
        </trans-unit>
        <trans-unit id="5e318cbbe5a1c0ec48c8b2b2021ac1f10131570e" translate="yes" xml:space="preserve">
          <source>If the C node acts as a server, it must first create a socket (call &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;) listening to a certain port number &lt;code&gt;port&lt;/code&gt;. It then publishes its name and port number with &lt;code&gt;epmd&lt;/code&gt;, the Erlang port mapper daemon. For details, see the &lt;code&gt;epmd&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">Cノードがサーバーとして機能する場合、最初に特定のポート番号 &lt;code&gt;port&lt;/code&gt; を &lt;code&gt;listen()&lt;/code&gt; &lt;code&gt;bind()&lt;/code&gt; ソケット（bind（）およびlisten（）を呼び出す）を作成する必要があります。次に、Erlangポートマッパーデーモンである &lt;code&gt;epmd&lt;/code&gt; を使用して、名前とポート番号を公開します。詳細については、 &lt;code&gt;epmd&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="82d38ec527a550307461604062c03b211a833f6c" translate="yes" xml:space="preserve">
          <source>If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).</source>
          <target state="translated">COND1 パターンが一致した場合、FOO が試行される(FOO が成功した場合は、グループの終了後にさらに別の項目が試行される可能性もある)。失敗した場合、マッチャーは2番目の代替案にスキップし、COND1にバックトラックせずにCOND2を試みる。これが成功してBARが失敗した場合、COND3が試される。BAZ が失敗した場合、それ以上の選択肢はないので、グループ全体の前に来たものへのバックトラックが発生する。(*THEN)が選択肢の中にない場合は、(*PRUNE)のように動作します。</target>
        </trans-unit>
        <trans-unit id="ac5eaef6ff1820888de0ffa5ad9b4186d0234433" translate="yes" xml:space="preserve">
          <source>If the CPU information has changed since the last time it was read, the atom &lt;code&gt;changed&lt;/code&gt; is returned, otherwise the atom &lt;code&gt;unchanged&lt;/code&gt;. If the CPU information has changed, you probably want to &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt;. You typically want to have as many schedulers online as &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CPU情報は、それが読まれた最後の時間以降に変更された場合には、原子 &lt;code&gt;changed&lt;/code&gt; そうでない原子、返される &lt;code&gt;unchanged&lt;/code&gt; 。CPU情報が変更された場合は、おそらく &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt; を調整する必要があります。通常、 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt; 同じ数のスケジューラをオンラインにしたいとします。</target>
        </trans-unit>
        <trans-unit id="674a0c6bf29cc8c8f0b253946e997318f6046675" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the &lt;code&gt;auth_group_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Detsストレージ方式を使用する場合、グループデータベースはDetsによって維持され、手動で編集することはできません。モジュール &lt;code&gt;mod_auth&lt;/code&gt; のAPIを使用して、グループデータベースを作成/編集します。 Mnesiaストレージ方式が使用されている場合、このディレクティブは無視されます。セキュリティ上の理由から、 &lt;code&gt;auth_group_file&lt;/code&gt; がWebサーバーのドキュメントツリーの外部に格納されていることを確認してください。それが保護するディレクトリに配置されている場合、クライアントはそれをダウンロードできます。</target>
        </trans-unit>
        <trans-unit id="2690e1607b444fbdfb4354a7fc5e69fab4fc5a65" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that &lt;code&gt;auth_user_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Detsストレージ方式を使用する場合、ユーザーデータベースはDetsによって維持され、手動で編集してはなりません。モジュール &lt;code&gt;mod_auth&lt;/code&gt; の API関数を使用して、ユーザーデータベースを作成/編集します。 Mnesiaストレージ方式が使用されている場合、このディレクティブは無視されます。セキュリティ上の理由から、 &lt;code&gt;auth_user_file&lt;/code&gt; がWebサーバーのドキュメントツリーの外部に格納されていることを確認してください。それが保護するディレクトリに配置されている場合、クライアントはそれをダウンロードできます。</target>
        </trans-unit>
        <trans-unit id="5d6f0952016312ac237e99b15d9161adf55f700d" translate="yes" xml:space="preserve">
          <source>If the Erlang node was alive, that is, set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</source>
          <target state="translated">Erlangノードが生きていた場合、つまり他のノードと通信できるように設定されていた場合、このセクションではアクティブなコネクションのリストを表示します。以下のフィールドが存在します。</target>
        </trans-unit>
        <trans-unit id="18daf2db870215dd47d6849bc420623f1e0d4030" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</source>
          <target state="translated">もしErlangランタイムシステムが唯一のOSプロセスが論理プロセッサにスレッドをバインドしている場合、ランタイムシステムのパフォーマンスが向上します。しかし、他のOSプロセス(例えば、他のErlangランタイムシステム)もスレッドを論理プロセッサにバインドしている場合、パフォーマンスのペナルティが発生することがあります。時には、このパフォーマンスペナルティが深刻になることもあります。その場合、スケジューラをバインドしないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3549c6b8d3c0426e098c164e7bd7160b6e4be362" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system. However, if other operating system processes (for example another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. This performance penalty can sometimes be severe. If so, you are advised not to bind the schedulers.</source>
          <target state="translated">もしErlangランタイムシステムがスレッドを論理プロセッサにバインドする唯一のオペレーティングシステムプロセスなら、ランタイムシステムのパフォーマンスが向上します。しかし、他のオペレーティングシステムプロセス(例えば他のErlangランタイムシステム)もスレッドを論理プロセッサにバインドしている場合、パフォーマンスのペナルティが発生することがあります。このパフォーマンスペナルティは時に深刻になることがあります。その場合、スケジューラをバインドしないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="78b8e3a5a6a0636736a794de9e5a1415d4c36fbf" translate="yes" xml:space="preserve">
          <source>If the Erlang shell buffer would be killed the command line history is saved to a file. The command line history is automatically retrieved when a new Erlang shell is started.</source>
          <target state="translated">もしErlangシェルバッファが死んでしまった場合、コマンドラインの履歴はファイルに保存されます。コマンドラインの履歴は新しいErlangシェルが起動すると自動的に取得されます。</target>
        </trans-unit>
        <trans-unit id="5ad331d93d63bf83b44ef888cb4e43e94ea364bb" translate="yes" xml:space="preserve">
          <source>If the INDEX column is of type INTEGER, or derived from INTEGER, the corresponding type should be &lt;code&gt;integer&lt;/code&gt;. If it is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING), the corresponding type should be &lt;code&gt;string&lt;/code&gt;. Finally, if the type is of variable length, but with a fixed size restriction (e.g. IpAddress), the corresponding type should be &lt;code&gt;fix_string&lt;/code&gt;.</source>
          <target state="translated">INDEX列のタイプがINTEGERであるか、INTEGERから派生している場合、対応するタイプは &lt;code&gt;integer&lt;/code&gt; でなければなりません。可変長タイプ（OBJECT IDENTIFIER、OCTET STRINGなど）の場合、対応するタイプは &lt;code&gt;string&lt;/code&gt; でなければなりません。最後に、型が可変長であるが、サイズ制限が固定されている場合（IpAddressなど）、対応する型は &lt;code&gt;fix_string&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="27815f723f23d4e4cf3d912f3476eb64c838477e" translate="yes" xml:space="preserve">
          <source>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">MGがMGCのMIDでプロビジョニングできない場合、MGはmegaco:connect/4のRemoteMidパラメータにアトム'previous_mid'を使用することができ、コールフローは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="291d17d4be116cb44759c41864d170474773407f" translate="yes" xml:space="preserve">
          <source>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">MGがMGCのMIDでプロビジョニングされている場合は、そのMIDをRemoteMidパラメータとしてmegaco:connect/4に与えることができ、コールフローは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3d3ec8b1bad21c29a9fcf6552b6d84ffcf7600b8" translate="yes" xml:space="preserve">
          <source>If the Mnesia database is used, this function calls &lt;code&gt;mnesia:write&lt;/code&gt; to store the values. This means that this function must be called from within a transaction (&lt;code&gt;mnesia:transaction/1&lt;/code&gt; or &lt;code&gt;mnesia:dirty/1&lt;/code&gt;).</source>
          <target state="translated">Mnesiaデータベースが使用されている場合、この関数は &lt;code&gt;mnesia:write&lt;/code&gt; を呼び出して値を格納します。つまり、この関数はトランザクション内から呼び出す必要があります（ &lt;code&gt;mnesia:transaction/1&lt;/code&gt; または &lt;code&gt;mnesia:dirty/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="40a56f15bd541bd82f926eed2c112eaac90f9e71" translate="yes" xml:space="preserve">
          <source>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</source>
          <target state="translated">NIFコールが長すぎる場合、応答性の低下、スケジューラのロードバランシング問題、その他の奇妙な動作を避けるために、以下のいずれかの方法で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="436a83604c57a3e3475d1d2d6359ca37e137b110" translate="yes" xml:space="preserve">
          <source>If the OBJECT IDENTIFIER is longer than an OBJECT IDENTIFIER of an object type in the MIB, it refers to object instances. Because of this, it is possible to control whether or not particular rows in a table shall be visible.</source>
          <target state="translated">OBJECT IDENTIFIERがMIB内のオブジェクト型のOBJECT IDENTIFIERよりも長い場合は,オブジェクトインスタンスを参照する。このため,テーブル内の特定の行を可視化するかどうかを制御することが可能である。</target>
        </trans-unit>
        <trans-unit id="b1b26d2a72fe7f32dcd9c24e2f00608157279f71" translate="yes" xml:space="preserve">
          <source>If the OS used does not support non-blocking &lt;code&gt;sendfile&lt;/code&gt;, an Erlang fallback using &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用しているOSが非ブロッキング &lt;code&gt;sendfile&lt;/code&gt; をサポートしていない場合、 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; を使用したErlangフォールバックが使用されます。</target>
        </trans-unit>
        <trans-unit id="b3598222fc1bb53b9989c1f5e6bfd02eed50487d" translate="yes" xml:space="preserve">
          <source>If the SNMP agent needs to interact with sub-agents constructed in another package, a special sub-agent should be used, which communicates through a protocol specified by the other package.</source>
          <target state="translated">SNMPエージェントが他のパッケージで構築されたサブエージェントと対話する必要がある場合、他のパッケージで指定されたプロトコルを介して通信する特別なサブエージェントを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1c500f599c51107a79c77a136f03f46d05fafc58" translate="yes" xml:space="preserve">
          <source>If the SNMP table has more than one INDEX column, the corresponding Mnesia row is a tuple, where the first element is a tuple with the INDEX columns. Generally, if the SNMP table has &lt;strong&gt;N&lt;/strong&gt; INDEX columns and &lt;strong&gt;C&lt;/strong&gt; data columns, the Mnesia table is of arity &lt;strong&gt;(C-N)+1&lt;/strong&gt;, where the key is a tuple of arity &lt;strong&gt;N&lt;/strong&gt; if &lt;strong&gt;N &amp;gt; 1&lt;/strong&gt;, or a single term if &lt;strong&gt;N = 1&lt;/strong&gt;.</source>
          <target state="translated">SNMPテーブルに複数のINDEX列がある場合、対応するMnesia行はタプルです。最初の要素はINDEX列を持つタプルです。一般に、SNMPテーブルに&lt;strong&gt;N&lt;/strong&gt; INDEX列と&lt;strong&gt;C&lt;/strong&gt;データ列がある場合、Mnesiaテーブルはアリティ&lt;strong&gt;（CN）+1&lt;/strong&gt;であり、キーは&lt;strong&gt;N&amp;gt; 1の&lt;/strong&gt;場合はアリティ&lt;strong&gt;Nの&lt;/strong&gt;タプル、&lt;strong&gt;N = 1の&lt;/strong&gt;場合は単一の項です。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c217a2396ebcee146469f461600abdf337e010c" translate="yes" xml:space="preserve">
          <source>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</source>
          <target state="translated">TFTP サーバは、既にクライアントへのアクティブな接続がある状態で、 同じクライアント (同じホストとポート)から別のリクエストを受け取った場合、 そのリクエストが最初のリクエスト (ファイル名とオプションが同じ)と同じであれば、その新しいリクエストを無視します。これは、(新しい)クライアントはサーバ側で既に進行中の接続によって 扱われることを意味しています。進行中の接続と並行して別の接続を設定しないことで、サーバはより少ないリソースを消費します。</target>
        </trans-unit>
        <trans-unit id="89cbc4f7538c3f8a055eafb734ab8d43e17f7e9a" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF:</source>
          <target state="translated">Unicode変換修飾子（ &lt;code&gt;t&lt;/code&gt; ）が有効な場合、整数の引数は有効なUnicodeコードポイントを表す任意の数値にすることができます。それ以外の場合は、255以下の整数にし、そうでない場合は16＃FFでマスクします。</target>
        </trans-unit>
        <trans-unit id="cc5c86359b9d2f999369876543233d4ea822c7b0" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used in the format string, all event handlers must ensure that the formatted output is correctly encoded for the I/O device.</source>
          <target state="translated">Unicode変換修飾子（ &lt;code&gt;t&lt;/code&gt; ）がフォーマット文字列で使用されている場合、すべてのイベントハンドラーは、フォーマットされた出力がI / Oデバイス用に正しくエンコードされていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="9a64305e88f74d03f63e30e4aff9344ad3928f49" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function clause:</source>
          <target state="translated">分析が句レベルで行われる場合、結果はタプル &lt;code&gt;{Clause,Calls}&lt;/code&gt; リストとして提供されます。ここで &lt;code&gt;Calls&lt;/code&gt; は、各関数句の呼び出し数です。</target>
        </trans-unit>
        <trans-unit id="7bb518d0fd97d3152a60a637270e37af04b13222" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt;, one for each function clause in the module. A clause is specified by its module name, function name, arity and position within the function definition:</source>
          <target state="translated">分析が句レベルで行われる場合、結果はモジュールの各関数句に1つ &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt; タプル{Clause、{Cov、NotCov}}のリストとして提供されます。節は、モジュール名、関数名、アリティ、および関数定義内の位置によって指定されます。</target>
        </trans-unit>
        <trans-unit id="2478a8c8617596c655cc3da82b5c379b47e51b09" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function:</source>
          <target state="translated">分析が関数レベルで行われる場合、結果はタプルのリスト &lt;code&gt;{Function,Calls}&lt;/code&gt; として与えられます。ここで、 &lt;code&gt;Calls&lt;/code&gt; は各関数の呼び出し数です。</target>
        </trans-unit>
        <trans-unit id="55b7df1c13246cf49b1f19e127c65003b3a10d37" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt;, one for each function in the module. A function is specified by its module name, function name and arity:</source>
          <target state="translated">分析が関数レベルで行われる場合、結果はモジュール内の関数ごとに1つのタプル &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt; リストとして提供されます。関数は、そのモジュール名、関数名、およびアリティによって指定されます。</target>
        </trans-unit>
        <trans-unit id="77e592dc92d7ea0f9403bfb4d1e1860bc8a3fe5a" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given as a tuple &lt;code&gt;{Module,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the total number of calls to functions in the module:</source>
          <target state="translated">分析がモジュールレベルで行われる場合、結果はタプル &lt;code&gt;{Module,Calls}&lt;/code&gt; として与えられます。ここでの &lt;code&gt;Calls&lt;/code&gt; は、モジュール内の関数への呼び出しの総数です。</target>
        </trans-unit>
        <trans-unit id="5cba27c146502c3ec8e1044a59eca78a126f8832" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given for the entire module as a tuple &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt;:</source>
          <target state="translated">分析がモジュールレベルで行われる場合、結果はモジュール全体に対してタプル &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cde9769f09668ea79529ce6edefab85a0899d6da" translate="yes" xml:space="preserve">
          <source>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. &lt;code&gt;MasterNodes&lt;/code&gt; can only contain nodes where the table has a replica. If the &lt;code&gt;MasterNodes&lt;/code&gt; list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</source>
          <target state="translated">アプリケーションが、データベースの不整合を引き起こした可能性のある（潜在的に分割されたネットワークで）通信障害を検出した場合、関数 &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; を使用して、各テーブルをロードするノードを定義できます。起動時に、Mnesiaの通常のテーブルロードアルゴリズムはバイパスされ、Mnesiaが他のノードでいつ終了したかに関わらず、テーブルに定義されたマスターノードの1つからテーブルがロードされます。 &lt;code&gt;MasterNodes&lt;/code&gt; は、テーブルにレプリカがあるノードのみを含めることができます。 &lt;code&gt;MasterNodes&lt;/code&gt; リストが空の場合、特定のテーブルのマスターノード回復メカニズムがリセットされ、次の再起動時に通常のロードメカニズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="130ab90516f90ac945b3ebb327eb04a5eb66e021" translate="yes" xml:space="preserve">
          <source>If the application detects that there has been a communication failure that can have caused an inconsistent database, it can use the function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; to pinpoint from which nodes each table can be loaded.</source>
          <target state="translated">データベースの不整合を引き起こした可能性のある通信障害が発生したことをアプリケーションが検出した場合、アプリケーションは関数 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; を使用して、各テーブルをロードできるノードを特定できます。</target>
        </trans-unit>
        <trans-unit id="afc60992fdf5138ada7ac0487b61ff57acf63af0" translate="yes" xml:space="preserve">
          <source>If the application is distributed, setting the permission to &lt;code&gt;false&lt;/code&gt; means that the application will be started at, or moved to, another node according to how its distribution is configured (see &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">アプリケーションが配布される場合、許可を &lt;code&gt;false&lt;/code&gt; に設定すると、アプリケーションは、その配布の構成方法（ &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; を参照）に従って別のノードで開始または移動されます。</target>
        </trans-unit>
        <trans-unit id="ff80acb30d9dab81e0a46a50c51388e4dd17f7a3" translate="yes" xml:space="preserve">
          <source>If the application is not already loaded, the application controller first loads it using &lt;code&gt;application:load/1&lt;/code&gt;. It checks the value of the &lt;code&gt;applications&lt;/code&gt; key, to ensure that all applications that are to be started before this application are running.</source>
          <target state="translated">アプリケーションがまだロードされていない場合、アプリケーションコントローラーは最初に &lt;code&gt;application:load/1&lt;/code&gt; を使用してアプリケーションをロードします。 &lt;code&gt;applications&lt;/code&gt; キーの値をチェックして、このアプリケーションが実行される前に起動されるすべてのアプリケーションを確認します。</target>
        </trans-unit>
        <trans-unit id="60e7f4b69d5dbe87fef4344be83c638457c7eec7" translate="yes" xml:space="preserve">
          <source>If the application needs to include the generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">アプリケーションが生成された &lt;code&gt;.hrl&lt;/code&gt; ファイルを含める必要がある場合は、Erlangコンパイラに &lt;code&gt;-include_lib&lt;/code&gt; ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="683ef606c81dc1c47b5d3b9c095a4243030bc6f8" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;Func&lt;/code&gt;, the timetrap is triggered when this function returns. &lt;code&gt;Func&lt;/code&gt; can also return a new &lt;code&gt;Time&lt;/code&gt; value, which in that case is the value for the new timetrap.</source>
          <target state="translated">引数が &lt;code&gt;Func&lt;/code&gt; の場合、この関数が戻るとタイムトラップがトリガーされます。 &lt;code&gt;Func&lt;/code&gt; は、新しいTimetrapの値である新しい &lt;code&gt;Time&lt;/code&gt; 値を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="0044e9d649274cc90388ee08844dd19dea89fffe" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt;, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</source>
          <target state="translated">引数が &lt;code&gt;false&lt;/code&gt; の場合、現在のプロセスの呼び出しトレースメッセージモードは、この呼び出しとそれ以降のすべての呼び出しで通常（非サイレント）に設定されます。</target>
        </trans-unit>
        <trans-unit id="580f4ef0ac5467ad7d400143bdf178fbf747f519" translate="yes" xml:space="preserve">
          <source>If the argument is invalid</source>
          <target state="translated">引数が無効な場合</target>
        </trans-unit>
        <trans-unit id="c3def1ea3a84c13010f731140dbb829f22745007" translate="yes" xml:space="preserve">
          <source>If the argument is not &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the call trace message mode is unaffected.</source>
          <target state="translated">引数が &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; でない場合、呼び出しトレースメッセージモードは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="259c1b3a1fe7d6190505c0293c344282223212ec" translate="yes" xml:space="preserve">
          <source>If the arguments or options are malformed, the function throws a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">引数またはオプションの形式が正しくない場合、関数は &lt;code&gt;badarg&lt;/code&gt; 例外をスローします。</target>
        </trans-unit>
        <trans-unit id="6b60aa2a26e0a24944e43c25dc549ab30b52857b" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, and &lt;code&gt;I&lt;/code&gt; is greater than &lt;code&gt;size(Array)-1&lt;/code&gt;, the array grows to size &lt;code&gt;I+1&lt;/code&gt;.</source>
          <target state="translated">配列のサイズが固定されておらず、 &lt;code&gt;I&lt;/code&gt; が &lt;code&gt;size(Array)-1&lt;/code&gt; より大きい場合、配列のサイズは &lt;code&gt;I+1&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="e97eb155a25d26096ef78fc2b67cf5447071cfc9" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, the default value for any index &lt;code&gt;I&lt;/code&gt; greater than &lt;code&gt;size(Array)-1&lt;/code&gt; is returned.</source>
          <target state="translated">配列のサイズが固定されていない場合は、 &lt;code&gt;size(Array)-1&lt;/code&gt; より大きいインデックス &lt;code&gt;I&lt;/code&gt; のデフォルト値が返されます。</target>
        </trans-unit>
        <trans-unit id="5552e65bff8e7b19a94e0b983a0ae9846e97b32b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;len&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">アトムは既に、この機能を格納用語が存在する場合 &lt;code&gt;*atom&lt;/code&gt; と戻り &lt;code&gt;true&lt;/code&gt; 、そうでない場合 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;len&lt;/code&gt; がアトムに許可されている最大長（255文字）を超える場合も &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0d657f088165dffa1fac0e9bbe37e81e0983227b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if the length of &lt;code&gt;name&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">アトムは既に、この機能を格納用語が存在する場合 &lt;code&gt;*atom&lt;/code&gt; と戻り &lt;code&gt;true&lt;/code&gt; 、そうでない場合 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; の長さがアトムに許可されている最大長（255文字）を超える場合も &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="cbc8e0e10b7bf47bd128f48e3648baa81fc6271d" translate="yes" xml:space="preserve">
          <source>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">ログを切り捨てる試みが失敗した場合、ディスクログプロセスはEXITメッセージ &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt; ます。リクエストがキューに入れられている他のプロセスは、メッセージ &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e7576e0423d861bfb48c83bfa3b5b0c281c96ce4" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt;systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">ブートスクリプトに &lt;code&gt;$ROOT&lt;/code&gt; 以外のパス変数 &lt;code&gt;Var&lt;/code&gt; が含まれている場合、この変数は &lt;code&gt;Dir&lt;/code&gt; に展開されます。アプリケーションが &lt;code&gt;$ROOT/lib&lt;/code&gt; 以外のディレクトリにインストールされている場合に使用されます。SASLの &lt;code&gt;systools:make_script/1,2&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc4746e92bb60b88599fe7a3e474a68b05603534" translate="yes" xml:space="preserve">
          <source>If the call times out, a &lt;code&gt;timeout&lt;/code&gt; exception is raised.</source>
          <target state="translated">呼び出しが &lt;code&gt;timeout&lt;/code&gt; と、タイムアウト例外が発生します。</target>
        </trans-unit>
        <trans-unit id="55cc2b4bba08ca73afe9b3ccf29541b97304c864" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;erlang:load_nif/2&lt;/code&gt; fails, the module is unloaded and a warning report is sent to the error loader.</source>
          <target state="translated">&lt;code&gt;erlang:load_nif/2&lt;/code&gt; の呼び出しが失敗した場合、モジュールはアンロードされ、警告レポートがエラーローダーに送信されます。</target>
        </trans-unit>
        <trans-unit id="4b48d532db57aebd987ac6820de7ad7436dd64ed" translate="yes" xml:space="preserve">
          <source>If the callback module cannot be loaded, an error tuple is returned. The &lt;code&gt;Reason&lt;/code&gt; in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</source>
          <target state="translated">コールバックモジュールをロードできない場合、エラータプルが返されます。エラータプルの &lt;code&gt;Reason&lt;/code&gt; は、コールバックモジュールのコードをロードしようとしたときにコードローダーによって返された理由です。</target>
        </trans-unit>
        <trans-unit id="8bf050fe2cb79b5d36a88eaed63edd7eed898889" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_get_state/1&lt;/code&gt; function, &lt;code&gt;get_state/1,2&lt;/code&gt; assumes that the &lt;code&gt;Misc&lt;/code&gt; value is the state of the callback module and returns it directly instead.</source>
          <target state="translated">コールバックモジュールが &lt;code&gt;system_get_state/1&lt;/code&gt; 関数をエクスポートしない場合、 &lt;code&gt;get_state/1,2&lt;/code&gt; は &lt;code&gt;Misc&lt;/code&gt; 値がコールバックモジュールの状態であると想定し、代わりに直接返します。</target>
        </trans-unit>
        <trans-unit id="883a1351f7fb38c93f27abac246b139ddf314ded" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_replace_state/2&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; assumes that &lt;code&gt;Misc&lt;/code&gt; is the state of the callback module, passes it to &lt;code&gt;StateFun&lt;/code&gt; and uses the return value as both the new state and as the new value of &lt;code&gt;Misc&lt;/code&gt;.</source>
          <target state="translated">コールバックモジュールが &lt;code&gt;system_replace_state/2&lt;/code&gt; 関数をエクスポートしない場合、 &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;Misc&lt;/code&gt; がコールバックモジュールの状態であると想定し、それを &lt;code&gt;StateFun&lt;/code&gt; に渡し、戻り値を新しい状態と &lt;code&gt;Misc&lt;/code&gt; の新しい値の両方として使用します。。</target>
        </trans-unit>
        <trans-unit id="6b0469d22f2398ad4902a9f0274d691cde96d200" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">コールバックモジュールがエクスポートした場合 &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; 機能を、それを使用して、その状態を置き換えるために、ターゲット・プロセスで呼び出され &lt;code&gt;StateFun&lt;/code&gt; を。その2つの引数は &lt;code&gt;StateFun&lt;/code&gt; 及び &lt;code&gt;Misc&lt;/code&gt; 、 &lt;code&gt;Misc&lt;/code&gt; 同じである &lt;code&gt;Misc&lt;/code&gt; によって返される値 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;system_replace_state/2&lt;/code&gt; 関数を返すことが期待されている &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; 、 &lt;code&gt;NewState&lt;/code&gt; には呼び出すことによって取得コールバックモジュールの新しい状態である &lt;code&gt;StateFun&lt;/code&gt; を、そして &lt;code&gt;NewMisc&lt;/code&gt; は元交換するために使用される可能性の新しい値である &lt;code&gt;Misc&lt;/code&gt; （として必要 &lt;code&gt;Misc&lt;/code&gt; は、コールバックモジュールの状態が含まれていることがよくあります）。</target>
        </trans-unit>
        <trans-unit id="22c3eecf9345190c4251d4199b67e06fe9f176a1" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">コールバックモジュールが関数 &lt;code&gt;system_get_state/1&lt;/code&gt; をエクスポートする場合、その状態を取得するためにターゲットプロセスで呼び出されます。その引数は &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; によって返される &lt;code&gt;Misc&lt;/code&gt; 値と同じで、関数 &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; はそこからコールバックモジュールの状態を抽出することが期待されています。関数 &lt;code&gt;system_get_state/1&lt;/code&gt; は &lt;code&gt;{ok, State}&lt;/code&gt; 返す必要があります。ここで、 &lt;code&gt;State&lt;/code&gt; はコールバックモジュールの状態です。</target>
        </trans-unit>
        <trans-unit id="01c2d9fbdbf4902fbd9ed598640b451a617bf5cc" translate="yes" xml:space="preserve">
          <source>If the callback module's &lt;code&gt;system_get_state/1&lt;/code&gt; function crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception.</source>
          <target state="translated">コールバックモジュールの &lt;code&gt;system_get_state/1&lt;/code&gt; 関数がクラッシュまたは例外をスローした場合、呼び出し元はエラー &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt; で終了します。ここで、 &lt;code&gt;Module&lt;/code&gt; はコールバックモジュールの名前、 &lt;code&gt;Class&lt;/code&gt; と &lt;code&gt;Reason&lt;/code&gt; は詳細を示します例外の。</target>
        </trans-unit>
        <trans-unit id="7986fc8d38f019b96fd636349aa5cfd63d9efc6a" translate="yes" xml:space="preserve">
          <source>If the callback module's function &lt;code&gt;system_replace_state/2&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception. If the callback module does not provide a &lt;code&gt;system_replace_state/2&lt;/code&gt; function and &lt;code&gt;StateFun&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt;.</source>
          <target state="translated">コールバックモジュールの関数 &lt;code&gt;system_replace_state/2&lt;/code&gt; がクラッシュまたは例外をスローした場合、呼び出し元はエラー &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt; で終了します。ここで、 &lt;code&gt;Module&lt;/code&gt; はコールバックモジュールの名前、 &lt;code&gt;Class&lt;/code&gt; と &lt;code&gt;Reason&lt;/code&gt; は詳細を示します例外の。コールバックモジュールが &lt;code&gt;system_replace_state/2&lt;/code&gt; 関数を提供せず、 &lt;code&gt;StateFun&lt;/code&gt; がクラッシュまたは例外をスローした場合、呼び出し元はエラー &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt; 終了します。</target>
        </trans-unit>
        <trans-unit id="f20f590333f587ce4f158c6bd3d9e3042df378fe" translate="yes" xml:space="preserve">
          <source>If the caller of the function wants to know whether or not acknowledgments are received for a certain notification (provided it is sent as an inform), the &lt;code&gt;Receiver&lt;/code&gt; parameter can be specified as &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (refer to the Reference Manual, section snmp, module &lt;code&gt;snmp&lt;/code&gt; for more details). In this case, the agent send a message &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; or &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; for each management target.</source>
          <target state="translated">関数の呼び出し元が特定の通知の確認応答を受信したかどうかを知りたい場合（通知として送信された場合）、 &lt;code&gt;Receiver&lt;/code&gt; パラメーターを &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; として指定できます（リファレンスマニュアルのセクションsnmpを参照） 、詳細についてはモジュール &lt;code&gt;snmp&lt;/code&gt; ）。この場合、エージェントは各管理ターゲットに対してメッセージ &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; または &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; を送信します。</target>
        </trans-unit>
        <trans-unit id="74d99e3904aef3995d136af596a2f043101aa1f9" translate="yes" xml:space="preserve">
          <source>If the calling process is not trapping exits, and checking &lt;code&gt;PidOrPort&lt;/code&gt; is cheap (that is, if &lt;code&gt;PidOrPort&lt;/code&gt; is local), &lt;code&gt;link/1&lt;/code&gt; fails with reason &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">呼び出しプロセスが出口をトラップしておらず、 &lt;code&gt;PidOrPort&lt;/code&gt; のチェックが安価である場合（つまり、 &lt;code&gt;PidOrPort&lt;/code&gt; がローカルの場合）、 &lt;code&gt;link/1&lt;/code&gt; は理由 &lt;code&gt;noproc&lt;/code&gt; で失敗します。</target>
        </trans-unit>
        <trans-unit id="49a8b4f21577fe3cc5ca8d0fd53bd3ee9424f7f7" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">呼び出しプロセスが後で &lt;code&gt;Reason&lt;/code&gt; で終了した場合、イベントマネージャーは、引数として &lt;code&gt;{stop,Reason}&lt;/code&gt; を指定して &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、イベントハンドラーを削除します。</target>
        </trans-unit>
        <trans-unit id="f41eb527b8f8f2ec9a45659469012def9325921e" translate="yes" xml:space="preserve">
          <source>If the capture options describe that no substring capturing is to be done (&lt;code&gt;{capture, none}&lt;/code&gt;), the function returns the single atom &lt;code&gt;match&lt;/code&gt; upon successful matching, otherwise the tuple &lt;code&gt;{match, ValueList}&lt;/code&gt;. Disabling capturing can be done either by specifying &lt;code&gt;none&lt;/code&gt; or an empty list as &lt;code&gt;ValueSpec&lt;/code&gt;.</source>
          <target state="translated">キャプチャーオプションで部分文字列のキャプチャーを行わないことを記述している場合（ &lt;code&gt;{capture, none}&lt;/code&gt; ）、関数は &lt;code&gt;match&lt;/code&gt; が成功すると単一の原子の一致を返し、そうでない場合はタプル &lt;code&gt;{match, ValueList}&lt;/code&gt; 返します。キャプチャを無効にするには、 &lt;code&gt;ValueSpec&lt;/code&gt; に &lt;code&gt;none&lt;/code&gt; または空のリストを指定します。</target>
        </trans-unit>
        <trans-unit id="8dfe9740232e522c9dccf1bcdb49e9bacfa76b87" translate="yes" xml:space="preserve">
          <source>If the carrier could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">システムの応答性を損なうことなくキャリアを完全にスキャンできなかった場合、 &lt;code&gt;UnscannedSize&lt;/code&gt; はスキップする必要があったバイト数です。</target>
        </trans-unit>
        <trans-unit id="b3d882b62bc462be24a22c4ebd1a0b80e4bbf23e" translate="yes" xml:space="preserve">
          <source>If the character escaping feature needs to be disabled (typically for backwards compatibility reasons), use the &lt;code&gt;ct_run&lt;/code&gt; start flag &lt;code&gt;-no_esc_chars&lt;/code&gt;, or the &lt;code&gt;ct:run_test/1&lt;/code&gt; start option &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (this start option is also supported in test specifications).</source>
          <target state="translated">文字エスケープ機能を無効にする必要がある場合（通常は下位互換性の理由から）、 &lt;code&gt;ct_run&lt;/code&gt; 開始フラグ &lt;code&gt;-no_esc_chars&lt;/code&gt; または &lt;code&gt;ct:run_test/1&lt;/code&gt; 開始オプション &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; （この開始オプションはテスト仕様でもサポートされています）。 。</target>
        </trans-unit>
        <trans-unit id="93733502359d2306f277753fcf5f39262e0db10b" translate="yes" xml:space="preserve">
          <source>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning and &lt;code&gt;restart_child/2&lt;/code&gt; cannot be used for these children.</source>
          <target state="translated">子が一時的なものである場合、子仕様はプロセスが終了するとすぐに削除されます。この手段 &lt;code&gt;delete_child/2&lt;/code&gt; は何の意味と持っていない &lt;code&gt;restart_child/2&lt;/code&gt; は、これらの子供たちのために使用することはできません。</target>
        </trans-unit>
        <trans-unit id="43bb63cf5661d4a237a06093eced5cd149d67b35" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">子プロセスが別の監視プログラムである場合、サブツリーにシャットダウンするのに十分な時間を与えるために、それは &lt;code&gt;infinity&lt;/code&gt; に設定されます。子プロセスがワーカーの場合は、 &lt;code&gt;infinity&lt;/code&gt; に設定することもできます。以下の警告をご覧ください。</target>
        </trans-unit>
        <trans-unit id="04ca616fb018a5f7ed9b1457ccf717eb545a0d6c" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">子プロセスが別のスーパーバイザの場合、サブツリーにシャットダウンする十分な時間を与えるために、シャットダウン時間は &lt;code&gt;infinity&lt;/code&gt; に設定されます。子プロセスがワーカーの場合は、 &lt;code&gt;infinity&lt;/code&gt; に設定することもできます。</target>
        </trans-unit>
        <trans-unit id="f6c8d2313d1867bff7ceabb992796a9dc2cb660e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the child specification is added to the supervisor (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, see below), the pid is set to &lt;code&gt;undefined&lt;/code&gt;, and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">子プロセスの開始関数が &lt;code&gt;ignore&lt;/code&gt; を返す場合、子の仕様がスーパーバイザーに追加され（スーパーバイザーが &lt;code&gt;simple_one_for_one&lt;/code&gt; スーパーバイザーでない限り、以下を参照）、pidが &lt;code&gt;undefined&lt;/code&gt; に設定され、関数は &lt;code&gt;{ok,undefined}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="5ef5502f7b080e1244d616694cf24b3ea2478505" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">子プロセスの開始関数が &lt;code&gt;ignore&lt;/code&gt; を返した場合、pidは &lt;code&gt;undefined&lt;/code&gt; に設定されたままで、関数は &lt;code&gt;{ok,undefined}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="2f7a47396e2013d77055f46cf69011c8dbc710aa" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the child specification and pid are added to the supervisor and the function returns the same value.</source>
          <target state="translated">子プロセスの開始関数が &lt;code&gt;{ok,Child}&lt;/code&gt; または &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 返す場合、子の仕様とpidがスーパーバイザーに追加され、関数は同じ値を返します。</target>
        </trans-unit>
        <trans-unit id="48c5d696f2b0fd45c1b44f5e625a2accf1b0ea21" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the pid is added to the supervisor and the function returns the same value.</source>
          <target state="translated">子プロセスの開始関数が &lt;code&gt;{ok,Child}&lt;/code&gt; または &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 返す場合、pidがスーパーバイザーに追加され、関数は同じ値を返します。</target>
        </trans-unit>
        <trans-unit id="6d773deb857a328ed14a9080339dfab940c8161a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">子プロセスのスタート機能は、エラータプルまたは誤った値を返し、または、それが失敗した場合、子仕様は破棄され、関数が戻る場合は &lt;code&gt;{error,Error}&lt;/code&gt; 、 &lt;code&gt;Error&lt;/code&gt; エラーと子仕様に関する用語を含む情報です。</target>
        </trans-unit>
        <trans-unit id="1b122e474c03f3cefc84e42bbf3408fd35e5bb5e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error.</source>
          <target state="translated">子プロセスの開始関数がエラータプルまたは誤った値を返す場合、または失敗した場合、関数は &lt;code&gt;{error,Error}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Error&lt;/code&gt; はエラーに関する情報を含む用語です。</target>
        </trans-unit>
        <trans-unit id="4b1288099957500451c193cb8d9ad26569f30036" translate="yes" xml:space="preserve">
          <source>If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification exists but the corresponding process is already running, the function returns &lt;code&gt;{error,running}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Id&lt;/code&gt; で識別される子仕様が存在しない場合、関数は &lt;code&gt;{error,not_found}&lt;/code&gt; 返します。子の仕様は存在するが、対応するプロセスがすでに実行されている場合、関数は &lt;code&gt;{error,running}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="cdb0f0cbc98dc7d94d6b59162ff7e5e589d60364" translate="yes" xml:space="preserve">
          <source>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</source>
          <target state="translated">クライアントがサーバがアドバタイズしたプロトコルのいずれもサポートしていない場合、またはサーバがいずれのプロトコルもアドバタイズしていない場合、クライアントはリストの最初のプロトコル、またはデフォルトプロトコル(デフォルトが提供されている場合)にフォールバックする。サーバが Next Protocol Negotiation をサポートしていない場合、デフォルトプロトコルが指定されていない場合、接続は終了します。</target>
        </trans-unit>
        <trans-unit id="1eacb16ee64844ecf9771b5e95710813db228ddf" translate="yes" xml:space="preserve">
          <source>If the client earlier has acquired a lock through &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt;, this operation releases the associated lock. To access another target than &lt;code&gt;running&lt;/code&gt;, the server must support &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">クライアントが以前に &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt; を介してロックを取得している場合、この操作は関連するロックを解放します。 &lt;code&gt;running&lt;/code&gt; 中以外のターゲットにアクセスするには、サーバーが &lt;code&gt;:candidate&lt;/code&gt; や &lt;code&gt;:startup&lt;/code&gt; をサポートしている必要があります。</target>
        </trans-unit>
        <trans-unit id="bc1ef493c0d6b60856faddf62e5c3f0669465abe" translate="yes" xml:space="preserve">
          <source>If the code cannot be structured as in the &lt;code&gt;multiple_setelement/1&lt;/code&gt; example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</source>
          <target state="translated">&lt;code&gt;multiple_setelement/1&lt;/code&gt; の例のようにコードを構造化できない場合、大きなタプルの複数の要素を変更する最良の方法は、タプルをリストに変換し、リストを変更して、それをタプルに戻すことです。</target>
        </trans-unit>
        <trans-unit id="f0b7ca0808d04f400f34111028c04d20133e9b2d" translate="yes" xml:space="preserve">
          <source>If the common event handler needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">共通イベントハンドラーが現在の状態を知る必要がある場合は、代わりに関数 &lt;code&gt;handle_common/4&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="ff5b1741be466acda153b10a36fc7487f2ca70d6" translate="yes" xml:space="preserve">
          <source>If the compiler is to warn for missing callback functions, as it does for the OTP behaviours, add &lt;code&gt;-callback&lt;/code&gt; attributes in the behaviour module to describe the expected callbacks:</source>
          <target state="translated">コンパイラーがOTP動作の場合と同様に、欠落しているコールバック関数について警告する場合は、動作モジュールに &lt;code&gt;-callback&lt;/code&gt; 属性を追加して、予期されるコールバックを記述します。</target>
        </trans-unit>
        <trans-unit id="523bb4f391597ed38f62115f28e3a49961855867" translate="yes" xml:space="preserve">
          <source>If the complete history is to be stored in the configuration file, &lt;code&gt;Config&lt;/code&gt; must be &lt;code&gt;all&lt;/code&gt;. If only a selected number of entries from the history are to be stored, &lt;code&gt;Config&lt;/code&gt; must be a list of integers pointing out the entries to be stored.</source>
          <target state="translated">完全な履歴を構成ファイルに保存する場合、 &lt;code&gt;Config&lt;/code&gt; は &lt;code&gt;all&lt;/code&gt; でなければなりません。履歴から選択した数のエントリのみを保存する場合、 &lt;code&gt;Config&lt;/code&gt; は、保存するエントリを指す整数のリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="21e0716b03f7aa9ffd13782b0d420ef9a664a3d2" translate="yes" xml:space="preserve">
          <source>If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:</source>
          <target state="translated">条件が上記の形式のいずれにもない場合は、アサーションでなければなりません。これは、正または負のルックヘッドまたはルックバックのアサーションになります。次のパターンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8a2fdb8b039278dbbab74f5b7bfb97af967770cd" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:</source>
          <target state="translated">条件が満たされていれば yes-pattern が使用され、そうでなければ no-pattern が使用される(存在する場合)。サブパターンに2つ以上の選択肢が存在する場合、コンパイル時エラーが発生します。2つの選択肢のそれぞれは、条件付きのサブパターンを含め、どんな形式の入れ子になったサブパターンを含むことができます;2つの選択肢への制限は、条件のレベルでのみ適用されます。以下のパターンの断片は、選択肢が複雑な場合の例です。</target>
        </trans-unit>
        <trans-unit id="fa304219623acf477a2744ed1bbab72da379738b" translate="yes" xml:space="preserve">
          <source>If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</source>
          <target state="translated">条件が文字列(DEFINE)であり、DEFINEという名前のサブパターンが存在しない場合、条件は常にFalseとなります。この場合、サブパターンには1つの選択肢しかありません。制御がパターンのこの点に達すると、常にスキップされます。DEFINEの考え方は、他の場所から参照できる「サブルーチン」を定義するのに使えるということです。(サブルーチンの使用法については後述します。)例えば、IPv4アドレスにマッチするパターン、例えば &quot;192.168.23.245 &quot;のように、次のように書くことができます(空白や改行は無視してください)。</target>
        </trans-unit>
        <trans-unit id="8e3f4e65a85b857108a35b24009e6fe7e2ac2084" translate="yes" xml:space="preserve">
          <source>If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:</source>
          <target state="translated">条件が文字列(R)であり、Rという名前のサブパターンが存在しない場合、パターン全体または任意のサブパターンへの再帰的呼び出しが行われた場合、条件は真となります。数字や名前の前にアンパサンドが付いている場合は、例えば、Rの後に文字が続きます。</target>
        </trans-unit>
        <trans-unit id="95c431a360008991bb1b7759c9f06391d6e75043" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, or if the initiation fails, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">構成に問題がある場合、または開始が失敗した場合、コールバック関数は &lt;code&gt;{error,Reason}&lt;/code&gt; 返す必要があります。</target>
        </trans-unit>
        <trans-unit id="18a294113eb6042d9ad2a36514917a6dc077c344" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">設定に誤りがある場合、コールバック関数は &lt;code&gt;{error,Reason}&lt;/code&gt; 返す必要があります。</target>
        </trans-unit>
        <trans-unit id="6a82e12e149afd95e3ddf1bb75d52a9982f828ca" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the same arguments as when &lt;code&gt;enable/2&lt;/code&gt; was called.</source>
          <target state="translated">構成パラメーター &lt;code&gt;os_sup_enable&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、この関数は、 &lt;code&gt;enable/2&lt;/code&gt; が呼び出されたときと同じ引数を使用して、 &lt;code&gt;os_sup&lt;/code&gt; によって自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="aedee7601f2ce3a18dc9a8c63054f54ca3093e3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the values of &lt;code&gt;os_sup_own&lt;/code&gt; and &lt;code&gt;os_sup_syslogconf&lt;/code&gt; as arguments.</source>
          <target state="translated">構成パラメーター &lt;code&gt;os_sup_enable&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、この関数は &lt;code&gt;os_sup_own&lt;/code&gt; および &lt;code&gt;os_sup_syslogconf&lt;/code&gt; の値を引数として使用して、 &lt;code&gt;os_sup&lt;/code&gt; によって自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b2ffcf1c22e3ce76143a4b07b440007a5df05ea7" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;relocatable&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt; there is no need to install the target system with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be started. In that case the file tree containing the target system can be moved without re-installation.</source>
          <target state="translated">設定パラメータの場合は &lt;code&gt;relocatable&lt;/code&gt; に設定された &lt;code&gt;true&lt;/code&gt; とターゲット・システムをインストールする必要はありません &lt;code&gt;reltool:install/2&lt;/code&gt; 、それを開始する前に。その場合、ターゲットシステムを含むファイルツリーは、再インストールせずに移動できます。</target>
        </trans-unit>
        <trans-unit id="90f42cb19285f317fb015c9fad2016cce36110ed" translate="yes" xml:space="preserve">
          <source>If the connection timeout option &lt;code&gt;connect_timeout&lt;/code&gt; is set, that value is used also for the negotiation timeout and this option (&lt;code&gt;timeout&lt;/code&gt;) is ignored.</source>
          <target state="translated">接続タイムアウトオプション &lt;code&gt;connect_timeout&lt;/code&gt; が設定されている場合、その値はネゴシエーションタイムアウトにも使用され、このオプション（ &lt;code&gt;timeout&lt;/code&gt; ）は無視されます。</target>
        </trans-unit>
        <trans-unit id="860a4598c1d1ec6a83570120e591b858d6e8f890" translate="yes" xml:space="preserve">
          <source>If the connection to a remote node goes down, the main node will mark it as lost. If the node comes back it will be added again. If the remote node was alive during the disconnected periode, cover data from before and during this periode will be included in the analysis.</source>
          <target state="translated">リモートノードへの接続がダウンした場合、メインノードはそれを紛失したものとしてマークします。ノードが復帰した場合は、再び追加されます。切断されたペリオデ中にリモートノードが生きていた場合、このペリオデの前後のカバーデータが解析に含まれます。</target>
        </trans-unit>
        <trans-unit id="c3b7535bf38d5e1053e0dcfad4dfa786c040f2e7" translate="yes" xml:space="preserve">
          <source>If the contents of &lt;code&gt;.erlang&lt;/code&gt; are changed and a private version of &lt;code&gt;user_default&lt;/code&gt; is defined, the Erlang/OTP environment can be customized. More powerful changes can be made by supplying command-line arguments in the startup script &lt;code&gt;erl&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.erlang&lt;/code&gt; の内容が変更され、プライベートバージョンの &lt;code&gt;user_default&lt;/code&gt; が定義されている場合、Erlang / OTP環境をカスタマイズできます。起動スクリプト &lt;code&gt;erl&lt;/code&gt; でコマンドライン引数を指定することにより、より強力な変更を行うことができます。詳細については、 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="6279554b0d57c5f26b8ffa794daeaf8c67036750" translate="yes" xml:space="preserve">
          <source>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the &lt;code&gt;909&lt;/code&gt;-prefix and lift/glob markers) ends in a &lt;code&gt;9&lt;/code&gt;, the integer will become an Erlang-level variable prefixed with &lt;code&gt;Q&lt;/code&gt;, and if it ends with &lt;code&gt;99&lt;/code&gt; it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</source>
          <target state="translated">コンテキストが変数、アトム、または文字列ではなく整数を必要とする場合、大文字の規則を使用して自動メタ変数をマークすることはできません。代わりに、整数（ &lt;code&gt;909&lt;/code&gt; プレフィックスとリフト/グロブマーカーなし）が &lt;code&gt;9&lt;/code&gt; で終わる場合、整数は &lt;code&gt;Q&lt;/code&gt; で始まるErlangレベルの変数になり、 &lt;code&gt;99&lt;/code&gt; で終わる場合も、自動的に抽象化されます。たとえば、次はエクスポートされた関数fのアリティをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="e14244783ffadbf99f1d872c65ba8477af77375e" translate="yes" xml:space="preserve">
          <source>If the converse of a function F is a function F', then F' is called the &lt;strong id=&quot;inverse&quot;&gt;inverse&lt;/strong&gt; of F.</source>
          <target state="translated">関数Fの逆が関数F 'である場合、F'はFの&lt;strong id=&quot;inverse&quot;&gt;逆&lt;/strong&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="04e1722c7eed1557956908ac595866c524c53815" translate="yes" xml:space="preserve">
          <source>If the cross compilation tools are prefixed by &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; you probably do not need to set these variables (where &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; is what has been passed as &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt;).</source>
          <target state="translated">クロスコンパイルツールの前に &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; が付いている場合、おそらくこれらの変数を設定する必要はありません（ &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; は &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 引数として &lt;code&gt;configure&lt;/code&gt; に渡されたものです）。</target>
        </trans-unit>
        <trans-unit id="693638c468a0a688aceae31ef9d5b589f67e3d3d" translate="yes" xml:space="preserve">
          <source>If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag &lt;code&gt;error&lt;/code&gt;, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;.</source>
          <target state="translated">リスト内のUnicode / ISO Latin-1文字が正しくないため、またはバイナリのUTFエンコードが無効であるためにデータを変換できない場合、エラータプルが返されます。エラータプルには、タグ &lt;code&gt;error&lt;/code&gt; 、エラーが発生する前に変換された可能性のある文字を表すリスト、および問題の整数/バイトを含む文字とその後の文字の表現が含まれています。最後の部分は、おそらく元のデータと同じ深さである必要はなく、おそらく深いリストまたは混合リスト、あるいはその両方を構成するため、ほとんどがデバッグ用です。このエラーは、リストをトラバースするときに発生し、デコードされずに残っているものはすべて「そのまま」返されます。</target>
        </trans-unit>
        <trans-unit id="830c19e2812b5ad638344d6692b4a5d1c14189d2" translate="yes" xml:space="preserve">
          <source>If the data in the table is to be accessed so that the order of the keys in the table is significant, the table type &lt;code&gt;ordered_set&lt;/code&gt; can be used instead of the more usual &lt;code&gt;set&lt;/code&gt; table type. An &lt;code&gt;ordered_set&lt;/code&gt; is always traversed in Erlang term order regarding the key field so that the return values from functions such as &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;match_object&lt;/code&gt;, and &lt;code&gt;foldl&lt;/code&gt; are ordered by the key values. Traversing an &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; operations also returns the keys ordered.</source>
          <target state="translated">テーブル内のデータにアクセスして、テーブル内のキーの順序が重要になる場合は、通常の &lt;code&gt;set&lt;/code&gt; テーブルタイプの代わりにテーブルタイプ &lt;code&gt;ordered_set&lt;/code&gt; を使用できます。 &lt;code&gt;ordered_set&lt;/code&gt; は、いつものような関数からの戻り値をそのキーフィールドに関するErlangの項順序にトラバースされる &lt;code&gt;select&lt;/code&gt; 、 &lt;code&gt;match_object&lt;/code&gt; 、および &lt;code&gt;foldl&lt;/code&gt; のは、キー値によって順序付けられます。 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; 操作で &lt;code&gt;ordered_set&lt;/code&gt; をトラバースすると、順序付けされたキーも返されます。</target>
        </trans-unit>
        <trans-unit id="c7cef7dde804ec38da41a38a959068e58669e710" translate="yes" xml:space="preserve">
          <source>If the data is to be sent from the driver to the port owner process, it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">データがドライバーからポート所有者プロセスに送信される場合は、 &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt; を使用する方が高速です。</target>
        </trans-unit>
        <trans-unit id="d69f0718531a0dc4b5192097fe34a9a400874115" translate="yes" xml:space="preserve">
          <source>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</source>
          <target state="translated">データベースが巨大な場合、オンラインで復元できるとは限りません。そのような場合は、フォールバックをインストールして古いデータベースを復元してから再起動してください。</target>
        </trans-unit>
        <trans-unit id="1a465de33f0929289f4ba867f52979d6f1b60be6" translate="yes" xml:space="preserve">
          <source>If the decoded message happens to be received before the connection is established, a new &quot;virtual&quot; connection is established. This is typically the case for the Media Gateway Controller (MGC) upon the first Service Change. When this occurs the following callback function will be invoked:</source>
          <target state="translated">接続が確立される前にデコードされたメッセージを受信した場合、新しい「仮想」接続が確立されます。これは通常、最初のサービス変更時にメディアゲートウェイコントローラ(MGC)で発生します。この場合、以下のコールバック関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fbdce8830ddb42e0e285519e4fb52411ce2090fe" translate="yes" xml:space="preserve">
          <source>If the decoded message instead of transactions contains a message error, the following callback function will be invoked:</source>
          <target state="translated">トランザクションではなくデコードされたメッセージにメッセージエラーが含まれている場合は、以下のコールバック関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e05877711912cb7abc7753f9ce969b4440e6bb55" translate="yes" xml:space="preserve">
          <source>If the definitions are identical, the output module keeps only one definition with the original name.</source>
          <target state="translated">定義が同一の場合、出力モジュールは元の名前で1つの定義だけを保持します。</target>
        </trans-unit>
        <trans-unit id="709eb064721592f0145e0c9870df4b79e36f2fb2" translate="yes" xml:space="preserve">
          <source>If the definitions have the same name and differs in the definition, they are renamed. The new names are the definition name and the original module name concatenated.</source>
          <target state="translated">定義が同じ名前で、定義が異なる場合は名前を変更します。新しい名前は、定義名と元のモジュール名を連結したものです。</target>
        </trans-unit>
        <trans-unit id="c3055c07c7bca6e36c452534d5a6de3daec9136a" translate="yes" xml:space="preserve">
          <source>If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.</source>
          <target state="translated">削除されたエントリが登録されたサブスクライバである場合、サブスクライバプロセスが最終メッセージを取得すると同時に、サブスクライバとして登録されていないことを意味する。</target>
        </trans-unit>
        <trans-unit id="818e5bafa76101bf732fc51de14593ea48da629f" translate="yes" xml:space="preserve">
          <source>If the destination node would have to be auto-connected to do the send, &lt;code&gt;noconnect&lt;/code&gt; is returned instead.</source>
          <target state="translated">送信を行うために宛先ノードを自動接続する必要がある &lt;code&gt;noconnect&lt;/code&gt; は、代わりにnoconnectが返されます。</target>
        </trans-unit>
        <trans-unit id="fa49b96a6e23a80a21210ac903528ecee8169a93" translate="yes" xml:space="preserve">
          <source>If the directory for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is &lt;code&gt;/etc&lt;/code&gt;, the line in &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;syslog.conf.ORIG&lt;/code&gt; および &lt;code&gt;syslog.conf.OTP&lt;/code&gt; ファイルのディレクトリが &lt;code&gt;/etc&lt;/code&gt; の場合、 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; の行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1cfa13bd96270a398f97e146ebd653c8f1622e36" translate="yes" xml:space="preserve">
          <source>If the directory is not found</source>
          <target state="translated">ディレクトリが見つからない場合</target>
        </trans-unit>
        <trans-unit id="ee9c7c20028055c752f1006405fb6ac3dd62c654" translate="yes" xml:space="preserve">
          <source>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; is in the path, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</source>
          <target state="translated">ディレクトリがアーカイブ内のディレクトリを参照している場合、パスが返される前にアーカイブ名が削除されます。たとえば、ディレクトリ &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; がパスにある場合、/ &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; 返されます。つまり、アプリケーションがアーカイブに存在するかどうかに関係なく、アプリケーションのライブラリディレクトリは同じです。</target>
        </trans-unit>
        <trans-unit id="f85643a441c622fdd2576beffc4873deda4e4256" translate="yes" xml:space="preserve">
          <source>If the dirty NIF is expected to be CPU-bound, its &lt;code&gt;flags&lt;/code&gt; field is to be set to &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt;.</source>
          <target state="translated">ダーティNIFがCPUにバインドされていると予想される場合、その &lt;code&gt;flags&lt;/code&gt; フィールドは &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; または &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="9c2ddfd812a9a461d82c50bcdf565e3ca018a4da" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">ドライバーが何らかの理由でドライバーのバイナリを静的変数などに保持したい場合は、参照カウントをインクリメントし、後で &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; コールバックで &lt;code&gt;driver_free_binary&lt;/code&gt; を使用してバイナリを解放できます。</target>
        </trans-unit>
        <trans-unit id="a12df4e4fa0309d2f4f4f74b51f81225f4bdeeaf" translate="yes" xml:space="preserve">
          <source>If the driver has option &lt;code&gt;kill_ports&lt;/code&gt; set, or if &lt;code&gt;kill_ports&lt;/code&gt; is specified as an option to this function, all pending ports using this driver are killed when unloading is done by the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. If no port-killing is involved and there are open ports, the unloading is delayed until no more open ports use the driver. If, in this case, another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (or even this user) loads the driver again before the driver is unloaded, the unloading never takes place.</source>
          <target state="translated">ドライバーにオプション &lt;code&gt;kill_ports&lt;/code&gt; が設定されている場合、またはこの関数のオプションとして &lt;code&gt;kill_ports&lt;/code&gt; が指定されている場合、最後の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; がアンロードを実行すると、このドライバーを使用する保留中のすべてのポートが強制終了されます。ポートキリングが行われておらず、開いているポートがある場合、開いているポートがドライバを使用しなくなるまで、アンロードは遅延されます。この場合、別の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; （またはこのユーザー）がドライバーをアンロードする前に再度ロードすると、アンロードは行われません。</target>
        </trans-unit>
        <trans-unit id="fcf785a336b2c213c45577e83eb09e396c7e3eab" translate="yes" xml:space="preserve">
          <source>If the driver is unloaded (not present in the system), error code &lt;code&gt;not_loaded&lt;/code&gt; is returned. Option &lt;code&gt;reload&lt;/code&gt; is intended for when the user has already loaded the driver in advance.</source>
          <target state="translated">ドライバがアンロードされている（システムに存在しない）場合、エラーコード &lt;code&gt;not_loaded&lt;/code&gt; が返されます。オプションの &lt;code&gt;reload&lt;/code&gt; は、ユーザーが事前にドライバーを既にロードしている場合を対象としています。</target>
        </trans-unit>
        <trans-unit id="af3e2b2e4d5d486f038ae4047d709485c51ebafd" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ドライバがデータを返したい場合は、それを &lt;code&gt;rbuf&lt;/code&gt; で返します。場合 &lt;code&gt;control&lt;/code&gt; 、と呼ばれる &lt;code&gt;*rbuf&lt;/code&gt; デフォルトのバッファにポイント &lt;code&gt;rlen&lt;/code&gt; データを返すために使用することができるバイト。データは、ポート制御フラグ（ &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; で設定されるもの）に応じて異なる方法で返されます。</target>
        </trans-unit>
        <trans-unit id="f299a698f91b18144d2db6873d22e3355371e343" translate="yes" xml:space="preserve">
          <source>If the driver was previously unloaded, but is still present because of open ports to it, a call to &lt;code&gt;load/2&lt;/code&gt; stops the unloading and keeps the driver (as long as &lt;code&gt;Path&lt;/code&gt; is the same), and &lt;code&gt;ok&lt;/code&gt; is returned. If you really want the object code to be reloaded, use &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; or the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead. See also the description of &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; for loading/unloading in the introduction.</source>
          <target state="translated">ドライバーが以前にアンロードされたが、ポートが開いているためにまだ存在する場合、 &lt;code&gt;load/2&lt;/code&gt; の呼び出しによりアンロードが停止され、（ &lt;code&gt;Path&lt;/code&gt; が同じである限り）ドライバーが保持され、 &lt;code&gt;ok&lt;/code&gt; が返されます。本当にオブジェクトコードを &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; 場合は、代わりにreload / 2または低レベルインターフェイス &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; を使用してください。概要のロード/アンロードの &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; の説明も参照してください。</target>
        </trans-unit>
        <trans-unit id="73cd90e7e567fcfaa60abf0aba49564831915adf" translate="yes" xml:space="preserve">
          <source>If the edge would create a cycle in an &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; is returned. If &lt;code&gt;G&lt;/code&gt; already has an edge with value &lt;code&gt;E&lt;/code&gt; connecting a different pair of vertices, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; is returned. If either of &lt;code&gt;V1&lt;/code&gt; or &lt;code&gt;V2&lt;/code&gt; is not a vertex of digraph &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt;V&lt;code&gt;}}&lt;/code&gt; is returned, V = &lt;code&gt;V1&lt;/code&gt; or V = &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">エッジが &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt; で循環を作成する場合、 &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; が返されます。 &lt;code&gt;G&lt;/code&gt; に別の頂点のペアを接続する値 &lt;code&gt;E&lt;/code&gt; のエッジが既にある場合、 &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; が返されます。 &lt;code&gt;V1&lt;/code&gt; または &lt;code&gt;V2&lt;/code&gt; のいずれかがダイグラフ &lt;code&gt;G&lt;/code&gt; の頂点でない場合、 &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt; V &lt;code&gt;}}&lt;/code&gt; が返されます。V= &lt;code&gt;V1&lt;/code&gt; またはV = &lt;code&gt;V2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="88548b0769c08599153c91bedffecba4076939a2" translate="yes" xml:space="preserve">
          <source>If the emulator detects an internal error (or runs out of memory), it, by default, generates both a crash dump and a core dump. The core dump is, however, not very useful as the content of process heaps is destroyed by the crash dump generation.</source>
          <target state="translated">エミュレータが内部エラーを検出した場合(またはメモリ不足に陥った場合)、デフォルトではクラッシュダンプとコアダンプの両方を生成します。しかし、プロセスヒープの内容はクラッシュダンプの生成によって破壊されてしまうので、コアダンプはあまり有用ではありません。</target>
        </trans-unit>
        <trans-unit id="1c268e0a4f924dc7fcacea261eaf98d33a0b39dd" translate="yes" xml:space="preserve">
          <source>If the emulator needs to be restarted after upgrading or downgrading, that is, if the ERTS version differs between &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">アップグレードまたはダウングレード後にエミュレータを再起動する必要がある場合、つまり、ERTSバージョンが &lt;code&gt;Name.rel&lt;/code&gt; と &lt;code&gt;Name2.rel&lt;/code&gt; で異なる場合</target>
        </trans-unit>
        <trans-unit id="0e5cf3cf162417b51e0a5af24e5040b612349b1b" translate="yes" xml:space="preserve">
          <source>If the emulator needs to write a crash dump, the value of this variable is the filename of the crash dump file. If the variable is not set, the name of the crash dump file is &lt;code&gt;erl_crash.dump&lt;/code&gt; in the current directory.</source>
          <target state="translated">エミュレータがクラッシュダンプを書き込む必要がある場合、この変数の値はクラッシュダンプファイルのファイル名です。変数が設定されていない場合、クラッシュダンプファイルの名前は現在のディレクトリの &lt;code&gt;erl_crash.dump&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="40c61683ad15fa177c304fbdf476f8b2479cdc64" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt; をサポートするようにエミュレータが構築されている場合、オンラインでスケジューラの数を変更すると、オンラインでダーティCPUスケジューラの数も変更される可能性があります。たとえば、12個のスケジューラと6個のダーティCPUスケジューラがオンラインで、 &lt;code&gt;system_flag/2&lt;/code&gt; を使用してオンラインのスケジューラ数を6に設定すると、オンラインのダーティCPUスケジューラの数も自動的に半分に減り、3になります。同様に、オンラインのダーティCPUスケジューラの数は、オンラインのスケジューラの数の増加に比例して増加します。</target>
        </trans-unit>
        <trans-unit id="b9353bd702a35793ac18305b8482171f21007231" translate="yes" xml:space="preserve">
          <source>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</source>
          <target state="translated">パターンの終了に到達した場合は、一致が成功し、変数の内容を取得することができます。</target>
        </trans-unit>
        <trans-unit id="ec86b8e10359d9eb0c69eab5270c60f057cce319" translate="yes" xml:space="preserve">
          <source>If the engine is located in the OpenSSL/LibreSSL installation &lt;code&gt;engines&lt;/code&gt; directory.</source>
          <target state="translated">エンジンがOpenSSL / LibreSSLインストール &lt;code&gt;engines&lt;/code&gt; ディレクトリにある場合。</target>
        </trans-unit>
        <trans-unit id="17edef4a35e3cca0ca8935fe0f2de48f9e5dfe47" translate="yes" xml:space="preserve">
          <source>If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.</source>
          <target state="translated">エントリが新しいサブスクライバの場合、新しいサブスクライバプロセスは、それとすべての古いサブスクライバが この特定のエントリを取得する前に、すでに格納されているディクショナリエントリごとに 1 つのメッセージを最初に取得することを意味する。コレクタープロセスは、サブスクライバプロセスにリンクしてから監視する。サブスクライバプロセスが終了した場合、通常の dict_delete/2 と同様に登録解除されることを意味する。</target>
        </trans-unit>
        <trans-unit id="a094e54489c949e55e10b1bfd099675a9945d8d2" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">&lt;code&gt;Exprs&lt;/code&gt; の評価が例外なく成功すると、パターン &lt;code&gt;Pattern&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; 式の場合と同じ方法で結果に対して順次照合されますが、照合が失敗した場合は、 &lt;code&gt;try_clause&lt;/code&gt; ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="631031b9e342940aba31e2236569e617b51e7128" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">イベントハンドラが原因への呼び出しを追加した場合 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;InitArgs&lt;/code&gt; がある &lt;code&gt;Args&lt;/code&gt; のこれらの関数の引数。</target>
        </trans-unit>
        <trans-unit id="3160cb662d43645579ff66ccf206017473a57cb3" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">イベントハンドラがあるために、コールの削除された場合 &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;Arg&lt;/code&gt; がある &lt;code&gt;Args&lt;/code&gt; この関数呼び出しの引数。</target>
        </trans-unit>
        <trans-unit id="89ab1aecc97fe6f0f9ffea8f0aa54544b441d79d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted later, the event manager sends a message &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; to the calling process. &lt;code&gt;Reason&lt;/code&gt; is one of the following:</source>
          <target state="translated">イベントハンドラーが後で削除された場合、イベントマネージャーはメッセージ &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; を呼び出しプロセスに送信します。 &lt;code&gt;Reason&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="b6a4d7864917b404d52d14fae5596ac8786e5389" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">イベントハンドラが原因の呼び出しの別のイベントハンドラを置き換える場合 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 又は &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 、又はための &lt;code&gt;swap&lt;/code&gt; 他のコールバック関数のいずれかからの戻りタプルは、 &lt;code&gt;InitArgs&lt;/code&gt; があるタプル &lt;code&gt;{Args,Term}&lt;/code&gt; 、ここで、 &lt;code&gt;Args&lt;/code&gt; あります関数呼び出し/戻りタプルで提供される引数と &lt;code&gt;Term&lt;/code&gt; は、古いイベントハンドラーの終了の結果です &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="bd74a922c6e5b981bbc80b4da38fda2c75c0b1ea" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. It however detects this state and loses no records that are not overwritten.</source>
          <target state="translated">イベントログが自動的に &lt;code&gt;nteventlog&lt;/code&gt; ように構成されている場合、ログに到着し、nteventlogが実行されていなかったときに上書きされたレコードは失われます。ただし、この状態を検出し、上書きされていないレコードを失うことはありません。</target>
        </trans-unit>
        <trans-unit id="1781a9137364e9b0633c2b37fb076419c90678b9" translate="yes" xml:space="preserve">
          <source>If the event manager is part of a supervision tree, no stop function is needed. The event manager is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">イベントマネージャが監視ツリーの一部である場合、停止機能は必要ありません。イベントマネージャは、そのスーパーバイザによって自動的に終了されます。これがどのように行われるかは、スーパーバイザに設定された &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; によって正確に定義されます。</target>
        </trans-unit>
        <trans-unit id="23a26a698f7576e3a5781ee1ace5ea565efded8a" translate="yes" xml:space="preserve">
          <source>If the event manager is successfully created, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the event manager. If a process with the specified &lt;code&gt;EventMgrName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">イベントマネージャが正常に作成されると、関数は &lt;code&gt;{ok,Pid}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はイベントマネージャのpidです。指定された &lt;code&gt;EventMgrName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="85c7349696150a1895889e8faf7c4713894d022f" translate="yes" xml:space="preserve">
          <source>If the exclusive decode function has, for example, the name &lt;code&gt;decode_exclusive&lt;/code&gt; and an ASN.1 encoded message &lt;code&gt;Bin&lt;/code&gt; is to be exclusive decoded, the call is as follows:</source>
          <target state="translated">たとえば、排他的なデコード関数の名前が &lt;code&gt;decode_exclusive&lt;/code&gt; で、ASN.1でエンコードされたメッセージ &lt;code&gt;Bin&lt;/code&gt; を排他的にデコードする場合、呼び出しは次のようになります。</target>
        </trans-unit>
        <trans-unit id="03f0f3b2eabafa60c9e9c721aa1cad9fcc5b78a3" translate="yes" xml:space="preserve">
          <source>If the failed test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">失敗したテストケースがテストケースグループに属している場合、最初の引数はタプル &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; です。それ以外の場合は、関数名のみです。</target>
        </trans-unit>
        <trans-unit id="ae5596ad95475cf2f268aa093acd0a50a12f5551" translate="yes" xml:space="preserve">
          <source>If the file contains source code (as in the example above), it is processed by the &lt;code&gt;epp&lt;/code&gt; preprocessor. This means that you, for example, can use predefined macros (such as &lt;code&gt;?MODULE&lt;/code&gt;) and include directives like the &lt;code&gt;-include_lib&lt;/code&gt; directive. For example, use</source>
          <target state="translated">（上記の例のように）ファイルにソースコードが含まれている場合、そのファイルは &lt;code&gt;epp&lt;/code&gt; プリプロセッサによって処理されます。つまり、たとえば、事前定義されたマクロ（ &lt;code&gt;?MODULE&lt;/code&gt; など）を使用して、 &lt;code&gt;-include_lib&lt;/code&gt; ディレクティブなどのディレクティブを含めることができます。たとえば、</target>
        </trans-unit>
        <trans-unit id="09f7b5f0081b8333cb37ae76ae1513548332cd8c" translate="yes" xml:space="preserve">
          <source>If the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</source>
          <target state="translated">ファイルがバイナリモードで開かれている場合、読み込まれたバイトはバイナリで返され、そうでない場合はリストで返されます。</target>
        </trans-unit>
        <trans-unit id="d43d376c036cd6704fab6602e0a821d2fca0f536" translate="yes" xml:space="preserve">
          <source>If the file is opened with &lt;code&gt;encoding&lt;/code&gt; set to something else than &lt;code&gt;latin1&lt;/code&gt;, each byte written can result in many bytes being written to the file, as the byte range 0..255 can represent anything between one and four bytes depending on value and UTF encoding type.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; &lt;code&gt;latin1&lt;/code&gt; 以外に設定してファイルを開いた場合、バイト範囲0..255は値とUTFエンコーディングに応じて1〜4バイトを表すことができるため、書き込まれる各バイトは多くのバイトをファイルに書き込む可能性があります。タイプ。</target>
        </trans-unit>
        <trans-unit id="3ff2942f4038fb71563badd19ea96ee04bc36590" translate="yes" xml:space="preserve">
          <source>If the file is read past &lt;code&gt;eof&lt;/code&gt;, only the remaining bytes are read and returned. If no bytes are read, &lt;code&gt;eof&lt;/code&gt; is returned.</source>
          <target state="translated">ファイルが &lt;code&gt;eof&lt;/code&gt; を超えて読み取られた場合、残りのバイトのみが読み取られて返されます。バイトが読み込まれない場合は、 &lt;code&gt;eof&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="0301143503899c06f595e73d4da8e12a605f082d" translate="yes" xml:space="preserve">
          <source>If the file is specified as an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, no file is read or monitored in the future. This emulates the old behavior of not configuring the DNS client when the node is started in short name distributed mode.</source>
          <target state="translated">ファイルが空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; として指定されている場合、今後ファイルの読み取りや監視は行われません。これは、ノードが短い名前の分散モードで起動されたときにDNSクライアントを構成しないという古い動作をエミュレートします。</target>
        </trans-unit>
        <trans-unit id="f524572ea2342154f69f71b644500e15cc9901dc" translate="yes" xml:space="preserve">
          <source>If the file server of this node is not a slave, the file was opened by the file server of this node (this implies that &lt;code&gt;Pid&lt;/code&gt; must be a local pid) and the file is not closed. &lt;code&gt;Filename&lt;/code&gt; is the filename in flat string format.</source>
          <target state="translated">このノードのファイルサーバーがスレーブでない場合、ファイルはこのノードのファイルサーバーによって開かれ（ &lt;code&gt;Pid&lt;/code&gt; はローカルpidでなければならないことを意味します）、ファイルは閉じられません。 &lt;code&gt;Filename&lt;/code&gt; は、フラットストリング形式のファイル名です。</target>
        </trans-unit>
        <trans-unit id="19dad8b9ff6393c913546c9bff544a5e8d858493" translate="yes" xml:space="preserve">
          <source>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary is shorter than the number of bytes requested if end of file was reached.</source>
          <target state="translated">ファイルがバイナリモードで開かれている場合、読み込んだバイトはバイナリで返され、そうでない場合はリストで返されます。ファイルの終端に達した場合、リストまたはバイナリは要求されたバイト数よりも短くなります。</target>
        </trans-unit>
        <trans-unit id="ead416d9e5e17b9f14938d13eb799b54c7ee7032" translate="yes" xml:space="preserve">
          <source>If the file write fails (for example, &lt;code&gt;enospc&lt;/code&gt;), the command is aborted and &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; is returned. However, the file is &lt;strong&gt;not&lt;/strong&gt; removed.</source>
          <target state="translated">ファイルの書き込みが失敗した場合（ &lt;code&gt;enospc&lt;/code&gt; など）、コマンドは中止され、 &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; が返されます。ただし、ファイルは削除され&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3f0c09a69dc8ebf1e91578b9796f029369abc850" translate="yes" xml:space="preserve">
          <source>If the filename &lt;code&gt;File&lt;/code&gt; is absolute (possibly after variable substitution), the include file with that name is included. Otherwise, the specified file is searched for in the following directories, and in this order:</source>
          <target state="translated">ファイル名 &lt;code&gt;File&lt;/code&gt; が絶対変数の場合（おそらく変数置換後）、その名前のインクルードファイルが含まれます。それ以外の場合は、指定されたファイルが次のディレクトリでこの順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="f6fdb5791718e9cf14d2a9c0a809646872e636fd" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, decide if the event is allowed or not.</source>
          <target state="translated">フィルターが一致しない場合は、 &lt;code&gt;ignore&lt;/code&gt; を返します。つまり、他のフィルター、または構成パラメーター &lt;code&gt;filter_default&lt;/code&gt; の値が、イベントを許可するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="298fc01aae2302d31a30ab2828690b737a94df8b" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, will decide if the event is allowed or not.</source>
          <target state="translated">フィルターが一致しない場合は、 &lt;code&gt;ignore&lt;/code&gt; を返します。つまり、他のフィルター、または構成パラメーター &lt;code&gt;filter_default&lt;/code&gt; の値が、イベントを許可するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="3e713bc836d6d924cbd200c2e55ce5f9136754b5" translate="yes" xml:space="preserve">
          <source>If the filter function returns &lt;code&gt;ignore&lt;/code&gt;, it means that it did not recognize the log event, and thus leaves to other filters to decide the event's destiny.</source>
          <target state="translated">フィルター関数が &lt;code&gt;ignore&lt;/code&gt; を返す場合、それはログイベントを認識しなかったので、他のフィルターに任せてイベントの運命を決定します。</target>
        </trans-unit>
        <trans-unit id="957041343c23aa2d4654805ac48c48dc4fb915f8" translate="yes" xml:space="preserve">
          <source>If the filter has the form &lt;code&gt;{Key, RegExp, re}&lt;/code&gt;, the report must contain an element with key equal to &lt;code&gt;Key&lt;/code&gt; and the value must match the regular expression &lt;code&gt;RegExp&lt;/code&gt;.</source>
          <target state="translated">フィルターの形式が &lt;code&gt;{Key, RegExp, re}&lt;/code&gt; 場合、レポートには &lt;code&gt;Key&lt;/code&gt; と等しいキーを持つ要素が含まれている必要があり、値は正規表現 &lt;code&gt;RegExp&lt;/code&gt; と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e1184361ce4e087a6b4dd8211b45d80ed4f9e48" translate="yes" xml:space="preserve">
          <source>If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the log event is allowed. If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the log event is stopped.</source>
          <target state="translated">フィルターが一致し、 &lt;code&gt;Action&lt;/code&gt; が &lt;code&gt;log&lt;/code&gt; の場合、ログイベントが許可されます。フィルターが一致し、 &lt;code&gt;Action&lt;/code&gt; が &lt;code&gt;stop&lt;/code&gt; の場合、ログイベントは停止されます。</target>
        </trans-unit>
        <trans-unit id="32e9da768719e8b90b1faba156fc380cf35dffea" translate="yes" xml:space="preserve">
          <source>If the final string is too long, it is truncated according to the value of configuration parameter &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最終的な文字列が長すぎる場合は、構成パラメーター &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; の値に従って切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="f6ebf0a745164970b389f3300cbccd27f4b3b5d3" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">フラグが &lt;code&gt;0&lt;/code&gt; に設定されている場合、データは整数のリストとして返されます。デフォルトのバッファーを使用するか、 &lt;code&gt;*rbuf&lt;/code&gt; を設定して &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; で割り当てられたより大きなバッファーを指すようにします。 &lt;code&gt;control&lt;/code&gt; が戻ると、バッファーは自動的に解放されます。</target>
        </trans-unit>
        <trans-unit id="3fdf06cbeca702cf9635bd5a2282dbe52c9f9489" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">フラグが &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; に設定されている場合、バイナリが返されます。生データをデフォルトのバッファに書き込むことにより、小さなバイナリを返すことができます。 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; で割り当てられたバイナリを指すように &lt;code&gt;*rbuf&lt;/code&gt; を設定することにより、バイナリを返すこともできます。このバイナリは、 &lt;code&gt;control&lt;/code&gt; が戻ると自動的に解放されます。ドライバーは、 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; を使用して&lt;strong&gt;読み取り専用&lt;/strong&gt;アクセス用のバイナリーを保持し、後でerl_driver：driver_free_binaryを使用して解放 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; ます。 &lt;code&gt;control&lt;/code&gt; が戻った後は、バイナリを変更することはできません。 &lt;code&gt;*rbuf&lt;/code&gt; が &lt;code&gt;NULL&lt;/code&gt; に設定されている場合&lt;strong&gt;&lt;/strong&gt;、空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="ba4d8831063581aeb6c792a1b032f97e23a799b0" translate="yes" xml:space="preserve">
          <source>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</source>
          <target state="translated">&quot;a &quot;や &quot;b &quot;で始まらない文字列に以下のパターンを適用した場合、通常は件名の先頭にある空の文字列と一致します。</target>
        </trans-unit>
        <trans-unit id="2009a1faa40085a7c2fd996ec540bc12d65d8f07" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">フォーマッタモジュールがオプションのコールバック関数 &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt; をエクスポートする場合、フォーマッタ情報が設定または変更されたときにLoggerがこの関数を呼び出し、フォーマッタ構成の有効性を確認します。</target>
        </trans-unit>
        <trans-unit id="05f7a6a810b002e4a0681949501258c2a927f78c" translate="yes" xml:space="preserve">
          <source>If the fragment option is &lt;code&gt;true&lt;/code&gt;, the URI fragment is returned as part of the parsing result, otherwise it is ignored.</source>
          <target state="translated">フラグメントオプションが &lt;code&gt;true&lt;/code&gt; の場合、URIフラグメントは解析結果の一部として返されます。それ以外の場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="a9f39219b3544f3ad6a57e7c4b45e2e83b08a49c" translate="yes" xml:space="preserve">
          <source>If the fully connected network is not set up properly, try first to increase the value of &lt;code&gt;net_setuptime&lt;/code&gt;.</source>
          <target state="translated">完全に接続されたネットワークが正しく設定されていない場合は、 &lt;code&gt;net_setuptime&lt;/code&gt; の値を増やしてみてください。</target>
        </trans-unit>
        <trans-unit id="e9be0c3ab255377067e7c9ca15639a8fa64c8dbb" translate="yes" xml:space="preserve">
          <source>If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">fun/3が使用されている場合、実際の認証が発生した時に呼び出され、時間やリモートIPなどの動的なデータを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="a10d9917bf561ed6546055b4ad6ae668ede9a486" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;mnesia:table_info/2&lt;/code&gt; is started in the activity context of module &lt;code&gt;mnesia_frag&lt;/code&gt;, information of several new items can be obtained:</source>
          <target state="translated">関数 &lt;code&gt;mnesia:table_info/2&lt;/code&gt; がモジュール &lt;code&gt;mnesia_frag&lt;/code&gt; のアクティビティコンテキストで開始されると、いくつかの新しいアイテムの情報を取得できます：</target>
        </trans-unit>
        <trans-unit id="b7b2e6d233f123be817d60a836703d289792c0af" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;print_name/1&lt;/code&gt;, and so on, had been interface functions, the situation would have been different, as you do not want the user of the interface to know about the internal data representation.</source>
          <target state="translated">関数 &lt;code&gt;print_name/1&lt;/code&gt; などがインターフェイス関数であった場合、インターフェイスのユーザーに内部データ表現について知らせたくないため、状況は異なります。</target>
        </trans-unit>
        <trans-unit id="ac91618962c7d06d3c9f00caac895bd89a410ca3" translate="yes" xml:space="preserve">
          <source>If the function is called, it will be called again with &lt;code&gt;undo&lt;/code&gt;, or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">関数が呼び出されると、 &lt;code&gt;undo&lt;/code&gt; または最初の引数として &lt;code&gt;set&lt;/code&gt; を使用して、再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="40c262c2c2a844d0cf26a7433449f15feea3fd0e" translate="yes" xml:space="preserve">
          <source>If the function is found, the function clauses are scanned sequentially until a clause is found that fulfills both of the following two conditions:</source>
          <target state="translated">関数が見つかった場合は、以下の2つの条件の両方を満たす節が見つかるまで、関数節を順次スキャンしていきます。</target>
        </trans-unit>
        <trans-unit id="c5c83cab902e2b61262a72c526eeaa77228c4460" translate="yes" xml:space="preserve">
          <source>If the function is rewritten as follows, the compiler is free to rearrange the clauses:</source>
          <target state="translated">関数を以下のように書き換えれば、コンパイラは自由に節を並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="b63119293c0f8660be248a19b2479210b58e3c5a" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;ignore&lt;/code&gt;, then it is assumed that either:</source>
          <target state="translated">関数が &lt;code&gt;ignore&lt;/code&gt; を返す場合、次のいずれかが想定されます。</target>
        </trans-unit>
        <trans-unit id="d3d840a1e8e533a047b65414d5bcef0d60c4bcbd" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{cancel, Reason}&lt;/code&gt;, this means the transport module decided not to send the message. This is &lt;strong&gt;not&lt;/strong&gt; an error. No error messages will be issued and no error counters incremented. What actions this will result in depends on what kind of message was sent.</source>
          <target state="translated">関数が &lt;code&gt;{cancel, Reason}&lt;/code&gt; 返す場合、これはトランスポートモジュールがメッセージを送信しないことを決定したことを意味します。これはエラーではあり&lt;strong&gt;ません&lt;/strong&gt;。エラーメッセージは発行されず、エラーカウンターは増加しません。これによりどのようなアクションが発生するかは、送信されたメッセージの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="7fa5ac3ae4df99fa5b9b2dd8db96506aecf3fefc" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release.</source>
          <target state="translated">関数が &lt;code&gt;{error,Reason}&lt;/code&gt; 返す場合、進行中のアップグレードは失敗し、古いリリースにロールバックします。</target>
        </trans-unit>
        <trans-unit id="cace8ed5fbcae8411e61d141c38b3af395942b38" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; can not be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">関数が失敗 &lt;code&gt;Reason&lt;/code&gt; を返した場合、進行中のアップグレードは失敗し、古いリリースにロールバックします。 &lt;code&gt;Reason&lt;/code&gt; は &lt;code&gt;{ok,_,_}&lt;/code&gt; タプルにはならないことに注意してください。これは、 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; タプルと見なされるためです。また &lt;code&gt;{ok,_}&lt;/code&gt; 一致するタプルも無効な失敗 &lt;code&gt;Reason&lt;/code&gt; です。アトムは &lt;code&gt;{error,Reason}&lt;/code&gt; タプルでラップされるため、 &lt;code&gt;Reason&lt;/code&gt; としてアトムを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="23b279a0456aa090aac1cc8d9973e0efdd61b891" translate="yes" xml:space="preserve">
          <source>If the function returns anything else, the test case is considered successful. The return value always gets printed in the test case log file.</source>
          <target state="translated">関数が何か他のものを返すと、テストケースは成功したとみなされます。戻り値は常にテストケースのログファイルに出力されます。</target>
        </trans-unit>
        <trans-unit id="f7a01fb7804d1dc8b9d59f7e2487cb33130c4689" translate="yes" xml:space="preserve">
          <source>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</source>
          <target state="translated">長く実行されているNIFの機能を分割して、より短いNIFの呼び出しで作業を行うことができるようにするには、アプリケーションには2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="ba5aec2652bfb4fd0698f0092b5faec8c5e7749c" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;ebin&lt;/code&gt;, modules (BEAM files) are searched for in that directory, otherwise modules are searched for in the given directory.</source>
          <target state="translated">指定されたディレクトリに &lt;code&gt;ebin&lt;/code&gt; という名前のサブディレクトリがある場合、モジュール（BEAMファイル）はそのディレクトリで検索されます。それ以外の場合、モジュールは指定されたディレクトリで検索されます。</target>
        </trans-unit>
        <trans-unit id="206b9b6e0e97d510493a5ac088ad8e22427aae29" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;lib&lt;/code&gt;, the directories in that directory are assumed to be application directories, otherwise all subdirectories of the given directory are assumed to be application directories. If there are several versions of some application, the one with the highest version is chosen.</source>
          <target state="translated">指定されたディレクトリに &lt;code&gt;lib&lt;/code&gt; というサブディレクトリがある場合、そのディレクトリ内のディレクトリはアプリケーションディレクトリと見なされます。それ以外の場合、指定されたディレクトリのすべてのサブディレクトリはアプリケーションディレクトリと見なされます。アプリケーションのバージョンが複数ある場合は、最も高いバージョンのものが選択されます。</target>
        </trans-unit>
        <trans-unit id="33fb4bc732c4bac52e2f3ecc8dc02b6458e5f64a" translate="yes" xml:space="preserve">
          <source>If the global name server fails to connect nodes (&lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; in the Erlang shell), but it indicates a network problem.</source>
          <target state="translated">グローバルネームサーバーがノード（例では &lt;code&gt;N1&lt;/code&gt; と &lt;code&gt;N3&lt;/code&gt; ）の接続に失敗すると、警告イベントがエラーロガーに送信されます。そのようなイベントが存在しても、後で接続するノードは除外されません（たとえば、Erlangシェルでコマンド &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; を試すことができます）が、ネットワークの問題を示しています。</target>
        </trans-unit>
        <trans-unit id="90420c92850a1634589e73fa3152ae2df519947e" translate="yes" xml:space="preserve">
          <source>If the guard test &lt;code&gt;is_integer(Int)&lt;/code&gt; succeeds, the fourth clause is executed.</source>
          <target state="translated">ガードテスト &lt;code&gt;is_integer(Int)&lt;/code&gt; が成功すると、4番目の句が実行されます。</target>
        </trans-unit>
        <trans-unit id="51156ed0f0b60bdec0db2a3c5c342e77e9337761" translate="yes" xml:space="preserve">
          <source>If the guard test fails, the input value is compared to &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, and the appropriate clause is selected. (There is a &lt;code&gt;function_clause&lt;/code&gt; exception if none of the values matched.)</source>
          <target state="translated">ガードテストが失敗した場合、入力値が比較される &lt;code&gt;four&lt;/code&gt; 、 &lt;code&gt;five&lt;/code&gt; 、及び &lt;code&gt;six&lt;/code&gt; 、及び適切な句が選択されます。（一致する値がない場合は、 &lt;code&gt;function_clause&lt;/code&gt; 例外があります。）</target>
        </trans-unit>
        <trans-unit id="042ae23e884f62c0355d18895948d09799091a5c" translate="yes" xml:space="preserve">
          <source>If the handler is meant to replace the default handler, the Kernel's default handler have to be disabled before the new handler is added. A &lt;code&gt;sys.config&lt;/code&gt; file that disables the Kernel handler and adds a custom handler could look like this:</source>
          <target state="translated">ハンドラーがデフォルトハンドラーを置き換えることを目的としている場合、新しいハンドラーを追加する前に、カーネルのデフォルトハンドラーを無効にする必要があります。 &lt;code&gt;sys.config&lt;/code&gt; のカーネルハンドラを無効にして、次のようになりますカスタムハンドラを追加したファイル：</target>
        </trans-unit>
        <trans-unit id="65f1827df55837b13a3b7ed59d4d8ea4a1983d32" translate="yes" xml:space="preserve">
          <source>If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value &lt;code&gt;infinity&lt;/code&gt; prevents restarts.</source>
          <target state="translated">ハンドラーが終了した場合、ミリ秒単位で指定された遅延後に自動的に再起動します。値 &lt;code&gt;infinity&lt;/code&gt; は再起動を防ぎます。</target>
        </trans-unit>
        <trans-unit id="b7ef0ec4d5b98a48302f9d89b544d31dce7e98f5" translate="yes" xml:space="preserve">
          <source>If the handler process is terminated because of overload, it prints information about it in the log. It also prints information about when a restart has taken place, and the handler is back in action.</source>
          <target state="translated">ハンドラプロセスが過負荷のために終了した場合、その情報をログに出力します。また、いつ再起動が行われ、ハンドラが動作を再開したかについての情報も表示します。</target>
        </trans-unit>
        <trans-unit id="71ca4e1b2a57423c539bf11275ee92c1598c8e04" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to listen on.</source>
          <target state="translated">ホストが多くのネットワークインターフェースを持っている場合、このオプションはどのネットワークインターフェースをリッスンするかを指定します。</target>
        </trans-unit>
        <trans-unit id="5938c2bcb45adfa6db096780d07c1f69ca15570f" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to use.</source>
          <target state="translated">ホストが多くのネットワークインターフェースを持っている場合、このオプションはどのネットワークインターフェースを使用するかを指定します。</target>
        </trans-unit>
        <trans-unit id="7a3654ae9fae9da43a3b1501da91842a28524e6b" translate="yes" xml:space="preserve">
          <source>If the included application itself contains included applications, instead the &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; option must be included.</source>
          <target state="translated">含まれているアプリケーション自体に含まれているアプリケーションが含まれている場合は、代わりに &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; オプションを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="93280124390abf78f821c80eb86f0bf50631ec9d" translate="yes" xml:space="preserve">
          <source>If the initial call is to one of the system-defined behaviors such as &lt;code&gt;gen_server&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;, it is translated to more useful information. If a &lt;code&gt;gen_server&lt;/code&gt; is spawned, the returned &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Function&lt;/code&gt; is &lt;code&gt;init&lt;/code&gt; (the function that initiates the new server).</source>
          <target state="translated">最初の呼び出しが &lt;code&gt;gen_server&lt;/code&gt; や &lt;code&gt;gen_event&lt;/code&gt; などのシステム定義の動作の1つである場合、それはより有用な情報に変換されます。場合 &lt;code&gt;gen_server&lt;/code&gt; が起動され、返された &lt;code&gt;Module&lt;/code&gt; 、コールバックモジュールの名前である &lt;code&gt;Function&lt;/code&gt; れる &lt;code&gt;init&lt;/code&gt; （機能を開始新しいサーバーという）。</target>
        </trans-unit>
        <trans-unit id="e36a8cae40a2ccda598cbf83afe268a5c720aa0e" translate="yes" xml:space="preserve">
          <source>If the initial encode of the outgoing request fails, then the request process fails and &lt;code&gt;{error,encode}&lt;/code&gt; is returned.</source>
          <target state="translated">発信リクエストの初期エンコードが失敗した場合、リクエストプロセスは失敗し、 &lt;code&gt;{error,encode}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="512a1cbc51d5459f85caaea2fd4bfade04f37668" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">初期化が失敗した場合、関数は &lt;code&gt;{error,Error}&lt;/code&gt; を返します。ここで、 &lt;code&gt;Error&lt;/code&gt; は任意の項であるか、 &lt;code&gt;ignore&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4efffcc1b527bd1b225e810cb600a2ae77401619" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{stop,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">初期化が失敗した場合、関数は &lt;code&gt;{stop,Reason}&lt;/code&gt; （ &lt;code&gt;Reason&lt;/code&gt; は任意の項）を返すか、 &lt;code&gt;ignore&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9346621e797dd1360944a672ab82ead28612c984" translate="yes" xml:space="preserve">
          <source>If the initialization is successful, the function is to return &lt;code&gt;{ok,State}&lt;/code&gt;, &lt;code&gt;{ok,State,Timeout}&lt;/code&gt;, or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">初期化が成功した場合、関数は &lt;code&gt;{ok,State}&lt;/code&gt; 、 &lt;code&gt;{ok,State,Timeout}&lt;/code&gt; 、または &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; &lt;code&gt;gen_server&lt;/code&gt; ます。ここで、 &lt;code&gt;State&lt;/code&gt; はgen_serverプロセスの内部状態です。</target>
        </trans-unit>
        <trans-unit id="eddc615bd88d8608ab31b9841323633dc12870aa" translate="yes" xml:space="preserve">
          <source>If the installation fails, the system can be rebooted. The old release version is then automatically used.</source>
          <target state="translated">インストールに失敗した場合は、システムを再起動することができます。その後、古いリリースバージョンが自動的に使用されます。</target>
        </trans-unit>
        <trans-unit id="c0e9d4940ae270a2841d572606f563a099b85e09" translate="yes" xml:space="preserve">
          <source>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</source>
          <target state="translated">インストールに成功した場合、新しいバージョンがデフォルトバージョンになり、システムの再起動時に使用されるようになります。</target>
        </trans-unit>
        <trans-unit id="08dbb0e86d47275a0a4e636be8892780b15448e3" translate="yes" xml:space="preserve">
          <source>If the instruction appears after instruction &lt;code&gt;point_of_no_return&lt;/code&gt; and the function call fails, the system is restarted.</source>
          <target state="translated">命令が &lt;code&gt;point_of_no_return&lt;/code&gt; 命令の後に表示され、関数呼び出しが失敗した場合、システムが再起動されます。</target>
        </trans-unit>
        <trans-unit id="efab2c6cbaff99e6149cda9413164011c49b633d" translate="yes" xml:space="preserve">
          <source>If the instruction appears before instruction &lt;code&gt;point_of_no_return&lt;/code&gt;, a failure is caught. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; then returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt;, unless &lt;code&gt;{error,Error}&lt;/code&gt; is thrown or returned. Then it returns &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">命令が &lt;code&gt;point_of_no_return&lt;/code&gt; 命令の前にある場合、失敗がキャッチされます。次に、 &lt;code&gt;{error,Error}&lt;/code&gt; がスローまたは返されない限り &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; は{error、{'EXIT'、Reason}}を返します。次に、 &lt;code&gt;{error,Error}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="6accd78db997b4f0cc8c3eb17cc0cfe9969dd581" translate="yes" xml:space="preserve">
          <source>If the instrumentation functions communicate with UNIX processes, it might be a good idea to use a special sub-agent. This sub-agent sends the SNMP request to the other process in one packet in order to minimize context switches. For example, if a whole MIB is implemented on the C level in UNIX, but you still want to use the Erlang SNMP tool, then you may have one special sub-agent, which sends the variables in the request as a single operation down to C.</source>
          <target state="translated">計装機能がUNIXプロセスと通信する場合、特別なサブエージェントを使用するのが良いでしょう。このサブエージェントはコンテキストスイッチを最小限にするために、SNMPリクエストを1つのパケットで他のプロセスに送ります。例えば、MIB全体がUNIXのCレベルで実装されていて、それでもErlangのSNMPツールを使いたい場合、特別なサブエージェントを1つ持っていて、リクエストの中の変数を1つの操作としてCに送ることができます。</target>
        </trans-unit>
        <trans-unit id="6073ddc2f6ff51455fef10943643ff33d4a41b31" translate="yes" xml:space="preserve">
          <source>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as &lt;code&gt;'_'&lt;/code&gt; or &lt;code&gt;'$1'&lt;/code&gt;, the whole &lt;code&gt;employee&lt;/code&gt; table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt;) if the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">キー属性がパターンでバインドされている場合、一致操作は効率的です。ただし、パターンのキー属性が &lt;code&gt;'_'&lt;/code&gt; または &lt;code&gt;'$1'&lt;/code&gt; として指定されている場合、 &lt;code&gt;employee&lt;/code&gt; テーブル全体で一致するレコードを検索する必要があります。したがって、テーブルが大きい場合、これは時間のかかる操作になる可能性がありますが、関数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; が使用されている場合は、 &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt; 使用して修正できます（インデックス作成を参照）。</target>
        </trans-unit>
        <trans-unit id="702da889833ee1dc6797c2ff9a6559f2d21f93ff" translate="yes" xml:space="preserve">
          <source>If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large.</source>
          <target state="translated">パターンの中でキーが指定されている場合は、非常に効率的にマッチします。キーが指定されていない場合、つまり変数やアンダースコアの場合は、テーブル全体を検索しなければなりません。テーブルが非常に大きい場合、検索時間はかなりのものになります。</target>
        </trans-unit>
        <trans-unit id="006f97d543b8ad5e428fa64fac1606142a9e3339" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects.</source>
          <target state="translated">keypos'th要素場合 &lt;code&gt;MatchSpec&lt;/code&gt; が結合され、一致仕様は、正しいキー（S）を持つテーブルのすべてのオブジェクトに適用されます。 keypos'th要素場合 &lt;code&gt;MatchSpec&lt;/code&gt; が未結合である、マッチ仕様がテーブルのすべてのオブジェクトに適用され、 &lt;code&gt;N&lt;/code&gt; は、少なくとも一つのオブジェクトの一致またはテーブルの端に到達するまで、一度にオブジェクト。 &lt;code&gt;N&lt;/code&gt; に &lt;code&gt;default&lt;/code&gt; という値を与えることで示されるデフォルトは、オブジェクトのサイズに応じてオブジェクトの数を変化させることです。同じキーを持つすべてのオブジェクトは常に同時に処理されます。これは、Nを超えるオブジェクトに一致仕様を適用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="5b16233e004fe373963364905dc9a2ad762556f0" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">keypos'th要素場合 &lt;code&gt;MatchSpec&lt;/code&gt; が結合され、一致仕様は、正しいキー（S）を持つオブジェクトに適用されます。</target>
        </trans-unit>
        <trans-unit id="f90ff4fedc7cf136ced2894c42e307fbd5a5c73b" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">keypos'th要素場合 &lt;code&gt;MatchSpec&lt;/code&gt; が未結合である、マッチ仕様はテーブルのすべてのオブジェクトに適用されます。keyposの要素がバインドされている場合、一致仕様は正しいキーのみを持つオブジェクトに適用されます。</target>
        </trans-unit>
        <trans-unit id="c802fc2a3fde97f62fdbabfc7b66189e18b5dfc7" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; のkeypos番目の要素がバインドされている場合、すべてのテーブルオブジェクトが一致します。 keyposの要素がバインドされていない場合、少なくとも1つのオブジェクトが一致するか、テーブルの最後に到達するまで、一度に &lt;code&gt;N&lt;/code&gt; 個のオブジェクトがすべてのテーブルオブジェクトと一致します。 &lt;code&gt;N&lt;/code&gt; に &lt;code&gt;default&lt;/code&gt; という値を与えることで示されるデフォルトは、オブジェクトのサイズに応じてオブジェクトの数を変化させることです。同じキーを持つすべての一致するオブジェクトは、常に同じ応答で返されます。これは、Nを超えるオブジェクトが返される場合があることを意味します。</target>
        </trans-unit>
        <trans-unit id="ee8399b71f2614d1c169eead97f1d70700fb4b6e" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; のkeypos番目の要素がバインドされている場合、すべてのテーブルオブジェクトが一致します。keyposの要素がバインドされていない場合、少なくとも1つのオブジェクトが一致するか、テーブルの最後に到達するまで、一度に &lt;code&gt;N&lt;/code&gt; 個のオブジェクトがすべてのテーブルオブジェクトと一致します。 &lt;code&gt;N&lt;/code&gt; に &lt;code&gt;default&lt;/code&gt; という値を与えることで示されるデフォルトは、オブジェクトのサイズに応じてオブジェクトの数を変化させることです。同じキーを持つすべてのオブジェクトは常に同時に照合されます。これは、Nを超えるオブジェクトが照合される場合があることを意味します。</target>
        </trans-unit>
        <trans-unit id="81cd44a63c897e4a4fbbf303d633ae129d55b04f" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; のkeypos番目の要素がバインドされている場合、正しいキーを持つオブジェクトのみが一致します。</target>
        </trans-unit>
        <trans-unit id="519fdb3cbbeb8df2c304203d27f11912d501b21d" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is unbound, all table objects are matched. If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; のkeypos番目の要素がバインドされていない場合、すべてのテーブルオブジェクトが一致します。 &lt;code&gt;Pattern&lt;/code&gt; のkeypos番目の要素がバインドされている場合、正しいキーを持つオブジェクトのみが一致します。</target>
        </trans-unit>
        <trans-unit id="56e84a693998be360a017f2de3532689d94a7f87" translate="yes" xml:space="preserve">
          <source>If the last expression of a function body is a function call, a &lt;strong&gt;tail recursive&lt;/strong&gt; call is done. This is to ensure that no system resources, for example, call stack, are consumed. This means that an infinite loop can be done if it uses tail-recursive calls.</source>
          <target state="translated">関数本体の最後の式が関数呼び出しの場合、&lt;strong&gt;末尾再帰&lt;/strong&gt;呼び出しが行われます。これは、コールスタックなどのシステムリソースが消費されないようにするためです。つまり、末尾再帰呼び出しを使用すると、無限ループが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9ae06ba70f228c8b154f39f0df23503609bcb3bd" translate="yes" xml:space="preserve">
          <source>If the length of the message queue grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the messages in the message queue by receiving them in a loop without logging. Client processes waiting for a response from a synchronous log request receive a reply from the handler indicating that the request is dropped. The handler process increases its priority during the flush loop to make sure that no new events are received during the operation. Notice that after the flush operation is performed, the handler prints information in the log about how many events have been deleted.</source>
          <target state="translated">メッセージキューの長さがこのしきい値よりも大きくなると、フラッシュ(削除)操作が行われます。イベントをフラッシュするために、ハンドラはメッセージキュー内のメッセージをログを記録せずにループで受信して破棄します。同期ログ要求からの応答を待っているクライアントプロセスは、ハンドラから要求が取り下げられたことを示す応答を受け取ります。ハンドラプロセスは、操作中に新しいイベントが受信されないことを確認するために、フラッシュループ中に優先度を上げます。フラッシュ操作が実行された後、ハンドラは削除されたイベントの数についての情報をログに表示することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d10dfdc12d1915667ccceb0a8869e7352174a1a5" translate="yes" xml:space="preserve">
          <source>If the level for &lt;code&gt;mymodule&lt;/code&gt; is now set to &lt;code&gt;debug&lt;/code&gt;, then debug events from this module will be logged by the handler &lt;code&gt;h2&lt;/code&gt;, but not by handler &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mymodule&lt;/code&gt; のレベルが &lt;code&gt;debug&lt;/code&gt; に設定されている場合、このモジュールからのデバッグイベントはハンドラー &lt;code&gt;h2&lt;/code&gt; ではなくハンドラー &lt;code&gt;h1&lt;/code&gt; によって記録されます。</target>
        </trans-unit>
        <trans-unit id="57aa00c976a435bf8bda5a05ad6230ef4e15342c" translate="yes" xml:space="preserve">
          <source>If the library path is set to &lt;code&gt;code_path&lt;/code&gt;, the set of library modules is not determined, and the &lt;code&gt;info&lt;/code&gt; functions will return empty lists of library modules.</source>
          <target state="translated">ライブラリパスが &lt;code&gt;code_path&lt;/code&gt; に設定されている場合、ライブラリモジュールのセットは決定されず、 &lt;code&gt;info&lt;/code&gt; 関数はライブラリモジュールの空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="5a12290de86cdc8197c1cbb41227356d8ad7a7f4" translate="yes" xml:space="preserve">
          <source>If the list contains more than one object with &lt;strong&gt;matching&lt;/strong&gt; keys and the table type is &lt;code&gt;set&lt;/code&gt;, one is inserted, which one is not defined. The same holds for table type &lt;code&gt;ordered_set&lt;/code&gt; if the keys &lt;strong&gt;compare equal&lt;/strong&gt;.</source>
          <target state="translated">リストに&lt;strong&gt;一致する&lt;/strong&gt;キーを持つ複数のオブジェクトが含まれ、テーブルタイプが &lt;code&gt;set&lt;/code&gt; されている場合は、定義されていないオブジェクトが挿入されます。キーが&lt;strong&gt;等しい&lt;/strong&gt;場合、テーブルタイプ &lt;code&gt;ordered_set&lt;/code&gt; にも同じことが言えます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="306fdef74e5ed0763cd6967950f14b6cd849bc3e" translate="yes" xml:space="preserve">
          <source>If the list of applications contains core applications, i.e &lt;code&gt;erts&lt;/code&gt;, &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt; or &lt;code&gt;sasl&lt;/code&gt;, the &lt;code&gt;Install&lt;/code&gt; script in the patched Erlang/OTP installation must be rerun.</source>
          <target state="translated">アプリケーションのリストにコアアプリケーション、つまり &lt;code&gt;erts&lt;/code&gt; 、 &lt;code&gt;kernel&lt;/code&gt; 、 &lt;code&gt;stdlib&lt;/code&gt; 、または &lt;code&gt;sasl&lt;/code&gt; が含まれている場合は、パッチが適用されたErlang / OTPインストールの &lt;code&gt;Install&lt;/code&gt; スクリプトを再実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="8acd485e36998d865f417532aa218ed4f2b0d80e" translate="yes" xml:space="preserve">
          <source>If the local node is part of a global group, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;synced&lt;/code&gt;. If no global groups are defined, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;no_conf&lt;/code&gt;.</source>
          <target state="translated">ローカルノードがグローバルグループの一部である場合、 &lt;code&gt;State&lt;/code&gt; は &lt;code&gt;synced&lt;/code&gt; と等しくなります。グローバルグループが定義されていない場合、 &lt;code&gt;State&lt;/code&gt; は &lt;code&gt;no_conf&lt;/code&gt; に等しくなります。</target>
        </trans-unit>
        <trans-unit id="b3dc78cf933189665aca88d0f65ce3644c34d9ac" translate="yes" xml:space="preserve">
          <source>If the log event is returned, the next filter function is called with the returned value as the first argument. That is, if a filter function modifies the log event, the next filter function receives the modified event. The value returned from the last filter function is the value that the handler callback receives.</source>
          <target state="translated">ログイベントが返された場合、返された値を第一引数として次のフィルタ関数が呼び出されます。つまり、フィルタ関数がログイベントを変更した場合、次のフィルタ関数は変更されたイベントを受け取ります。最後のフィルタ関数から返される値は、ハンドラコールバックが受け取る値となります。</target>
        </trans-unit>
        <trans-unit id="d41baef54ef4b512298e69bbec24ae875c8c68a0" translate="yes" xml:space="preserve">
          <source>If the log is blocked by the closing process, the log is also unblocked.</source>
          <target state="translated">終了処理でログがブロックされている場合は、ログのブロックも解除されます。</target>
        </trans-unit>
        <trans-unit id="8605585ed728deb58354312d2da402db9d75ef1c" translate="yes" xml:space="preserve">
          <source>If the log is local on the current node, &lt;code&gt;Dist&lt;/code&gt; has the value &lt;code&gt;local&lt;/code&gt;, otherwise all nodes where the log is distributed are returned as a list.</source>
          <target state="translated">ログが現在のノードのローカルである場合、 &lt;code&gt;Dist&lt;/code&gt; の値は &lt;code&gt;local&lt;/code&gt; です。それ以外の場合、ログが配布されているすべてのノードがリストとして返されます。</target>
        </trans-unit>
        <trans-unit id="dafa7b7f2609edae55f58fdb8dad531885491f7e" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">ログメッセージは次のように指定された場合 &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;report_cb&lt;/code&gt; のキーは、書式文字列と引数にレポートを変換し楽しい（レポートコールバック）に関連付けることができます。レポートコールバックの詳細については、ユーザーガイドの「 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="de16ab6d2dd843eaf98a56613e46e210c0e2c90f" translate="yes" xml:space="preserve">
          <source>If the log size is decreased, for example, to save space, function &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; can be used to force the log to wrap.</source>
          <target state="translated">たとえば、スペースを節約するためにログサイズが減少した場合、関数 &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; を使用してログを強制的にラップできます。</target>
        </trans-unit>
        <trans-unit id="720cb0ae706744e4ee9df32b00d37adc564581fe" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined before the &lt;code&gt;merl.hrl&lt;/code&gt; header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions &lt;code&gt;?Q(...) = ...&lt;/code&gt;, case switches using &lt;code&gt;?Q(...)&lt;/code&gt; patterns, and automatic metavariables like &lt;code&gt;_@Tuple&lt;/code&gt; cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the &lt;code&gt;?Q(Text, Map)&lt;/code&gt; macro, e.g.:</source>
          <target state="translated">マクロ場合 &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; が前に定義されて &lt;code&gt;merl.hrl&lt;/code&gt; のヘッダファイルが含まれている、MERLによって使用される変換解析が無効になって、その場合には、一致表現されます &lt;code&gt;?Q(...) = ...&lt;/code&gt; 、場合は、使用してスイッチ &lt;code&gt;?Q(...)&lt;/code&gt; パターン、および &lt;code&gt;_@Tuple&lt;/code&gt; Tupleなどの自動メタ変数はコードで使用できませんが、Merlマクロと関数は引き続き機能します。メタ変数置換を行うには、 &lt;code&gt;?Q(Text, Map)&lt;/code&gt; マクロを使用する必要があります。例：</target>
        </trans-unit>
        <trans-unit id="2f7a0ebf63b23efbe71cc89202b72b358a0f129b" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NOASSERT&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">EUnitヘッダーファイルをインクルードする前にマクロ &lt;code&gt;NOASSERT&lt;/code&gt; が定義されている場合、これらのマクロはテストも無効になっている場合は効果がありません。詳細については、 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="146cb0ce4e92421175ea3746cf274e2455137df9" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NODEBUG&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">EUnitヘッダーファイルをインクルードする前にマクロ &lt;code&gt;NODEBUG&lt;/code&gt; が定義されている場合、これらのマクロは効果がありません。詳細については、 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9b5a901ceceb4e69c701bf0dc03c50b6bae11f7b" translate="yes" xml:space="preserve">
          <source>If the manager is not configured to use any particular transport domain, the behaviour &lt;code&gt;handle_agent/4&lt;/code&gt; will for backwards copmpatibility reasons be called with the old &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments</source>
          <target state="translated">マネージャーが特定のトランスポートドメインを使用するように構成されていない場合、下位互換性のために、 &lt;code&gt;handle_agent/4&lt;/code&gt; の動作が古い &lt;code&gt;IpAddr&lt;/code&gt; および &lt;code&gt;PortNumber&lt;/code&gt; 引数で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f6efb33521a71965325da2bbd03e23ab8ae58659" translate="yes" xml:space="preserve">
          <source>If the manager tries to set the same variable many times in the same PDU, the agent is free to improvise. There is no definition which determines if the instrumentation will be called once or twice. If called once only, there is no definition that determines which of the new values is going to be supplied.</source>
          <target state="translated">管理者が同じPDUで何度も同じ変数を設定しようとした場合、エージェントは自由に即興をすることができます。インストルメントが一度だけ呼ばれるか二度だけ呼ばれるかを決定する定義はありません。一度だけ呼び出された場合、どちらの新しい値が供給されようとしているかを決定する定義はありません。</target>
        </trans-unit>
        <trans-unit id="74415b1346dd0ddc93d29cb9c0389734be028243" translate="yes" xml:space="preserve">
          <source>If the master node fails, the entire pool exits.</source>
          <target state="translated">マスターノードに障害が発生した場合、プール全体が終了します。</target>
        </trans-unit>
        <trans-unit id="ada210019d5db3434b3a98372ed4ed0f124b6d6b" translate="yes" xml:space="preserve">
          <source>If the match specification contains errors, tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">一致指定にエラーが含まれている場合、タプル &lt;code&gt;{error, Errors}&lt;/code&gt; が返されます。ここで、 &lt;code&gt;Errors&lt;/code&gt; は、一致指定の何が問題であったかを自然言語で記述したリストです。</target>
        </trans-unit>
        <trans-unit id="73520de0bbd30344138b28e89ae6e3ad45ab6a3d" translate="yes" xml:space="preserve">
          <source>If the match specification is executed when selecting objects from an ETS table:</source>
          <target state="translated">ETS テーブルからオブジェクトを選択する際にマッチ指定が実行された場合。</target>
        </trans-unit>
        <trans-unit id="c4b956c127ba515516d186daa8a6509787e44051" translate="yes" xml:space="preserve">
          <source>If the match specification is executing when tracing:</source>
          <target state="translated">トレース時にマッチ指定が実行されている場合。</target>
        </trans-unit>
        <trans-unit id="8673441fb53d8c53d833ea8413d411b45f3c363b" translate="yes" xml:space="preserve">
          <source>If the match specification is syntactically correct, the function either returns &lt;code&gt;{ok,Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">一致指定が構文的に正しい場合、関数は &lt;code&gt;{ok,Result}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Result&lt;/code&gt; は実際の &lt;code&gt;select/2&lt;/code&gt; 呼び出しの結果となるものか、一致指定がオブジェクト &lt;code&gt;Tuple&lt;/code&gt; と一致しない場合は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="760d740968a06c49ac007f36a245af2196bd1b34" translate="yes" xml:space="preserve">
          <source>If the matching conditions are not met, the match fails, either with:</source>
          <target state="translated">一致する条件が満たされていない場合は、以下のいずれかの条件で一致に失敗します。</target>
        </trans-unit>
        <trans-unit id="1935f33d435bd33bb34072fa05214583d09d6dc0" translate="yes" xml:space="preserve">
          <source>If the matching fails, a &lt;code&gt;badmatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">マッチングが失敗すると、 &lt;code&gt;badmatch&lt;/code&gt; ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5e6c9dcffff87aa8aa658e5eae30b4366a1b2bb3" translate="yes" xml:space="preserve">
          <source>If the matching subpart of &lt;code&gt;Subject&lt;/code&gt; giving raise to the replacement is to be inserted in the result, option &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; inserts the matching part into &lt;code&gt;Replacement&lt;/code&gt; at the specified position (or positions) before inserting &lt;code&gt;Replacement&lt;/code&gt; into &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">置換を発生させる &lt;code&gt;Subject&lt;/code&gt; の一致するサブパートを結果に挿入する場合、オプション &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; は、 &lt;code&gt;Replacement&lt;/code&gt; を &lt;code&gt;Subject&lt;/code&gt; に挿入する前に、一致する部分を &lt;code&gt;Replacement&lt;/code&gt; の指定された位置に挿入します。</target>
        </trans-unit>
        <trans-unit id="fdd041679c28a1dfb5c5129e21e191da62b2500c" translate="yes" xml:space="preserve">
          <source>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of &lt;code&gt;Expr2&lt;/code&gt; is returned.</source>
          <target state="translated">マッチングが成功すると、パターン内のバインドされていない変数がバインドされ、 &lt;code&gt;Expr2&lt;/code&gt; の値が返されます。</target>
        </trans-unit>
        <trans-unit id="5059fa619d98d60a3d0f2e7f4484d57de08a27f3" translate="yes" xml:space="preserve">
          <source>If the maximum depth is reached, it cannot be read in the resultant output. Also, the &lt;code&gt;,...&lt;/code&gt; form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</source>
          <target state="translated">最大深度に達すると、結果の出力で読み取ることができません。また、タプル内の &lt;code&gt;,...&lt;/code&gt; フォームは、タプル内により多くの要素があることを示しますが、これらは印刷深度より下にあります。</target>
        </trans-unit>
        <trans-unit id="6c939753050268aea10f52760cad514608911137" translate="yes" xml:space="preserve">
          <source>If the message cannot be decoded the following callback function will be invoked:</source>
          <target state="translated">メッセージがデコードできない場合は、以下のコールバック関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fa13ca2255dfd047e4217a3af88a01b044ce4d8d" translate="yes" xml:space="preserve">
          <source>If the message is on report form, it is converted to &lt;code&gt;{Format,Args}&lt;/code&gt; by calling the report callback. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information about report callbacks and valid forms of log messages.</source>
          <target state="translated">メッセージがレポートフォームにある場合、レポートコールバックを呼び出すことにより &lt;code&gt;{Format,Args}&lt;/code&gt; 変換されます。レポートコールバックとログメッセージの有効な形式の詳細については、 『カーネルユーザーガイド』の「 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="c5713a5c2133c11304f85627e2ccde367a7ac635" translate="yes" xml:space="preserve">
          <source>If the minimum repetition is &amp;gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching.</source>
          <target state="translated">最小繰り返しが&amp;gt; 0の場合、数量詞は無視されます。アサーションは、マッチング中に遭遇したときに一度だけ従われます。</target>
        </trans-unit>
        <trans-unit id="5f724a3bd58fe6f9ce42fc406728de7f89ce0ad1" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;m1&lt;/code&gt; is introduced in version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt;, it must also be loaded when upgrading and deleted when downgrading:</source>
          <target state="translated">モジュール &lt;code&gt;m1&lt;/code&gt; が &lt;code&gt;ch_app&lt;/code&gt; のバージョン「2」で導入された場合、アップグレード時にもロードし、ダウングレード時に削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="7aff411ea6299d7bca7ad227ec0e1bc26a882a00" translate="yes" xml:space="preserve">
          <source>If the module cannot be found, &lt;code&gt;non_existing&lt;/code&gt; is returned.</source>
          <target state="translated">モジュールが見つからない場合は、 &lt;code&gt;non_existing&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="5745afeece7b41ec1bfc061d3b5f18d8e8d1dfba" translate="yes" xml:space="preserve">
          <source>If the module is Cover-compiled, &lt;code&gt;cover_compiled&lt;/code&gt; is returned.</source>
          <target state="translated">モジュールがカバーコンパイルされている場合、 &lt;code&gt;cover_compiled&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="52f516f712d9242bfd152b08a6fd0f4a2793c3fd" translate="yes" xml:space="preserve">
          <source>If the module is loaded, it returns the name of the file containing the loaded object code.</source>
          <target state="translated">モジュールがロードされている場合は、ロードされたオブジェクトコードを含むファイル名を返します。</target>
        </trans-unit>
        <trans-unit id="46dba590f6c1f6f800702e68508881918dc97bf9" translate="yes" xml:space="preserve">
          <source>If the module is not loaded, this function searches the code path for the first file containing object code for &lt;code&gt;Module&lt;/code&gt; and returns the absolute filename.</source>
          <target state="translated">モジュールがロードされていない場合、この関数は &lt;code&gt;Module&lt;/code&gt; オブジェクトコードを含む最初のファイルのコードパスを検索し、絶対ファイル名を返します。</target>
        </trans-unit>
        <trans-unit id="229acd9737c1671ac97dd505de45081f475b5a4e" translate="yes" xml:space="preserve">
          <source>If the module is preloaded, &lt;code&gt;preloaded&lt;/code&gt; is returned.</source>
          <target state="translated">モジュールがプリロードされている場合、 &lt;code&gt;preloaded&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="ea6cb550bcdaadfe5116319b2dd6e7b241b066a1" translate="yes" xml:space="preserve">
          <source>If the module is successfully Cover compiled, the function returns &lt;code&gt;{ok,Module}&lt;/code&gt;. Otherwise the function returns &lt;code&gt;{error,File}&lt;/code&gt;. Errors and warnings are printed as they occur.</source>
          <target state="translated">モジュールがCoverコンパイルに成功すると、関数は &lt;code&gt;{ok,Module}&lt;/code&gt; 返します。それ以外の場合、関数は &lt;code&gt;{error,File}&lt;/code&gt; 返します。エラーと警告は、発生時に出力されます。</target>
        </trans-unit>
        <trans-unit id="1e0a91a6b9e2e2cfbc8f28ae6d3d48928ca8ba21" translate="yes" xml:space="preserve">
          <source>If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; processes. The message is &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt;. The reply to this message is &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt;, where &lt;code&gt;Modules&lt;/code&gt; is a list of the currently active modules in the process.</source>
          <target state="translated">プロセスの実装に使用されるモジュールが実行時に動的に変化する場合、プロセスはもう1つのメッセージを理解する必要があります。例は、 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; プロセスです。メッセージは &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt; です。このメッセージへの返信は &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt; 、ここで &lt;code&gt;Modules&lt;/code&gt; は、プロセスで現在アクティブなモジュールのリストです。</target>
        </trans-unit>
        <trans-unit id="df61dd8b4c6d4d214b129a5077aaee5f7910b304" translate="yes" xml:space="preserve">
          <source>If the name after the prefix and any lift and glob markers is &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, the variable is treated as an anonymous catch-all pattern in matches. For example, &lt;code&gt;_@_&lt;/code&gt;, &lt;code&gt;_@@_&lt;/code&gt;, &lt;code&gt;_@__&lt;/code&gt;, or even &lt;code&gt;_@__@_&lt;/code&gt;.</source>
          <target state="translated">接頭辞とリフトマーカーとグロブマーカーの後の名前が &lt;code&gt;_&lt;/code&gt; または &lt;code&gt;0&lt;/code&gt; の場合、変数は一致で匿名のキャッチオールパターンとして扱われます。たとえば、 &lt;code&gt;_@_&lt;/code&gt; 、 &lt;code&gt;_@@_&lt;/code&gt; 、 &lt;code&gt;_@__&lt;/code&gt; 、さらには &lt;code&gt;_@__@_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8c34344ea584c9364120e1acb56d82e908a1af1b" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_server&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the &lt;code&gt;gen_server&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">名前を省略すると、 &lt;code&gt;gen_server&lt;/code&gt; は登録されません。代わりに、そのpidを使用する必要があります。名前は &lt;code&gt;{global, Name}&lt;/code&gt; として指定することもできます。その場合、 &lt;code&gt;gen_server&lt;/code&gt; は &lt;code&gt;global:register_name/2&lt;/code&gt; を使用して登録されます。</target>
        </trans-unit>
        <trans-unit id="5f90545e460868142094a7469ef7c519e7a99526" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_statem&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be specified as &lt;code&gt;{global,Name}&lt;/code&gt;, then the &lt;code&gt;gen_statem&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt; in Kernel.</source>
          <target state="translated">名前を省略すると、 &lt;code&gt;gen_statem&lt;/code&gt; は登録されません。代わりに、そのpidを使用する必要があります。名前は &lt;code&gt;{global,Name}&lt;/code&gt; として指定することもできます。その後、 &lt;code&gt;gen_statem&lt;/code&gt; はカーネルで &lt;code&gt;global:register_name/2&lt;/code&gt; を使用して登録されます。</target>
        </trans-unit>
        <trans-unit id="bce770e9e17197a693d6f9ec8afdca775fdac582" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the event manager is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the event manager is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">名前を省略した場合、イベントマネージャーは登録されません。代わりに、そのpidを使用する必要があります。名前は &lt;code&gt;{global, Name}&lt;/code&gt; として指定することもできます。その場合、イベントマネージャは &lt;code&gt;global:register_name/2&lt;/code&gt; を使用して登録されます。</target>
        </trans-unit>
        <trans-unit id="980ec5f2e4cbb3a6bcddf606d02e3f399d751b31" translate="yes" xml:space="preserve">
          <source>If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.</source>
          <target state="translated">この種の条件で使用されている名前が重複している場合、このテストは同じ名前のすべてのサブパターンに適用され、その中のどれかが一致していれば真となります。</target>
        </trans-unit>
        <trans-unit id="49bffa909b81c50ee39e3329bfdea53c42d35846" translate="yes" xml:space="preserve">
          <source>If the node is distributed, all referenced nodes are visible. Column &lt;strong&gt;Connection type&lt;/strong&gt; shows if the node is visible, hidden, or not connected. Visible nodes are alive nodes with a living connection to the originating node. Hidden nodes are the same as visible nodes, except they are started with flag &lt;code&gt;-hidden&lt;/code&gt;. Not connected nodes are nodes that are not connected to the originating node anymore, but references (that is, process or port identifiers) exist.</source>
          <target state="translated">ノードが分散している場合、参照されているすべてのノードが表示されます。列&lt;strong&gt;接続タイプ&lt;/strong&gt;は、ノードが表示、非表示、または接続されていないかを示します。可視ノードは、元のノードへの生きた接続を持つ生きたノードです。非表示ノードは、フラグ &lt;code&gt;-hidden&lt;/code&gt; で開始されることを除いて、表示ノードと同じです。接続されていないノードは、元のノードに接続されなくなったノードですが、参照（つまり、プロセスまたはポートの識別子）は存在します。</target>
        </trans-unit>
        <trans-unit id="9c56f0553bb17f48448269d8c3f6b6f7e5b7e66d" translate="yes" xml:space="preserve">
          <source>If the node is started with command-line flag &lt;code&gt;-sname&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the short name of the host (not the fully qualified domain name). If started with flag &lt;code&gt;-name&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified domain name. For more information, see &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">ノードがコマンドラインフラグ &lt;code&gt;-sname&lt;/code&gt; で起動されている場合、ノード名は &lt;code&gt;foobar@Host&lt;/code&gt; 。ここで、 &lt;code&gt;Host&lt;/code&gt; はホストの短い名前です（完全修飾ドメイン名ではありません）。フラグ &lt;code&gt;-name&lt;/code&gt; で開始した場合、ノード名は &lt;code&gt;foobar@Host&lt;/code&gt; 。ここで、 &lt;code&gt;Host&lt;/code&gt; は完全修飾ドメイン名です。詳細については、 &lt;code&gt;erl&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="95b56bcd18c923019bf4643e2b58f9471a6acfb9" translate="yes" xml:space="preserve">
          <source>If the node was not distributed.</source>
          <target state="translated">ノードが分散していなかった場合</target>
        </trans-unit>
        <trans-unit id="aedd11aac41ef6bf71a8b2c8d09b6e7316fb0ef3" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, &lt;code&gt;0&lt;/code&gt; is returned, otherwise &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">ノードがEPMDから正常に登録解除された場合、 &lt;code&gt;0&lt;/code&gt; が返されます。それ以外の場合は &lt;code&gt;-1&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が &lt;code&gt;EIO&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="9460cf94d8c06eac24b50547fafb0d6e9b4fd6e1" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, the function returns &lt;code&gt;0&lt;/code&gt;. Otherwise, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">ノードがEPMDから正常に登録解除された場合、関数は &lt;code&gt;0&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;-1&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が &lt;code&gt;EIO&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="0d5ac939fb10f304c0c8f3c91721403a64646c5e" translate="yes" xml:space="preserve">
          <source>If the node where the application is running goes down, the application is restarted (after the specified time-out) at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. This is called a &lt;strong&gt;failover&lt;/strong&gt;.</source>
          <target state="translated">アプリケーションが実行されているノードがダウンした場合、アプリケーションは（指定されたタイムアウト後に） &lt;code&gt;distributed&lt;/code&gt; 構成パラメーターのノードのリストにリストされている最初の稼働ノードで再始動されます。これは&lt;strong&gt;フェイルオーバー&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d2b0ad4edfef4bb3e88a7ddeeff16d1de18813" translate="yes" xml:space="preserve">
          <source>If the number of arguments are known at compile time, the call is better written as &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt;.</source>
          <target state="translated">引数の数がコンパイル時にわかっている場合、呼び出しは &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt; として記述する方が適切です。</target>
        </trans-unit>
        <trans-unit id="37c7a476d1b0b827d6493e10ef324cd201488a29" translate="yes" xml:space="preserve">
          <source>If the number of elements in the arguments are known at compile time, the call is better written as &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt;.</source>
          <target state="translated">引数の要素の数がコンパイル時にわかっている場合、呼び出しは &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt; として記述する方が適切です。</target>
        </trans-unit>
        <trans-unit id="5f1678d016c144fe15d956c065fed8204d1f4e8c" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">古い動作が望ましい場合は、カーネル構成パラメーター &lt;code&gt;logger_sasl_compatible&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定できます。その後、 &lt;code&gt;SASL configuration parameters&lt;/code&gt; を以前と同様に使用できます。SASLレポートは、SASLアプリケーションが実行されている場合にのみ、 &lt;code&gt;sasl&lt;/code&gt; という2番目のログハンドラーを介して出力されます。</target>
        </trans-unit>
        <trans-unit id="e5231cf8edc57a7fbd05d3b31ba66fb76e90acd0" translate="yes" xml:space="preserve">
          <source>If the operation fails, a bad match error occurs that terminates the test case.</source>
          <target state="translated">操作が失敗した場合、一致不良エラーが発生してテストケースが終了します。</target>
        </trans-unit>
        <trans-unit id="965b40d04fea8544035ae2adb0a45bfab2ddc16f" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned.</source>
          <target state="translated">オプション &lt;code&gt;raw&lt;/code&gt; が設定されている場合、ファイルサーバーは呼び出されず、ローカルファイルに関する情報のみが返されます。</target>
        </trans-unit>
        <trans-unit id="5e127046f0102151c6ef18467d6c0abf9dd2f077" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">オプション &lt;code&gt;raw&lt;/code&gt; が設定されている場合、ファイルサーバーは呼び出されず、ローカルファイルに関する情報のみが返されます。これは、 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt; への同時呼び出しと競合する可能性があるため、このモジュールのアトミック性の保証に違反します。</target>
        </trans-unit>
        <trans-unit id="4d027da67948b3928fcb8c40cf4bee29a349c9ad" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is proably not what you want.</source>
          <target state="translated">オプション &lt;code&gt;verify&lt;/code&gt; が &lt;code&gt;verify_peer&lt;/code&gt; に設定されている場合、オプション &lt;code&gt;server_name_indication&lt;/code&gt; も指定する必要があります。指定されていない場合、サーバー名表示拡張が送信され、 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; が &lt;code&gt;ReferenceID&lt;/code&gt; として接続のIPアドレスで呼び出されます。おそらくあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="c3a18e0b35e87dbcf1a9dcdd4db312f82e11bde7" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;{handshake, hello}&lt;/code&gt; を使用すると、サーバーのhelloメッセージを受信した後にハンドシェイクが一時停止し、成功の応答は &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; ではなく{ok、SslSocket、Ext}に &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。その後、handshake_continue &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ハンドシェイクが続行またはキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="06f7f3873edec45c49aeb8ad204a603fa73eff84" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;allow deny&lt;/code&gt;, the users network address is first controlled to be in the allow subset. If the user network address is not in the allowed subset, the user is denied to get the asset. If the network address is in the allowed subset, a second control is performed. That is, the user network address is not in the subset of network addresses to be denied as specified by parameter &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">順序が &lt;code&gt;allow deny&lt;/code&gt; を許可するように設定されている場合、ユーザーのネットワークアドレスは、最初にallowサブセットに含まれるように制御されます。ユーザーのネットワークアドレスが許可されたサブセットにない場合、ユーザーはアセットの取得を拒否されます。ネットワークアドレスが許可されたサブセット内にある場合、2番目の制御が実行されます。つまり、ユーザーのネットワークアドレスは、 &lt;code&gt;deny&lt;/code&gt; パラメータで指定されているように、拒否されるネットワークアドレスのサブセットに含まれていません。</target>
        </trans-unit>
        <trans-unit id="48d8a47c543c2d39d92d2c1d202bacab80c1642d" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;deny allow&lt;/code&gt;, only users from networks specified to be in the allowed subset succeeds to request assets in the limited area.</source>
          <target state="translated">順序が &lt;code&gt;deny allow&lt;/code&gt; に設定されている場合、許可されたサブセットに含まれるように指定されたネットワークからのユーザーのみが、制限された領域のアセットをリクエストできます。</target>
        </trans-unit>
        <trans-unit id="5413791d17ed0b4814f8fb694ad1efb815f76c05" translate="yes" xml:space="preserve">
          <source>If the order of the answers is not important, there is an alternative to the &lt;code&gt;unique&lt;/code&gt; option, namely to sort the answers uniquely:</source>
          <target state="translated">回答の順序が重要でない場合は、 &lt;code&gt;unique&lt;/code&gt; オプションに代わるものがあります。つまり、回答を一意に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="b054305581b7663ed91514b307669add31ca5b5b" translate="yes" xml:space="preserve">
          <source>If the packet does not conform to the protocol format, &lt;code&gt;{error,Reason}&lt;/code&gt; is returned.</source>
          <target state="translated">パケットがプロトコル形式に準拠していない場合、 &lt;code&gt;{error,Reason}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a2c9f15b9a918cfc529cc22dc69ae62a00c732a6" translate="yes" xml:space="preserve">
          <source>If the page is empty, it means either of the following:</source>
          <target state="translated">ページが空の場合は、以下のいずれかを意味します。</target>
        </trans-unit>
        <trans-unit id="f52fa558245396ce59f0c16eb282e09760e84891" translate="yes" xml:space="preserve">
          <source>If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The module &lt;code&gt;dbg&lt;/code&gt; actually exports a function with this name, but it should never really be called except for when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including the &lt;code&gt;ms_transform.hrl&lt;/code&gt; header file, compiled code will never call the function, but the function call is replaced by a literal match_spec.</source>
          <target state="translated">この疑似関数を呼び出すモジュールにparse_transformが適用されていない場合、呼び出しは実行時に失敗します（ &lt;code&gt;badarg&lt;/code&gt; を使用）。モジュール &lt;code&gt;dbg&lt;/code&gt; は実際にはこの名前の関数をエクスポートしますが、シェルで関数を使用する場合を除いて、この関数を実際に呼び出すことはできません。 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ヘッダーファイルを &lt;code&gt;parse_transform&lt;/code&gt; が適切に適用されている場合、コンパイルされたコードは関数を呼び出すことはありませんが、関数呼び出しはリテラルmatch_specに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="7c4c35e1fed61f85f87d7154c2244f967d2936c6" translate="yes" xml:space="preserve">
          <source>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</source>
          <target state="translated">パターンがアンチャンクされていない場合は、次の開始文字への通常の「バンパロン」進撃が発生します。バックトラッキングは、(*PRUNE)の左に通常通り、(*PRUNE)に到達する前、または(*PRUNE)の右に一致したときに発生しますが、右に一致するものがない場合、バックトラッキングは(*PRUNE)を越えることができません。単純なケースでは、(*PRUNE)の使用は、原子群や所有的量詞の代わりになるだけですが、(*PRUNE)には、他の方法では表現できない使用法があります。アンカードパターンでは、(*PRUNE)は(*COMMIT)と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="caf53e7076db6e332a206c64cff8afbb0ab34c47" translate="yes" xml:space="preserve">
          <source>If the permission of a loaded, but not started, application is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; but the application is not started until the permission is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ロードされたが開始されていないアプリケーションの許可が &lt;code&gt;false&lt;/code&gt; に設定されている場合、 &lt;code&gt;start&lt;/code&gt; は &lt;code&gt;ok&lt;/code&gt; を返しますが、許可が &lt;code&gt;true&lt;/code&gt; に設定されるまでアプリケーションは開始されません。</target>
        </trans-unit>
        <trans-unit id="fb5424927d13c1c2f8655ecb9fa4aea52eaa565c" translate="yes" xml:space="preserve">
          <source>If the permission of a running application is set to &lt;code&gt;false&lt;/code&gt;, the application is stopped. If the permission later is set to &lt;code&gt;true&lt;/code&gt;, it is restarted.</source>
          <target state="translated">実行中のアプリケーションの許可が &lt;code&gt;false&lt;/code&gt; に設定されている場合、アプリケーションは停止します。後でパーミッションを &lt;code&gt;true&lt;/code&gt; に設定すると、再起動されます。</target>
        </trans-unit>
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">portコマンドが中止された場合は &lt;code&gt;false&lt;/code&gt; が返され、それ以外の場合は &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">ポートドライバが同期制御動作をサポートしていない場合。</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">ポートドライバーが何らかの理由（おそらく &lt;code&gt;Operation&lt;/code&gt; または &lt;code&gt;Data&lt;/code&gt; に問題がある）で決定した場合。</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">何らかの理由でポートが終了した場合。</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Port&lt;/code&gt; で識別されるポートが開いていない場合、 &lt;code&gt;undefined&lt;/code&gt; が返されます。ポートが閉じていて、呼び出しプロセスが以前にポートにリンクされていた場合、 &lt;code&gt;port_info/2&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; を返す前に、ポートからの終了信号が確実に配信されます。</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">ポートがビジー状態の場合、ポートがそれ以上ビジー状態でなくなるまで呼び出し処理が中断されます。</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">ポートがビジー状態の場合、ポートがビジー状態でなくなるまで呼び出し処理が中断されます。</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">ポートプログラムが終了せずに &lt;code&gt;stdout&lt;/code&gt; を閉じる場合、オプション &lt;code&gt;exit_status&lt;/code&gt; は機能しません。</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">ポートプログラムを更新する場合、 &lt;code&gt;gen_server&lt;/code&gt; のコードは、古いポートを閉じて新しいポートを開く &lt;code&gt;code_change&lt;/code&gt; 関数で拡張できます。（必要に応じて、 &lt;code&gt;gen_server&lt;/code&gt; は最初にポートプログラムから保存する必要があるデータを要求し、このデータを新しいポートに渡すことができます）：</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:resume_process/1&lt;/code&gt; を呼び出すプロセスが、以前に &lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスの中断カウントを増やしていなかった場合。</target>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">プロセスが存在しない場合、 &lt;code&gt;noproc&lt;/code&gt; 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">呼び出しを実行するプロセスがどのアプリケーションにも属していない場合、関数は &lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">プロセスがメッセージキューにメッセージを持っている場合は、先に説明したのと同じ方法で直ちにプロセスを覚醒させます。</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; で識別されるプロセスに登録名がある場合は、項目 &lt;code&gt;registered_name&lt;/code&gt; を持つ &lt;code&gt;InfoTuple&lt;/code&gt; も含まれます。</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; で識別されるプロセスが既存のローカルプロセスでない場合。</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスが、現在使用されている内部データ構造で表すことができる回数よりも、呼び出しプロセスによって一時停止されている場合。システム制限は2,000,000,000を超えるサスペンドであり、これを下回ることはありません。</target>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスが生きていない場合。</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されるプロセスが &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; を呼び出すプロセスと同じプロセスである場合。</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスが別のノードにある場合。</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">プロセスが &lt;code&gt;InfoTuple&lt;/code&gt; で、単一の &lt;code&gt;Item&lt;/code&gt; が指定されている場合、 &lt;code&gt;Item =:= registered_name&lt;/code&gt; でプロセスに登録名がない場合を除き、戻り値は対応するInfoTupleです。この場合、 &lt;code&gt;[]&lt;/code&gt; が返されます。この奇妙な動作は歴史的な理由によるものであり、下位互換性のために残されています。</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">プロセスがfun &lt;code&gt;StateFun&lt;/code&gt; を使用して状態を置き換える場合、handle_system_msgは &lt;code&gt;handle_system_msg&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">プロセスがその状態を返す場合、 &lt;code&gt;handle_system_msg&lt;/code&gt; は以下を呼び出します。</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">プロセスやポートが既に登録されている場合(名前が既に登録されている場合)。</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">プロセスがそのキューで多くのメッセージを取得する可能性がある場合は、フラグを &lt;code&gt;off_heap&lt;/code&gt; に設定することをお勧めします。これは、ヒープに多くのメッセージが配置されたガベージコレクションが非常に高価になり、プロセスが大量のメモリを消費する可能性があるためです。ただし、実際のメッセージパッシングのパフォーマンスは、フラグ &lt;code&gt;off_heap&lt;/code&gt; を使用しないほうが一般に良くなります。</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">プロセスが &lt;code&gt;normal&lt;/code&gt; または &lt;code&gt;shutdown&lt;/code&gt; 以外の理由で終了した場合、クラッシュレポートが生成されます。クラッシュレポートの詳細については、 『SASLユーザーズガイド』を参照してください。</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">funを使用してプロセスが生成された場合、 &lt;code&gt;initial_call/1&lt;/code&gt; はfunを返さなくなりますが、モジュール、funを実装するローカル関数の関数、およびアリティ、たとえば &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; （ファンが関数 &lt;code&gt;some_module:work/3&lt;/code&gt; で作成されたことを意味します）。その理由は、楽しみを維持すると、モジュールのコードアップグレードが妨げられ、大量のメモリが浪費される可能性があるからです。</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">プログラムがでプロファイリングするには大きすぎる場合は &lt;code&gt;fprof&lt;/code&gt; または &lt;code&gt;eprof&lt;/code&gt; 、 &lt;code&gt;cprof&lt;/code&gt; はより徹底的に使用してプロファイルされるコードの部品配置するために使用することができます &lt;code&gt;fprof&lt;/code&gt; または &lt;code&gt;eprof&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">純粋なエンコード/デコード性能が本当に深刻な問題であれば、erlang配布フォーマットのエンコード/デコードが他のすべての選択肢よりもはるかに速いので、私たちのerl_distエンコーダを使うことができます。主な欠点は、有効なMegaco/H.248メッセージエンコーディングとして承認されていないことです。</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">定量化子が{0}の場合、マッチング中にアサーションに従うことはありません。しかし、サブルーチンの仕組みを利用して他の場所から呼び出される内部捕獲括弧付きグループを含むことができます。</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">正規表現に in のようなキャプチャサブパターンが含まれている場合。</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">正規表現が以前にコンパイルされている場合、オプションリストには以下のオプションのみを含めることができます。</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">正規表現がオプション &lt;code&gt;unicode&lt;/code&gt; を使用して以前にコンパイルされている場合、 &lt;code&gt;Subject&lt;/code&gt; は有効なUnicode &lt;code&gt;charlist()&lt;/code&gt; として提供されます。それ以外の場合は、 &lt;code&gt;iodata()&lt;/code&gt; が提供します。コンパイルが関係し、オプション &lt;code&gt;unicode&lt;/code&gt; が指定されている場合、 &lt;code&gt;Subject&lt;/code&gt; と正規表現の両方が有効なUnicode &lt;code&gt;charlists()&lt;/code&gt; として指定されます。</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">リリースをアップグレードする場合は、SASLアプリケーションも含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">リリースパッケージに新しいErlangランタイムシステムを含める場合、指定したランタイムシステムの &lt;code&gt;bin&lt;/code&gt; ディレクトリ &lt;code&gt;{erts,Dir}&lt;/code&gt; が &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">呼び出しのタイムアウト後に応答が到着した場合、この関数は仲介者プロセスを生成して、このような孤立した応答の（無効な）宛先として機能するため、呼び出し元のメッセージキューを汚染するメッセージはありません。この機能により、この関数は呼び出し側の &lt;code&gt;call/4&lt;/code&gt; よりも高価になります。</target>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">レポートブラウザーをオフラインで使用する場合、ブラウザーの起動時に指定した別のディレクトリにレポートをコピーできます。そのようなディレクトリが指定されていない場合、ブラウザはSASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; からレポートを読み取ります。</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">SFTPチャネルの要求関数が &lt;code&gt;{error, timeout}&lt;/code&gt; 返した場合、予想される時間内にサーバーから応答がありませんでした。</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">要求がHTTP / 1.1要求の場合、URIは絶対URI形式にすることができます。その場合、 &lt;code&gt;httpd&lt;/code&gt; はこのフィールドに絶対URIを保存します。絶対URIの例は &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">リクエストが正常にエンコードされて送信されたが、応答がタイムアウトした場合、 &lt;code&gt;Reason = timeout&lt;/code&gt; &lt;code&gt;handle_error/4&lt;/code&gt; コールバックが発生します。</target>
        </trans-unit>
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">リクエストが正常にエンコードされて送信されたが、問題のサービスが応答が受信される前に停止された場合、 &lt;code&gt;Reason = cancel&lt;/code&gt; して &lt;code&gt;handle_error/4&lt;/code&gt; コールバックが実行されます。</target>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">要求されたデータが利用可能である場合、サブエントリが関連付けられている &lt;code&gt;Name&lt;/code&gt; の要素の値を用いて読み取ることができるように &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; 提供 &lt;code&gt;Name&lt;/code&gt; 代わりに全体で使用される &lt;code&gt;Required&lt;/code&gt; 用語。</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">エミュレータの起動時にSTDLIB変数を設定して制限付きシェルをアクティブにし、コールバックモジュールをロードできない場合は、コマンド &lt;code&gt;q()&lt;/code&gt; および &lt;code&gt;init:stop()&lt;/code&gt; のみを許可するデフォルトの制限付きシェルがフォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; を使用して制限付きシェルがアクティブ化され、コールバックモジュールをロードできない場合、エラーレポートがエラーロガーに送信され、呼び出しは &lt;code&gt;{error,Reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">リスト内包の結果が&lt;strong&gt;明らか&lt;/strong&gt;に使用されない場合、リストは構成されません。たとえば、次のコードでは：</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; 場合、ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; が変更されたことを検出すると、タイムオフセットが変更されます。ただし、ランタイムシステムは、これが発生してもすぐには検出しません。時間オフセットをチェックするタスクは少なくとも1分に1回実行されるようにスケジュールされているため、通常の操作ではこれは1分以内に検出されますが、負荷が高い場合はさらに時間がかかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 場合、ランタイムシステムが &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; が変更されたことを検出すると、タイムオフセットが変更されます。ただし、ランタイムシステムは、これが発生してもすぐには検出しません。時間オフセットをチェックするタスクは、少なくとも1分に1回実行されるようにスケジュールされています。そのため、通常の操作ではこれは1分以内に検出されますが、負荷が高い場合は時間がかかることがあります。</target>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">スキーム &lt;code&gt;https&lt;/code&gt; を使用する場合は、 &lt;code&gt;SSL&lt;/code&gt; アプリケーションを開始する必要があります。 &lt;code&gt;https&lt;/code&gt; リンクがプロキシを経由する必要がある場合、HTTP-1.1へのCONNECTメソッド拡張を使用してトンネルを確立し、接続をTLSにアップグレードします。ただし、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; による「TLSアップグレード」はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">送信を行うために送信者を一時停止する必要がある場合は、代わりに &lt;code&gt;nosuspend&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーが構成ファイルで指定されていない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーが設定ファイルで指定されていない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーオプションが設定ファイルで指定されている場合、または名前付きクライアントがロギング目的で必要な場合（このモジュールでの &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; を参照）、代わりに &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">サーバーオプションが構成ファイルで指定されている場合は、代わりに &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">サーバーが、 &lt;code&gt;sni_hosts&lt;/code&gt; オプションにリストされているホストと一致するクライアントからSNI（サーバー名表示）を受信した場合、そのホストの特定のオプションは、以前に指定されたオプションをオーバーライドします。オプション &lt;code&gt;sni_fun&lt;/code&gt; および &lt;code&gt;sni_hosts&lt;/code&gt; は相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">サーバーがクライアントからSNI（サーバー名表示）を受信すると、指定されたサーバーの &lt;code&gt;[ssl_option()]&lt;/code&gt; を取得するために、指定された関数が呼び出されます。これらのオプションは、事前定義された &lt;code&gt;[ssl_option()]&lt;/code&gt; にマージされます。関数は、 &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; として定義する必要があり、funまたは名前付きの &lt;code&gt;fun module:function/1&lt;/code&gt; として指定できますmodule：function / 1オプション &lt;code&gt;sni_fun&lt;/code&gt; および &lt;code&gt;sni_hosts&lt;/code&gt; は相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">ファイルのサイズが減少した場合、変更は現在のログに直ちに影響します。すでにいっぱいになっているログファイルのサイズは、次に使用するまで変更されません。</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">プロセス内のライブデータのサイズが最小ヒープサイズよりも小さい場合、プロセスが目覚めた後に発生する最初のガベージコレクションは、ヒープサイズが最小ヒープサイズよりも小さくないサイズに変更されることを確実にします。</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">スキップされたテストケースがテストケースグループに属している場合、最初の引数はタプル &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; です。それ以外の場合は、関数名のみです。</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">snmpエージェントが分散Erlangアプリケーションとして設定されている場合、テイクオーバー時に古いノードでロードされたのと同じMIBをロードしようとします。古いノードと同じファイル名を使います。もしMIBが異なるノードの同じパスにない場合は、テイクオーバー後にMIBを明示的にロードしなければなりません。</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">ソケットがリスンソケットの場合、2つの目的のために別の(通常の)ファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">ソケットが閉じている場合は、以下のメッセージが配信されます。</target>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">ソケットが &lt;code&gt;{active, N}&lt;/code&gt; モード（詳細は &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; を参照）であり、そのメッセージカウンターが &lt;code&gt;0&lt;/code&gt; に下がると、ソケットがパッシブに移行したことを示す次のメッセージが配信されます（ &lt;code&gt;{active, false}&lt;/code&gt; ）モード：</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">ソケットがビジー状態の場合、ERTSソケット実装が内部でキューイングしているデータ量がこの制限値を下回ると、ソケットはビジー状態ではない状態に設定される。デフォルトは4kBです。</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">ソケットがアクティブモードでない場合は、 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; 呼び出しを通じてデータを取得できます。受信バッファオプションが指定するよりも長い到着UDPパケットは警告なしに切り捨てられる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">ソケットがアクティブモードに設定されている場合、この関数は呼び出し元のメールボックス内のメッセージを新しい制御プロセスに転送します。転送中に他のプロセスがソケットを操作していた場合、転送が正常に行われず、呼び出し元のメールボックスにメッセージが残る可能性があります。例えば、転送が完了する前にソケットのアクティブモードを変更すると、このような問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">ソケットメッセージキューがビジー状態の場合、メッセージキューのデータ量がこの制限値以下になると、ソケットメッセージキューはビジー状態ではない状態に設定される。この制限は、ERTSの内部ソケット実装にまだ到達していないデータにのみ関係することに注意してください。デフォルトは4キロバイトです。</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">&lt;code&gt;file:open/2&lt;/code&gt; を使用してソースファイルや出力ファイルを開くことができない場合、関数は &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;File&lt;/code&gt; はファイル名、 &lt;code&gt;Reason&lt;/code&gt; はエラーの理由です。</target>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">特殊プロセスがトラップ終了するように設定されていて、親プロセスが終了した場合、期待される動作は、同じ理由で終了することです。</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">指定された &lt;code&gt;SessionId&lt;/code&gt; が現在のセッションIDと等しい場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">指定されたアロケータタイプが有効でない場合、呼び出しは &lt;code&gt;{error, not_enabled}&lt;/code&gt; 失敗します。</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">指定されたアプリケーションがロードされていない場合、または呼び出しを実行しているプロセスがどのアプリケーションにも属していない場合、関数は &lt;code&gt;[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">指定されたアプリケーションがロードされていない場合、関数は &lt;code&gt;undefined&lt;/code&gt; を返します。呼び出しを実行するプロセスがどのアプリケーションにも属していない場合、関数は &lt;code&gt;[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">指定されたプロセスがどのアプリケーションにも属していない場合、または指定されたプロセスまたはモジュールが存在しない場合、関数は &lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">起動手順が失敗した場合、関数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; は暗号のタプル &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; 返します。起動の失敗に関する詳細情報を取得するには、 &lt;code&gt;erl&lt;/code&gt; スクリプトの引数としてコマンドライン引数 &lt;code&gt;-boot start_sasl&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">状態が変化した場合、着信イベントのキューはリセットされ、最も古く延期されたものから開始されます。</target>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">ステータスが &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;ok_simultaneous&lt;/code&gt; の場合、ハンドシェイクは &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; に別のメッセージであるチャレンジを送信して続行します。チャレンジには、最初に &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;B&lt;/code&gt; に送信された「名前」メッセージと同じタイプの情報と、32ビットのチャレンジが含まれています。</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">スキーマのストレージタイプが &lt;code&gt;ram_copies&lt;/code&gt; 、つまりディスクのないノードの場合、 &lt;code&gt;Mnesia&lt;/code&gt; はその特定のノードでディスクを使用しません。ディスクの使用は、テーブル &lt;code&gt;schema&lt;/code&gt; ストレージタイプを &lt;code&gt;disc_copies&lt;/code&gt; に変更することで有効になります。</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">構造化タイプに &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; が埋め込まれたコンポーネントがあり、その埋め込みタイプが &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; である場合、次の例のように、 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; オプションが追加されたレコードが得られます。</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">この例のようにスタイルシートがインストールされている場合、カテゴリは問題のスイートにプライベートです。これらは、スイート内のすべてのテストケースで使用できますが、他のスイートでは使用できません。スイートプライベートスタイルシートが指定されている場合は、グローバルスタイルシート（フラグ &lt;code&gt;-stylesheet&lt;/code&gt; で指定されたもの）が優先されます。スタイルシートタプル（上記の &lt;code&gt;suite/0&lt;/code&gt; によって返される）は、テストケース情報関数から返すこともできます。この場合、スタイルシートで指定されたカテゴリは、その特定のテストケースでのみ使用できます。スイートまたはグローバルレベルのスタイルシートを優先して、テストケースのプライベートスタイルシートが使用されます。</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">主語が &quot;aaaac...&quot; の場合、最初のマッチ試行が失敗した後 (文字列の最初の文字から開始)、開始点はスキップして次の試行を &quot;c&quot; から開始します。所有的量詞は、この例と同じ効果を持たないことに注意してください。最初のマッチ試行中にバックトラッキングを抑制しますが、2回目の試行では &quot;c &quot;にスキップするのではなく、2文字目から始まります。</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">主語が &quot;abac &quot;の場合、Perlはマッチしますが、グループの2回目のリピートにある(*COMMIT)が作用するため、PCREは失敗します。</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">主語が「バ」の場合、このパターンはマッチしません。.*?はgreedyではないので、最初は0文字にマッチします。その後、条件 (?=a)は失敗し、文字 &quot;b&quot; は一致しますが、&quot;c&quot; は一致しません。この時点では、おそらく「|」文字の存在から予想されるように、マッチングは.*? 条件付きサブパターンは、パターン全体を構成する単一の選択肢の一部であるため、マッチングは失敗します。(もし、.*?へのバックトラックがあり、それが &quot;b &quot;にマッチするようになっていれば、マッチは成功します)。</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">主語が「xyz123abc123」であれば、一致点は4文字目である。したがって、このようなパターンは暗黙のうちにアンカリングされません。</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">サブシステムオプションが存在しない場合、 &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; の値が使用されます。これにより、デフォルトでsftpサブシステムが有効になります。デーモンがサブシステムを実行しないようにする場合は、オプションを空のリストに設定できます。</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">スーパーバイザとその子プロセスが正常に作成された場合（つまり、すべての子プロセスの開始関数が &lt;code&gt;{ok,Child}&lt;/code&gt; 、 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; を返した場合）、関数は &lt;code&gt;{ok,Pid}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; スーパーバイザーのPIDです。</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">スーパーバイザブリッジとサブシステムが正常に起動すると、関数は &lt;code&gt;{ok,Pid}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はスーパーバイザブリッジのpidです。</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">スーパーバイザが &lt;code&gt;simple_one_for_one&lt;/code&gt; の場合、 &lt;code&gt;Id&lt;/code&gt; は子プロセスの &lt;code&gt;pid()&lt;/code&gt; である必要があります。指定されたプロセスは &lt;code&gt;{error,not_found}&lt;/code&gt; であるが、指定されたスーパーバイザの子ではない場合、関数は{error、not_found}を返します。 &lt;code&gt;pid()&lt;/code&gt; の代わりに子仕様識別子が指定されている場合、関数は &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">スーパーバイザが &lt;code&gt;simple_one_for_one&lt;/code&gt; でない場合、 &lt;code&gt;Id&lt;/code&gt; は子仕様識別子である必要があります。プロセスがあれば終了し、一時的な子でない限り、子の仕様はスーパーバイザによって保持されます。子プロセスは、スーパーバイザが後で再起動できます。子プロセスは、 &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; を呼び出すことによって明示的に再起動することもできます。子仕様を削除するには、 &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">スーパーバイザが実行されていない場合、関数は &lt;code&gt;badarg&lt;/code&gt; という理由で失敗します。</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスの中断カウントが増加した &lt;code&gt;true&lt;/code&gt; はtrueが返され、それ以外の場合は &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">再帰的なサブパターン呼び出しのための構文(番号または名前による)が、それが参照する括弧の外で使われる場合、それはプログラミング言語のサブルーチンのように動作します。呼び出されるサブパターンは、参照の前にも後にも定義することができます。番号付きの参照は、以下の例のように、絶対的なものでも相対的なものでもよい。</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">システムが複数のErlangノードで構成されている場合、各ノードは独自のバージョンのリリースを使用できます。リリースハンドラーはローカルに登録されたプロセスであり、アップグレードまたはダウングレードが必要な各ノードで呼び出す必要があります。リリース処理命令 &lt;code&gt;sync_nodes&lt;/code&gt; を使用して、いくつかのノードでリリースハンドラプロセスを同期できます &lt;code&gt;appup(4)&lt;/code&gt; マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">システムがBIF &lt;code&gt;erlang:halt/1&lt;/code&gt; によって停止されている場合、スローガンはBIFに渡される文字列パラメーターです。それ以外の場合は、エミュレーターまたは（Erlang）カーネルによって生成される説明です。通常、メッセージは問題を理解するのに十分ですが、いくつかのメッセージがここで説明されています。提案されたクラッシュの理由は&lt;strong&gt;単なる提案&lt;/strong&gt;であることに注意してください。エラーの正確な理由は、ローカルアプリケーションと基になるオペレーティングシステムによって異なります。</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">ハートビートがないためにシステムを再起動する場合、またはErlangランタイムシステムが終了した場合は、システムを起動する前に環境変数 &lt;code&gt;HEART_COMMAND&lt;/code&gt; を設定する必要があります。この変数が設定されていない場合、警告テキストが出力されますが、システムは再起動しません。</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">システムのアップグレードに失敗した場合は、 &lt;code&gt;Mnesia&lt;/code&gt; はすべてに再起動する必要があります &lt;code&gt;db_nodes&lt;/code&gt; 古いデータベースを復元します。フォールバックは、正常に起動すると自動的に削除されます。関数 &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; を使用して、システムのアップグレードが成功した後にフォールバックを削除することもできます。繰り返しますが、これはすべての &lt;code&gt;db_nodes&lt;/code&gt; 実行されるか、まったく実行されない分散操作です。フォールバックのインストールと削除の両方で、Erlangがすべての &lt;code&gt;db_nodes&lt;/code&gt; で動作可能である必要がありますが、 &lt;code&gt;Mnesia&lt;/code&gt; が実行されているかどうかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">システムがリリース処理を使用する場合、これは &lt;code&gt;start_erl.exe&lt;/code&gt; のようなプログラムに設定されます。</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; を使用してテーブルが修正されている場合、呼び出しはタプルを返します。ここで、 &lt;code&gt;FixationTime&lt;/code&gt; は、テーブルがプロセスによって最初に修正された時刻であり、現在までに修正されているプロセスの1つであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">テーブルがハッシュテーブルの場合、つまり、 &lt;code&gt;ordered_set&lt;/code&gt; でない場合。</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">テーブルがハッシュテーブルの場合。最大値、最小値、平均チェーン長などのテーブルに関する統計情報が含まれます。最大値が平均よりもはるかに大きく、標準偏差が期待される標準偏差よりもはるかに大きいということは、何らかの理由で項のハッシュ処理がうまくいかないことを示しています。</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">テーブルが &lt;code&gt;ordered_set&lt;/code&gt; の場合。（要素の数は、テーブル内のオブジェクトの数と同じです。）</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">テーブルが削除された場合、同じ名前で別の名前付きテーブルが作成されても、 &lt;code&gt;tid()&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">テーブルが空の場合、 &lt;code&gt;'$end_of_table'&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">テーブルが &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; または何らかの内部メカニズムを使用して修正されている場合。</target>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">テーブルが修正されていない場合、呼び出しは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;ordered_set&lt;/code&gt; であり、挿入されたオブジェクトのキーがテーブル内のオブジェクトのキー&lt;strong&gt;と等しい場合&lt;/strong&gt;、古いオブジェクトが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; て、指定されたキーを持つ複数のオブジェクトが存在する場合、オブジェクトの1つが選択されます。これは必ずしも、入力関数によって返されたオブジェクトのシーケンスで指定されたキーを持つ最後のオブジェクトであるとは限りません。キーの重複を避けます。そうしないと、ファイルが不必要に断片化されます。これは、 &lt;code&gt;bag&lt;/code&gt; タイプのテーブルに格納されている複製オブジェクトにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; て、指定されたキーを持つ複数のオブジェクトが存在する場合、オブジェクトの1つが選択されます。これは必ずしも、入力関数によって返されたオブジェクトのシーケンスで指定されたキーを持つ最後のオブジェクトであるとは限りません。これは、 &lt;code&gt;bag&lt;/code&gt; タイプのテーブルに格納されている複製オブジェクトにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; ていて、挿入されたオブジェクトのキーがテーブル内のオブジェクトのキーと&lt;strong&gt;一致&lt;/strong&gt;する場合、古いオブジェクトが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">テーブルタイプが &lt;code&gt;set&lt;/code&gt; 場合、指定されたキーを持つオブジェクトは複数存在できないため、関数は空のリストまたは1つのオブジェクトを含むリストを返します。テーブルタイプが &lt;code&gt;bag&lt;/code&gt; または &lt;code&gt;duplicate_bag&lt;/code&gt; の場合、関数は任意の長さのリストを返します。</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">キーが等しいか &lt;code&gt;qlc&lt;/code&gt; 比較するときにテーブルが &lt;code&gt;==/2&lt;/code&gt; を使用する場合、qlcモジュールはQLCで使用されている演算子に関係なく定数を検索します。ただし、 &lt;code&gt;==/2&lt;/code&gt; が推奨されます。</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">テーブルが圧縮されていた場合</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">対象のホストが「特殊」ノードの場合は、設定ファイルに以下のようにFTPアドレスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">ターゲットホストが他のもの、例えばUNIXホストの場合、設定ファイルにはユーザ名とパスワード(両方の文字列)も含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">テストケース関数が意図的にクラッシュまたは終了した場合、&lt;strong&gt;失敗し&lt;/strong&gt;たと見なされます。値が返された場合（どのような値でも）、成功したと見なされます。このルールの例外は、戻り値 &lt;code&gt;{skip,Reason}&lt;/code&gt; です。このタプルが返された場合、テストケースはスキップされたと見なされ、ログに記録されます。</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テストケースがタプル &lt;code&gt;{comment,Comment}&lt;/code&gt; 返す場合、ケースは成功と見なされ、 &lt;code&gt;Comment&lt;/code&gt; が概要ログファイルに出力されます。これは、 &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">オプション &lt;code&gt;create_priv_dir&lt;/code&gt; を &lt;code&gt;manual_per_tc&lt;/code&gt; に設定してテストを開始した場合、テストケースでプライベートディレクトリを使用するには、まずこの関数を呼び出してテストケースを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">代わりに &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; 呼び出してテストセッションを開始した場合、結果として、テスト &lt;code&gt;t1&lt;/code&gt; は &lt;code&gt;ct_node@host_x&lt;/code&gt; （または他のノード）では実行されません。テスト &lt;code&gt;t3&lt;/code&gt; は &lt;code&gt;ct_node@host_y&lt;/code&gt; と &lt;code&gt;ct_node@host_z&lt;/code&gt; 両方で実行されます。</target>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">括弧内のテキストが一連の数字で構成されている場合、その番号のキャプチャサブパターンが以前に一致していれば、条件は真です。同じ番号のキャプチャサブパターンが複数存在する場合（前述の「 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 」を参照）、それらのいずれかが一致した場合、条件は真です。別の表記法では、数字の前にプラス記号またはマイナス記号を付けます。この場合、サブパターン番号は絶対ではなく相対です。最近開いた括弧は（？（-1）で参照でき、次の最新の括弧は（？（-2）で参照できます。以下同様です。ループ内では、後続のグループを参照することも意味があります。次の括弧（？（+ 1）などのように開くことができます（これらのフォームの値0は使用されません。コンパイル時にエラーが発生します）。</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">タイマーのタイプが &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; 場合、中間タイムアウトごとに応答が再送信されます（これは、ACKが受信されるか、タイマーが期限切れになるまで有効です）。</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">トレースタプルに5つの要素がある場合、5番目の要素が &lt;code&gt;Opts&lt;/code&gt; マップの &lt;code&gt;extra&lt;/code&gt; 値として送信されます。</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">トレースされたノードがディスクレスの場合、 &lt;code&gt;ttb&lt;/code&gt; はディスクにアクセスできるトレースコントロールノードから &lt;code&gt;file&lt;/code&gt; 必要があり、オプションファイルを指定して、値 &lt;code&gt;{local, File}&lt;/code&gt; で &lt;code&gt;tracer/2&lt;/code&gt; を機能させる必要があります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">トレースプロセス/ポートが停止するか、トレーサモジュールが &lt;code&gt;remove&lt;/code&gt; を返す場合、フラグは警告なしに削除されます。</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">関数が戻った後にトレースを続行する必要がある場合、たとえば、プロファイルされるプロセスを生成する開始関数である場合は、 &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; を使用できます。 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; を使用して、後で適切なタイミングでトレースを停止する必要があります。</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">要求が送信された後、応答が受信される前に、ピアとのトランスポート接続がダウンした場合、要求が代替ピアに再送信されます。そのようなピアが利用できない場合、または後続の &lt;code&gt;pick_peer/4&lt;/code&gt; コールバックが候補を拒否する場合、 &lt;code&gt;handle_error/4&lt;/code&gt; コールバックは &lt;code&gt;Reason = failover&lt;/code&gt; 行われます。ピアが選択されると、 &lt;code&gt;prepare_retransmit/3&lt;/code&gt; コールバックが &lt;code&gt;prepare_request/3&lt;/code&gt; ます。その後、セマンティクスは、最初のprepare_request / 3コールバックと同じです。</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">アップグレードやダウングレードに失敗すると、アプリケーションが矛盾した状態になってしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">ユーザーが何らかの理由でトレーストークンをポートに渡したい場合は、ポート制御プロセスのコードで手動で行う必要があります。プロセスを制御するポートは、適切な順次トレース設定（ &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; から取得）をチェックし、それぞれのポートに送信されるメッセージデータにトレース情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">ユーザがテスト用のテストスイートのディレクトリ全体を指定した場合、スイートの実行順序は、オペレーティングシステムがどのようにファイルをリストアップするかに依存しますが、これはシステム間で異なります。</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">ユーザは、（例えば、開始フラグ/オプションでのみトップディレクトリを指定することにより、テストオブジェクト（またはOTPアプリケーション）のために、すべてのテストスイートを実行したい場合は &lt;code&gt;dir&lt;/code&gt; ）、 &lt;code&gt;Common Test&lt;/code&gt; 、主に名前のサブディレクトリにテストスイートのモジュールを探します &lt;code&gt;test&lt;/code&gt; 。このサブディレクトリが存在しない場合、指定されたトップディレクトリがテストディレクトリであると想定され、代わりにそこからテストスイートが読み取られます。</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">ユーザーがレコードを更新したい場合は、 &lt;code&gt;write/sticky_write&lt;/code&gt; としてwrite / sticky_writeを使用する方が効率的 &lt;code&gt;LockKind&lt;/code&gt; 。テーブルで多数決チェックがアクティブな場合、書き込みロックが試行されるとすぐにチェックされます。多数決条件が満たされない場合、これを使用してすばやく終了できます。</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">ユーザーが負荷値を機械容量に対するパーセンテージとして表示したい場合、負荷値が固定間隔に制限されていないため、この測定方法では問題が発生します。この場合、以下の簡単な数学的変換により、負荷値をパーセンテージで表示することができます。</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">ユーザの DSA、RSA、または ECDSA 鍵がパスフレーズで保護されている場合、これらのオプションを提供することができます。</target>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">値が &lt;code&gt;false&lt;/code&gt; （パッシブモード）の場合、プロセスは &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; （ソケットのタイプに応じて）を呼び出して、着信データを明示的に受信する必要があります）。</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">値が &lt;code&gt;false&lt;/code&gt; の場合、Igorは、 &lt;code&gt;-include(...).&lt;/code&gt; などのプリプロセッサーディレクティブの拡張を回避するために、Erlangプリプロセッサー（ &lt;code&gt;epp&lt;/code&gt; ）を介さずにソースファイルを読み取ります。、 &lt;code&gt;-define(...).&lt;/code&gt; および &lt;code&gt;-ifdef(...)&lt;/code&gt; 、および &lt;code&gt;?LINE&lt;/code&gt; や &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; などのマクロ呼び出し。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。つまり、前処理は行われません。 （詳細については、モジュール &lt;code&gt;epp_dodger&lt;/code&gt; を参照してください。）</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;once&lt;/code&gt; （ &lt;code&gt;{active, once}&lt;/code&gt; ）の場合、ソケットからの&lt;strong&gt;1つの&lt;/strong&gt;データメッセージがプロセスに送信されます。さらに1つのメッセージを受信するには、オプション &lt;code&gt;{active, once}&lt;/code&gt; &lt;code&gt;setopts/2&lt;/code&gt; 再度呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、元のコードのすべての &lt;code&gt;-import(...)&lt;/code&gt; 宣言が結果で展開されます。それ以外の場合は、元のインポート宣言が可能な限り保持されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべてのインポート文が削除され、インポートされた関数の呼び出しが明示的なリモート呼び出しに拡張されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべての情報メッセージと警告メッセージが抑制されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、すべてが「 &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; 」に一致します。ここで、 &lt;code&gt;E&lt;/code&gt; はcase-、if-、またはreceive-expressionであり、そのブランチはすべてnタプルを返す（または明示的に例外をスローする）と書き直されます変数 &lt;code&gt;V1&lt;/code&gt; 、...、 &lt;code&gt;Vn&lt;/code&gt; を直接バインドしてエクスポートします。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、コードの変更方法に影響するすべてのオプションが「変更なし」に設定されます。たとえば、ガードテストのみを更新するには、オプション &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; 使用します。（リストの先頭に近いオプションほど優先順位が高いことを思い出してください。）</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;lists:map/2&lt;/code&gt; および &lt;code&gt;lists:filter/2&lt;/code&gt; の呼び出しは、リスト内包表記を使用して書き換えられます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、新しいファイルが書き込み用に開かれる前に、既存のファイルの名前が変更されます。新しい名前は、 &lt;code&gt;backup_suffix&lt;/code&gt; オプションで指定された文字列を元の名前に追加することによって形成されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">値がある場合は &lt;code&gt;true&lt;/code&gt; 、ガードのテストではなく、新しいものの古い名前を使用するように変更され、例えば「 &lt;code&gt;integer(X)&lt;/code&gt; 」ではなく「の &lt;code&gt;is_integer(X)&lt;/code&gt; 」。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。このオプションは、 &lt;code&gt;new_guard_tests&lt;/code&gt; オプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ガードテストは新しい名前を使用するように更新されます。たとえば、「 &lt;code&gt;is_integer(X)&lt;/code&gt; 」ではなく「is_integer &lt;code&gt;integer(X)&lt;/code&gt; 」です。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。 &lt;code&gt;old_guard_tests&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ディスクに書き込まれるファイルの代わりに、標準出力に出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ターゲットモジュールがどの入力モジュールとも同じ名前でなくても、結果のモジュールの上部にバナーコメントは追加されません。代わりに、IGORは、コードが出力の上部にあるモジュールの外観を保持しようとします。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ファイルは変更されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ファイルは変更されません。これは通常、 &lt;code&gt;verbose&lt;/code&gt; フラグが有効になっている場合に最も役立ち、プログラムファイルに影響を与えずにレポートを生成します。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、特定の入力モジュールに由来するコードの各セクションの先頭で、結果のモジュールにヘッダーコメントは追加されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。これは、2つ以上のモジュールがマージされるたびにセクションヘッダーが通常追加されることを意味します。</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ソースコードを読み取るときに前処理が行われます。詳細については、 &lt;code&gt;merge_files/4&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;quiet&lt;/code&gt; オプションが &lt;code&gt;true&lt;/code&gt; でない限り、プログラムの実行中に進捗メッセージが出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;quiet&lt;/code&gt; オプションが &lt;code&gt;true&lt;/code&gt; でない限り、プログラムの実行中に進捗メッセージが出力されます。 &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; を呼び出すときのデフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、プログラムの実行中に進捗メッセージが出力されます。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、元のファイルのソースコードコメントは出力に保持されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、ターゲットモジュールと同じ名前ではないすべてのエクスポートされたモジュールに対してスタブモジュールファイルが自動的に生成されます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、サブディレクトリは再帰的にアクセスされます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、シンボリックディレクトリリンクをたどります。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、結果のコードは &lt;code&gt;erl_tidy&lt;/code&gt; モジュールを使用して処理されます。これにより、未使用の関数が削除され、一般的なコードのクリーンアップが行われます。（追加オプションについては、 &lt;code&gt;erl_tidy:module/2&lt;/code&gt; を参照してください。）デフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、これは、 &lt;code&gt;export&lt;/code&gt; オプションですべての入力モジュールをリストすることと同じです。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、未使用の関数はコードから削除されません。デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; （デフォルト）の場合、ソケットから受信したすべてがメッセージとして受信プロセスに送信されます。</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;yes&lt;/code&gt; の場合、入力ソースのすべてのファイル属性 &lt;code&gt;-file(...)&lt;/code&gt; が結果のコードに保持されます。値が &lt;code&gt;comment&lt;/code&gt; の場合、コメントに変換されますが、他のソースコードフォームに対してコード内の元の位置に残ります。値が &lt;code&gt;no&lt;/code&gt; の場合、コメントが添付されていない限り、すべてのファイル属性がコードから削除されます。この場合、 &lt;code&gt;comment&lt;/code&gt; 場合と同様に処理されます。デフォルト値は &lt;code&gt;no&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;yes&lt;/code&gt; の場合、コードで重要な変更が行われた場所にコメントが挿入されます。値がある場合は &lt;code&gt;always&lt;/code&gt; 、&lt;strong&gt;すべて&lt;/strong&gt;のコードへの変更はコメントされます。値が &lt;code&gt;no&lt;/code&gt; の場合、コメントなしで変更が行われます。デフォルト値は &lt;code&gt;yes&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">値が-32768〜32767の範囲の整数 &lt;code&gt;N&lt;/code&gt; である場合、値は、制御プロセスに送信されたデータメッセージのソケットの数に追加されます。ソケットのデフォルトのメッセージ数は &lt;code&gt;0&lt;/code&gt; です。負の値が指定され、その大きさがソケットの現在のメッセージ数以上の場合、ソケットのメッセージ数は &lt;code&gt;0&lt;/code&gt; に設定されます。受信したデータメッセージをプロセスに送信するため、または明示的に設定することによって、ソケットのメッセージカウントが &lt;code&gt;0&lt;/code&gt; に達すると、ソケットのタイプに固有の特別なメッセージによって、ソケットがパッシブモードになったことがプロセスに通知されます。ソケットがパッシブモードに入ると、より多くのメッセージを受信するために &lt;code&gt;setopts/2&lt;/code&gt; ソケットをアクティブモードに戻すには、再度呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">値に到達していない場合は、その接続に対してソケットを閉じます。</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">オプション &lt;code&gt;keep_labels&lt;/code&gt; の値が &lt;code&gt;true&lt;/code&gt; （デフォルト）の場合、頂点の &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;Digraph&lt;/code&gt; エッジがサブグラフにも使用されます。値が &lt;code&gt;false&lt;/code&gt; の場合、サブグループの頂点とエッジにはデフォルトのラベル &lt;code&gt;[]&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">オプションの値ならば &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;inherit&lt;/code&gt; デフォルトである、のタイプの &lt;code&gt;Digraph&lt;/code&gt; 、同様部分グラフに使用されます。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; のオプション値は &lt;code&gt;digraph:new/1&lt;/code&gt; の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os_mon.app&lt;/code&gt; にリストされている値がニーズに合わない場合は、そのファイルを編集し&lt;strong&gt;ないで&lt;/strong&gt;ください。代わりに、&lt;strong&gt;システム構成ファイルの&lt;/strong&gt;値を&lt;strong&gt;オーバーライド&lt;/strong&gt;します。そのフルパス名は、コマンドラインで &lt;code&gt;erl&lt;/code&gt; に指定されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">変数 &lt;code&gt;V&lt;/code&gt; がバインドされていない場合は、キー &lt;code&gt;K&lt;/code&gt; 関連付けられている値にバインドされます。これは、マップ &lt;code&gt;M&lt;/code&gt; に存在する必要があります。変数 &lt;code&gt;V&lt;/code&gt; がバインドされている場合、それは &lt;code&gt;M&lt;/code&gt; の &lt;code&gt;K&lt;/code&gt; に関連付けられた値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">変数が &lt;code&gt;0&lt;/code&gt; 秒に設定されている場合、ランタイムシステムはクラッシュダンプファイルへの書き込みを試みません。終了するだけです。オプションの場合、これがデフォルトです &lt;code&gt;-heart&lt;/code&gt; がに渡され &lt;code&gt;erl&lt;/code&gt; と &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; が設定されていません。</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">変数が正の値 &lt;code&gt;S&lt;/code&gt; に設定されている場合、 &lt;code&gt;S&lt;/code&gt; 秒間待機してクラッシュダンプファイルを完了し、ランタイムシステムを &lt;code&gt;SIGALRM&lt;/code&gt; シグナルで終了します。</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">検証コールバックfunが常に &lt;code&gt;{valid, UserState}&lt;/code&gt; 返す場合、検証の失敗に関してTLS / DTLSハンドシェイクは終了せず、接続が確立されます。</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{fail, Reason}&lt;/code&gt; 返す場合、検証プロセスは直ちに停止され、アラートがピアに送信され、TLS / DTLSハンドシェイクが終了します。</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{fail, Reason}&lt;/code&gt; 返した場合、検証プロセスはすぐに停止されます。検証コールバックfunが &lt;code&gt;{valid, UserState}&lt;/code&gt; 返した場合、検証プロセスが続行されます。これは、 &lt;code&gt;selfsigned_peer&lt;/code&gt; などの特定のパス検証エラーを受け入れるため、およびアプリケーション固有の拡張機能を検証するために使用できます。ユーザーアプリケーションに不明な拡張子で呼び出された場合、戻り値 &lt;code&gt;{unknown, UserState}&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">検証コールバックfunが &lt;code&gt;{valid, UserState}&lt;/code&gt; 返した場合、検証プロセスが続行されます。</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">開発システムの &lt;code&gt;OTP_VERSION&lt;/code&gt; ファイルから読み取られたバージョンに &lt;code&gt;**&lt;/code&gt; サフィックスが付いている場合、システムには &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; ツールを使用してパッチが適用されています。この場合、システムは複数のOTPバージョンのアプリケーションバージョンで構成されます。 &lt;code&gt;**&lt;/code&gt; サフィックスの前のバージョンは、パッチが適用された基本システムのOTPバージョンに対応しています。 &lt;code&gt;otp_patch_apply&lt;/code&gt; 以外の方法で開発システムが更新された場合、OTP_VERSIONファイルが誤ったOTPバージョンを識別できることに &lt;code&gt;OTP_VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">すべてのファイルがまだ使用されていないため &lt;code&gt;{error, end_of_log}&lt;/code&gt; ない場合、ログの外に出ようとすると、{error、end_of_log}が返されます。</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">その後、モジュールの新しいインスタンスがロードされると(例えば、エラー修正のために)、前のインスタンスのコードは「古い」になり、前のインスタンスを参照しているすべてのエクスポートエントリが削除されます。その後、新しいインスタンスは初めてロードされ、'current' になります。</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">指定された識別子を &lt;code&gt;ChildSpec&lt;/code&gt; 仕様がすでに存在する場合、ChildSpecは破棄され、対応する子プロセスが実行されているかどうかに応じて、関数は &lt;code&gt;{error,already_present}&lt;/code&gt; または &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">指定された &lt;code&gt;SupBridgeName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">指定された &lt;code&gt;SupName&lt;/code&gt; を持つプロセスがすでに存在する場合、関数は &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 返します。ここで、 &lt;code&gt;Pid&lt;/code&gt; はそのプロセスのpidです。</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">モジュールの現在のコードがすでに存在する場合、そのコードは現在のままであり、 &lt;code&gt;on_load&lt;/code&gt; 関数が戻るまで呼び出すことができます。場合 &lt;code&gt;on_load&lt;/code&gt; の機能に障害が発生し、現在のコードは、（もしあれば）現在のままになります。モジュールには、現在のコードが存在しない場合は、前のモジュールへの外部呼び出しを行う任意のプロセス &lt;code&gt;on_load&lt;/code&gt; まで機能が終了したが中断されます &lt;code&gt;on_load&lt;/code&gt; の機能が完成しています。</target>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">キューに入れられたイベントがある場合、おそらく新しい状態の &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; が最も古いキューに入れられたイベントで呼び出され、このリストの先頭から再び開始します。</target>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">ハイバネーションが要求されたときに処理するキューに入れられたイベントがある場合、休止状態ではなく &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; を呼び出すことでこれが最適化され、 &lt;code&gt;gen_statem&lt;/code&gt; がハイバネーションに入り、キューに入れられたイベントによってすぐに起動します。</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">複数の modify_algorithms オプションがある場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">イテレータに関連付けがなくなると、 &lt;code&gt;none&lt;/code&gt; も返されません。</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">テーブルにレコードがない場合、この関数はアトム &lt;code&gt;'$end_of_table'&lt;/code&gt; 返します。このアトムをユーザーレコードのキーとして使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">テーブルにレコードがない場合、この関数はアトム &lt;code&gt;'$end_of_table'&lt;/code&gt; 返します。したがって、このアトムをユーザーレコードのキーとして使用することは非常に望ましくありませんが、禁止されていません。</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">適切なピアがない場合、または &lt;code&gt;pick_peer/4&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すことでそれらを拒否した場合は、 &lt;code&gt;{error,no_connection}&lt;/code&gt; が返されます。それ以外の場合、 &lt;code&gt;pick_peer/4&lt;/code&gt; の後に &lt;code&gt;prepare_request/3&lt;/code&gt; コールバックが続き、メッセージはエンコードされてから送信されます。</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">接続で開いているNETCONFセッションがある場合、これらは残酷に中止されます。これを回避するには、各セッションを &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt; で閉じます。</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">ドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、ドライバーの参照カウントは減少するだけなので、呼び出し元はドライバーの &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; とは見なされなくなります。使用シナリオ &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; は、このモジュールの冒頭の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">ドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、ドライバーの参照カウントは単に減少するだけなので、呼び出し元は &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; とは見なされなくなります。使用シナリオ &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; は、このモジュールの冒頭の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">このドライバーの他の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; がいる場合、関数は &lt;code&gt;{error, pending_process}&lt;/code&gt; 返しますが、他のユーザーがいない場合、開いているすべてのポートが閉じるまで、関数呼び出しはハングします。</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">アクティブなテーブルレプリカが2つある場合、1つのレプリカが失敗してもすべての情報が利用可能です。これは多くのアプリケーションで重要な特性となります。さらに、テーブルレプリカが2つの特定のノードに存在する場合、これらのノードのいずれかで実行するアプリケーションは、ネットワークにアクセスせずにテーブルからデータを読み取ることができます。ネットワーク操作は、ローカル操作よりもかなり遅く、より多くのリソースを消費します。</target>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">プロセスに例外がなかった場合、スタックトレースは &lt;code&gt;[]&lt;/code&gt; です。プロセスのコードを変更した後、スタックトレースを &lt;code&gt;[]&lt;/code&gt; にリセットすることもできます。</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">NOがない場合は &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドには、 &lt;code&gt;Subject&lt;/code&gt; フィールドがチェックされます。すべての &lt;code&gt;CN&lt;/code&gt; 名がすべてのホスト名と比較されます</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">存在する場合に &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールド、 &lt;code&gt;{uri_id,string()}&lt;/code&gt; 関数呼び出しで任意に比較される &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; 証明書のフィールドです。2つの &lt;code&gt;strings()&lt;/code&gt; が等しい場合（大文字と小文字は区別されません）、一致があります。同じことが、任意に適用 &lt;code&gt;{dns_id,string()}&lt;/code&gt; すべてと比較されるコールに &lt;code&gt;{dNSName,string()}&lt;/code&gt; 証明書のフィールドです。</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">存在する場合に &lt;code&gt;Value&lt;/code&gt; に &lt;code&gt;List&lt;/code&gt; するよう &lt;code&gt;Pred(Value)&lt;/code&gt; を返し &lt;code&gt;true&lt;/code&gt; 、戻り &lt;code&gt;{value, Value}&lt;/code&gt; 最初のそのようなための &lt;code&gt;Value&lt;/code&gt; 、それ以外の場合は返し &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">右側にマッチング失敗がある場合、(*PRUNE)にバックトラックすると、それがトリガーされ、そのアクションが実行されます。(*COMMIT)へのバックトラックはありえません。</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">もしテキストのどこかに構文エラーがあった場合(上の2つ目の節のセミコロンの欠落など)、Merlはあなたのソースコードの正確な行を示すエラーメッセージを生成します。(リストの中の文字列はカンマで区切ることを忘れないでください。そうしないとErlangは文字列の断片をあたかも一つの文字列であるかのように連結してしまいます)</target>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ソケットポートにバッファリングされているデータがある場合、そのデータがカーネルソケット送信バッファに書き込まれるまで、ソケットをシャットダウンする試みは延期されます。エラーが発生した場合、ソケットは閉じられ、次の &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;{error, closed}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">同じ名前のサブパターンが複数ある場合は、最も古いものを使用します。</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">メールボックスに一致するメッセージがない場合は、直ちにタイムアウトとなります。</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">真のガードシーケンスと一致するパターンがない場合、 &lt;code&gt;case_clause&lt;/code&gt; ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">指定された型の公開鍵が利用できない場合、対応するエントリは無視されます。利用可能なセットは、基礎となるcryptolibと現在のユーザの公開鍵に依存することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Handler1&lt;/code&gt; とプロセス &lt;code&gt;Pid&lt;/code&gt; の間に監視された接続があった場合、代わりに &lt;code&gt;Handler2&lt;/code&gt; と &lt;code&gt;Pid&lt;/code&gt; の間に監視された接続があります。</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">&lt;code&gt;[1,2]&lt;/code&gt; を入力として &lt;code&gt;badmatch&lt;/code&gt; ときに、 &lt;code&gt;lists:reverse/1&lt;/code&gt; が &lt;code&gt;[2,1]&lt;/code&gt; 以外の何かを返すバグがあった場合、上記の最後のテストでbadmatchエラーがスローされました。最初の2つ（ &lt;code&gt;badmatch&lt;/code&gt; を取得しないと想定）は、それぞれ &lt;code&gt;[]&lt;/code&gt; と &lt;code&gt;[1]&lt;/code&gt; を返すだけなので、どちらも成功します。 （EUnitは精神的なものではないことに注意してください。値を返すテストを作成した場合、たとえそれが間違った値であっても、EUnitはそれを成功と見なします。テストが書かれていることを確認する必要があります。結果は本来あるべきものではありません。）</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">これらの要件が満たされていないと、システムの動作が非常に悪くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">この属性が指定されていない場合、バージョンはモジュールの MD5 チェックサムをデフォルトとします。</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">このコールバックは、エクスポートが、おそらく機密データを非表示にするには、失敗した場合、デフォルトの機能が代わりに返されます &lt;code&gt;{State,Info}&lt;/code&gt; 、どこ &lt;code&gt;Info&lt;/code&gt; 何もなく、事実言わない &lt;code&gt;format_status/2&lt;/code&gt; がクラッシュしたが。</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">この構成パラメータが設定されている場合、デフォルトのレポート・コールバックとメタデータ内の任意のレポート・コールバックの両方が置き換えられます。つまり、すべてのレポートはこの設定された関数によって変換されます。</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">もしこれがあなたのシステムで動作しない場合、Erlang/OTPリリースにはドキュメントがHTMLとして含まれています。ドキュメントをHTMLで読んだり、www.erlang.se (商用Erlang)やwww.erlang.org (オープンソース)のサイトからPDFでダウンロードすることもできます。例えば、Erlang/OTPリリースR9Bの場合。</target>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">このフラグが存在する場合、 &lt;code&gt;global&lt;/code&gt; は分散型Erlangノードの完全に接続されたネットワークを維持しないため、グローバル名の登録は使用できません。 &lt;code&gt;global(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このフラグが設定されている場合 &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; と{error、Errors、Warnings}が返されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">このフラグが設定されている場合、 &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; と{error、ErrorList、WarningList}が返されます。</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このフラグが設定されている場合、成功時に返されるタプルに &lt;code&gt;Warnings&lt;/code&gt; を含む追加のフィールドが追加されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">このフラグが設定されている場合、成功時に返されるタプルに、 &lt;code&gt;WarningList&lt;/code&gt; を含む追加のフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">この関数が呼び出されるかどうかは、前のhandle_trans_request/3の呼び出しからの応答によって制御されます。handle_trans_request/3 関数は、アクションリクエストを自分自身で処理するか、 この関数に処理を委ねるかを決定することができます。</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">この関数が呼び出されるかどうかは、前の関数 handle_trans_request/3 の呼び出しからの応答によって制御されます。handle_trans_request/3 関数は {handle_ack,ack_data()}または {handle_sloppy_ack,ack_data()}を返すかどうかを決定するかもしれません。</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">この関数が呼び出された場合、この関数は1回しか &lt;code&gt;ei&lt;/code&gt; ず、eiライブラリ内の他の関数が呼び出される前に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が呼び出された場合、関数 &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; の呼び出しの直後に一度だけ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">この関数が呼び出されると、 &lt;code&gt;undo&lt;/code&gt; または最初の引数として &lt;code&gt;set&lt;/code&gt; を使用して、再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">この関数が呼ばれなかった場合、開始関数はエラータプル(リンクやタイムアウトが使用されている場合)を返すか、そうでなければハングを返します。</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">この関数が現在の状態と等しい（ &lt;code&gt;=/=&lt;/code&gt; ）と一致しない次の状態で戻る場合、延期されたすべてのイベントが次の状態で再試行されます。</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">この関数のボディがインライン定数値を返さない場合は、コールバックモジュールが何か変なことをしている可能性があります。</target>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">これが問題であれば、ブーリアンを生成するには、以下のようなものを使用します。</target>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">このマクロが定義されている場合、NOASSERT マクロを上書きし、他の設定に関係なく常に assert マクロを有効にします。</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">このマクロが定義されている場合、NODEBUG マクロをオーバーライドし、デバッグマクロを強制的に有効にします。</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">このマクロが定義されている場合、テストも無効になっていると、assertマクロは効果がありません。 &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; 参照してください。テストを有効にすると、assertマクロは常に自動的に有効になり、無効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">このマクロが定義されている場合、テスト関数の自動エクスポートまたはストリッピングは無効になります。</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">このマクロが定義されている場合、デバッグマクロは無効になります。 &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 参照してください。 &lt;code&gt;NODEBUG&lt;/code&gt; はまた意味 &lt;code&gt;NOASSERT&lt;/code&gt; をテストが有効になっている場合を除き、。</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">このオプションが存在する場合、テーブルデータは、より少ないメモリを消費するために、よりコンパクトな形式で保存されます。ただし、テーブル操作が遅くなります。特に、 &lt;code&gt;match&lt;/code&gt; や &lt;code&gt;select&lt;/code&gt; など、オブジェクト全体を検査する必要がある操作は、非常に遅くなります。キー要素は圧縮されていません。</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">このオプションが存在する場合、テーブルはその &lt;code&gt;Name&lt;/code&gt; で登録され、その後の操作でテーブル識別子の代わりに使用できます。</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">このオプションが設定されている場合、パターン内のほとんどの空白文字は、エスケープされている場合または文字クラス内にある場合を除いて、完全に無視されます。ただし、かっこで囲んだサブパターンを導入する &lt;code&gt;(?&amp;gt;&lt;/code&gt; などのシーケンス内や、 &lt;code&gt;{1,3}&lt;/code&gt; などの数値数量詞内では空白を使用できません。ただし、アイテムと後続の数量詞の間、および量指定子とそれに続く+は所有性を示します。</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">このオプションがソースコードで &lt;code&gt;-compile&lt;/code&gt; ディレクティブとして記述されている場合、構文 &lt;code&gt;F/A&lt;/code&gt; を &lt;code&gt;{F,A}&lt;/code&gt; 代わりに使用できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">このパラメーターが指定されて &lt;code&gt;/etc/hosts&lt;/code&gt; ない場合、このファイルのディレクトリーを &lt;code&gt;/etc&lt;/code&gt; 以外に定義する環境変数 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; が設定されていない限り、デフォルトで/ etc / hostsになります。</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">このパラメーターが指定されていない場合、このファイルのディレクトリーを &lt;code&gt;/etc&lt;/code&gt; 以外に定義する環境変数 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; が設定されていない限り、デフォルトで &lt;code&gt;/etc/resolv.conf&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">このパターンがより大きなものに埋め込まれている場合は、相対参照を使用することができます。</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">このプロパティが定義されている場合、 &lt;code&gt;Inets&lt;/code&gt; は、Apacheに似た構文を使用する、このファイルで定義されている他のすべてのプロパティを見つけることを期待しています。ファイルには、必須プロパティの下にリストされているすべてのプロパティを含める必要があります。Apacheに似た構文はプロパティであり、新しい単語がそれぞれ大文字で始まり、空白、値、改行の順に続く1つの単語として記述されます。</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">このプロパティが定義されている場合、 &lt;code&gt;Inets&lt;/code&gt; はこのファイルで定義されている他のすべてのプロパティを見つけることを期待しています。ファイルには、必須プロパティの下にリストされているすべてのプロパティを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">この状況が受け入れられない場合、この関数を使用してMnesiaテーブルロードアルゴリズムの戦略を上書きすることができます。これは、結果として一貫性のないデータベースでいくつかのトランザクション効果が失われる状況をもたらす可能性がありますが、一部のアプリケーションでは一貫性のあるデータよりも高可用性の方が重要です。</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">この値が false の場合、mib をロードする際に、mib のインストール前に各 mib-エントリがチェックされます。このチェックの目的は、同じシンボリックな mibentry 名が異なる oid に使われることを防ぐことです。</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">この値が false の場合、mib をロードする際に、mib のインストール前に各トラップがチェックされます。このチェックの目的は、同じシンボリックトラップ名が異なるトラップに使用されることを防ぐためです。</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">これがより大きなパターンの一部であった場合は、パターン全体を再解析したくないので、代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">時刻補正が無効になっている場合、Erlangのモノトニックタイムは前にワープしたり停止したり、長時間フリーズしたりすることがあります。この場合、Erlangのモノトニッククロックの周波数が正確で安定しているという保証はありません。</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">時刻補正が無効になっている場合、OSシステムの時間が前に進むとErlangのモノトニックタイムが前に進みます。OSシステムの時間が後退すると、Erlangのモノトニックタイムは一時的に止まりますが、長時間フリーズすることはありません。これは時間オフセットが変更され、Erlangシステムの時間をOSシステムの時間に合わせるようになったためです。</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">時間修正が無効になっている場合、OSシステム時間の変更は &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; が使用されている場合と同じように単調クロックに影響します。</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">時刻修正が有効になっている場合、Erlang単調クロックの調整は、その周波数を可能な限り正確に保つために行われます。ただし、Erlangのシステム時刻とOSのシステム時刻を合わせるための調整は行われ&lt;strong&gt;ません&lt;/strong&gt;。つまり、準備段階では、Erlangのシステム時刻とOSのシステム時刻が互いに異なる可能性があり、これを防止する試みは行われていません。</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">時間修正が有効になっている場合、Erlangランタイムシステムは &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; の両方を使用して、Erlang単調クロックの周波数を調整します。時間補正により、 &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 、周波数が比較的正確になります。周波数調整のタイプは、使用するタイムワープモードによって異なります。詳細については、セクション &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">時刻補正が有効になっていない場合、OSシステムの時間が逆に跳ね上がるとErlangのモノトニックタイムがフリーズします。モノトニックタイムのフリーズはOSシステムの時間が追いつくまで続きます。フリーズは長い間続く可能性があります。OSシステムの時間が前方に跳ね上がると、Erlangのモノトニックタイムも前方に跳ね上がります。</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">トレースモードがオンになっている場合、ODBCドライバにトレースログをSQL.LOGというファイルに書き込むように指示し、それをerlangエミュレータのカレントディレクトリに置きます。この情報はerlang ODBCアプリケーションにバグがあるかもしれないと思ったときに役立つかもしれません。そうでなければ、これを使うことはあまりないでしょう。</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; および &lt;code&gt;Rootset&lt;/code&gt; のすべてのプロセスでトレースを有効にできる場合、関数は &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; が値 &lt;code&gt;Value&lt;/code&gt; で戻るときに &lt;code&gt;{ok,Value}&lt;/code&gt; 返し、 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; が終了理由 &lt;code&gt;Reason&lt;/code&gt; で失敗した場合は &lt;code&gt;{error,Reason}&lt;/code&gt; 返します。。それ以外の場合は &lt;code&gt;{error, Reason}&lt;/code&gt; すぐに{error、Reason}を返します。</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">true の場合、ECC カーブの選択にはサーバーの環境設定を使用します。false (デフォルト)の場合は、クライアントの環境設定を使用します。</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">true の場合、暗号の選択にサーバの設定を使用します。false (デフォルト)の場合は、クライアントの設定を使用します。</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">2つの &lt;code&gt;Dates&lt;/code&gt; が指定されている場合、それらの日付の間に発生したレポートが返されます。</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">2つの一致するキーが宣言されている場合、後者のキーが優先されます。</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">2つのプロセスが同じ名前と引数を与えて同じテーブルを開く場合、そのテーブルには2人のユーザがいます。1人のユーザがテーブルを閉じると、2人目のユーザが閉じるまでテーブルは開いたままになります。</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">2つのプロセスが &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; を同時に実行する場合、両方の更新が有効になり、一方の更新が失われるリスクはありません。カウンターの新しい値 &lt;code&gt;NewVal&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ガードの最上位で使用する場合、引数が浮動小数点数かどうかをテストします。明確にするために、代わりに &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">検証がオンになっていて、ファイルがオプション &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; で書き込まれた場合、ファイルの読み取りは遅くなり、それ以外の場合よりも大幅に多くのCPU時間を消費します。</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">警告がオンになっている場合（前述のオプション &lt;code&gt;report_warnings&lt;/code&gt; ）、次のオプションは、生成される警告のタイプを制御します。 &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; 除いて、次のオプションには2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">接続されている場合（および接続ハンドルが &lt;code&gt;NULL&lt;/code&gt; でない場合）、データベースからログアウトします。 &lt;code&gt;'ok'&lt;/code&gt; エンコードする必要があるかどうかを確認する必要があります。これは、データをエミュレータに返さないfunction &lt;code&gt;stop&lt;/code&gt; から取得できるためです。</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">セキュリティレベルが &lt;code&gt;noAuthNoPriv&lt;/code&gt; でない場合、エージェントはステージ2に進み、その前にusm関連の更新を行う必要があるため、これは複雑になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">接続していない場合は、 &lt;code&gt;PQsendQuery&lt;/code&gt; からの結果を待ち、結果を取得して返します。エンコードは、前の例と同じ関数で行われます。</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">このような状況が起こりえないと確信している場合には、関係するモジュールを &quot;safe &quot;と指定して、その間のすべての呼び出しをローカルにすることができます。ターゲットモジュール自体が安全と指定されている場合、それ自身への「リモート」コールはローカルコールに変わることに注意してください。これは、例えば典型的なサーバループのようなコード置換の特性を破壊することになります。</target>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; バッファーにデータがあることで示される接続の結果がある場合は、出力（ &lt;code&gt;ready_output&lt;/code&gt; ）で選択する必要がないため、 &lt;code&gt;driver_select&lt;/code&gt; を呼び出してこれを削除します。</target>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">実行中の &lt;code&gt;Collector&lt;/code&gt; フィルターを追加すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">ノード &lt;code&gt;ant@stack&lt;/code&gt; シェルからメッセージを送信すると、シェルからのすべての送信がトレースされます。</target>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">このように実行すると、 &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; 結果は &lt;code&gt;result_xs.html&lt;/code&gt; になります。入力ファイルが以前の「モーターサイクル」XMLファイルと同じ構造であるが、「bike」要素がもう少しあり、「manufacturer」要素が順番になっていない場合。</target>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; yおよびy &lt;code&gt;F&lt;/code&gt; xの場合、x = y（ &lt;code&gt;F&lt;/code&gt; は非対称）です。</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; yおよびy &lt;code&gt;F&lt;/code&gt; zの場合、x &lt;code&gt;F&lt;/code&gt; z（ &lt;code&gt;F&lt;/code&gt; は推移的）。</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">x が I から X までのファミリーである場合、x[i]はインデックス i における関数の値を表します。</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">xはXの部分集合の族である場合は、xの範囲の労働組合は、呼び出された&lt;strong&gt;家族の労働組合&lt;/strong&gt;のx。</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">xが空でない（インデックスセットが空でない）場合&lt;strong&gt;、ファミリー&lt;/strong&gt; xの共通部分はxの範囲の共通部分です。</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">Etsテーブルに保存されているすべてのデータを返す&lt;strong&gt;必要がある&lt;/strong&gt;場合は、 &lt;code&gt;ets:tab2list/1&lt;/code&gt; を使用できます。ただし、通常、関心があるのは情報のサブセットのみです。この場合、 &lt;code&gt;ets:tab2list/1&lt;/code&gt; は高価です。たとえば、各人の年齢など、各レコードから1つのフィールドのみを抽出する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">gitからErlang / OTPをビルドしている場合は、。/ &lt;code&gt;./otp_build autoconf&lt;/code&gt; を実行して設定スクリプトを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">もしあなたが64ビット版のErlangを作っているなら、PATHなどの設定が少し違うはずです。CygwinとMSYSの両方で動作させるためのテンプレートが2つありますが、MSYS2で動作させるためには編集が必要です(スクリプトのコメントを参照してください)。次のものは32ビット用です。</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">64ビットバージョンをビルドする場合は、アーキテクチャパラメータを &lt;code&gt;otp_build&lt;/code&gt; に指定します。</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; でビルドする場合は、最初に &lt;code&gt;configure&lt;/code&gt; スクリプトを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Gitでビルドしている場合は、先に進む前に &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 」セクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">自分のアプリケーションのソースコードを他の人がコンパイルして実行できるように配布している場合、EUnit が利用できなくてもコードがコンパイルできるようにしたいと思うでしょう。前節の例のように、共通のヘッダファイルに以下の行を入れます。</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">時間オフセットが変化するモードで実行していて、イベントが発生したときの実際のErlangシステムの時刻を取得したい場合、時間オフセットをタプルの3番目の要素(3つのタプルを比較するときに最も重要でない要素)として保存することができます。</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">64bit Windows版をビルドする場合は、CygwinでMinGWの64bit gccをインストールするようにしましょう。開発パッケージの一つに入っています。</target>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">イベントが発生したときのErlangシステム時刻に関心がある場合は、 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; を使用して、イベントを保存する前または後に時間オフセットを保存することもできます。時間オフセットが追加されたアーラン単調時間は、アーランシステム時間に対応します。</target>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">Cygwin、MSYS、MSYS2、またはUnix環境に慣れていない場合は、おそらくそれがどのように機能するかを少し読む必要があるでしょう。これに関するオンラインのドキュメントはたくさんあります。</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">OSシステムの時刻が正しいかどうかわからない場合は、Erlangランタイムシステムを起動する前に、実際のPOSIX時刻よりも早くなることが保証されている時刻に設定してください。</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">もしあなたが「ブライアン」という名前の人の年齢だけに興味があるのであれば</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">HiPEをサポートしているプラットフォーム上で実行していて、HiPEを無効にしていない場合は、Erlangシェルからこのようなネイティブコードにモジュールをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">分散Erlangアプリケーションをテストしている場合、コードカバレッジ分析に含めるコードが、 &lt;code&gt;Common Test&lt;/code&gt; が実行されているものとは別のErlangノードで実行される可能性があります。その場合、カバー仕様ファイルでこれらの他のノードを指定するか、ノードのコードカバレッジセットに動的に追加する必要があります。後者の詳細については、モジュール &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">きちんとタームを解放したかどうかわからない場合は、以下の関数を使って固定タームアロケーションの状態を確認することができます。</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">ソースコードを編集して再コンパイルできる場合は、プロファイルするコードの前後に &lt;code&gt;fprof:trace(start)&lt;/code&gt; および &lt;code&gt;fprof:trace(stop)&lt;/code&gt; を挿入すると便利です。生成されたすべてのプロセスもトレースされます。デフォルト以外のファイル名が必要な場合は、 &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; 試してください。</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">この関数からのキャッチ例外を &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; と組み合わせて、呼び出しがタイムアウトしたときに呼び出しプロセスが停止しないようにするには、遅延応答を処理する準備をする必要があります。ネットワークの問題が発生した場合などに、 &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; または &lt;code&gt;infinity&lt;/code&gt; を使用しても応答が遅れる可能性があります。では、なぜ例外をキャッチしないことで呼び出しプロセスを死なせないのですか？</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">あなたは、コードと比較した場合、あなたはすることもありでしょう &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; からのみ呼び出された &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; と自体、およびのみと呼ばれる &lt;code&gt;file:write/2&lt;/code&gt; 、への呼び出しの数に注意 &lt;code&gt;file:write/2&lt;/code&gt; 。しかし、ここでは、 &lt;code&gt;suspend&lt;/code&gt; が数回呼び出されたことがわかります。これは、 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; での実行中にプロセスが中断されたことを示す疑似関数であり、コードに &lt;code&gt;receive&lt;/code&gt; または &lt;code&gt;erlang:yield/0&lt;/code&gt; がないため、Erlangスケジューリングの中断、またはトレースファイルドライバーの補正が必要です大きなファイルの書き込み操作の場合（これらは、同じプロセスへのスケジュールが続くスケジュールアウトと見なされます）。</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">以下を使用してコンパイルした場合、結果は、3つのASN.1仕様から生成されたコードを &lt;code&gt;MyModule.erl&lt;/code&gt; 1つのマージモジュールMyModule.erlになります。</target>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">結局、テストケースを実行しないことにした場合は、 &lt;code&gt;{skip,Reason}&lt;/code&gt; 返します。 &lt;code&gt;Reason&lt;/code&gt; は、HTML結果ページのフィールド &lt;code&gt;Comment&lt;/code&gt; に印刷されます。</target>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">リンクされたドライバー（共有ライブラリ）を開発する場合は、 &lt;code&gt;gcc&lt;/code&gt; とフラグ &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; を使用してリンクする必要があります。また、コンパイル時に &lt;code&gt;CFLAGS&lt;/code&gt; に &lt;code&gt;-fno-common&lt;/code&gt; を含めます。ライブラリのサフィックスとして &lt;code&gt;.so&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">ファイルコンテンツの完全なバイナリがない場合は、代わりにファイルをチャンクし、部分ごとにチェックできます。関数 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; からの戻りタプル &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; が便利です。ファイルから読み取られたデータのチャンクの不完全な残りは、次のチャンクの前に追加されるため、UTF-8エンコーディングでバイトのチャンクを読み取るときの文字境界の問題を回避します。</target>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">データを再割り当てしたり、NIF呼び出し全体でデータを保持したりする必要がない場合は、代わりに &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; を使用することを検討してください。可能な場合、プロセスヒープに小さなバイナリが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">X-windows を使っていない場合は、コンソールシステムメニューのプロパティ(ウィンドウの左上隅、タイトルバーの Cygwin アイコン)を選択して、Windows コンソールウィンドウを設定するとよいでしょう。特に、画面のバッファサイズ(行数)を大きく設定すると、スクロールバーが表示されるので、表示される可能性のあるエラーメッセージを見ることができるので便利です。</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">引数ベクトルにプログラム名を明示的に設定したい場合は、オプション &lt;code&gt;arg0&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">エミュレータのスレッドでスレッド固有のデータをクリアしてから制御不能にしてしまうと、後になってシステムの他の部分で予期せぬエラーが発生して、このデータをクリアできなくなってしまうかもしれません。</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">環境とビルドシステムに慣れ、必要なツールがすべて揃っていれば、Windows用のErlang / OTPディストリビューションをより良いものにするチャンスがあります。 &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; への提案と &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; へのパッチを提出して、Erlangの次のバージョンへの道を見つけてください。ビルドシステムに変更を加える場合（makefileなど）、同じmakefileがUnix / VxWorksで使用されているため、変更によって他のプラットフォームが壊れることはありません。もちろん、Cコードも同様です。システム固有のコードは、主に &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; および &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; ディレクトリにあります。 &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; ディレクトリには、共通のコードです。</target>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">テーブルのキーではないフィールドを頻繁に検索する場合、この関数はテーブル全体を横断するので、&quot;mnesia:select/match_object &quot;を使用するとパフォーマンスが低下します。代わりにセカンダリインデックスを作成し、&quot;mnesia:index_read &quot;を使用して高速なアクセスを得ることができますが、これはより多くのメモリを必要とします。</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">公開鍵 &lt;code&gt;PubKey&lt;/code&gt; と、 &lt;code&gt;ssh_decode/2&lt;/code&gt; によって返された属性 &lt;code&gt;Attributes&lt;/code&gt; の関連リストを取得した場合、次のように新しいSSHファイルを作成できます。</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">エミュレーターをハックする場合は、 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 立ってエミュレーターの実行可能ファイルをビルドし、簡単な操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">Xcode 4.3以降をお持ちの場合は、Xcodeのダウンロード環境設定ペインから &quot;Command Line Tools &quot;をダウンロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">リストのリスト &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; 場合、次のように &lt;code&gt;L&lt;/code&gt; のすべての文字列の長さを合計できます。</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">上記のように宣言 &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; をモジュールに追加した場合は、モジュールをコンパイルして、自動的にエクスポートされた関数 &lt;code&gt;test()&lt;/code&gt; を実行するだけで済みます。たとえば、モジュールの名前が &lt;code&gt;m&lt;/code&gt; の場合、 &lt;code&gt;m:test()&lt;/code&gt; を呼び出すと、モジュールで定義されているすべてのテストでEUnitが実行されます。テスト関数の &lt;code&gt;-export&lt;/code&gt; 宣言を記述する必要はありません。これはすべて魔法によって行われます。</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;install&lt;/code&gt; ターゲットを使用してErlang / OTPをインストールした場合は、 &lt;code&gt;install-docs&lt;/code&gt; ターゲットを使用してドキュメントをインストールします。 &lt;code&gt;configure&lt;/code&gt; によって決定されたインストール場所が使用されます。 &lt;code&gt;$DESTDIR&lt;/code&gt; は、 &lt;code&gt;make install&lt;/code&gt; を実行するときと同じ方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; ターゲットを使用してErlang / OTPをインストールした場合は、 &lt;code&gt;release_docs&lt;/code&gt; ターゲットを使用してドキュメントをインストールします。通常、 &lt;code&gt;make release&lt;/code&gt; を呼び出すときと同じ &lt;code&gt;RELEASE_ROOT&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">OTPインストールでドキュメントをインストールしている場合は、ドキュメントもビルドしてください。</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">現在のソースツリーでErlang / OTPをビルドしたばかりの場合は、すでに &lt;code&gt;configure&lt;/code&gt; を実行しているので、これを再度行う必要はありません。それ以外の場合は、 &lt;code&gt;configure&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">1つのノードに多数のサーバーがあり、それらの存続期間にサーバーがしばらくアイドル状態になることが予想されるいくつかの状態があり、これらすべてのサーバーに必要なヒープメモリの量が問題である場合、メモリフットプリントサーバーのは、 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; を介して休止状態にすることで最小化できます。</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">プロファイリングするタスクを実行する関数が1つあり、プロファイリングを停止する必要があるときに関数が戻る場合は、 &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; および関連するトレースステップを使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">公開鍵データがあり、PEMファイルを作成したい場合は、関数 &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; および &lt;code&gt;pem_encode/1&lt;/code&gt; を呼び出し、結果をファイルに保存することでこれを行うことができます。たとえば、 &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; ます。次に、PEM- &quot;RSA PUBLIC KEY&quot;ファイル（ASN.1タイプ &lt;code&gt;'RSAPublicKey'&lt;/code&gt; ）またはPEM- &quot;PUBLIC KEY&quot;ファイル（ &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1タイプ）を作成できます。</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">ファイルの場所やサイトに依存しないシステム構成データがある場合は、 &lt;code&gt;sys.config&lt;/code&gt; を早期に作成しておくと便利です。そのため、このデータは、 &lt;code&gt;target_system:create/1&lt;/code&gt; によって作成されるターゲットシステムのtarファイルの一部になります。あなたは現在のディレクトリ内のファイルだけでなく、作成した場合、実際には、 &lt;code&gt;mysystem.rel&lt;/code&gt; 、だけでなく、ファイル &lt;code&gt;sys.config&lt;/code&gt; を、後者のファイルは、暗黙のうち、適切なディレクトリに置かれています。</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">ファイルにクロスコンパイル設定がある場合は、 &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; コマンドライン引数を使用して渡します。そうでない場合は、-- &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 、-- &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 、およびコマンドラインで &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 構文を使用して構成変数を渡します（（3）と同じ）。 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; はどちらか一方に渡す必要があることに注意してください。構成ファイルで &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; および &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; を使用するか、-- host &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; および &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; コマンドライン引数を使用します。</target>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">あなたがでた場合は &lt;code&gt;gen_statem&lt;/code&gt; 、例えば、あなたの別の状態コールバックを一つの状態でイベントを延期してから呼び出して、あなたは状態を変更していないので、延期イベントが論理的であるが、混乱することができ、再試行されていません。</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">代わりにXMLドキュメントを文字列として受け取った場合は、 &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; で解析できます。file / 2とstring / 2の両方が存在し、2番目の引数はパーサーのオプションのリストです。 &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">返されるバイナリが常に小さいことがわかっている場合は、 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 形式を使用して、事前に割り当てられたバイナリを必要としないドライバAPI呼び出し &lt;code&gt;driver_output()&lt;/code&gt; または &lt;code&gt;erl_drv_output_term()&lt;/code&gt; など）を使用してランタイムを許可することをお勧めしますヒープバイナリを構築します。</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">&lt;code&gt;escript&lt;/code&gt; 実行可能ファイルの場所がわかっている場合は、最初の行で &lt;code&gt;escript&lt;/code&gt; へのパスを直接指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">スレッドを制御不能にしたときに、ミューテックスをエミュレータスレッドにロックしたままにすると、エミュレータ全体&lt;strong&gt;が&lt;/strong&gt;デッドロックする&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;高くなり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">スレッドを制御不能にしたときにエミュレータースレッドでrwlockをロックしたままにすると、エミュレーター全体&lt;strong&gt;が&lt;/strong&gt;デッドロックする&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;高くなり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">USTAR tar形式との互換性を維持する必要がある場合は、保存されるファイルパスが合計で255バイト未満、ファイル名コンポーネントの最大長が100バイトであることを確認する必要があります。 USTARは、名前フィールドに加えてヘッダーフィールド（プレフィックス）を使用し、100バイトを超えるファイルパスを2つの部分に分割します。この分割は、ディレクトリ境界で行われ、これら2つのフィールドで利用可能なスペースを最大限に活用する方法で行われますが、実際には、パスの255バイトよりも少ないことを意味します。 &lt;code&gt;erl_tar&lt;/code&gt; はフォーマットをPAXに自動的にアップグレードしてより長いファイル名を処理するため、これは、 &lt;code&gt;erl_tar&lt;/code&gt; または &lt;code&gt;tar&lt;/code&gt; の古い実装でアーカイブを抽出する必要がある場合にのみ問題になります。PAXをサポートしていません。この場合、PAXヘッダーは通常のファイルとして抽出されるため、手動で適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">ブライアン」という名前の人物について、Etsテーブルに保存されているすべての情報が必要な場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">&lt;code&gt;sqlserver&lt;/code&gt; 、 &lt;code&gt;mysql&lt;/code&gt; 、 &lt;code&gt;postgres&lt;/code&gt; 、 &lt;code&gt;oracle&lt;/code&gt; 、 &lt;code&gt;cybase&lt;/code&gt; などのリレーショナルデータベースにアクセスする必要がある場合は、Erlang ODBCインターフェースを使用してerlangアプリケーションからアクセスするのが良い方法です。</target>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">他のイベントのためにタイマーをキャンセルする必要がある場合は、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; を使用できます。タイムアウトメッセージは、前に延期していない限り（次のセクションを参照）、到着しないので注意してください。誤ってそのようなメッセージを延期しないようにしてください。また、キャンセルする直前にタイムアウトメッセージが到着した可能性があるため、 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; からの戻り値によっては、このようなメッセージをプロセスメールボックスから読み取る必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">テストを実行するために構成操作を実行する必要がある場合は、スイートに構成関数を実装できます。構成関数の結果は、構成データ、つまり &lt;code&gt;Config&lt;/code&gt; です。これは、構成関数からテストケースに（おそらく「下位レベル」の構成関数を介して）渡されるKey-Valueタプルのリストです。データフローは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; ではないErlangコードを使用する必要があり、OSシステム時刻が修正される前にErlangランタイムシステムを起動する必要がある場合は、シングルタイムワープモードを使用できます。</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">エミュレータのスレッドでスレッド固有のデータを使用する必要がある場合は、スレッドが自分の制御下にある間だけスレッド固有のデータセットを持ち、スレッドを自分の制御外に出す前にスレッド固有のデータをクリアしてください。</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">ブートストラップビームファイルが提供されたソースファイルと一致することを確認する必要がある場合は、。 &lt;code&gt;./otp_build update_primary&lt;/code&gt; を使用して、相違がある場合はそれを含む新しいコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">あなたまたはあなたのシステムに特別な要件がある場合は、追加の構成情報について &lt;code&gt;Makefile&lt;/code&gt; を読んでください。</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">システムを再起動せずにコードを変更する場合は、関数 &lt;code&gt;Resolve&lt;/code&gt; として外部fun（ &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ）を使用する必要があります。ローカルのfunを使用する場合、funが属するモジュールのコードを置き換えることはできません。</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; を使用してオプション値を読み戻しても値がない場合、そのオプションはホストオペレーティングシステムに存在しません。同じポートでリッスンするIPv6ソケットとIPv4ソケットの両方の動作、およびIPv6ソケットの場合、IPv4トラフィックを取得することは、もはや予測できなくなります。</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">どうしても、どうしてもというなら、「インガ」と呼んでもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; トレースフラグを設定する場合は、&lt;strong&gt;トレース&lt;/strong&gt;する関数の&lt;strong&gt;トレースパターン&lt;/strong&gt;も設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">プレーンテキストの段落をフォーマットするだけの場合は、おそらく次の例のように、 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">このプログラムを &lt;code&gt;code_lock:start([17])&lt;/code&gt; で起動すると、 &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt; ロックを解除できます。</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; の検証でXMLファイルを正常に解析できた場合、XMLドキュメントが有効であり、DTDに準拠した構造を持っていることがわかります。</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">別の都市で再度同じことをしようとすると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">オブジェクトをレジストリに保存しようとしたときに、同じキーを持つ既存のオブジェクトが存在する場合、新しい値が古いものに置き換わります。これは、新しいオブジェクトと古いオブジェクトの型が同じであるかどうかに関係なく行われるので、例えば文字列を整数に置き換えることができます。既存の値が文字列またはバイナリの場合は、新しい値が代入される前に解放されます。</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;erl_connect_init()&lt;/code&gt; を使用する場合、ノードには短い名前が付けられます。つまり、完全修飾されません。完全修飾（長い）名を使用する必要がある場合は、代わりに &lt;code&gt;erl_connect_xinit()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">あなたが使用している場合 &lt;code&gt;systools&lt;/code&gt; （参照コードを包装するため、アーラン/ OTPツールを &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ）、各アプリケーションのコードは、事前定義された以下の別のディレクトリに置かれている &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">古いアパスのような設定ファイルを使用している場合。</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">複数のCTHを使用する場合、戻りタプルの最初の部分は次のCTHの入力として使用されます。したがって、前の例では、次のCTH は2番目のパラメーターとして &lt;code&gt;{fail,Reason}&lt;/code&gt; を取得できます。多くのCTHが相互作用している場合は、各CTHリターンが &lt;code&gt;fail&lt;/code&gt; たり &lt;code&gt;skip&lt;/code&gt; したりしないでください。代わりに、 &lt;code&gt;Config&lt;/code&gt; リストを介してアクションが実行されることを返し、最後に正しいアクションを実行するCTHを実装します。</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">POSIXスレッドまたはSolarisスレッドに基づくスレッド化されたアプリケーションで &lt;code&gt;Erl_Interface&lt;/code&gt; 関数を使用する場合、 &lt;code&gt;Erl_Interface&lt;/code&gt; はスレッドパッケージ内のいくつかの同期機能にアクセスする必要があります。使用するパッケージを示すために、追加のコンパイラフラグを指定する必要があります。 &lt;code&gt;_REENTRANT&lt;/code&gt; および &lt;code&gt;STHREADS&lt;/code&gt; または &lt;code&gt;PTHREADS&lt;/code&gt; を定義します。 &lt;code&gt;_REENTRANT&lt;/code&gt; が指定されている場合、デフォルトではPOSIXスレッドが使用されます。</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; プログラムを使用する場合、フラグ &lt;code&gt;-shell&lt;/code&gt; およびオプションでフラグ &lt;code&gt;-config&lt;/code&gt; および/または &lt;code&gt;-userconfig&lt;/code&gt; を使用して、Erlangシェルと &lt;code&gt;Common Test&lt;/code&gt; を一度に開始できます。</target>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Erlangノードに最初から（デフォルトのローカルジョブではなく）リモートジョブをアクティブにしたい場合は、フラグ &lt;code&gt;-remsh&lt;/code&gt; を使用して Erlangを開始します。例： &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">接続を &lt;code&gt;Handle&lt;/code&gt; のみに関連付ける場合（たとえば、ホストへの複数の接続を開く必要がある場合）は、構成変数名である &lt;code&gt;Key&lt;/code&gt; を使用してターゲットを指定します。ターゲット名が関連付けられていない接続は、 &lt;code&gt;Handle&lt;/code&gt; 値でのみ閉じることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; によって返されるものと同じフォーマットが必要な場合は、 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">motorcycles.xmlドキュメントに、2003年製の黒いハーレー・デービッドソン1200ccスポーツスターバイクの情報を新品同様の形で追加したい場合は、以下のようなシンプルな形式のデータ構造にデータを配置することができます。</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">異なるOTPバージョンに存在する複数のOTPアプリケーションのパッチを適用したい場合、これらのパッチを複数のステップで適用する必要があります。同じOTPバージョンの複数のOTPアプリケーションを一度に適用することができるのは</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">&lt;code&gt;wx&lt;/code&gt; アプリケーションをビルドする場合は、wxWidgets-3.0（ &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; を入手する必要があります。 3.0.3.tar.bz2）またはgithubからバグを修正して入手：</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; で互換性のあるErlang / OTPシステムを使用してビルドする場合は、（3）にジャンプします。</target>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">新しくビルドしたライブラリ(アプリケーション)をリリースエリアにコピーしたい場合は、エミュレータと同様に行います。</target>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">パターンのどこかの時点でマッチングの失敗を強制したい場合、空の文字列は常にマッチングするので、それを行う最も便利な方法は (?!)です。つまり、空文字列が存在しないことを要求するアサーションは常に失敗しなければなりません。バックトラッキング制御動詞(*fail)や(*f)は、(?!)の同義語です。</target>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">現在の状態の特定のイベントを無視し、将来の状態で処理する場合は、イベントを延期できます。状態が変更された後、延期されたイベントが再試行されます。つまり、 &lt;code&gt;OldState =/= NewState&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">トレースログのサイズを制限する場合は、ラップログを使用できます。これは、循環バッファのように機能します。バイナリログの最大数と各ログの最大サイズを指定できます。 &lt;code&gt;ttb&lt;/code&gt; は、ログが最大サイズに達するたびに新しいバイナリログを作成します。ログの最大数に達すると、新しいログが作成される前に最も古いログが削除されます。</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">典型的な回文フレーズにマッチさせたい場合は、パターンはすべての単語以外の文字を無視しなければならないので、以下のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">スレッドタイプごとのランタイムのみを表示したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">XML要素または属性のコンテンツを出力する場合は、 &lt;code&gt;value_of&lt;/code&gt; 関数によって値を文字列として取得します。</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">XMLファイルのmotorcycles.xmlをパースしたい場合は、Erlangシェルで以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">あなたがバイナリを渡したいとすでにバイナリの内容がない場合は &lt;code&gt;ErlDrvBinary&lt;/code&gt; を、あなたが使用して恩恵を受けることができ &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; を代わりに作成 &lt;code&gt;ErlDrvBinary&lt;/code&gt; を通過 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 、その後を通じてバイナリを渡す &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 。 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; が使用されている場合、ランタイムシステムは多くの場合、バイナリをよりスマートに割り当てます。ただし、渡すバイナリのコンテンツがすでに &lt;code&gt;ErlDrvBinary&lt;/code&gt; にある場合は、通常、 &lt;code&gt;ErlDrvBinary&lt;/code&gt; と問題のErlDrvBinaryを使用してバイナリを渡すことを &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 勧めします。</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">テストコードを通常のコードから分離したい場合（少なくともエクスポートされた関数をテストする場合）、モジュールの名前が &lt;code&gt;m&lt;/code&gt; の場合、テスト関数を &lt;code&gt;m_tests&lt;/code&gt; （注： &lt;code&gt;m_test&lt;/code&gt; ではない）という名前のモジュールに書き込むだけです。その後、EUnitにモジュール &lt;code&gt;m&lt;/code&gt; をテストするように依頼すると、モジュール &lt;code&gt;m_tests&lt;/code&gt; も検索され、それらのテストも実行されます。詳細については、セクション &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ModuleName&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">Erlang/OTPのビルドとインストールをカスタマイズしたい場合は、それぞれのステップについての詳細な情報を読んでください。</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">関数呼び出しをトレースする場合（つまり、プロセスにトレースフラグ &lt;code&gt;call&lt;/code&gt; 設定されている場合）、 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; して、必要な関数にトレースパターンを設定する必要があります。 / 2,3,4。関数は、トレースパターンがある場合にのみトレースされます。トレースパターンは、一致指定を使用して関数をトレースする方法を指定します。一致の仕様については、 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 記載されています。</target>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">代わりに、システムログをファイルに出力する場合は、デフォルトのハンドラーを構成してそのようにする必要があります。最も簡単な方法は、以下を &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; に含めることです。</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">対話モードを終了する場合（たとえば、 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; を使用して自動テスト実行を開始する場合）、関数 &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; を呼び出します。これにより、実行中の &lt;code&gt;ct&lt;/code&gt; アプリケーションがシャットダウンします。したがって、構成名と &lt;code&gt;require&lt;/code&gt; で作成されたデータとの関連付けは削除されます。関数 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; はインタラクティブモードに戻りますが、以前の状態は復元されません。</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">あなたは、レジストリ内の任意のポインタを保存したい場合は、指定した &lt;code&gt;size&lt;/code&gt; の &lt;code&gt;0&lt;/code&gt; を。この場合、オブジェクト自体は &lt;code&gt;ei_reg_dump()&lt;/code&gt; 操作では転送されず、ポインター値のみが転送されます。</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">キーボードでバックスティックが出せない場合は、kshバリアントを使うといいでしょう。</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">代わりにMinGWのMSYSを使用している場合は、 &lt;code&gt;C_DRV&lt;/code&gt; 設定を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">パッチでソースをアップグレードした場合、新しいビルドの前に以前のビルドからクリーンアップする必要があるかもしれません。 &lt;code&gt;make clean&lt;/code&gt; を実行する前に、以下の &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; セクションを必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">アプリケーションに複数のレベルの監督者がいる場合、単純にすべてのレベルで再起動の強度を同じ値に設定しないでください。再起動の合計数(トップレベルの監督者があきらめてアプリケーションを終了するまでの)は、失敗した子プロセスの上にいるすべての監督者の強度値の積になることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">ドライバがスクロール可能なカーソルをサポートしている場合は、もう少し自由度が高くなり、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">プロセスロジックがステートマシンとして説明するのに便利で、これらの &lt;code&gt;gen_statem&lt;/code&gt; の主要機能のいずれかが必要な場合：</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">テストコードが標準出力に書き込む場合、テストの実行時にコンソールにテキストが表示されないことに驚くかもしれません。これは、EUnitがテスト関数からすべての標準出力をキャプチャするためです（これには、セットアップ関数とクリーンアップ関数も含まれますが、ジェネレーター関数は含まれません）。これにより、エラーが発生した場合にテストレポートに含めることができます。テスト中にEUnitをバイパスしてテキストをコンソールに直接出力するには、 &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; 〜w &quot;、[Term]）のように、 &lt;code&gt;user&lt;/code&gt; 出力ストリームに書き込みます。これを行うための推奨される方法は、EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">たとえば、UNIXカーネルからの情報のみを監視する場合、行は &lt;code&gt;kern.LEVEL&lt;/code&gt; で始まります。 &lt;code&gt;LEVEL&lt;/code&gt; の可能な値については、 &lt;code&gt;syslog.conf(5)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">ただし、より残忍なバリエーションが望ましい場合、リリースアップグレードファイルは、単一のアップグレード命令 &lt;code&gt;restart_emulator&lt;/code&gt; のみを使用して手書きできます。この命令は、 &lt;code&gt;restart_new_emulator&lt;/code&gt; とは対照的に、&lt;strong&gt;すべての&lt;/strong&gt;アプリケーションの新しいバージョンでエミュレータを再起動します。</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">しかし、プロファイリング時間が短く、ホストマシンのOSが高解像度のCPU時間測定をサポートしていない場合、いくつかのOSのスケジューリングでは、実質的に何もしていない関数の実行時間がとんでもなく長くなることがあります。多かれ少なかれタプルを合成するだけの関数が、通常の実行時間の100倍程度の時間で実行され、トレースを繰り返すと実行時間が正常になった例が見られます。</target>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">次期は無視。</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igorは、コンパイルオプションで用語 &lt;code&gt;{igor, List}&lt;/code&gt; を検索します。ここで、 &lt;code&gt;List&lt;/code&gt; は次のようにIgor固有のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">イゴール:モジュールの合併とリナマー。</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">違法な記録の使用</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">2つのノードを想像してください &lt;code&gt;A&lt;/code&gt; はハンドシェイクを開始し、 &lt;code&gt;B&lt;/code&gt; は接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{addr,_}&lt;/code&gt; 直後に{ &lt;code&gt;{netmask,_}&lt;/code&gt; 続きます。</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">ソケットを一方向または二方向に即座に閉じます。</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">フラグ &lt;code&gt;broadcast&lt;/code&gt; が設定されて&lt;strong&gt;おらず&lt;/strong&gt;、 &lt;code&gt;pointtopoint&lt;/code&gt; フラグ&lt;strong&gt;が&lt;/strong&gt;設定されている場合 &lt;code&gt;{broadaddr,_}&lt;/code&gt; その直後に{broadaddr、_}が続きます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">ドライバーに（ &lt;code&gt;output&lt;/code&gt; コールバックの代わりに） &lt;code&gt;outputv&lt;/code&gt; コールバックを実装します。ドライバーに &lt;code&gt;outputv&lt;/code&gt; コールバックがある場合、iolistで &lt;code&gt;port_command/2&lt;/code&gt; の &lt;code&gt;Data&lt;/code&gt; 引数に渡されるrefcバイナリーは、ドライバーへの参照として渡されます。</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">ユーザー(複数)を実装する。</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">実装。バランス二値探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックの数である。</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">実装。バランス二値探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックのサイズの数である。</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">実装。バランスのとれたバイナリ探索木が使用される。時間の複雑さはlog Nに比例し、ここでNはフリーブロックの数である。</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">実装。フリーリストの最初のブロックを検査する。それが要求を満たす場合はそれを使用し、そうでない場合は新しいキャリアが作成されます。実装は一定の時間的複雑さを持っています。</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装：実装では、（各リストで）最大のブロック検索深度を持つ分離されたフリーリストを使用して、適切な適合をすばやく見つけます。最大ブロック検索深度が小さい場合（デフォルトでは3）、この実装は一定の時間の複雑さを持っています。最大ブロック検索深度は、パラメーター &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">マネージャーアプリケーションの実装</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">MIBの実装は、面倒な作業になる場合があります。ほとんどの場合、すべてのテーブルと変数が実装される前にエージェントをテストする必要があります。この場合、デフォルトの計測機能が役立ちます。ツールキットは、変数とテーブルのデフォルトのインストルメンテーション関数を生成できます。その結果、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;get&lt;/code&gt; 、 &lt;code&gt;get-next&lt;/code&gt; 、およびテーブル操作を処理できる実行中のプロトタイプエージェントが、プログラミングなしで生成されます。</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">Unicode文字セットのサポートを実装することは現在進行中のプロセスです。Erlang強化提案 (EEP)10はUnicodeサポートの基本を概説し、バイナリにデフォルトのエンコーディングを指定しました。</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">MIBの実装</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">結果が完了するまで呼び出し元を中断しないタイプのRPCであるpromiseを使用して&lt;strong&gt;呼び出しストリームを&lt;/strong&gt;実装し&lt;strong&gt;ます&lt;/strong&gt;。代わりに、後で値を収集するために使用できるキーが返されます。キーは、答えを提供する約束と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">内部CRL（証明書失効リスト）キャッシュを実装します。 &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 動作の実装に加えて、次の関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">グローバル（反復）検索を実装します（Perlのフラグ &lt;code&gt;g&lt;/code&gt; ）。各一致は、特定の一致と一致する部分式を含む個別の &lt;code&gt;list()&lt;/code&gt; として返されます（またはオプション &lt;code&gt;capture&lt;/code&gt; で指定された &lt;code&gt;list()&lt;/code&gt; です。したがって、このオプションが指定されている場合、戻り値の &lt;code&gt;Captured&lt;/code&gt; 部分はlist（）の &lt;code&gt;list()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">コンパイル時に変換を実装します。この関数は、ヘッダーファイル &lt;code&gt;ms_transform.hrl&lt;/code&gt; がソースコードに含まれている場合に、ソースコード変換を行うためにコンパイラーによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">&lt;code&gt;fun2ms/1&lt;/code&gt; 関数がシェルから呼び出されたときに変換を実装します。この場合、抽象形式は1つの楽しみ（Erlangシェルによって解析される）のためのものです。インポートされたすべての変数は、 &lt;code&gt;BoundEnvironment&lt;/code&gt; として渡されるキーと値のリストに含まれます。結果は正規化された用語、つまり抽象的な形式ではありません。</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">構成データをインポートします（ &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">インポートされた関数。ローカル関数と同じように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">&lt;code&gt;cover:export/1,2&lt;/code&gt; で作成されたファイル &lt;code&gt;ExportFile&lt;/code&gt; からカバレッジデータをインポートします。この後に実行される分析には、インポートされたデータが含まれます。</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">不適切な使用は、システムの性能を著しく低下させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">.emacsでは、スラッシュ文字&quot;/&quot;をパス区切り文字として使うことができます。しかし、バックスラッシュ&quot;\&quot;を使おうと思ったら、バックスラッシュを二重にしてはいけないということではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">1994年に、グローバルタグ付けモード &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; が導入されました。モジュールヘッダーに &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; を配置することにより、ASN.1コンパイラーは必要に応じて自動的にタグを追加します。以下は、 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; モードでの同じ仕様です。</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">8ビットの非UTF-8モードでは、コードポイントが256未満の文字のみが関連します。</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">では &lt;code&gt;$ERL_TOP&lt;/code&gt; 、というスクリプトがあり &lt;code&gt;otp_build&lt;/code&gt; 。このスクリプトは、 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; に必要なすべての適切なパラメーターを与える手間を処理し、Cygwin / MSYS / MSYS2でErlangソースを使用するための正しい環境変数を設定するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; 、わずか18ビットが重要です。残りは0であることがある &lt;code&gt;Creation&lt;/code&gt; 、2つだけのビットが重要です。残りは0 &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">で &lt;code&gt;Mnesia&lt;/code&gt; 、テーブル内のすべてのレコードは、同じ名前を持つ必要があります。すべてのレコードは、同じレコードタイプのインスタンスである必要があります。ただし、レコード名は必ずしもテーブル名と同じである必要はありませんが、これはこのユーザーズガイドのほとんどの例に当てはまります。プロパティ &lt;code&gt;record_name&lt;/code&gt; なしでテーブルが作成された場合、次のコードは、テーブル内のすべてのレコードがテーブルと同じ名前であることを確認します。</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">&lt;code&gt;Module:Name/Arity&lt;/code&gt; 、 &lt;code&gt;Module&lt;/code&gt; 、および &lt;code&gt;Name&lt;/code&gt; 原子であり、 &lt;code&gt;Arity&lt;/code&gt; 整数です。 Erlang / OTP R15以降、 &lt;code&gt;Module&lt;/code&gt; 、 &lt;code&gt;Name&lt;/code&gt; 、および &lt;code&gt;Arity&lt;/code&gt; も変数にすることができます。このように定義されたfun は、モジュール &lt;code&gt;Module&lt;/code&gt; の&lt;strong&gt;最新&lt;/strong&gt;バージョンのアリティ &lt;code&gt;Arity&lt;/code&gt; を持つ関数 &lt;code&gt;Name&lt;/code&gt; を参照します。この方法で定義されたfunは、それが定義されているモジュールのコードに依存しません。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">&lt;code&gt;Name/Arity&lt;/code&gt; 、 &lt;code&gt;Name&lt;/code&gt; 原子であり、 &lt;code&gt;Arity&lt;/code&gt; 整数です。 &lt;code&gt;Name/Arity&lt;/code&gt; は、既存のローカル関数を指定する必要があります。式は次の構文糖です。</target>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type_List&lt;/code&gt; 各デコードされていないサブコンポーネントにトップ型から「パス」が記載されています。パスの一番上のタイプは、その名前であるアトムです。続く各コンポーネント/タイプに対するアクションは、 &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; いずれかによって記述されます。</target>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;attr&lt;/code&gt; オブジェクトの属性論理として格納され&lt;strong&gt;OR&lt;/strong&gt;そのタイプ（の一つの &lt;code&gt;EI_INT&lt;/code&gt; 、 &lt;code&gt;EI_FLT&lt;/code&gt; 、 &lt;code&gt;EI_BIN&lt;/code&gt; 、及び &lt;code&gt;EI_STR&lt;/code&gt; それが削除対象としてマークされているか否か）、（ &lt;code&gt;EI_DELET&lt;/code&gt; ）、そしてそれが最後のバックアップ以降に変更されたか否か &lt;code&gt;Mnesia&lt;/code&gt; （ &lt;code&gt;EI_DIRTY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">&lt;code&gt;ch1.erl&lt;/code&gt; と &lt;code&gt;ch2.erl&lt;/code&gt; の実装、上記 &lt;code&gt;channels/0&lt;/code&gt; 、 &lt;code&gt;alloc/1&lt;/code&gt; 、及び &lt;code&gt;free/2&lt;/code&gt; 、それが例と関連していないように意図的に除外されています。完全を期すために、これらの関数を記述する1つの方法を以下に示します。これは単なる例であり、現実的な実装では、割り当てるチャネルが不足するなどの状況を処理できなければなりません。</target>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">&lt;code&gt;ei_s_print_term()&lt;/code&gt; は、パラメータ &lt;code&gt;s&lt;/code&gt; 、動的に（malloc関数）に割り当てられた文字列へのポイントである &lt;code&gt;BUFSIZ&lt;/code&gt; バイトまたは &lt;code&gt;NULL&lt;/code&gt; のポインタ。結果が &lt;code&gt;BUFSIZ&lt;/code&gt; 文字を超える場合、この関数によって文字列を再割り当てできます（ &lt;code&gt;*s&lt;/code&gt; を更新できます）。返される文字列は &lt;code&gt;NULL&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">では &lt;code&gt;file_logger&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">では &lt;code&gt;latin1&lt;/code&gt; のモードで、ファイル名はバイト単位符号化されています。これにより、システム内のすべてのファイル名のリスト表示が可能になります。ただし、「&amp;Ouml;stersund.txt」という名前のファイルは、 &lt;code&gt;file:list_dir/1&lt;/code&gt; に「&amp;Ouml;stersund.txt」（ファイル名がファイルを作成するプログラムによって &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; ISO Latin-1でエンコードされている場合）、またはおそらく[195,150,115,116,101,114,115,117,110,100として表示されます。 ]は、UTF-8バイトを含むリストです（必要なものではありません）。そのようなシステムでUnicodeファイル名変換を使用する場合、UTF-8以外のファイル名は &lt;code&gt;file:list_dir/1&lt;/code&gt; などの関数によって無視されます。それらはfunction &lt;code&gt;file:list_dir_all/1&lt;/code&gt; で取得できますが、誤ってエンコードされたファイル名は「生のファイル名」として表示されます。</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">では &lt;code&gt;latin1&lt;/code&gt; のモードで、ErlangのVMは、ファイル名のエンコーディングを変更しません。では &lt;code&gt;utf8&lt;/code&gt; モードで、ファイル名が255より大きいUnicode文字を含めることができ、VMは、（Windows上で通常はUTF-8が、UTF-16）ネイティブエンコーディングファイル名に前後にファイル名を変換します。</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">で &lt;code&gt;list_max/2&lt;/code&gt; 、あなたはリストを歩くと使用 &lt;code&gt;Head&lt;/code&gt; 代わりに &lt;code&gt;Result_so_far&lt;/code&gt; &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;when&lt;/code&gt; は、関数の-&amp;gt;の前に使用される特別な単語であり、後続のテストが真の場合にのみ関数のこの部分を使用することを示します。このタイプのテストは、&lt;strong&gt;ガード&lt;/strong&gt;と呼ばれます。ガードがfalseの場合（つまり、ガードが失敗した場合）、関数の次の部分が試行されます。この場合、 &lt;code&gt;Head&lt;/code&gt; が &lt;code&gt;Result_so_far&lt;/code&gt; より大きくない場合は、それ以下にする必要があります。これは、関数の次の部分のガードが不要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">で &lt;code&gt;sort&lt;/code&gt; 楽しみが使用されます。</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">では &lt;code&gt;terminal_logger&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">では &lt;code&gt;unicode&lt;/code&gt; モードで、ASCIIのみの数字と文字は、バックスラッシュの後に特別な意味を持ちます。他のすべての文字（特に、コードポイントが127より大きい文字）はリテラルとして扱われます。</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">AEAD解読（関連するデータで認証暗号化）モードでは、 &lt;code&gt;CipherText&lt;/code&gt; に記載の &lt;code&gt;Type&lt;/code&gt; ブロック暗号の真偽確認 &lt;code&gt;PlainText&lt;/code&gt; と &lt;code&gt;AAD&lt;/code&gt; 用いて（関連する認証されたデータ） &lt;code&gt;CipherTag&lt;/code&gt; を。復号化または検証が失敗した場合、 &lt;code&gt;error&lt;/code&gt; 返すことがあります</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">AEAD（関連するデータで認証暗号化）モード、暗号で &lt;code&gt;PlainText&lt;/code&gt; に記載の &lt;code&gt;Type&lt;/code&gt; ブロック暗号と計算 &lt;code&gt;CipherTag&lt;/code&gt; をも認証すること &lt;code&gt;AAD&lt;/code&gt; （関連する認証されたデータを）。</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">ASN.1では、それ自体が構造化型であるコンポーネントを持つことも可能です。例えば、以下のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">ASN.1では持つことができます。</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">ASN.1では、 &lt;code&gt;BIT STRING&lt;/code&gt; 定義は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">Megaco/H.248仕様(RFC 3525)の付録Aには、代表的な呼の流れを示すメッセージが約30個あります。また、バージョン1、バージョン2、バージョン3のメッセージを追加しました。これらのメッセージを測定の基礎として使用しています。私たちの数値は、メディアゲートウェイとそのコントローラの間で送信される異なる種類のメッセージの頻度に関しては、重み付けされていません。</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">Erlangのコードでは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">Erlangでは、BIFの &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; を使用して、用語を外部形式に変換します。バイナリデータエンコーディングを用語に変換するには、BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">Erlangでは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">Erlangでは、バイナリを構築したりバイナリパターンをマッチさせたりするためにBinが使われます。Binは次のような構文で書かれています。</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">Erlangでは、文字列は整数のリストです。Erlang/OTP R13までは文字列はISO Latin-1 (ISO 8859-1)の文字セットでエンコードされると定義されていました。</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;SET&lt;/code&gt; タイプは &lt;code&gt;SEQUENCE&lt;/code&gt; とまったく同じように使用されます。BERまたはDERエンコーディングルールを使用する場合、コンポーネントをソートする必要があるため、 &lt;code&gt;SET&lt;/code&gt; のデコードは &lt;code&gt;SEQUENCE&lt;/code&gt; のデコードよりも遅いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;unicode&lt;/code&gt; モジュールやビット構文のように、該当する場合は完全なUTF-16範囲がサポートされています。</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">Erlangでは、 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; でマークを取得するためのインターフェースがないため、Erlangプログラマーに関連するのは2次的な目的のみです。</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">Erlang/OTP 17.0では、ErlangソースファイルのエンコーディングのデフォルトがUTF-8に変更されました。</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">Erlang/OTP 20.0では、アトムと関数はUnicode文字を含むことができます。モジュール名、アプリケーション名、ノード名はまだISO Latin-1の範囲に制限されています。</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">Erlang / OTP 21.0では、ロギング用の新しいAPIが追加されました。古い &lt;code&gt;error_logger&lt;/code&gt; モジュールは引き続きレガシーコードで使用できますが、ログイベントは新しいLogger APIにリダイレクトされます。新しいコードでは、Logger APIを直接使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP R16Bでは、Erlangトークンの構文がUnicodeを処理するように拡張されました。サポートは文字列リテラルとコメントに限定されていました。ErlangソースファイルでのUnicodeの使用の詳細については、 &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B以降のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; ディレクトリは &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; の下にあります。ここで、 &lt;code&gt;OTPROOT&lt;/code&gt; はOTPインストールのルートディレクトリです（最近の例では &lt;code&gt;/usr/local/otp&lt;/code&gt; ）。 &lt;code&gt;VSN&lt;/code&gt; はErl_Interfaceアプリケーションのバージョンです（最近の例では3.2.1）。</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B以降のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; ディレクトリは &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; の下にあります。ここで、 &lt;code&gt;OTPROOT&lt;/code&gt; はOTPインストールのルートディレクトリです（最近の例では &lt;code&gt;/usr/local/otp&lt;/code&gt; ）。 &lt;code&gt;VSN&lt;/code&gt; はErl_interfaceアプリケーションのバージョンです（最近の例では3.2.1）。</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">Erlang / OTP R6Bでは、JavaのErl_Interfaceに似たライブラリがjinterfaceと呼ばれる&lt;strong&gt;よう&lt;/strong&gt;に追加され&lt;strong&gt;ました&lt;/strong&gt;。JavaプログラムがErlangノードと通信するためのツールを提供します。</target>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">Erlang / OTPでは、TCP / IPおよびUDPソケットへのアクセスは、カーネルのモジュール &lt;code&gt;gen_tcp&lt;/code&gt; および &lt;code&gt;gen_udp&lt;/code&gt; によって提供されます。どちらも使いやすく、ソケットの概念に関する詳細な知識は必要ありません。</target>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">FIPSモードでは、FIPSに準拠していないアルゴリズムはすべて無効になり、例外 &lt;code&gt;not_supported&lt;/code&gt; がスローされます。Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; 、FIPSモードで使用可能なアルゴリズムの制限リストを返すことをサポートしています。</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">FIPS モードでは、検証されていないアルゴリズムは無効になります。これは、暗号に依存するアプリケーションにおいて予期せぬ問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">ドイツ語では、文字「&amp;szlig;」（シャープs）は小文字ですが、対応する大文字は「SS」です。</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">ギリシャ語では、文字「&amp;Sigma;」には2つの異なる小文字形式があります。単語の最終位置にある「&amp;sigmaf;」とそれ以外の場所にある「&amp;sigma;」です。</target>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">OTP20では、rsa kexchangeを使用する暗号スイートをすべて削除することが望ましい(21ではデフォルトから削除されている)。</target>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">OTP R16では、オプションが簡素化されました。バックエンドは、 &lt;code&gt;ber&lt;/code&gt; 、 &lt;code&gt;per&lt;/code&gt; 、 &lt;code&gt;uper&lt;/code&gt; のいずれかのオプションを使用して選択されます。オプション &lt;code&gt;optimize&lt;/code&gt; 、 &lt;code&gt;nif&lt;/code&gt; 、および &lt;code&gt;driver&lt;/code&gt; オプションは不要になりました（使用すると、ASN.1コンパイラーは警告を生成します）。オプション &lt;code&gt;ber_bin&lt;/code&gt; 、 &lt;code&gt;per_bin&lt;/code&gt; 、および &lt;code&gt;uper_bin&lt;/code&gt; オプションは引き続き機能しますが、警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">R9C以前のOTPリリースでは、さらに処理を行った後の抽象コードがBeamファイルに格納されていました。タプルの最初の要素は、 &lt;code&gt;abstract_v1&lt;/code&gt; （OTP R7Bの場合）または &lt;code&gt;abstract_v2&lt;/code&gt; （OTP R8Bの場合）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">OTPでは、&lt;strong&gt;アプリケーションと&lt;/strong&gt;は、特定の機能を実装するコンポーネントを意味し&lt;strong&gt;ます。これ&lt;/strong&gt;は、1つの単位として開始および停止でき、他のシステムで再利用できます。このモジュールは、すべてのErlangランタイムシステムで開始されるプロセスである&lt;strong&gt;アプリケーションコントローラー&lt;/strong&gt;と対話し&lt;strong&gt;ます&lt;/strong&gt;。このモジュールには、アプリケーションを制御するための関数（たとえば、アプリケーションの起動と停止）と、アプリケーションに関する情報にアクセスするための関数（たとえば、構成パラメーター）が含まれています。</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">OTPでは、&lt;strong&gt;イベントマネージャ&lt;/strong&gt;はイベントを送信できる名前付きオブジェクトです。&lt;strong&gt;イベントは&lt;/strong&gt;、例えば、エラー、アラーム、またはログに記録されるいくつかの情報とすることができます。</target>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">：PCREでは、サブパターンは3つの方法のいずれかで名前を付けることができます &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; または &lt;code&gt;(?'name'...)&lt;/code&gt; はPerlのように、または &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; のようにPython。後方参照、再帰、条件など、パターンの他の部分から括弧をキャプチャするための参照は、名前と番号で行うことができます。</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">PCREでは、&quot;bab &quot;にマッチします。最初の捕獲括弧は &quot;b &quot;にマッチし、第2のグループでは、後方参照の\1が &quot;b &quot;にマッチしなかった場合、第2の代替案は &quot;a &quot;にマッチし、その後、再帰する。再帰では、\1 が &quot;b&quot; にマッチするようになり、全体のマッチが成功します。Perlでは、再帰呼び出しの中で、\1が外部から設定された値にアクセスできないため、パターンはマッチしません。</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">Perl では、\l,\L,\u,\U は、文字列ハンドラで認識され、以下の文字の大文字小文字を変更するために使用されます。PCRE はこれらのエスケープシーケンスをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">R4B以前のバージョンのOTPでは、 &lt;code&gt;include&lt;/code&gt; および &lt;code&gt;lib&lt;/code&gt; は &lt;code&gt;OTPROOT/usr&lt;/code&gt; の下にあります。</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">SNMPでは、 &lt;code&gt;set&lt;/code&gt; 操作はアトミックです。 &lt;code&gt;set&lt;/code&gt; 演算で指定されたすべての変数が変更されるか、何も変更されません。したがって、 &lt;code&gt;set&lt;/code&gt; 演算は2つのフェーズに分けられます。最初のフェーズでは、各変数の新しい値がMIB内の変数の定義に対してチェックされます。次の定義がチェックされます。</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">SNMPv1およびSNMPv2cでは、メッセージ内のコミュニティ文字列は(少なくとも)3つの異なる目的で使用されていました。</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">SNMPv3では、これらの使用領域ごとに独自のメカニズムがあります。コンテキストは、SNMPエンティティの名前である &lt;code&gt;contextName&lt;/code&gt; コンテキストの名前である &lt;code&gt;contextEngineID&lt;/code&gt; で識別されます。各SNMPv3メッセージには、これら2つのパラメーターの値が含まれています。</target>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">トルコ語では、ドット付きの「i」もドットなしの「i」も小文字と大文字で存在します。</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">UTF-8モードでは、255より大きい値（0xffff）の文字を、データ単位のリテラル文字列として、または\ x {エスケープメカニズムを使用してクラスに含めることができます。</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Unicodeファイル名モードでは、オプション &lt;code&gt;{spawn_executable,...}&lt;/code&gt; BIF &lt;code&gt;open_port/2&lt;/code&gt; に指定されたファイル名もUnicodeとして解釈されます。そのため、 &lt;code&gt;spawn_executable&lt;/code&gt; を使用するときに使用できるオプション &lt;code&gt;args&lt;/code&gt; 指定されたパラメーターリストも同様です。バイナリを使用すると、引数のUTF-8変換を回避できます。「 &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">Unicode モー ド では、 量詞は個々のデー タ 単位ではな く キ ャ ラ ク タ に適用 さ れます。したがって、たとえば Æx{100}{2}は 2 文字にマッチします。同様に、「\X{3}」は3つのUnicode拡張書記素クラスタにマッチしますが、それぞれのクラスタは何個ものデータ単位の長さになることがあります(長さも様々です)。</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">Unicodeモードでは、コードポイントが255を超える2つの文字が追加されます：LS（行区切り、U + 2028）とPS（段落区切り、U + 2029）。これらの文字を認識するために、Unicode文字プロパティのサポートは必要ありません。</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">Windowsでは、ディレクトリの区切り文字はすべてフォワードスラッシュで、ドライブレターは小文字になります。</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windowsでは、引数にバックスラッシュが含まれている場合でも、すべての関数がスラッシュのみのファイル名を返します。冗長なディレクトリセパレータを削除してファイル名を正規化するには、 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">CTHでは、以下の機能の後に動作をフックインすることができます。</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">CTHでは、以下の機能の前に動作をフックインすることができます。</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">KDE環境で、[ &lt;strong&gt;KDEコントロールセンター（個人設定）]&lt;/strong&gt; &amp;gt; [ &lt;strong&gt;地域とユーザー補助]&lt;/strong&gt; &amp;gt; [ &lt;strong&gt;キーボードレイアウト&lt;/strong&gt;&lt;strong&gt;]を&lt;/strong&gt;選択します。</target>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">UTFモードでは、PCREはlookbehindの長さを計算することができないため、lookbehindアサーションでは \Cエスケープ(UTFモードでも単一のデータユニットにマッチする)を許可しない。異なる数のデータユニットにマッチすることができる \Xおよび\Rエスケープも許可されていません。</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">Unix (ボーン)シェルでは、以下のようになります (改行は読みやすくするためのもので、タイプしたときには存在しません)。</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">ブラックボックステストシナリオでは、 &lt;code&gt;Common Test&lt;/code&gt; ベースのテストプログラムは、標準のO＆MおよびCLIプロトコルを介してターゲットシステムに接続します。 &lt;code&gt;Common Test&lt;/code&gt; は、これらのプロトコルの一部（OTPではスタンドアロンコンポーネントおよびアプリケーションとして存在する）の実装およびそれらへのラッパーインターフェイスを提供します。ラッパーは、構成を簡素化し、ロギングの目的で詳細度を追加します。 &lt;code&gt;Common Test&lt;/code&gt; は、便利なサポートモジュールで継続的に拡張されています。ただし、 &lt;code&gt;Common Test&lt;/code&gt; ラッパーを必要とせずに、 &lt;code&gt;Common Test&lt;/code&gt; でのテスト目的で任意のErlang / OTPコンポーネントを使用することは簡単なタスクであることに注意してください。 Erlang関数を呼び出すのと同じくらい簡単です。多くのターゲットに依存しないインターフェースがサポートされています &lt;code&gt;Common Test&lt;/code&gt; Generic TelnetやFTPなどの一般的なテスト。これらは、計測器、トラフィック負荷ジェネレータなどを制御するために特化するか、直接使用できます。</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">コールバックモジュールで</target>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">分散Erlangシステムでは、他のすべてのノードに接続せずにノードに接続すると便利な場合があります。例としては、システムの状態を乱さずに検査するために使用される、ある種のO＆M機能があります。この目的のために、&lt;strong&gt;非表示ノード&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">複数のErlangノードを持つ分散システムでは、分散した方法でアプリケーションを制御する必要があります。あるアプリケーションが動作しているノードがダウンした場合、別のノードでアプリケーションを再起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">将来の Erlang/OTP リリースでは、共有を保存する方法が実装されるかもしれません(オプションで)。</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">将来のリリースでは、引数 &lt;code&gt;Dir&lt;/code&gt; のタイプが正しくないと、例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">将来のリリースでは、引数 &lt;code&gt;Filename&lt;/code&gt; のタイプが正しくないと、例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将来のリリースでは、この関数はさらに多くの値と範囲を返す可能性があります。互換性の問題を回避するには、関数 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">大きなパターンでは、括弧の数字を追跡するのは厄介です。これは相対参照を使用することで簡単になります。上のパターンの(?1)の代わりに、(?-2)と書くことで、再帰の前に開いた2番目に最近開いた括弧を参照することができます。つまり、負の数は、それが遭遇した時点から左に向かって括弧をキャプチャすることをカウントします。</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">ユーザ(この場合はMGC)が複数のErlangノードに分散している大規模なシステムでは、少し違って見えます。ここではエンコーディングは発信元のErlangノード(1)で行われ、バイナリは物理的なネットワークインターフェースを持つノード(2)に転送されます。潜在的なメッセージの返信がノード(2)のインターフェースで受信されると、そこでデコードされ、メッセージ内の各トランザクションに対して異なるアクションが実行されます。トランザクション返信は、他のタイプのトランザクションがノード(2)上でローカルに処理される間、そのデコードされた形で発信ノード(1)に転送される。</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">関数 &lt;code&gt;mnesia:index_read/3&lt;/code&gt; と同様の方法で、レコードを一致させようとするときに、任意のインデックス情報を使用できます。この関数は、関数 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; と同じルールに従うパターンを取りますが、この関数には以下の条件が必要です。</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">単調に増加する値の列において、前任者を持つすべての値は、その前任者よりも大きいか、または等しいかのいずれかである。</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">リリースの新しいバージョンでは、アプリケーション &lt;code&gt;ch_app&lt;/code&gt; がprim_appに含まれ &lt;code&gt;prim_app&lt;/code&gt; 。それは、その最上位のスーパーバイザ、ある &lt;code&gt;ch_sup&lt;/code&gt; は子プロセスとして開始する &lt;code&gt;prim_sup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">パターンマッチングでは、左側の &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; が右側の &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; と照合されます。マッチングが成功すると、パターン内のバインドされていない変数がバインドされます。照合が失敗すると、実行時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">厳密に単調に増加する値の列では、前任者を持つすべての値がその前任者よりも大きい。</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">監督ツリーでは、プロセスの多くが似たような構造を持っており、似たようなパターンに従っています。例えば、監督者は構造が似ています。それらの間の唯一の違いは、どの子プロセスを監督するかということです。ワーカーの多くは、サーバ・クライアント関係のサーバ、有限状態マシン、エラーロガーなどのイベントハンドラです。</target>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">システム内のシステムプロセスと特別なプロセス、ビヘイビアの一つに存在する以外は、OTP設計原則、全てのプロセスに従って実施 &lt;code&gt;supervisor&lt;/code&gt; 、 &lt;code&gt;gen_server&lt;/code&gt; 、 &lt;code&gt;gen_fsm&lt;/code&gt; 、 &lt;code&gt;gen_statem&lt;/code&gt; 又は &lt;code&gt;gen_event&lt;/code&gt; 。これらはSTDLIBアプリケーションに属し、アップグレード/ダウングレードは通常エミュレータの再起動が必要です。</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; ノードのシステムでは、すべてのノードがすべてのテーブルの現在の場所を認識しています。この例では、データは両方のノードで複製され、テーブル内のデータを操作する関数は2つのノードのいずれかで実行できます。 &lt;code&gt;Mnesia&lt;/code&gt; データを操作するコードは、データがどこにあっても同じように動作します。</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">OTP設計原則に従って構築されたシステムでは、プロセスはすべてスーパーバイザに属する子プロセスになります。スーパーバイザの変更における &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">比較的少数のプロセスを使用するシステムでは、 &lt;code&gt;erl&lt;/code&gt; に &lt;code&gt;+h&lt;/code&gt; オプションを使用するか、または &lt;code&gt;spawn_opt/4&lt;/code&gt; に &lt;code&gt;min_heap_size&lt;/code&gt; オプションを使用してプロセスごとに最小ヒープサイズを増やすことにより、パフォーマンス&lt;strong&gt;が&lt;/strong&gt;向上する&lt;strong&gt;可能性&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">TCPベースの配布を使用するシステムでは、このデータは、分散ノードの起動時に&lt;strong&gt;接続&lt;/strong&gt;される&lt;strong&gt;Erlangポートマッパーデーモン&lt;/strong&gt;（ &lt;code&gt;epmd&lt;/code&gt; ）に保持されます。ロックファイルとUDSリスンソケットの名前の規則により、この配布モジュールを使用するときに &lt;code&gt;epmd&lt;/code&gt; が不要になります。UDSは常に1つのホストに制限されているため、ポートマッパーを回避するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">SNMPで監視されるテーブルでは、すべての要素は整数、文字列、または整数のリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">ターゲットシステムでは、リリースアップグレードファイルはディレクトリ &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">テストスイートでは、関連する値をテストケースまたは構成関数で読み取ろうとする前に、構成変数（前の定義では &lt;code&gt;CfgVarName&lt;/code&gt; ）が存在している&lt;strong&gt;必要&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">タプル &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; で、 &lt;code&gt;CSSFile&lt;/code&gt; にパスが指定されている場合（例： &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; 、このフルネームを使用してファイルが検索されます。ただし、ファイル名のみが指定されている場合（例えば、 &lt;code&gt;categories.css&lt;/code&gt; ）、CSSファイルはスイートのデータディレクトリ &lt;code&gt;data_dir&lt;/code&gt; にあると想定されます。後者の使用は、スイートのハードコーディングパス名に比べて移植性があるため推奨されます。</target>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; に定義された &lt;code&gt;{Item,Value}&lt;/code&gt; ペアに加えて、次のアイテムが許可されます：</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">コールグラフに加えて、&lt;strong id=&quot;inter_call_graph&quot;&gt;インターコールグラフ&lt;/strong&gt;と呼ばれるグラフがあり ます。これは呼び出し（From、To）のグラフで、コールグラフにはFromからToへの呼び出しのチェーンがあり、すべてのFromおよびToはエクスポートされた関数または未使用のローカル関数です。頂点はコールグラフと同じです。</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">鍵交換、ペイロード暗号化、メッセージ認証、および疑似ランダム計算に使用される暗号スイートによってネゴシエートされるアルゴリズムに加えて、 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; TLS署名アルゴリズム拡張を使用して、TLS 1.2から、 TLSハンドシェイク中に使用する署名アルゴリズム。 1.2より前のTLSバージョンがサポートされていない場合、クライアントは、このオプションで指定されたアルゴリズムを使用してTLS署名アルゴリズム拡張を送信します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">ここでのドキュメントに加えて、Erlangは最近の本でもいくつか説明されています。</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">先ほどのものに加えて。</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">必須のコールバック関数に加えて、 &lt;code&gt;log/2&lt;/code&gt; 、ハンドラモジュールは、オプションのコールバック関数をエクスポートすることができ &lt;code&gt;adding_handler/1&lt;/code&gt; 、 &lt;code&gt;changing_config/2&lt;/code&gt; 及び &lt;code&gt;removing_handler/1&lt;/code&gt; 。これらの関数の詳細については、logger（3）マニュアルページの「 &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">ファイルを受信および送信するための通常の関数（ &lt;code&gt;recv/2&lt;/code&gt; 、 &lt;code&gt;recv/3&lt;/code&gt; 、 &lt;code&gt;send/2&lt;/code&gt; 、および &lt;code&gt;send/3&lt;/code&gt; を参照）に加えて、リモートファイルをバイナリとして受信する（ &lt;code&gt;recv_bin/2&lt;/code&gt; を参照）ための関数と、バイナリをに送信するための関数があります。リモートファイルとして保存されます（ &lt;code&gt;send_bin/3&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">前述の表現に加えて、仕様が &lt;code&gt;legacy_erlang_types&lt;/code&gt; オプションを使用してコンパイルされている場合は、次の非推奨の表現を使用できます。</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">フォームの表現に加えて、モジュール宣言を表すリスト &lt;code&gt;epp(3)&lt;/code&gt; &lt;code&gt;erl_parse(3)&lt;/code&gt; およびerl_parse（3）の関数によって返される）には、以下を含めることができます。</target>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">前述の標準的なUnicodeプロパティに加えて、PCREは、\ wや\ sなどの従来のエスケープシーケンスを変換してUnicodeプロパティを使用できるようにする4つをサポートしています。PCREは、 &lt;code&gt;ucp&lt;/code&gt; オプションが渡されたときに、これらの非標準、非Perlプロパティを内部で使用します。ただし、明示的に使用することもできます。プロパティは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">静的な監視ツリーに加えて、動的な子プロセスは、以下の呼び出しで既存のスーパバイザに追加することができます。</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">トレースログファイルに加えて、拡張子が &lt;code&gt;.ti&lt;/code&gt; のファイルがTrace Tool Builderの起動時に作成されます。トレース情報ファイルです。これは、プロセス情報、使用されるトレースフラグ、それが属するノードの名前、および関数 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; で書き込まれたすべての情報を含むバイナリファイルです。トレースが停止すると、 &lt;code&gt;.ti&lt;/code&gt; ファイルは常に他のログとともにフェッチされます。</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">これらのオプションに加えて、&lt;strong&gt;生の&lt;/strong&gt;オプション仕様を使用できます。rawオプションは、タグ &lt;code&gt;raw&lt;/code&gt; で始まり、プロトコルレベル、オプション番号、およびバイナリとして指定されたオプション値が続くアリティ4のタプルとして指定されます。これは、CソケットAPIの &lt;code&gt;setsockopt&lt;/code&gt; 呼び出しの2番目、3番目、および4番目の引数に対応します。オプション値は、プラットフォームのネイティブエンディアンでコーディングする必要があり、構造が必要な場合は、特定のプラットフォームの構造整列規則に従う必要があります。</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">これらに加えて、次のフィールドがLoggerによって自動的に挿入されます。値は、2つの最初のパラメーターから &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; に取得されます。</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">この紹介の章に加えて、「 &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide」には次の章が含まれています。</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、Megacoユーザーズガイドには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、Reltool ユーザーズガイドには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">この入門編に加えて、SNMP User's Guideには以下の章があります。</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;#Record.Name&lt;/code&gt; はレコード &lt;code&gt;Record&lt;/code&gt; の &lt;code&gt;Name&lt;/code&gt; のタプル表現でインデックスを返します。</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">また、EUNITも名前があり、別のモジュールを探します &lt;code&gt;ModuleName&lt;/code&gt; のプラス接尾辞 &lt;code&gt;_tests&lt;/code&gt; 、それが存在する場合、そのモジュールからのすべてのテストも追加されます。（場合 &lt;code&gt;ModuleName&lt;/code&gt; のが既にサフィックス含ま &lt;code&gt;_tests&lt;/code&gt; を、これを行わない。）、例えば、仕様 &lt;code&gt;{module, mymodule}&lt;/code&gt; モジュール内のすべてのテストを実行する &lt;code&gt;mymodule&lt;/code&gt; と &lt;code&gt;mymodule_tests&lt;/code&gt; 。通常、 &lt;code&gt;_tests&lt;/code&gt; モジュールには、メインモジュールのパブリックインターフェイスを使用する（他のコードは使用しない）テストケースのみを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、テーブルのプロパティを設定および変更できます。詳細については、 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">また、以下の3つの組み込み型が存在し、以下に定義されているように考えることができますが、厳密にはそれらの「型の定義」は、上記で定義された型言語による有効な構文ではありません。</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">また、レコード型を使用する際には、以下のようにフィールドの型情報を付加することで、レコード型のフィールドをさらに指定することができます。</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">さらに、おそらく &lt;code&gt;dbg&lt;/code&gt; モジュールと、場合によっては &lt;code&gt;seq_trace&lt;/code&gt; モジュールについても理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">すべての関数エラーで、 &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; がスローされることがあります。ここで、 &lt;code&gt;Reason&lt;/code&gt; はエラーを説明しています。</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">これらすべてのケースで、 &lt;code&gt;ReplyInfo&lt;/code&gt; は次の構造を持っています。</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">他のすべてのケースで</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">他のすべての意味で、 &lt;code&gt;_tmo&lt;/code&gt; 関数は、 &lt;code&gt;_tmo&lt;/code&gt; サフィックスのない関数からすべての戻り値とセマンティクスを継承します。</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">上記のすべての例では、オブジェクトは存在していなければならず、指定された操作に適した型でなければなりません。オブジェクトの型がわからない場合は、問い合わせてみましょう。</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">OTPソースコードツリーでは、OTPバージョンはテキストファイル &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; から読み取ることができます。ファイルへの絶対パスは、 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; 呼び出すことで作成できます。</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">このAPIの以前のバージョンでは、 &lt;code&gt;lookup&lt;/code&gt; 関数は2つの引数を受け取り、 &lt;code&gt;Issuer&lt;/code&gt; を省略していました。互換性のため、これは引き続きサポートされています。コールバックモジュールに &lt;code&gt;lookup/2&lt;/code&gt; &lt;code&gt;lookup/3&lt;/code&gt; 関数がない場合は、代わりにlookup / 2が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">組み込みシステムでは、通常、対話型シェルはありません。ただし、オペレーターはコマンド &lt;code&gt;to_erl&lt;/code&gt; で Erlangシステムに接続できます。次に、オペレーターはErlangシェルに接続され、通常のErlangコマンドを実行できます。このシェルを介したシステムとのすべての対話は、特別なディレクトリに記録されます。</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">インストールされているOTP開発システムでは、OTPバージョンはテキストファイル &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; から読み取ることができます。ファイルへの絶対パスは、 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; 呼び出して構築できます。</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">インタラクティブシステムでは、コードローダーはデマンド駆動型のコードロードを提供しますが、組み込みシステムでは、コードローダーはすべてのコードをすぐにロードします。どちらの場合も、同じバージョンの &lt;code&gt;code&lt;/code&gt; が使用されます。コードサーバーは &lt;code&gt;init:get_argument(mode)&lt;/code&gt; を呼び出して、デマンドモードまたは非デマンドドリブンモードのどちらで実行するかを決定します。</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">いずれの場合も、現在のトークンが設定される。特に、受信したメッセージのトークンが空の場合は、プロセスの現在のトークンが空に設定されます。</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">どちらの場合も、テーブル内で最初にアクセス可能な要素を返す必要があります。キーカラムはアクセスできないので、これは3番目のカラムが最初の行であることを意味します。</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">前の両方の例では、 &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; は、トレースされた関数の直後にトレーストークンをリセットして、Erlangシェルでの出力による多くのトレースメッセージを回避します。</target>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">簡単に言えば、 &lt;code&gt;Common Test&lt;/code&gt; は以下をサポートします。</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">簡単に説明すると、CTHでは以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">簡単に言うと、CTHを使うことで可能になります。</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">簡単に言うと、単純なテストオブジェクトは、引数を取らない単一の関数で構成されています（おそらく、追加のメタデータ（つまり、行番号）で注釈が付けられています）。関数の評価は、何らかの値（無視されます）を返すことによって&lt;strong&gt;成功する&lt;/strong&gt;か、例外をスローすることによって&lt;strong&gt;失敗&lt;/strong&gt;します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
