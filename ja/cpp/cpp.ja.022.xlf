<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">インデックス &lt;code&gt;I&lt;/code&gt; が0でも1でもない場合、インデックスベースのオーバーロード（1〜4）はコンパイルに失敗します。</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">示された演算子はタイプ &lt;code&gt;T&lt;/code&gt; に適用できます</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">インダイレクト演算子とメンバ演算子は、多くのイテレータやスマートポインタクラスによってオーバーロードされています。</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">インダイレクト演算子の式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">この機能によって提供される情報は、通常、ディレクトリ反復の副生成物として提供され、そしてのメンバー関数によって得ることができる &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; 。ディレクトリの反復中に、 &lt;code&gt;status&lt;/code&gt; 再度呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">この関数によって提供される情報は、通常、ディレクトリ反復の副産物としても提供されます。ディレクトリの反復中に、 &lt;code&gt;exists(*iterator)&lt;/code&gt; を呼び出すことは、 &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; よりも効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">継承されたコンストラクターは、本体が空で、&lt;a href=&quot;constructor&quot;&gt;メンバーの初期化子リスト&lt;/a&gt;が1つの入れ子になった名前指定子で構成され、そのすべての引数を基本クラスコンストラクターに転送するユーザー定義コンストラクターと同等です。</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">初期値は、&lt;a href=&quot;declarations&quot;&gt;宣言子&lt;/a&gt;または&lt;a href=&quot;new&quot;&gt;新しい式&lt;/a&gt;の初期化セクションで指定できます。また、関数の呼び出し中にも実行されます。関数のパラメーターと関数の戻り値も初期化されます。</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">クラスまたは識別子が&lt;a href=&quot;derived_class&quot;&gt;仮想基本クラスを&lt;/a&gt;指定する初期化子は、構築されるオブジェクトの最も派生したクラスではないクラスのコンストラクターの実行中は無視されます。</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">注入されたクラス名は、当該クラスの範囲内のクラス名です。</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">クラス・テンプレートまたはクラス・テンプレート専門化の注入されたクラス名は、スコープ内であればどこでもテンプレート名または型名として使用することができます。</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">インライン指定子は、ブロックスコープ(別の関数内)での関数や変数(C++17 以降)の宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">インライン指定子は、変換単位で既に定義されている関数や変数(C++17 以降)を非インラインとして再定義することはできません。</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">入力は、ステージ1で選択された変換指定子を使用して &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; ように解析されます</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">入力はによってかのように解析される &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 符号付き整数のため &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 符号なし整数のための &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 用 &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">入力はによってかのように解析され &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 符号付き整数のため &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 符号なし整数のための &lt;code&gt;v&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 浮動小数点のために &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">式への入力は、そのオペランドから構成されます。</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; の挿入操作は、&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;として動作します。</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">のインスタンス化は</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コールバックと共に格納される整数値は、通常、 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; から取得したインデックスです。</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">エンジンによって生成される積分型。これが符号なし積分型でない場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">概念の目的は、構文上の制限（HasPlus、Array）ではなく、意味論的なカテゴリ（Number、Range、RegularFunction）をモデル化することです。&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C ++コアガイドラインT.20&lt;/a&gt;によると、「意味のあるセマンティクスを指定する機能は、構文上の制約とは対照的に、真の概念の定義的な特性です。」</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">この関数の目的は&lt;a href=&quot;../../language/range-for&quot;&gt;、ループの範囲&lt;/a&gt;がvalarrayで機能できるようにすることであり、コンテナーのセマンティクスを提供することではありません。</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">この要件の目的は、C ++ライブラリの複素数型と&lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C言語の複素数型&lt;/a&gt;（およびその配列）の間のバイナリ互換性を維持することです。これらには、同じオブジェクト表現要件があります。</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">C++標準ライブラリのインタフェースは、以下のヘッダの集合で定義されています。</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">汎用パス名形式の内部パス名を指定された文字列型に変換したものです。</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">ネイティブパス名形式の内部パス名を、指定された文字列型に変換したものです。</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">参照されるビットの逆数。</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; の呼び出しは、次のいずれかのコンテキストでのみ表示される必要があります。</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">このコンテナの反復順序は安定している必要はありません（たとえば、 &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; を使用して2つの &lt;code&gt;std::unordered_multimap&lt;/code&gt; を比較することはできません）。ただし、キーが比較する要素のすべてのグループは</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">このコンテナの反復順序は安定している必要はありません（たとえば、 &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; を使用して2つの &lt;code&gt;std::unordered_multiset&lt;/code&gt; を比較することはできません）。ただし、キーが比較する要素のすべてのグループは</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">&lt;code&gt;first==last&lt;/code&gt; 場合、イテレータは &lt;code&gt;first&lt;/code&gt; に逆参照可能である必要はありません。空の範囲の消去は何もしません。</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">イテレータ &lt;code&gt;pos&lt;/code&gt; は有効で逆参照可能でなければなりません。したがって、 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; イテレータ（有効ですが、逆参照はできません）を &lt;code&gt;pos&lt;/code&gt; の値として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">イテレータ &lt;code&gt;pos&lt;/code&gt; は有効で逆参照可能でなければなりません。したがって、 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; イテレータ（有効ですが、逆参照はできません）を &lt;code&gt;pos&lt;/code&gt; の値として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">イテレータは &lt;code&gt;first + (last - n_first)&lt;/code&gt; と等しくなります。</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">イテレータ・ライブラリには、5 種類 (C++17 まで)のイテレータ、6 種類 (C++17 以降)のイテレータ、およびイテレータの特性、アダプタ、ユーティリティ関数の定義が用意されています。</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">メンバ関数の場合、この関数から得られたイテレータは無効化され &lt;code&gt;resize()&lt;/code&gt; アレイ上に呼び出され &lt;code&gt;v&lt;/code&gt; 又は場合の寿命 &lt;code&gt;v&lt;/code&gt; いずれか早い方、終了します。</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">メンバ関数の場合、この関数テンプレートから得られたイテレータは無効化され&lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt;アレイ上に呼び出され &lt;code&gt;v&lt;/code&gt; 又は場合の寿命 &lt;code&gt;v&lt;/code&gt; いずれか早い方、終了します。</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">すべての要素が &lt;code&gt;p&lt;/code&gt; を満たす場合 &lt;code&gt;[first, last)&lt;/code&gt; または &lt;code&gt;last&lt;/code&gt; 内の最初のパーティションの終わりを過ぎた反復子。</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">キー比較関数オブジェクト。</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">キー比較機能です。</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">キーワード&lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;dependent_name&quot;&gt;依存するテンプレート名&lt;/a&gt;を明確にするために、必要に応じて修飾識別子に含めることができます。</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;nullptr&lt;/code&gt; は、ポインタリテラルを示します。それはある&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;型の &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 。存在する&lt;a href=&quot;implicit_cast&quot;&gt;暗黙の変換&lt;/a&gt;から &lt;code&gt;nullptr&lt;/code&gt; 任意のポインタ型とメンバー型へのポインタのヌルポインタ値は。同様の変換が、任意のnullポインター定数にも存在します。これには、 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 型の値とマクロ &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">キーワード &lt;code&gt;requires&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">キーワード &lt;code&gt;requires&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">キーワード &lt;code&gt;template&lt;/code&gt; は、演算子 &lt;code&gt;::&lt;/code&gt; (スコープ解決）、 &lt;code&gt;-&amp;gt;&lt;/code&gt; （ポインターによるメンバーアクセス）、およびの後にのみ、この方法で使用できます &lt;code&gt;.&lt;/code&gt; （メンバーアクセス）、以下はすべて有効な例です。</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">キーワード &lt;code&gt;this&lt;/code&gt; は、メンバー関数が呼び出されているオブジェクトのアドレスを値とする&lt;a href=&quot;value_category&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;式&lt;/a&gt;です。次のコンテキストで表示されます。</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、テンプレートの外でも使用できます。</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、修飾された名前（例： &lt;code&gt;T::x&lt;/code&gt; ）の前にのみこの方法で使用できますが、名前は依存する必要はありません。</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">キーワード &lt;code&gt;typename&lt;/code&gt; は、テンプレートの宣言と定義、および従属名を使用できるコンテキストでのみ使用する必要があります。これには、明示的な特殊化宣言と明示的なインスタンス化宣言は含まれません。</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">このキーワードは未使用で予約されています。</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">キーワードのようなフォーム（ &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;not&lt;/code&gt; ）と記号のようなフォーム（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;||&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; ）互換的に使用することができます（参照&lt;a href=&quot;operator_alternative&quot;&gt;代替表現を&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">ラムダ式は、一意の無名非組合わない非集約クラス型のprvalue式であり、これは</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">プーリングメカニズムを使用して満たす必要がある最大の割り当てサイズ。このしきい値より大きい単一のブロックを &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; うとすると、上流のstd :: pmr :: memory_resourceから直接割り当てられます。場合 &lt;code&gt;largest_required_pool_block&lt;/code&gt; はゼロであるか、または限界が代わりに使用されていることを、実装定義の限界よりも大きいです。実装は、このフィールドで指定されたよりも大きいパススルーしきい値を選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">最大のブロックサイズと最大のチャンクサイズは、 &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 構造体をコンストラクタに渡すことで調整できます。</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_string_view&lt;/code&gt; で参照できるchar型オブジェクトの最大数。</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::nearbyint&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::rint&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、 &lt;code&gt;std::round&lt;/code&gt; がそれ自体でオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">表現可能な最大の浮動小数点値は、すべての標準浮動小数点形式の正確な整数であるため、この関数自体がオーバーフローすることはありません。ただし、整数変数に格納すると、結果が整数型（ &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; を含む）をオーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">の最後の文字</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">参照先ファイルシステムオブジェクトの最終更新時刻。</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">ラテン&lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;文字「ſ」（U + 017F）&lt;/a&gt;は、「S」（U + 0053）の代替小文字形式です。</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">変換指定 &lt;code&gt;#o&lt;/code&gt; によって生成された先行ゼロ（例えば、 &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; の組み合わせから生じる）は、埋め込み文字としてカウントされません。</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が指す文字シーケンスの長さ。</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すバイト文字列の文字のみを含む最初の最大セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すワイド文字列の文字のみを含む最初の最大セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すバイト文字列にない文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指す文字列に見つからない文字のみを含む最大の初期セグメントの長さ。</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">ヌル文字で終わる文字列の長さ。</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">nullで終了する文字列 &lt;code&gt;str&lt;/code&gt; の長さ。</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">nullで終了するワイド文字列 &lt;code&gt;str&lt;/code&gt; の長さ。</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">指定されたマッチまたはサブマッチの長さ。</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">変換された文字列の長さで、終端のヌル文字は含まれません。</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">変換された幅広文字列の長さで、終端のヌル文字は含まれません。</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; 以外のオープンモードのサポートレベルは、実装によって異なります。C ++ 11 は &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; およびこのコンストラクターで &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; のサポートを明示的に指定していますが、 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; 実装ごとに異なる効果があります。</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">ライブラリは、すべての符号付きおよび符号なし整数型のオーバーロードと、パラメーター &lt;code&gt;value&lt;/code&gt; 参照型としての &lt;code&gt;char&lt;/code&gt; を提供します。2-4）浮動小数点パーサー：デフォルト（ &quot;C&quot;）ロケールで &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; によって使用されるものと同一のパターンを期待しますが、</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;のライブラリバージョン</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;のライブラリバージョン&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt;および&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;のライブラリバージョン</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;参照&lt;/a&gt;の有効期間は、初期化が完了したときに始まり、スカラーオブジェクトのように終了します。</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">配列の要素を初期化するために使用されるデフォルトのコンストラクタのデフォルト引数を評価したときに作成される一時オブジェクトの寿命は、配列の次の要素が初期化を開始する前に終了します。</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">一時オブジェクトの存続期間は、const左辺値参照または右辺値参照（C ++ 11以降）にバインドすることで延長できます。詳細については、&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;参照の初期化&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">オブジェクトの存続期間は、オブジェクトを参照するすべての &lt;code&gt;atomic_ref&lt;/code&gt; の存続期間を超えている必要があります。任意ながら &lt;code&gt;atomic_ref&lt;/code&gt; のオブジェクトを参照するインスタンスが存在し、オブジェクトは、排他的にこれらを介してアクセスされなければならない &lt;code&gt;atomic_ref&lt;/code&gt; のインスタンス。 &lt;code&gt;atomic_ref&lt;/code&gt; オブジェクトによって参照されるオブジェクトのサブオブジェクトは、他の &lt;code&gt;atomic_ref&lt;/code&gt; オブジェクトによって同時に参照できません。</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">返されたポインタが指す配列の寿命は指定されていませんが、実際には、与えられた型のRTTIデータ構造体が存在する限り持続し、動的ライブラリ(アンロード可能)からロードされない限り、アプリケーションの寿命を持ちます。</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">コアーチン状態の寿命は、呼び出し元の寿命の中に厳密に入れ子にされており</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">基本クラスのリストは、&lt;a href=&quot;class&quot;&gt;クラス宣言構文の&lt;/a&gt; base-clauseで提供されています。base-clauseは、文字 &lt;code&gt;:&lt;/code&gt; とそれに続く1つ以上のbase-specifiersのコンマ区切りリストで構成されます。</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;の例外のリストは、パックの拡張である場合もあります。</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;名前付き関数&lt;/a&gt;と同様のパラメーターのリスト。ただし、&lt;a href=&quot;default_arguments&quot;&gt;デフォルトの引数&lt;/a&gt;は許可されていません（C ++ 14まで）。 &lt;code&gt;auto&lt;/code&gt; がパラメーターのタイプとして使用される場合、ラムダは</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">この関数を呼び出す前のロケール。式 &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; の結果を効果的に返します。</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">ロケール機能には、文字の分類や文字列の照合、数値、通貨、日付の書式設定や解析、メッセージの検索などの国際化のサポートが含まれています。ロケール設定は、ストリーム IO、正規表現ライブラリ、および C++標準ライブラリのその他のコンポーネントの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">操作前のストリームに関連付けられたロケールオブジェクト。</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">正規表現でローカライズされた動作に使用されるロケール。&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructibleである&lt;/a&gt;必要があります</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">論理演算子の式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x)&lt;/code&gt; を呼び出した結果の論理的な補数。</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x, y)&lt;/code&gt; を呼び出した結果の論理的な補数。</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">lognormal_distribution乱数分布は、対数正規分布に従って乱数x&amp;gt; 0を生成し&lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;ます&lt;/a&gt;：f（x; m、s）=</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">メンバー &lt;code&gt;get&lt;/code&gt; のルックアップは、通常どおりアクセシビリティを無視し、非タイプテンプレートパラメーターの正確なタイプも無視します。プライベート &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; メンバーの形式が正しくなくても、メンバーの解釈が使用されます。</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例外仕様での識別子 &lt;code&gt;swap&lt;/code&gt; のルックアップは、通常のルックアップルールで検出されたものに加えて、この関数テンプレートを検出し、例外仕様をC ++ 17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">マクロ &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; は、標準レイアウトクラスの先頭からの任意のメンバーのオフセットを決定するために使用できます。</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">マクロ &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; は、標準レイアウトクラスでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">マクロ &lt;code&gt;NAN&lt;/code&gt; は、静的な非数値（QNaN）値に評価される &lt;code&gt;float&lt;/code&gt; 型の定数式に展開されます。実装がQNaNをサポートしていない場合、このマクロ定数は定義されていません。</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">マクロ &lt;code&gt;NULL&lt;/code&gt; は、実装定義のnullポインタ定数である場合があります。</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">マクロ &lt;code&gt;offsetof&lt;/code&gt; は、型 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 整数定数式に展開されます。その値は、指定された型のオブジェクトの先頭から指定されたメンバーまでのオフセット（バイト単位）です。</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">マクロ定数 &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; は、他のすべての &lt;code&gt;FE_*&lt;/code&gt; のビット単位ORに展開され、常に定義されており、実装で浮動小数点例外がサポートされていない場合はゼロです。</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">マクロ定数 &lt;code&gt;FE_DFL_ENV&lt;/code&gt; は、 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 型の式に展開されます。これは、デフォルトの浮動小数点環境の完全なコピー、つまりプログラムの起動時に読み込まれる環境を指します。</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">マクロ定数 &lt;code&gt;math_errhandling&lt;/code&gt; は、 &lt;code&gt;MATH_ERRNO&lt;/code&gt; と等しい &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; 、MATH_ERREXCEPTと等しいか、ビット単位のOR（ &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ）と等しい &lt;code&gt;int&lt;/code&gt; 型の式に展開されます。</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">引数で呼び出されるマニピュレーター（例： &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; ）は、指定されていない型のオブジェクトを返す関数として実装されます。これらのマニピュレータは、要求された操作を実行する独自の &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; または &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">引数なしで呼び出されるマニピュレーター（例： &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; ）は、ストリームへの参照を唯一の引数として取る関数として実装されます。&lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;の特別なオーバーロードは、これらの関数へのポインターを受け入れます。これらの関数（または関数テンプレートのインスタンス化）は、標準ライブラリ内で&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;アドレス指定可能な&lt;/a&gt;唯一の関数です（C ++ 20以降）。</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">その方法 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; （それが全てで最適化されているかどうかだけでなく、）スペース効率化され、実装定義です。1つの潜在的な最適化には、各要素が &lt;code&gt;sizeof(bool)&lt;/code&gt; バイトではなく単一ビットを占有するようにベクトル要素を合体させることが含まれます。</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">OSコマンドラインで指定された引数が &lt;code&gt;argv&lt;/code&gt; によって参照されるマルチバイト文字配列に変換される方法には、実装定義の処理が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">現在のCロケールのLC_CTYPEファセットの &lt;code&gt;desc&lt;/code&gt; によって識別されたマッピングを使用して、 &lt;code&gt;ch&lt;/code&gt; のマッピングされた値。</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">不要な一時オブジェクトの作成を回避するために、一時オブジェクトの具体化は、通常、可能な限り遅延されます。「&lt;a href=&quot;copy_elision&quot;&gt;コピーの省略&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">円弧サインの主値の数学的定義は、asin z=-です。</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">逆双曲線余弦の主値の数学的定義は、acosh z = ln（z +&amp;radic;z+1&amp;radic;z-1）です。任意のzに対して、acosh（z）=</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">逆双曲線正弦の主値の数学的定義は、asinh z = ln（z +&amp;radic;1+ z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準ライブラリコンポーネントの数学関数は、この例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されている範囲エラーを報告します）。</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントの数学関数はこの例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたオーバーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::overflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">OuterAllocの最大アロケーションサイズ。</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">1つの &lt;code&gt;InternT&lt;/code&gt; 文字を生成するために &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; によって変換された場合に消費される可能性がある &lt;code&gt;ExternT&lt;/code&gt; 文字の最大数。</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">プールを補充するために上流の &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; から一度に割り当てられるブロックの最大数。 &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; の値がゼロであるか、実装で定義された制限より大きい場合、代わりにその制限が使用されます。実装は、このフィールドで指定された値よりも小さい値を使用することを選択する場合があり、プールごとに異なる値を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock_for&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、 &lt;code&gt;try_lock_until&lt;/code&gt; を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">所有権のレベルの最大数は指定されていません。この数を超えると、タイプ &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; の例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; がロックされる最大回数は指定されていませんが、その回数に達すると、&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;を呼び出すと &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; がスローされ、&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;を呼び出すとfalseが返され &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">要素の最大値。</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">生成される可能性のある最大値。</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">サポートされている最大の割り当てサイズ。</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">分布によって生成される可能性のある最大値。</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">この関数の結果の意味とタイプは実装定義です。POSIXシステムでは、これはタイプ &lt;code&gt;pthread_cond_t*&lt;/code&gt; 値である場合があります。Windowsシステムでは、これは &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; の場合があります。</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">フォーマット指定子の意味は</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">ビルドレベルを選択する仕組みは実装で定義されています。異なるビルドレベルで翻訳された翻訳ユニットの結合は条件付きでサポートされています。</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">メンバー &lt;code&gt;operator()&lt;/code&gt; は効果的に &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; と同じ値を返します。</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">メンバのアクセス演算子の式には、次のような形式があります。</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">メンバーへのポインタを介したメンバーアクセス演算子式は、形式を持っています。</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">メンバー &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; へのポインターを介したメンバーアクセス。この演算子をオーバーロードすることによる特定の欠点はありませんが、実際にはめったに使用されません。これは、&lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;スマートポインターインターフェイスの&lt;/a&gt;一部である可能性が示唆され、実際には&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenixの&lt;/a&gt;アクターによってその能力で使用されます。これはcpp.reactなどのEDSLでより一般的&lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">書込み用にオープンされたバッファ内のメンバ文字列は、効率化のために過剰に割り当てられることがある。その場合は、バッファ内の</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_regex&lt;/code&gt; のメンバー定数は、名前空間 &lt;code&gt;std::regex_constants&lt;/code&gt; 定義されている&lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt;定数の複製です。</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">メンバー関数 &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">このサーチャーを使用して検索を実行するために、 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; サーチャーオーバーロードによって呼び出されるメンバー関数。</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">このサーチャーを使用して検索を実行するために、 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; サーチャーオーバーロードによって呼び出されるメンバー関数。 &lt;code&gt;RandomIt2&lt;/code&gt; は&lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;の要件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">の型を定義するために、使用宣言によって派生クラスに導入されたメンバ関数は、派生クラスのメンバとみなされます。</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">メンバーの機能 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;std::initializer_list&lt;/code&gt; のオーバーロード &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">この特殊化のメンバ関数は、基礎となる型のハッシュがスローされる可能性があるため、その場合を除いてnoexexであることは保証されません。</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">この特殊化のメンバ関数は、ポインタが空想ポインタである可能性があり、そのハッシュがスローされる可能性があるため、noexceptが保証されていません。</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">この特殊化のメンバ関数は、noexceptであることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">メンバー関数は、 &lt;code&gt;matched&lt;/code&gt; メンバーが &lt;code&gt;true&lt;/code&gt; でない限り、定義されたデフォルト値を返します。</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">メンバーの解釈は、範囲タイプに &lt;code&gt;begin&lt;/code&gt; という名前のメンバーと &lt;code&gt;end&lt;/code&gt; という名前のメンバーがある場合に使用されます。これは、メンバーがタイプ、データメンバー、関数、または列挙子であるかどうか、およびそのアクセシビリティに関係なく行われます。したがって、クラス &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; ようなクラス。/ *クラスの残りの部分* /}; 名前空間スコープの開始/終了関数が存在する場合でも、範囲ベースのforループでは使用できません。</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">のメンバー名が表示されます。</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conjunction&lt;/code&gt; および &lt;code&gt;operator=&lt;/code&gt; 以外の基本クラスのメンバー名は非表示にならず、 &lt;code&gt;conjunction&lt;/code&gt; 明確に使用できます。</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disjunction&lt;/code&gt; と &lt;code&gt;operator=&lt;/code&gt; 以外の基本クラスのメンバー名は非表示にならず、 &lt;code&gt;disjunction&lt;/code&gt; で明確に使用できます。</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">メンバーoperator（）は、それが &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 式がnoexceptである場合はnoexceptです（つまり、基になる呼び出し演算子の例外指定を保持します）。</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">メンバーの仕様、または</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">メンバーテンプレートクラスの再 &lt;code&gt;rebind&lt;/code&gt; は、別のタイプのアロケーターを取得する方法を提供します。例えば、</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">メンバータイプ &lt;code&gt;X::pointer&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">メンバータイプ &lt;code&gt;is_transparent&lt;/code&gt; は、この関数オブジェクトが</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">メンバータイプ &lt;code&gt;X::iterator&lt;/code&gt; および &lt;code&gt;X::const_iterator&lt;/code&gt; は&lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIteratorsです&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">メンバー型 &lt;code&gt;X::pointer&lt;/code&gt; 、 &lt;code&gt;X::const_pointer&lt;/code&gt; 、 &lt;code&gt;X::void_pointer&lt;/code&gt; と &lt;code&gt;X::const_void_pointer&lt;/code&gt; 、すべての&lt;a href=&quot;allocator&quot;&gt;アロケータの&lt;/a&gt;タイプ &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">メンバー型 &lt;code&gt;iterator&lt;/code&gt; および &lt;code&gt;const_iterator&lt;/code&gt; は、同じ型のエイリアスである場合があります。以来 &lt;code&gt;iterator&lt;/code&gt; に変換され &lt;code&gt;const_iterator&lt;/code&gt; の、 &lt;code&gt;const_iterator&lt;/code&gt; のは、一つの定義ルールの違反を避けるために、関数の引数リストで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">メンバーには以下のような意味があります。</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">C++プログラムで利用可能なメモリは、1つまたは複数の連続した</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">読み取り、変更、書き込み、および読み込み操作のメモリモデルは、それぞれ &lt;code&gt;succ&lt;/code&gt; と &lt;code&gt;fail&lt;/code&gt; です。（1-2）バージョンは、デフォルトで &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">読み取り、変更、書き込み、および読み込み操作のメモリモデルは、それぞれ &lt;code&gt;success&lt;/code&gt; と &lt;code&gt;failure&lt;/code&gt; です。（2）及び（4）バージョンの &lt;code&gt;order&lt;/code&gt; 除いて、両方のリード・モディファイ・ライトと負荷操作のために使用されること &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 場合、ロード操作のために使用される &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">このポリモーフィックアロケータが使用するメモリリソースポインタ。</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">メモリ書き込み変換指定子 &lt;code&gt;%n&lt;/code&gt; は、フォーマット文字列がユーザー入力に依存するセキュリティエクスプロイトの一般的なターゲットであり、境界チェック &lt;code&gt;printf_s&lt;/code&gt; ファミリーの関数ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">カタログからのメッセージ、または何も見つからなかった場合は &lt;code&gt;dfault&lt;/code&gt; のコピー。</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">要素の最小値。</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">生成される可能性のある最小値。</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">分布によって発生する可能性のある最小値。</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EC&lt;/code&gt; は、ロケールの代替世紀の表記を書き込みます。</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EX&lt;/code&gt; は、ロケールの代替時間表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EX&lt;/code&gt; は、ロケールの代替時間表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EY&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ec&lt;/code&gt; は、ロケールの代替の日付と時刻の表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ec&lt;/code&gt; は、ロケールの代替の日付と時刻の表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ex&lt;/code&gt; は、ロケールの代替日付表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ex&lt;/code&gt; は、ロケールの代替日付表現を生成します。</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OH&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OH&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OI&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OM&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OM&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OS&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OS&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OU&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OV&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%OW&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Od&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Oe&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Om&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Om&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ou&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ou&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ow&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ow&lt;/code&gt; は、ロケールの代替表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%EC&lt;/code&gt; および &lt;code&gt;%OC&lt;/code&gt; は、ロケールの世紀の代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ed&lt;/code&gt; および &lt;code&gt;%Ee&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ey&lt;/code&gt; および &lt;code&gt;%Oy&lt;/code&gt; は、ロケールの代替表現を解釈します。</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ez&lt;/code&gt; と &lt;code&gt;%Oz&lt;/code&gt; は、時間と分の間に &lt;code&gt;:&lt;/code&gt; を挿入します（例 &lt;code&gt;-04:30&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">変更されたコマンド &lt;code&gt;%Ez&lt;/code&gt; および &lt;code&gt;%Oz&lt;/code&gt; は、形式 &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; 解析します（つまり、時間と分の間で &lt;code&gt;:&lt;/code&gt; を必要とし、時間の先頭のゼロをオプションにします）。</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">通貨形式は、 &lt;code&gt;std::money_base::part&lt;/code&gt; 変換可能な4つの &lt;code&gt;char&lt;/code&gt; の配列です。そのシーケンスでは、 &lt;code&gt;symbol&lt;/code&gt; 、 &lt;code&gt;sign&lt;/code&gt; 、および &lt;code&gt;value&lt;/code&gt; はそれぞれ1回だけ出現し、残りの位置には &lt;code&gt;space&lt;/code&gt; または &lt;code&gt;none&lt;/code&gt; いずれかが出現します。存在する場合、値 &lt;code&gt;none&lt;/code&gt; は最初ではありません。存在する場合、値 &lt;code&gt;space&lt;/code&gt; は最初でも最後でもありません。</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に保存される月の値。</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">ほとんどの派生型 &lt;code&gt;other&lt;/code&gt; ほとんどの派生型と一致しないことがあり &lt;code&gt;*this&lt;/code&gt; 。したがって、派生クラスの実装は通常、 &lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の最も派生した型が &lt;code&gt;dynamic_cast&lt;/code&gt; を使用して一致するかどうかをチェックし、キャストが失敗した場合はすぐに &lt;code&gt;false&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">&lt;code&gt;std::result_of&lt;/code&gt; 背後にある動機は、特にその結果の型が引数のセットごとに異なる場合に、&lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;を呼び出した結果を判別することです。</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; の移動割り当て演算子は、次のすべてが当てはまる場合は簡単です。</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">割り当ての移動演算子は、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;によって選択されるたびに呼び出されます。たとえば、オブジェクトが割り当て式の左側に表示され、右側が同じまたは暗黙的に変換可能な型の右辺値である場合などです。</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">クラス &lt;code&gt;T&lt;/code&gt; のmoveコンストラクターは、次のすべてが当てはまる場合は簡単です。</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">オブジェクトがされたときに、典型的に呼ばれるムーブコンストラクタ&lt;a href=&quot;initialization&quot;&gt;初期化&lt;/a&gt;（によって&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;または&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期化&lt;/a&gt;から）&lt;a href=&quot;value_category#rvalue&quot;&gt;右辺値&lt;/a&gt;を含む同じタイプの（C ++ 17以降）はxValue（C ++ 17まで）（はxValue又はprvalue）。</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">この関数が使用するマルチバイトエンコーディングは、現在アクティブな C ロケールによって指定されます。</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">マルチバイトのヌル文字を変換して保存しました。</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">マルチバイトのnull文字が変換されて保存されました。 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に設定され、 &lt;code&gt;*ps&lt;/code&gt; は初期シフト状態を表します。</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">このミューテックスは、共有モードで実行中の現在のスレッドによってロックされている必要があり、そうでなければ動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">ミューテックスは、現在の実行スレッドでロックされていなければなりません。</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">nの分布パラメータです。</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">名前 &lt;code&gt;array::elems&lt;/code&gt; は説明のためだけのものであり、インターフェースの一部ではありません。</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">名前 &lt;code&gt;posix&lt;/code&gt; は、将来のトップレベルの名前空間のために予約されています。プログラムがその名前空間で何かを宣言または定義した場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">名前 &lt;code&gt;proxy&lt;/code&gt; は、説明のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">名前の &lt;code&gt;ranges::swap&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">非静的データ・メンバまたは非静的メンバ関数の名前は、以下の3つの状況でのみ出現します。</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;スコープ&lt;/a&gt;列挙で導入された列挙子の名前は、宣言の時点で始まり、列挙指定子の終わりで終わります（対照的に、スコープ指定されていない列挙子は、列挙指定子の終わりの後にスコープ内にあります）。</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">スコープされていない列挙の名前は省略することができます。</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">すべての&lt;a href=&quot;class&quot;&gt;クラス&lt;/a&gt;メンバーの名前（静的、非静的、関数、型など）には、関連付けられた「メンバーアクセス」があります。メンバーの名前がプログラムのどこかで使用されると、そのアクセスがチェックされ、それがアクセス規則を満たさない場合、プログラムはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">関連する &lt;code&gt;type_info&lt;/code&gt; オブジェクトの名前。</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">ロケールの名前、または名前がない場合は &quot;*&quot;。</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">ネストされたクラスの名前は、包含クラスのスコープ内に存在し、ネストされたクラスのメンバー関数からの名前ルックアップは、ネストされたクラスのスコープを調べた後、包含クラスのスコープを訪問します。ネストされたクラスは、その包含クラスのメンバーと同様に、包含クラスがアクセスできるすべての名前（private、protectedなど）にアクセスできますが、それ以外は独立しており、包含クラスの&lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;ポインターへの特別なアクセス権はありません。</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">パラメータ名は任意です。</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">必要な言語連携の名前</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">この関数の名前は、2つの形式のうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">この関数の名前は &quot;stream:how many characters? &quot;の略なので、&quot;show many C &quot;ではなく &quot;S how many C &quot;と発音します。</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">このタイムゾーンの名前（例： &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">名前は「文字列ポインタブレーク」の略で、区切り文字(「ブレーク」)の最初の文字へのポインタを返すことから、「文字列ポインタブレーク」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">名前 &lt;code&gt;argc&lt;/code&gt; と &lt;code&gt;argv&lt;/code&gt; は任意であり、パラメーターのタイプの表現も同様です &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; も同様に有効です。</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">デフォルトの引数で使用される名前は検索され、&lt;a href=&quot;access&quot;&gt;アクセシビリティが&lt;/a&gt;チェックされ、宣言の時点でバインドされますが、関数呼び出しの時点で実行されます。</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">名前空間&lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt;は、一般的な演算子 &lt;code&gt;!=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; を提供します</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">名前空間 &lt;code&gt;std&lt;/code&gt; は、標準C ++ライブラリの名前を配置するために使用されます。&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;名前の&lt;/a&gt;追加に関する規則については、名前空間stdの拡張を参照してください。</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">名前空間エイリアス &lt;code&gt;std::view&lt;/code&gt; は、 &lt;code&gt;std::ranges::view&lt;/code&gt; 省略形として提供されています。</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">名前空間本体は、&lt;a href=&quot;scope&quot;&gt;名前の&lt;/a&gt;&lt;a href=&quot;lookup&quot;&gt;検索に&lt;/a&gt;影響する名前空間スコープを定義します。</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">この条件変数のネイティブハンドル。</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">パス名のネイティブ文字列表現で、ネイティブ構文、ネイティブ文字型、ネイティブ文字エンコーディングを使用します。この文字列は、OS API での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">極座標成分（r、&amp;theta;）を持つ複素数zの自然対数は、ln r + i（&amp;theta;+2n&amp;pi;）に等しく、主値はln r +i&amp;theta;です。</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;../fenv/fe_round&quot;&gt;現在の丸めモード&lt;/a&gt;に従って、 &lt;code&gt;arg&lt;/code&gt; に最も近い整数値が返されます。</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">新しいエイリアス alias_name は、ns_name にアクセスする代替方法を提供します。</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">新しい式は、まずクラススコープで適切な割り当て関数の名前を検索し、次にグローバルスコープで検索します。&lt;a href=&quot;../../language/lookup&quot;&gt;名前ルックアップルールに従って&lt;/a&gt;、クラススコープで宣言された割り当て関数は、このクラスのオブジェクトを割り当てようとする新しい式のすべてのグローバル割り当て関数を非表示にすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">新しい文字列は、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; の新しい値は指定されていません。</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">新しい名もなきロケ地。</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">new-expressionは、適切な&lt;a href=&quot;../memory/new/operator_new&quot;&gt;割り当て関数を&lt;/a&gt;呼び出してストレージを割り当てます。場合は &lt;code&gt;type&lt;/code&gt; 非配列型で、関数の名前は &lt;code&gt;operator new&lt;/code&gt; 。 &lt;code&gt;type&lt;/code&gt; が配列型の場合、関数の名前は &lt;code&gt;operator new[]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">改行文字 &lt;code&gt;\n&lt;/code&gt; は、&lt;a href=&quot;../io/c&quot;&gt;テキストモードI / Oで&lt;/a&gt;使用する場合に特別な意味を持ちます。OS固有の改行表現に変換されます。通常、バイトまたはバイトシーケンスです。一部のシステムでは、代わりに長さフィールドで行をマークしています。</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の新しく作成されたオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">get領域の次の文字。成功すると &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; 、失敗すると &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">次の文字は、 &lt;code&gt;char_type ct = *in;&lt;/code&gt; ように &lt;code&gt;in&lt;/code&gt; から抽出されます。</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">保存される次のマルチバイト文字は &lt;code&gt;len&lt;/code&gt; を超えます。</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">ストリームの次のワイド文字、またはエラーが発生したかファイルの終わりに達した場合は &lt;code&gt;WEOF&lt;/code&gt; 。エンコードエラーが発生した場合、 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;EILSEQ&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">次に格納されるワイド文字は &lt;code&gt;len&lt;/code&gt; を超えます。</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">noexcept-specificationは関数タイプの一部であり、&lt;a href=&quot;function&quot;&gt;関数宣言子の&lt;/a&gt;一部として表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">noexcept-specificationは関数型の一部ではなく（&lt;a href=&quot;except_spec&quot;&gt;動的例外仕様&lt;/a&gt;と同様）、型の関数、変数、非静的データメンバーを&lt;a href=&quot;function&quot;&gt;宣言する&lt;/a&gt;ときに、&lt;a href=&quot;lambda&quot;&gt;ラムダ宣言子&lt;/a&gt;または最上位関数宣言子の一部としてのみ表示できます関数、関数へのポインター、関数への参照、またはメンバー関数へのポインター。また、これらの宣言の1つでパラメーターまたは戻り値の型を宣言し、その宣言がたまたま関数へのポインターまたは参照である場合。&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;または&lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 常に &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">非変換の特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">変換しない特殊化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; で使用できるタイプ &lt;code&gt;catalog&lt;/code&gt; 負でない値。カタログを開けなかった場合は、負の値を返します。</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">投げないオーバーロードは、エラーに対して特別なアクションを持ちません。</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードは、エラーが発生すると &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードはエラー時に &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">スローしないオーバーロードは、エラー時に &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">投げないオーバーロードは、エラー時に空のパスを返します。</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">スローしないオーバーロードは、エラー時にすべてのメンバーを &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">この関数によって計算されるノルムは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;フィールドノルム&lt;/a&gt;または&lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;絶対二乗&lt;/a&gt;とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">式 &lt;code&gt;(E)&lt;/code&gt; の正規形は、 &lt;code&gt;E&lt;/code&gt; の正規形です。</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">表現の正規形 &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; の名前コンセプトの制約表現の正規形である &lt;code&gt;C&lt;/code&gt; 、A1、A2を代入した後、...、ANのための &lt;code&gt;C&lt;/code&gt; &quot; s Cの各アトミック制約のパラメーターマッピング内のそれぞれのテンプレートパラメーター。パラメーターマッピングへのそのような置換の結果、無効な型または式になる場合、プログラムの形式が正しくないため、診断は必要ありません。</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; の正規形は、 &lt;code&gt;E1&lt;/code&gt; と &lt;code&gt;E2&lt;/code&gt; の正規形の結合です。</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">式の正規形 &lt;code&gt;E1 || E2&lt;/code&gt; は、 &lt;code&gt;E1&lt;/code&gt; と &lt;code&gt;E2&lt;/code&gt; の正規形の分離です。</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">他の式 &lt;code&gt;E&lt;/code&gt; の正規形は、式が &lt;code&gt;E&lt;/code&gt; であり、パラメーターマッピングがIDマッピングであるアトミック制約です。これには、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; または &lt;code&gt;||&lt;/code&gt; を折りたたむものも含め、すべての&lt;a href=&quot;fold&quot;&gt;折りたたみ式が&lt;/a&gt;含まれます。演算子。</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">通知スレッドは、待機スレッドが保持しているものと同じミューテックスにロックを保持する必要はありません。</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">実際、そうすると、通知されたスレッドは通知されたスレッドがロックを解放するのを待って、すぐにまたブロックしてしまうので、悲観的になってしまいます。しかし、いくつかの実装(特に pthreads の多くの実装)では、この状況を認識しており、待機中のスレッドを起動させずに、条件変数のキューから直接通知呼び出し内のミューテックスのキューに転送することで、この「急いで待つ」シナリオを回避しています。</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">null文字（ &lt;code&gt;'\0'&lt;/code&gt; 、 &lt;code&gt;L'\0'&lt;/code&gt; 、 &lt;code&gt;char16_t()&lt;/code&gt; など）は常に文字列リテラルに追加されます。したがって、文字列リテラル &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; は文字 &lt;code&gt;'H'&lt;/code&gt; を保持する &lt;code&gt;const char[6]&lt;/code&gt; 、 &lt;code&gt;'e'&lt;/code&gt; 、 &lt;code&gt;'l'&lt;/code&gt; 、 &lt;code&gt;'l'&lt;/code&gt; 、 &lt;code&gt;'o'&lt;/code&gt; 、および &lt;code&gt;'\0'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">ヌル文字を変換して保存しました。</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">ヌル文字が変換されて保存されました。 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に設定され、 &lt;code&gt;*ps&lt;/code&gt; は初期シフト状態を表します。</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">nullディレクティブ（ &lt;code&gt;#&lt;/code&gt; の後に改行が続く）は許可され、効果はありません。</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">文字列内の &lt;code&gt;CharT&lt;/code&gt; 要素の数。</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">ビュー内の &lt;code&gt;CharT&lt;/code&gt; 要素の数。</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">すべての &lt;code&gt;from_end-from&lt;/code&gt; 文字が消費されるか、 &lt;code&gt;max&lt;/code&gt; &lt;code&gt;internT&lt;/code&gt; 文字が生成されるか、変換エラーが発生するまで、 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; によって変換された場合に消費される &lt;code&gt;externT&lt;/code&gt; 文字の数。</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">呼び出しの瞬間に管理対象オブジェクトの所有権を共有する &lt;code&gt;shared_ptr&lt;/code&gt; インスタンスの数。</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">ビットフィールドのビット数は、それが保持できる値の範囲の制限を設定します。</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">コンテナ内のバケツの数です。</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">（間のバイト数 &lt;code&gt;1&lt;/code&gt; 及び &lt;code&gt;n&lt;/code&gt; は完全に有効なマルチバイト文字こと）。</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">配列オブジェクトに格納されているバイト数（シフトシーケンスを含む）。これは、 &lt;code&gt;c8&lt;/code&gt; がコードポイントのUTF-8表現の最後のコード単位ではない場合、ゼロになることがあります。</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">成功した場合の終了 &lt;code&gt;'\0'&lt;/code&gt; を含まない、 &lt;code&gt;str&lt;/code&gt; が指す文字配列に書き込まれたバイト数。場合は &lt;code&gt;count&lt;/code&gt; 文字列全体が格納される前に到達した、 &lt;code&gt;​0​&lt;/code&gt; 返され、その内容は不定です。</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">実際に抽出した文字数。</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">非ブロック読み取りに使用できる文字数（get領域のサイズまたは関連する文字シーケンスから読み取る準備ができている文字数）、または &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; までの関連シーケンスで使用できる文字がない場合は &lt;code&gt;-1&lt;/code&gt; ）わかる。</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">ファイルからの読み取りに使用できる文字数。ファイルの終わりに達した場合は &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">直近の変換操作で消費された文字数。</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">最後の未整形入力操作で抽出された文字数。</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">put領域の文字数、何も出力されなかった場合は0。</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">正常に読み取られた文字数。 &lt;code&gt;count&lt;/code&gt; 未満の場合、入力シーケンスは最後に達しています。</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">正常に書き込まれた文字数です。</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">関連する文字シーケンスで確実に使用可能な文字の数、または &lt;code&gt;showmanyc&lt;/code&gt; がブロックなしで使用可能な文字がないと判断できる場合は &lt;code&gt;-1&lt;/code&gt; 。 &lt;code&gt;showmanyc&lt;/code&gt; が &lt;code&gt;-1&lt;/code&gt; を返す場合、 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; は必ず &lt;code&gt;Traits::eof&lt;/code&gt; またはthrowを返します。</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">putエリアに書き込まれた文字数。</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">実行される比較の数は、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; 距離の対数です（最大2 * log</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">実行される比較の数は、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; 距離の対数です（最大で対数</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">間の桁数 &lt;code&gt;thousand-sep&lt;/code&gt; S（の最大サイズ &lt;code&gt;digits&lt;/code&gt; ）の結果によって指定される &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">小数点以下に表示する桁数。一般的な米国のロケールでは、これは値 &lt;code&gt;2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ints&lt;/code&gt; の要素数。</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">バケット &lt;code&gt;n&lt;/code&gt; の要素の数。</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">コンテナ内の要素数。</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">スパン内の要素数。</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">削除された要素の数。</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; のハードリンクの数。</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">参照先ファイルシステムオブジェクトのハードリンクの数。</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; から &lt;code&gt;last&lt;/code&gt; までの増分に必要な数。ランダムアクセス反復子が使用され、 &lt;code&gt;first&lt;/code&gt; から &lt;code&gt;last&lt;/code&gt; 到達できる場合（C ++ 11以降）、値は負の値になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">正規表現内のマークされた副表現の数。</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">サブマッチの数。</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">この期間の目盛りの数。</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">&lt;code&gt;std::numpunct&lt;/code&gt; がサポートする数値の形式は以下のとおりです。ここで、 &lt;code&gt;digit&lt;/code&gt; は &lt;code&gt;fmtflags&lt;/code&gt; 引数値で指定された基数セットを表し、 &lt;code&gt;thousands-sep&lt;/code&gt; と &lt;code&gt;decimal-point&lt;/code&gt; はそれぞれ、 &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; 関数とdecimal_point（）関数の結果です。整数値の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;処理のステージ2で、次の文字の読み取り中にストリームの終わりが検出された場合、&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;の数値入力オーバーロード。解析状態に応じて、 &lt;code&gt;failbit&lt;/code&gt; は同時に設定される場合と設定されない場合があります &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; たとえば、int n; istringstream buf（ &quot;1&quot;）; buf &amp;gt;&amp;gt; n; &lt;code&gt;eofbit&lt;/code&gt; ではなく &lt;code&gt;failbit&lt;/code&gt; 設定します。整数 &lt;code&gt;1&lt;/code&gt; は正常に解析され、 &lt;code&gt;n&lt;/code&gt; に格納されました。一方、 &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; &lt;code&gt;eofbit&lt;/code&gt; と &lt;code&gt;failbit&lt;/code&gt; の両方を設定します：ブール値 &lt;code&gt;true&lt;/code&gt; の解析を完了するのに十分な文字がありませんでした。</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; が実際に現在組み込まれているロケールで数値の &lt;code&gt;radix&lt;/code&gt; として有効な数字を表す場合の数値、またはエラーの場合は &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">数値、ポインタ、およびブールの入力過負荷&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;（技術的には、オーバーロードの&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;、彼らが呼ぶ）、入力が有効な値として、あるいは解析された値がに収まらない場合は解析できない場合宛先タイプ。</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">オブジェクトの</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">オブジェクト &lt;code&gt;u&lt;/code&gt; は&lt;a href=&quot;../language/default_initialization&quot;&gt;デフォルトで初期化されます&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">オブジェクト &lt;code&gt;u&lt;/code&gt; は&lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;または&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">新規式で作成されたオブジェクトは、以下のルールに従って初期化されます。</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">GLVALUEで表されるオブジェクトは、以下の場合にはアクセスされません。</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">オブジェクトはデフォルトで初期化されています。</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">オブジェクトは、&lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt;または構築中に &lt;code&gt;shared_ptr&lt;/code&gt; に提供されるカスタム削除機能を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">オブジェクトは、 &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; を呼び出すことにより、ユーザーが提供する可能性のある削除機能を使用して破棄されます。デフォルトの &lt;code&gt;delete&lt;/code&gt; 機能は、オブジェクトを破棄してメモリの割り当てを解除する削除演算子を使用します。</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">オブジェクトは、以下のいずれかが発生した場合に、関連する削除器を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">オブジェクトは、 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 型の値または &lt;code&gt;optional&lt;/code&gt; オブジェクトで初期化/割り当てられます。</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">オブジェクトがで初期化さ/タイプの値から割り当てられた &lt;code&gt;T&lt;/code&gt; または別の &lt;code&gt;optional&lt;/code&gt; その</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">このロケールで使用される&lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt;を記述するstd :: money_base :: formatタイプのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">グループを保持するタイプ &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::moneypunct&lt;/code&gt; の標準的な特殊化は、グループ化がないことを示す空の文字列を返します。典型的なグループ（たとえば、 &lt;code&gt;en_US&lt;/code&gt; ロケール）は &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">グループを保持するタイプ &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::numpunct&lt;/code&gt; の標準的な特殊化は、グループ化がないことを示す空の文字列を返します。典型的なグループ（たとえば、 &lt;code&gt;en_US&lt;/code&gt; ロケール）は &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">小数点文字を保持するタイプ &lt;code&gt;CharT&lt;/code&gt; のオブジェクト。</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">桁区切り記号として使用するタイプ &lt;code&gt;char_type&lt;/code&gt; のオブジェクト。一般的な米国のロケールでは、これは &lt;code&gt;','&lt;/code&gt; または &lt;code&gt;L','&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">桁区切り記号として使用するタイプ &lt;code&gt;char_type&lt;/code&gt; のオブジェクト。 &lt;code&gt;std::numpunct&lt;/code&gt; の標準的な特殊化は &lt;code&gt;','&lt;/code&gt; および &lt;code&gt;L','&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">通貨記号またはコードを保持する &lt;code&gt;string_type&lt;/code&gt; 型のオブジェクト。</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">このような宣言によって宣言されたオブジェクトまたは型の&lt;a href=&quot;objects#Alignment&quot;&gt;整列要件&lt;/a&gt;は、型の自然な整列を弱める場合を除き、宣言で使用されるすべての &lt;code&gt;alignas&lt;/code&gt; 指定子の最も厳密な（最大の）非ゼロ式と等しくなります。</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">オブジェクトは、 &lt;code&gt;lock&lt;/code&gt; 、 &lt;code&gt;try_lock&lt;/code&gt; 、および &lt;code&gt;unlock&lt;/code&gt; への不特定の一連の呼び出しによってロックされます。 &lt;code&gt;lock&lt;/code&gt; または &lt;code&gt;unlock&lt;/code&gt; 呼び出しで例外が発生した場合は、再スローする前に、ロックされたオブジェクトに対して &lt;code&gt;unlock&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">new-expressionsによって作成されたオブジェクト（動的ストレージ期間を持つオブジェクト）は、new-expressionによって返されたポインターが一致&lt;a href=&quot;delete&quot;&gt;するdelete-expressionで&lt;/a&gt;使用されるまで存続します。ポインタの元の値が失われると、オブジェクトに到達できなくなり、割り当てを解除できなくなります。</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">オブジェクトはオーバーラップする可能性があります。コピーは、文字が一時的な文字配列にコピーされた後に、配列から &lt;code&gt;dest&lt;/code&gt; に文字がコピーされたかのように行われます。</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">成功した場合は取得した文字、失敗した場合は &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">取得したワイド文字、またはエラーが発生したかファイルの終わりに達した場合は &lt;code&gt;WEOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">機能テストの推奨に関する公式文書</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">標準レイアウトタイプの最初のメンバーのオフセットは常にゼロです（&lt;a href=&quot;../language/ebo&quot;&gt;空ベースの最適化&lt;/a&gt;は必須です）。</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; の古い値。</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 格納される唯一のデータは、タイプ &lt;code&gt;Rep&lt;/code&gt; のティックカウントです。 &lt;code&gt;Rep&lt;/code&gt; が浮動小数点の場合、 &lt;code&gt;duration&lt;/code&gt; はティックの分数を表すことができます。 &lt;code&gt;Period&lt;/code&gt; は期間のタイプの一部として含まれ、異なる期間間で変換する場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一の違い &lt;code&gt;std::nearbyint&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; されていること &lt;code&gt;std::nearbyint&lt;/code&gt; 上げることはありません &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一の違い &lt;code&gt;std::rint&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; されていること &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; 上げることはありません &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">唯一の例外は</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">decl-specifier-seqで2回出現できる唯一の指定子は &lt;code&gt;long&lt;/code&gt; （2回出現する可能性があります）です。 &lt;code&gt;const static const&lt;/code&gt; や &lt;code&gt;virtual inline virtual&lt;/code&gt; などの他のすべての繰り返しはエラーです。</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">コンストラクター宣言のdecl-specifier-seqで許可される指定子は、&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;、&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;、 &lt;code&gt;explicit&lt;/code&gt; 、および &lt;code&gt;constexpr&lt;/code&gt; のみです（特に、戻り値の型は許可されていません）。&lt;a href=&quot;member_functions&quot;&gt;cv-およびref-qualifiers&lt;/a&gt;も使用できないことに注意してください。構築中のオブジェクトのconstとvolatileのセマンティクスは、最も派生したコンストラクタが完了するまで機能しません。</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">唯一の標準 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; メンバー定数 &lt;code&gt;is_always_lock_free&lt;/code&gt; も、この特殊化によって提供されます。</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外をスローする唯一の標準ライブラリコンポーネントは &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外をスローする標準ライブラリコンポーネントは &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">個人的にコピー可能な型は、スカラ型、個人的にコピー可能なクラス、およびそのような型クラスの配列(const修飾されている可能性がありますが、volatile修飾されていません)のみです。</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">唯一の有効な使用 &lt;code&gt;operator*&lt;/code&gt; イテレータは割り当ての左側にある出力には： &lt;code&gt;operator*&lt;/code&gt; メンバー定義プロキシオブジェクトを返すことができる &lt;code&gt;operator=&lt;/code&gt; （テンプレートであってもよいです）。</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">アロケータを置き換えるには、コピー割り当て、移動割り当て、スワップしかありません。</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">組み込みの後置インクリメントまたはデクリメント演算子のオペランドexprは、非ブール算術型の変更可能な（非const）&lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;または完全な&lt;a href=&quot;type-id&quot;&gt;オブジェクトタイプ&lt;/a&gt;へのポインターでなければなりません。結果は、オペランドの元の値の&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;コピーです。副作用として、非ブールオペランドの場合、式 &lt;code&gt;x++&lt;/code&gt; は &lt;code&gt;x += 1&lt;/code&gt; 評価することによってそのオペランドの値を変更し、式 &lt;code&gt;x--&lt;/code&gt; は &lt;code&gt;x -= 1&lt;/code&gt; 評価することによってそのオペランドの値を変更します。&lt;a href=&quot;operator_arithmetic&quot;&gt;算術演算子に&lt;/a&gt;定義されているすべての算術変換規則とポインター算術規則 オペランドに適用される暗黙の変換（存在する場合）および式の戻り値の型を適用および決定します。</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">組み込みの前置インクリメントまたはデクリメント演算子のオペランドexprは、非ブール算術型の変更可能な（非const）&lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;または完全な&lt;a href=&quot;type-id&quot;&gt;オブジェクトタイプ&lt;/a&gt;へのポインターでなければなりません。非ブールオペランドの場合、式 &lt;code&gt;++x&lt;/code&gt; は &lt;code&gt;x += 1&lt;/code&gt; とまったく同じであり、式 &lt;code&gt;--x&lt;/code&gt; は &lt;code&gt;x -= 1&lt;/code&gt; とまったく同じです。つまり、プレフィックスのインクリメントまたはデクリメントは、変更されたオペランド。&lt;a href=&quot;operator_arithmetic&quot;&gt;算術演算子に&lt;/a&gt;定義されているすべての算術変換規則とポインター算術規則が適用され、オペランドに適用される暗黙の変換（存在する場合）と式の戻り値の型が決定されます。</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; のオペランドをCスタイルの型キャストにすることはできません。式 &lt;code&gt;sizeof (int) * p&lt;/code&gt; は &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; として明確に解釈されますが、 &lt;code&gt;sizeof((int)*p)&lt;/code&gt; は解釈されません。</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">組み込みのindirection演算子のオペランドは、オブジェクトへのポインタまたは関数へのポインタでなければならず、結果はexprが指すポインタまたは関数を参照するlvalueとなります。</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">任意の演算子のオペランドは、他の式または1次式にすることができます（たとえば、 &lt;code&gt;1+2*3&lt;/code&gt; では、operator +のオペランドは部分式 &lt;code&gt;2*3&lt;/code&gt; および &lt;code&gt;1&lt;/code&gt; 次式1です）。</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">演算子&lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt;（C ++ 11以降）のオペランドは、評価されない式です（これらが多相型glvalueであり、 &lt;code&gt;typeid&lt;/code&gt; のオペランドでない限り）。これらの演算子はコンパイル時のプロパティのみをクエリするためですオペランドの。したがって、 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; コンソール出力を実行しません。</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">操作は、 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;set_exception&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">操作は、 &lt;code&gt;set_value&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; がpromiseオブジェクトの更新中にpromiseオブジェクトに関連付けられた単一のミューテックスを取得するかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">以下のように操作を行います。</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">オペレーター &lt;code&gt;operator!&lt;/code&gt; 通常、ブールコンテキストで使用するためのユーザー定義クラスによってオーバーロードされます。このようなクラスは、ユーザー定義の変換関数の &lt;code&gt;explicit operator bool()&lt;/code&gt; （標準ライブラリの例については &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; を参照）と &lt;code&gt;operator!&lt;/code&gt; 予期される動作も提供します！ &lt;code&gt;operator bool&lt;/code&gt; 反対の値を返すことです。</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">演算子 &lt;code&gt;::&lt;/code&gt; （スコープ解決）、 &lt;code&gt;.&lt;/code&gt; （メンバーアクセス）、 &lt;code&gt;.*&lt;/code&gt; （メンバーへのポインターを介したメンバーアクセス） &lt;code&gt;?:&lt;/code&gt; 3項条件付き）はオーバーロードできません。</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非ローカル変数の破棄の順序は &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 説明されています。</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">等しい要素の順序が保持されるとは限りません。範囲 &lt;code&gt;[middle, last)&lt;/code&gt; の残りの要素の順序は指定されていません。</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">リスト内のメンバーの初期化子の順番は関係ありません。</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">消去されない要素の順番は保存されます。(これにより、コンテナを反復しながら個々の要素を消去することが可能になります)。</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">等価比較する要素の順序は挿入順であり、変更はありません。(C++11 以降)。</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">キーが等価な比較をするキーと値のペアの順序は、挿入順であり、変更されません。(C++11 以降)。</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">順序付けの比較は辞書式に行われます-比較は &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; と同等の関数によって実行されます。</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">順序は厳密な弱順序関係である。</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; キーワードの本来の目的は、&lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;関数のインライン置換が&lt;/a&gt;関数呼び出しよりも優先される、つまり、関数呼び出しのCPU命令を実行して関数本体に制御を移す代わりに、関数本体は、呼び出しを生成せずに実行されます。これにより、関数呼び出し（引数の受け渡しと結果の取得）によって生じるオーバーヘッドは回避されますが、関数のコードを複数回繰り返す必要があるため、実行可能ファイルが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">出力イテレータ &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; すると、標準のアルゴリズムで初期化されていないメモリに結果を保存できます。アルゴリズムがタイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを逆参照イテレーターに書き込むときはいつでも、オブジェクトはイテレーターが指す初期化されていないストレージ内の場所にコピー構築されます。テンプレートパラメータ &lt;code&gt;OutputIt&lt;/code&gt; は、&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;の要件を満たし、オブジェクトを返すように &lt;code&gt;operator*&lt;/code&gt; 定義されている任意のタイプです。そのため、 &lt;code&gt;operator&amp;amp;&lt;/code&gt; はタイプ &lt;code&gt;T*&lt;/code&gt; オブジェクトを返します。通常、タイプ &lt;code&gt;T*&lt;/code&gt; は &lt;code&gt;OutputIt&lt;/code&gt; として使用されます。</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">式の出力は、その結果と、式によって変更されたすべてのオペランド(もしあれば)で構成されます。</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">場合、過負荷（3）のみオーバーロード解決に関与 &lt;code&gt;Sseq&lt;/code&gt; はとしての資格&lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;。特に、 &lt;code&gt;Sseq&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; に変換可能な場合、候補関数のセットから除外されます。</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">オーバーロード（3）は、 &lt;code&gt;int&lt;/code&gt; などの非クラス型の要素をゼロに初期化します。これは、初期化されていない&lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt;動作とは異なります。 &lt;code&gt;new[]&lt;/code&gt; 動作と一致させるために、そのような要素を初期化しないままにする&lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;カスタムAllocator :: construct&lt;/a&gt;を提供できます。</target>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; リターンの最初の要素へのポインタ &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;valarray&lt;/code&gt; 数値配列の最初の要素を参照して指定されていないタイプのイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;initializer_list&lt;/code&gt; の最後の要素過去1に戻りポインタ &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;valarray&lt;/code&gt; 数値配列の最後の要素過去1を参照の不特定の型のイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; リターン &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; の最後の要素を指し &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">過負荷 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;initializer_list&lt;/code&gt; 戻り &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; の最初の要素を指し &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">operator- &lt;code&gt;-&amp;gt;&lt;/code&gt; のオーバーロードは、生のポインターを返すか、またはoperator- &lt;code&gt;-&amp;gt;&lt;/code&gt; がオーバーロードされたオブジェクトを（参照または値によって）返す必要があります。</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを取らないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; を使用し、エラーコード引数としてOSエラーコードを使用して構築された、基になるOS APIエラーに対して&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを取らないオーバーロードは、OSエラーコードをエラーコード引数として構築された、基になるOS APIエラーに対して&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取らないオーバーロードは、最初のパス引数として &lt;code&gt;to&lt;/code&gt; から 2番目のパス引数として、およびエラーコード引数としてOSエラーコードとして構築さ &lt;code&gt;from&lt;/code&gt; 、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを受け取らないオーバーロードは、最初のパス引数として &lt;code&gt;new_p&lt;/code&gt; 、2番目のパス引数としてnew_p、エラーコード引数としてOSエラーコードを &lt;code&gt;old_p&lt;/code&gt; して構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">とらないオーバーロード &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータは、スロー&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; を&lt;/a&gt;用いて構築基盤となるOSのAPIのエラー、上 &lt;code&gt;p1&lt;/code&gt; 最初のパス引数として &lt;code&gt;p2&lt;/code&gt; 第2の経路引数として、およびエラーコードの引数としてOSのエラーコード。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターを取らないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; を使用し、エラーコード引数としてOSエラーコードを使用して構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータをとらないオーバーロードは、最初のパス引数として &lt;code&gt;p&lt;/code&gt; 、2番目のパス引数として &lt;code&gt;base&lt;/code&gt; 、エラーコード引数としてOSエラーコードを使用して構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメーターをとらないオーバーロードは、最初のパス引数として &lt;code&gt;path to be returned&lt;/code&gt; れるパスとエラーコード引数としてOSエラーコードで構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; パラメータをとらないオーバーロードは、 &lt;code&gt;target&lt;/code&gt; を最初のパス引数として、 &lt;code&gt;link&lt;/code&gt; を2番目のパス引数として、OSエラーコードをエラーコード引数として構築された、基になるOS APIエラーに対して&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;をスローします。 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆パラメータを取るオーバーロードは、OS API呼び出しが失敗した場合にOS APIエラーコードに設定し、エラーが発生しない場合は &lt;code&gt;ec.clear()&lt;/code&gt; を実行します。 &lt;code&gt;noexcept&lt;/code&gt; とマークされていないオーバーロードは、メモリの割り当てに失敗した場合に &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; スローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">&lt;code&gt;ExecutionPolicy&lt;/code&gt; という名前のテンプレートパラメータを持つオーバーロードは、次のようにエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">オーバーロード（2-6）は &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; へのアロケーターの伝播を提供します。これは、リーディングアロケーターもトレーリングアロケーターの呼び出し規約もサポートしません（たとえば、リーディングアロケーター規約を使用する &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; とは異なります）。</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">多くの場合、オーバーロード（5、6）は、 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; をヒントとしてオーバーロード（3）を呼び出すループとして実装されます。それらは、最小の要素が &lt;code&gt;*this&lt;/code&gt; の最後の要素より大きいソートされたシーケンス（別のセットなど）を追加するために最適化されています。</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">C ++ 14以降、オーバーロードは &lt;code&gt;constexpr&lt;/code&gt; としてマークされています。</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">パラメータとして &lt;code&gt;opts&lt;/code&gt; をとらないオーバーロードは、&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; の&lt;/a&gt;デフォルトで構築されたインスタンスをオプションとして使用します。 &lt;code&gt;upstream&lt;/code&gt; をパラメーターとして使用しないオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; の戻り値をアップストリームメモリリソースとして使用します。</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">パラメータとして &lt;code&gt;opts&lt;/code&gt; をとらないオーバーロードは、&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; の&lt;/a&gt;デフォルトで構築されたインスタンスをオプションとして使用します。 &lt;code&gt;upstream&lt;/code&gt; をパラメーターとして使用しないオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; 戻り値をアップストリームメモリリソースとして使用します。</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆または &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆を左側の引数として取る &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; のオーバーロードは、挿入および抽出演算子と呼ばれます。これらはユーザー定義型を正しい引数（ &lt;code&gt;b&lt;/code&gt; @bのb）として取るので、非メンバーとして実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; のオーバーロード 短絡評価を失います。</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">引数が範囲外の場合、 &lt;code&gt;pos1&lt;/code&gt; または &lt;code&gt;pos2&lt;/code&gt; という名前のパラメーターを取るオーバーロードは &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; スローします。</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 使用しないオーバーロードは、各タプル引数がペアの要素になることを前提としています。 &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; を使用するオーバーロードでは、各タプル引数を使用して、指定されたタイプの新しいオブジェクトを区分的に構築し、それがペアの要素になります。</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">&lt;code&gt;ExecutionPolicy&lt;/code&gt; という名前のテンプレートパラメータを持つオーバーロードは、次のようにエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">仮想メンバー関数 &lt;code&gt;what()&lt;/code&gt; のオーバーライドは提供される場合がありますが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;仮想&lt;/a&gt;関数のオーバーライドは、基本クラス宣言からデフォルト引数を取得しません。仮想関数呼び出しが行われると、デフォルト引数はオブジェクトの静的タイプに基づいて決定されます（注：これは&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;非仮想インターフェイス&lt;/a&gt;パターン）。</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">オブジェクトの所有権は、その値を別の &lt;code&gt;shared_ptr&lt;/code&gt; にコピー構築またはコピー割り当てすることによってのみ、別の &lt;code&gt;shared_ptr&lt;/code&gt; と共有できます。別の &lt;code&gt;shared_ptr&lt;/code&gt; が所有する生の基本ポインターを使用して新しい &lt;code&gt;shared_ptr&lt;/code&gt; を構築すると、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">標準規格の厳密なエイリアシングルールを定義する段落には、Cから部分的に継承された2つの追加の箇条書きが含まれています。</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">このアルゴリズムの並列化可能なバージョンである &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; では、 &lt;code&gt;op1&lt;/code&gt; と &lt;code&gt;op2&lt;/code&gt; が可換的かつ連想的である必要がありますが、 &lt;code&gt;std::inner_product&lt;/code&gt; ではそのような要件はなく、常に指定された順序で操作を実行します。</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">パラメータ &lt;code&gt;P&lt;/code&gt; は次のように取得されます &lt;code&gt;T&lt;/code&gt; では、 &lt;code&gt;auto&lt;/code&gt; を含む変数の宣言された型で、autoのすべての出現 &lt;code&gt;auto&lt;/code&gt; が架空の型テンプレートパラメータ &lt;code&gt;U&lt;/code&gt; で、または初期化がcopy-list-initializationの場合は &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; 置き換えられます。initializer_list &amp;lt;U&amp;gt;。引数 &lt;code&gt;A&lt;/code&gt; は初期化式です。上記のルールに従って &lt;code&gt;P&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; を演繹した後、演繹された &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;P&lt;/code&gt; に代入され、実際の変数の型が取得されます。</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">パラメータ &lt;code&gt;i&lt;/code&gt; は、配列の要素数よりも少なくなければなりません。それ以外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">パラメータ &lt;code&gt;init&lt;/code&gt; は、この関数ではオプションであるため、 &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; とは異なり、最後に表示されます。</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">パラメータは値で渡され、スライスの対象となります。</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">関数のパラメータ型と戻り値の型はターゲットと正確に一致していなければならず、暗黙の変換は考慮されません(例えば、baseへのポインタを返す関数へのポインタを初期化する際に、 derivedへのポインタを返す関数は選択されません)。</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">削除された関数（C ++ 11以降）を除いて、パラメーターの型と関数の戻りの型を&lt;a href=&quot;incomplete_type&quot;&gt;不完全な&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;クラス型&lt;/a&gt;にすることはできません。完全性チェックは、関数のコンテキストで行われます</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">関数定義の宣言子で宣言されたパラメーターは、本体内の&lt;a href=&quot;scope&quot;&gt;スコープ&lt;/a&gt;内にあります。関数本体でパラメーターが使用されていない場合は、名前を付ける必要はありません（抽象宣言子を使用するだけで十分です）。</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">パラメータ m と s はそれぞれ x の自然対数の平均と標準偏差である。</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">配布オブジェクトのパラメーターは、 &lt;code&gt;d.param(p)&lt;/code&gt; を使用して永続的に変更することも、 &lt;code&gt;d(g,p)&lt;/code&gt; を使用して単一のoperator（）呼び出しの期間だけ変更することもできます。</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">スライスのパラメータ --開始、サイズ、ストライドをそれぞれ指定します。</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">スライスのパラメータ --それぞれ開始、サイズ、歩幅。</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">主関数の2つのパラメータ形式のパラメータは、実行環境から任意のマルチバイト文字列を渡すことを可能にします(これらは通常</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析された日付は、引数 &lt;code&gt;t&lt;/code&gt; が指す &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体の対応するフィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">解析された月は、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; フィールド &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析された時間は、引数 &lt;code&gt;t&lt;/code&gt; が指す &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体の対応するフィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">解析された平日は、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; フィールド &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">解析された年は、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 構造体フィールド &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">部分的な特殊化（5）は、 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; 変換できない場合にのみ存在します。</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">ペアの &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; の部分的な特殊化は、タプルのような構文を使用して、ペアの要素の数（常に2）を取得するコンパイル時の方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">ペアの &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; の部分的な特殊化は、タプルのような構文を使用して、ペアの要素のタイプへのコンパイル時アクセスを提供します。 &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; 場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">テンプレートの部分特殊化 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、ユーザーがshared_ptrのがアトミックオブジェクトを操作することができます。</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">テンプレートの部分特殊化 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、ユーザーがアトミックのweak_ptrオブジェクトを操作することができます。</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">過去の終わりのイテレータは特に言及する価値があります。一般に、このイテレータは、消去されていない要素に対する通常のイテレータであるかのように無効化されます。したがって、 &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; は決して無効化されず、 &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; はrehashでのみ無効化され、 &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; は常に無効化されます（常に変更された要素の後にあるため）。</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">また、消去された要素がコンテナの先頭にあり、最後の要素が消去されていない場合は、過去終了イテレータも無効になります。</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">過去の終わりのイテレータは無効になる可能性があります(実装で定義されています)。</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">過去の終わりのイテレータです。</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">パス &lt;code&gt;&quot;/&quot;&lt;/code&gt; はPOSIX OSでは絶対パスですが、Windowsでは相対パスです。</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">パスは、 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 関数によって返されるイテレータを介して要素ごとにトラバースできます。イテレータは一般的な形式でパスを表示し、ルート名、ルートディレクトリ、および後続のファイル名要素を反復します（ただし、ディレクトリセパレータはスキップされます。ルートディレクトリを識別するもの）。パスの最後の要素がディレクトリセパレータの場合、最後のイテレータは空の要素を逆参照します。</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">入力文字列を UTF-8 からファイルシステムのネイティブ文字エンコーディングに変換した後に構築されたパス。</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">パス名には次のような構文があります。</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">親ディレクトリへのパス。</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">離心率 &lt;code&gt;k&lt;/code&gt; 、半長軸aの楕円の外周は4aE（k）に等しく、Eは &lt;code&gt;std::comp_ellint_2&lt;/code&gt; です。離心率が0の場合、楕円は縮退して半径aの円になり、周長は2&amp;pi;aになるため、E（0）=&amp;pi;/ 2になります。離心率が1に等しい場合、楕円は長さが2aの線に縮退し、その外周は4aなので、E（1）= 1です。</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">結果の期間の期間は、 &lt;code&gt;Period1&lt;/code&gt; と &lt;code&gt;Period2&lt;/code&gt; の最大公約数です。</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">プレースホルダー&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;はconversion-type-idで使用でき、&lt;a href=&quot;function#Return_type_deduction&quot;&gt;推定される戻りの型を示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">プレースホルダー &lt;code&gt;auto&lt;/code&gt; には、型の推定に参加する &lt;code&gt;const&lt;/code&gt; や &lt;code&gt;&amp;amp;&lt;/code&gt; などの修飾子が伴う場合があります。プレースホルダー &lt;code&gt;decltype(auto)&lt;/code&gt; は、宣言された型の唯一の構成要素でなければなりません（C ++ 14以降）。</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">配置形式 &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; は許可されません。これは、割り当て解除関数の一致するシグニチャー &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; が通常の（配置ではない）ためです。割り当て解除関数。</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">プラットフォーム依存のエラー値。</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">&lt;a href=&quot;injected-class-name&quot;&gt;注入されたクラス名&lt;/a&gt;の宣言のポイントは、そのクラス（またはクラステンプレート）定義の左中括弧の直後です。</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">&lt;a href=&quot;structured_binding&quot;&gt;構造化バインディング&lt;/a&gt;の宣言のポイントは、構造化バインディング宣言の識別子リストの直後ですが、構造化バインディング初期化子は、導入されている名前を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;タイプエイリアスまたはエイリアステンプレート&lt;/a&gt;の宣言のポイントは、エイリアスが参照するtype-idの直後です。</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">クラスまたはテンプレートの宣言のポイントは、クラスに名前を付ける識別子（またはテンプレートの特殊化に名前を付けるテンプレート&lt;a href=&quot;templates#template-id&quot;&gt;ID&lt;/a&gt;）がその&lt;a href=&quot;classes&quot;&gt;class-headに&lt;/a&gt;現れた直後であり、基本クラスのリストのスコープ内に既にあります。</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">列挙型の宣言のポイントは、&lt;a href=&quot;enum&quot;&gt;列挙型指定子&lt;/a&gt;または不透明な列挙型宣言で最初に使用された方の、列挙型を指定する識別子の直後です。</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">列挙子の宣言ポイントは、その定義の直後(変数の場合のようにイニシャライザの前ではありません)です。</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">ポインタからメンバへのポインタは,それ自体がポインタからメンバへのポインタであっても構いません:メンバへのポインタは,複数レベルであっても構いません.ポインタとポインタからメンバへのポインタの混在した複数レベルの組み合わせも許されます.</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; が保持するポインタ。</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; が直接保持するポインターは &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; によって返されるポインターですが、制御ブロックが保持するポインター/オブジェクトは、共有所有者の数がゼロに達したときに削除されるポインターです。これらのポインタは必ずしも同じではありません。</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">ポインターは範囲 &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; は有効であり、その値は文字列に格納された値に対応し、最後の位置の後にnull文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; から取得したポインタは、次の方法で無効化できます。</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; から取得したポインタは、文字列オブジェクトに他のnull文字が含まれていない場合にのみ、nullで終了する文字列へのポインタとして扱われます。</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;data()&lt;/code&gt; から取得したポインタは、次の方法で無効化できます。</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.allocate(n)&lt;/code&gt; の呼び出しによって返されるポインター。</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">この実装で使用されるポインタの安全性。</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">変換先のポインタ</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">割り当てられたストレージへのポインタ。</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">再利用するストレージのブロックへのポインターは、最初の引数として上記のプロセスで選択された&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;割り当て解除関数に&lt;/a&gt;渡されます。ブロックのサイズは、オプションの &lt;code&gt;std::size_t&lt;/code&gt; 引数として渡されます。アラインメント要件は、オプションの &lt;code&gt;std::align_val_t&lt;/code&gt; 引数として渡されます（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">人気の高いEdsger W. Dijkstraのエッセイ&lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;「Gotoは有害であると考えられている」は&lt;/a&gt;、このキーワードの不注意な使用がもたらす可能性がある多くの微妙な問題の調査を提示しています。</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; の前の宣言の部分は、導入された識別子ではなく、隠し変数 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; に適用されます。</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">指定されたマッチまたはサブマッチの最初の文字の位置。</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">このタイプの可能な値（ &lt;code&gt;icase&lt;/code&gt; 、 &lt;code&gt;optimize&lt;/code&gt; 、など）は&lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt;内で複製されます。</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FLT_ROUNDSの可能な値は、 &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; によって返されるstd :: &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; 可能な値と一致します。</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">後付けの条件は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">postfix の増分式と減分式は、形式を持ちます。</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">関数パラメータ(ラムダ式のパラメータを含む)または関数ローカルの定義済み変数の潜在的なスコープは、その宣言時点から始まります。</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;クラスで&lt;/a&gt;宣言された名前の潜在的なスコープは、宣言の時点から始まり、残りのクラス本体とすべての関数本体（クラス定義の外部または名前の宣言の前に定義されている場合でも）、デフォルト引数、例外仕様が含まれます、クラス内のブレースまたはイコールイニシャライザ、&lt;a href=&quot;attributes/contract&quot;&gt;コントラクト条件&lt;/a&gt;（C ++ 20以降）、およびネストされたクラスのこれらすべてのものを再帰的に返します。</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">例外ハンドラで宣言された名前の潜在的なスコープは、宣言された時点から始まり、例外ハンドラが終了した時点で終了します。</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">で宣言された名前の潜在的なスコープは</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">テンプレート・パラメータ名の潜在的な範囲は、宣言された時点から始まり、それが導入された最小のテンプレート宣言の最後まで続きます。特に,テンプレート・パラメータは,後続のテンプレート・パラメータの宣言や基底クラスの仕様では使用できますが,先行するテンプレート・パラメータの宣言では使用できません。</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">&lt;a href=&quot;statements#Compound_statements&quot;&gt;ブロック（複合ステートメント）の&lt;/a&gt;宣言によって導入される変数の潜在的なスコープは、宣言のポイントで始まり、ブロックの終わりで終わります。同じ名前を導入する宣言を持つネストされたブロックがない限り、実際のスコープは潜在的なスコープと同じです（その場合、ネストされた宣言の潜在的なスコープ全体が外部宣言のスコープから除外されます）。</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">&lt;a href=&quot;namespace&quot;&gt;名前空間で&lt;/a&gt;宣言されたエンティティの潜在的なスコープは宣言から始まり、その後に続く同じ名前空間名のすべての名前空間定義の連結と、この名前またはその名前空間全体を別のスコープに導入した&lt;a href=&quot;namespace&quot;&gt;usingディレクティブ&lt;/a&gt;で構成されます。そのスコープの残りの部分。</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">テンプレートテンプレートパラメータのパラメータ名の潜在的なスコープは、その名前が現れる最小のテンプレートパラメータリストです。</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">結果の精度は少なくとも &lt;code&gt;std::chrono::seconds&lt;/code&gt; であり、引数の精度が高いほど、精度が高くなります。</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">契約条件の述語には、それが適用される関数の本文の最初の&lt;a href=&quot;../statements#Expression_statements&quot;&gt;式ステートメント&lt;/a&gt;として出現する場合と同じ意味上の制限があります。</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">接頭辞の増分式と減分式は、形式を持ちます。</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">前処理ディレクティブは、プリプロセッサの動作を制御します。それぞれのディレクティブは1行で構成され、以下のような形式になっています。</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">プリプロセッサは、ソースファイルの翻訳機能を持っています。</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">プリプロセッサーは、コンパイル前の&lt;a href=&quot;language/translation_phases&quot;&gt;変換フェーズ4&lt;/a&gt;で実行されます。前処理の結果、単一のファイルが作成され、実際のコンパイラに渡されます。</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">プリプロセッサは、ソースファイルの一部の条件付きコンパイルをサポートしています。この動作はによって制御されている &lt;code&gt;#if&lt;/code&gt; 、 &lt;code&gt;#else&lt;/code&gt; の、 &lt;code&gt;#elif&lt;/code&gt; の、 &lt;code&gt;#ifdef&lt;/code&gt; 、 &lt;code&gt;#ifndef&lt;/code&gt; 命令と &lt;code&gt;#endif&lt;/code&gt; のディレクティブ。</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">プリプロセッサは、テキストマクロの置換をサポートしています。関数のようなテキストマクロの置換もサポートしています。</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; によって返される以前のロケール。</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">グローバル C++ロケールの前の値。</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされた新しいハンドラ、または何もインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされていた終了ハンドラ、またはインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">以前にインストールされた予期せぬハンドラ、または何もインストールされていない場合はNULLポインタの値。</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">プライマリ &lt;code&gt;std::atomic&lt;/code&gt; テンプレートは、&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;と&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignableの&lt;/a&gt;両方を満たす任意の&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型 &lt;code&gt;T&lt;/code&gt; でインスタンス化できます。次のいずれかの値が &lt;code&gt;false&lt;/code&gt; の場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">主な &lt;code&gt;std::atomic_ref&lt;/code&gt; テンプレートは、任意の&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;タイプ &lt;code&gt;T&lt;/code&gt; （ &lt;code&gt;bool&lt;/code&gt; を含む）でインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">function-try-block の主な目的は、コンストラクタのメンバ初期化リストからスローされた例外に対応するために、ログを取って再スローしたり、例外オブジェクトを修正して再スローしたり、代わりに別の例外をスローしたり、プログラムを終了したりすることです。デストラクタや通常の関数ではほとんど使用されません。</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">大文字、小文字、異体字、発音区別符号などを無視して、現在埋め込まれているロケールの文字シーケンス &lt;code&gt;[first, last)&lt;/code&gt; のプライマリソートキー。</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">プライマリテンプレート(1)は定義されておらず、4つの異なるレベルの精度を扱うために4つの特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">プライマリ・テンプレートは空の構造体です。標準では、以下のような特殊化を定義しています。</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">プライマリテンプレートが空です。デフォルトのタイムゾーンポインタータイプである &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; の特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; の主な用途は、 &lt;code&gt;operator[]&lt;/code&gt; から返されるl値を提供することです。</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bitset::reference&lt;/code&gt; の主な用途は、&lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt;から返されるl値を提供することです。</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">プライベート &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; メンバーは、この代入演算子の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">確率 &lt;code&gt;h(a)==h(b)&lt;/code&gt; ための &lt;code&gt;a!=b&lt;/code&gt; 接近しなければならない &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">プログラムは形が悪い</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">&lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; が真でない場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 特殊化でない場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; が負の場合、プログラムの形式は正しくありません。場合 &lt;code&gt;N&lt;/code&gt; がゼロである、示されたタイプである &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; が2の累乗でない場合、プログラムの形式は &lt;code&gt;ptr&lt;/code&gt; ません。ptrが &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを指さない場合（すべてのレベルでcv-qualificationを無視）、またはオブジェクトの配置が &lt;code&gt;N&lt;/code&gt; でない場合、動作は未定義です。。</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が関数型または（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; の場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">&lt;code&gt;std::initializer_list&lt;/code&gt; 明示的または部分的な特殊化が宣言されている場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">次のいずれかが当てはまらない場合、プログラムの形式が &lt;code&gt;true&lt;/code&gt; ありません。</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">プログラムは,1つの明確な</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">プログラマーは、デストラクタが起動したら、特に待機スレッドがループで待機関数を呼び出している場合や、述語を取る待機関数のオーバーロードを使用している場合に、スレッドが &lt;code&gt;*this&lt;/code&gt; 待機を試みないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">プログラミング言語&lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt;は、最初に式の値カテゴリを導入しました。すべてのCPL式は「右側モード」で評価できますが、「左側モード」では特定の種類の式のみが意味を持ちます。右辺モードで評価される場合、式は値（右辺の値、または</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">プロミスは、プロミス未来通信チャネルの &quot;プッシュ &quot;エンドである:共有状態に値を格納する操作</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; のパブリック関数は、 &lt;code&gt;gptr() == nullptr&lt;/code&gt; または &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; 場合にのみ、この関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">厳密なエイリアスと関連ルールの目的は、タイプベースのエイリアス分析を有効にすることです。これは、プログラムが関連のないタイプ（ &lt;code&gt;int*&lt;/code&gt; と &lt;code&gt;float*&lt;/code&gt; ）への2つのポインタが同時に存在し、どちらも同じメモリをロードまたは保存するために使用できます（&lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;SG12リフレクタのこの電子メールを&lt;/a&gt;参照）。したがって、そのような状況を作成できると思われる技法は、必ず未定義の動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">このアダプタの目的は、入れ子になったコンテナのすべてのレベルが同じ共有メモリセグメントに配置されなければならない場合など、入れ子になったコンテナ内のステートフルなアロケータを正しく初期化することです。アダプタのコンストラクタはリスト内のすべてのアロケータの引数を取り、 各ネストされたコンテナは必要に応じてアダプタからそのアロケータの状態を取得します。</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外タイプの目的は、エラー条件 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; メンバー関数から &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; スローされる）および関連するerrno定数 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">このルールの目的は、テンプレートのインスタンス化に関する&lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODRの&lt;/a&gt;違反を防ぐことです。</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">疑問符のエスケープシーケンス &lt;code&gt;\?&lt;/code&gt; &lt;a href=&quot;operator_alternative&quot;&gt;トリグラフ&lt;/a&gt;が文字列リテラル内で解釈されないようにするために使用されます。 &lt;code&gt;&quot;??/&quot;&lt;/code&gt; などの文字列は &lt;code&gt;&quot;\&quot;&lt;/code&gt; としてコンパイルされ &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; 、「？\？/」のように2番目の疑問符がエスケープされると、「？」になり &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">実装がクワイエットNaNをサポートしていない場合は、識別文字列 &lt;code&gt;arg&lt;/code&gt; またはゼロに対応するクワイエットNaN値。</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">商は実装で定義された方向に丸められます。</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">商は、小数部分が破棄された（ゼロに向かって切り捨てられた）代数商です。残りは &lt;code&gt;quot * y + rem == x&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">商は、式 &lt;code&gt;x/y&lt;/code&gt; の結果です。残りは、式 &lt;code&gt;x%y&lt;/code&gt; の結果です。</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">商はゼロに向かって切り捨てられます(端数部分は破棄されます)。</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">乱数ライブラリは、乱数や擬似乱数を生成するクラスを提供します。これらのクラスには以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、 &lt;code&gt;value&lt;/code&gt; に関して少なくとも部分的に順序付けられている必要があります。つまり、次の要件をすべて満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、式 &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; または &lt;code&gt;!comp(value, element)&lt;/code&gt; に関して分割する必要があります。つまり、式が &lt;code&gt;true&lt;/code&gt; であるすべての要素は、式が &lt;code&gt;false&lt;/code&gt; であるすべての要素の前になければなりません。。完全にソートされた範囲はこの基準を満たしています。</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; は、式 &lt;code&gt;element &amp;lt; value&lt;/code&gt; または &lt;code&gt;comp(element, value)&lt;/code&gt; に関して分割する必要があります。つまり、式が &lt;code&gt;true&lt;/code&gt; であるすべての要素は、式が &lt;code&gt;false&lt;/code&gt; であるすべての要素よりも前になければなりません。完全にソートされた範囲はこの基準を満たしています。</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">ranges ライブラリには、さまざまなビューアダプタを含む、要素の範囲を扱うためのコンポーネントが用意されています。</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">標準変換シーケンスのランクは、それが保持する標準変換のランクの中で最悪です（最大&lt;a href=&quot;implicit_cast&quot;&gt;3つの変換&lt;/a&gt;がある場合があります）。</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">生のポインタオーバーロードは、ポイントされたオブジェクトの所有権を想定しています。したがって、 &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; などによってすでに &lt;code&gt;shared_ptr&lt;/code&gt; によって管理されているオブジェクトの生のポインタオーバーロードを使用して &lt;code&gt;shared_ptr&lt;/code&gt; を構築すると、オブジェクトが &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">再割り当てはどちらかで行います。</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">rebindメンバのテンプレートエイリアスは、Tを指すポインタのような型が与えられると、Uを指すのと同じポインタのような型を取得することを可能にします。</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">認識されるバイトオーダーマークは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">参照は、この &lt;code&gt;ios_base&lt;/code&gt; オブジェクトに対する操作 &lt;code&gt;iword()&lt;/code&gt; への別の呼び出しを含む）によって無効になる可能性がありますが、格納された値は保持されるため、後で同じインデックスを持つ &lt;code&gt;iword(index)&lt;/code&gt; から読み取ると、同じ値が生成されます（次の &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ）を呼び出します。値は任意の目的に使用できます。要素のインデックスは、以前に &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; を呼び出して取得する必要があります。それ以外の場合の動作は未定義です。新しい要素はに初期化され &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参照は、この &lt;code&gt;ios_base&lt;/code&gt; オブジェクトに対する操作 &lt;code&gt;pword()&lt;/code&gt; への別の呼び出しを含む）によって無効になる可能性がありますが、格納された値は保持されるため、後で同じインデックスを持つ &lt;code&gt;pword(index)&lt;/code&gt; から読み取ると、同じ値が生成されます（次の &lt;code&gt;copyfmt()&lt;/code&gt; への呼び出し）。値は任意の目的に使用できます。要素のインデックスは &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; によって取得する必要があります。そうでない場合、動作は未定義です。新しい要素は &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; に初期化されます。</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">参照されるビット。</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">正規表現イテレータは、シーケンス内で見つかった正規表現のマッチのセット全体を追跡するために使用されます。</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">正規表現ライブラリはこの特性を使用して、文字を等価クラスと照合します。例えば、正規表現 &lt;code&gt;[[=a=]]&lt;/code&gt; 文字に相当する &lt;code&gt;c1&lt;/code&gt; 場合 &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; と等価である &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; （いずれかのために真である &lt;code&gt;c1&lt;/code&gt; から &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; 米国で英語ロケール）。なお &lt;code&gt;transform_primary()&lt;/code&gt; 同値クラスは複数文字であってもよいのでなど、文字列引数を取る &lt;code&gt;[[=ch=]]&lt;/code&gt; チェコまたは &lt;code&gt;[[=dzs=]]&lt;/code&gt; ハンガリー語です。</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">regex traits クラスは、正規表現のローカライズ可能な側面をカプセル化するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">登録された関数は、&lt;a href=&quot;exit&quot;&gt;通常のプログラム終了時&lt;/a&gt;に呼び出されません。その場合に関数を &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 必要がある場合は、std :: atexitを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">正規表現ライブラリは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正規表現&lt;/a&gt;を表すクラスを提供します。正規表現は、文字列内でパターンマッチングを実行するために使用される一種のミニ言語です。正規表現を使用したほとんどすべての操作は、以下のオブジェクトのいくつかを操作することによって特徴付けることができます。</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">関連するPOSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt;は、 &lt;code&gt;command&lt;/code&gt; によって生成された出力を呼び出し元が利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">関連する関数 &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; は出力に改行文字を追加し、 &lt;code&gt;std::fputs&lt;/code&gt; は変更されていない文字列を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">トップレベルの cv-qualifiers を削除しても,関数内で表示されるパラメータの型には影響しません.</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">&lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; ヘッダーが含まれていなくても、置き換え可能な割り当て解除関数（1〜10）は各変換単位で暗黙的に宣言されます。これらの機能は</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">指定された照合要素の文字列としての表現。</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C1::duration&lt;/code&gt; の表現タイプ。</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; となるような、要求されたサブスパン &lt;code&gt;r&lt;/code&gt; 。 &lt;code&gt;Count&lt;/code&gt; が &lt;code&gt;std::dynamic_extent&lt;/code&gt; 場合、 &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; それ以外の場合は &lt;code&gt;r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">要素に課される要件は、コンテナで実行される実際の操作によって異なります。一般に、要素タイプは完全なタイプであり、&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;の要件を満たす必要がありますが、多くのメンバー関数はより厳しい要件を課しています。</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">要素に課される要件は、コンテナで実行される実際の操作によって異なります。一般に、要素タイプは&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;の要件を満たす必要がありますが、多くのメンバー関数はより厳しい要件を課しています。アロケータが&lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;アロケータの完全性要件を&lt;/a&gt;満たしている場合、このコンテナ（そのメンバーではない）は不完全な要素型でインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">結果は</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">式に以下の潜在的に評価される構成の少なくとも1つが含まれている場合、結果は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">式の&lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;潜在的な例外&lt;/i&gt;&lt;/a&gt;のセットが空の場合、結果は &lt;code&gt;true&lt;/code&gt; になり、それ以外の場合は &lt;code&gt;false&lt;/code&gt; になります。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （算術オーバーフローなしで計算）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （算術オーバーフローなしで計算）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; （なしで計算されます）算術オーバーフロー）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 特殊化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 、指定された &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; および &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （計算なしで算術オーバーフロー）、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">結果は &lt;code&gt;bool&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">結果は準備ができています</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">結果は、列挙型の基になる型から宛先の型への&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的な変換&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">結果は、元の値を最初に列挙型の基になる型に&lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;変換し&lt;/a&gt;、次に列挙型に変換するのと同じです。</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; の大きさが大きい場合、結果にはほとんどまたはまったく意味がありません。</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; の結果は実装定義です。</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs != rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs % rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs * rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs + rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs - rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs / rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs ^ rhs&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs | rhs&lt;/code&gt; の結果| rhs。</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs || rhs&lt;/code&gt; の結果|| rhs。</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">終了反復子の &lt;code&gt;operator*&lt;/code&gt; または &lt;code&gt;operator-&amp;gt;&lt;/code&gt; の結果は、未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; の結果は、空のクラス型に適用された場合でも、常にゼロ以外です。</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;~arg&lt;/code&gt; の結果。</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">ディレクトリのサイズを決定しようとした結果(通常のファイルやシンボリックリンクではない他のファイルも同様に)は、実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">ではない match_results オブジェクトのほとんどのメンバ関数を呼び出した結果。</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">2つのポインタをメンバに比較した結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">オブジェクトへの2つのポインタを比較した結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">符号なし整数に負の数の文字列を変換した結果は、いくつかの実装でのプロトコルに続いているが、++ 17 Cまでゼロを生成するために指定された &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; ターゲットタイプで否定、与え &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&quot;-1&quot;&lt;/code&gt; 、および代わりに、ターゲットタイプの最大値を生成します。C ++ 17 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; は、std :: strtoullに厳密に従うことが正しい動作です。</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">2つのポインタの均等比較の結果(変換後)は以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">operator〜の結果は、（昇格後の）引数のビット単位のNOT（1の補数）値です。 operator＆の結果は、オペランドのビットごとのAND値です（通常の算術変換後）。オペレーターの結果|オペランドのビットごとのOR値です（通常の算術変換後）。 operator ^の結果は、オペランドのビット単位のXOR値です（通常の算術変換後）。</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">パス連結の結果。</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">2つの &lt;code&gt;month&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::months&lt;/code&gt; です。その期間の単位はグレゴリオ暦の平均月の長さを表し、結果の期間は、オペランドによって表される特定の月の日数とは関係ありません。たとえば、 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; は、3月の秒数（ &lt;code&gt;2678400s&lt;/code&gt; ）ではなく、 &lt;code&gt;2629746s&lt;/code&gt; （30.436875日）です。</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">2つの &lt;code&gt;year&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::years&lt;/code&gt; 期間です。この期間単位はグレゴリオ暦の平均年の長さを表し、結果の期間は、オペランドで表される特定の年の日数とは関係ありません。たとえば、 &lt;code&gt;2018y - 2017y&lt;/code&gt; 結果は &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; であり、365日ではなく365.2425日を表します。</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">2つの &lt;code&gt;year_month&lt;/code&gt; 値を減算した結果は、型 &lt;code&gt;std::chrono::months&lt;/code&gt; です。この期間の単位は、平均グレゴリオ月（30.436875日）の長さを表し、結果の期間は、問題の期間の実際の日数とは関係ありません。例えば、結果 &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; 、2017年2月は28日しか含まれていても。</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">比較の結果： &lt;code&gt;*obj&lt;/code&gt; が &lt;code&gt;*expected&lt;/code&gt; と等しい場合は &lt;code&gt;true&lt;/code&gt; 、それ以外の場合は &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">上記のように変換した結果</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">以上のように決定された変換結果。</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">式の結果の型は常に &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">ジェネレーターによって生成された結果タイプ。これが &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、または &lt;code&gt;long double&lt;/code&gt; のいずれでもない場合の効果は未定義です。</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">ジェネレーターによって生成された結果タイプ。これが &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、または &lt;code&gt;unsigned long long&lt;/code&gt; のいずれでもない場合、効果は未定義です。</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">結果値は &lt;code&gt;T&lt;/code&gt; （1-3）または &lt;code&gt;bool&lt;/code&gt; （4）に明確に変換できます。</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">結果の値は、明確に &lt;code&gt;bool&lt;/code&gt; に変換できます。</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">結果のオフセットは、成功すると &lt;code&gt;pos_type&lt;/code&gt; に変換され、失敗すると &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">結果として得られる範囲は、どちらかの入力範囲と重なることはできません。</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">結果の範囲もソートされます。等価な要素がいくつかの要素が見つかった場合、すなわち、個別に処理される &lt;code&gt;m&lt;/code&gt; 個の時刻 &lt;code&gt;[first1, last1)&lt;/code&gt; および &lt;code&gt;n&lt;/code&gt; で時間を &lt;code&gt;[first2, last2)&lt;/code&gt; 、それにコピーされ &lt;code&gt;d_first&lt;/code&gt; 正確に &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; 回。結果の範囲は、いずれの入力範囲とも重複できません。</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">結果の文字列には &lt;code&gt;N&lt;/code&gt; 文字が含まれ、最初の文字は最後（ &lt;code&gt;N-1&lt;/code&gt; 番目）のビットに対応し、最後の文字は最初のビットに対応します。</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">円形にシフトされた要素を持つ結果の配列。</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">結果として得られる要素をシフトさせた値の配列。</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;func&lt;/code&gt; を適用して取得した値を持つ結果のvalarray 。</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">結果の値（つまり、対応するメンバー関数の効果の直前の値に、対応する2項演算子を &lt;code&gt;*this&lt;/code&gt; の&lt;a href=&quot;../memory_order#Modification_order&quot;&gt;変更順序&lt;/a&gt;で適用した結果）。</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">結果の値(つまり、対応するメンバ関数の効果の直前の値に対応する二進演算子を適用した結果)。</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">からの復帰は</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">捨て文のリターン文は、関数のリターン型控除には参加しません。</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">戻り値の型は、最も深く入れ子にされた引数型の上に2レベル以上のテンプレート入れ子を追加しません。</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; による任意のポインター型 &lt;code&gt;U*&lt;/code&gt; への変換をサポートするために、戻り値の型は（たとえば、 &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; *ではなく） &lt;code&gt;void*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">戻り値の型は、積分昇格後の左オペランドの型です。</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt;の戻り型</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が関数の場合、 &lt;code&gt;T&lt;/code&gt; の戻り型。それ以外の場合、定義されていません</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::begin&lt;/code&gt; の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::end&lt;/code&gt; の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iota_view::begin&lt;/code&gt; の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iota_view::end&lt;/code&gt; の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::bind&lt;/code&gt; の戻り値の型は、 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt;（f）から構築された型 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; メンバーオブジェクト、および &lt;code&gt;args...&lt;/code&gt; ごとに1つのオブジェクト型を保持します &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; &amp;lt;Arg_i&amp;gt; :: type。std &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; &amp;lt;Arg_i&amp;gt;（arg_i）から同様に構築されます。</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">戻り型 &lt;code&gt;std::bind&lt;/code&gt; ある&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;コピーコンストラクト&lt;/a&gt;、そのメンバオブジェクトの全て（上記で特定）はコピーコンストラクトであり、ある場合&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;そうでありません。タイプは次のメンバーを定義します。</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; の戻り値の型は、コピー/移動コンストラクターがメンバーごとのコピー/移動を実行するかのように動作します。それは&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;コピーコンストラクト&lt;/a&gt;（上記で特定）は、そのメンバオブジェクトのすべてがコピーコンストラクトであり、ある場合&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;そうでありません。</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not_fn&lt;/code&gt; の戻り型は、std &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 型のメンバーオブジェクトを保持します。</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">条件演算子の戻り値の型は、バイナリ型の特性 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; としてもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">関数呼び出し式の戻りの型は、選択された関数の戻りの型です。実際に呼び出されるオーバーライド関数が別の型を返す場合でも、静的バインディングを使用して決定されます（ &lt;code&gt;virtual&lt;/code&gt; キーワードは無視されます）。これにより、オーバーライド関数は、基本関数から返された戻り値の型から派生したクラスへのポインターまたは参照を返すことができ&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;ます&lt;/a&gt;。つまり、C ++は共変戻り値の型をサポートします。 &lt;code&gt;E&lt;/code&gt; がデストラクタを指定する場合、戻り値の型は &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">関数の戻り値の型は、関数型や配列型にすることはできません(ただし、それらへのポインタや参照は可能です)。</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">戻り値は、デフォルトで &lt;code&gt;std::cout&lt;/code&gt; 出力するものとは大幅に異なる場合があります。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">呼び出された関数の戻り値。</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">Compareを満たす型のオブジェクトに適用された関数呼び出し操作の戻り値は、&lt;a href=&quot;../language/implicit_cast&quot;&gt;状況に応じ&lt;/a&gt;て &lt;code&gt;bool&lt;/code&gt; に変換され、呼び出しの最初の引数が2番目の引数の前にある場合に &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">返される配列はヌル終端である必要はありません。</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">返される配列はnullで終了します。つまり、 &lt;code&gt;data()&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; は同じ機能を実行します。</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">返されたオブジェクト(コール・ラッパー)は、以下のプロパティを持っています。</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">返されたオブジェクトは、 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt;（f）から構築されたstd :: &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; &amp;lt;F&amp;gt;タイプのメンバーオブジェクト &lt;code&gt;fd&lt;/code&gt; と、 &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; （&lt;a href=&quot;../forward&quot;&gt;stdで&lt;/a&gt;構築された &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; オブジェクト &lt;code&gt;tup&lt;/code&gt; を保持するかのように動作します。:: forward &amp;lt; Args &amp;gt;（args）...）（これは &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; のラップを解除します）、ただし返されるオブジェクトの割り当て動作は指定されておらず、名前は説明のためだけに使用されます。</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">たとえば &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; が残っていて、制御ブロック全体が破棄されるまで実装が削除を破棄しない場合、返されたポインタは最後の &lt;code&gt;shared_ptr&lt;/code&gt; よりも長く存続する可能性があります。</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">返される範囲は2つのイテレータで定義され、1つは最初の要素である</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">返される文字列は、 &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; ように構築されます。これは、返される文字列のアロケータがデフォルトで構築されることを意味します&amp;mdash;新しいアロケータは</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">返された文字列はプログラムで変更してはなりませんが、 &lt;code&gt;strerror&lt;/code&gt; 関数への後続の呼び出しで上書きできます。 &lt;code&gt;strerror&lt;/code&gt; はスレッドセーフである必要はありません。実装は、静的な読み取り専用文字列リテラルへの異なるポインターを返す場合と、strerrorが文字列を配置する静的バッファーを指す同じポインターを繰り返し返す場合があります。</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">戻り値は &lt;code&gt;x&lt;/code&gt; と同じ符号を持ち、大きさは &lt;code&gt;y&lt;/code&gt; 未満です。</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">戻り値は正確で（ &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; は発生しません）、現在の&lt;a href=&quot;../fenv/fe_round&quot;&gt;丸めモード&lt;/a&gt;とは無関係です。</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">戻り値は正確で&lt;a href=&quot;../fenv/fe_round&quot;&gt;、現在の丸めモード&lt;/a&gt;は無視されます</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">逆は必ずしも当てはまりません。異なるオブジェクト表現を持つ&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型の2つのオブジェクトが同じ値を表す場合があります。たとえば、複数の浮動小数点ビットパターンは同じ特別な値&lt;a href=&quot;../numeric/math/nan&quot;&gt;NaNを&lt;/a&gt;表します。より一般的には、オブジェクト表現の一部のビットが値の表現にまったく関与しない場合があります。そのようなビットは、&lt;a href=&quot;objects#Alignment&quot;&gt;アラインメント要件&lt;/a&gt;、&lt;a href=&quot;bit_field&quot;&gt;ビットフィールド&lt;/a&gt;サイズなどを満たすために導入されたパディングである場合があります。</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">パスのルートディレクトリ。</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">パスのルート名。</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">パスのルートパスです。</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">丸めモードは &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 変更でき、 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; はその変更を反映します。</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">「より効率的な実装」に関するルールは、中間バッファリングなしでバルクI / Oを許可します。これにより、 &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; は、iostreamの一部の実装でポインタをPOSIX &lt;code&gt;read()&lt;/code&gt; システムコールに渡すだけです。</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">三五〇〇の法則</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">安全なbool問題</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">同じことが、I / O階層の次のクラス &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; ます。さらに派生したクラス（ &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; ）は常に具象streambufferオブジェクトを使用して構築され、仮想ベースの初期化を完了するために、場合によっては複数回、&lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S(il.begin(), il.end())&lt;/code&gt; と同じ</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">同じ機能を複数回登録することができます。</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">この関数が呼ばれるたびに同じ値が返されます。</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">同じ単語がマクロとしてインクルードファイル &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; のCプログラミング言語で定義されています。C ++で、これらは言語に組み込まれているため、C ++のバージョン &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; は、何も定義されていません。</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">名前のない名前空間またはインライン名前空間で宣言されたエンティティのスコープには、囲む名前空間が含まれます。</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">条件で紹介された名前の範囲は、宣言であれば両ステートメントの本体の範囲を合わせたものになります。</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;choose&lt;/code&gt; を &lt;code&gt;std::chrono::time_zone&lt;/code&gt; と &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; 特定のメンバー関数に渡して、あいまいな、または存在しない現地時間を解決する方法を制御できます。 &lt;code&gt;choose::earliest&lt;/code&gt; を渡すと以前の時点が返され、 &lt;code&gt;choose::latest&lt;/code&gt; を渡すと遅い時点が返されます。（存在しない現地時間の場合、これらの2つの時点は同じです。）</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::cv_status&lt;/code&gt; は、タイムアウトが原因で時間待機が返されたかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::errc&lt;/code&gt; は、POSIXエラーコードに対応する移植可能なエラー条件の値を定義します。</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::future_errc&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 例外オブジェクトの &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; および関連クラスによって報告されるエラーコードを定義します。実装では追加のエラーコードが定義される場合がありますが、必要なエラーコードは4つだけです。適切な専門ので &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 提供され、式の値 &lt;code&gt;std::future_errc&lt;/code&gt; に暗黙的に変換されている &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープ付き列挙 &lt;code&gt;std::io_errc&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 例外オブジェクトのI / Oストリームによって報告されるエラーコードを定義します。1つのエラーコード（ &lt;code&gt;std::io_errc::stream&lt;/code&gt; ）のみが必要ですが、実装では追加のエラーコードが定義される場合があります。 &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; の適切な特殊化が提供されているため、タイプ &lt;code&gt;std::io_errc&lt;/code&gt; 値は暗黙的に &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 変換できます。</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">スコープ付き列挙型 &lt;code&gt;pointer_safety&lt;/code&gt; は、C ++でサポートされるポインターセーフモードをリストします。</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">両方の演算子の第2オペランドが（正式名である&lt;a href=&quot;name#In_expressions&quot;&gt;ID-発現&lt;/a&gt;名こと）のデータメンバーまたはメンバー関数 &lt;code&gt;T&lt;/code&gt; または明白とアクセス基底クラスの &lt;code&gt;B&lt;/code&gt; の &lt;code&gt;T&lt;/code&gt; （例えば &lt;code&gt;E1.E2&lt;/code&gt; または &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ） 、オプションで&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;修飾&lt;/a&gt;（例： &lt;code&gt;E1.B::E2&lt;/code&gt; または &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; ）、オプションで&lt;a href=&quot;dependent_name&quot;&gt;テンプレートの曖昧性&lt;/a&gt; &lt;code&gt;E1.template E2&lt;/code&gt; （例：E1.template E2または &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; ）を使用。</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">両方のオペレータの第二オペランド部材（TO型ポインタの表現である&lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;データ&lt;/a&gt;又は&lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;機能&lt;/a&gt;）の &lt;code&gt;T&lt;/code&gt; 明白とアクセス可能な基底クラスのメンバーまたはポインタ &lt;code&gt;B&lt;/code&gt; の &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">2 番目のオーバーロードには、引数の先頭のための別のテンプレートパラメータとパラメータパックが含まれています。</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コールバックの2番目のパスは、 &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; ポインターが指すユーザー定義オブジェクトをディープコピーするために使用できます。</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">2番目のシグニチャーは、 &lt;code&gt;opts&lt;/code&gt; を &lt;code&gt;perm_options::replace&lt;/code&gt; 設定して呼び出されたかのように動作します。</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">選択された要素が存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">継承コンストラクターのセマンティクスは&lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;、C ++ 11に対する欠陥レポート&lt;/a&gt;によって遡及的に変更されました。以前は、継承コンストラクター宣言により、一連の合成コンストラクター宣言が派生クラスに注入され、冗長な引数のコピー/移動が発生し、SFINAEの一部の形式との相互作用に問題があり、主要なABIに実装できない場合がありました。古いコンパイラは、以前のセマンティクスをまだ実装している場合があります。</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">メンバー関数のセマンティクスは以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数のセマンティクスは、C関数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt;との一貫性を保つことを目的としています。</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数のセマンティクスは、C関数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt;と一致することを目的としています。</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">この対のイテレータで示されるシーケンスは、以下のように構成されている。</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">ステージ2で蓄積された &lt;code&gt;char&lt;/code&gt; のシーケンスは数値に変換されます</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">同じ &lt;code&gt;g&lt;/code&gt; を使用したこの呼び出しの連続した呼び出しによって返される一連の番号は、 &lt;code&gt;d.param()&lt;/code&gt; によってパラメーター化された分布に従ってランダムに分布されます。</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">同じ &lt;code&gt;g&lt;/code&gt; を使用したこの呼び出しの連続した呼び出しによって返される一連の数値は、 &lt;code&gt;p&lt;/code&gt; によってパラメーター化された分布に従ってランダムに分布されます。</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">候補となる関数のセットと引数のリストは、オーバーロード解決が使用されるコンテキストごとに独自の方法で用意されています。</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">オーバーロードの解決のために送信される候補関数のセットは、上記のセットの和集合です。オーバーロードの解決を目的とした引数リストは、 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; を除く演算子のオペランドで構成されています。2番目のオペランドは関数呼び出しの引数ではありません（&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;メンバーアクセス演算子を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">通常の&lt;a href=&quot;lookup&quot;&gt;非修飾ルックアップ&lt;/a&gt;によって見つかった宣言のセットと、ADLによって生成された関連セットのすべての要素で見つかった宣言のセットは、次の特別なルールでマージされます。</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">区間境界の集合 b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">baseの有効な値のセットは{0,2,3、...、36}です。2進整数の有効な数字のセットは &lt;code&gt;{0,1&lt;/code&gt; }、3 進整数は &lt;code&gt;{0,1,2&lt;/code&gt; }のようになります。 &lt;code&gt;10&lt;/code&gt; より大きい基数の場合、有効な数字には、11 進整数の &lt;code&gt;Aa&lt;/code&gt; から始まり、36 進整数の &lt;code&gt;Zz&lt;/code&gt; までの英字が含まれます。文字の大文字と小文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共有状態には、すでに値または例外が格納されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; に&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共有状態は、 &lt;code&gt;get_future&lt;/code&gt; の呼び出しによってすでに取得されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; に&lt;/a&gt;設定されます。</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">共有状態は、現在のスレッドが終了して</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短絡のインスタンス化は、 &lt;code&gt;conjunction&lt;/code&gt; を折り畳み式と区別します： &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; ような折り畳み式は、 &lt;code&gt;Bs&lt;/code&gt; のすべての &lt;code&gt;B&lt;/code&gt; をインスタンス化しますが、 &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; は、値が決定されるとインスタンス化を停止します。これは、後者のタイプのインスタンス化にコストがかかる場合、または間違ったタイプでインスタンス化するとハードエラーが発生する可能性がある場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短絡インスタンス化は &lt;code&gt;disjunction&lt;/code&gt; をフォールド式と区別します： &lt;code&gt;(... || Bs::value)&lt;/code&gt; ようなフォールド式は &lt;code&gt;Bs&lt;/code&gt; 内のすべての &lt;code&gt;B&lt;/code&gt; をインスタンス化しますが、 &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; は値が可能になるとインスタンス化を停止します決定。これは、後者のタイプのインスタンス化にコストがかかる場合、または間違ったタイプでインスタンス化するとハードエラーが発生する可能性がある場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">スカラーM(書き込み)に対する副作用Aは</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">結果の符号は、比較されるオブジェクトが異なる最初のバイトのペア（両方とも &lt;code&gt;unsigned char&lt;/code&gt; として解釈される）の値の差の符号です。</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">結果の符号は、比較される文字列が異なる最初の文字のペア（両方とも &lt;code&gt;unsigned char&lt;/code&gt; として解釈される）の値の差の符号です。</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">結果の符号は、比較される配列の中で異なる幅広文字の最初のペアの値の間の差の符号である。</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">結果の符号は、比較される文字列の中で異なる最初のワイド文字のペアの値の差の符号である。</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">署名に &lt;code&gt;const &amp;amp;&lt;/code&gt; を含める必要はありません。</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">比較関数のシグネチャは、次のようなものに相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">関数のシグネチャは以下に相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">述語関数のシグネチャは、次のようなものに相当するものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">同様の名前のコンテナーメンバー関数&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt;は、削除された要素を消去します。</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">サインは複素平面上の関数全体であり、枝切りを持たない。サインの数学的定義は、sin z =</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">との整合性が取れていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">大きさ &lt;code&gt;A&lt;/code&gt; の状態の大きさ以上である &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;array&lt;/code&gt; のサイズ。</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">任意のサイズ&lt;a href=&quot;objects&quot;&gt;のオブジェクト&lt;/a&gt;またはメンバーのサブオブジェクト（ない限り &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -下記参照）（++ 20 C以降）は、タイプが空である場合でも、少なくとも1であることが要求される&lt;a href=&quot;class&quot;&gt;クラスタイプ&lt;/a&gt;（あるクラスまたは同じタイプの異なるオブジェクトのアドレスが常に異なることを保証できるようにするために、非静的データメンバーを持たない構造体）。</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">ファイルのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">工事時に投入された民間コンテナの大きさ。</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">プッシュバックバッファのサイズは、実際には 4k (Linux,MacOS)から 4 (Solaris)まで、あるいは保証された最低 1 (HPUX,AIX)まで様々です。</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">参照先のファイルシステムオブジェクトのサイズ。</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">バイト単位のシーケンスのサイズ、つまり、 &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">演算子のサイズは</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">最小 &lt;code&gt;q&lt;/code&gt; における &lt;code&gt;[p,p+n)&lt;/code&gt; なるように &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; 真であります</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 以上の最小の2のべき乗、または結果が &lt;code&gt;T&lt;/code&gt; で表現できない場合は未指定の値。</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">ソケットが接続されていない</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">最大マンチルールの唯一の例外は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">メッセージのソースは実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">スパンは静的範囲（つまり、 &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ）でなければならず、 &lt;code&gt;I&lt;/code&gt; は &lt;code&gt;[0, N)&lt;/code&gt; 範囲の整数値でなければなりません。これは、 &lt;code&gt;operator[]&lt;/code&gt; ではなく、コンパイル時に適用されます。</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">特別なパス名のドット（ &lt;code&gt;&quot;.&quot;&lt;/code&gt; ）は、その親ディレクトリへのハードリンクです。特別なパス名のドットドット &lt;code&gt;&quot;..&quot;&lt;/code&gt; は、その親の親であるディレクトリへのハードリンクです。</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">特殊なパス名のdotとdot-dotはスキップされます。</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">サイズゼロの特別な無名ビットフィールドは、パディングを強制的に分割することができる。これは、次のビットフィールドがその割り当て単位の先頭から始まることを指定する。</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">特殊化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;に&lt;/a&gt;は、C ++ 14まで &lt;code&gt;emplace()&lt;/code&gt; メンバーがありませんでした。</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">特殊化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;に&lt;/a&gt;は、C ++ 14まで &lt;code&gt;emplace_back()&lt;/code&gt; メンバーがありませんでした。</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">特殊化 &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; は、パブリックで明確なベースがあります。</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">特殊化 &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; は、公開された明確なベースがあります。</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">特殊化 &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; は、 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; が有効な場合に有効になり（ &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）、それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; が有効になっている場合、特殊化 &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; が有効になります（ &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）。それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; すべての特殊化が有効な場合、特殊化 &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; が有効になります（ &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 参照）。それ以外の場合は無効になります。</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">専門は &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; 、 &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; 、および &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; です&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt;表現し、操作するための&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;複素数が&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">リリースと消費の順序の仕様は改訂中であり、 &lt;code&gt;memory_order_consume&lt;/code&gt; の使用は一時的にお勧めできません。</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">指定された非タイプ引数は、対応する非タイプテンプレートパラメータのタイプと一致するか、それらに&lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;変換可能で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">指定されたテンプレート引数は、種類的にはテンプレートパラメータと一致していなければなりません(すなわち、typeの場合はtype、nontypeの場合はnontype、templateの場合はtemplate)。パラメータの数よりも多くの引数を持つことはできません(1つのパラメータがパラメータパックでない限り、その場合はパックではないパラメータごとに引数を持たなければなりません)。</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">標準の32ビットIEEE 754浮動小数点型には、24ビットの小数部（23ビットが書き込まれ、1つが暗示される）があるため、7桁の10進数を表すことができる（ &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; は7.22）。ただし、相対的な丸め誤差は不均一であり、7桁の10進数字の一部の浮動小数点値は、32ビット浮動小数点への変換および &lt;code&gt;8.589974e9&lt;/code&gt; 以降の変換を存続させません。最小の正の例は &lt;code&gt;8.589973e9&lt;/code&gt; であり、これはラウンドトリップ後に8.589974e9になります。これらの丸め誤差は表現で1ビットを超えることはできず、 &lt;code&gt;digits10&lt;/code&gt; は &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; として計算されます。これは6.92です。切り捨てると、値は6になります。</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準Cストリームは、 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準のC ++ストリームは次のとおりです &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 、std :: cerr、 &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">標準のコンテナ &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; は、これらの要件を満たしています。デフォルトでは、特定のスタッククラスのインスタンス化にコンテナクラスが指定されていない場合、標準のコンテナ &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">この標準は、C ++ 11以降で導入されたC ++言語およびライブラリ機能に対応する一連の&lt;a href=&quot;preprocessor/replace&quot;&gt;プリプロセッサマクロを&lt;/a&gt;定義しています。それらは、前述の機能の存在を検出するためのシンプルでポータブルな方法として意図されています。</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">標準では、I / Oが行われる前に呼び出される &lt;code&gt;setbuf(0, 0)&lt;/code&gt; バッファリングされていない出力を設定する必要があることを除いて、この関数の動作を定義していません。</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">標準では、メインスレッドと &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; によって開始されたスレッドが同時に進行することを保証することを推奨していますが、これは必須ではありません。</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準エラー状態 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; は、通常、入力ではなく結果が範囲外であり、 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; に密接に関連している状態を示します。</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">標準自体は優先順位のレベルを指定していません。それらは文法から派生したものです。</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリは、関数テンプレート&lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;を定義して、イテレータのペアと値を取得します。このオーバーロードは、標準&lt;a href=&quot;../../algorithm&quot;&gt;アルゴリズムの&lt;/a&gt; 1つです。</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリものオーバーロード定義 &lt;code&gt;std::remove&lt;/code&gt; 取る &lt;code&gt;const char*&lt;/code&gt; 削除ファイルを使用し、：&lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準ライブラリは、事前定義された&lt;a href=&quot;../utility/functional&quot;&gt;関数オブジェクトテンプレートの&lt;/a&gt;ほか、新しいテンプレートを作成するメソッドも提供します（ &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">標準ライブラリコンポーネント &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; 使用すると、コンパイル時に評価される条件に基づいて特定のオーバーロードを有効または無効にするために、置換の失敗を作成できます。</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">標準ライブラリコンポーネント &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; は、SFINAEアプリケーションを簡略化する別のユーティリティメタ関数です。</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているドメインエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::domain_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">標準ライブラリコンポーネントはこの例外をスローしません（数学関数は、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているアンダーフローエラーを報告します）。ただし、サードパーティのライブラリはこれを使用します。例えば、&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.mathは&lt;/a&gt;スロー &lt;code&gt;std::underflow_error&lt;/code&gt; 場合 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 有効になっている（デフォルト設定）。</target>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリでは、2つの重要な要素、 &lt;code&gt;std::suspend_always&lt;/code&gt; と &lt;code&gt;std::suspend_never&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">nothrowバージョン(5-8)の標準ライブラリ実装は、対応するthrowingバージョン(1-4)を直接呼び出します。投げ配列バージョン(2,4)の標準ライブラリ実装は、対応する単一オブジェクトバージョン(1,3)を直接呼び出す。このように、すべての割り当てを処理するためには、throwing単一オブジェクト割り当て関数を置き換えるだけで十分です。</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">nothrowバージョン(9,10)の標準ライブラリ実装は、対応するthrowingバージョン(1,2)を直接呼び出します。サイズを考慮した解放関数(5-8)の標準ライブラリ実装は,対応するサイズを考慮しない解放関数(1-4)を直接呼び出す.サイズを考慮しない配列フォーム(2,4)の標準ライブラリ実装は、対応する単一オブジェクトフォーム(1,3)を直接呼び出します。</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">演算子の削除の標準ライブラリ配置形式（13、14）は置き換えることができず、配置の新しい式が &lt;code&gt;::new&lt;/code&gt; 構文を使用しなかった場合にのみカスタマイズできます。これには、クラス固有の配置の削除（25、26）を一致する署名： &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; または &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;std::bit_and&lt;/code&gt; 特殊化を提供します &lt;code&gt;T&lt;/code&gt; が指定されていない場合は、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_not&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_or&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::bit_xor&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::divides&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::equal_to&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が指定されていない場合、標準ライブラリは &lt;code&gt;std::greater&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::greater_equal&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::less&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::less_equal&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;std::logical_and&lt;/code&gt; 特殊化を提供します &lt;code&gt;T&lt;/code&gt; が指定されていない場合は、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::logical_not&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::logical_or&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::minus&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が指定されていない場合、標準ライブラリは &lt;code&gt;std::modulus&lt;/code&gt; 特殊化を提供します。これにより、パラメータの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::multiplies&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::negate&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::not_equal_to&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が指定されていない場合、標準ライブラリは &lt;code&gt;std::owner_less&lt;/code&gt; 特殊化を提供します。この場合、パラメーターの型は引数から推定されます（それぞれの引数は &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; でなければなりません）。</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;T&lt;/code&gt; が指定されていない場合に &lt;code&gt;std::plus&lt;/code&gt; 特殊化を提供します。これにより、パラメーターの型と戻り値の型が推定されます。</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">標準ライブラリは、タイプ &lt;code&gt;bool&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; 特殊化を提供します。これは、スペース効率のために最適化される場合があります。</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">標準ライブラリは、返される値を取得したり、非同期タスク(別のスレッドで起動された関数など)によってスローされる例外をキャッチしたりする機能を提供しています。これらの値は</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">標準ライブラリは、次のタイプの &lt;code&gt;std::atomic&lt;/code&gt; テンプレートを部分的に特殊化し、プライマリテンプレートにはない追加のプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">標準ライブラリは、すべてのポインタ型に対して &lt;code&gt;std::atomic_ref&lt;/code&gt; テンプレートの部分的な特殊化を提供します。すべてのアトミック型に提供される演算に加えて、これらの特殊化はさらに、&lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;などのポインター型に適したアトミック算術演算をサポートします。</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">標準ライブラリには、以下のようなサーチャーが用意されています。</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">算術型の別名である標準ライブラリ型（ &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; ）も、 &lt;code&gt;std::numeric_limits&lt;/code&gt; 型の特性で調べることができます。</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリの非割り当ての演算子new（9-10）の配置形式は置き換えられず、配置new-expressionが &lt;code&gt;::new&lt;/code&gt; 構文を使用しなかった場合にのみカスタマイズできます。クラス固有の配置new（19、 20）署名が一致する場合： &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; または &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">標準出力オブジェクト &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; は、デフォルトで &lt;code&gt;unitbuf&lt;/code&gt; ビットが設定されています。</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">規格では、持続時間の測定に&lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt;を使用することを推奨しています。実装が代わりに&lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; &lt;/a&gt;を使用する場合、待機時間もクロック調整の影響を受けやすい場合があります。</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">標準規格では、継続時間を測定するために定常クロックを使用することを推奨しています。実装が代わりにシステムクロックを使用する場合、待ち時間はクロックの調整に敏感になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">標準の符号付き整数型： &lt;code&gt;signed char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、および &lt;code&gt;long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; の標準的な特殊化は、パターン &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt; 返します</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">標準の符号なし整数型： &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、および &lt;code&gt;unsigned long long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">すべての書き込み可能なためのgetエリアの開始、 &lt;code&gt;std::strstreambuf&lt;/code&gt; が提供するインタフェースを介して構築されたオブジェクト &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 、またプット領域の開始です。</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">開始ディレクトリの深さは0、サブディレクトリの深さは1などです。</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">状態 &lt;code&gt;A&lt;/code&gt; は状態含み、 &lt;code&gt;B&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">&lt;code&gt;if constexpr&lt;/code&gt; がとして知られている場合に始まるステートメント</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">分子と分母を表す静的データメンバー &lt;code&gt;nom&lt;/code&gt; と &lt;code&gt;den&lt;/code&gt; は、 &lt;code&gt;Num&lt;/code&gt; と &lt;code&gt;Denom&lt;/code&gt; をそれらの最大公約数で割ることによって計算されます。ただし、 &lt;code&gt;Num&lt;/code&gt; または &lt;code&gt;Denom&lt;/code&gt; が異なる2つの &lt;code&gt;std::ratio&lt;/code&gt; は、同じ有理数を表している場合でも（リダクション後）異なるタイプです。 &lt;code&gt;ratio&lt;/code&gt; タイプは、その介し最低条件に低減することができる &lt;code&gt;type&lt;/code&gt; メンバー： &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; ある &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">エントリで参照されたファイルの状態。</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">保留中の再帰フラグのステータスは、この呼び出しの後に &lt;code&gt;false&lt;/code&gt; である&lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt;で照会できます。&lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt;後に &lt;code&gt;true&lt;/code&gt; にリセットされ、その初期値も &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">パスによって識別されるファイル名のステム (すなわち、最終的な拡張子のないファイル名)。</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">ストレージクラス指定子は、名前の&lt;a href=&quot;declarations&quot;&gt;宣言構文&lt;/a&gt;のdecl-specifier-seqの一部です。名前の&lt;a href=&quot;scope&quot;&gt;スコープ&lt;/a&gt;とともに、名前の2つの独立したプロパティを制御します。</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">デックのストレージは、必要に応じて自動的に拡張および縮小されます。両端キューの拡張は、既存の要素を新しいメモリ位置にコピーする必要がないため、 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 拡張よりも安価です。一方、両端キューは通常、最小限のメモリコストが大きくなります。要素を1つだけ保持する両端キューは、その完全な内部配列を割り当てる必要があります（たとえば、64ビットlibstdc ++ではオブジェクトサイズの8倍、64ビットlibc ++ではオブジェクトサイズの16倍または4096バイトのいずれか大きい方）。</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">ベクトルの保存は自動的に処理され、必要に応じて拡張および縮小されます。将来の成長に対応するためにより多くのメモリが割り当てられるため、通常、ベクトルは静的配列よりも多くのスペースを占有します。このように、要素が挿入されるたびにベクターが再割り当てを行う必要はありませんが、追加のメモリが使い果たされた場合のみです。割り当てられたメモリの総量は、 &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 関数を使用して照会できます。追加のメモリは、 &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; への呼び出しを介してシステムに返すことができます（C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">保存された呼び出し可能なオブジェクトは</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">保存されているdeleterオブジェクト。</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">保存されている期間。</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">保存されているエラーカテゴリ。</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">保存されているエラーコード。</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">保存されているポインタ。</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">保存されている参照。</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">保存されたタスクはすでに呼び出されています。エラーカテゴリは&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; に&lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">保存されたタスクはすでに呼び出されています。エラーカテゴリは &lt;code&gt;promise_already_satisfied&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">ストリームベースのI / Oライブラリは、&lt;a href=&quot;io/manip&quot;&gt;I / Oマニピュレータ&lt;/a&gt;（例： &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; など）を使用して、ストリームの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">ストリームベースの入出力ライブラリは、抽象的な入出力デバイスを中心に構成されています。これらの抽象デバイスにより、同じコードでファイル、メモリストリーム、または任意の操作 (圧縮など)をオンザフライで実行するカスタムアダプタデバイスへの入力出力を処理することができます。</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">streambuf引数がnullポインターの場合、または文字がstreambufに挿入されなかった場合、&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;のstreambufオーバーロード。</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">関数が文字を挿入しない場合、&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;のstreambufオーバーロード。</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">指定された浮動小数点型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">指定された符号付き整数型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">指定された符号なし整数型に変換された文字列。</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">文字列入力関数 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; は、指定された終了文字に到達するのではなく、ストリームの最後に到達することによって完了する場合。</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">文字列ライブラリは、 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; （C ++ 17以降）の型と関数を定義するクラステンプレート &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; も提供します。次の特殊化が定義されています。</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">文字列リテラル。</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">正または負の符号として使用される文字を保持するタイプ &lt;code&gt;string_type&lt;/code&gt; の文字列。</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">元の文字列を照合する代わりに、変換された文字列の辞書式比較を使用できるように変換された文字列。「C」ロケールでは、返される文字列は &lt;code&gt;[low, high)&lt;/code&gt; 正確なコピーです。他のロケールでは、返される文字列の内容は実装定義であり、サイズはかなり長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">string_literal は通常、アセンブリ言語で書かれた短いプログラムで、この宣言が実行されるたびに実行されます。異なる C++コンパイラは、asm 宣言のルールを大きく変えており、周囲の C++コードとの相互作用についても異なる規約を持っています。</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">string_viewリテラル。</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">この構造体は、C スタイルの配列のパフォーマンスとアクセス性を、独自のサイズの把握、代入のサポート、ランダムアクセスイテレータなどの標準コンテナの利点と組み合わせたものです。</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">添え字演算子式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">テンプレート化された&lt;a href=&quot;templates#Templated_entity&quot;&gt;エンティティの&lt;/a&gt;宣言で使用されるrequire-expressionにテンプレート引数を代入すると、その要件に無効なタイプまたは式が形成されたり、それらの要件のセマンティック制約に違反したりする可能性があります。このような場合、requires-expressionは &lt;code&gt;false&lt;/code&gt; と評価され、プログラムが不正な形式になることはありません。置換とセマンティック制約のチェックは字句順に行われ、requires-expressionの結果を決定する条件が検出されると停止します。置換（存在する場合）およびセマンティック制約チェックが成功した場合、requires-expressionは &lt;code&gt;true&lt;/code&gt; と評価されます。</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">要素の合計。</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">戻り値と &lt;code&gt;*iptr&lt;/code&gt; に格納された値の合計により、 &lt;code&gt;x&lt;/code&gt; が得られます（丸めが可能）。</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">提供されたロック &lt;code&gt;lk&lt;/code&gt; は、スレッドが終了するまで保持されます。この関数が呼び出されると、 &lt;code&gt;cond&lt;/code&gt; を待機するためにこれ以上スレッドが同じロックを取得することはできません。あるスレッドがこの条件変数で待機している場合、誤って起動したときにロックを解放して再取得しようとするべきではありません。</target>
        </trans-unit>
        <trans-unit id="e9ad164a9bae7d10fe5fec949515a05485fa2d71" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">提供されたバージョンのヘッダー &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; は、少なくとも関数 &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt; （C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="5b99d0c2b824af433d36c158441c754d3faf4148" translate="yes" xml:space="preserve">
          <source>The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.</source>
          <target state="translated">スワップ関数はコンテナ内のイテレータを無効にしませんが、スワップ領域の終了を示すイテレータを無効にします。</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">同期はスレッド間でのみ確立されます。</target>
        </trans-unit>
        <trans-unit id="af5a157ab893f882387e99debe5b0576aec5458b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;T object();&lt;/code&gt; does not initialize an object; it declares a function that takes no arguments and returns &lt;code&gt;T&lt;/code&gt;. The way to value-initialize a named variable before C++11 was &lt;code&gt;T object = T();&lt;/code&gt;, which value-initializes a temporary and then copy-initializes the object: most compilers &lt;a href=&quot;copy_elision&quot;&gt;optimize out the copy&lt;/a&gt; in this case.</source>
          <target state="translated">構文 &lt;code&gt;T object();&lt;/code&gt; オブジェクトを初期化しません。引数を取らず &lt;code&gt;T&lt;/code&gt; を返す関数を宣言します。C ++ 11の前に名前付き変数を値初期化する方法は &lt;code&gt;T object = T();&lt;/code&gt; 、一時的に値を初期化してからオブジェクトをコピーで初期化します。この場合&lt;a href=&quot;copy_elision&quot;&gt;、&lt;/a&gt;ほとんどのコンパイラはコピーを最適化します。</target>
        </trans-unit>
        <trans-unit id="ae224bb840d8d7b9d78b650bc1b03492b672c0b6" translate="yes" xml:space="preserve">
          <source>The syntax forms (3,4) are known as designated initializers: each designator must name a direct non-static data members of T, and all designators used in the expression must appear in the same order as the data members of T.</source>
          <target state="translated">構文形式(3,4)は指定されたイニシャライザとして知られています:各デジグネータはTの直接の非静的データメンバを指定しなければならず、式中で使用されるすべてのデジグネータはTのデータメンバと同じ順序で出現しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f00bfbaecf20babfadbc5e22b52d48a548c5a848" translate="yes" xml:space="preserve">
          <source>The syntax of</source>
          <target state="translated">の構文は</target>
        </trans-unit>
        <trans-unit id="6f89d606c1975f38aa5544527e8e97e16b6bb96a" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a &lt;code&gt;(&lt;/code&gt; as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching &lt;code&gt;)&lt;/code&gt; token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">関数のようなマクロ呼び出しの構文は、関数呼び出しの構文に似ています：マクロ名の各インスタンスの後に &lt;code&gt;(&lt;/code&gt; が続くので、次の前処理トークンは、置換リストによって置き換えられるトークンのシーケンスを導入します。シーケンス一致する &lt;code&gt;)&lt;/code&gt; トークンで終了し、間にある一致する左右の括弧のペアをスキップします。</target>
        </trans-unit>
        <trans-unit id="9bcf66af5c16c1977a2766c06868ed208b549d02" translate="yes" xml:space="preserve">
          <source>The syntax of a user-defined deduction guide is the syntax of a function declaration with a trailing return type, except that it uses the name of a class template as the function name:</source>
          <target state="translated">ユーザー定義の推論ガイドの構文は、クラス・テンプレートの名前を関数名として使用することを除いて、末尾に戻り値の型を持つ関数宣言の構文です。</target>
        </trans-unit>
        <trans-unit id="de7f5913c9173da622b172081363583fac269c9b" translate="yes" xml:space="preserve">
          <source>The syntax of an individual capture in captures is.</source>
          <target state="translated">キャプチャにおける個別キャプチャの構文は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="702f4bc2e64078809bb1b5388513237231aab2e6" translate="yes" xml:space="preserve">
          <source>The system-supplied locales normally do not collate two strings as equivalent (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; does not return &lt;code&gt;​0​&lt;/code&gt;) if &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt;&lt;code&gt;basic_string::operator==&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, but a user-installed &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet may provide different collation rules, for example, it may treat strings as equivalent if they have the same Unicode normalized form.</source>
          <target state="translated">システム提供ロケールが正常に同等にコレートない2つの文字列を行う（ &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 戻らない &lt;code&gt;​0​&lt;/code&gt; ）場合&lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt; &lt;code&gt;basic_string::operator==&lt;/code&gt; &lt;/a&gt;返し &lt;code&gt;false&lt;/code&gt; が、ユーザーインストール &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ファセットは異なる照合規則を提供することができ、たとえば、Unicodeの正規化された形式が同じである場合、文字列は同等として扱われます。</target>
        </trans-unit>
        <trans-unit id="48237f3ec26215b3606e67c0e6d68687b01822f6" translate="yes" xml:space="preserve">
          <source>The target of the symlink (which may not necessarily exist).</source>
          <target state="translated">シンボリックリンクのターゲット(必ずしも存在しない場合もあります)。</target>
        </trans-unit>
        <trans-unit id="676256b3d34d8447f5998ce9c718f12a262b3700" translate="yes" xml:space="preserve">
          <source>The template argument that can be used with a non-type template parameter can be any &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the type of the template parameter.</source>
          <target state="translated">型ではないテンプレートパラメーターで使用できるテンプレート引数は、テンプレートパラメーターの型の&lt;a href=&quot;constant_expression&quot;&gt;変換された定数式&lt;/a&gt;にすることができます。</target>
        </trans-unit>
        <trans-unit id="50cbc99825f7a6c9a124b9687858d33d44b2131c" translate="yes" xml:space="preserve">
          <source>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.</source>
          <target state="translated">テンプレートはユーザ定義のイテレータに特化することができるので、型が通常の型定義を提供していなくても、イテレータに関する情報を取得することができます。</target>
        </trans-unit>
        <trans-unit id="557201976e8a00a9ece65cd2feec4760fa0f5cd2" translate="yes" xml:space="preserve">
          <source>The template function &lt;code&gt;async&lt;/code&gt; runs the function &lt;code&gt;f&lt;/code&gt; asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; that will eventually hold the result of that function call.</source>
          <target state="translated">テンプレート関数 &lt;code&gt;async&lt;/code&gt; は、関数 &lt;code&gt;f&lt;/code&gt; を非同期的に（スレッドプールの一部である別のスレッドで実行される可能性があります）実行し、最終的にその関数呼び出しの結果を保持する &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="eff5e7944f6337f3549b2f87230ec73fcb57ba24" translate="yes" xml:space="preserve">
          <source>The template may be specialized for any user-defined &lt;code&gt;T&lt;/code&gt; type: the specialization must satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">テンプレートは、ユーザー定義の &lt;code&gt;T&lt;/code&gt; タイプに特化することができます。この特化は、&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;を満たして</target>
        </trans-unit>
        <trans-unit id="57234bb7a67c620ea3f65bd79181da8581f11c93" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;TimeZonePtr&lt;/code&gt; allows users to supply their own time zone pointer types and further customize the behavior of &lt;code&gt;zoned_time&lt;/code&gt; via &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt;. Custom time zone types need not support all the operations supported by &lt;code&gt;std::chrono::time_zone&lt;/code&gt;, only those used by the functions actually called on the &lt;code&gt;zoned_time&lt;/code&gt;.</source>
          <target state="translated">テンプレートパラメータ &lt;code&gt;TimeZonePtr&lt;/code&gt; を使用すると、ユーザーは独自のタイムゾーンポインタタイプを &lt;code&gt;zoned_time&lt;/code&gt; し、 &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt; 介してzoned_timeの動作をさらにカスタマイズできます。カスタムタイムゾーンタイプは、 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; サポートするすべての操作をサポートする必要はなく、実際に &lt;code&gt;zoned_time&lt;/code&gt; で呼び出される関数が使用する操作のみをサポートします。</target>
        </trans-unit>
        <trans-unit id="976e95956188ddd1cc5dc013bb47e40cd53b4619" translate="yes" xml:space="preserve">
          <source>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</source>
          <target state="translated">部分特殊化のメンバのテンプレート・パラメータ・リストとテンプレート引数リストは、部分特殊化のパラメータ・リストと引数リストと一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="35c19ab099f7c63eddf13b79738caebc5d6c5994" translate="yes" xml:space="preserve">
          <source>The template parameter list may be followed by an optional &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;requires-clause&lt;/a&gt; that specifies the &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; on the template arguments.</source>
          <target state="translated">テンプレートパラメータリストの後には、テンプレート引数&lt;a href=&quot;constraints&quot;&gt;に対する制約&lt;/a&gt;を指定するオプションの&lt;a href=&quot;constraints#Requires_clauses&quot;&gt;require-clause&lt;/a&gt;を続けることができます。</target>
        </trans-unit>
        <trans-unit id="0e09d82796b1385db8c4e7f7eb0aae7cb58e1066" translate="yes" xml:space="preserve">
          <source>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</source>
          <target state="translated">テンプレートテンプレートパラメータのテンプレートパラメータリストは、それ自身のデフォルト引数を持つことができ、それはテンプレートテンプレートパラメータ自体がスコープ内にある場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="9b6ab43de318de05ac5e805e82ee83900637e335" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the identifiers of threads.</source>
          <target state="translated">テンプレートの専門 &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; クラスは、ユーザーがスレッドの識別子のハッシュを得ることができます。</target>
        </trans-unit>
        <trans-unit id="1617c98734849159498d6d58c8ee6130545cbbf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5b98ae6aa533d3d486ad6a1f3c3dd5a2a2cc3c3" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="189f220de4b5df21be91fb36e6e09506d95caaf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fa82fede24ddf383b749f64c40120c7a6b969fc" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの専門 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e08e96dcabc0ff66b712bd52aab0a0c10bbb4f5" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c9f3d1ec6cfcd95caae7ac3bda8cf8e03255245" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; ユーザーが型のオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d968cfa6e1f3e875e46aac917073ba195240e6bb" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 、ユーザーがタイプのオブジェクトのハッシュ得ることを可能にする &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce7952ddebf3c0d01e620facea4a820fd43fa101" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the values contained in &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="translated">テンプレートの特殊化 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のため &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; クラスのユーザーが中に含まれる値のハッシュ得ることを可能にする &lt;code&gt;optional&lt;/code&gt; オブジェクトを。</target>
        </trans-unit>
        <trans-unit id="db5007b65d07bfed77b8824218281a413afda965" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; template allows users to obtain hashes of &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; テンプレート用の &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のテンプレート特殊化により、ユーザーは &lt;code&gt;variant&lt;/code&gt; オブジェクトのハッシュを取得できます。</target>
        </trans-unit>
        <trans-unit id="8ddcabf8bbccc8b0c948a37b70ba7a9f9c022693" translate="yes" xml:space="preserve">
          <source>The template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various string classes allow users to obtain hashes of strings.</source>
          <target state="translated">さまざまな文字列クラスの &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; のテンプレート特殊化により、ユーザーは文字列のハッシュを取得できます。</target>
        </trans-unit>
        <trans-unit id="584921a66a2cf4fe71de6a59a91614782dd86242" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator in the specialization for arrays, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; behaves the same as in the primary template, except that will only participate in overload resolution if all of the following is true:</source>
          <target state="translated">配列の特殊化におけるこの代入演算子のテンプレートバージョン &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; は、次のすべてがtrueの場合にのみオーバーロード解決に参加することを除いて、プライマリテンプレートと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="0ac5be2688655da010f5c804e64763bf5f3459f9" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not an array type and &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; is implicitly convertible to &lt;code&gt;pointer&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;(since C++17).</source>
          <target state="translated">この代入演算子のテンプレートバージョンは、 &lt;code&gt;U&lt;/code&gt; が配列型ではなく、 &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; が暗黙的に &lt;code&gt;pointer&lt;/code&gt; 変換可能であり、 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します（ C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="22030dbd3e1d3908354d7549e8f30d9f71beae72" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generalizes how sequences of characters are manipulated and stored. String creation, manipulation, and destruction are all handled by a convenient set of class methods and related functions.</source>
          <target state="translated">テンプレート化されたクラス &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; は、文字のシーケンスがどのように操作および格納されるかを一般化します。文字列の作成、操作、破棄はすべて、便利な一連のクラスメソッドと関連関数によって処理されます。</target>
        </trans-unit>
        <trans-unit id="ae2a3669d2ccc3c953612c7002da0c5821d0cf01" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; provides a lightweight object that offers read-only access to a string or a part of a string using an interface similar to the interface of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テンプレートクラス &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 申し出が読み取り専用ことを文字列またはのインタフェースと同様のインタフェース使用して、文字列の一部にアクセスできる軽量のオブジェクト提供 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5938eb91acf69026cdeecae1d1a114be0e7c8cbb" translate="yes" xml:space="preserve">
          <source>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).</source>
          <target state="translated">テンポラリオブジェクトは、それぞれ関数の引数または戻り値から構築され、関数のパラメータまたは戻り値オブジェクトは、テンポラリをコピーするために削除されていないtrivialコンストラクタを使用するかのように初期化されます(そのコンストラクタがアクセスできないか、またはオブジェクトのコピーまたは移動を実行するためにオーバーロード解決によって選択されない場合であっても)。</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; からの終端のnull文字は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="0b502a26934eaa1380b44846902030ef133c5174" translate="yes" xml:space="preserve">
          <source>The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">終端のnull文字は文字列の一部と見なされ、 &lt;code&gt;'\0'&lt;/code&gt; 検索すると見つかります。</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; からの終端のnullワイド文字は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="f64c2cf450c071f73e284e57290f6f2917e30baf" translate="yes" xml:space="preserve">
          <source>The test &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; in the exposition code above makes sure that &lt;code&gt;weak_this&lt;/code&gt; is not reassigned if it already indicates an owner. This test is required as of C++17.</source>
          <target state="translated">上記の説明コードのテスト &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; は、所有者をすでに示している場合、 &lt;code&gt;weak_this&lt;/code&gt; が再割り当てされないようにします。このテストはC ++ 17以降で必要です。</target>
        </trans-unit>
        <trans-unit id="a76ffdb1119a59ee47d50b27acec60df78d37530" translate="yes" xml:space="preserve">
          <source>The textual representation is written with &lt;code&gt;os.fmtflags&lt;/code&gt; set to &lt;code&gt;ios_base::dec&lt;/code&gt;|&lt;code&gt;ios_base::left&lt;/code&gt; and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces.</source>
          <target state="translated">テキスト表現は、 &lt;code&gt;os.fmtflags&lt;/code&gt; を &lt;code&gt;ios_base::dec&lt;/code&gt; 設定して記述されます。 &lt;code&gt;ios_base::left&lt;/code&gt; および空白文字に設定された塗りつぶし文字。エンジンの内部状態のテキスト表現は、スペースで区切られた一連の10進数です。</target>
        </trans-unit>
        <trans-unit id="a79d1b4a44870cfcd4b53d3f95a0c8fcc074b16b" translate="yes" xml:space="preserve">
          <source>The textual representation of &lt;code&gt;A&lt;/code&gt; includes the textual representation of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">テキスト表現 &lt;code&gt;A&lt;/code&gt; は、のテキスト表現を含む &lt;code&gt;B&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="484f772cf54bb66a16db5954b6b4e3c3d93ea751" translate="yes" xml:space="preserve">
          <source>The thread that intends to modify the variable has to.</source>
          <target state="translated">変数を変更しようとするスレッドは、変更しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e07534c510b6011cf58e1ef843a07565960e50d4" translate="yes" xml:space="preserve">
          <source>The three-way comparison operator expressions have the form.</source>
          <target state="translated">三元比較演算子の式は形式を持っています。</target>
        </trans-unit>
        <trans-unit id="ab243e4025d54ef42cc354407fff2484190465e4" translate="yes" xml:space="preserve">
          <source>The throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; is not guaranteed to be matched by a pointer catch clause, because the exception object type may be &lt;code&gt;int&lt;/code&gt;, but &lt;code&gt;throw nullptr;&lt;/code&gt; is assuredly matched by any pointer or pointer-to-member catch clause.</source>
          <target state="translated">throw式 &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; 例外オブジェクトタイプは &lt;code&gt;int&lt;/code&gt; である可能性がありますが、 &lt;code&gt;throw nullptr;&lt;/code&gt; するため、ポインタキャッチ句による一致は保証されません。ポインターまたはメンバーへのポインターキャッチ節によって確実に一致します。</target>
        </trans-unit>
        <trans-unit id="7ac8ab79b96ed80e6fe4f38b7019eb38273067c1" translate="yes" xml:space="preserve">
          <source>The throw-expression is classified as &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; of type &lt;code&gt;void&lt;/code&gt;. Like any other expression, it may be a sub-expression in another expression, most commonly in the &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;:</source>
          <target state="translated">throw式は、 &lt;code&gt;void&lt;/code&gt; 型の&lt;a href=&quot;value_category&quot;&gt;prvalue式&lt;/a&gt;として分類されます。他の式と同様に、それは別の式のサブ式である可能性があり、最も一般的には&lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;条件演算子&lt;/a&gt;です：</target>
        </trans-unit>
        <trans-unit id="f868d34253cbb949d0014de0f9071a9627d84ee5" translate="yes" xml:space="preserve">
          <source>The throwing overload is additionally specified to throw &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;status(p)&lt;/code&gt; would throw.</source>
          <target state="translated">スローするオーバーロードは、 &lt;code&gt;status(p)&lt;/code&gt; がスローする場合に &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; をスローするように追加で指定されます。</target>
        </trans-unit>
        <trans-unit id="fc934bec30518ea798c5b7ac6343fa0fedd9880c" translate="yes" xml:space="preserve">
          <source>The tick period of the clock in seconds.</source>
          <target state="translated">時計の周期を秒単位で表示します。</target>
        </trans-unit>
        <trans-unit id="2af4361db95a4cd97928b9e845816898c3e9820b" translate="yes" xml:space="preserve">
          <source>The tied stream, or a null pointer if there was no tied stream.</source>
          <target state="translated">紐付けられたストリーム、または紐付けられたストリームがなかった場合はNULLポインタ。</target>
        </trans-unit>
        <trans-unit id="a5636311e3a8dbe661c517df9ff905b4bc0cff87" translate="yes" xml:space="preserve">
          <source>The time input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a time value according to the given format string.</source>
          <target state="translated">時間入力マニピュレータ &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; （技術的には、&lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt;が呼び出す）。指定されたフォーマット文字列に従って入力を時間値として明確に解析できない場合。</target>
        </trans-unit>
        <trans-unit id="9fa1c3ac8a91c2dbb258d7d0b1ca35724a76b047" translate="yes" xml:space="preserve">
          <source>The timeout has expired</source>
          <target state="translated">タイムアウトが切れました</target>
        </trans-unit>
        <trans-unit id="cda93e07e16d4fa1f6f842ae631aef263d983dc5" translate="yes" xml:space="preserve">
          <source>The top-level scope of a translation unit (&quot;file scope&quot; or &quot;global scope&quot;) is also a namespace and is properly called &quot;global namespace scope&quot;. The potential scope of any entity declared in the global namespace scope begins at the declaration and continues to the end of the translation unit.</source>
          <target state="translated">翻訳単位の最上位のスコープ(「ファイルスコープ」または「グローバルスコープ」)は、名前空間でもあり、正しくは「グローバル名前空間スコープ」と呼ばれます。グローバル名前空間スコープで宣言された任意のエンティティの潜在的なスコープは、宣言時に始まり、翻訳ユニットの最後まで続きます。</target>
        </trans-unit>
        <trans-unit id="f4b95d9b7d4331d266dae2fa32fe8fccb817c35a" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_copy_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; type, must be an lvalue of type &lt;code&gt;T&lt;/code&gt;) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, which is required of all &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; types.</source>
          <target state="translated">形質 &lt;code&gt;std::is_copy_assignable&lt;/code&gt; 未満厳しい&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;それは割り当ての結果の種類をチェックしない（そのため、ため&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;型、型の左辺値でなければならない &lt;code&gt;T&lt;/code&gt; ）と引数ことセマンティック要件をチェックしません式は変更されません。また、 &lt;code&gt;T&lt;/code&gt; がすべての&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;型に必要な&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignableを&lt;/a&gt;満たすかどうかもチェックしません。</target>
        </trans-unit>
        <trans-unit id="31f748256061c85c5babfc77d3f3bd56ed39666b" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_move_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; type, must be &lt;code&gt;T&amp;amp;&lt;/code&gt;), nor the semantic requirement that the target's value after the assignment is equivalent to the source's value before the assignment.</source>
          <target state="translated">トレイト &lt;code&gt;std::is_move_assignable&lt;/code&gt; は、割り当ての結果のタイプ（&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;タイプの場合は &lt;code&gt;T&amp;amp;&lt;/code&gt; である必要がある）をチェックしないため、&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;よりも厳密ではありません。また、割り当て後のターゲットの値が等しいというセマンティック要件もありません。割り当て前のソースの値に。</target>
        </trans-unit>
        <trans-unit id="c13322dcd5d602786d0d4da2697757a492c38ddc" translate="yes" xml:space="preserve">
          <source>The transformed type is a publicly accessible nested type named &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">変換された型は、typeという名前のパブリックにアクセス可能なネストされた &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0c6a8d80fefbf063a7c6fc4d41e35477e554e0" translate="yes" xml:space="preserve">
          <source>The transition algorithm of the LCG function is x</source>
          <target state="translated">LCG関数の遷移アルゴリズムはx</target>
        </trans-unit>
        <trans-unit id="ed030a839d21fbb758c903e3966139f3e58ea684" translate="yes" xml:space="preserve">
          <source>The tuple need not be &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, and instead may be anything that supports &lt;code&gt;std::get&lt;/code&gt; and &lt;code&gt;std::tuple_size&lt;/code&gt;; in particular, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">タプルは &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; である必要はなく、代わりに &lt;code&gt;std::get&lt;/code&gt; および &lt;code&gt;std::tuple_size&lt;/code&gt; をサポートするものであれば何でも構いません。特に、 &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="faab3655bae1576862bf3243d78b803053240daa" translate="yes" xml:space="preserve">
          <source>The tuple-like interpretation is always used if &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, even if that would cause the program to be ill-formed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; が完全な型である場合は、タプルのような解釈が常に使用されます。これにより、プログラムが不正な形式になります。</target>
        </trans-unit>
        <trans-unit id="280f7270ad4976a06da0f10d73ed8109ee8c86a2" translate="yes" xml:space="preserve">
          <source>The two overloads are distinct because the types of the parameter &lt;code&gt;func&lt;/code&gt; are distinct (&lt;a href=&quot;../../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">パラメーター &lt;code&gt;func&lt;/code&gt; のタイプが異なるため、2つのオーバーロードは異なります（&lt;a href=&quot;../../language/language_linkage&quot;&gt;言語リンケージ&lt;/a&gt;はそのタイプの一部です）。</target>
        </trans-unit>
        <trans-unit id="ced307005cb72698444581ef51d2ce693acf63e2" translate="yes" xml:space="preserve">
          <source>The two overloads provided by the C++ standard library are distinct because the types of the parameter &lt;code&gt;comp&lt;/code&gt; are distinct (&lt;a href=&quot;../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">C ++標準ライブラリによって提供される2つのオーバーロードは、パラメータ &lt;code&gt;comp&lt;/code&gt; のタイプが異なるため、異なります（&lt;a href=&quot;../language/language_linkage&quot;&gt;言語リンケージ&lt;/a&gt;はそのタイプの一部です）。</target>
        </trans-unit>
        <trans-unit id="7e0c402d18cba21bbc3c62ac427b669b87db8687" translate="yes" xml:space="preserve">
          <source>The two-way comparison operator expressions have the form.</source>
          <target state="translated">双方向比較演算子の式は、形式を持っています。</target>
        </trans-unit>
        <trans-unit id="b32340d0d14dfd5d1c51dde23771404f36595788" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3e4f9ee4f9a6dc679b68e252ddbe4d829628a2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;D&lt;/code&gt; satisfies RandomNumberDistribution if.</source>
          <target state="translated">タイプ &lt;code&gt;D&lt;/code&gt; は、RandomNumberDistribution ifを満たします。</target>
        </trans-unit>
        <trans-unit id="9d9d3aa5279931f61ae09ea879f4c70a82c6ceaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;G&lt;/code&gt; satisfies UniformRandomBitGenerator if.</source>
          <target state="translated">タイプ &lt;code&gt;G&lt;/code&gt; は、UniformRandomBitGeneratorを満たす場合。</target>
        </trans-unit>
        <trans-unit id="c21b37c97960f36e90434bac25ddcd2dc1e68569" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</source>
          <target state="translated">タイプは、 &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dca3e5d709f32f44d0ddfe5eab719ca4892184c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; は&lt;a href=&quot;copyassignable&quot;&gt;CopyAssignableを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="23ab122f56da738cdd552f61aadec9d1cd833ab0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; は&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructibleを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="b6b3d6cdd7d4f3c9acce01cee40f271ece634a18" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">タイプは、 &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252d2ffb66f7d81557faa1f7f4f4ea09867d93b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; を満たし&lt;a href=&quot;destructible&quot;&gt;破壊可能&lt;/a&gt;、と</target>
        </trans-unit>
        <trans-unit id="4b8f1bcfc4815dc189422b13e3981c0b3806ab7c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7e27b1e0bc61deba4ad72e16345b7759b232775" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">タイプは、 &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e98de10f38832410717d032044fe5876aae1620" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</source>
          <target state="translated">タイプは、 &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19b959ec118b4fc4e346a0c4b3066583c69eb391" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">タイプは、 &lt;code&gt;It&lt;/code&gt; を満たす&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e6b1f70b5515f9b7f9ece951c8b0565a4faeae3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies ConstexprIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; はConstexprIterator ifを満たします。</target>
        </trans-unit>
        <trans-unit id="99ec40230a473cc7e644a50a1f568278d332cce3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyBidirectionalIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; はLegacyBidirectionalIteratorを満たす場合。</target>
        </trans-unit>
        <trans-unit id="fb470c2619e1df677c704caef889c4118fc3151e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyContiguousIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; は、LegacyContiguousIteratorを満たす場合。</target>
        </trans-unit>
        <trans-unit id="630cbbc2820c720d8b04165d105e0a9744bea443" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyForwardIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; を満たすLegacyForwardIterator場合。</target>
        </trans-unit>
        <trans-unit id="0ffbcd885e9525a21db6be67dd85f4aff0c605f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyInputIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; はLegacyInputIteratorを満たす場合。</target>
        </trans-unit>
        <trans-unit id="98c67370e8cebdd88c142031ae165afb773d121a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; を満たすLegacyIterator場合。</target>
        </trans-unit>
        <trans-unit id="685b9ef2517672d40d4de466c9757d30ae0a366e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyRandomAccessIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; を満たすLegacyRandomAccessIterator場合。</target>
        </trans-unit>
        <trans-unit id="c0271171a00bcc035de12ccb951df5f4eb58be30" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies some iterator requirements MeowIterator</source>
          <target state="translated">タイプ &lt;code&gt;It&lt;/code&gt; はいくつかのイテレータ要件を満たしていますMeowIterator</target>
        </trans-unit>
        <trans-unit id="3fa432a57da4f847b5c070a3bfc7c01c5763011a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;ForwardIt&lt;/code&gt; のオブジェクトを逆参照してタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f3a1ebcc723e658952997b5498f82af157e85e51" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;OutputIt&lt;/code&gt; のオブジェクトを逆参照してタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="949b21cde2cc2392d063407c9e220c78be2ec5c8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;CopyInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt;, and, given.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はある&lt;strong&gt;CopyInsertable&lt;/strong&gt;容器に &lt;code&gt;X&lt;/code&gt; その &lt;code&gt;value_type&lt;/code&gt; と同一である &lt;code&gt;T&lt;/code&gt; 場合 &lt;code&gt;T&lt;/code&gt; はある&lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;に &lt;code&gt;X&lt;/code&gt; 、及び、所与。</target>
        </trans-unit>
        <trans-unit id="3d96c921cf6324f16eef56dd97bb17fac1318864" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;DefaultInsertable&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、指定された場合、 &lt;code&gt;value_type&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; と同一である&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt; &lt;code&gt;X&lt;/code&gt; への&lt;strong&gt;DefaultInsertable&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="4a2192b55df7721f52fc4a376a8910667373086e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; (whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt;) from the arguments &lt;code&gt;args&lt;/code&gt; if, given.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、&lt;strong&gt;指定&lt;/strong&gt;された場合、引数 &lt;code&gt;args&lt;/code&gt; から&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt; &lt;code&gt;X&lt;/code&gt; （ &lt;code&gt;value_type&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; と同じ）にEmplaceConstructibleです。</target>
        </trans-unit>
        <trans-unit id="5237f2595087683918faff0e0fb827167c77ec98" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;Erasable&lt;/strong&gt; from the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、指定された場合、 &lt;code&gt;value_type&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; と同一である&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt; &lt;code&gt;X&lt;/code&gt; から&lt;strong&gt;消去可能&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7c4f49cd45501a79870e1b3afa64d91ff0308500" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;MoveInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はある&lt;strong&gt;MoveInsertable&lt;/strong&gt;容器に &lt;code&gt;X&lt;/code&gt; その &lt;code&gt;value_type&lt;/code&gt; と同一である &lt;code&gt;T&lt;/code&gt; 与え、場合。</target>
        </trans-unit>
        <trans-unit id="0e41120cbb6ece4723895cfa12eeda9a968c6032" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is not allowed to be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, even if the size or internal structure of &lt;code&gt;T&lt;/code&gt; is never used, as in &lt;code&gt;&amp;amp;x[0]&lt;/code&gt;.</source>
          <target state="translated">型 &lt;code&gt;T&lt;/code&gt; は、であることが許可されていない&lt;a href=&quot;incomplete_type&quot;&gt;不完全な型の&lt;/a&gt;サイズまたは内部構造も、 &lt;code&gt;T&lt;/code&gt; は同様に、使用されない &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94188845ce20ed55f2a876e3342aa84bc7330295" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicateを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="4d4404ddfa538ff7555e67eecb1dbcc3ff5cdc1a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、&lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;、&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;、&lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="0db4b9570ecd95be9606704e9f21eff1149143a0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;moveassignable&quot;&gt;MoveAssignableを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="6647adc652b8dbbc01016470d35eed7d2fe7e630" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructibleを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="4262127f8a223198cec9f54e58d1717c6a50c453" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt; 、かつ</target>
        </trans-unit>
        <trans-unit id="3f046e47e7505811e9555f3b245d7d20697f7a3e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Callable if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はCallable ifを満たします。</target>
        </trans-unit>
        <trans-unit id="49e6eff2866df130bb7fd318296a16096d51e92f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Compare if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はCompare ifを満たします。</target>
        </trans-unit>
        <trans-unit id="66ff21aa578ecf4f62632269d8614fbe18a110bb" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyAssignable if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、CopyAssignable ifを満たします。</target>
        </trans-unit>
        <trans-unit id="0ad2a77779033cb383bdf5ceddef00240ba13b76" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyConstructible if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、CopyConstructible ifを満たします。</target>
        </trans-unit>
        <trans-unit id="2e05ec58d3dab38ca771379d16b2fe5adee88104" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies DefaultConstructible if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はDefaultConstructible ifを満たします。</target>
        </trans-unit>
        <trans-unit id="cc55fbe4fbf6e0f85ba467734b5b915583f84e1b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Destructible if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はDestructible ifを満たします。</target>
        </trans-unit>
        <trans-unit id="dfe96628803d13e4d50a5465ce9ed6a67992a048" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies EqualityComparable if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; は、EqualityComparable ifを満たします。</target>
        </trans-unit>
        <trans-unit id="41ee5c2d1ddb0009a5b5ac10f88ce89d5cc10e9a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies FunctionObject if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はFunctionObject ifを満たします。</target>
        </trans-unit>
        <trans-unit id="3ae67a347ab32c589872346530c83699208f4eaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Hash if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はハッシュを満たす場合。</target>
        </trans-unit>
        <trans-unit id="9d2af4bf93a9ceba9a70379149efdadf03a56bc7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies LessThanComparable if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はLessThanComparable ifを満たします。</target>
        </trans-unit>
        <trans-unit id="52a749029f41bfcab44646101c78f08a559bdcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveAssignable if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はMoveAssignable ifを満たします。</target>
        </trans-unit>
        <trans-unit id="aaf38d3e0ca9bb3163280eb3190656f5f78d0b7e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveConstructible if.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; はMoveConstructible ifを満たします。</target>
        </trans-unit>
        <trans-unit id="3c095863553c4d9f9528e17b876f6565ea71dc1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TC::time_point::clock&lt;/code&gt; meets the TrivialClock requirements, recursively.</source>
          <target state="translated">タイプ &lt;code&gt;TC::time_point::clock&lt;/code&gt; は、再帰的にTrivialClock要件を満たします。</target>
        </trans-unit>
        <trans-unit id="8c5bdf5c0ebdfaea70c628010c98d8c02bdb6a1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; は、タイプ &lt;code&gt;ForwardIt&lt;/code&gt; のオブジェクトを逆参照して、暗黙的に &lt;code&gt;Type1&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを暗黙的に &lt;code&gt;Type2&lt;/code&gt; に変換できるタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="76589c2d20456a54480cd63abef696cc4671a0d0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを暗黙的に &lt;code&gt;Type1&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;ForwardIt&lt;/code&gt; のオブジェクトを逆参照して、暗黙的に &lt;code&gt;Type2&lt;/code&gt; に変換できるタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e15c34b8b5699cfcccd67dddcde261f5330e1e3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを暗黙的に &lt;code&gt;Type1&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt&lt;/code&gt; のオブジェクトを逆参照して、暗黙的に &lt;code&gt;Type2&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトにタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9c7c828977f3aee5181d50399292252dea34b2f7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; は、タイプ &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; オブジェクトを暗黙的に &lt;code&gt;Type1&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt&lt;/code&gt; のオブジェクトを逆参照して、暗黙的に &lt;code&gt;Type2&lt;/code&gt; に変換できるタイプでなければなりません。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; オブジェクトにタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="446f611669a83b2fef5ed0fe51541c392716bba5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Type&lt;/code&gt; は、タイプ &lt;code&gt;InputIt&lt;/code&gt; のオブジェクトが逆参照され、暗黙的に &lt;code&gt;Type&lt;/code&gt; に変換されるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="7a83e5bd1fdfaaf9d85e03162ceb874df7fc25ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type&lt;/code&gt; は、タイプ &lt;code&gt;InputIt&lt;/code&gt; のオブジェクトが逆参照され、暗黙的に &lt;code&gt;Type&lt;/code&gt; に変換されるようなタイプでなければなりません。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;OutputIt&lt;/code&gt; のオブジェクトを逆参照してタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="3f2ee2c7e39e16c2fc94f6e2cd419b938a6ba925" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type&lt;/code&gt; は、タイプ &lt;code&gt;double&lt;/code&gt; のオブジェクトが間接参照され、暗黙的に &lt;code&gt;Type&lt;/code&gt; に変換されるようなタイプでなければなりません。型 &lt;code&gt;Ret&lt;/code&gt; は、型 &lt;code&gt;double&lt;/code&gt; のオブジェクトが逆参照され、型 &lt;code&gt;Ret&lt;/code&gt; の値を割り当てられるようなものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b435ca7efbcb7d3a69a4c425c8166ae1ecf9b3b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は&lt;a href=&quot;container&quot;&gt;コンテナを&lt;/a&gt;満たします</target>
        </trans-unit>
        <trans-unit id="51c4cd0302a38d9ca2d378e53146319f03ed2267" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;, and</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は&lt;a href=&quot;container&quot;&gt;Containerを&lt;/a&gt;満たし、かつ</target>
        </trans-unit>
        <trans-unit id="6607d21d863fd1139823f255f3616f78582f1b99" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は&lt;a href=&quot;iterator&quot;&gt;LegacyIteratorを&lt;/a&gt;満たします</target>
        </trans-unit>
        <trans-unit id="fd2220d4e7d2be0a6e2436dc20ed5fc81f925717" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies ContiguousContainer if.</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は、ContiguousContainerを満たす場合。</target>
        </trans-unit>
        <trans-unit id="9c59f17268ae0799c6c9ad4a2f510730b7974007" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies LegacyOutputIterator if.</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は、LegacyOutputIteratorを満たす場合。</target>
        </trans-unit>
        <trans-unit id="4ce304e60343f172de9a358f8aec0594d119616e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies SequenceContainer if.</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は、SequenceContainerを満たす場合。</target>
        </trans-unit>
        <trans-unit id="0b0a4238d5b55da548fec0c52f2f145ef62aca2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; supports &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; は&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorsを&lt;/a&gt;サポートします</target>
        </trans-unit>
        <trans-unit id="9c91c4098ab4ce6057b1eb103c2691ca5d989b78" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; must be exactly</source>
          <target state="translated">タイプ &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; は正確でなければなりません</target>
        </trans-unit>
        <trans-unit id="3d90dab02f7f3b6e43e81a90b17cf46259c35fe4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with a BaseCharacteristic of &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; ある&lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;のBaseCharacteristicと &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83883f03d07c1a12ee9dfb5e67e0fc6f4a49f177" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::partial_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">タイプ &lt;code&gt;std::partial_ordering&lt;/code&gt; は4つの有効な値があり、そのタイプのconst静的データメンバーとして実装されています。</target>
        </trans-unit>
        <trans-unit id="baf068b5f9f0a2f3a687379dab87c44a84ac79f2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamoff&lt;/code&gt; is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;std::streamoff&lt;/code&gt; は、オペレーティングシステムがサポートする可能な最大ファイルサイズを表すのに十分なサイズの符号付き整数型です。通常、これは &lt;code&gt;long long&lt;/code&gt; からlongへのtypedef です。</target>
        </trans-unit>
        <trans-unit id="081a86b87857472711ceb628824320cbad10918c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamsize&lt;/code&gt; is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, similar to the POSIX type &lt;code&gt;ssize_t&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;std::streamsize&lt;/code&gt; は、I / O操作で転送される文字数またはI / Oバッファーのサイズを表すために使用される符号付き整数型です。これは、POSIXタイプ &lt;code&gt;ssize_t&lt;/code&gt; と同様に、 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 署名済みの対応物として使用されます。</target>
        </trans-unit>
        <trans-unit id="35bd4cec907f3b6ac35655e3dc99fe6dc74b2c63" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_equality&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">タイプ &lt;code&gt;std::strong_equality&lt;/code&gt; は4つの有効な値があり、そのタイプのconst静的データメンバーとして実装されています。</target>
        </trans-unit>
        <trans-unit id="d1fa9bb7b57f78a76b739de735267fbd796b77b7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">タイプ &lt;code&gt;std::strong_ordering&lt;/code&gt; は4つの有効な値があり、そのタイプのconst静的データメンバーとして実装されています。</target>
        </trans-unit>
        <trans-unit id="caaff90770bed5d2d4f0c217a33a582a915365ac" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_equality&lt;/code&gt; has only two valid values, implemented as const static data members of its type: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; and &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt;:</source>
          <target state="translated">タイプ &lt;code&gt;std::weak_equality&lt;/code&gt; は2つの有効な値のみがあり、そのタイプのconst静的データメンバーとして実装されています： &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; および &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b1a20430a83aa89500e66ebd1c9900c5d380b9b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_ordering&lt;/code&gt; has three valid values, implemented as const static data members of its type:</source>
          <target state="translated">タイプ &lt;code&gt;std::weak_ordering&lt;/code&gt; は3つの有効な値があり、そのタイプのconst静的データメンバーとして実装されています。</target>
        </trans-unit>
        <trans-unit id="eea5d0d3527e4ae7b88635106c278af003375133" translate="yes" xml:space="preserve">
          <source>The type T may be an incomplete type.</source>
          <target state="translated">T型は不完全型である可能性があります。</target>
        </trans-unit>
        <trans-unit id="47e3c39ad9f26d80f148e942aab053b6361ba66e" translate="yes" xml:space="preserve">
          <source>The type allows subnormal values</source>
          <target state="translated">この型は正規値以下の値を許可します。</target>
        </trans-unit>
        <trans-unit id="89d3d7da193a1958b43f17239e6e96abc49dd3f5" translate="yes" xml:space="preserve">
          <source>The type and value category of the conditional expression &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; are determined according to the following rules:</source>
          <target state="translated">条件式 &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; のタイプと値のカテゴリー？E2：E3は、次の規則に従って決定されます。</target>
        </trans-unit>
        <trans-unit id="b0032656c660ab91cfc9f1912ec36a11287348d7" translate="yes" xml:space="preserve">
          <source>The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if &lt;code&gt;noexcept&lt;/code&gt; support is added to &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; in a later standard).</source>
          <target state="translated">これらの演繹ガイドによって推定される型は、後の標準リビジョンで変更される可能性があります（特に、後の標準で &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;noexcept&lt;/code&gt; サポートが追加された場合に発生する可能性があります）。</target>
        </trans-unit>
        <trans-unit id="8dcc1ea760f892b4e6eddb08b2acf9f9c879aeb1" translate="yes" xml:space="preserve">
          <source>The type defined by &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; can be used to create uninitialized memory blocks suitable to hold the objects of given type, optionally aligned stricter than their natural alignment requirement, for example on a cache or page boundary.</source>
          <target state="translated">&lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; typeで定義されたタイプを使用して、特定のタイプのオブジェクトを保持するのに適した初期化されていないメモリブロックを作成できます。</target>
        </trans-unit>
        <trans-unit id="015fb8d559015f4868df42502a384ec989660bc6" translate="yes" xml:space="preserve">
          <source>The type does not have to implement &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this type requirement: a &lt;a href=&quot;../language/as_operator&quot;&gt;copy assignment operator&lt;/a&gt; that takes its parameter by value or as a &lt;code&gt;const Type&amp;amp;&lt;/code&gt;, will bind to rvalue argument.</source>
          <target state="translated">型は、この型の要件を満たすために&lt;a href=&quot;../language/move_operator&quot;&gt;移動代入演算子&lt;/a&gt;を実装する必要はありません。値によって、または &lt;code&gt;const Type&amp;amp;&lt;/code&gt; としてパラメーターを取る&lt;a href=&quot;../language/as_operator&quot;&gt;コピー代入演算子&lt;/a&gt;は、rvalue引数にバインドします。</target>
        </trans-unit>
        <trans-unit id="4ee6bc4a29e09101e3ca894cf68274fb41416543" translate="yes" xml:space="preserve">
          <source>The type does not have to implement a &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this trait; see &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; for details.</source>
          <target state="translated">型は、この特性を満たすために&lt;a href=&quot;../language/move_operator&quot;&gt;移動代入演算子&lt;/a&gt;を実装する必要はありません。詳細については、&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="71c7ef3196579896dbcb86da29f6c58aaeef4821" translate="yes" xml:space="preserve">
          <source>The type does not support subnormal values</source>
          <target state="translated">この型は亜正規値をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="c0aefe5f52f0c91ab7dcca87fc13463e2b84f15b" translate="yes" xml:space="preserve">
          <source>The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">mbstate_t型は、サポートされているマルチバイト文字エンコーディングルールの実装定義セットで発生する可能性のある変換状態を表すことができる、単純な非配列型です。 &lt;code&gt;mbstate_t&lt;/code&gt; のゼロで初期化された値は、初期変換状態を表しますが、 &lt;code&gt;mbstate_t&lt;/code&gt; の他の値も存在して、初期変換状態を表す場合があります。</target>
        </trans-unit>
        <trans-unit id="ee6f31452577bc5b29d1b96501ba9c9ead4fd373" translate="yes" xml:space="preserve">
          <source>The type must meet &lt;a href=&quot;clock&quot;&gt;Clock&lt;/a&gt; requirements.</source>
          <target state="translated">タイプは&lt;a href=&quot;clock&quot;&gt;クロック&lt;/a&gt;要件を満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="417fa810ac7b429d2e715174963cd48512430822" translate="yes" xml:space="preserve">
          <source>The type must meet all of the following requirements:</source>
          <target state="translated">タイプは以下の要件をすべて満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="5fe47f690f454a471c8cf3ffe3e0c793213ba10d" translate="yes" xml:space="preserve">
          <source>The type must satisfy the following additional expressions, given two values &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; that are of the type, and that &lt;code&gt;np&lt;/code&gt; is a value of &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type (possibly &lt;code&gt;const&lt;/code&gt; qualified):</source>
          <target state="translated">型である2つの値 &lt;code&gt;p&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; が与えられ、 &lt;code&gt;np&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 型の値（おそらく &lt;code&gt;const&lt;/code&gt; 修飾）であることを前提として、型は次の追加式を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="369901cace11f8d9f2b85e35e2783ef729d22cb1" translate="yes" xml:space="preserve">
          <source>The type must work with &amp;lt; operator and the result should have standard semantics.</source>
          <target state="translated">タイプは&amp;lt;演算子で機能する必要があり、結果は標準のセマンティクスを持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="8ccea44fbb2fd126230d043404a673c987073e90" translate="yes" xml:space="preserve">
          <source>The type must work with == operator and the result should have standard semantics.</source>
          <target state="translated">この型は ==演算子で動作し、結果は標準的なセマンティクスを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="a401af7b772905929e6c578148662943f7e9b5a8" translate="yes" xml:space="preserve">
          <source>The type need not be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt; or have an available &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, and can be &lt;a href=&quot;abstract_class&quot;&gt;abstract&lt;/a&gt;. This rule doesn't apply to sub-expressions: in &lt;code&gt;decltype(f(g()))&lt;/code&gt;, &lt;code&gt;g()&lt;/code&gt; must have a complete type, but &lt;code&gt;f()&lt;/code&gt; need not.</source>
          <target state="translated">種類は、である必要はなく、&lt;a href=&quot;incomplete_type&quot;&gt;完全な&lt;/a&gt;または利用可能な&lt;a href=&quot;destructor&quot;&gt;デストラクタを&lt;/a&gt;することができ、&lt;a href=&quot;abstract_class&quot;&gt;抽象的&lt;/a&gt;。このルールはサブ式には適用されません &lt;code&gt;decltype(f(g()))&lt;/code&gt; では、 &lt;code&gt;g()&lt;/code&gt; は完全な型を持つ必要がありますが、 &lt;code&gt;f()&lt;/code&gt; は必須ではありません。</target>
        </trans-unit>
        <trans-unit id="c83f8d22479920f797dda997ec4470602b5cb196" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;E&lt;/code&gt; after substitution must be exactly &lt;code&gt;bool&lt;/code&gt;. No conversion is permitted:</source>
          <target state="translated">置換後の &lt;code&gt;E&lt;/code&gt; の型は、正確に &lt;code&gt;bool&lt;/code&gt; でなければなりません。変換は許可されていません：</target>
        </trans-unit>
        <trans-unit id="092bcee309aef84863a0a22c05df0ff5cc2306f8" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;N&lt;/code&gt; in the type &lt;code&gt;T[N]&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T[N]&lt;/code&gt; 型の &lt;code&gt;N&lt;/code&gt; の型は &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e00aa691520243fc7bb95963a65a42850ff0ee2d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;replacement&lt;/code&gt; is &lt;code&gt;std::filesystem::path&lt;/code&gt; even though it is not intended to represent an object on the file system in order to correctly account for the filesystem character encoding.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; のタイプは &lt;code&gt;std::filesystem::path&lt;/code&gt; ですが、ファイルシステムの文字エンコーディングを正しく説明するためにファイルシステム上のオブジェクトを表すことは意図されていません。</target>
        </trans-unit>
        <trans-unit id="73ef25a9616ca1a936ee4e3bf75aad3a667fbb50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;this&lt;/code&gt; in a member function of class &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;X*&lt;/code&gt; (pointer to X). If the member function is &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt;, the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;cv X*&lt;/code&gt; (pointer to identically cv-qualified X). Since constructors and destructors cannot be cv-qualified, the type of &lt;code&gt;this&lt;/code&gt; in them is always &lt;code&gt;X*&lt;/code&gt;, even when constructing or destroying a const object.</source>
          <target state="translated">クラス &lt;code&gt;X&lt;/code&gt; のメンバー関数での &lt;code&gt;this&lt;/code&gt; 型は &lt;code&gt;X*&lt;/code&gt; （Xへのポインター）です。メンバー関数が&lt;a href=&quot;member_functions&quot;&gt;cv-qualifiedの&lt;/a&gt;場合、 &lt;code&gt;this&lt;/code&gt; 型は &lt;code&gt;cv X*&lt;/code&gt; （完全にcv-qualified Xへのポインター）です。コンストラクタとデストラクタは、CV-修飾することができないので、タイプの &lt;code&gt;this&lt;/code&gt; それらでは常に &lt;code&gt;X*&lt;/code&gt; constオブジェクトを構築したり破壊した場合でも、。</target>
        </trans-unit>
        <trans-unit id="4a3330b556852ca71717541f2c81d240e408418f" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; appearing in an alias template declaration is different between instantiations of that template, even when the lambda expression is not dependent.</source>
          <target state="translated">エイリアステンプレートの宣言に現れる&lt;a href=&quot;lambda&quot;&gt;ラムダ式&lt;/a&gt;のタイプは、ラムダ式が依存していない場合でも、そのテンプレートのインスタンス化間で異なります。</target>
        </trans-unit>
        <trans-unit id="1c03df0e9a6c3883eefceaf776f001998a556f7d" translate="yes" xml:space="preserve">
          <source>The type of a bit field can only be integral or enumeration type.</source>
          <target state="translated">ビットフィールドの型は、積分型か列挙型のみとすることができます。</target>
        </trans-unit>
        <trans-unit id="3e828f47acdf8dd1be944f104aebcd681e249b7b" translate="yes" xml:space="preserve">
          <source>The type of a non-type template parameter may be deduced if it includes a placeholder type (&lt;code&gt;auto&lt;/code&gt;, a placeholder for a deduced class type(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;). The deduction is performed as if by deducing the type of the variable &lt;code&gt;x&lt;/code&gt; in the invented declaration &lt;code&gt;T x = template-argument;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</source>
          <target state="translated">非タイプテンプレートパラメータのタイプは、プレースホルダタイプ（ &lt;code&gt;auto&lt;/code&gt; 、推論されたクラスタイプのプレースホルダ（C ++ 20以降）、または &lt;code&gt;decltype(auto)&lt;/code&gt; ）を含む場合、推論される可能性があります。推定は、発明された宣言で変数 &lt;code&gt;x&lt;/code&gt; の型を推定するかのように実行されます &lt;code&gt;T x = template-argument;&lt;/code&gt; ここで、 &lt;code&gt;T&lt;/code&gt; はテンプレートパラメータの宣言された型です。推定された型が非型のテンプレートパラメーターで許可されていない場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="9f077ca46cbdc83666da091d5f4c5c63b8be8535" translate="yes" xml:space="preserve">
          <source>The type of a pointer to array of unknown bound, or of a type defined by a &lt;code&gt;typedef&lt;/code&gt; declaration to be an array of unknown bound, cannot be completed.</source>
          <target state="translated">不明な境界の配列へのポインターの型、または &lt;code&gt;typedef&lt;/code&gt; 宣言によって不明な境界の配列として定義された型は、完了できません。</target>
        </trans-unit>
        <trans-unit id="e1654f0998b812161591ecd53f879aa981b5cfa6" translate="yes" xml:space="preserve">
          <source>The type of an expression that results from the compile-time analysis of the program is known as the</source>
          <target state="translated">プログラムのコンパイル時解析の結果として得られる式の型は</target>
        </trans-unit>
        <trans-unit id="dc3ab407bca97dd7b2182e8d6089591cbf78c0f6" translate="yes" xml:space="preserve">
          <source>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</source>
          <target state="translated">各データメンバの型は、エンティティが参照型を持つ場合を除き、対応するキャプチャされたエンティティの型である(その場合、関数への参照は参照された関数へのlvalue参照としてキャプチャされ、オブジェクトへの参照は参照されたオブジェクトのコピーとしてキャプチャされる)。</target>
        </trans-unit>
        <trans-unit id="85801fe2a975f6f74abeb5935ecc5a8cbc8a24c1" translate="yes" xml:space="preserve">
          <source>The type of each function parameter in the parameter list is determined according to the following rules:</source>
          <target state="translated">パラメータリストの各関数パラメータのタイプは、以下のルールに従って決定されます。</target>
        </trans-unit>
        <trans-unit id="14480ff70d6d9671051d3a3bebfef0ffda9aa55c" translate="yes" xml:space="preserve">
          <source>The type of function callbacks that can be registered using &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; to be called on specific events.</source>
          <target state="translated">特定のイベントで呼び出されるように &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; を使用して登録できる関数コールバックのタイプ。</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">の種類があります。</target>
        </trans-unit>
        <trans-unit id="b1b79e1851bb8cd4e0abe53b7badea94acb8b63a" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array must be a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">配列の要素の型は&lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;である必要があります。そうでない場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="2a440bce9393578dcc59e67d819369eb6fff9dc5" translate="yes" xml:space="preserve">
          <source>The type of the elements.</source>
          <target state="translated">要素の種類。</target>
        </trans-unit>
        <trans-unit id="39cb107adf449bbc790a8800f9b0f24f9bbe1ba6" translate="yes" xml:space="preserve">
          <source>The type of the function being declared is composed from the</source>
          <target state="translated">宣言される関数の型は</target>
        </trans-unit>
        <trans-unit id="9bbb6b4e7d477a9cc16a3aa9d6f2075047c3171b" translate="yes" xml:space="preserve">
          <source>The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">整数リテラルの型は、どの数値基底とどの整数サフィックスが使用されたかに依存する型のリストの中から、値が収まる最初の型です。</target>
        </trans-unit>
        <trans-unit id="68e06d906da63b0e924e6b7c9ec59a39e6b3cb3e" translate="yes" xml:space="preserve">
          <source>The type of the literal</source>
          <target state="translated">リテラルの型</target>
        </trans-unit>
        <trans-unit id="66d91e0faa820f737700bea3d6d88e6c67abbd4b" translate="yes" xml:space="preserve">
          <source>The type of the stored elements. The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is not the same type as &lt;code&gt;Container::value_type&lt;/code&gt;.(since C++17)</source>
          <target state="translated">格納されている要素のタイプ。 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Container::value_type&lt;/code&gt; と同じ型でない場合の動作は未定義です（C ++ 17以降）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
