<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8b3f01687d89feac7cfe2128cd7fb4336c3f52ee" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt;.</source>
          <target state="translated">エラーや特殊なケースは、あたかも操作が &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt; によって実装されているかのように処理されます。</target>
        </trans-unit>
        <trans-unit id="d8eceb47949f152b23fef3272be167f4940d38aa" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">エラーや特殊なケースは、あたかも演算が &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt; によって実装されているかのように処理されます。ここで、 &lt;code&gt;i&lt;/code&gt; は虚数単位です。</target>
        </trans-unit>
        <trans-unit id="2ab0e556309413233a2f6554e50dca392be2f614" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーは &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されているように報告されます。</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">エラーは&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;と一致して報告されます。</target>
        </trans-unit>
        <trans-unit id="ed0e29a499e18c343b1b41bf866f5a04007120ed" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーは &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; と一致して報告されます。</target>
        </trans-unit>
        <trans-unit id="5864985afc7c53fae220dc47110ea05595ec5f47" translate="yes" xml:space="preserve">
          <source>Errors may be reported as specified in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">エラーは、&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandlingで&lt;/a&gt;指定されているように報告される場合があります。</target>
        </trans-unit>
        <trans-unit id="ee99754a522541dd514fb00437ecaa5173a3680b" translate="yes" xml:space="preserve">
          <source>Errors that arise during exception handling are handled by &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;(until C++17).</source>
          <target state="translated">例外処理中に発生するエラーは、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; によって処理されます（C ++ 17まで）。</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">脱出シーケンス</target>
        </trans-unit>
        <trans-unit id="bd56cff3676fe902e346c447da9fdfeeaa8307a3" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt;.</source>
          <target state="translated">エスケープシーケンスは、&lt;a href=&quot;character_literal&quot;&gt;文字&lt;/a&gt;&lt;a href=&quot;string_literal&quot;&gt;列リテラル&lt;/a&gt;および文字リテラル内の特定の特殊文字を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="f742a88872219830426d31bbcd98064272e610fb" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in both cases; 2) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt;:</source>
          <target state="translated">基本的に、 &lt;code&gt;E1&lt;/code&gt; はどちらの場合も評価されて破棄されます。2） &lt;code&gt;E2&lt;/code&gt; が&lt;a href=&quot;data_members&quot;&gt;非静的データメンバーの場合&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cff4774a9f4e9cd8077ee08295f533dd38074331" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;strict weak ordering&lt;/a&gt; relation with the following properties</source>
          <target state="translated">次のプロパティとの&lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;厳密な弱い順序&lt;/a&gt;関係を確立します</target>
        </trans-unit>
        <trans-unit id="852a89d52bfbfe13219c2f99e5bebf530d7e1264" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;memory_order&quot;&gt;memory synchronization ordering&lt;/a&gt; of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation.</source>
          <target state="translated">関連するアトミック操作なしで、 &lt;code&gt;order&lt;/code&gt; の指示に従って、非アトミックで緩和されたアトミックアクセスの&lt;a href=&quot;memory_order&quot;&gt;メモリ同期順序&lt;/a&gt;を確立します。</target>
        </trans-unit>
        <trans-unit id="f3f364090d806d3b0cee66b4e00edd9582f9bb6b" translate="yes" xml:space="preserve">
          <source>Establishes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;, that is, it satisfies the following properties:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;等価関係を&lt;/a&gt;確立します。つまり、次の特性を満たします。</target>
        </trans-unit>
        <trans-unit id="8d058e497d38c36626918d3f0a58443807999d35" translate="yes" xml:space="preserve">
          <source>Establishes an equivalence relation. Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x.param() == y.param()&lt;/code&gt; and future infinite sequences of values that would be generated by repeated invocations of &lt;code&gt;x(g1)&lt;/code&gt; and &lt;code&gt;y(g2)&lt;/code&gt; would be equal as long as &lt;code&gt;g1 == g2&lt;/code&gt;.</source>
          <target state="translated">等価関係を確立します。 &lt;code&gt;x.param() == y.param()&lt;/code&gt; および &lt;code&gt;x(g1)&lt;/code&gt; と &lt;code&gt;y(g2)&lt;/code&gt; の繰り返し呼び出しによって生成される将来の無限の値のシーケンスが &lt;code&gt;g1 == g2&lt;/code&gt; 限り等しい場合に &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="224e99f2262d85ee9bdcb40ff75322e28286d665" translate="yes" xml:space="preserve">
          <source>Establishes an exception handler around the body of a function.</source>
          <target state="translated">関数のボディ周辺に例外ハンドラを確立します。</target>
        </trans-unit>
        <trans-unit id="2c8128bfda4d0efc1187706eb75c4af98c699f3e" translate="yes" xml:space="preserve">
          <source>Establishes equivalence relationship with the following properties</source>
          <target state="translated">以下の性質を持つ同値関係を確立する</target>
        </trans-unit>
        <trans-unit id="a0a813deb9e43ef1c13a8996290d00b720e38940" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">スレッドと、同じスレッドで実行されるシグナルハンドラーとの間で、 &lt;code&gt;order&lt;/code&gt; の指示に従って、非アトミックでリラックスしたアトミックアクセスのメモリ同期順序を確立します。これは &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; と同等ですが、メモリの順序付けに関するCPU命令が発行されない点が異なります。コンパイラーによる命令の再順序付けのみが、 &lt;code&gt;order&lt;/code&gt; 指示として抑制されます。たとえば、リリースセマンティクスのフェンスは、読み取りまたは書き込みが後続の書き込みを超えて移動することを防ぎ、取得セマンティクスのフェンスは、読み取りまたは書き込みが先行する読み取りより前に移動することを防ぎます。</target>
        </trans-unit>
        <trans-unit id="557e271e8a3a0cf9ee786e9ab59e8bf077dde9c7" translate="yes" xml:space="preserve">
          <source>Estimates the number of characters available for input in the associated character sequence. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; is guaranteed not to return &lt;code&gt;Traits::eof()&lt;/code&gt; or throw an exception until at least that many characters are extracted.</source>
          <target state="translated">関連する文字シーケンスで入力に使用できる文字数を推定します。 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; は、少なくともその数の文字が抽出されるまで、 &lt;code&gt;Traits::eof()&lt;/code&gt; を返さないか、例外をスローしないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="5ad645d0b6cf4e8f2f0f5a5463bf7ca6f9950d22" translate="yes" xml:space="preserve">
          <source>Euclidean norm</source>
          <target state="translated">ユークリッドノルム</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">評価の順番と順序</target>
        </trans-unit>
        <trans-unit id="f6b2d28039057e6a76561c58410eb4f016c0728f" translate="yes" xml:space="preserve">
          <source>Even before allocator support was removed from &lt;code&gt;std::function&lt;/code&gt; in C++17, these assignment operators use the default allocator rather than the allocator of &lt;code&gt;*this&lt;/code&gt; or the allocator of &lt;code&gt;other&lt;/code&gt; (see &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG #2386&lt;/a&gt;).</source>
          <target state="translated">C ++ 17で &lt;code&gt;std::function&lt;/code&gt; からアロケーターサポートが削除される前でも、これらの代入演算子は &lt;code&gt;*this&lt;/code&gt; のアロケーターや &lt;code&gt;other&lt;/code&gt; のアロケーターではなく、デフォルトのアロケーターを使用します（&lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG＃2386を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5bf28a5cb25e295e74fa193c881e4823ae53ebb2" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_day&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymd.day()&lt;/code&gt; is 29, 30, or 31.</source>
          <target state="translated">場合でも &lt;code&gt;ymd.ok()&lt;/code&gt; が真であり、得られた &lt;code&gt;year_month_day&lt;/code&gt; があれば有効な日付を表していないかもしれ &lt;code&gt;ymd.day()&lt;/code&gt; は 29、30、または31です。</target>
        </trans-unit>
        <trans-unit id="13f714ec21c59f4555ffdd439f65ba1de4339a70" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymwd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_weekday&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymwd.index()&lt;/code&gt; is 5.</source>
          <target state="translated">場合でも &lt;code&gt;ymwd.ok()&lt;/code&gt; が真であり、得られた &lt;code&gt;year_month_weekday&lt;/code&gt; があれば有効な日付を表していないかもしれ &lt;code&gt;ymwd.index()&lt;/code&gt; は 5です。</target>
        </trans-unit>
        <trans-unit id="d9c13458a40bd815f989f602ad0395796fb458d9" translate="yes" xml:space="preserve">
          <source>Even if notified under lock, overload (1) makes no guarantees about the state of the associated predicate when returning due to timeout.</source>
          <target state="translated">ロック中に通知された場合でも、オーバーロード(1)は、タイムアウトによるリターン時の関連述語の状態を保証しません。</target>
        </trans-unit>
        <trans-unit id="e8a756d7fa529afd7aeb13d1511bd134a3d2cc0c" translate="yes" xml:space="preserve">
          <source>Even if the clock in use is &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; or another monotonic clock, a system clock adjustment may induce a spurious wakeup.</source>
          <target state="translated">使用中のクロックが &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; または別の単調なクロックである場合でも、システムクロックの調整により、誤ったウェイクアップが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="30fbd007da85ebd7312535e0cc529833d2a4d4fe" translate="yes" xml:space="preserve">
          <source>Even if the name to the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace, the template disambiguator is allowed:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; の左側の名前が名前空間を参照している場合でも、テンプレートの曖昧性解消記号は許可されます。</target>
        </trans-unit>
        <trans-unit id="82ac5cb6cfab85d924b4733697e77158a0419204" translate="yes" xml:space="preserve">
          <source>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</source>
          <target state="translated">たとえ共有変数がアトミックであったとしても、その変更を待ちスレッドに正しく公開するためには、ミューテックスの下で変更されなければなりません。</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">にもかかわらず &lt;code&gt;%c&lt;/code&gt; は期待する &lt;code&gt;int&lt;/code&gt; 型の引数を、合格しても安全である &lt;code&gt;char&lt;/code&gt; ので、可変引数関数が呼び出されたときに行われる整数のプロモーションの。</target>
        </trans-unit>
        <trans-unit id="eef899288103457cb2c6536cbb280b5cca3eb991" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;if&lt;/code&gt; is a &lt;a href=&quot;../../keywords/if&quot;&gt;keyword&lt;/a&gt; in C++, it is a ud-suffix of the &lt;a href=&quot;../../language/user_literal&quot;&gt;literal operator&lt;/a&gt; of the form &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; and in the literal expressions such as &lt;code&gt;1if&lt;/code&gt; or &lt;code&gt;1.0if&lt;/code&gt; because it is not separated by whitespace and is not a standalone token.</source>
          <target state="translated">にもかかわらず、 &lt;code&gt;if&lt;/code&gt; ある&lt;a href=&quot;../../keywords/if&quot;&gt;キーワード&lt;/a&gt; C ++で、それは、UD-接尾辞である&lt;a href=&quot;../../language/user_literal&quot;&gt;リテラルオペレータ&lt;/a&gt;形式の &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; 、そのようにリテラル式で &lt;code&gt;1if&lt;/code&gt; 又は &lt;code&gt;1.0if&lt;/code&gt; それは空白で区切られていないため、スタンドアロントークンありません。</target>
        </trans-unit>
        <trans-unit id="205833ef6be0b707c638302ab3b276a23d851ced" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;try&lt;/code&gt; blocks are allowed in constexpr functions, throwing exceptions is still disallowed in a constant expression.</source>
          <target state="translated">にもかかわらず &lt;code&gt;try&lt;/code&gt; ブロックがconstexprの機能で許可されている、例外をスローすることは、まだ定数式で許可されていません。</target>
        </trans-unit>
        <trans-unit id="beca8aa735200901df75e963c1c548f38fd8410f" translate="yes" xml:space="preserve">
          <source>Even though destructors are not inherited, if a base class declares its destructor &lt;code&gt;virtual&lt;/code&gt;, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</source>
          <target state="translated">デストラクタは継承されませんが、基本クラスがそのデストラクタ &lt;code&gt;virtual&lt;/code&gt; を宣言すると、派生したデストラクタが常にそれをオーバーライドします。これにより、動的に割り当てられたポリモーフィック型のオブジェクトを、baseへのポインターを介して削除できます。</target>
        </trans-unit>
        <trans-unit id="fd583cbe0ab59fe4a28f57f7cb504c86fd58cbce" translate="yes" xml:space="preserve">
          <source>Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique.</source>
          <target state="translated">名前のない名前空間の名前は外部リンクで宣言されていても、名前空間名が一意であるため、他の翻訳ユニットからはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="89f989b918b3efa1509410878202d64feeaad6c7" translate="yes" xml:space="preserve">
          <source>Even though the non-allocating placement new (9,10) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt;), must use &lt;code&gt;::new&lt;/code&gt; and also cast the pointer to &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">割り当てられていない配置new（9,10）を置き換えることはできませんが、同じシグネチャを持つ関数は、上記のようにクラススコープで定義できます。さらに、新しい配置のように見えるが、2番目の引数としてvoid以外のポインター型をとるグローバルオーバーロードが許可されているため、実際の新しい配置が確実に呼び出されるようにするコード（例： &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;::new&lt;/code&gt; を使用し、ポインタを &lt;code&gt;void*&lt;/code&gt; キャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="f76a45b89412fbbe4ac41ff04a11f89153e89cd3" translate="yes" xml:space="preserve">
          <source>Even though top-level &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</source>
          <target state="translated">パラメーターのトップレベルの&lt;a href=&quot;cv&quot;&gt;cv修飾子&lt;/a&gt;は関数宣言では破棄されますが、関数の本体に表示されるようにパラメーターの型を変更します。</target>
        </trans-unit>
        <trans-unit id="a45dfe469d18cb059aef8c5b79aaf3c568df5677" translate="yes" xml:space="preserve">
          <source>Even when the destructor is called directly (e.g. &lt;code&gt;obj.~Foo();&lt;/code&gt;), the return statement in &lt;code&gt;~Foo()&lt;/code&gt; does not return control to the caller immediately: it calls all those member and base destructors first.</source>
          <target state="translated">（例えばデストラクタが直接呼び出された場合でも &lt;code&gt;obj.~Foo();&lt;/code&gt; ）、中return文 &lt;code&gt;~Foo()&lt;/code&gt; すぐに呼び出し側に制御を返しません：それは最初にすべてのそれらの部材とベースデストラクタを呼び出します。</target>
        </trans-unit>
        <trans-unit id="c457cc0cca53f5efaec11bdae6464c7a8f3d1683" translate="yes" xml:space="preserve">
          <source>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">緩和されたメモリモデルを使用した場合でも、たとえば、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が最初はゼロの場合など、空気不足の値が独自の計算に循環的に依存することはできません。</target>
        </trans-unit>
        <trans-unit id="0d294028b66fc033fb8f8b33345165f1b149cdc7" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; and &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; has a</source>
          <target state="translated">すべての&lt;a href=&quot;objects&quot;&gt;オブジェクト&lt;/a&gt;と&lt;a href=&quot;reference&quot;&gt;参照&lt;/a&gt;には</target>
        </trans-unit>
        <trans-unit id="1e3d5eff0d465c69879e0e0871021f12c2fae6c2" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</source>
          <target state="translated">すべての&lt;a href=&quot;templates&quot;&gt;テンプレート&lt;/a&gt;は、テンプレート宣言構文のパラメーターリストに示されている1つ以上のテンプレートパラメーターによってパラメーター化されます。</target>
        </trans-unit>
        <trans-unit id="9a47d9aa16911998ba8cb56b9196661886621057" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt; has the property called</source>
          <target state="translated">すべての&lt;a href=&quot;type-id&quot;&gt;オブジェクトタイプに&lt;/a&gt;は、</target>
        </trans-unit>
        <trans-unit id="d4c1d197b0b4ce5bf0d47347c3c212d7928dae9a" translate="yes" xml:space="preserve">
          <source>Every call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, &lt;code&gt;freeze(false)&lt;/code&gt; needs to be called explicitly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; を呼び出すたびにストリームが凍結され、返されるポインタの有効性が保持されます。デストラクタがバッファの割り当てを解除できるようにするには、 &lt;code&gt;freeze(false)&lt;/code&gt; を明示的に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="267f5eca029a0473ad86866143a283d6e67dc0cd" translate="yes" xml:space="preserve">
          <source>Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by &lt;code&gt;throw;&lt;/code&gt;. The return statement is not allowed in any catch clause of a constructor's function-try-block.</source>
          <target state="translated">コンストラクターのfunction-try-block内のすべてのcatch節は、例外をスローして終了する必要があります。コントロールがそのようなハンドラーの最後に到達すると、現在の例外は &lt;code&gt;throw;&lt;/code&gt; ように自動的に再スローされます。。returnステートメントは、コンストラクターのfunction-try-blockのcatch節では許可されていません。</target>
        </trans-unit>
        <trans-unit id="40c918ca9b8fb74eddbf2e3635eb193312898d9a" translate="yes" xml:space="preserve">
          <source>Every character &lt;code&gt;c&lt;/code&gt; obtained in Stage 1, other than the decimal point &lt;code&gt;'.'&lt;/code&gt;, is converted to &lt;code&gt;CharT&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt;.</source>
          <target state="translated">小数点 &lt;code&gt;'.'&lt;/code&gt; 除き、ステージ1で取得されたすべての文字 &lt;code&gt;c&lt;/code&gt; 。は、 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt; &amp;lt; &lt;a href=&quot;../ctype&quot;&gt;std :: ctype&lt;/a&gt; &amp;lt;CharT &amp;gt;&amp;gt;（str.getloc（））。widen（c）を呼び出すことによって &lt;code&gt;CharT&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="55240b46d1b2c778147a32f69f02140623223676" translate="yes" xml:space="preserve">
          <source>Every copy assignment operator is &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">すべてのコピー割り当て演算子は&lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;簡単&lt;/a&gt;または削除されます</target>
        </trans-unit>
        <trans-unit id="44ece2209b7a05d39c75b1dcbb965646849a11d9" translate="yes" xml:space="preserve">
          <source>Every copy constructor is &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">すべてのコピーコンストラクターは&lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;簡単&lt;/a&gt;または削除されます</target>
        </trans-unit>
        <trans-unit id="ddca33bae1f5063131bf99b04d54385eb0d2361a" translate="yes" xml:space="preserve">
          <source>Every coroutine must have a return type that satisfies a number of requirements, noted below.</source>
          <target state="translated">すべてのコルーチンは、以下に示すように、いくつかの要件を満たすリターン型を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="6f0b1e2abf2c7b435c80221dcc61afd569006cf6" translate="yes" xml:space="preserve">
          <source>Every direct base of &lt;code&gt;T&lt;/code&gt; has a trivial default constructor</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のすべての直接ベースには、簡単なデフォルトコンストラクターがあります。</target>
        </trans-unit>
        <trans-unit id="e4f4a9e39d552d4d3b8434b290840e0cb2a72f79" translate="yes" xml:space="preserve">
          <source>Every expression required to be equality preserving is further required to be</source>
          <target state="translated">平等性が保たれていることが求められるすべての式は、さらに次のように求められます。</target>
        </trans-unit>
        <trans-unit id="596cadab563dc077013bb82171b4d411422fe26e" translate="yes" xml:space="preserve">
          <source>Every function in C++ is either</source>
          <target state="translated">C++のすべての関数は</target>
        </trans-unit>
        <trans-unit id="2e5a037bddcba35d74d8f0e90f7f426c42f8bbb7" translate="yes" xml:space="preserve">
          <source>Every function type, every function name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, and every variable name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, has a property called</source>
          <target state="translated">すべての関数型を持つすべての関数名&lt;a href=&quot;storage_duration&quot;&gt;外部リンケージ&lt;/a&gt;、および持つすべての変数名&lt;a href=&quot;storage_duration&quot;&gt;外部リンケージは&lt;/a&gt;、というプロパティを持っています</target>
        </trans-unit>
        <trans-unit id="9220204e7dd00c7e1b3f8ea123e9b7a6432dc43a" translate="yes" xml:space="preserve">
          <source>Every initializer clause is &lt;a href=&quot;eval_order&quot;&gt;sequenced before&lt;/a&gt; any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;, which are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt;.</source>
          <target state="translated">すべての初期化句は、braced-init-list内でそれに続く初期化句の&lt;a href=&quot;eval_order&quot;&gt;前に&lt;/a&gt;順序付けされます。これは、&lt;a href=&quot;eval_order&quot;&gt;シーケンスされて&lt;/a&gt;いない&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;関数呼び出し式の&lt;/a&gt;引数とは対照的です。</target>
        </trans-unit>
        <trans-unit id="e6ec13c0519794ea073e3092993cf4c79e0a531c" translate="yes" xml:space="preserve">
          <source>Every move assignment operator is &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">すべての移動割り当て演算子は&lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;簡単&lt;/a&gt;または削除されます</target>
        </trans-unit>
        <trans-unit id="be04d7a82c5aad5c68ef07fc699cbbb387d1c3f3" translate="yes" xml:space="preserve">
          <source>Every move constructor is &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">すべての移動コンストラクターは&lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;取るに足らない&lt;/a&gt;か削除されています</target>
        </trans-unit>
        <trans-unit id="cec5230f04de71fff49fd937f9a018fd570d7a46" translate="yes" xml:space="preserve">
          <source>Every name that denotes an entity is introduced into the program by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. Every name that denotes a label is introduced into the program either by a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; or by a &lt;a href=&quot;statements#Labels&quot;&gt;labeled statement&lt;/a&gt;. A name used in more than one translation unit may refer to the same or different entities, depending on &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt;.</source>
          <target state="translated">エンティティを表すすべての名前は、&lt;a href=&quot;declarations&quot;&gt;宣言&lt;/a&gt;によってプログラムに導入されます。ラベルを示すすべての名前は、&lt;a href=&quot;goto&quot;&gt;gotoステートメント&lt;/a&gt;または&lt;a href=&quot;statements#Labels&quot;&gt;ラベル付きステートメント&lt;/a&gt;によってプログラムに導入されます。複数の翻訳単位で使用される名前は、&lt;a href=&quot;storage_duration#Linkage&quot;&gt;リンケージ&lt;/a&gt;に応じて、同じエンティティまたは異なるエンティティを参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="b69a8648e61c5f2cb090d5c8ee69368fecb775bd" translate="yes" xml:space="preserve">
          <source>Every non-static data member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; must be a direct member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; or the same base class of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;, and must be well-formed in the context of the structured binding when named as &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt;. &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; may not have an anonymous union member. The number of identifiers must equal the number of non-static data members.</source>
          <target state="translated">すべての非静的データメンバ &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; は直接メンバーでなければならない &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; または同じ基底クラス &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; との関連でよく形成されなければならない構造と名付けたときバインディング &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; には匿名の組合員がいない場合があります。識別子の数は、非静的データメンバーの数と等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="b87d3e4870484b5764d76023f3269d280331e5c7" translate="yes" xml:space="preserve">
          <source>Every non-static member of class type has a trivial default constructor</source>
          <target state="translated">クラス型のすべての非静的メンバには、簡単なデフォルトのコンストラクタがあります。</target>
        </trans-unit>
        <trans-unit id="2ce1bf1bc0be1980d77a06eeb4de4b342c337db3" translate="yes" xml:space="preserve">
          <source>Every standard library component that may need to allocate or release storage, from &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and every container except &lt;code&gt;std::array&lt;/code&gt;, to &lt;code&gt;std::shared_ptr&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt;, does so through an &lt;strong&gt;Allocator&lt;/strong&gt;: an object of a class type that satisfies the following requirements.</source>
          <target state="translated">&lt;code&gt;std::string&lt;/code&gt; 、 &lt;code&gt;std::vector&lt;/code&gt; 、および &lt;code&gt;std::array&lt;/code&gt; を除くすべてのコンテナーから &lt;code&gt;std::shared_ptr&lt;/code&gt; および &lt;code&gt;std::function&lt;/code&gt; へのストレージの割り当てまたは解放を必要とする可能性があるすべての標準ライブラリコンポーネントは、&lt;strong&gt;Allocatorを&lt;/strong&gt;介して行います。次の要件を満たすクラス型のオブジェクト。</target>
        </trans-unit>
        <trans-unit id="2cf1b35b018fe1d430f2ed7ed9345dcf2146ab69" translate="yes" xml:space="preserve">
          <source>Every stream I/O function if an exception is thrown by any member function of the associated stream buffer (e.g. sbumpc(), xsputn(), sgetc(), overflow(), etc)</source>
          <target state="translated">関連するストリームバッファのいずれかのメンバ関数 (例:sbumpc()、xsputn()、sgetc()、overflow()など)によって例外がスローされた場合、すべてのストリーム IO 関数。</target>
        </trans-unit>
        <trans-unit id="b09575dd9bf238348e1eb74acc65642a4f28513f" translate="yes" xml:space="preserve">
          <source>Every successive character &lt;code&gt;c&lt;/code&gt; from the sequence of CharT's from Stage 3 is output as if by &lt;code&gt;*out++ = c&lt;/code&gt;.</source>
          <target state="translated">ステージ3のCharTのシーケンスから続くすべての文字 &lt;code&gt;c&lt;/code&gt; は、 &lt;code&gt;*out++ = c&lt;/code&gt; 場合と同様に出力されます。</target>
        </trans-unit>
        <trans-unit id="fa77f47a69b4e10cfca826c1e3a0f4dc9c68af3b" translate="yes" xml:space="preserve">
          <source>Every value of pointer type is one of the following:</source>
          <target state="translated">ポインタ型のすべての値は、以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="2711daf557af7651a60993264c29beb1d7e39e00" translate="yes" xml:space="preserve">
          <source>Everything about the actual allocation details of bit fields within the class object</source>
          <target state="translated">クラスオブジェクト内のビットフィールドの実際の割り当て詳細に関するすべてのこと</target>
        </trans-unit>
        <trans-unit id="17a1a39f3910e68bd1f80c1b610bdc32df68bf11" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, equivalence is determined by using the equivalence relation as described on &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリが&lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;要件を使用するすべての場所で、等価性は&lt;a href=&quot;../named_req/compare&quot;&gt;Compareで&lt;/a&gt;説明されているように等価関係を使用して決定されます。不正確に言えば、2つのオブジェクト &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は、どちらも他方よりも比較が小さい場合、同等と見なされます： &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b75c2f9b6cdfbe488daafdef876670cbfaba7ec" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent (not unique) if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリが&lt;a href=&quot;../named_req/compare&quot;&gt;比較&lt;/a&gt;要件を使用するすべての場所で、一意性は同値関係を使用して決定されます。不正確に言うと、2つのオブジェクト &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は、どちらも他方よりも小さい場合、同等（一意ではない）と見なされます： &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b615d029d5b8025e266ba5a37f8108df4dbd2078" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリが&lt;a href=&quot;../named_req/compare&quot;&gt;比較&lt;/a&gt;要件を使用するすべての場所で、一意性は同値関係を使用して決定されます。不正確に言えば、2つのオブジェクト &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は、どちらも他方よりも比較が小さい場合、同等と見なされます： &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="b73dce3ae50ecab687b47c8e8958379cbaf57ff0" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first) - 1&lt;/code&gt; applications of the binary operation.</source>
          <target state="translated">正確 &lt;code&gt;(last - first) - 1&lt;/code&gt; -2 項演算の1つのアプリケーション。</target>
        </trans-unit>
        <trans-unit id="4db39051f1f33d287e9bf44fd101eccfd97335d2" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first)/2&lt;/code&gt; swaps.</source>
          <target state="translated">正確に &lt;code&gt;(last - first)/2&lt;/code&gt; スワップ。</target>
        </trans-unit>
        <trans-unit id="999c7ba21fe6cfdf477efe576e8b30044ac5b242" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">述語の正確な &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; アプリケーション。</target>
        </trans-unit>
        <trans-unit id="1fc8a6d486ec5aab15a1c1be51264f79f56fc49b" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments.</source>
          <target state="translated">正確に &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; の &lt;code&gt;g()&lt;/code&gt; の呼び出しと割り当て。</target>
        </trans-unit>
        <trans-unit id="35529081f2f26b1b90fd973935838e5852bc467d" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, for &lt;code&gt;count &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; 場合、割り当てを正確に &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a8809cf33804ae021cd515fa06675d07f185d82" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; の場合、割り当てを正確に &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0e851801f10602f0a4225377722df5cf5583ba1" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments, for &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; の場合、 &lt;code&gt;g()&lt;/code&gt; の呼び出しと割り当てを正確に &lt;code&gt;count&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9e8a97940b9961f72ad69126c982a5fb916192e8" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の正確な &lt;code&gt;distance(first, last)&lt;/code&gt; アプリケーション。</target>
        </trans-unit>
        <trans-unit id="664be72d77dd1a490f0db6001689b115d6a6b71a" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">まさに &lt;code&gt;last - first&lt;/code&gt; 述語の最初のアプリケーション。</target>
        </trans-unit>
        <trans-unit id="7e7f4d09b4ff46a04df0991518050618d9d2f7b5" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; assignments.</source>
          <target state="translated">正確に &lt;code&gt;last - first&lt;/code&gt; 割り当て。</target>
        </trans-unit>
        <trans-unit id="b25aeebe72d8f421614fa0ad0873495e44259427" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; increments and assignments.</source>
          <target state="translated">正確に &lt;code&gt;last - first&lt;/code&gt; 増分と割り当て。</target>
        </trans-unit>
        <trans-unit id="dd0f4944e44dc9fa8a6fa7891d44439f219ac35c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; move assignments.</source>
          <target state="translated">正確に &lt;code&gt;last - first&lt;/code&gt; 割り当てを移動します。</target>
        </trans-unit>
        <trans-unit id="64786764c6cc4f57b36277db2d8d6df02d730d57" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">正確には &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; のアプリケーション &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd8d57c8139bdfd24f5d36db13c1c858637e062" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">正確に &lt;code&gt;n&lt;/code&gt; 個のアプリケーション &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabf3a891f0ec18e0d36466fa6f0c9ce5485153e" translate="yes" xml:space="preserve">
          <source>Exactly max(N-1,0) comparisons, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">正確にmax（N-1,0）の比較 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99195733fda66fedc7bf44e9446fa1cb19801072" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt;, &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; and &lt;code&gt;bool(a == b)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; 、 &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; 、および &lt;code&gt;bool(a == b)&lt;/code&gt; いずれか1つが &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c0a2d0e4e192dcffd92f7c5fc920779a3a46eca3" translate="yes" xml:space="preserve">
          <source>Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with &lt;a href=&quot;status&quot;&gt;&lt;code&gt;status()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;is_regular_file&quot;&gt;&lt;code&gt;is_regular_file()&lt;/code&gt;&lt;/a&gt;, and other status accessors.</source>
          <target state="translated">このディレクトリエントリによって参照されるファイルシステムオブジェクトを調べ、その属性を保存して、&lt;a href=&quot;status&quot;&gt; &lt;code&gt;status()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;is_regular_file&quot;&gt; &lt;code&gt;is_regular_file()&lt;/code&gt; &lt;/a&gt;、およびその他のステータスアクセサで取得します。</target>
        </trans-unit>
        <trans-unit id="d9b9f013ab46e72d63d24bb4f00288b2d9847138" translate="yes" xml:space="preserve">
          <source>Examines the partitioned (as if by &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt;) range &lt;code&gt;[first, last)&lt;/code&gt; and locates the end of the first partition, that is, the first element that does not satisfy &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">検査は、（であるかのように分配 &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt; ）の範囲 &lt;code&gt;[first, last)&lt;/code&gt; と、満たさない最初の要素である最初のパーティションの終了位置する &lt;code&gt;p&lt;/code&gt; 又は &lt;code&gt;last&lt;/code&gt; すべての要素が満たす場合 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcb284168678a0919d196ddf44691afe02c5f4b3" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; を調べ、要素が昇順でソートされている &lt;code&gt;first&lt;/code&gt; から始まる最大範囲を見つけます。</target>
        </trans-unit>
        <trans-unit id="0a9b4d7926393a3c0dd8eb8f3c42a7ab58af6b22" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">範囲調べ &lt;code&gt;[first, last)&lt;/code&gt; 及び発見最大の範囲で始まる &lt;code&gt;first&lt;/code&gt; であります</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="bd9e11c33e704e33e3cee607c8252cdbbcd8a124" translate="yes" xml:space="preserve">
          <source>Example With Custom Comparator</source>
          <target state="translated">カスタムコンパレータを使用した例</target>
        </trans-unit>
        <trans-unit id="ab4f744b89a1cf5abcd9dceb291ddd3e9f741894" translate="yes" xml:space="preserve">
          <source>Example from &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htmの&lt;/a&gt;例。</target>
        </trans-unit>
        <trans-unit id="e251b366d1e0802c0331ec415628df8aa911103c" translate="yes" xml:space="preserve">
          <source>Example output on one of the implementations.</source>
          <target state="translated">一実施形態における出力例。</target>
        </trans-unit>
        <trans-unit id="ea1fb9b04a44f008daf87c7d9f9e133ac9bce209" translate="yes" xml:space="preserve">
          <source>Example using a custom comparison function</source>
          <target state="translated">カスタム比較機能を使用した例</target>
        </trans-unit>
        <trans-unit id="db0a68cbf7c526f2a972b13383c59c76ca98c33e" translate="yes" xml:space="preserve">
          <source>Example with vectors :</source>
          <target state="translated">ベクトルを使った例 .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8221a0d43625eba2795f842d5c24c7c9f59b0337" translate="yes" xml:space="preserve">
          <source>Examples of &lt;code&gt;Boolean&lt;/code&gt; types include &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt;. Pointers are not &lt;code&gt;Boolean&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 型の例には、 &lt;code&gt;bool&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt; ます。ポインタは &lt;code&gt;Boolean&lt;/code&gt; 型ではありません。</target>
        </trans-unit>
        <trans-unit id="d1eddcef956b054e171719c037485ba482a76be3" translate="yes" xml:space="preserve">
          <source>Examples of erasure methods are &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消去メソッドの例は、 &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1fe47fa951fcb6357223febc9d44197fbb268fda" translate="yes" xml:space="preserve">
          <source>Examples of implementation-defined launch policies are the sync policy (execute immediately, within the async call) and the task policy (similar to async, but thread-locals are not cleared).</source>
          <target state="translated">実装定義の起動ポリシーの例としては、syncポリシー(async呼び出し内で即時実行)とタスクポリシー(asyncに似ていますが、スレッドローカルはクリアされません)があります。</target>
        </trans-unit>
        <trans-unit id="e910df0f6bb9dfed95f71ce88f75479176c518cf" translate="yes" xml:space="preserve">
          <source>Examples of insertion methods are &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">挿入メソッドの例は &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="69702eefdd99747ec1287d6c73c6d3f8f05c1292" translate="yes" xml:space="preserve">
          <source>Examples of partial specializations in the standard library include &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, which has a partial specialization for array types.</source>
          <target state="translated">標準ライブラリの部分的な特殊化の例には、 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 含まれます。これには、配列型の部分的な特殊化があります。</target>
        </trans-unit>
        <trans-unit id="a00ca19e4db47060f538e8b506c6503ac18be3b7" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;value_type&lt;/code&gt;, all the member types of &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; are complete types.</source>
          <target state="translated">&lt;code&gt;value_type&lt;/code&gt; を除き、 &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; すべてのメンバータイプは完全なタイプです。</target>
        </trans-unit>
        <trans-unit id="8acd64a7d513ffba5fa93f11be47de7c9fc5c1db" translate="yes" xml:space="preserve">
          <source>Except for default argument, aligned_storage is expressible in terms of alignas:</source>
          <target state="translated">デフォルトの引数を除いて、aligned_storageはalignasで表現可能です。</target>
        </trans-unit>
        <trans-unit id="f51732ca4ed72fa4525ab38c97db1146e4d04378" translate="yes" xml:space="preserve">
          <source>Except in the constructors of &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, negative values of &lt;code&gt;std::streamsize&lt;/code&gt; are never used.</source>
          <target state="translated">コンストラクタを除いて &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 、負の値 &lt;code&gt;std::streamsize&lt;/code&gt; 使用されることはありません。</target>
        </trans-unit>
        <trans-unit id="d587eb69ad8f0449298a08da77269d9ca0f24406" translate="yes" xml:space="preserve">
          <source>Except that if no exception specification is explicitly provided, the exception specification is considered to be one that would be used by the implicitly-declared destructor (see below). In most cases, this is &lt;code&gt;noexcept(true)&lt;/code&gt;. Thus a throwing destructor must be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">例外仕様が明示的に提供されていない場合を除き、例外仕様は、暗黙的に宣言されたデストラクタによって使用されるものと見なされます（以下を参照）。ほとんどの場合、これは &lt;code&gt;noexcept(true)&lt;/code&gt; です。したがって、スローデストラクタは明示的に &lt;code&gt;noexcept(false)&lt;/code&gt; と宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d95da02e76b8dae287531e540c02e16d08b2978" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of both statements.</source>
          <target state="translated">init-statementによって宣言された名前(init-statementが宣言である場合)と、conditionによって宣言された名前(conditionが宣言である場合)が同じスコープ内にあることを除いては、両方のステートメントのスコープでもあります。</target>
        </trans-unit>
        <trans-unit id="29967c007b524bf4d82e67020addcf8209e607a6" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of statement.</source>
          <target state="translated">init-statementで宣言された名前(init-statementが宣言である場合)と、条件で宣言された名前(条件が宣言である場合)が同じ範囲にあることを除いては、文の範囲でもあります。</target>
        </trans-unit>
        <trans-unit id="e357f711ee87c54bd0e9332d642407c850fea7c4" translate="yes" xml:space="preserve">
          <source>Except that the calls to &lt;code&gt;decay_copy&lt;/code&gt; are evaluated in the context of the caller, so that any exceptions thrown during evaluation and copying/moving of the arguments are thrown in the current thread, without starting the new thread.</source>
          <target state="translated">呼び出しことを除いて &lt;code&gt;decay_copy&lt;/code&gt; は、引数の移動/任意の例外がスローされた評価の中にそのことを、呼び出し元のコンテキストで評価してコピーする新しいスレッドを起動せずに、現在のスレッドでスローされます。</target>
        </trans-unit>
        <trans-unit id="1eeb0a1df8df205ed68a524cbaa8c0fab4fe1d23" translate="yes" xml:space="preserve">
          <source>Except that.</source>
          <target state="translated">それ以外はね</target>
        </trans-unit>
        <trans-unit id="f96eec6bcb0eb29fc403d27737c989d54305c3d2" translate="yes" xml:space="preserve">
          <source>Exception categories</source>
          <target state="translated">例外カテゴリ</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">例外処理</target>
        </trans-unit>
        <trans-unit id="2c1ebcb87ed425e2ea948b9057321bf79663c920" translate="yes" xml:space="preserve">
          <source>Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack).</source>
          <target state="translated">例外処理は、プログラムの実行中のある時点から、以前に実行によって渡された時点に関連付けられたハンドラに制御と情報を転送する方法を提供します(言い換えれば、例外処理は呼び出しスタックの上に制御を転送します)。</target>
        </trans-unit>
        <trans-unit id="484018b13af3fa5985246c3cf1cb9a80f78a4b2e" translate="yes" xml:space="preserve">
          <source>Exception handling utilities</source>
          <target state="translated">例外処理ユーティリティ</target>
        </trans-unit>
        <trans-unit id="f20b401bcfd0d6316854bd1c5be2e83c76d1de4f" translate="yes" xml:space="preserve">
          <source>Exception objects</source>
          <target state="translated">例外オブジェクト</target>
        </trans-unit>
        <trans-unit id="c178e2e0328be43fb7ba635e2d8a88fc566b2eb0" translate="yes" xml:space="preserve">
          <source>Exception of type &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; may be thrown on errors, with the following error codes:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 型の例外は、エラー時にスローされ、次のエラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">例外的な安全性</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="860a1ec6dde884258f991928e357d615dac44a1f" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;), assertions (e.g. &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">例外（例： &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ）、アサーション（例： &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1c85cdf1b242c92824cb3422445a6b69100c6e06" translate="yes" xml:space="preserve">
          <source>Exceptions of type &lt;code&gt;std::runtime_error&lt;/code&gt; are thrown by the following standard library components: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;std::runtime_error&lt;/code&gt; 例外は、標準ライブラリコンポーネント &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt; によってスローされます。</target>
        </trans-unit>
        <trans-unit id="3655d713d676393ce50c4dfe2c15b248f391aaef" translate="yes" xml:space="preserve">
          <source>Exceptions that are thrown from member initializers may be handled by &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;.</source>
          <target state="translated">メンバー初期化子からスローされた例外は、&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;によって処理される場合があります。</target>
        </trans-unit>
        <trans-unit id="f3ccb3655838c7cc0f05342ca4d518865db28c05" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;r&lt;/code&gt; の内容を交換します。</target>
        </trans-unit>
        <trans-unit id="cf0531db840de334e816e5c677f3bd63fcd3dd1a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の内容を交換します</target>
        </trans-unit>
        <trans-unit id="10d46d6be13fed97bcfc06d63285187114a038e8" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</source>
          <target state="translated">コンテナアダプタの内容を &lt;code&gt;other&lt;/code&gt; と交換します。 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt; を使用して効果的に呼び出します。swap（c、other.c）; swap（comp、other.comp）;</target>
        </trans-unit>
        <trans-unit id="3e6e9555c788d205a45c120fea2405b48de6ce8a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</source>
          <target state="translated">コンテナアダプタの内容を &lt;code&gt;other&lt;/code&gt; と交換します。 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt; を使用して効果的に呼び出します。swap（c、other.c）;</target>
        </trans-unit>
        <trans-unit id="49de04ba32b7f84cb9cd03e37185b56ecd9e1b91" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not cause iterators and references to associate with the other container.</source>
          <target state="translated">コンテナの内容を &lt;code&gt;other&lt;/code&gt; の内容と交換します。イテレータと参照が他のコンテナに関連付けられることはありません。</target>
        </trans-unit>
        <trans-unit id="cca5e7e3ee4209e3931f1f34eaaecf8cf0a0bc6a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not invoke any move, copy, or swap operations on individual elements.</source>
          <target state="translated">コンテナの内容を &lt;code&gt;other&lt;/code&gt; の内容と交換します。個々の要素に対して移動、コピー、またはスワップ操作を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="62bfbc4c539262880741976e01c4f02e7c1e4a00" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">ストリームバッファの内容を &lt;code&gt;other&lt;/code&gt; ものと交換します。</target>
        </trans-unit>
        <trans-unit id="3a6e431a73a626620ce066c3e9d4f31fda3acf08" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the string with those of &lt;code&gt;other&lt;/code&gt;. All iterators and references may be invalidated.</source>
          <target state="translated">文字列の内容を &lt;code&gt;other&lt;/code&gt; の内容と交換します。すべてのイテレータと参照が無効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a091ec29303367010ecc75278a112bbcdf30230b" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the sync stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">同期ストリームバッファの内容を &lt;code&gt;other&lt;/code&gt; ものと交換します。</target>
        </trans-unit>
        <trans-unit id="6582eb59d4c7d4d4f55d78fce8cfcf8c22bc4bb7" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of two regular expressions.</source>
          <target state="translated">2つの正規表現の内容を交換します。</target>
        </trans-unit>
        <trans-unit id="67e3c44b994c5e59c6fd36a93ede7ec7c8983289" translate="yes" xml:space="preserve">
          <source>Exchanges the given values.</source>
          <target state="translated">与えられた値を交換します。</target>
        </trans-unit>
        <trans-unit id="a2b38d8b13b6bc9e51339c32d2d13644d36846b9" translate="yes" xml:space="preserve">
          <source>Exchanges the internal states of the lock objects.</source>
          <target state="translated">ロック・オブジェクトの内部状態を交換します。</target>
        </trans-unit>
        <trans-unit id="7c072815ce7ddc6a4942335ae6ce9574b39ca082" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states and stored tasks of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の共有状態と保存されたタスクを交換します。</target>
        </trans-unit>
        <trans-unit id="8b12f471554dcab6c425a7585115003928398434" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two &lt;code&gt;match_results&lt;/code&gt; objects.</source>
          <target state="translated">2つの &lt;code&gt;match_results&lt;/code&gt; オブジェクトの共有状態を交換します。</target>
        </trans-unit>
        <trans-unit id="59d42fecea425bb592e078023cd032e5a993fe31" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two promise objects.</source>
          <target state="translated">2つのプロミスオブジェクトの共有状態を交換します。</target>
        </trans-unit>
        <trans-unit id="18b676510da12b57d475482111403500d0eaec7b" translate="yes" xml:space="preserve">
          <source>Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">交流の状態 &lt;code&gt;lhs&lt;/code&gt; のものと &lt;code&gt;rhs&lt;/code&gt; 。 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="f1b9970f1ef14caaf33f01eabd758b36bb1eff60" translate="yes" xml:space="preserve">
          <source>Exchanges the state of the stream with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">ストリームの状態を &lt;code&gt;other&lt;/code&gt; の状態と交換します。</target>
        </trans-unit>
        <trans-unit id="31ddf92acf4cafa84669771e5848a6787348f3e4" translate="yes" xml:space="preserve">
          <source>Exchanges the state with another input/output stream object. Effectively calls &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt;.</source>
          <target state="translated">状態を別の入出力ストリームオブジェクトと交換します。効果的に &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="d4b57df173bf97bd6ea27f8a30b30cea7df455a9" translate="yes" xml:space="preserve">
          <source>Exchanges the states of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, except for the associated &lt;code&gt;rdbuf&lt;/code&gt; objects. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;other.rdbuf()&lt;/code&gt; returns the same values as before the call.</source>
          <target state="translated">関連する &lt;code&gt;rdbuf&lt;/code&gt; オブジェクトを除いて、 &lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の状態を交換します。 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;other.rdbuf()&lt;/code&gt; は、呼び出し前と同じ値を返します。</target>
        </trans-unit>
        <trans-unit id="7057d033a604041b5eda100f7d1ff124d6f8a8db" translate="yes" xml:space="preserve">
          <source>Exchanges the stored callable objects of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; および &lt;code&gt;other&lt;/code&gt; の格納された呼び出し可能オブジェクトを交換します。</target>
        </trans-unit>
        <trans-unit id="d4dce99c5d1d30eb407da92e2d161ddb796ea801" translate="yes" xml:space="preserve">
          <source>Exchanges the underlying handles of two thread objects.</source>
          <target state="translated">2つのスレッドオブジェクトの基礎となるハンドルを交換します。</target>
        </trans-unit>
        <trans-unit id="4bec71ee58c3ce1a623ca2ef092eecb76d6de116" translate="yes" xml:space="preserve">
          <source>Exchanges the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; と &lt;code&gt;u&lt;/code&gt; によって参照される値を交換します。</target>
        </trans-unit>
        <trans-unit id="9a51b1fd2363fd0ca07531efcb4dd24feaa75b80" translate="yes" xml:space="preserve">
          <source>Exchanges the view with that of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">ビューを &lt;code&gt;v&lt;/code&gt; のビューと交換します。</target>
        </trans-unit>
        <trans-unit id="be6d66875d5906f7cae3a9398d5dbf1c7968e188" translate="yes" xml:space="preserve">
          <source>Exclusive locking</source>
          <target state="translated">専用ロック</target>
        </trans-unit>
        <trans-unit id="7f9696585c07b96ae418afaf36f528ec350cef50" translate="yes" xml:space="preserve">
          <source>Executable file format error</source>
          <target state="translated">実行可能なファイル形式のエラー</target>
        </trans-unit>
        <trans-unit id="9c973cb9f93e36abf91a1e9c23f91399e854d72a" translate="yes" xml:space="preserve">
          <source>Executes a for loop over a range.</source>
          <target state="translated">範囲内でforループを実行します。</target>
        </trans-unit>
        <trans-unit id="613b116d4f4f58b27e039a622ea9cf3d90eab7e4" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of condition becomes &lt;code&gt;false&lt;/code&gt;. The test takes place before each iteration.</source>
          <target state="translated">conditionの値が &lt;code&gt;false&lt;/code&gt; になるまで、ステートメントを繰り返し実行します。テストは各反復の前に行われます。</target>
        </trans-unit>
        <trans-unit id="fb5a19ea5e56f8a6995eea08fd4658f19b1ba739" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.</source>
          <target state="translated">式の値が偽になるまで、文を繰り返し実行します。テストは各反復の後に行われます。</target>
        </trans-unit>
        <trans-unit id="0c64270896df6b47ed0ab90cdaa2526a36293282" translate="yes" xml:space="preserve">
          <source>Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.</source>
          <target state="translated">init-statementを一度実行し、その後、条件の値がfalseになるまで、statementとiteration_expressionを繰り返し実行します。テストは各反復の前に行われます。</target>
        </trans-unit>
        <trans-unit id="64b4397dfd824f8172c44d1c4f9e248b16268c1c" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; exactly once, even if called concurrently, from several threads.</source>
          <target state="translated">複数のスレッドから&lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;オブジェクト &lt;code&gt;f&lt;/code&gt; を同時に実行する場合でも、1回だけ実行します。</target>
        </trans-unit>
        <trans-unit id="5241bfbf176faa293d6e52adf2a2d31791dc7d39" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; as if under a global lock: all outermost synchronized blocks in the program execute in a single total order. The end of each synchronized block synchronizes with the beginning of the next synchronized block in that order. Synchronized blocks that are nested within other synchronized blocks have no special semantics.</source>
          <target state="translated">実行&lt;a href=&quot;statements#Compound_statements&quot;&gt;複合文を&lt;/a&gt;グローバルロックの下にいるかのように：プログラムのすべての最も外側のsynchronizedブロックは、単一の全順序で実行されます。各同期ブロックの終わりは、次の同期ブロックの始まりとその順序で同期します。他の同期ブロック内にネストされている同期ブロックには、特別なセマンティクスはありません。</target>
        </trans-unit>
        <trans-unit id="fb88910ec6e8f148a726def306751bb61d10e009" translate="yes" xml:space="preserve">
          <source>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword &lt;code&gt;mutable&lt;/code&gt; was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this &lt;code&gt;operator()&lt;/code&gt;. The function-call operator is never volatile-qualified and never virtual.</source>
          <target state="translated">呼び出されたときに、ラムダ式の本体を実行します。変数にアクセスする場合、キャプチャされたコピー（コピーによってキャプチャされたエンティティの場合）、または元のオブジェクト（参照によってキャプチャされたエンティティの場合）にアクセスします。キーワード &lt;code&gt;mutable&lt;/code&gt; がラムダ式で使用されていない限り、関数呼び出し演算子はconst修飾され、コピーによってキャプチャされたオブジェクトは、この &lt;code&gt;operator()&lt;/code&gt; 内から変更できません。関数呼び出し演算子は、揮発性修飾されておらず、仮想化されていません。</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="de7349273ae9d07fc03da50e188f4f34b7d2aa3e" translate="yes" xml:space="preserve">
          <source>Execution policies</source>
          <target state="translated">実行ポリシー</target>
        </trans-unit>
        <trans-unit id="881673b7fc0425b71c75a900e8dd961e60da16d7" translate="yes" xml:space="preserve">
          <source>Exhausting memory in the pool causes the next allocation request for that pool to allocate an additional chunk of memory from the</source>
          <target state="translated">プール内のメモリを使い果たした場合、そのプールの次の割り当て要求は</target>
        </trans-unit>
        <trans-unit id="4d3a207c682e51fd0f76ac46376bd504dd04bb4b" translate="yes" xml:space="preserve">
          <source>Existing elements of &lt;code&gt;a&lt;/code&gt; are destroyed or assigned to</source>
          <target state="translated">既存の要素に破壊または割り当てられています &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">拡張値</target>
        </trans-unit>
        <trans-unit id="3a28add9450f041df1694bda9dbd7fe1ffe87170" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt; によって返される、1秒あたりのクロック刻み数に等しい &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; 型の式（必ずしもコンパイル時定数ではない）に展開します。</target>
        </trans-unit>
        <trans-unit id="a94ceb9709072dbc8a9721a63225f49eded59877" translate="yes" xml:space="preserve">
          <source>Expands to an expression which can be used to initialize an &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; object that can be initialized from &lt;code&gt;value&lt;/code&gt;. If the atomic object has static storage duration, this initialization is &lt;a href=&quot;../language/constant_initialization&quot;&gt;constant initialization&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; から初期化できる &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; オブジェクトの初期化に使用できる式に展開されます。アトミックオブジェクトに静的ストレージ期間がある場合、この初期化は&lt;a href=&quot;../language/constant_initialization&quot;&gt;定数初期化&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="de6a2f8e65def43ce5a852e140e79c980dade60d" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; によって返される最大値に等しい整数定数式に展開します。この値は実装に依存します。この値は少なくとも &lt;code&gt;32767&lt;/code&gt; であることが保証されています。</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">オーバーフローを示す正の &lt;code&gt;double&lt;/code&gt; 式に展開されますが、必ずしも &lt;code&gt;float&lt;/code&gt; として表現できるわけではありません</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">オーバーフローを示す正の &lt;code&gt;float&lt;/code&gt; 式に展開します</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">オーバーフローを示す正の &lt;code&gt;long double&lt;/code&gt; 式に展開されますが、必ずしも &lt;code&gt;float&lt;/code&gt; または &lt;code&gt;double&lt;/code&gt; として表現できるわけではありません</target>
        </trans-unit>
        <trans-unit id="bc198697dbf6af57511ca5dfb75efa170fb6388d" translate="yes" xml:space="preserve">
          <source>Expansion loci</source>
          <target state="translated">展開軌跡</target>
        </trans-unit>
        <trans-unit id="d9e0a488e53cfe7c390afb8b463eb5bb25a7cfba" translate="yes" xml:space="preserve">
          <source>Experimental libraries</source>
          <target state="translated">実験用ライブラリ</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="52641b8a40589b37d9770ba9ee57a29be108ded9" translate="yes" xml:space="preserve">
          <source>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</source>
          <target state="translated">部分特殊化のメンバの明示的な(完全な)特殊化は,主テンプレートの明示的な特殊化と同じように宣言されます.</target>
        </trans-unit>
        <trans-unit id="dd412ab552031cf5dc3a067286b0057cfec3dfe8" translate="yes" xml:space="preserve">
          <source>Explicit conversion from (possibly const) &lt;code&gt;fpos&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;. The result is the stored offset.</source>
          <target state="translated">（おそらくconst） &lt;code&gt;fpos&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; への明示的な変換。結果は保存されたオフセットです。</target>
        </trans-unit>
        <trans-unit id="1c63bca80feb759ba98d57e981b658fef25d5cce" translate="yes" xml:space="preserve">
          <source>Explicit instantiation</source>
          <target state="translated">明示的なインスタンス化</target>
        </trans-unit>
        <trans-unit id="4b142316d64b45cb4860439c17ed8cd8981f0aa9" translate="yes" xml:space="preserve">
          <source>Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:</source>
          <target state="translated">このような場合には、「このテンプレートを使用していない」ということになります。</target>
        </trans-unit>
        <trans-unit id="ee1fc799be568941add0e5c7edd28b1bd51ae960" translate="yes" xml:space="preserve">
          <source>Explicit instantiation declarations do not suppress the implicit instantiation of &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; functions, &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU).</source>
          <target state="translated">明示的なインスタンス化宣言は、&lt;a href=&quot;inline&quot;&gt;インライン&lt;/a&gt;関数、&lt;a href=&quot;auto&quot;&gt;自動&lt;/a&gt;宣言、参照、およびクラステンプレートの特殊化の暗黙的なインスタンス化を抑制しません。（したがって、明示的なインスタンス化宣言の対象であるインライン関数がODRで使用される場合、インライン化のために暗黙的にインスタンス化されますが、このTUでの行外コピーは生成されません）。</target>
        </trans-unit>
        <trans-unit id="572c84d2570e91de98df5fd413b0bd1a4670b56d" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definition of a function template with &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; is not a use of the arguments, and does not attempt to initialize them:</source>
          <target state="translated">&lt;a href=&quot;default_arguments&quot;&gt;デフォルトの引数&lt;/a&gt;を持つ関数テンプレートの明示的なインスタンス化定義は、引数の使用ではなく、それらを初期化しようとしません：</target>
        </trans-unit>
        <trans-unit id="0dcc010f6137a4796c623c315a5959bc45a20109" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</source>
          <target state="translated">明示的なインスタンス化定義では、メンバ・アクセス指定子を無視します。</target>
        </trans-unit>
        <trans-unit id="65478c257174b4e3c09ba657cd00b83b6bf1640b" translate="yes" xml:space="preserve">
          <source>Explicit instantiation has no effect if an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; appeared before for the same set of template arguments.</source>
          <target state="translated">同じテンプレート引数のセットに対して前に&lt;a href=&quot;template_specialization&quot;&gt;明示的な特殊&lt;/a&gt;化が現れた場合、明示的なインスタンス化は効果がありません。</target>
        </trans-unit>
        <trans-unit id="d36a0cc2732df089c694dc98284a6d85796f30ad" translate="yes" xml:space="preserve">
          <source>Explicit instantiation of a function template or of a member function of a class template cannot use &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;constexpr&lt;/code&gt;. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.</source>
          <target state="translated">関数テンプレートまたはクラステンプレートのメンバー関数の明示的なインスタンス化では、 &lt;code&gt;inline&lt;/code&gt; または &lt;code&gt;constexpr&lt;/code&gt; を使用できません。明示的なインスタンス化の宣言が暗黙的に宣言された特別なメンバー関数を指定している場合、プログラムは不正な形式です。</target>
        </trans-unit>
        <trans-unit id="30c811d49cc758004cfc53fc79ee65d4652de860" translate="yes" xml:space="preserve">
          <source>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).</source>
          <target state="translated">概念の明示的なインスタンス化、明示的な特殊化、または部分的な特殊化は許可されていません(制約の元の定義の意味を変更することはできません)。</target>
        </trans-unit>
        <trans-unit id="2e55319f81d1a852746aa5972684208a80ae6770" translate="yes" xml:space="preserve">
          <source>Explicit specialization</source>
          <target state="translated">明示的な特殊化</target>
        </trans-unit>
        <trans-unit id="593deb78caf931f5a8926f7968637e3804e9bc2d" translate="yes" xml:space="preserve">
          <source>Explicit specialization may be declared in any scope where its primary template may be defined (which may be different from the scope where the primary template is defined; such as with out-of-class specialization of a &lt;a href=&quot;member_template&quot;&gt;member template&lt;/a&gt;) . Explicit specialization has to appear after the non-specialized template declaration.</source>
          <target state="translated">明示的な特殊化は、そのプライマリテンプレートを定義できるスコープで宣言できます（これは、プライマリテンプレートが定義されているスコープとは異なる場合があります。&lt;a href=&quot;member_template&quot;&gt;メンバーテンプレートの&lt;/a&gt;クラス外の特殊化など）。明示的な特殊化は、特殊化されていないテンプレート宣言の後に表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="8870f1f0b78d6b643054caef6f197e66cbb50dc0" translate="yes" xml:space="preserve">
          <source>Explicit specializations of function templates</source>
          <target state="translated">関数テンプレートの明示的な特殊化</target>
        </trans-unit>
        <trans-unit id="d9b457bfa7e9dfdb8f202a1cfd0b13910b32a1d1" translate="yes" xml:space="preserve">
          <source>Explicit template argument lists may not be specified when calling any of them.</source>
          <target state="translated">明示的なテンプレート引数リストは、いずれかを呼び出す際に指定できない場合があります。</target>
        </trans-unit>
        <trans-unit id="901409defb65997b43ccf96e53d877ad8c4540d5" translate="yes" xml:space="preserve">
          <source>Explicit template arguments</source>
          <target state="translated">明示的なテンプレート引数</target>
        </trans-unit>
        <trans-unit id="4431a5f6720c93927b4ab9fdd98f9a2ec4e9c49f" translate="yes" xml:space="preserve">
          <source>Explicit template instantiation</source>
          <target state="translated">明示的なテンプレートのインスタンス化</target>
        </trans-unit>
        <trans-unit id="0fab44e233e42157cd5dea76fd8cf3c8b9d7adc5" translate="yes" xml:space="preserve">
          <source>Explicit template specialization</source>
          <target state="translated">明示的なテンプレートの特殊化</target>
        </trans-unit>
        <trans-unit id="efc7df6ee447c5edc7f6c07135ad3f5023dea6a8" translate="yes" xml:space="preserve">
          <source>Explicit type conversion</source>
          <target state="translated">明示的な型変換</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">指数関数</target>
        </trans-unit>
        <trans-unit id="af9874c4957d8cd8c01ba533edd025cf4c27e381" translate="yes" xml:space="preserve">
          <source>Exposes class &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a method of accessing individual bits. In particular, objects of this class are returned by &lt;a href=&quot;vector/operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt; by value.</source>
          <target state="translated">個々のビットにアクセスする方法として、クラス &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; を公​​開します。特に、このクラスのオブジェクトは、&lt;a href=&quot;vector/operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt;によって値によって返されます。</target>
        </trans-unit>
        <trans-unit id="386b8e5c19a5d25975c5d960c8d6889b5c0e7456" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; の共通タイプであるtypeという名前の &lt;code&gt;type&lt;/code&gt; を公​​開します。</target>
        </trans-unit>
        <trans-unit id="81c630945113fb74890dbe59b04840a67c663c1b" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; の共通タイプであるtypeという名前の &lt;code&gt;type&lt;/code&gt; を公​​開します。</target>
        </trans-unit>
        <trans-unit id="dde7602ac0e3b525fda01f2a33c67f49539ca405" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel (typically either a number, for a bounded iota view, or an instance of &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; for an unbounded iota view.</source>
          <target state="translated">センチネルを保持する公開専用のデータメンバー（通常は、制限されたiotaビューの場合は数値、非制限のiotaビューの場合は &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; インスタンスのいずれか）。</target>
        </trans-unit>
        <trans-unit id="cf2a2572c2908ed7f54343df2e7969e31bec570b" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel of the underlying &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基になる&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; の&lt;/a&gt;標識を保持する、説明専用のデータメンバー。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="41e32832dbe3b76f5e8fc2a5f15b3848cf05e235" translate="yes" xml:space="preserve">
          <source>Expression SFINAE</source>
          <target state="translated">式 SFINAE</target>
        </trans-unit>
        <trans-unit id="833207cd0a28197ca9f0d233e80f2413b069f412" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;) and may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; prints the character &lt;code&gt;'4'&lt;/code&gt; on the standard output).</source>
          <target state="translated">式の評価は結果を生成し（たとえば、 &lt;code&gt;2+2&lt;/code&gt; の評価は結果 &lt;code&gt;4&lt;/code&gt; を生成）、副作用を生成する可能性があります（たとえば、 &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; は、文字 &lt;code&gt;'4'&lt;/code&gt; を標準に出力します出力）。</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">表現文</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd7f69f355486bcb0814ab9e5cf3b7318931dffa" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;static_assert&lt;/code&gt;</source>
          <target state="translated">拡張 &lt;code&gt;static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85f5fa538ad73dc2c1cf60d6bcfc4288cb6d221b" translate="yes" xml:space="preserve">
          <source>Extending memory management tools</source>
          <target state="translated">メモリ管理ツールの拡張</target>
        </trans-unit>
        <trans-unit id="446e27d8fc1178607fbaea2ba6117c2bee0e3166" translate="yes" xml:space="preserve">
          <source>Extending the namespace std</source>
          <target state="translated">名前空間 std</target>
        </trans-unit>
        <trans-unit id="e73f93d7fc042bb05945a0bc48fe3f9f81efe46b" translate="yes" xml:space="preserve">
          <source>Extension to &lt;a href=&quot;language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/aggregate_initialization&quot;&gt;初期化&lt;/a&gt;を集約する拡張機能</target>
        </trans-unit>
        <trans-unit id="9d6e9863adde877292363ab102515ca7b6ccafb6" translate="yes" xml:space="preserve">
          <source>Extensions for &lt;code&gt;std::future&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::future&lt;/code&gt; 拡張</target>
        </trans-unit>
        <trans-unit id="71a1260f76544c68e3425a1c076e5499b0002fbb" translate="yes" xml:space="preserve">
          <source>Extent</source>
          <target state="translated">Extent</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">外部リンク</target>
        </trans-unit>
        <trans-unit id="a1aea7fedb01b55857a374fd355fdb3f3d76821e" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">ノードを抽出すると、抽出された要素へのイテレータのみが無効になり、消去されない要素の相対的な順序が保持されます。抽出された要素へのポインタや参照は有効ですが、要素がノード・ハンドルによって所有されている間は使用できません。</target>
        </trans-unit>
        <trans-unit id="b5485507a535a08d29060699bc1ba26e5fbec017" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">ノードを抽出すると、抽出された要素へのイテレータは無効になります。抽出された要素へのポインタや参照は有効ですが、要素がノードハンドルによって所有されている間は使用できません。</target>
        </trans-unit>
        <trans-unit id="b15d94524be33e2064c90d0f8c997adad64d1ab7" translate="yes" xml:space="preserve">
          <source>Extracting a single character that is the last character of the stream does not set &lt;code&gt;eofbit&lt;/code&gt;: this is different from other formatted input functions, such as extracting the last integer with &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, but this behavior matches the behavior of &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;%c&quot;&lt;/code&gt; format specifier.</source>
          <target state="translated">ストリームの最後の文字である単一の文字を抽出しても、 &lt;code&gt;eofbit&lt;/code&gt; は設定されません。これは、 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; で最後の整数を抽出するなど、他のフォーマットされた入力関数とは異なりますが、この動作は &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 動作と &lt;code&gt;&quot;%c&quot;&lt;/code&gt; フォーマット指定子。</target>
        </trans-unit>
        <trans-unit id="77a2197986a0f5813101a331f598cfcb85a220fb" translate="yes" xml:space="preserve">
          <source>Extracts an element from the pair using tuple-like interface.</source>
          <target state="translated">タプルのようなインターフェースを使ってペアから要素を抽出します。</target>
        </trans-unit>
        <trans-unit id="ef0ddc3034770dba9709a96861d6340f80bd0470" translate="yes" xml:space="preserve">
          <source>Extracts and discards characters from the input stream until and including &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delim&lt;/code&gt; を含むまで、入力ストリームから文字を抽出して破棄します。</target>
        </trans-unit>
        <trans-unit id="c16944c77e932413c2253839ec882702fb001de1" translate="yes" xml:space="preserve">
          <source>Extracts character or characters from stream.</source>
          <target state="translated">ストリームから文字または文字を抽出します。</target>
        </trans-unit>
        <trans-unit id="a68c11784d768fd75f5143a08580523eaca81d6d" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream until end of line or the specified delimiter &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">行の終わりまで、または指定された区切り文字 &lt;code&gt;delim&lt;/code&gt; まで、ストリームから文字を抽出します。</target>
        </trans-unit>
        <trans-unit id="b0ac0f2a82fe93a443fa08ceb0fe622f9ece3c06" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream.</source>
          <target state="translated">ストリームから文字を抽出します。</target>
        </trans-unit>
        <trans-unit id="7649df41de72e363648c6e8cac8be1f6dc3a552f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;Ith&lt;/code&gt; element element from the array.</source>
          <target state="translated">配列から &lt;code&gt;Ith&lt;/code&gt; 要素elementを抽出します。</target>
        </trans-unit>
        <trans-unit id="44b2e430b2cfaf879035a796088aa41b5223f736" translate="yes" xml:space="preserve">
          <source>Extracts the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;regex_iterator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; から現在のstd :: match_resultsを抽出し &lt;code&gt;regex_iterator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b56e81381fa5a47e6b3ea3eb1d488fda4cab62e7" translate="yes" xml:space="preserve">
          <source>Extracts up to &lt;code&gt;count&lt;/code&gt; immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">入力ストリームからすぐに利用可能な文字を最大 &lt;code&gt;count&lt;/code&gt; まで抽出します。抽出された文字は、 &lt;code&gt;s&lt;/code&gt; が指す文字配列に格納されます。</target>
        </trans-unit>
        <trans-unit id="e72ac13e9cd4d6af9eb70d5cf0e07a1000b3c95a" translate="yes" xml:space="preserve">
          <source>F is sequenced-before X in thread A</source>
          <target state="translated">スレッド A で X よりも前に F がシーケンスされます。</target>
        </trans-unit>
        <trans-unit id="7baf4c10d15dfb9c6bb605f66aef033fa6c6e2a5" translate="yes" xml:space="preserve">
          <source>FA is sequenced-before X in thread A</source>
          <target state="translated">FAはスレッドAのXの前にシーケンスされています。</target>
        </trans-unit>
        <trans-unit id="ee8392aac4b3ee280362ef5273dcbf0dce3c5592" translate="yes" xml:space="preserve">
          <source>FEMININE ORDINAL INDICATOR</source>
          <target state="translated">じょせいめいしすう</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">fp_normal,fp_subnormal,fp_zero,fp_infinite,fp_nan</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="8c6c7c8ebbe0f69f73a317ea017f66dfe215ff4a" translate="yes" xml:space="preserve">
          <source>Facet categories</source>
          <target state="translated">ファセットカテゴリ</target>
        </trans-unit>
        <trans-unit id="041a83e17c0f537ae2ed62d3b2cdf6826e396193" translate="yes" xml:space="preserve">
          <source>Facet category base classes</source>
          <target state="translated">ファセットカテゴリ基本クラス</target>
        </trans-unit>
        <trans-unit id="b533c7fea0c500ba4ef293884991083e32ec4a68" translate="yes" xml:space="preserve">
          <source>Facets with the same &lt;code&gt;id&lt;/code&gt; belong to the same facet category and replace each other when added to a locale object.</source>
          <target state="translated">同じ &lt;code&gt;id&lt;/code&gt; ファセットは同じファセットカテゴリに属し、ロケールオブジェクトに追加されると互いに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="66908b176ccb4f40a6f1a10938d28a50727305a6" translate="yes" xml:space="preserve">
          <source>Factor operations</source>
          <target state="translated">因子操作</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="ce6c5bc258e8bef5e3ae59b1338a20c4748ea8d2" translate="yes" xml:space="preserve">
          <source>Failure to open</source>
          <target state="translated">開封の失敗</target>
        </trans-unit>
        <trans-unit id="d3051aec047cdd51e6d43d2664a5df396a9877fb" translate="yes" xml:space="preserve">
          <source>Failures to meet the postconditions, such as failing to produce a valid return value object</source>
          <target state="translated">有効な戻り値オブジェクトの生成に失敗するなど、事後条件を満たさなかった場合</target>
        </trans-unit>
        <trans-unit id="3914bd46dc4687d6b7087f5c008acc618475cc00" translate="yes" xml:space="preserve">
          <source>Failures to meet the preconditions of another function that must be called</source>
          <target state="translated">呼び出されなければならない別の関数の前提条件を満たしていない</target>
        </trans-unit>
        <trans-unit id="c29752c93447e11b1a890d7ac78a70435ca5bdb4" translate="yes" xml:space="preserve">
          <source>Fancy pointers</source>
          <target state="translated">ファンシーポイント</target>
        </trans-unit>
        <trans-unit id="b494fef582ccfffefb54575ea4e577f7dbaf26c1" translate="yes" xml:space="preserve">
          <source>Fast access but fixed number of elements</source>
          <target state="translated">高速アクセスが可能だが、要素数は固定</target>
        </trans-unit>
        <trans-unit id="24dd69ccc43e1ae6d5f5a742d02f0da0f6b32305" translate="yes" xml:space="preserve">
          <source>Fast access but mostly inefficient insertions/deletions</source>
          <target state="translated">高速アクセスだが、ほとんどが非効率的な挿入削除</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="0775fb360f01bab977ed5ec997840be1f65f3719" translate="yes" xml:space="preserve">
          <source>Feature testing</source>
          <target state="translated">機能テスト</target>
        </trans-unit>
        <trans-unit id="9fe9f4b9291746b85204d55ff6be73414f9570ac" translate="yes" xml:space="preserve">
          <source>Feature testing (C++20)</source>
          <target state="translated">機能テスト(C++20</target>
        </trans-unit>
        <trans-unit id="bc0228c9de8004fdac6db7743fdd23e61859a392" translate="yes" xml:space="preserve">
          <source>Fence-atomic synchronization</source>
          <target state="translated">フェンス-原子同期</target>
        </trans-unit>
        <trans-unit id="c0f00371ddb6eac35be65eb720b3cab89de6182d" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization</source>
          <target state="translated">柵と柵の同期</target>
        </trans-unit>
        <trans-unit id="e79120c3392d8a2111f0e85788e61d24a2973100" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example.</source>
          <target state="translated">柵-柵同期は、例えば、いくつかの緩和された原子演算のシーケンスに同期を追加するために使用することができる。</target>
        </trans-unit>
        <trans-unit id="9d413b1e7e21f8acf4d5ba31c56b61a1a190cf03" translate="yes" xml:space="preserve">
          <source>File I/O implementation</source>
          <target state="translated">ファイル IO 実装</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">ファイルアクセス</target>
        </trans-unit>
        <trans-unit id="ecbca940d8a1676fb3cfcf517eb3d1e3e48574ec" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;in binary mode&lt;/a&gt;. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">ファイルアクセスモードフラグ &lt;code&gt;&quot;b&quot;&lt;/code&gt; をオプションで指定して、&lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;バイナリモードで&lt;/a&gt;ファイルを開くことができます。このフラグはPOSIXシステムには影響しませんが、たとえばWindowsでは &lt;code&gt;'\n'&lt;/code&gt; および &lt;code&gt;'\x1A'&lt;/code&gt; 特別な処理を無効にします。</target>
        </trans-unit>
        <trans-unit id="9675879f138420dc849c3b02c7a08a45f1764ce0" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17)</source>
          <target state="translated">ファイルアクセスモードフラグ &lt;code&gt;&quot;x&quot;&lt;/code&gt; は、オプションで &quot;w&quot;または &quot;w +&quot;指定子に追加できます。このフラグは、ファイルが存在する場合、ファイルを上書きする代わりに、関数を強制的に失敗させます。（C ++ 17）</target>
        </trans-unit>
        <trans-unit id="848538ee54491f003e342600d6426cc1665c1d90" translate="yes" xml:space="preserve">
          <source>File descriptor value too large</source>
          <target state="translated">ファイル記述子の値が大きすぎる</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">ファイルが存在する</target>
        </trans-unit>
        <trans-unit id="64fd779c46cf2d931941b36cb1e56f079e1d6e2c" translate="yes" xml:space="preserve">
          <source>File operations</source>
          <target state="translated">ファイル操作</target>
        </trans-unit>
        <trans-unit id="0b24f6042e86aadda1815101f042d04954349481" translate="yes" xml:space="preserve">
          <source>File owner has execute/search permission</source>
          <target state="translated">ファイルの所有者はexecutesearch許可を得ています。</target>
        </trans-unit>
        <trans-unit id="1a3e84e64dd01307f0ee39195f923bfa54b5c0c6" translate="yes" xml:space="preserve">
          <source>File owner has read permission</source>
          <target state="translated">ファイルの所有者は、読み取り許可を得ています。</target>
        </trans-unit>
        <trans-unit id="00a45fcb3c463f25a9813f51c216665d3293d7ab" translate="yes" xml:space="preserve">
          <source>File owner has read, write, and execute/search permissions</source>
          <target state="translated">ファイルの所有者は、読み取り、書き込み、およびexecutesearchのパーミッションを持っています。</target>
        </trans-unit>
        <trans-unit id="01358bbedd5677b98189c5d53b33f357f182c488" translate="yes" xml:space="preserve">
          <source>File owner has write permission</source>
          <target state="translated">ファイルの所有者は書き込み許可を得ています</target>
        </trans-unit>
        <trans-unit id="1a996ddad7a713856017f5f90fe0498db20bdbda" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;-1L&lt;/code&gt; if failure occurs. Also sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">成功した場合のファイル位置インジケータ。失敗した場合は &lt;code&gt;-1L&lt;/code&gt; 。失敗時には &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; も設定します。</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">ファイルの配置</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">ファイルほうき</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">ファイルが大きすぎる</target>
        </trans-unit>
        <trans-unit id="0205534386e03d869079430b7c0117e9af5229d7" translate="yes" xml:space="preserve">
          <source>File types</source>
          <target state="translated">ファイルの種類</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">ファイル名と行情報</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">ファイル名が長すぎる</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="bbc4c49f164b158dbe825399e8316a41a98039c5" translate="yes" xml:space="preserve">
          <source>Filesystem TS</source>
          <target state="translated">ファイルシステム TS</target>
        </trans-unit>
        <trans-unit id="f6adde9d94ef3f9818beca92c4fb5775d3d08a90" translate="yes" xml:space="preserve">
          <source>Filesystem library</source>
          <target state="translated">ファイルシステムライブラリ</target>
        </trans-unit>
        <trans-unit id="d6016e126bb1261237244c868e871626e1164a78" translate="yes" xml:space="preserve">
          <source>Fills [&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt;) with 32-bit quantities depending on the initial supplied values and potential previous calls to &lt;code&gt;generate&lt;/code&gt;. If &lt;code&gt;rb == re&lt;/code&gt;, it does nothing.</source>
          <target state="translated">[ &lt;code&gt;rb&lt;/code&gt; 、 &lt;code&gt;re&lt;/code&gt; ]を、 &lt;code&gt;generate&lt;/code&gt; された初期の提供された値と潜在的な以前の呼び出しに応じて32ビット量で埋めます。 &lt;code&gt;rb == re&lt;/code&gt; 場合、何もしません。</target>
        </trans-unit>
        <trans-unit id="0477adab8010ca288bf22b1b3deddefba747b42d" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[begin, end)&lt;/code&gt; with unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">範囲 &lt;code&gt;[begin, end)&lt;/code&gt; を符号なし整数値 &lt;code&gt;i&lt;/code&gt; 、0&amp;le;i &amp;lt;232で埋めます</target>
        </trans-unit>
        <trans-unit id="da2860ae65231144c9442af16b999bbb60810f8b" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[first, last)&lt;/code&gt; with sequentially increasing values, starting with &lt;code&gt;value&lt;/code&gt; and repetitively evaluating &lt;code&gt;++value&lt;/code&gt;.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; を、 &lt;code&gt;value&lt;/code&gt; から開始して &lt;code&gt;++value&lt;/code&gt; を繰り返し評価しながら、順次増加する値で埋めます。</target>
        </trans-unit>
        <trans-unit id="ae117132b523ad7bbcabf063e4512b94303ad825" translate="yes" xml:space="preserve">
          <source>Final classes cannot be used as base classes.</source>
          <target state="translated">最終クラスを基底クラスとして使用することはできません。</target>
        </trans-unit>
        <trans-unit id="f71bda78a1e6997b4c579d61039ab383458a0b93" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; is called, and its result is the result of the whole &lt;code&gt;co_await expr&lt;/code&gt; expression.</source>
          <target state="translated">最後に、 &lt;code&gt;awaiter.await_resume()&lt;/code&gt; が呼び出され、その結果は &lt;code&gt;co_await expr&lt;/code&gt; 式全体の結果です。</target>
        </trans-unit>
        <trans-unit id="4db4903bd597b61dd8a328899682e291be0a76a1" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;is.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最後に、 &lt;code&gt;is.width(0)&lt;/code&gt; を呼び出して、 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 影響があればキャンセルします。</target>
        </trans-unit>
        <trans-unit id="9e4015259c16ae5de63c7894d2c7b391c4ca0b80" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;os.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最後に、 &lt;code&gt;os.width(0)&lt;/code&gt; を呼び出して、 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 影響があればキャンセルします。</target>
        </trans-unit>
        <trans-unit id="177dc3f32e13dff30c58fffec60fe61e244cc93e" translate="yes" xml:space="preserve">
          <source>Finally, outputs each character from the resulting sequence as if by calling &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; and &lt;code&gt;out.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最後に、 &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 呼び出すかのように、結果のシーケンスから各文字を出力します。ここで、 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; および &lt;code&gt;out.width(0)&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 影響をキャンセルします（存在する場合）。</target>
        </trans-unit>
        <trans-unit id="00d858cc8e88f691053b3dcc6137ac4cde6d6ced" translate="yes" xml:space="preserve">
          <source>Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes each and must be partitioned with respect to the object pointed to by &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; が指す配列内の &lt;code&gt;key&lt;/code&gt; が指す要素と等しい要素を検索します。配列には、 &lt;code&gt;size&lt;/code&gt; それぞれバイトの &lt;code&gt;count&lt;/code&gt; 個の要素が含まれており、 &lt;code&gt;key&lt;/code&gt; が指すオブジェクトに関してパーティション化する必要があります。つまり、より小と比較するすべての要素は、等しいと比較するすべての要素の前に出現し、すべての要素の前に出現しなければなりません。キーオブジェクトよりも大きい要素。完全にソートされた配列はこれらの要件を満たします。要素は &lt;code&gt;comp&lt;/code&gt; が指す関数を使用して比較されます。</target>
        </trans-unit>
        <trans-unit id="e9927a1e661f4bfd80aaf31b22f6f41e30e9b227" translate="yes" xml:space="preserve">
          <source>Finds real roots of multiple quadratic equations.</source>
          <target state="translated">複数の二次方程式の実根を求めます。</target>
        </trans-unit>
        <trans-unit id="30bcbdf5d9a1fe0bd647e009803f909f56efc575" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to any of the characters in the given character sequence.</source>
          <target state="translated">指定された文字列のいずれかの文字と等しい最初の文字を見つけます。</target>
        </trans-unit>
        <trans-unit id="5cdb4e092b97109f8b2048be07ca72c3bde0609f" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">指定された文字シーケンスのどの文字とも等しくない最初の文字を検索します。検索では、間隔[ &lt;code&gt;pos&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ）のみが考慮されます。文字が間隔内に存在しない場合、 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="24f9fbec876cfd13c75d96d81a6a74110daac9d5" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">指定された文字シーケンスの文字の1つに等しい最初の文字を検索します。検索では、間隔[ &lt;code&gt;pos&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ）のみが考慮されます。文字が間隔内に存在しない場合、 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; が指すワイド文字列、つまり &lt;code&gt;str&lt;/code&gt; が指すワイド文字列の最初の文字を検索します。</target>
        </trans-unit>
        <trans-unit id="981d0030e7019507414199bd0e078d7265cd8673" translate="yes" xml:space="preserve">
          <source>Finds the first character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">指定された文字列のいずれの文字とも一致しない最初の文字を見つけます。</target>
        </trans-unit>
        <trans-unit id="c744c8fe55a01d138ec8c24e1528aec65ec2023a" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the byte string &lt;code&gt;target&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すバイト文字列内で最初に出現するバイト文字列 &lt;code&gt;target&lt;/code&gt; を検索します。終端のnull文字は比較されません。</target>
        </trans-unit>
        <trans-unit id="822e0508dd7e5034ad40e0d29a486e2402585a0d" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the character &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すバイト文字列で最初に出現する文字 &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; を検索します。</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すワイド文字列でワイド文字 &lt;code&gt;ch&lt;/code&gt; が最初に出現する場所を見つけます。</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; が指すワイド文字列でワイド文字列 &lt;code&gt;src&lt;/code&gt; が最初に出現する場所を検索します。終端のnull文字は比較されません。</target>
        </trans-unit>
        <trans-unit id="fc71329dcb9337103dd5851e9eb7dfa903cd2767" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence.</source>
          <target state="translated">与えられた文字列と等しい最初の部分文字列を見つけます。</target>
        </trans-unit>
        <trans-unit id="73d8f05c9748bf0bddfc6937b1e51af871f089f0" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position preceding &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">指定された文字シーケンスに等しい最初の部分文字列を検索します。つまり、検索は &lt;code&gt;pos&lt;/code&gt; から始まります。つまり、見つかった部分文字列は &lt;code&gt;pos&lt;/code&gt; の前の位置で始まってはなりません。</target>
        </trans-unit>
        <trans-unit id="d519b8e547c2fea611a706cf0f567de8c481f047" translate="yes" xml:space="preserve">
          <source>Finds the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 範囲で最大の要素を見つけます。</target>
        </trans-unit>
        <trans-unit id="2a0eba935882bc5c40f3eb57edca9ffaa6207e17" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">指定された文字シーケンスのどの文字とも等しくない最後の文字を検索します。検索では、間隔[0、pos]のみが考慮されます。文字が間隔内に存在しない場合、 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="031b5bc7f5b52d9b68f531ec16e07add0732f8a9" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">指定された文字シーケンスのいずれかの文字に等しい最後の文字を検索します。正確な検索アルゴリズムは指定されていません。検索では、間隔[0; pos]。文字が間隔内に存在しない場合、 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="262672fc83487a5e2f2a3a72605026935426490e" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">指定された文字シーケンスのいずれかの文字に等しい最後の文字を検索します。正確な検索アルゴリズムは指定されていません。検索では、間隔[0、pos]のみが考慮されます。文字が間隔内に存在しない場合、 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c2eeb42fd9c4368ca6e261a7eaf0eb9173c9ca19" translate="yes" xml:space="preserve">
          <source>Finds the last character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">指定された文字列のいずれの文字とも一致しない最後の文字を見つけます。</target>
        </trans-unit>
        <trans-unit id="c9e927921904e1bd8a7847a95ec12dfc3ed90fd5" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt;) in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すバイト文字列内で最後に出現する &lt;code&gt;ch&lt;/code&gt; を検索します（ &lt;code&gt;char&lt;/code&gt; に変換した後）。終端のnull文字は文字列の一部と見なされ、 &lt;code&gt;'\0'&lt;/code&gt; 検索すると見つかります。</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すワイド文字列内のワイド文字 &lt;code&gt;ch&lt;/code&gt; の最後の出現を検索します。</target>
        </trans-unit>
        <trans-unit id="aba2a0477e061745abafbf2e570698649cfbd049" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence.</source>
          <target state="translated">与えられた文字列と等しい最後の部分文字列を見つけます。</target>
        </trans-unit>
        <trans-unit id="85ecfa172af6c676f0f2b7ede4563bdf54dbd13d" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position following &lt;code&gt;pos&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; or any value not smaller than &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;-1 is passed as &lt;code&gt;pos&lt;/code&gt;, whole string will be searched.</source>
          <target state="translated">指定された文字シーケンスと等しい最後の部分文字列を検索します。つまり、検索は &lt;code&gt;pos&lt;/code&gt; から始まります。つまり、見つかった部分文字列は &lt;code&gt;pos&lt;/code&gt; に続く位置から始めてはなりません。場合 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; またはより小さくない任意の値 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; -1として渡され &lt;code&gt;pos&lt;/code&gt; 、文字列全体が検索されます。</target>
        </trans-unit>
        <trans-unit id="4e96707b2590ca4719626a87f0675c2693cd9371" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すnullで終了するバイト文字列で次のトークンを検索します。区切り文字は、 &lt;code&gt;delim&lt;/code&gt; が指すnullで終了するバイト文字列によって識別されます。</target>
        </trans-unit>
        <trans-unit id="380ef08d0f8e6c7597e5b529abb1fb2b2ba51aa4" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が指すnullで終了するワイド文字列で次のトークンを検索します。区切り文字は、 &lt;code&gt;delim&lt;/code&gt; が指すnullで終了するワイド文字列によって識別されます。</target>
        </trans-unit>
        <trans-unit id="59f9527a2060df058f520ec4facfb5d116cfb5ab" translate="yes" xml:space="preserve">
          <source>Finds the smallest and greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 範囲で最小および最大の要素を検索します。</target>
        </trans-unit>
        <trans-unit id="73f7ebc728f72e9244fbcb71e4bebffbcaa8c095" translate="yes" xml:space="preserve">
          <source>Finds the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 範囲で最小の要素を見つけます。</target>
        </trans-unit>
        <trans-unit id="fb4718767cbeb7ec2a4050ea8b0704c79bba10d8" translate="yes" xml:space="preserve">
          <source>First clears &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最初に&lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; を&lt;/a&gt;クリアします。</target>
        </trans-unit>
        <trans-unit id="c779ca82cc21b768cc6c4bcc4f1d87107bdb7d29" translate="yes" xml:space="preserve">
          <source>First clears &lt;code&gt;eofbit&lt;/code&gt;, then behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;rdbuf()&lt;/code&gt; is not null, calls &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt;, which calls &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; if &lt;code&gt;ch&lt;/code&gt; does not equal the most recently extracted character.</source>
          <target state="translated">最初に &lt;code&gt;eofbit&lt;/code&gt; をクリアし、次に&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;として動作します。構築した場合、歩哨のオブジェクトを確認した後 &lt;code&gt;rdbuf()&lt;/code&gt; nullでない、呼び出す &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt; 呼び出す、 &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; 場合 &lt;code&gt;ch&lt;/code&gt; が最近抽出された文字が等しくありません。</target>
        </trans-unit>
        <trans-unit id="13f51e93c18a65140da3cb2cb1dfab78c49243a0" translate="yes" xml:space="preserve">
          <source>First destroys the current contained object (if any) by &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt;, then:</source>
          <target state="translated">最初に、現在含まれているオブジェクト（存在する場合）を &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; によって破棄し、次に：</target>
        </trans-unit>
        <trans-unit id="401e859548baba3ec799317e533e96d7551f1830" translate="yes" xml:space="preserve">
          <source>First version</source>
          <target state="translated">最初のバージョン</target>
        </trans-unit>
        <trans-unit id="1654933a6fa4f43716580ffeb045cae1b208fe38" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;implicit_cast&quot;&gt;Pointer conversions&lt;/a&gt; (pointer to member conversions if the arguments are pointers to members), function pointer conversions,(since C++17) and &lt;a href=&quot;implicit_cast&quot;&gt;qualification conversions&lt;/a&gt; are applied to both operands to obtain the</source>
          <target state="translated">最初に、&lt;a href=&quot;implicit_cast&quot;&gt;ポインター変換&lt;/a&gt;（引数がメンバーへのポインターの場合はメンバーへのポインター変換）、関数ポインター変換（C ++ 17以降）、および&lt;a href=&quot;implicit_cast&quot;&gt;修飾変換&lt;/a&gt;が両方のオペランドに適用され、</target>
        </trans-unit>
        <trans-unit id="30c242bb4e4e1c97688da86303f8e70ebf723f0f" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;long&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;long&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">最初に、プライベートストレージ（ &lt;code&gt;long&lt;/code&gt; または別のインデックス可能なデータ構造の動的配列）を十分に割り当てまたはサイズ変更して、 &lt;code&gt;index&lt;/code&gt; を有効なインデックスにし、次にインデックス &lt;code&gt;index&lt;/code&gt; を持つプライベートストレージの &lt;code&gt;long&lt;/code&gt; 要素への参照を返します。</target>
        </trans-unit>
        <trans-unit id="c741d459f4a943d6ccb7e91f1d19877e2b46cf15" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;void*&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;void*&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">最初に、プライベートストレージ（ &lt;code&gt;void*&lt;/code&gt; または別のインデックス可能なデータ構造の動的配列）を十分に割り当てまたはサイズ変更して、 &lt;code&gt;index&lt;/code&gt; を有効なインデックスにし、次にインデックス &lt;code&gt;index&lt;/code&gt; を持つプライベートストレージの &lt;code&gt;void*&lt;/code&gt; 要素への参照を返します。</target>
        </trans-unit>
        <trans-unit id="f1a406a5e11adcba583e47ceded69c0a59895e04" translate="yes" xml:space="preserve">
          <source>First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;fopen&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">まず、エラーを無視して、 &lt;code&gt;stream&lt;/code&gt; に関連付けられたファイルを閉じようとします。次に、 &lt;code&gt;filename&lt;/code&gt; がnullでない場合、filenameで指定された &lt;code&gt;filename&lt;/code&gt; を &lt;code&gt;fopen&lt;/code&gt; と同じように &lt;code&gt;mode&lt;/code&gt; を使用して開こうとし、そのファイルをstreamが指すファイルストリームに関連付け &lt;code&gt;stream&lt;/code&gt; 。場合 &lt;code&gt;filename&lt;/code&gt; ヌルポインタで、この関数の試みがすでに関連付けられているファイルを再び開くために &lt;code&gt;stream&lt;/code&gt; （それがモード変更は、この場合、許可されている定義された実装です）。</target>
        </trans-unit>
        <trans-unit id="5badc51c36e2585292a914e3f1823ec376257caf" translate="yes" xml:space="preserve">
          <source>First, before doing anything else, obtains type and permissions of &lt;code&gt;from&lt;/code&gt; by no more than a single call to</source>
          <target state="translated">最初に、他のことをする前に、への1回の呼び出しで &lt;code&gt;from&lt;/code&gt; のタイプと権限を取得します</target>
        </trans-unit>
        <trans-unit id="bd0a7f661657d89c37e4c1215e80d0191bb4862d" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream.</source>
          <target state="translated">まず、&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;を呼び出して、保留中のすべての出力（および、もしあれば遅延フラッシュ）をラップされたストリームに送信します。</target>
        </trans-unit>
        <trans-unit id="eab9bd2628b9d318b166ebaf056d0f32c1ae9059" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored.</source>
          <target state="translated">まず、&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; を&lt;/a&gt;呼び出します。 &lt;code&gt;emit()&lt;/code&gt; の呼び出しによって例外がスローされた場合、それはキャッチされて無視されます。</target>
        </trans-unit>
        <trans-unit id="daac23b0d5c1b3ef73330f0f556ea905967387b5" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored. Then, destroys the member &lt;code&gt;std::basic_syncbuf&lt;/code&gt; and the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; as usual.</source>
          <target state="translated">まず、&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; を&lt;/a&gt;呼び出します。 &lt;code&gt;emit()&lt;/code&gt; の呼び出しによって例外がスローされた場合、それはキャッチされて無視されます。次に、通常どおり、メンバー &lt;code&gt;std::basic_syncbuf&lt;/code&gt; とベース &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="99f9e198aa798816c58da32cfc0095d286931e68" translate="yes" xml:space="preserve">
          <source>First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then reads characters from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; that are expected by the &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; format specifier formed by combining &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;modifier&lt;/code&gt; (if not &lt;code&gt;'\0'&lt;/code&gt;), and &lt;code&gt;format&lt;/code&gt;. If the characters do not combine to form a valid conversion specifier, sets &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the end of the input stream is reached after reading a character, sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the input string was parsed successfully, updates the corresponding fields of &lt;code&gt;*t&lt;/code&gt;.   For complex conversion specifiers, such as &lt;code&gt;'%x'&lt;/code&gt; or &lt;code&gt;'%c'&lt;/code&gt;, or the directives that use the modifiers &lt;code&gt;'E'&lt;/code&gt; and &lt;code&gt;'O'&lt;/code&gt;, the function may fail to determine some of the values to store in &lt;code&gt;*t&lt;/code&gt;. In such case, it sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; and leaves these fields in unspecified state.</source>
          <target state="translated">まず、 &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std :: ios_base :: goodbitを&lt;/a&gt;実行して、 &lt;code&gt;err&lt;/code&gt; のエラービットをクリアします。次に、入力シーケンス &lt;code&gt;[beg, end)&lt;/code&gt; から、 &lt;code&gt;'%'&lt;/code&gt; 、 &lt;code&gt;modifier&lt;/code&gt; （ &lt;code&gt;'\0'&lt;/code&gt; ない場合）、および &lt;code&gt;format&lt;/code&gt; を組み合わせて形成される &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 形式指定子で予期される文字を読み取ります。文字が結合して有効な変換指定子を形成しない場合は、 &lt;code&gt;err&lt;/code&gt; に &lt;code&gt;failbit&lt;/code&gt; を設定します。文字を読み取った後で入力ストリームの終わりに達した場合、 &lt;code&gt;err&lt;/code&gt; に &lt;code&gt;eofbit&lt;/code&gt; を設定します。入力文字列が正常に解析された場合、の対応するフィールドを更新します &lt;code&gt;*t&lt;/code&gt; 。 &lt;code&gt;'%x'&lt;/code&gt; や &lt;code&gt;'%c'&lt;/code&gt; などの複雑な変換指定子、または修飾子 &lt;code&gt;'E'&lt;/code&gt; と &lt;code&gt;'O'&lt;/code&gt; を使用するディレクティブの場合、関数は &lt;code&gt;*t&lt;/code&gt; に格納する値のいくつかを決定できないことがあります。そのような場合、 &lt;code&gt;eofbit&lt;/code&gt; を &lt;code&gt;err&lt;/code&gt; に設定し、これらのフィールドを指定されていない状態のままにします。</target>
        </trans-unit>
        <trans-unit id="761e411f45989f18b8cdc09dfae5d408bc3760bb" translate="yes" xml:space="preserve">
          <source>First, expr is converted to an awaitable as follows:</source>
          <target state="translated">まず、exprは以下のように待ち受けに変換されます。</target>
        </trans-unit>
        <trans-unit id="49e86d447ef30f5d8ac55d11082a293ce491a304" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, performs the ISO/IEC/IEEE 60559</source>
          <target state="translated">まず、 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、ISO / IEC / IEEE 60559を実行します</target>
        </trans-unit>
        <trans-unit id="714bfffed5c4d1159d21c2074b0dd5ebd28587dd" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;T&lt;/code&gt; is a class type and the initializer is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; expression whose cv-unqualified type is the same class as &lt;code&gt;T&lt;/code&gt;, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;</source>
          <target state="translated">最初に、 &lt;code&gt;T&lt;/code&gt; がクラス型であり、初期化子がcv非修飾型が &lt;code&gt;T&lt;/code&gt; と同じクラスである&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;式である場合、一時オブジェクトからではなく初期化子式自体が宛先オブジェクトの初期化に使用されます。&lt;a href=&quot;copy_elision&quot;&gt;コピーを&lt;/a&gt;参照してください省略</target>
        </trans-unit>
        <trans-unit id="3a19b536bb9ed4bb6c617709d11bbfa515bb05a0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt;, returns a default-constructed path.</source>
          <target state="translated">まず、 &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt; 場合！= base.root_name（）|| is_absolute（）！= base.is_absolute（）|| （！has_root_directory（）&amp;amp;&amp;amp; base.has_root_directory（））は、デフォルトで作成されたパスを返します。</target>
        </trans-unit>
        <trans-unit id="0af0623ac822520c62720be6f5b81d9ab7f82065" translate="yes" xml:space="preserve">
          <source>First, records that a flush is pending, by updating the appropriate private flag.</source>
          <target state="translated">まず、適切なプライベートフラグを更新することで、フラッシュが保留中であることを記録します。</target>
        </trans-unit>
        <trans-unit id="a3dedc18a8aa37448d34180fda53b30fdca03e04" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">まず、現在発生している浮動小数点例外を記憶し、次に &lt;code&gt;envp&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; と同様）が指すオブジェクトから浮動小数点環境を復元し、保存された浮動小数点例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="f26f81a265113be2257dfeddeb17e46ef91bc7df" translate="yes" xml:space="preserve">
          <source>First, retrieve the outermost allocator &lt;code&gt;OUTERMOST&lt;/code&gt; by calling &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt;, and then calling the &lt;code&gt;outer_allocator()&lt;/code&gt; member function recursively on the result of this call until reaching an allocator that has no such member function.</source>
          <target state="translated">最初に、 &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt; を呼び出して最も外側のアロケーター &lt;code&gt;OUTERMOST&lt;/code&gt; を取得し、次に、そのようなメンバー関数を持たないアロケーターに到達するまで、この呼び出しの結果に対して &lt;code&gt;outer_allocator()&lt;/code&gt; メンバー関数を再帰的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="b22ed5216bdf7ab4edb25ec8436348da2427fb87" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初に、現在の浮動小数点環境を &lt;code&gt;envp&lt;/code&gt; が指すオブジェクトに保存し（ &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt; と同様）、すべての浮動小数点ステータスフラグをクリアしてから、ノンストップモードをインストールします。将来の浮動小数点例外は発生しません &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; によって浮動小数点環境が復元されるまで、実行を中断します（トラップしません）。</target>
        </trans-unit>
        <trans-unit id="19ae2c760d73ee6a549348974c9ddff8cc5fef2c" translate="yes" xml:space="preserve">
          <source>First, set each element of the output range to the value &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</source>
          <target state="translated">まず、出力範囲の各要素を値 &lt;code&gt;0x8b8b8b8b&lt;/code&gt; に設定します</target>
        </trans-unit>
        <trans-unit id="37c02899047a91960018379b0f4a7201e2a7714f" translate="yes" xml:space="preserve">
          <source>First, the argument-dependent lookup is not considered if the lookup set produced by usual &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; contains any of the following:</source>
          <target state="translated">まず、通常の&lt;a href=&quot;lookup&quot;&gt;非修飾ルックアップ&lt;/a&gt;によって作成されたルックアップセットに次のいずれかが含まれている場合、引数に依存するルックアップは考慮されません。</target>
        </trans-unit>
        <trans-unit id="71da67e0b30adfe6e4f96fe9e13991f6f8a033f3" translate="yes" xml:space="preserve">
          <source>Firstly, if this path has an &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt;, it is removed from the generic-format view of the pathname.</source>
          <target state="translated">まず、このパスに&lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt;が含まれている場合、パス名の総称形式ビューから削除されます。</target>
        </trans-unit>
        <trans-unit id="d24ff9bf0ed02a5411428beac3e4bd1d30fe9f46" translate="yes" xml:space="preserve">
          <source>Five &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;span&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;span&lt;/code&gt; は5つの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;が用意されています。</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">固定幅整数型</target>
        </trans-unit>
        <trans-unit id="a96f6d996f06dc7144585656dcc077cf300a6377" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C++11)</source>
          <target state="translated">固定幅整数型(C++11以降</target>
        </trans-unit>
        <trans-unit id="0a6c931f357cf026414e375b77b04d8235b7334d" translate="yes" xml:space="preserve">
          <source>Flag type and operations</source>
          <target state="translated">フラグの種類と運用</target>
        </trans-unit>
        <trans-unit id="27cbb35a9b1b271932f7636ca4faaede088277a2" translate="yes" xml:space="preserve">
          <source>Flips bits, i.e. changes &lt;code&gt;true&lt;/code&gt; values to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values to &lt;code&gt;true&lt;/code&gt;. Equivalent to a logical NOT operation on part or all of the bitset.</source>
          <target state="translated">ビットを反転します。つまり、 &lt;code&gt;true&lt;/code&gt; 値を &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 値を &lt;code&gt;true&lt;/code&gt; 変更します。ビットセットの一部またはすべてに対する論理NOT演算と同等です。</target>
        </trans-unit>
        <trans-unit id="b5dfec7a1df7a1c20eb6ca15e9bee0c75b291919" translate="yes" xml:space="preserve">
          <source>Floating point literal defines a compile-time constant whose value is specified in the source file.</source>
          <target state="translated">浮動小数点リテラルは、ソースファイルで指定された値を持つコンパイル時定数を定義します。</target>
        </trans-unit>
        <trans-unit id="530b771e0a4d9da8f37e390916e11d1da9b65536" translate="yes" xml:space="preserve">
          <source>Floating point manipulation functions</source>
          <target state="translated">浮動小数点操作機能</target>
        </trans-unit>
        <trans-unit id="4cdfaff55d21c2eb1c0a0dbeace3c9c4e378eda8" translate="yes" xml:space="preserve">
          <source>Floating point types</source>
          <target state="translated">浮動小数点型</target>
        </trans-unit>
        <trans-unit id="931a4d33f9a7670df77e53c7e39d2883c52b8c58" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned and *str_end is set to str.</source>
          <target state="translated">成功時に &lt;code&gt;str&lt;/code&gt; の内容に対応する浮動小数点値。変換された値が対応する戻り値の型の範囲外の場合、範囲エラーが発生し、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; が返されます。変換は行うことができない場合は、 &lt;code&gt;​0​&lt;/code&gt; 返され、* str_endはSTRに設定されています。</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">成功時に &lt;code&gt;str&lt;/code&gt; の内容に対応する浮動小数点値。変換された値が対応する戻り値の型の範囲外の場合、範囲エラーが発生し、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; が返されます。変換が行われなかっできる場合は、 &lt;code&gt;​0​&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="d2f57b6272c09794ad846fa25baa135845cf2031" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the &amp;mu; distribution parameter.</source>
          <target state="translated">&amp;mu;分布パラメーターを識別する浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="9a1cf11d8c926cc9f1bbac062621307bdc11199f" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the degrees of freedom of the distribution.</source>
          <target state="translated">分布の自由度を識別する浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="a725365fc9cc7788cab748ff13281e3d748d0017" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the p distribution parameter.</source>
          <target state="translated">p 分布パラメータを識別する浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="3bfd050a822b215062fc674739b968774ba30a01" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the rate of events per unit.</source>
          <target state="translated">単位当たりのイベント発生率を識別する浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="5c65e500905d168962e036e5e1c8cfd585b5a35a" translate="yes" xml:space="preserve">
          <source>Floating point value in range [0, 1).</source>
          <target state="translated">範囲[0,1]の浮動小数点値。</target>
        </trans-unit>
        <trans-unit id="a4edd9f5da9c5bff6fa7351be1698e5f17713a8e" translate="yes" xml:space="preserve">
          <source>Floating&amp;ndash;integral conversions</source>
          <target state="translated">浮動小数点積分変換</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">浮動小数点収縮</target>
        </trans-unit>
        <trans-unit id="a694704378ed350bc958fb519c8315b5d52a02b7" translate="yes" xml:space="preserve">
          <source>Floating-point conversions</source>
          <target state="translated">浮動小数点変換</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">浮動小数点環境</target>
        </trans-unit>
        <trans-unit id="fc13961bdda58d06692a8ad8f8156b2841512415" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. Floating-point expressions may also be</source>
          <target state="translated">浮動小数点式の範囲と精度は、それらの型で示されるよりも大きい場合があります &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 参照してください。浮動小数点式も</target>
        </trans-unit>
        <trans-unit id="0e05b4ea4725d83345dcb31354835a769615b781" translate="yes" xml:space="preserve">
          <source>Floating-point promotion</source>
          <target state="translated">浮動小数点プロモーション</target>
        </trans-unit>
        <trans-unit id="f74d231baa71e2a641e3234ad91f55a94e0aa7a0" translate="yes" xml:space="preserve">
          <source>Floating-point types may support &lt;a href=&quot;../types/numeric_limits&quot;&gt;special values&lt;/a&gt;:</source>
          <target state="translated">浮動小数点型は&lt;a href=&quot;../types/numeric_limits&quot;&gt;特別な値を&lt;/a&gt;サポートするかもしれません：</target>
        </trans-unit>
        <trans-unit id="a26e00b84e77b40bea4bb511f8f60ed076daa97b" translate="yes" xml:space="preserve">
          <source>Flowing off the end of a value-returning function (except &lt;code&gt;main&lt;/code&gt;) without a return statement is undefined behavior.</source>
          <target state="translated">returnステートメントを使用せずに値を返す関数（ &lt;code&gt;main&lt;/code&gt; を除く）の最後からフローすることは未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="6666b9fcba2b772c274346c92162b6c1a3611ada" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.flush()&lt;/code&gt; を呼び出すのと同じように、出力シーケンス &lt;code&gt;os&lt;/code&gt; をフラッシュします。</target>
        </trans-unit>
        <trans-unit id="9cdb990f130f6549318c7c3b84780625f76de3f4" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;. Then, if &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, calls &lt;code&gt;buf.emit()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.flush()&lt;/code&gt; を呼び出すのと同じように、出力シーケンス &lt;code&gt;os&lt;/code&gt; をフラッシュします。その後、場合 &lt;code&gt;os.rdbuf()&lt;/code&gt; を実際にポイント &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &amp;lt;チャート、形質、アロケータ&amp;gt; &lt;code&gt;buf&lt;/code&gt; が、呼び出す &lt;code&gt;buf.emit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4727f15c3dadc6abc3267b67039a85b366a9aeb" translate="yes" xml:space="preserve">
          <source>Flushing is performed in the destructor of the &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; object, which calls &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt;.</source>
          <target state="translated">フラッシュは &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; オブジェクトのデストラクタで実行され、 &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: unitbuf&lt;/a&gt; == trueの場合にstr.rdbuf（） &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="dd2e024a054d8c1876c1f1a73eab175647867cec" translate="yes" xml:space="preserve">
          <source>Fold expressions</source>
          <target state="translated">フォールド式</target>
        </trans-unit>
        <trans-unit id="820f688950b36fa22a06159885b2b0b589f17953" translate="yes" xml:space="preserve">
          <source>Fold-expressions</source>
          <target state="translated">Fold-expressions</target>
        </trans-unit>
        <trans-unit id="73ea87451f9d5e42c6d3450b515bcb3f98250b83" translate="yes" xml:space="preserve">
          <source>Follow rather than skip directory symlinks.</source>
          <target state="translated">ディレクトリのシンボリックリンクをスキップするのではなく、フォローします。</target>
        </trans-unit>
        <trans-unit id="c9eac869d3c658b081e1a95ca062116b32f0aaa4" translate="yes" xml:space="preserve">
          <source>Follow symlinks (default behavior)</source>
          <target state="translated">シンボリックリンクに従う(デフォルトの動作</target>
        </trans-unit>
        <trans-unit id="9d728e94fbab96a42d3b4d9a6cb222f5e938822e" translate="yes" xml:space="preserve">
          <source>Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.</source>
          <target state="translated">以下の説明のみの概念は、いくつかの型で使用されていますが、標準ライブラリのインターフェースの一部ではありません。</target>
        </trans-unit>
        <trans-unit id="6f40e40d82fd8846da49808b0b708490ce0379e1" translate="yes" xml:space="preserve">
          <source>Following member functions are conditionally different from corresponding member functions of &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">次のメンバー関数は、 &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 対応するメンバー関数と条件付きで異なります。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="2eedcffa258b92b2d623f330307d6610480c73b1" translate="yes" xml:space="preserve">
          <source>For (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">（1）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; は、 &lt;code&gt;Types&lt;/code&gt; すべての &lt;code&gt;T_i&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="27e932e63be3980babb2b5c3e1834eb9ece2f5cb" translate="yes" xml:space="preserve">
          <source>For (1),&lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">（1）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cce1fc39ab817dad0417c749a97b121fa9da8698" translate="yes" xml:space="preserve">
          <source>For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">(1-3)については、結果が[0,255]の範囲外になる場合は、実際の格納値は不定です。</target>
        </trans-unit>
        <trans-unit id="80750dcb6fca71c81371e8509ae0e5a32ea184f9" translate="yes" xml:space="preserve">
          <source>For (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">（2）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; は、 &lt;code&gt;Types&lt;/code&gt; すべての &lt;code&gt;T_i&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cf60873df305a2582da8245d9a95bc5dabb1f1c1" translate="yes" xml:space="preserve">
          <source>For (2),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">（2）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2e266ee47c94d97b82af99ef255fd0f260a99d2c" translate="yes" xml:space="preserve">
          <source>For (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">（3）については、 &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; のタイプのすべての対応するペアのために &lt;code&gt;T_i&lt;/code&gt; に &lt;code&gt;Types&lt;/code&gt; と &lt;code&gt;U_i&lt;/code&gt; に &lt;code&gt;UTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235c0ae5251a55b5cc4853b6e31b390a6d489d01" translate="yes" xml:space="preserve">
          <source>For (3),&lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">（3）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6c23beb9ab1e1686d723073f239e4dd5ad833ba8" translate="yes" xml:space="preserve">
          <source>For (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">（4）については、 &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; のタイプのすべての対応するペアの &lt;code&gt;T_i&lt;/code&gt; で &lt;code&gt;Types&lt;/code&gt; と &lt;code&gt;U_i&lt;/code&gt; で &lt;code&gt;UTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d612fce9fe1d1b17e3a906128095373ba91170e6" translate="yes" xml:space="preserve">
          <source>For (4),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">（4）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6dc7376755e98b71c2080e8a531379170a9f0d46" translate="yes" xml:space="preserve">
          <source>For (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">（5）の場合、 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; は両方とも &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;T_0&lt;/code&gt; および &lt;code&gt;T_1&lt;/code&gt; は、 &lt;code&gt;Types&lt;/code&gt; 構成する2つのタイプです。</target>
        </trans-unit>
        <trans-unit id="94214e5075f274a6f5fa7b33c9435afe45df0332" translate="yes" xml:space="preserve">
          <source>For (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">（6）の場合、 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; であり、 &lt;code&gt;T_0&lt;/code&gt; および &lt;code&gt;T_1&lt;/code&gt; はタイプを構成する2つの &lt;code&gt;Types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83856baa7fbad81b10e160970bde088c89421d40" translate="yes" xml:space="preserve">
          <source>For 0&amp;le;arg&amp;le;1,</source>
          <target state="translated">0&amp;le;arg&amp;le;1の場合</target>
        </trans-unit>
        <trans-unit id="3bd6dc6d78016b2a3f1c8c074db727a1bd8e2c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a</source>
          <target state="translated">ため&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;値である場合を除いてタイプ、値表現がバイトをコピーするストレージ内のオブジェクトによって占有され（同じ値を持つ別のオブジェクトを生成するのに十分であることを意味するオブジェクト表現の一部であります</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">以下のために&lt;a href=&quot;do&quot;&gt;行う-ながら&lt;/a&gt;ループ、それはとして機能します：</target>
        </trans-unit>
        <trans-unit id="192dfceddbf339e300daed630beff6523e185814" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; and &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">以下のために&lt;a href=&quot;for&quot;&gt;用&lt;/a&gt;と&lt;a href=&quot;range-for&quot;&gt;レンジ用の&lt;/a&gt;ループは、として機能します：</target>
        </trans-unit>
        <trans-unit id="25d4ebe9fb8814a98da8afb721d4a6bdeed00a0f" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">以下のための&lt;a href=&quot;operator_comparison&quot;&gt;関係演算子&lt;/a&gt; &amp;gt;と&amp;ge;それぞれ</target>
        </trans-unit>
        <trans-unit id="c82d883f6eaf9d2b9ddb7fd8e6adaa4e2930e681" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;lt; and &amp;le; respectively</source>
          <target state="translated">以下のための&lt;a href=&quot;operator_comparison&quot;&gt;関係演算子&lt;/a&gt;をそれぞれ&amp;lt;と&amp;le;</target>
        </trans-unit>
        <trans-unit id="80184e736b13dd44e9e03f7f4a2465c93e2f10ce" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; = and &amp;ne; respectively</source>
          <target state="translated">&lt;a href=&quot;operator_comparison&quot;&gt;関係演算子&lt;/a&gt; =およびForの場合</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">以下のため&lt;a href=&quot;while&quot;&gt;のwhile&lt;/a&gt;ループは、として機能します。</target>
        </trans-unit>
        <trans-unit id="2ceb12570320e8236ce37933edca4d8d71e4edce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt;, if the character &amp;micro; (U+00B5) cannot be represented in the encoding used for &lt;code&gt;CharT&lt;/code&gt;, the suffix &quot;&lt;code&gt;us&lt;/code&gt;&quot; is used instead.</source>
          <target state="translated">以下のため &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt; 文字&amp;mu;（U + 00B5）のために使用されるエンコーディングで表現できない場合は、 &lt;code&gt;CharT&lt;/code&gt; 、接尾辞は、「 &lt;code&gt;us&lt;/code&gt; 」代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="decd50a2a6c24904b14b0159d4b4ee28edc12dd8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, the elements are bytes (objects of type char), which are not the same as characters if a multibyte encoding such as UTF-8 is used.</source>
          <target state="translated">ため &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 、要素は、UTF-8で符号化するマルチバイトが使用される場合、文字と同じではないバイト（char型のオブジェクト）です。</target>
        </trans-unit>
        <trans-unit id="4fc81475176c004bf7dd4b13445be6b3d996668a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; the value type is the same as the key type and both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the value type is &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">以下のため &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 値型は、キータイプとの両方と同じで &lt;code&gt;iterator&lt;/code&gt; と &lt;code&gt;const_iterator&lt;/code&gt; の定数イテレータです。以下のため &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 値の型がされて &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d3533c7dfac4c0a2f11001f27ce7038422be45e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">以下のために &lt;code&gt;T*&lt;/code&gt; のタイプ、結果は未定義アドレスであってもよいが、操作がそうでなければ、未定義の動作を持っていません。 &lt;code&gt;T&lt;/code&gt; がオブジェクト型でない場合、プログラムの形式は正しくありません。</target>
        </trans-unit>
        <trans-unit id="6d8b259c841d7fe56fd4cbc44dbede3d4a2f5d45" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">以下のために &lt;code&gt;T*&lt;/code&gt; の種類、結果は未定義アドレスであってもよいが、操作は、そうでなければ、未定義の動作を持っていません。 &lt;code&gt;T&lt;/code&gt; がオブジェクト型でない場合、プログラムの形式は正しくありません。</target>
        </trans-unit>
        <trans-unit id="fdab33fa5bc42221e341bfb5aa446019046bda10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared&lt;/code&gt;, the object (or the individual array elements for (2-5))(since C++20) are destroyed via the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator passed to &lt;code&gt;allocate_shared&lt;/code&gt;, rebound to the type of the object being destroyed.</source>
          <target state="translated">ため &lt;code&gt;allocate_shared&lt;/code&gt; 、オブジェクト（またはのための個々の配列要素（2-5））の発現を介して破壊される（20 ++ C以降） &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; がありますオブジェクトへのポインタであり &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;allocate_shared&lt;/code&gt; に渡されたアロケータのコピーであり、破棄されるオブジェクトのタイプに再バインドされます。</target>
        </trans-unit>
        <trans-unit id="ffeded1df965bfced36bed8a9a11d97603f70744" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared_default_init&lt;/code&gt;, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">用 &lt;code&gt;allocate_shared_default_init&lt;/code&gt; 、オブジェクト（または個々の要素場合 &lt;code&gt;T&lt;/code&gt; は配列型である）によって破壊される &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; はオブジェクトへのポインタであり、 &lt;code&gt;X&lt;/code&gt; がそのタイプです。</target>
        </trans-unit>
        <trans-unit id="eaf9872d7fc84f0c3657f05544061163d1795a7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</source>
          <target state="translated">以下のため &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a84133a6d81bd30988c564a8a6cf37a9783a4cf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = m,..., m+n-1&lt;/code&gt;,</source>
          <target state="translated">以下のための &lt;code&gt;k = m,..., m+n-1&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="3702c14d2d2a72e5ae19407c373383886d03512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator,&lt;/code&gt;, the unary &lt;code&gt;operator&amp;amp;&lt;/code&gt;, and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, if there are no viable functions (see below) in the set of candidate functions, then the operator is reinterpreted as a built-in.</source>
          <target state="translated">以下のために &lt;code&gt;operator,&lt;/code&gt; 、単項 &lt;code&gt;operator&amp;amp;&lt;/code&gt; と &lt;code&gt;operator-&amp;gt;&lt;/code&gt; は全く生存機能がない場合、候補関数のセットに（下記参照）、その後、オペレータは、内蔵のように再解釈されます。</target>
        </trans-unit>
        <trans-unit id="0d394b44570e5e62b408fa0499880cd8eb0cf013" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::binary_search&lt;/code&gt; to succeed, the range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">以下のため &lt;code&gt;std::binary_search&lt;/code&gt; 成功するために、範囲は &lt;code&gt;[first, last)&lt;/code&gt; 少なくとも部分的に関連して注文する必要があります &lt;code&gt;value&lt;/code&gt; 、それは次の要件のすべてを満たさなければならない。すなわち：</target>
        </trans-unit>
        <trans-unit id="82aaf8ae9515fcaa10aa37778070bfaa5e42e07b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lrint&lt;/code&gt; and &lt;code&gt;std::llrint&lt;/code&gt; functions:</source>
          <target state="translated">以下のため &lt;code&gt;std::lrint&lt;/code&gt; と &lt;code&gt;std::llrint&lt;/code&gt; 機能：</target>
        </trans-unit>
        <trans-unit id="386ec7b95ea37fdce144fa4084a418bcda9d46f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lround&lt;/code&gt; and &lt;code&gt;std::llround&lt;/code&gt; functions:</source>
          <target state="translated">以下のため &lt;code&gt;std::lround&lt;/code&gt; と &lt;code&gt;std::llround&lt;/code&gt; 機能：</target>
        </trans-unit>
        <trans-unit id="93056bf6dac8be93c20bc17806b06200f88a2398" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move assignment operator copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">以下のための &lt;code&gt;union&lt;/code&gt; 型、暗黙的に定義されたムーブ代入演算子コピー（よるようなオブジェクト表現 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">IEEE互換の型 &lt;code&gt;double&lt;/code&gt; の場合、オーバーフローは、 &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; または &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; 場合に発生します。</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">IEEE互換の型 &lt;code&gt;double&lt;/code&gt; の場合、709.8 &amp;lt;argの場合はオーバーフローが保証され、arg &amp;lt;-708.4の場合はアンダーフローが保証されます。</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">IEEE互換の型 &lt;code&gt;double&lt;/code&gt; の場合、709.8 &amp;lt;argの場合、オーバーフローが保証されます。</target>
        </trans-unit>
        <trans-unit id="7abd0d73ae7ceb8182e2cfda7bc62d8a3837d067" translate="yes" xml:space="preserve">
          <source>For POSIX-based operating systems, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt;.</source>
          <target state="translated">POSIXベースのオペレーティングシステムの場合、 &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="119d7cdec7ea51fa50da00d5d9417b5384f14791" translate="yes" xml:space="preserve">
          <source>For Windows, &lt;code&gt;absolute&lt;/code&gt; may be implemented as a call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;.</source>
          <target state="translated">Windowsの場合、 &lt;code&gt;absolute&lt;/code&gt; は&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameWの&lt;/a&gt;呼び出しとして実装できます。</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">のために</target>
        </trans-unit>
        <trans-unit id="ca411b7633697d58c29db0495dbecc36219406c0" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;dependent_name&quot;&gt;non-dependent name&lt;/a&gt; used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a &lt;a href=&quot;dependent_name&quot;&gt;dependent name&lt;/a&gt; used in a template definition, the lookup is postponed until the template arguments are known, at which time &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</source>
          <target state="translated">以下のために&lt;a href=&quot;dependent_name&quot;&gt;非依存名&lt;/a&gt;テンプレート定義を検討する際にテンプレート定義で使用される、非修飾名の検索が行われます。その時点で行われた宣言へのバインディングは、インスタンス化の時点で表示される宣言の影響を受けません。以下のために&lt;a href=&quot;dependent_name&quot;&gt;依存名&lt;/a&gt;のテンプレート引数が知られるまで、テンプレート定義で使用される、ルックアップは、延期された時点で&lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;非ADLルックアップは、外部リンケージがある関数宣言（C ++ 11まで）を検査しますが、非ADLルックアップは、外部リンケージがある関数宣言（C ++ 11まで）を検査します。テンプレート定義のコンテキストから表示されます（つまり、テンプレート定義の後に新しい関数宣言を追加しても、ADL以外では表示されません）。他の翻訳単位で宣言されたADLルックアップによって検査された名前空間の外部リンケージとの一致がより良い場合、またはそれらの翻訳単位が検査された場合のルックアップがあいまいだった場合の動作は未定義です。いずれにせよ、基本クラスがテンプレートパラメータに依存している場合、そのスコープは、非修飾名のルックアップによっては定義されません（定義の時点でもインスタンス化の時点でも）。</target>
        </trans-unit>
        <trans-unit id="883759e78914d4b04a2fe3535a894bcffbf8a177" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; of a non-template class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class defaults would turn a member function into a default, copy, or move constructor the program is ill-formed. For member functions of class templates, all defaults must be provided in the initial declaration of the member function.</source>
          <target state="translated">ための&lt;a href=&quot;member_functions&quot;&gt;メンバ関数&lt;/a&gt;非テンプレートクラスの、デフォルトの引数はアウト・オブ・クラス定義に許可され、そしてクラス体内宣言によって提供されるデフォルト引数と組み合わされます。これらのクラス外のデフォルトがメンバー関数をデフォルト、コピー、または移動コンストラクターに変える場合、プログラムは不正な形式です。クラステンプレートのメンバー関数の場合、メンバー関数の初期宣言ですべてのデフォルトを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="02ea56864a8e8c007867dec05809cd5a9f98b81f" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">コンテナー &lt;code&gt;c&lt;/code&gt; の場合、式 &lt;code&gt;c.front()&lt;/code&gt; は &lt;code&gt;*c.begin()&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="c061e2be7835c9d94a21ab627e460ae3f5da4b8d" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;return c.back();&lt;/code&gt; is equivalent to &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</source>
          <target state="translated">コンテナ &lt;code&gt;c&lt;/code&gt; の場合、式は &lt;code&gt;return c.back();&lt;/code&gt; &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt; と同等です。--tmp; * tmpを返す; }</target>
        </trans-unit>
        <trans-unit id="a12f2ebb81a91e44d54c155d3b7a470c7c32d87a" translate="yes" xml:space="preserve">
          <source>For a given &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt;, this specialization ensures that.</source>
          <target state="translated">特定の &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt; 場合、この特殊化によってそれが保証されます。</target>
        </trans-unit>
        <trans-unit id="61761986c4556882eacd9227f774252dea0c81ea" translate="yes" xml:space="preserve">
          <source>For a name used anywhere in &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;, except inside a member function body, a default argument of a member function, exception specification of a member function, default member initializer, &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt;(since C++20), or inside a nested class definition (including names of the bases from which the nested class is derived), the following scopes are searched:</source>
          <target state="translated">メンバー関数本体、メンバー関数のデフォルト引数、メンバー関数の例外指定、デフォルトメンバー初期化子、&lt;a href=&quot;attributes/contract&quot;&gt;コントラクト条件&lt;/a&gt;（C ++ 20以降）、またはネストされたクラス内を除く、&lt;a href=&quot;class&quot;&gt;クラス定義の&lt;/a&gt;任意の場所で使用される名前定義（ネストされたクラスの派生元のベースの名前を含む）、次のスコープが検索されます：</target>
        </trans-unit>
        <trans-unit id="a684765457eef405a769182256e4ade4f401bc30" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt; in a function declaration, or name used in the expression part of a &lt;a href=&quot;constructor&quot;&gt;member-initializer&lt;/a&gt; of a constructor, the function parameter names are found first, before the enclosing block, class, or namespace scopes are examined:</source>
          <target state="translated">で使用される名前のための&lt;a href=&quot;default_arguments&quot;&gt;デフォルト引数&lt;/a&gt;の関数宣言で、または発現に使用される名前部分&lt;a href=&quot;constructor&quot;&gt;メンバー初期化子&lt;/a&gt;コンストラクタの、関数のパラメータ名は、最初に発見され、封入ブロックの前、クラス、または名前空間スコープが検査されます。</target>
        </trans-unit>
        <trans-unit id="6ae66449c2d64e5e5aa0c8dcee38ad7d218d4918" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function definition inside the body of the class that is granting friendship, unqualified name lookup proceeds the same way as for a member function. For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function which is defined outside the body of a class, unqualified name lookup proceeds the same way as for a function in a namespace.</source>
          <target state="translated">フレンドシップを付与しているクラスの本体内の&lt;a href=&quot;friend&quot;&gt;フレンド&lt;/a&gt;関数定義で使用される名前の場合、非修飾名の検索はメンバー関数の場合と同じように進行します。クラスの本体の外部で定義されている&lt;a href=&quot;friend&quot;&gt;フレンド&lt;/a&gt;関数で使用される名前の場合、非修飾名の検索は、名前空間の関数の場合と同じように行われます。</target>
        </trans-unit>
        <trans-unit id="f880effac86bc82db2f16b2948bd47f4311ada8a" translate="yes" xml:space="preserve">
          <source>For a name used in a user-declared namespace outside of any function or class, this namespace is searched before the use of the name, then the namespace enclosing this namespace before the declaration of this namespace, etc until the global namespace is reached.</source>
          <target state="translated">関数やクラス以外のユーザ宣言された名前空間で使用されている名前については、その名前を使用する前にその名前空間を検索し、その名前空間の宣言前にその名前空間を囲む名前空間を検索し、グローバル名前空間に到達するまで検索します。</target>
        </trans-unit>
        <trans-unit id="d01e0277c975bcb293141e811447dfa3ec140823" translate="yes" xml:space="preserve">
          <source>For a name used in global (top-level namespace) scope, outside of any function, class, or user-declared namespace, the global scope before the use of the name is examined:</source>
          <target state="translated">関数、クラス、またはユーザが宣言した名前空間以外のグローバル・スコープ (トップレベル名前空間)で使用される名前については、その名前を使用する前のグローバル・スコープが検査されます。</target>
        </trans-unit>
        <trans-unit id="6751cf91d41edea8f420573f4bb5cfa36ba1c19a" translate="yes" xml:space="preserve">
          <source>For a name used in the catch-clause of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, lookup proceeds as if for a name used in the very beginning of the outermost block of the function body (in particular, function parameters are visible, but names declared in that outermost block are not).</source>
          <target state="translated">&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;のcatch-clauseで使用される名前の場合、検索は、関数本体の最も外側のブロックの非常に先頭で使用される場合と同様に続行されます（特に、関数パラメーターは表示されますが、その最も外側のブロックはそうではありません）。</target>
        </trans-unit>
        <trans-unit id="0ecffe6eebcdaa6e0a2a4a2d57d191d6b1fc5d6c" translate="yes" xml:space="preserve">
          <source>For a name used in the declarator of a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function declaration that friends a member function from another class, if the name isn't a part of any template argument, the unqualified lookup first examines the entire scope of the member function's class. If not found in that scope (or if the name is a part of a template argument), the lookup continues as if for a member function of the class that is granting friendship.</source>
          <target state="translated">別のクラスのメンバー関数をフレンドにする&lt;a href=&quot;friend&quot;&gt;フレンド&lt;/a&gt;関数宣言の宣言子で使用される名前の場合、その名前がテンプレート引数の一部ではない場合、非修飾ルックアップはまずメンバー関数のクラスのスコープ全体を調べます。そのスコープで見つからない場合（または名前がテンプレート引数の一部である場合）、フレンドシップを付与しているクラスのメンバー関数の場合と同様に検索が続行されます。</target>
        </trans-unit>
        <trans-unit id="d95608e8a2ef528dbac2bab8b35c1d8f3a28d62b" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;, lookup proceeds the same way as for a name used in the definition of a member function.</source>
          <target state="translated">&lt;a href=&quot;static&quot;&gt;静的データメンバーの&lt;/a&gt;定義で使用される名前の場合、ルックアップは、メンバー関数の定義で使用される名前の場合と同じように進行します。</target>
        </trans-unit>
        <trans-unit id="f034307944cf4601fdfc2f8a86c32703ec89cf55" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a function, either in its body or as part of default argument, where the function is a member of user-declared or global namespace, the block in which the name is used is searched before the use of the name, then the enclosing block is searched before the start of that block, etc, until reaching the block that is the function body. Then the namespace in which the function is declared is searched until the definition (not necessarily the declaration) of the function that uses the name, then the enclosing namespaces, etc.</source>
          <target state="translated">関数の定義で使用される名前は、その関数の本体またはデフォルト引数の一部であり、その関数がユーザ宣言された名前空間またはグローバル名前空間のメンバである場合、名前が使用される前に、その名前が使用されているブロックが検索され、そのブロックの開始前に、そのブロックを囲むブロックが検索されるなど、関数本体であるブロックに到達するまで検索されます。その後、関数が宣言されている名前空間は、その名前を使用する関数の定義(宣言とは限らない)まで検索され、その後、囲い込み名前空間などが検索されます。</target>
        </trans-unit>
        <trans-unit id="e69fc9e6436e85bd5e71b5f6fffe00b9251f55e4" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a namespace-member variable outside the namespace, lookup proceeds the same way as for a name used inside the namespace:</source>
          <target state="translated">名前空間外の名前空間メンバ変数の定義で使用されている名前については、名前空間内で使用されている名前と同じ方法で検索が行われます。</target>
        </trans-unit>
        <trans-unit id="8362e87a521c085b7be1055bd62a4345efa29ea0" translate="yes" xml:space="preserve">
          <source>For a name used in the initializer part of the &lt;a href=&quot;enum&quot;&gt;enumerator declaration&lt;/a&gt;, previously declared enumerators in the same enumeration are found first, before the unqualified name lookup proceeds to examine the enclosing block, class, or namespace scope.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;列挙子宣言の&lt;/a&gt;初期化子部分で使用される名前の場合、同じ列挙内で以前に宣言された列挙子が最初に検出され、その後、非修飾名の検索が囲まれたブロック、クラス、または名前空間のスコープを調べます。</target>
        </trans-unit>
        <trans-unit id="6979bced06285133967c5c4b103d3e0247545465" translate="yes" xml:space="preserve">
          <source>For a name used inside a member function body, a default argument of a member function, an exception specification of a member function, a default member initializer, a &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt; of a member function(since C++20), or a nested class definition (including names of the bases from which the nested class is derived), the scopes searched are the same as in &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;class definition&lt;/a&gt;, except that the entire scope of the class is considered, not just the part prior to the declaration that uses the name. For nested classes the entire body of the enclosing class is searched.</source>
          <target state="translated">メンバー関数本体の内部で使用される名前、メンバー関数のデフォルト引数、メンバー関数の例外指定、デフォルトのメンバー初期化子、メンバー関数の&lt;a href=&quot;attributes/contract&quot;&gt;規約条件&lt;/a&gt;（C ++ 20以降）、またはネストされたクラス定義（ネストされたクラスの派生元のベースの名前を含む）、検索されるスコープは、&lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;クラス定義の&lt;/a&gt;場合と同じですが、名前を使用する宣言の前の部分だけでなく、クラスのスコープ全体が考慮されます。ネストされたクラスの場合は、囲んでいるクラスの本体全体が検索されます。</target>
        </trans-unit>
        <trans-unit id="5f9f456dc65dd5916b44e6d8b6b804f14836dd56" translate="yes" xml:space="preserve">
          <source>For a non-union aggregate, element for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</source>
          <target state="translated">非組合集合体の場合、指定されたイニシャライザがない要素は、イニシャライザ句の数がメンバーの数よりも少ない場合は、上記と同様に初期化されます(イニシャライザがある場合はデフォルトのメンバーイニシャライザ、それ以外の場合は空のリストイニシャライザ)。</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">AとBと呼ばれるMの原子修飾のペアについて、もしAとBがMの修飾順でAの後に来るならば、BはMの修飾順でAの後に来る。</target>
        </trans-unit>
        <trans-unit id="00a88dd4d98c693a356d74c5b2bd02963d1cfab7" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">2つの &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s XとYがあり、Aが次の場合、AとBと呼ばれるMのペアのアトミック操作の場合、AはMの値を書き込み、BはMの値を読み取ります。</target>
        </trans-unit>
        <trans-unit id="e8a036efd00fe52d195f38f7af9f452d212a3c7c" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;p&lt;/code&gt;, returns the size determined as if by reading the &lt;code&gt;st_size&lt;/code&gt; member of the structure obtained by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed).</source>
          <target state="translated">通常のファイル &lt;code&gt;p&lt;/code&gt; の場合、POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;statで&lt;/a&gt;取得した構造体の &lt;code&gt;st_size&lt;/code&gt; メンバーを読み取った場合と同じように決定されたサイズを返します（シンボリックリンクをたどります）。</target>
        </trans-unit>
        <trans-unit id="1a9910e8a0a912c3015de0a3b33c5c17808e192d" translate="yes" xml:space="preserve">
          <source>For a reverse iterator &lt;code&gt;r&lt;/code&gt; constructed from an iterator &lt;code&gt;i&lt;/code&gt;, the relationship &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; is always true (as long as &lt;code&gt;r&lt;/code&gt; is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</source>
          <target state="translated">イテレータ &lt;code&gt;i&lt;/code&gt; から構築された逆イテレータ &lt;code&gt;r&lt;/code&gt; の場合、関係 &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; は常に真です（ &lt;code&gt;r&lt;/code&gt; が逆参照可能である限り）。したがって、1つの過去の反復子から構築された逆反復子は、シーケンスの最後の要素を逆参照します。</target>
        </trans-unit>
        <trans-unit id="ad06b47edb0bcc2d8539e75487122b7c88338360" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.back()&lt;/code&gt; is equivalent to &lt;code&gt;*(c.end()-1)&lt;/code&gt;.</source>
          <target state="translated">スパン &lt;code&gt;c&lt;/code&gt; の場合、式 &lt;code&gt;c.back()&lt;/code&gt; は &lt;code&gt;*(c.end()-1)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="e1fa034a73d65c807607dcc81680fbdbbcb66bcc" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">スパン &lt;code&gt;c&lt;/code&gt; の場合、式 &lt;code&gt;c.front()&lt;/code&gt; は &lt;code&gt;*c.begin()&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="5c154bb2c5d060e3bc21cda45246264cc660e3cf" translate="yes" xml:space="preserve">
          <source>For a standard stream &lt;code&gt;str&lt;/code&gt;, synchronized with the C stream &lt;code&gt;f&lt;/code&gt;, the following pairs of functions have identical effect:</source>
          <target state="translated">Cストリーム &lt;code&gt;f&lt;/code&gt; と同期した標準ストリーム &lt;code&gt;str&lt;/code&gt; の場合、次の関数のペアは同じ効果を持ちます。</target>
        </trans-unit>
        <trans-unit id="de5683ef87cd469dd98d4cc4a0aed5b17f0dbfb7" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;T&lt;/code&gt;, the default value of &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is:</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の場合、 &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; デフォルト値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a003d5a71c47171b8ec220d6469cdc87d155fcf6" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;TC&lt;/code&gt;:</source>
          <target state="translated">タイプ &lt;code&gt;TC&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="28eb0e4e99d6754c04540069cc9b86b6e86b0026" translate="yes" xml:space="preserve">
          <source>For a unary operator &lt;code&gt;@&lt;/code&gt; whose argument has type &lt;code&gt;T1&lt;/code&gt; (after removing cv-qualifications), or binary operator &lt;code&gt;@&lt;/code&gt; whose left operand has type &lt;code&gt;T1&lt;/code&gt; and right operand of type &lt;code&gt;T2&lt;/code&gt; (after removing cv-qualifications), the following sets of candidate functions are prepared:</source>
          <target state="translated">引数の型が &lt;code&gt;T1&lt;/code&gt; である単項演算子 &lt;code&gt;@&lt;/code&gt; （cv-qualificationsを削除した後）、または左のオペランドが型 &lt;code&gt;T1&lt;/code&gt; で型 &lt;code&gt;T2&lt;/code&gt; の右のオペランド（cv-qualificationsを削除した後）を持つ二項演算子 &lt;code&gt;@&lt;/code&gt; の場合、次の候補関数のセットが準備されます。 ：</target>
        </trans-unit>
        <trans-unit id="a0f6b7e105043260b05aaf0d46100e8d47e56be4" translate="yes" xml:space="preserve">
          <source>For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.</source>
          <target state="translated">一部のメンバの値表現には参加しているが他のメンバの値表現には参加していないビットを持つユニオンの場合、アクティブ・メンバの値表現に参加していない場合、そのようなパディング・ビットは不確定な値を持つため、比較交換は常に失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1edec90a35f1485dfd1de3cb8edee29c85050704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be2f118aaee33f35b4a4d55d4b1363d900dc2269" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;comp(a,a)==false&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;a&lt;/code&gt; について、 &lt;code&gt;comp(a,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="232a0e7be31828ff9c9e76ce04deca11781e6a26" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;a&lt;/code&gt; について、 &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda67f6f48d3eaf152c442223488264fae5046f" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; is equal to &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;c&lt;/code&gt; および &lt;code&gt;d&lt;/code&gt; について、 &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; は &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt; と等しくなります</target>
        </trans-unit>
        <trans-unit id="2032585f99e27bc2ad7b8385f77f212571492869" translate="yes" xml:space="preserve">
          <source>For all other functions, reaching the end of a catch clause is equivalent to &lt;code&gt;return;&lt;/code&gt; if the function's return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">他のすべての関数では、catch句の終わりに到達することは &lt;code&gt;return;&lt;/code&gt; と同等です。関数の戻り値の型が（おそらくcv修飾された） &lt;code&gt;void&lt;/code&gt; の場合、それ以外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="da7d72e89e6f7a108ff843546e67ee1b3d8bf96b" translate="yes" xml:space="preserve">
          <source>For all other names (variables, namespaces, classes, etc), name lookup must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the &quot;struct hack&quot; or &quot;type/non-type hiding&quot;: Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a typedef, while all other occurrences of the same name either all refer to the same variable, non-static data member (since C++14), or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; to access it).</source>
          <target state="translated">他のすべての名前（変数、名前空間、クラスなど）の場合、プログラムをコンパイルするには、名前の検索で単一の宣言を生成する必要があります。スコープで名前を検索すると、その名前のすべての宣言が見つかりますが、「struct hack」または「type / non-type hiding」と呼ばれる1つの例外があります。同じスコープ内で、名前の一部が宣言を参照している場合がありますtypedefではないクラス/構造体/共用体/列挙型の場合、同じ名前の他のすべての出現は、すべて同じ変数、非静的データメンバー（C ++ 14以降）、または列挙子を参照するか、またはそれらすべてオーバーロードされている可能性がある関数または関数テンプレート名を参照してください。この場合、エラーは発生しませんが、型名はルックアップから非表示になります（コードは、アクセスするには&lt;a href=&quot;elaborated_type_specifier&quot;&gt;複雑な型指定子&lt;/a&gt;を使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="10db488ddc48847974dabc392b2f321428b2ad60" translate="yes" xml:space="preserve">
          <source>For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.</source>
          <target state="translated">その他のすべてのオブジェクト (簡単なデフォルトのコンストラクタで初期化されたクラス・オブジェクト、非クラス・オブジェクト、それらの配列など)については、ライフタイムは、オブジェクトの適切に配置されたストレージが割り当てられたときに始まり、そのストレージが他のオブジェクトによって解放されたり再利用されたりしたときに終了します。</target>
        </trans-unit>
        <trans-unit id="760abd8226337c152c576ef554b6c75c15801476" translate="yes" xml:space="preserve">
          <source>For all three operators, the usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">3つの演算子すべてについて、通常の算術変換が両方のオペランドで実行され、結果の型が決定されます。</target>
        </trans-unit>
        <trans-unit id="8d67a35b43e5bf5606d1d36920c0574ac4035475" translate="yes" xml:space="preserve">
          <source>For all values of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a == a&lt;/code&gt; yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">すべての値に対して、 &lt;code&gt;a == a&lt;/code&gt; 利回り &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7a423e3b93ec1547e0b8fd506cf138031deb4a" translate="yes" xml:space="preserve">
          <source>For an</source>
          <target state="translated">のために</target>
        </trans-unit>
        <trans-unit id="abab0bc9e7d335f8452e190fdf3bbe8302cb65a4" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;expressions#Operators&quot;&gt;operator&lt;/a&gt; used in expression (e.g., &lt;code&gt;operator+&lt;/code&gt; used in &lt;code&gt;a+b&lt;/code&gt;), the lookup rules are slightly different from the operator used in an explicit function-call expression such as &lt;code&gt;operator+(a,b)&lt;/code&gt;: when parsing an expression, two separate lookups are performed: for the non-member operator overloads and for the member operator overloads (for the operators where both forms are permitted). Those sets are then merged with the built-in operator overloads on equal grounds as described in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;. If explicit function call syntax is used, regular unqualified name lookup is performed:</source>
          <target state="translated">以下のために&lt;a href=&quot;expressions#Operators&quot;&gt;オペレータ&lt;/a&gt;の発現に用いられる（例えば、 &lt;code&gt;operator+&lt;/code&gt; で使用される &lt;code&gt;a+b&lt;/code&gt; ）、ルックアップルールは、次のような明示的な関数呼び出しの式で使用オペレータ若干異なる &lt;code&gt;operator+(a,b)&lt;/code&gt; の発現を解析するとき、二つの別々 。ルックアップが実行されます：非メンバー演算子のオーバーロードおよびメンバー演算子のオーバーロード（両方の形式が許可されている演算子の場合）。次に、これらのセットは、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロードの解決で&lt;/a&gt;説明されているように、等しい理由で組み込み演算子のオーバーロードとマージされます。明示的な関数呼び出し構文が使用されている場合、通常の非修飾名の検索が実行されます。</target>
        </trans-unit>
        <trans-unit id="cfdde08423e6892ce026f332e4722775a6fd0ec4" translate="yes" xml:space="preserve">
          <source>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is</source>
          <target state="translated">インライン関数またはインライン変数(C++17以降)の場合、それが</target>
        </trans-unit>
        <trans-unit id="b13c06c8df9fdd2618a4c37f530dfc9ec64faee7" translate="yes" xml:space="preserve">
          <source>For an object &lt;code&gt;m&lt;/code&gt; of Mutex type:</source>
          <target state="translated">Mutexタイプのオブジェクト &lt;code&gt;m&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="10c618faebd2cba6e4ed1d78498e9c737887c436" translate="yes" xml:space="preserve">
          <source>For an object of type &lt;code&gt;T&lt;/code&gt;,</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトの場合、</target>
        </trans-unit>
        <trans-unit id="9cbc15bac40798667e2c28ef32d8acd0bfca6527" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;year_month_day&lt;/code&gt; object &lt;code&gt;ymd&lt;/code&gt; representing a valid date (&lt;code&gt;ymd.ok() == true&lt;/code&gt;), converting &lt;code&gt;ymd&lt;/code&gt; to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value.</source>
          <target state="translated">有効な日付を表す任意の &lt;code&gt;year_month_day&lt;/code&gt; オブジェクト &lt;code&gt;ymd&lt;/code&gt; （ &lt;code&gt;ymd.ok() == true&lt;/code&gt; ）の場合、 &lt;code&gt;ymd&lt;/code&gt; を &lt;code&gt;sys_days&lt;/code&gt; に変換して戻すと、同じ値になります。</target>
        </trans-unit>
        <trans-unit id="f2a393f7232125085f4da3eb01cb2d41b026b8c4" translate="yes" xml:space="preserve">
          <source>For any object &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; is the real part of z and &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; is the imaginary part of z.</source>
          <target state="translated">&lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; 型のオブジェクト &lt;code&gt;z&lt;/code&gt; の場合、 &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; はzの実数部であり、 &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; zの虚数部です。</target>
        </trans-unit>
        <trans-unit id="aa002637ab58deab74ffaca3cf03066bd188d114" translate="yes" xml:space="preserve">
          <source>For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, lifetime begins when initialization ends.</source>
          <target state="translated">クラスまたは集約型のオブジェクト、またはそのサブオブジェクトのいずれかが&lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;自明なデフォルトコンストラクター&lt;/a&gt;以外で初期化されている場合、初期化が終了すると存続時間が始まります。</target>
        </trans-unit>
        <trans-unit id="cdd8992024517b51f7efb1e98465ebff61447714" translate="yes" xml:space="preserve">
          <source>For any object of class types whose &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; is not trivial, lifetime ends when the execution of the destructor begins.</source>
          <target state="translated">&lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;デストラクタ&lt;/a&gt;が自明ではないクラス型のオブジェクトの場合、デストラクタの実行が始まると寿命が終了します。</target>
        </trans-unit>
        <trans-unit id="fa44da499e47fc6fac2860172008adb9c1ff9a16" translate="yes" xml:space="preserve">
          <source>For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">その他のタイプの場合、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cefa90cb2c929a28be455e9f8fda7d414ab3948b" translate="yes" xml:space="preserve">
          <source>For any pointer to an element of an array of &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; named &lt;code&gt;p&lt;/code&gt; and any valid array index &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; is the real part of the complex number &lt;code&gt;p[i]&lt;/code&gt;, and &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; is the imaginary part of the complex number &lt;code&gt;p[i]&lt;/code&gt;</source>
          <target state="translated">任意の配列の要素へのポインタのための &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; という名前の &lt;code&gt;p&lt;/code&gt; および任意の有効な配列インデックス &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; 複素数の実数部である &lt;code&gt;p[i]&lt;/code&gt; 、および &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; は、複素数 &lt;code&gt;p[i]&lt;/code&gt; 虚数部です</target>
        </trans-unit>
        <trans-unit id="33bcdf350e21fefb2826ca912ee3190d4a971dc5" translate="yes" xml:space="preserve">
          <source>For any two values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; of the type &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt;, if &lt;code&gt;pred(A, B) == true&lt;/code&gt;, then &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; shall be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">任意の二つの値に対して &lt;code&gt;A&lt;/code&gt; 及び &lt;code&gt;B&lt;/code&gt; 型 &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt; 場合、 &lt;code&gt;pred(A, B) == true&lt;/code&gt; 、次いで、 &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; なければならない &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b450ffc7f721529dcdc6d1be9e46c5d50a2a925" translate="yes" xml:space="preserve">
          <source>For any type &lt;code&gt;T&lt;/code&gt; (including incomplete types), other than &lt;a href=&quot;functions&quot;&gt;function type&lt;/a&gt; or &lt;a href=&quot;reference&quot;&gt;reference type&lt;/a&gt;, there are three more distinct types in the C++ type system: const-qualified&lt;code&gt;T&lt;/code&gt;, volatile-qualified&lt;code&gt;T&lt;/code&gt;, and const-volatile-qualified&lt;code&gt;T&lt;/code&gt;.  Note: &lt;a href=&quot;array&quot;&gt;array types&lt;/a&gt; are considered to have the same cv-qualification as their element types.</source>
          <target state="translated">あらゆるタイプの &lt;code&gt;T&lt;/code&gt; 以外の（不完全型を含む）、&lt;a href=&quot;functions&quot;&gt;関数型&lt;/a&gt;または&lt;a href=&quot;reference&quot;&gt;参照型&lt;/a&gt; const修飾：、C ++型システムにおける3つの異なるタイプが存在する &lt;code&gt;T&lt;/code&gt; 、揮発性修飾 &lt;code&gt;T&lt;/code&gt; 、及びCONST揮発性修飾 &lt;code&gt;T&lt;/code&gt; は。注：&lt;a href=&quot;array&quot;&gt;配列型&lt;/a&gt;は、その要素型と同じcv-qualificationを持つと見なされます。</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">任意のzに対して、acos（z）=&amp;pi;-acos（-z）。</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">任意のzについて、atanh(z)=</target>
        </trans-unit>
        <trans-unit id="e254b6622c2f4cf79e478657cc199aa0c2eea2e9" translate="yes" xml:space="preserve">
          <source>For append streams (&lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt;), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt;, so that subsequent output will be appended to the last character copied from &lt;code&gt;s&lt;/code&gt;(since C++11)</source>
          <target state="translated">追加ストリーム（ &lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt; ）、 &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt; 場合、後続の出力は &lt;code&gt;s&lt;/code&gt; からコピーされた最後の文字に追加されます（C ++ 11以降） ）</target>
        </trans-unit>
        <trans-unit id="c24da57cc18573525a82a6c2c1fa0a27b061d0da" translate="yes" xml:space="preserve">
          <source>For arg&amp;gt;1, &amp;Sigma;&amp;infin;</source>
          <target state="translated">arg&amp;gt; 1の場合、&amp;Sigma;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="7046cc5d9597c58aa7e54080523a910de0e052c1" translate="yes" xml:space="preserve">
          <source>For arg&amp;lt;0, 2arg</source>
          <target state="translated">arg &amp;lt;0、2argの場合</target>
        </trans-unit>
        <trans-unit id="188be9f862ad64a9a657bafc75642d5f5c9f6a4f" translate="yes" xml:space="preserve">
          <source>For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt;.</source>
          <target state="translated">昇格の対象とならない算術型の場合、共通型は &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt; などの（混合モードの可能性がある）算術式の型と見なされる場合があります。</target>
        </trans-unit>
        <trans-unit id="79dccf2c6a91881692253227b281b3f534531201" translate="yes" xml:space="preserve">
          <source>For arithmetic types, the thousands separator character, obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;, is inserted into the sequence according to the grouping rules provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</source>
          <target state="translated">算術型の場合、 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; から取得される千単位の区切り文字が、stdによって提供されるグループ化規則に従ってシーケンスに挿入され &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01eb08fd12dd04934e4ddc13d646e9cc256574b" translate="yes" xml:space="preserve">
          <source>For auto-returning functions, the parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared return type of the function that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the expression of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, and if the return statement has no operand, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt;. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;T&lt;/code&gt; to get the actual return type:</source>
          <target state="translated">自動復帰関数の場合、パラメーター &lt;code&gt;P&lt;/code&gt; は次のように取得されます &lt;code&gt;auto&lt;/code&gt; を含む関数の宣言された戻り型である &lt;code&gt;T&lt;/code&gt; では、出現するすべての &lt;code&gt;auto&lt;/code&gt; が虚数型テンプレートパラメーター &lt;code&gt;U&lt;/code&gt; に置き換えられます。引数 &lt;code&gt;A&lt;/code&gt; は&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;ステートメントの式であり、returnステートメントにオペランドがない場合、 &lt;code&gt;A&lt;/code&gt; は &lt;code&gt;void()&lt;/code&gt; です。上記のルールに従って &lt;code&gt;P&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; を差し引いた後、差し引かれた &lt;code&gt;U&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; に代入して、実際の戻り値の型を取得します。</target>
        </trans-unit>
        <trans-unit id="21745cae4e72428f50d08dc188de6ed08f485b25" translate="yes" xml:space="preserve">
          <source>For both integer and floating-point types, if &lt;code&gt;showpos&lt;/code&gt; is set, the modifier &lt;code&gt;+&lt;/code&gt; is prepended</source>
          <target state="translated">整数型と浮動小数点型の両方で、 &lt;code&gt;showpos&lt;/code&gt; が設定されている場合、修飾子 &lt;code&gt;+&lt;/code&gt; が付加されます</target>
        </trans-unit>
        <trans-unit id="6e00438cc48aea953c237222b040f934d513cc5a" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored.</source>
          <target state="translated">どちらのオーバーロードでも、イテレータータイプが変更可能な場合、 &lt;code&gt;f&lt;/code&gt; は逆参照されたイテレーターを介して範囲の要素を変更する場合があります。 &lt;code&gt;f&lt;/code&gt; が結果を返す場合、結果は無視されます。</target>
        </trans-unit>
        <trans-unit id="d4b87d39492f3a203318f3eec5a45d21ed020f35" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored. If &lt;code&gt;n&lt;/code&gt; is less than zero, the behavior is undefined.</source>
          <target state="translated">どちらのオーバーロードでも、イテレータータイプが変更可能な場合、 &lt;code&gt;f&lt;/code&gt; は逆参照されたイテレーターを介して範囲の要素を変更する場合があります。 &lt;code&gt;f&lt;/code&gt; が結果を返す場合、結果は無視されます。 &lt;code&gt;n&lt;/code&gt; がゼロ未満の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="2cbfdeffec6dd0f35e1227e8a499f4b7385ae247" translate="yes" xml:space="preserve">
          <source>For both user-defined or implicitly-defined destructors, after the body of the destructor is executed, the compiler calls the destructors for all non-static non-variant members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in &lt;a href=&quot;constructor#Initialization_order&quot;&gt;reverse order of construction&lt;/a&gt; (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of most-derived class, it calls the destructors of all virtual bases.</source>
          <target state="translated">ユーザー定義または暗黙的に定義されたデストラクタの両方について、デストラクタの本体が実行された後、コンパイラはクラスのすべての非静的非バリアントメンバのデストラクタを宣言とは逆の順序で呼び出し、その後、デストラクタを呼び出しますすべての直接非仮想基本クラスは&lt;a href=&quot;constructor#Initialization_order&quot;&gt;、構築の逆の順序で&lt;/a&gt;（メンバーのデストラクタとその基本クラスなどを呼び出します）、次に、このオブジェクトが最も派生したクラスである場合、すべての仮想のデストラクタを呼び出します拠点。</target>
        </trans-unit>
        <trans-unit id="db34171dc6d92c22aa5da5d7cd5e78cc97249f77" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; より短いchar配列の場合、 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 符号付き対応物として機能します。これは、任意のタイプの配列のサイズを格納でき、ほとんどのプラットフォームでは &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt; と同義です。</target>
        </trans-unit>
        <trans-unit id="6f3c75e611a43557be37674fd1cb00bb164eeebf" translate="yes" xml:space="preserve">
          <source>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</source>
          <target state="translated">C89との互換性のために、パラメータリストに少なくとも1つのパラメータが含まれている場合は、省略可能なカンマが省略記号の前に現れることがあります。</target>
        </trans-unit>
        <trans-unit id="94880bd109360b34fd05f9d76510d26eb3dee88a" translate="yes" xml:space="preserve">
          <source>For constexpr function templates and constexpr member functions of class templates, at least one specialization must satisfy the abovementioned requirements. Other specializations are still considered as constexpr, even though a call to such a function cannot appear in a constant expression.</source>
          <target state="translated">constexpr関数テンプレートとクラステンプレートのconstexprメンバ関数については、少なくとも1つの特殊化が上述の要件を満たさなければならない。その他の特殊化は、そのような関数への呼び出しが定数式に現れなくても、constexprとみなされます。</target>
        </trans-unit>
        <trans-unit id="9efcdd76c0a92319514fd74592e33806161ca5b0" translate="yes" xml:space="preserve">
          <source>For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">フォーマットを制御するには、 &lt;code&gt;std::chrono::format&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="ce61db7d14bb600483458137835d50aed271a6ed" translate="yes" xml:space="preserve">
          <source>For creation of a full date, any of the following three orders are accepted:</source>
          <target state="translated">完全日の作成については、以下の3つの注文のいずれかを受け付けています。</target>
        </trans-unit>
        <trans-unit id="1e51f626291c443aca3537b45aaca51887d63f76" translate="yes" xml:space="preserve">
          <source>For detailed rules on overload resolution, see &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">オーバーロードの解決に関する詳細なルールについては、&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロードの解決を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ccd8ef2913234c8ce975d9ef8bd2b1cb54addbe" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;Ti&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;, the corresponding type &lt;code&gt;Vi&lt;/code&gt; in &lt;code&gt;VTypes...&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">それぞれについて &lt;code&gt;Ti&lt;/code&gt; で &lt;code&gt;Types...&lt;/code&gt; 、対応するタイプ &lt;code&gt;Vi&lt;/code&gt; の中 &lt;code&gt;VTypes...&lt;/code&gt; である &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; のアプリケーションない限り &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; における結果 &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; いくつかのタイプのための &lt;code&gt;X&lt;/code&gt; 、その場合、推定される型は &lt;code&gt;X&amp;amp;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ebdcf0767cd45dcef0e5f166fda3ae1b99a89262" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,j)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">毎 &lt;code&gt;i&lt;/code&gt; で &lt;code&gt;[0,j)&lt;/code&gt; 、 &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; 真であります</target>
        </trans-unit>
        <trans-unit id="a48fe3fe8c043eed63afe7b1696e912edb4e26e0" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt;.</source>
          <target state="translated">それぞれについて &lt;code&gt;i&lt;/code&gt; で &lt;code&gt;[0,n)&lt;/code&gt; 、実行 &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7673ab38c4ed279e12cc192b7a57b5fd910e9b3" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</source>
          <target state="translated">それぞれについて &lt;code&gt;i&lt;/code&gt; で &lt;code&gt;[0,n)&lt;/code&gt; 、実行 &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6ddee35ee106c63cce63cef04db68150835b00" translate="yes" xml:space="preserve">
          <source>For each declarator, the initializer may be one of the following:</source>
          <target state="translated">各宣言子について、イニシャライザは以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="71cdc882df31450c88808b61a9ff32adee6518cf" translate="yes" xml:space="preserve">
          <source>For each distinct base class that is specified &lt;code&gt;virtual&lt;/code&gt;, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited &lt;code&gt;virtual&lt;/code&gt; every time).</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; と指定された個別の基本クラスごとに、クラスが継承階層に何度も表示される場合でも（そのクラスが毎回 &lt;code&gt;virtual&lt;/code&gt; に継承されている限り）、最も派生したオブジェクトには、そのタイプの基本クラスサブオブジェクトが1つだけ含まれます。</target>
        </trans-unit>
        <trans-unit id="5bfb358921b4b02768fb8323b116ca9ed3bbe11d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の要素ごとに計算</target>
        </trans-unit>
        <trans-unit id="483eec964f0d73c99af70508de57de3007259d4d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の逆余弦を計算します。</target>
        </trans-unit>
        <trans-unit id="adb75759a95a8aeb64e9736b66397da9bd1d4446" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の逆正弦を計算します。</target>
        </trans-unit>
        <trans-unit id="ca88cd5ed53414ce6dc3bf89279bd5da6137ef0b" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の逆正接を計算します。</target>
        </trans-unit>
        <trans-unit id="f7b456dfebcb725eca2a813704a2d061981a4d5d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes common (base 10) logarithm of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の常用（底10）対数を計算します。</target>
        </trans-unit>
        <trans-unit id="604bbd841643b027a383acee66008e7977d1d958" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の余弦を計算します。</target>
        </trans-unit>
        <trans-unit id="6f10323acc53f3b6e728d81bacf3f244188492b8" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の双曲線余弦を計算します。</target>
        </trans-unit>
        <trans-unit id="d1e0c67a77c4c9f3880463f9d8f3aa99bf732d31" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の双曲線正弦を計算します。</target>
        </trans-unit>
        <trans-unit id="fea32eb8ad9df99ec39e088fce28cbee17276c80" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の双曲線正接を計算します。</target>
        </trans-unit>
        <trans-unit id="cd3565d6513a55d7d6d649e63d9ef8dc096c132d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes natural logarithm of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の自然対数を計算します。</target>
        </trans-unit>
        <trans-unit id="8613519bb915be734bdb83ddf1139c1436d679c7" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の正弦を計算します。</target>
        </trans-unit>
        <trans-unit id="16f2ed1e42028d25247c7e709cdd5ffa277bdfdc" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の正接を計算します。</target>
        </trans-unit>
        <trans-unit id="2e8b5a06d41da5547ea77c34dce52624edf4f443" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes the square root of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の各要素について、要素の値の平方根を計算します。</target>
        </trans-unit>
        <trans-unit id="de5098d9b31cace81235396b1ac2a117bb05f2f0" translate="yes" xml:space="preserve">
          <source>For each identifier, a variable whose type is &quot;reference to &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt;&quot; is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the i-th variable is.</source>
          <target state="translated">識別子ごとに、タイプが「 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt; への参照」である変数が導入されています。対応する初期化子が左辺値の場合は左辺値参照、それ以外の場合は右辺値参照。i番目の変数の初期化子は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e5405c9dfb873a374ff065f865a38e9ad5451317" translate="yes" xml:space="preserve">
          <source>For each non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; in &lt;code&gt;T&lt;/code&gt; or in a base of &lt;code&gt;T&lt;/code&gt; (unless hidden), whose cv-qualifiers is same or greater than &lt;code&gt;T&lt;/code&gt;'s cv-qualifiers, and where the conversion function converts to:</source>
          <target state="translated">各非明示するための&lt;a href=&quot;cast_operator&quot;&gt;ユーザ定義の変換関数&lt;/a&gt;における &lt;code&gt;T&lt;/code&gt; または塩基における &lt;code&gt;T&lt;/code&gt; CV-修飾子同じ又はより大きい（隠されていない限り）、 &lt;code&gt;T&lt;/code&gt; 「S CV-修飾子、および変換関数変換します。</target>
        </trans-unit>
        <trans-unit id="96919b66c472b53a5ced1aa599bee24bc87358ce" translate="yes" xml:space="preserve">
          <source>For each pair of viable function &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt;, the implicit conversion sequences from the &lt;code&gt;i&lt;/code&gt;-th argument to &lt;code&gt;i&lt;/code&gt;-th parameter are ranked to determine which one is better (except the first argument, the</source>
          <target state="translated">実行可能な関数 &lt;code&gt;F1&lt;/code&gt; と &lt;code&gt;F2&lt;/code&gt; の各ペアについて、 &lt;code&gt;i&lt;/code&gt; 番目の引数から &lt;code&gt;i&lt;/code&gt; 番目のパラメーターへの暗黙の変換シーケンスがランク付けされ、どちらがより良いかが決定されます（最初の引数を除いて、</target>
        </trans-unit>
        <trans-unit id="077e83335df9a76882a31f009c6cc740f8436fb9" translate="yes" xml:space="preserve">
          <source>For each such match &lt;code&gt;m&lt;/code&gt;, copies the non-matched subsequence (&lt;a href=&quot;match_results/prefix&quot;&gt;&lt;code&gt;m.prefix()&lt;/code&gt;&lt;/a&gt;) into &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; and then replaces the matched subsequence with the formatted replacement string as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">そのような一致 &lt;code&gt;m&lt;/code&gt; ごとに、一致しないサブシーケンス（&lt;a href=&quot;match_results/prefix&quot;&gt; &lt;code&gt;m.prefix()&lt;/code&gt; &lt;/a&gt;）を &lt;code&gt;out&lt;/code&gt; に &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; 。これは、out = std :: copy（m.prefix（）。first、m.prefix（）。second、out）および次に、&lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt; &lt;/a&gt;呼び出すのと同じように、一致したサブシーケンスをフォーマットされた置換文字列に置き換えます。</target>
        </trans-unit>
        <trans-unit id="35a02408e3ec343aa382ddb9f4539b81b6f6a912" translate="yes" xml:space="preserve">
          <source>For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template</source>
          <target state="translated">パラメータパックを含む各タイプ、非タイプ、テンプレートパラメータについて、固有の架空のタイプ、値、テンプレートが生成され、テンプレートの関数タイプに置換されます。</target>
        </trans-unit>
        <trans-unit id="952fe468d5ee316980e589da22eb6018ea32e1cd" translate="yes" xml:space="preserve">
          <source>For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">元の2つの範囲の等価な要素については、第1の範囲の要素(元の順序を保持する)が第2の範囲の要素(元の順序を保持する)よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="f8bf46aa49e5e80eadcaac2f31ab62ee0b13bf20" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">すべての &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; （特殊化されているかどうかにかかわらず）について、 &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="57dd021d134106ddd0d180af4fadda643026b891" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">すべての &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; （特殊化されているかどうかにかかわらず）について、 &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e51dc104fca63d5103f9e0cf646aa86197a6c341" translate="yes" xml:space="preserve">
          <source>For every T that is a pointer-to-member type or the type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">メンバーへのポインター型または &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 型であるすべてのTについて、次の関数シグネチャがオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 以外のすべての変換指定子について、指定されたフィールド幅を超えず、変換指定子が期待するものとまったく同じか、または期待されるシーケンスのプレフィックスである最も長い入力文字シーケンスが、ストリームから消費されます。この消費されたシーケンスの後の最初の文字（ある場合）は未読のままです。消費されたシーケンスの長さが0であるか、消費されたシーケンスが上記のように変換できない場合、ファイルの終わり、エンコーディングエラー、または読み取りエラーがストリームからの入力を妨げない限り、マッチングエラーが発生します。入力エラー。</target>
        </trans-unit>
        <trans-unit id="90c2546abb31c7caf07bad20c6eabba4b2fe603e" translate="yes" xml:space="preserve">
          <source>For every enumeration or pointer to member type &lt;code&gt;T&lt;/code&gt;, optionally volatile-qualified, the following function signature participates in overload resolution:</source>
          <target state="translated">列挙型またはメンバー型 &lt;code&gt;T&lt;/code&gt; へのポインター（オプションでvolatile修飾）の場合、次の関数シグネチャがオーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="88970b9a9ff96606e8a48b4759fd878eb0266d29" translate="yes" xml:space="preserve">
          <source>For every iterator type &lt;code&gt;It&lt;/code&gt;, a typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; is available, which is an alias to one of these five(until C++20)six(since C++20) tag types.</source>
          <target state="translated">すべてのイテレータタイプ &lt;code&gt;It&lt;/code&gt; について、typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; が使用可能です。これは、これらの5つのタグタイプ（C ++ 20まで）の6つ（C ++ 20以降）のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="e71c9303eec62288eff7b54439f77781e36bc155" translate="yes" xml:space="preserve">
          <source>For every optionally cv-qualified object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">オプションでcv修飾されたオブジェクトタイプ &lt;code&gt;T&lt;/code&gt; ごとに、次の関数シグネチャがオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="96c0842f465784a49ab8d68561798db17053d280" translate="yes" xml:space="preserve">
          <source>For every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signature participates in overload resolution:</source>
          <target state="translated">A1 が算術型(任意に volatile-qualified)であり、A2 が昇格算術型である A1 と A2 の各ペアについて、以下の関数シグネチャがオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="20e473aa5e7c31193000e4e17752d2e9b84efea5" translate="yes" xml:space="preserve">
          <source>For every pair I1 and I2, where I1 is an integral type (optionally volatile-qualified) and I2 is a promoted integral type, the following function signatures participate in overload resolution:</source>
          <target state="translated">I1 は積分型(任意に volatile-qualified)であり、I2 は昇格積分型であるため、以下の関数シグネチャが過負荷解決に関与します。</target>
        </trans-unit>
        <trans-unit id="fef8c5eb5bd67258e2ec4544fa11f3c0a8bfa352" translate="yes" xml:space="preserve">
          <source>For every pair of promoted arithmetic types L and R and for every type P, where P is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in the overload resolution performed in step 5 of the rules above:</source>
          <target state="translated">昇格された算術型LとRの各ペア、およびPがポインタ、ポインタツーメンバー、またはスコープ付き列挙型であるすべての型Pについて、以下の関数シグネチャは、上記の規則のステップ5で実行されるオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="d638c80e090b37ee12468ee54f0147dce03100fb" translate="yes" xml:space="preserve">
          <source>For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an invented template parameter is added to template-params, in order of appearance. The invented template parameter may be a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; if the corresponding function member of params is a function parameter pack.</source>
          <target state="translated">タイプが &lt;code&gt;auto&lt;/code&gt; として指定されているparams内のすべてのパラメーターについて、発明されたテンプレートパラメーターが出現順にtemplate-paramsに追加されます。paramsの対応する関数メンバーが関数&lt;a href=&quot;parameter_pack&quot;&gt;パラメーターパックである&lt;/a&gt;場合、発明されたテンプレートパラメーターはパラメーターパックである可能性があります。</target>
        </trans-unit>
        <trans-unit id="859f56c75df09c6419c76fcbdbe8ae8dbb4f8aed" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;MP&lt;/code&gt; that is a pointer to member object or pointer to member function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">メンバーオブジェクトへのポインター、メンバー関数へのポインター、または &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; であるすべての型 &lt;code&gt;MP&lt;/code&gt; について、次の関数シグネチャがオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="5ba25517699790e207bae588adda9d67eb82eb32" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;P&lt;/code&gt; which is either pointer to object or pointer to function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;(until C++14), the following function signatures participate in overload resolution:</source>
          <target state="translated">オブジェクトへのポインターまたは関数または &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; （C ++ 14まで）へのポインターであるすべての型 &lt;code&gt;P&lt;/code&gt; について、次の関数シグネチャがオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="ee4a3f0b05542f01bd799b3b751f77169b8294dd" translate="yes" xml:space="preserve">
          <source>For every type other than reference and function, the type system supports three additional &lt;a href=&quot;cv&quot;&gt;cv-qualified versions&lt;/a&gt; of that type (&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, and &lt;code&gt;const volatile&lt;/code&gt;).</source>
          <target state="translated">参照と関数以外のすべての型について、型システムはその型の3つの追加の&lt;a href=&quot;cv&quot;&gt;cv修飾バージョン&lt;/a&gt;（ &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;volatile&lt;/code&gt; 、および &lt;code&gt;const volatile&lt;/code&gt; ）をサポートします。</target>
        </trans-unit>
        <trans-unit id="ba768967270bb243200289babda957e1dccea676" translate="yes" xml:space="preserve">
          <source>For every valid value of &lt;code&gt;char_type&lt;/code&gt;, there must be a unique value of &lt;code&gt;int_type&lt;/code&gt; distinct from &lt;code&gt;eof()&lt;/code&gt;. For example, a common implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; is &lt;code&gt;return -1&lt;/code&gt;, and a corresponding valid implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; is &lt;code&gt;return (unsigned char)c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; の有効な値ごとに、 &lt;code&gt;eof()&lt;/code&gt; とは異なる &lt;code&gt;int_type&lt;/code&gt; の一意の値が必要です。たとえば、 &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; 一般的な実装は &lt;code&gt;return -1&lt;/code&gt; であり、対応する &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; 有効な実装は &lt;code&gt;return (unsigned char)c&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="220aba5bf092ed62052a3a23de11e863b192c055" translate="yes" xml:space="preserve">
          <source>For every virtual function, there is the</source>
          <target state="translated">すべての仮想関数に対して</target>
        </trans-unit>
        <trans-unit id="96405e325a2957f41ae4e0cb514953a5e216ba60" translate="yes" xml:space="preserve">
          <source>For example when the regex flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is set, then the sequence &lt;code&gt;[a-b]&lt;/code&gt; would match some character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt;. Note that this function takes a character sequence as the argument to accomodate to the ranges defined like &lt;code&gt;[&lt;/code&gt;&lt;code&gt;[.ae.]-d]&lt;/code&gt;.</source>
          <target state="translated">正規表現フラグ例えば &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 設定され、その後、シーケンス &lt;code&gt;[a-b]&lt;/code&gt; いくつかの文字と一致することになる &lt;code&gt;c1&lt;/code&gt; 場合 &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt; 。この関数は、 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;[.ae.]-d]&lt;/code&gt; ように定義された範囲に対応するために、引数として文字シーケンスをとります。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="21afdf58d530130e0cd1ecfb369c10eeeccc97f9" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int b:3;&lt;/code&gt; may have the range of values &lt;code&gt;0..7&lt;/code&gt; or &lt;code&gt;-4..3&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;int b:3;&lt;/code&gt; 値の範囲は &lt;code&gt;0..7&lt;/code&gt; または &lt;code&gt;-4..3&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b7d231fa0de4c53b5a41ff143b9ff0bc463fe738" translate="yes" xml:space="preserve">
          <source>For example, a gslice with starting index &lt;code&gt;3&lt;/code&gt;, strides &lt;code&gt;{19,4,1&lt;/code&gt;} and lengths &lt;code&gt;{2,4,3} &lt;/code&gt; generates the following set of indices:</source>
          <target state="translated">たとえば、開始インデックス &lt;code&gt;3&lt;/code&gt; 、ストライド &lt;code&gt;{19,4,1&lt;/code&gt; }、長さ &lt;code&gt;{2,4,3} &lt;/code&gt; のgsliceは、次のインデックスのセットを生成します。</target>
        </trans-unit>
        <trans-unit id="b98b27a6a16bb9a7bf0282ec3a82d51ac5557fa2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt;, the type of &lt;code&gt;i&lt;/code&gt; is exactly the type of the argument &lt;code&gt;u&lt;/code&gt; in an imaginary template &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; if the function call &lt;code&gt;f(expr)&lt;/code&gt; was compiled. Therefore, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.</source>
          <target state="translated">たとえば、 &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt; 、関数呼び出し &lt;code&gt;f(expr)&lt;/code&gt; がコンパイルされた場合、 &lt;code&gt;i&lt;/code&gt; の型は、仮想テンプレート &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; の引数 &lt;code&gt;u&lt;/code&gt; の型とまったく同じです。void f（const U＆u）したがって、 &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; は、範囲ベースのforループで使用されるイニシャライザに従って、左辺値参照または右辺値参照として推定できます。</target>
        </trans-unit>
        <trans-unit id="b64fbd2e8414cb52362895b9416d02f046ec2ac9" translate="yes" xml:space="preserve">
          <source>For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:</source>
          <target state="translated">例えば、ラッパーが単に引数を転送するのではなく、引数上のメンバ関数を呼び出し、その結果を転送する場合。</target>
        </trans-unit>
        <trans-unit id="3ad08d76cd3366adf2e4002a2a86eba860f92547" translate="yes" xml:space="preserve">
          <source>For example, if used in wrapper such as the following, the template behaves as described below:</source>
          <target state="translated">例えば、以下のようなラッパーで使用した場合、テンプレートは以下のように動作します。</target>
        </trans-unit>
        <trans-unit id="17f92461460ba9421050f5a120102adab4bd7d16" translate="yes" xml:space="preserve">
          <source>For example, in:</source>
          <target state="translated">例えば、で。</target>
        </trans-unit>
        <trans-unit id="8f787b27b81522ff7994a2b1d11b99ed11a43f0f" translate="yes" xml:space="preserve">
          <source>For example, on Windows, where &lt;code&gt;\&lt;/code&gt; is the preferred separator, the path &lt;code&gt;foo/bar&lt;/code&gt; will be converted to &lt;code&gt;foo\bar&lt;/code&gt;.</source>
          <target state="translated">たとえば、Windowsの場合、 &lt;code&gt;\&lt;/code&gt; が優先セパレーターであり、パス &lt;code&gt;foo/bar&lt;/code&gt; は &lt;code&gt;foo\bar&lt;/code&gt; 変換されます。</target>
        </trans-unit>
        <trans-unit id="c80798c74b99761f9f8d6a1d7f496bb6f7e553ba" translate="yes" xml:space="preserve">
          <source>For example, on some platforms, bit fields don't straddle bytes, on others they do</source>
          <target state="translated">例えば、あるプラットフォームではビットフィールドはバイトを跨がないが、他のプラットフォームでは跨ぐ。</target>
        </trans-unit>
        <trans-unit id="e2df7d9cb75dfece63f96a9945f6d4796b35277d" translate="yes" xml:space="preserve">
          <source>For example, the composite pointer type of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;const int*&lt;/code&gt; is &lt;code&gt;const void*&lt;/code&gt;. The composite pointer type of &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; is &lt;code&gt;const int* const*&lt;/code&gt;. Note that until C++14, &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; could not be compared.</source>
          <target state="translated">たとえば、 &lt;code&gt;void*&lt;/code&gt; と &lt;code&gt;const int*&lt;/code&gt; の複合ポインター型は &lt;code&gt;const void*&lt;/code&gt; です。 &lt;code&gt;int**&lt;/code&gt; と &lt;code&gt;const int**&lt;/code&gt; の複合ポインター型は &lt;code&gt;const int* const*&lt;/code&gt; です。C ++ 14までは、 &lt;code&gt;int**&lt;/code&gt; と &lt;code&gt;const int**&lt;/code&gt; 比較できなかったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="62bb742426a794f8be0f5a25a2d2f7632ae88b7a" translate="yes" xml:space="preserve">
          <source>For example, the following class template does not use the type T in its private members or in the body of push_back.</source>
          <target state="translated">例えば、以下のクラステンプレートでは、プライベートメンバやpush_backのボディでT型を使用していません。</target>
        </trans-unit>
        <trans-unit id="9c6f9185eeed0381f9dd1d89f296fbc5ee5be5b1" translate="yes" xml:space="preserve">
          <source>For example, to compile &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt;, the compiler performs:</source>
          <target state="translated">たとえば、 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt; をコンパイルするには、、コンパイラーは以下を実行します。</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">たとえば、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が最初はゼロの場合、</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f2cbbd695a1dfd1a4a615d31b844bf65755121de" translate="yes" xml:space="preserve">
          <source>For floating-point &amp;alpha;, the value obtained is the sum of &amp;alpha; independent exponentially distributed random variables, each of which has a mean of &amp;beta;</source>
          <target state="translated">浮動小数点&amp;alpha;の場合、得られる値は、&amp;alpha;の独立した指数分布確率変数の合計であり、それぞれに平均&amp;beta;があります。</target>
        </trans-unit>
        <trans-unit id="37bba3e4eccd73e2ef72c749ab8c25e15efc6e60" translate="yes" xml:space="preserve">
          <source>For floating-point types with denormalization, &lt;code&gt;min&lt;/code&gt; returns the minimum positive normalized value.</source>
          <target state="translated">非正規化を伴う浮動小数点型の場合、 &lt;code&gt;min&lt;/code&gt; は正の最小正規化値を返します。</target>
        </trans-unit>
        <trans-unit id="b593b953b77c2c511c9c9e8acca67b444d03c30c" translate="yes" xml:space="preserve">
          <source>For floating-point types, if &lt;code&gt;showpoint&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">浮動小数点型の場合、 &lt;code&gt;showpoint&lt;/code&gt; が設定されていると、修飾子 &lt;code&gt;#&lt;/code&gt; が付加されます。</target>
        </trans-unit>
        <trans-unit id="52fff2d809b2cb152e5b4a1ad6291720dc27d5c1" translate="yes" xml:space="preserve">
          <source>For floating-point types, the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.</source>
          <target state="translated">浮動小数点型の場合、有効な&lt;a href=&quot;../../numeric/fenv&quot;&gt;浮動小数点環境&lt;/a&gt;は、呼び出し側のスレッドの浮動小数点環境とは異なる場合があります。操作は、対応する &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; トレイトに準拠する必要はありませんが、準拠することをお勧めします。結果がその型の表現可能な値ではない場合、結果は不定ですが、それ以外の場合、操作の動作は未定義ではありません。</target>
        </trans-unit>
        <trans-unit id="5ab94c8e0b590e7f556887eaae16aec44908d571" translate="yes" xml:space="preserve">
          <source>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;. &lt;a href=&quot;function_template&quot;&gt;Template argument deduction&lt;/a&gt; may also apply, and the set of declarations is passed to &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which selects the declaration that will be used. &lt;a href=&quot;access&quot;&gt;Member access&lt;/a&gt; rules, if applicable, are considered only after name lookup and overload resolution.</source>
          <target state="translated">関数および関数テンプレート名の場合、名前のルックアップは、同じ名前の複数の宣言を関連付けることができ、&lt;a href=&quot;adl&quot;&gt;引数に依存するルックアップ&lt;/a&gt;から追加の宣言を取得できます。&lt;a href=&quot;function_template&quot;&gt;テンプレート引数の控除&lt;/a&gt;も適用される場合があり、宣言のセットが&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;に渡され、使用される宣言が選択されます。&lt;a href=&quot;access&quot;&gt;メンバーアクセス&lt;/a&gt;ルールは、該当する場合、名前の検索とオーバーロードの解決後にのみ考慮されます。</target>
        </trans-unit>
        <trans-unit id="36d9c94cd9c3cc36a9b671f755d250722c29f111" translate="yes" xml:space="preserve">
          <source>For functions, specifies that the return type will be deduced from its return statements.</source>
          <target state="translated">関数の場合、戻り値の型がその戻り値の文から推測されることを指定します。</target>
        </trans-unit>
        <trans-unit id="f9d92b090fe79a87f7ef3997de21c665c200fc40" translate="yes" xml:space="preserve">
          <source>For initialization of locals (that is, block scope) static and thread-local variables, see &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;static local variables&lt;/a&gt;.</source>
          <target state="translated">ローカル（ブロックスコープ）の静的変数とスレッドローカル変数の初期化については、&lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;静的ローカル変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac4327b8179e23975065e9af7bd05ec6be15b5bc" translate="yes" xml:space="preserve">
          <source>For input streams (&lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt;), &lt;code&gt;eback()&lt;/code&gt; points at the first character, &lt;code&gt;gptr() == eback()&lt;/code&gt;, and &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt;: the subsequent input will read the first character copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">入力ストリーム（ &lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt; ）の場合、 &lt;code&gt;eback()&lt;/code&gt; は最初の文字を &lt;code&gt;gptr() == eback()&lt;/code&gt; 、gptr（）== eback（）、および &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt; ：後続の入力は、 &lt;code&gt;s&lt;/code&gt; からコピーされた最初の文字を読み取ります。</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">入力ストリーム(および最後の操作が入力された更新ストリーム)については、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">整数 &lt;code&gt;arg&lt;/code&gt; の場合、2進数の対数は、入力の最上位1ビットのゼロベースのインデックスとして解釈できます。</target>
        </trans-unit>
        <trans-unit id="ed5f0c55df7482886d0bbb61dde66b50525bc79d" translate="yes" xml:space="preserve">
          <source>For integer types, if &lt;code&gt;showbase&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">整数型の場合、 &lt;code&gt;showbase&lt;/code&gt; が設定されていると、修飾子 &lt;code&gt;#&lt;/code&gt; が付加されます。</target>
        </trans-unit>
        <trans-unit id="cf8479d95c472194fb01daf6a842e55ed66b89af" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;h&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;</source>
          <target state="translated">整数型の場合、必要に応じて、長さ修飾子が変換仕様に追加されます &lt;code&gt;h&lt;/code&gt; は &lt;code&gt;short&lt;/code&gt; および &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; は &lt;code&gt;long&lt;/code&gt; および &lt;code&gt;unsigned long&lt;/code&gt; 、 &lt;code&gt;ll&lt;/code&gt; は &lt;code&gt;long long&lt;/code&gt; および &lt;code&gt;unsigned long long&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6101d794e56d2d1f4f0a50cfba90d4442ea8210d" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;(since C++11).</source>
          <target state="translated">必要であれば、整数型のために、長さ修飾子は、変換仕様に追加さ： &lt;code&gt;l&lt;/code&gt; のための &lt;code&gt;long&lt;/code&gt; と &lt;code&gt;unsigned long&lt;/code&gt; 型、 &lt;code&gt;ll&lt;/code&gt; のための &lt;code&gt;long long&lt;/code&gt; と &lt;code&gt;unsigned long long&lt;/code&gt; （C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="9635f0a469e86775a961c9f4f06c2d75d2ad2838" translate="yes" xml:space="preserve">
          <source>For integral and arithmetic types, the template argument provided during instantiation must be a &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the template parameter's type (so certain implicit conversion applies).</source>
          <target state="translated">整数型と算術型の場合、インスタンス化中に提供されるテンプレート引数は、テンプレートパラメーターの型の&lt;a href=&quot;constant_expression&quot;&gt;変換された定数式&lt;/a&gt;でなければなりません（したがって、特定の暗黙的な変換が適用されます）。</target>
        </trans-unit>
        <trans-unit id="888e66ad3cd1de9e2997f82859b81050f3f98936" translate="yes" xml:space="preserve">
          <source>For integral arguments, &lt;a href=&quot;abs&quot;&gt;the integral overloads of &lt;code&gt;std::abs&lt;/code&gt;&lt;/a&gt; are likely better matches. If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">積分引数の場合&lt;a href=&quot;abs&quot;&gt;、 &lt;code&gt;std::abs&lt;/code&gt; &lt;/a&gt;積分オーバーロードの方が一致する可能性があります。場合 &lt;code&gt;std::abs&lt;/code&gt; 型の引数で呼び出された &lt;code&gt;X&lt;/code&gt; よう &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; および &lt;code&gt;X&lt;/code&gt; は、に変換することはできません &lt;code&gt;int&lt;/code&gt; 型で&lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;不可欠なプロモーション&lt;/a&gt;、プログラムは悪いが形成されています。</target>
        </trans-unit>
        <trans-unit id="1060ee889330db82947214695c2314922ae38003" translate="yes" xml:space="preserve">
          <source>For integral operands, it yields the algebraic quotient.</source>
          <target state="translated">積分オペランドについては、代数的商が得られます。</target>
        </trans-unit>
        <trans-unit id="88259ad2a8442b91aaef00f672b4f16ecba02e17" translate="yes" xml:space="preserve">
          <source>For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage).</source>
          <target state="translated">lvalue参照パラメータの場合、インスタンス化時に提供される引数は、一時的なもの、名前のないlvalue、またはリンケージのない名前付きlvalueにすることはできません(言い換えれば、引数はリンケージを持っていなければなりません)。</target>
        </trans-unit>
        <trans-unit id="07ec985082848563aa89c0c13f4926e059b3c9cc" translate="yes" xml:space="preserve">
          <source>For member functions of class &lt;code&gt;X&lt;/code&gt;, the type of the implicit object parameter is affected by cv-qualifications and ref-qualifications of the member function as described in &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;.</source>
          <target state="translated">クラス &lt;code&gt;X&lt;/code&gt; のメンバー関数の場合、暗黙的なオブジェクトパラメーターの型は、メンバー関数で説明されているように、&lt;a href=&quot;member_functions&quot;&gt;メンバー関数の&lt;/a&gt; cv-qualificationsおよびref-qualificationsの影響を受けます。</target>
        </trans-unit>
        <trans-unit id="19791e90c11ccaf6d487d6bb230d6565f3784cc4" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;std::proj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">ほとんどの &lt;code&gt;z&lt;/code&gt; の場合、 &lt;code&gt;std::proj(z)==z&lt;/code&gt; ですが、すべての複素数の無限大は、1つの成分が無限大で、もう1つの成分がNaNである場合でも、正の実無限大、 &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; または &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt; 。虚数（ゼロ）成分の符号は、 &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt; 符号です。</target>
        </trans-unit>
        <trans-unit id="dedc12147e0e26b892c9c3c4c65e52f5512feb4a" translate="yes" xml:space="preserve">
          <source>For multi-level pointers, the following restrictions apply: a multilevel pointer &lt;code&gt;P1&lt;/code&gt; which is cv1</source>
          <target state="translated">マルチレベルポインターの場合、次の制限が適用されます。cv1であるマルチレベルポインター &lt;code&gt;P1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376ecc03409163c2995d77d8d27738cf7cb39e45" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the behavior of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is undefined.</source>
          <target state="translated">負の &lt;code&gt;a&lt;/code&gt; の場合、 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="1494de8919bb1c4ea96591e8c652173df74c133c" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</source>
          <target state="translated">負の &lt;code&gt;a&lt;/code&gt; の場合、 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 値は実装定義です（ほとんどの実装では、これは算術右シフトを実行するため、結果は負のままです）。</target>
        </trans-unit>
        <trans-unit id="8d245548c2af614dd2b79e9d581bbfee18630af5" translate="yes" xml:space="preserve">
          <source>For non-&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; class types, members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; are always allocated so that the members declared later have higher addresses within a class object. Members with different access control are allocated in unspecified order (the compiler may group them together). Alignment requirements may necessitate padding between members, or after the last member of a class.</source>
          <target state="translated">非&lt;a href=&quot;union&quot;&gt;共用&lt;/a&gt;クラス型の場合、後で宣言されたメンバーがクラスオブジェクト内でより高いアドレスを持つように、同じ&lt;a href=&quot;access&quot;&gt;メンバーアクセスを&lt;/a&gt;持つメンバーが常に割り当てられます。異なるアクセス制御を持つメンバーは、不特定の順序で割り当てられます（コンパイラーがそれらをグループ化する場合があります）。配置要件により、メンバー間、またはクラスの最後のメンバーの後にパディングが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="9b6b58d70b3d593d4d88872f97e32d333db88729" translate="yes" xml:space="preserve">
          <source>For non-appending output streams, &lt;code&gt;pptr() == pbase()&lt;/code&gt;, so that subsequent output will overwrite the characters copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">追加されない出力ストリームの場合、 &lt;code&gt;pptr() == pbase()&lt;/code&gt; 。これにより、後続の出力は &lt;code&gt;s&lt;/code&gt; からコピーされた文字を上書きします。</target>
        </trans-unit>
        <trans-unit id="606fb425d7d848cb68effbf7891839f3901900f6" translate="yes" xml:space="preserve">
          <source>For non-array &lt;code&gt;type&lt;/code&gt;, the single object is constructed in the acquired memory area.</source>
          <target state="translated">非配列 &lt;code&gt;type&lt;/code&gt; 場合、取得したメモリ領域に単一オブジェクトが構築されます。</target>
        </trans-unit>
        <trans-unit id="2e50302a0b35323ade517a1a99cf0e861fd9f2ad" translate="yes" xml:space="preserve">
          <source>For non-class types, copy and move assignment are indistinguishable and are referred to as</source>
          <target state="translated">非クラスタイプでは、コピーと移動の割り当ては区別できず、以下のように呼ばれています。</target>
        </trans-unit>
        <trans-unit id="961645d5c1ea45b10c1dab6cd681b33d3b3e7623" translate="yes" xml:space="preserve">
          <source>For non-class types, the right operand is first &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the cv-unqualified type of the left operand, and then its value is copied into the object identified by left operand.</source>
          <target state="translated">非クラス型の場合、最初に右のオペランドが&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的に&lt;/a&gt;左のオペランドのcv非修飾型に変換され、次にその値が左のオペランドで識別されるオブジェクトにコピーされます。</target>
        </trans-unit>
        <trans-unit id="763322c7964e589eee6959c4585b224d003bfdec" translate="yes" xml:space="preserve">
          <source>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</source>
          <target state="translated">非ポリモーフィックオブジェクトの場合、値の解釈はオブジェクトが使用されている式から決定され、コンパイル時に決定されます。</target>
        </trans-unit>
        <trans-unit id="abfd29ae0e4b12baa41dd1f2957ee892d3a0b889" translate="yes" xml:space="preserve">
          <source>For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the defaults are a union of the defaults provided in all visible declarations for the function. A redeclaration cannot introduce a default for an argument for which a default is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.</source>
          <target state="translated">テンプレートではない関数の場合、その関数が同じスコープで再宣言されている場合、すでに宣言されている関数にデフォルト引数を追加することができます。関数呼び出しの時点で、デフォルトは、その関数のすべての可視宣言で提供されるデフォルトの和となります。再宣言は、デフォルトが既に可視化されている引数に対してデフォルトを導入することはできません(値が同じであっても)。内部スコープ内の再宣言は、外部スコープからのデフォルト引数を取得しません。</target>
        </trans-unit>
        <trans-unit id="0991570f4540f46325a93449ba04cca879b380b0" translate="yes" xml:space="preserve">
          <source>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</source>
          <target state="translated">テンプレート・パラメータ・パックでタイプがプレースホルダ・タイプを使用する非タイプの場合、タイプはテンプレート引数ごとに独立して推論され、一致する必要はありません。</target>
        </trans-unit>
        <trans-unit id="bd5aba2924605ce9fcbd81eb53c058fae5c7dea4" translate="yes" xml:space="preserve">
          <source>For non-type template parameters, specifies that the type will be deduced from the argument.</source>
          <target state="translated">型を持たないテンプレートパラメータの場合、引数から型を推論することを指定します。</target>
        </trans-unit>
        <trans-unit id="7514bfabe1453bf3e4fa04b102092e65768ddd6d" translate="yes" xml:space="preserve">
          <source>For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</source>
          <target state="translated">ユニオン以外のクラスタイプ（ &lt;code&gt;class&lt;/code&gt; および &lt;code&gt;struct&lt;/code&gt; ）の場合、移動割り当て演算子は、スカラーの組み込み割り当てを使用して、オブジェクトの直接ベースと直接の非静的メンバーのメンバーごとの移動割り当てを宣言順に実行します。配列の移動割り当て、およびクラス型の移動割り当て演算子（非仮想と呼ばれます）。</target>
        </trans-unit>
        <trans-unit id="268fe4cbc20a4aa0215c7d01242785136c98fb6e" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">空でない範囲の場合、正確に &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; 対応する述語の1つのアプリケーション。</target>
        </trans-unit>
        <trans-unit id="f6180b71feea7358927f872628400b8246c94135" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">空でない範囲の場合、対応する述語の正確な &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; アプリケーション。</target>
        </trans-unit>
        <trans-unit id="6147555f2527654078938dabd88a3dffc2574f9a" translate="yes" xml:space="preserve">
          <source>For objects of non-aggregate class type, a public &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructor&lt;/a&gt; must be defined (either user-defined or implicitly defined) to satisfy DefaultConstructible.</source>
          <target state="translated">非集約クラスタイプのオブジェクトの場合、DefaultConstructibleを満たすために、パブリック&lt;a href=&quot;../language/default_constructor&quot;&gt;デフォルトコンストラクターを&lt;/a&gt;定義する（ユーザー定義または暗黙的に定義する）必要があります。</target>
        </trans-unit>
        <trans-unit id="5e455249348a9249c3d467d0641b99a240d6d8c9" translate="yes" xml:space="preserve">
          <source>For other contexts where overloaded function names can appear, see &lt;a href=&quot;overloaded_address&quot;&gt;taking the address of an overloaded function&lt;/a&gt;.</source>
          <target state="translated">オーバーロードされた関数名が表示される可能性がある他のコンテキストについて&lt;a href=&quot;overloaded_address&quot;&gt;は、オーバーロードされた関数のアドレスの取得を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e2bc8579aeb917ea35ac1bcbad18eb05fd4bdc45" translate="yes" xml:space="preserve">
          <source>For output streams (&lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt;), &lt;code&gt;pbase()&lt;/code&gt; points at the first character and &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr is allowed to point farther so that the following &lt;code&gt;sputc()&lt;/code&gt; wouldn't immediately call &lt;code&gt;overflow()&lt;/code&gt;)</source>
          <target state="translated">出力ストリーム（のための &lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt; ）、 &lt;code&gt;pbase()&lt;/code&gt; の最初の文字とで点 &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; （epptrが遠いので、ポイントが許可されていることを次の &lt;code&gt;sputc()&lt;/code&gt; はすぐに &lt;code&gt;overflow()&lt;/code&gt; を呼び出さないでしょう）</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">出力ストリームの場合（および最後の操作が出力された更新ストリームの場合）、 &lt;code&gt;stream&lt;/code&gt; のバッファーから関連する出力デバイスに、書き込まれていないデータを書き込みます。</target>
        </trans-unit>
        <trans-unit id="481575f6bdf13b67deef2e241c2a9a6d1c8d891f" translate="yes" xml:space="preserve">
          <source>For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;), is to do nothing.</source>
          <target state="translated">出力ストリームの場合、これにより、通常、配置領域の内容が関連するシーケンスに書き込まれます（出力バッファーのフラッシュなど）。入力ストリームの場合、これは通常、get領域を空にし、関連するシーケンスからの再読み取りを強制して、最近の変更を取得します。デフォルトの動作（たとえば、 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; ）では、何も実行されません。</target>
        </trans-unit>
        <trans-unit id="a6ae1e52a83b6ade1ae039896874969c5f21c0bf" translate="yes" xml:space="preserve">
          <source>For overload (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">オーバーロード（5）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="75a2c90c2bfc30a317a46c88b8a56739d5f6fa1d" translate="yes" xml:space="preserve">
          <source>For overload (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">オーバーロード（6）の場合、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; はどちらも &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2780c151ef71bd4320af5b5a8131bcdca9bcbb78" translate="yes" xml:space="preserve">
          <source>For overloads (1,2), if one of the parameters is an rvalue, the reference returned becomes a dangling reference at the end of the full expression that contains the call to &lt;code&gt;minmax&lt;/code&gt;:</source>
          <target state="translated">オーバーロード（1、2）の場合、パラメーターの1つが右辺値の場合、返される参照は、 &lt;code&gt;minmax&lt;/code&gt; への呼び出しを含む完全な式の最後にぶら下がり参照になります。</target>
        </trans-unit>
        <trans-unit id="8382a9060c467fcc4ada14b4b211aabe3aa6d683" translate="yes" xml:space="preserve">
          <source>For overloads (3,5,7,9), The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">オーバーロード（3、5、7、9）の場合、関数は &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; とは異なる戻り値の型で実装できます。この場合、置換タイプには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="e863547ad76debf1e954b0555a0ab321eb1a4d01" translate="yes" xml:space="preserve">
          <source>For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</source>
          <target state="translated">関数へのポインタの場合、有効な引数はリンケージを持つ関数へのポインタ(またはヌルポインタ値に評価される定数式)です。</target>
        </trans-unit>
        <trans-unit id="0c14d4f91a6fd67c34187b14315456bf4871a9d3" translate="yes" xml:space="preserve">
          <source>For pointers to member functions and pointers to data members, &lt;code&gt;t1&lt;/code&gt; may be a regular pointer or an object of class type that overloads &lt;code&gt;operator*&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">メンバー関数へのポインターとデータメンバーへのポインターの場合、 &lt;code&gt;t1&lt;/code&gt; は通常のポインター、または &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; などの &lt;code&gt;operator*&lt;/code&gt; をオーバーロードするクラス型のオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="a71d4a336a0c5624e650b25202bdefde98d600fd" translate="yes" xml:space="preserve">
          <source>For pointers to members, the argument has to be a pointer to member expressed as &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; or a constant expression that evaluates to null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">メンバーへのポインターの場合、引数は &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; として表現されるメンバーへのポインター、またはnullポインターまたは &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 値に評価される定数式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a1d3d2317fc6b323549d75e48efcd87a6d6fa4bd" translate="yes" xml:space="preserve">
          <source>For pointers to objects, the template arguments have to designate the address of a complete object with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and a &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; (either internal or external), or a constant expression that evaluates to the appropriate null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">オブジェクトへのポインターの場合、テンプレート引数は、静的な&lt;a href=&quot;storage_duration&quot;&gt;記憶期間&lt;/a&gt;と&lt;a href=&quot;storage_duration#Linkage&quot;&gt;リンケージ&lt;/a&gt;（内部または外部のいずれか）を持つ完全なオブジェクトのアドレス、または適切なnullポインターまたは &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 値に評価される定数式を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="62b3bed6c74847c88d09ff91b5a9eb3064f5365b" translate="yes" xml:space="preserve">
          <source>For portable directory and file naming, see &lt;a href=&quot;../../filesystem&quot;&gt;C++ filesystem library&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;.</source>
          <target state="translated">移植可能なディレクトリとファイルの命名については、&lt;a href=&quot;../../filesystem&quot;&gt;C ++ファイルシステムライブラリ&lt;/a&gt;または&lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystemを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bb935bbe4c86edf17255328af95f195fe665edf1" translate="yes" xml:space="preserve">
          <source>For portable pathname generation from Unicode strings, see &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;.</source>
          <target state="translated">Unicode文字列からのポータブルパス名の生成については、&lt;a href=&quot;u8path&quot;&gt;u8pathを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0dfb375daadbb3e77fbf4f5775a23c9dc598be6b" translate="yes" xml:space="preserve">
          <source>For proper values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, the following properties are true:</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; の適切な値については、次のプロパティが当てはまります。</target>
        </trans-unit>
        <trans-unit id="530c267bd41398cdf37d989d6c0ff07e1066ef3d" translate="yes" xml:space="preserve">
          <source>For prvalue expressions, the dynamic type is always the same as the static type.</source>
          <target state="translated">prvalue式の場合、動的型は常に静的型と同じです。</target>
        </trans-unit>
        <trans-unit id="adfb2dec7da66f103fd2b9cd71521128041db54d" translate="yes" xml:space="preserve">
          <source>For signed &lt;code&gt;Integral&lt;/code&gt; types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">符号付き &lt;code&gt;Integral&lt;/code&gt; 型の場合、算術は2の補数表現を使用するように定義されています。未定義の結果はありません。</target>
        </trans-unit>
        <trans-unit id="ed5e530786bebc7b272d33fe3e9f636b75dcece4" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, if a * 2b</source>
          <target state="translated">署名し、非負の場合 &lt;code&gt;a&lt;/code&gt; 、* 2bがあれば</target>
        </trans-unit>
        <trans-unit id="3af751b6ecf63d4481061bc54946dd23bc4bd1ff" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is a * 2b</source>
          <target state="translated">署名し、非負のために &lt;code&gt;a&lt;/code&gt; の値 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; * 2Bあります</target>
        </trans-unit>
        <trans-unit id="8d1075cea1a2a6de71e067eda636b7104a7e1c7b" translate="yes" xml:space="preserve">
          <source>For signed integral types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">符号付き整数型の場合、算術は2の補数表現を使用するように定義されています。未定義の結果はありません。</target>
        </trans-unit>
        <trans-unit id="7df120d1e9011ddd1ce77a96f4b12ae1b34f6af9" translate="yes" xml:space="preserve">
          <source>For some &lt;code&gt;j&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; is true and</source>
          <target state="translated">一部の &lt;code&gt;j&lt;/code&gt; における &lt;code&gt;[0,n)&lt;/code&gt; 、 &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; 真であると</target>
        </trans-unit>
        <trans-unit id="81ca343fa42d2babb2e6749bedea9b053e460258" translate="yes" xml:space="preserve">
          <source>For some engines, &quot;fast jump&quot; algorithms are known, which advance the state by many steps (order of millions) without calculating intermediate state transitions, although not necessarily in constant time.</source>
          <target state="translated">いくつかのエンジンでは、「高速ジャンプ」アルゴリズムが知られています。これは、中間的な状態遷移を計算せずに何段階(数百万オーダー)ものステップで状態を進めるものですが、必ずしも一定時間ではありません。</target>
        </trans-unit>
        <trans-unit id="fd4abd3a725738e4ad1d6b4cf76b4fe8cb02df5a" translate="yes" xml:space="preserve">
          <source>For some of the C standard library headers of the form &lt;code&gt;xxx.h&lt;/code&gt;, the C++ standard library both includes an identically-named header and another header of the form &lt;code&gt;cxxx&lt;/code&gt; (all meaningful &lt;code&gt;cxxx&lt;/code&gt; headers are listed above).</source>
          <target state="translated">&lt;code&gt;xxx.h&lt;/code&gt; 形式の一部のC標準ライブラリヘッダーの場合、C ++標準ライブラリには、同じ名前のヘッダーと &lt;code&gt;cxxx&lt;/code&gt; 形式の別のヘッダーの両方が含まれます（意味のあるすべての &lt;code&gt;cxxx&lt;/code&gt; ヘッダーが上にリストされています）。</target>
        </trans-unit>
        <trans-unit id="cf567f1a3c60615e84656e20417b1a1de74545ac" translate="yes" xml:space="preserve">
          <source>For some of the signals, the implementation may call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; at the startup of the program. For the rest, the implementation must call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">一部のシグナルについては、プログラムの起動時に実装が &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; を呼び出す場合があります。それ以外の場合、実装は &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="7f03372ec69aa391f826e43bea001123512eb679" translate="yes" xml:space="preserve">
          <source>For standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero value.</source>
          <target state="translated">標準属性については、その属性が作業草案に追加された年と月に展開されます(下の表を参照)、ベンダー固有の属性の存在は、ゼロではない値によって決定されます。</target>
        </trans-unit>
        <trans-unit id="b56d8ebf643b96a82d52768c03f8db9aa07210bd" translate="yes" xml:space="preserve">
          <source>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;dependent type&lt;/a&gt;). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</source>
          <target state="translated">推定戻り値型のテンプレート関数の場合、戻り値は追加の制限なしに事後条件で名前を付けることができます（ただし、戻り値の名前は&lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;依存型&lt;/a&gt;を持つものとして扱われます）。戻り値の型が推定された非テンプレート関数の場合、戻り値の名前を宣言で禁止します（ただし、定義では許可されます）。</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">以下のための &lt;code&gt;A&lt;/code&gt; の変換スタイル</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">以下のための &lt;code&gt;E&lt;/code&gt; の変換スタイル</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">&lt;code&gt;G&lt;/code&gt; 変換の場合、スタイル &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;F&lt;/code&gt; のスタイル変換が実行されます。</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">以下のために &lt;code&gt;X&lt;/code&gt; の変換文字 &lt;code&gt;ABCDEF&lt;/code&gt; 使用されています。</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">以下のための &lt;code&gt;a&lt;/code&gt; 変換スタイル</target>
        </trans-unit>
        <trans-unit id="ff2ab4c944a5b84fe46520d57012d6c750be1de1" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;char&lt;/code&gt; specialization, &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt; are defined identically to the built-in operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; for type &lt;code&gt;unsigned char&lt;/code&gt; (</source>
          <target state="translated">ため &lt;code&gt;char&lt;/code&gt; 専門、 &lt;code&gt;eq&lt;/code&gt; および &lt;code&gt;lt&lt;/code&gt; 内蔵オペレータに同一に定義されている &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;&amp;lt;&lt;/code&gt; タイプに &lt;code&gt;unsigned char&lt;/code&gt; 型（</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">以下のための &lt;code&gt;e&lt;/code&gt; 変換スタイル</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 変換の場合、スタイル &lt;code&gt;e&lt;/code&gt; または &lt;code&gt;f&lt;/code&gt; のスタイル変換が実行されます。</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">以下のため &lt;code&gt;x&lt;/code&gt; 変換文字 &lt;code&gt;abcdef&lt;/code&gt; 使用されています。</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">| arg |の場合、IEEE互換タイプ &lt;code&gt;double&lt;/code&gt; の場合 &amp;gt; 710.5の場合、 &lt;code&gt;cosh(arg)&lt;/code&gt; がオーバーフローします。</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">IEEE互換の型 &lt;code&gt;double&lt;/code&gt; の場合、 &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55の場合、アンダーフローが保証されます。</target>
        </trans-unit>
        <trans-unit id="5139171c7dc4bf39c00774f4969ee9ed5cb06814" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default date format (if any), this function is usually case-insensitive.</source>
          <target state="translated">デフォルトの日付書式のアルファベット成分(もしあれば)については、この関数は通常、大文字小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="ca85fb6216b889960979e71b66f45292ecb6fff0" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default time format (if any), this function is usually case-insensitive.</source>
          <target state="translated">デフォルトの時刻フォーマットのアルファベット成分(もしあれば)については、この関数は通常、大文字小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="3387ca380771e46f30ac460b364c23f3a50ac485" translate="yes" xml:space="preserve">
          <source>For the binary operators (except shifts), if the promoted operands have different types, additional set of implicit conversions is applied, known as</source>
          <target state="translated">バイナリ演算子(シフトを除く)では、昇格したオペランドが異なる型を持つ場合、暗黙の変換の追加セットが適用されます。</target>
        </trans-unit>
        <trans-unit id="5834b75a1d37489895cb80d1b1901ebbb10cdea5" translate="yes" xml:space="preserve">
          <source>For the built-in logical AND operator, the result is &lt;code&gt;true&lt;/code&gt; if both operands are &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;. This operator is &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;: if the first operand is &lt;code&gt;false&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">組み込みの論理AND演算子の場合、両方のオペランドが &lt;code&gt;true&lt;/code&gt; であれば結果は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、結果は &lt;code&gt;false&lt;/code&gt; です。この演算子は&lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;短絡的&lt;/a&gt;です。最初のオペランドが &lt;code&gt;false&lt;/code&gt; の場合、2番目のオペランドは評価されません。</target>
        </trans-unit>
        <trans-unit id="4f868d872215ad926f03072ef85906893d1cbc9f" translate="yes" xml:space="preserve">
          <source>For the built-in logical NOT operator, the result is &lt;code&gt;true&lt;/code&gt; if the operand is &lt;code&gt;false&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">組み込みの論理NOT演算子の場合、オペランドが &lt;code&gt;false&lt;/code&gt; の場合、結果は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、結果は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="98a7f937369cdbc13ece1f4624b3c0deaca24c09" translate="yes" xml:space="preserve">
          <source>For the built-in logical OR operator, the result is &lt;code&gt;true&lt;/code&gt; if either the first or the second operand (or both) is &lt;code&gt;true&lt;/code&gt;. This operator is short-circuiting: if the first operand is &lt;code&gt;true&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">組み込みの論理OR演算子の場合、第1オペランドまたは第2オペランド（あるいはその両方）のいずれかが &lt;code&gt;true&lt;/code&gt; の場合、結果はtrue &lt;code&gt;true&lt;/code&gt; 。この演算子は短絡的です。最初のオペランドが &lt;code&gt;true&lt;/code&gt; の場合、2番目のオペランドは評価されません。</target>
        </trans-unit>
        <trans-unit id="e1db3901d3c9b8e71a137ee3fd4f6e31711c8ecd" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</source>
          <target state="translated">組込み演算子の場合、式は算術型またはスコープなしの列挙型でなければなりません。オペランドに対して積分昇格が行われ、結果の型が決定されます。</target>
        </trans-unit>
        <trans-unit id="ed7967925e3d9a903dc61fad15c26826b80985cc" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</source>
          <target state="translated">組込み演算子の場合、式は算術型、アンスコープされていない列挙型、またはポインタ型を持っていなければなりません。オペランドが積分型またはアンスコープされていない列挙型を持っている場合、オペランドに対して積分促進が行われ、結果の型が決定されます。</target>
        </trans-unit>
        <trans-unit id="1f4b14dfb9171534a115c48cff5a996c8739f0c3" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must be one of the following:</source>
          <target state="translated">組み込み演算子の場合、rhsとrhsは以下のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c2fd6c69985c326b9c90b5457d6125aba9680de4" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have arithmetic or unscoped enumeration type.</source>
          <target state="translated">組み込み演算子の場合、rhs と rhs は両方とも算術型またはスコープなしの列挙型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="21aefc527d6a29a300de35c2b1a6e0de364db29e" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have integral or unscoped enumeration type</source>
          <target state="translated">組み込み演算子の場合、rhs と rhs の両方が積分型またはスコープなしの列挙型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="0e1c1ef458021530f026a00ce0e6a1cdf579bce8" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs may have any non-const scalar type and rhs must be implicitly convertible to the type of lhs.</source>
          <target state="translated">組込み演算子の場合,lhs は任意の非コンスタントなスカラ型を持つことができ,rhs は暗黙のうちに lhs の型に変換可能でなければなりません.</target>
        </trans-unit>
        <trans-unit id="0fc6e93f0b5ccc41116e96e66ba6cc181fbeaf32" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</source>
          <target state="translated">組込み演算子の場合、rhsとrhsは両方とも積分型またはスコープなしの列挙型を持っていなければなりません。積分プロモーショ ンは両方のオペランドで実行されます。</target>
        </trans-unit>
        <trans-unit id="8b5909dfd25b823a91c25e0c6ebfb4fe115565d4" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">組込み演算子の場合、rhsとrhsは両方とも積分またはスコープなしの列挙型を持っていなければなりません。通常の算術変換は両方のオペランドで実行され、結果の型を決定します。</target>
        </trans-unit>
        <trans-unit id="631e90fa71e23701d70b68b196fb2c8886d4ce41" translate="yes" xml:space="preserve">
          <source>For the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.</source>
          <target state="translated">文字シーケンス &lt;code&gt;[first, last)&lt;/code&gt; 場合、組み込みロケールの照合順序、つまり国別アルファベットの文字と照合単位の位置に基づくソートキーのプライマリソートキーを取得します。大文字と小文字は区別されません。バリアントなど。プライマリソートキーが他のプライマリソートキーと &lt;code&gt;operator&amp;lt;&lt;/code&gt; で比較される場合、最初にソートされたキーを生成した文字シーケンスは、現在組み込まれているロケールのプライマリ照合順序で、2番目のソートキーを生成した文字シーケンスの前に来ます。 。</target>
        </trans-unit>
        <trans-unit id="e113ddf9e42810bbcd7d53a7fd8437e10332cdc3" translate="yes" xml:space="preserve">
          <source>For the definition of &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt;, the following exposition-only concept is defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt; 定義には、次の説明のみの概念が定義されています。</target>
        </trans-unit>
        <trans-unit id="d1225d08c6a217571442e3f149849eb65e94bce7" translate="yes" xml:space="preserve">
          <source>For the entities that are captured by reference (with the default capture &lt;code&gt;[&amp;amp;]&lt;/code&gt; or when using the character &amp;amp;, e.g. &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt;), it is unspecified if additional data members are declared in the closure type , but any such additional members must satisfy &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;(since C++17).</source>
          <target state="translated">参照によってキャプチャーされるエンティティー（デフォルトのキャプチャー &lt;code&gt;[&amp;amp;]&lt;/code&gt; または文字＆を使用する場合、例： &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt; ）では、追加のデータメンバーがクロージャータイプで宣言されているかどうかは不明ですが、追加のメンバーは&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypeを&lt;/a&gt;満たす必要があります（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="1a22058978c1262938bcaa97c3c6020766a5ad4e" translate="yes" xml:space="preserve">
          <source>For the first (non-array) form, expression must be a pointer to an object type or a class type &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly convertible&lt;/a&gt; to such pointer, and its value must be either</source>
          <target state="translated">最初の（非配列）形式の場合、式は、オブジェクトタイプへのポインタまたはそのようなポインタに&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的に変換&lt;/a&gt;可能なクラスタイプである必要があり、その値は次のいずれかである必要があります。</target>
        </trans-unit>
        <trans-unit id="299adf2377e7d703f91fcfc6dc32f0216b89eb0d" translate="yes" xml:space="preserve">
          <source>For the first (non-const) version, the behavior is undefined if this character is modified to any value other than &lt;code&gt;CharT()&lt;/code&gt; .</source>
          <target state="translated">最初の（非const）バージョンでは、この文字が &lt;code&gt;CharT()&lt;/code&gt; 以外の値に変更された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="90655817fab85d8ac14c5bbb029cd02bf793db95" translate="yes" xml:space="preserve">
          <source>For the last two rows of the table, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; in the suffix are &lt;code&gt;Period::type::num&lt;/code&gt; and &lt;code&gt;Period::type::den&lt;/code&gt; formatted as a decimal number with no leading zeroes, respectively.</source>
          <target state="translated">テーブルの最後の2つの行では、接尾辞の &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; と &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; は、それぞれ &lt;code&gt;Period::type::num&lt;/code&gt; と &lt;code&gt;Period::type::den&lt;/code&gt; 、それぞれ先行ゼロなしの10進数としてフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="cbb5833c26a713296ad8005d9e28d5fc0bbfe8a6" translate="yes" xml:space="preserve">
          <source>For the name of a class or class template used within the definition of that class or template or derived from one, unqualified name lookup finds the class that's being defined as if the name was introduced by a member declaration (with public member access). For more detail, see &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt;.</source>
          <target state="translated">そのクラスまたはテンプレートの定義内で使用された、またはそこから派生したクラスまたはクラステンプレートの名前の場合、非修飾名ルックアップは、名前がメンバー宣言（パブリックメンバーアクセス権）によって導入されたかのように定義されているクラスを見つけます。詳細については、&lt;a href=&quot;injected-class-name&quot;&gt;注入クラス名を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="43ac5c7c822f021589a3f0df6c74ca1128531b73" translate="yes" xml:space="preserve">
          <source>For the number of elements in the range &lt;code&gt;[first, last)&lt;/code&gt; without any additional criteria, see &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">追加の基準なしの範囲 &lt;code&gt;[first, last)&lt;/code&gt; 内の要素の数については、 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3eb35ae41318a2300948bfa04a8b59aa4c523fcb" translate="yes" xml:space="preserve">
          <source>For the objects of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt; (unless they are oversize &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型、 &lt;code&gt;signed char&lt;/code&gt; 型、 &lt;code&gt;unsigned char&lt;/code&gt; 型のオブジェクトの場合（オーバーサイズの&lt;a href=&quot;bit_field&quot;&gt;ビットフィールドで&lt;/a&gt;ない場合）、オブジェクト表現のすべてのビットが値表現に参加する必要があり、考えられる各ビットパターンは異なる値を表します（パディングなし、トラップなし）ビット、または複数の表現が可能です）。</target>
        </trans-unit>
        <trans-unit id="eda418fc0d7e0da6163efe2b320b70eff6e157ef" translate="yes" xml:space="preserve">
          <source>For the overload with an ExecutionPolicy, there may be a performance cost if ForwardIt's value type is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">ExecutionPolicyを使用したオーバーロードでは、ForwardItの値タイプが&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;でない場合、パフォーマンスが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e5b59a3fe5c4c6ada03047f0bc055b7cec5863b8" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if &lt;code&gt;ForwardIt1&lt;/code&gt;'s value_type is not &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">場合ExecutionPolicyと過負荷の場合は、パフォーマンスコストがあるかもしれません &lt;code&gt;ForwardIt1&lt;/code&gt; のVALUE_TYPEではありません&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca027ab75b905772f5d961e5c587aca010bc2ac6" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if the value type of &lt;code&gt;ForwardIterator1&lt;/code&gt; is not both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">ExecutionPolicyを使用したオーバーロードでは、 &lt;code&gt;ForwardIterator1&lt;/code&gt; の値の型が&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;と&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignableの&lt;/a&gt;両方ではない場合、パフォーマンスが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ecf8e99bee770bd19c532d009a039c1a135e9bb1" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, determining the type and value of the &lt;a href=&quot;this&quot;&gt;this pointer&lt;/a&gt; and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.</source>
          <target state="translated">目的のために、&lt;a href=&quot;lookup&quot;&gt;名前の検索&lt;/a&gt;の種類と値を決定する、&lt;a href=&quot;this&quot;&gt;このポインタを&lt;/a&gt;非静的クラスメンバーにアクセスするために、閉鎖型の関数呼び出し演算子の体は、ラムダ式の文脈で考えられています。</target>
        </trans-unit>
        <trans-unit id="65aeedb9e92b2d4cea74d76c9050bb672b686f5f" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;, if the next inner allocator is &lt;code&gt;A&lt;/code&gt;, any class &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participates in the recursion as if it was a container. Additionally, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as such a container by specific overloads of &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;&lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; の目的で、次の内部アロケーターが &lt;code&gt;A&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; &amp;lt;T、A&amp;gt; :: value == trueであるクラス &lt;code&gt;T&lt;/code&gt; は、コンテナーであるかのように再帰に参加します。さらに、 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; は、&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt; &lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt; &lt;/a&gt;特定のオーバーロードによってそのようなコンテナーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="4cae47b4767abaac03c592dbea46b05ec44cfc59" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements is unspecified, except that a minimum &lt;code&gt;T&lt;/code&gt; shall not qualify as a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; unless it meets all of the following conditions:</source>
          <target state="translated">この特性の目的のために、型が&lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt;要件を満たすことができないと実装が判断する範囲は指定されていません。ただし、次のすべての条件を満たさない限り、最小 &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt;としての資格がありません。</target>
        </trans-unit>
        <trans-unit id="fbf72513b1cc6b7e687b6187fddcae47438a5f71" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.</source>
          <target state="translated">この特性の目的のために、2 つの配列は、その要素が同じ値を持つ場合は同じ値を持ち、2 つの非ユニオン・クラスは、その直接のサブオブジェクトが同じ値を持つ場合は同じ値を持ち、2 つのユニオンは、それらが同じアクティブ・メンバを持ち、そのメンバの値が同じである場合は同じ値を持ちます。</target>
        </trans-unit>
        <trans-unit id="73e5a63a0091c86f2d780d4bd7205bd859be1626" translate="yes" xml:space="preserve">
          <source>For the purpose of unqualified name lookup, all declarations from a namespace nominated by a &lt;a href=&quot;namespace&quot;&gt;using directive&lt;/a&gt; appear as if declared in the nearest enclosing namespace which contains, directly or indirectly, both the using-directive and the nominated namespace.</source>
          <target state="translated">修飾されていない名前の検索の目的で、&lt;a href=&quot;namespace&quot;&gt;usingディレクティブ&lt;/a&gt;によって指定されたネームスペースからのすべての宣言は、usingディレクティブと指定されたネームスペースの両方を直接または間接的に含む最も近い囲みネームスペースで宣言されているかのように表示されます。</target>
        </trans-unit>
        <trans-unit id="be7ff9400561e79a38fa934ba94eb51a08e444ed" translate="yes" xml:space="preserve">
          <source>For the purposes of the description below, a pointer type &lt;code&gt;Y*&lt;/code&gt; is said to be</source>
          <target state="translated">以下の説明のために、ポインタ型 &lt;code&gt;Y*&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="e8841a4885b112152b14a19649fc94d610b058fa" translate="yes" xml:space="preserve">
          <source>For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to &lt;code&gt;T&lt;/code&gt; and any of the types in &lt;code&gt;Args&lt;/code&gt;. Only the validity of the immediate context of the variable definition is considered.</source>
          <target state="translated">このチェックでは、変数の定義が関数宣言として解釈されることはなく、 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; 使用は&lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;とは見なされません。&lt;a href=&quot;../language/access&quot;&gt;アクセスチェック&lt;/a&gt;は、 &lt;code&gt;T&lt;/code&gt; と関係のないコンテキストや &lt;code&gt;Args&lt;/code&gt; のいずれかの型から行われるかのように実行されます。変数定義の直接のコンテキストの有効性のみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="0b9a3ac76356afb7c5f4a3ea00f4b7fb14d9e7d4" translate="yes" xml:space="preserve">
          <source>For the rest of overload resolution, the</source>
          <target state="translated">過負荷解決の残りの部分については</target>
        </trans-unit>
        <trans-unit id="a71380803d7225c2397b15d7056c647fe014ba63" translate="yes" xml:space="preserve">
          <source>For the sake of exposition, assume that &lt;code&gt;regex_iterator&lt;/code&gt; contains the following members:</source>
          <target state="translated">説明のために、 &lt;code&gt;regex_iterator&lt;/code&gt; に次のメンバーが含まれていると仮定します。</target>
        </trans-unit>
        <trans-unit id="67321d4e15267f4eda7f0452bd90ebdb6e086831" translate="yes" xml:space="preserve">
          <source>For the second (array) form, expression must be a null pointer value or a pointer value previously obtained by an array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;. If expression is anything else, including if it's a pointer obtained by the non-array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">2番目の（配列）形式の場合、式はnullポインター値、または配列形式の&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;によって以前に取得されたポインター値でなければなりません。式がそれ以外の場合、それが配列でない形式の&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;によって取得されたポインターである場合も含め、動作は&lt;a href=&quot;ub&quot;&gt;未定義&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a9c4273040bcad4221585f3c35b8ea39b7d5d39a" translate="yes" xml:space="preserve">
          <source>For the situations when three-way comparison is not required, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; provides the usual &lt;a href=&quot;operator_cmp&quot;&gt;relational operators&lt;/a&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc).</source>
          <target state="translated">3者間比較が不要な状況では、 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; は通常の&lt;a href=&quot;operator_cmp&quot;&gt;関係演算子&lt;/a&gt;（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; など）を提供します。</target>
        </trans-unit>
        <trans-unit id="6f0ec42ffc782d2dbbdc18b148a303310b9bc1a6" translate="yes" xml:space="preserve">
          <source>For the specializations of &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; that are used in the standard library, &lt;code&gt;State&lt;/code&gt; is always &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリで使用される &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 特殊化の場合、 &lt;code&gt;State&lt;/code&gt; は常に &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="144964c0df3039e3c71b1f52434a1f307b2a75a0" translate="yes" xml:space="preserve">
          <source>For the static member functions, the</source>
          <target state="translated">静的なメンバ関数については</target>
        </trans-unit>
        <trans-unit id="eb5c7ff9cfa9a962ebc4d24b7e58d44592b6e8bd" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">&lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;と&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparableの&lt;/a&gt;両方である型の場合、C ++標準ライブラリは以下を区別します</target>
        </trans-unit>
        <trans-unit id="731f2b2536187de6fbaec0afbeb784f1678b4260" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and LessThanComparable, the C++ standard library makes a distinction between</source>
          <target state="translated">&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;とLessThanComparableの両方である型の場合、C ++標準ライブラリは以下を区別します</target>
        </trans-unit>
        <trans-unit id="a44f5a2bb8a05cc20c72fea8758fde71db78f3d3" translate="yes" xml:space="preserve">
          <source>For the types that are both EqualityComparable and &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">EqualityComparableと&lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparableの&lt;/a&gt;両方である型の場合、C ++標準ライブラリは以下を区別します</target>
        </trans-unit>
        <trans-unit id="ea9de19131b3606684b0baafb3d2151f5a32dd40" translate="yes" xml:space="preserve">
          <source>For the use in derived class definitions, see &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">派生クラス定義での使用については、&lt;a href=&quot;using_declaration&quot;&gt;using宣言を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="48183fff740905d93ae3026fe871d3be4a4d9ec5" translate="yes" xml:space="preserve">
          <source>For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">等しくない2つの異なるパラメーター &lt;code&gt;k1&lt;/code&gt; と &lt;code&gt;k2&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; が &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt; に近づく確率は非常に小さいはずです:: numeric_limits &amp;lt;size_t&amp;gt; :: max（）。</target>
        </trans-unit>
        <trans-unit id="cc4402b538e707e656178152f7bd8d1b40d16256" translate="yes" xml:space="preserve">
          <source>For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">等しい2つのパラメーター &lt;code&gt;k1&lt;/code&gt; と &lt;code&gt;k2&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="94a3ad0257f1ac1480c81596b592db0d4b3511aa" translate="yes" xml:space="preserve">
          <source>For two-digit input values, many implementations use the same parsing rules as the conversion specifier &lt;code&gt;'%y'&lt;/code&gt; as used by &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;: two-digit integer is expected, the values in the range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068. Four-digit inputs are typically accepted as-is.</source>
          <target state="translated">2桁の入力値の場合、多くの実装では、 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt; 、およびPOSIX関数 &lt;code&gt;strptime()&lt;/code&gt; で使用される変換指定子 &lt;code&gt;'%y'&lt;/code&gt; と同じ解析ルールを使用します。数字の整数が必要です。[69,99]の範囲の値は1969〜1999の値になり、[00,68]の範囲は2000-2068になります。通常、4桁の入力はそのまま受け入れられます。</target>
        </trans-unit>
        <trans-unit id="642cd801d14b4a66f154da3cc51856b49e293f28" translate="yes" xml:space="preserve">
          <source>For two-way comparisons, &lt;a href=&quot;operator_cmp&quot;&gt;binary operators&lt;/a&gt; may be more suitable.</source>
          <target state="translated">双方向比較の場合、&lt;a href=&quot;operator_cmp&quot;&gt;二項演算子の&lt;/a&gt;方が適している場合があります。</target>
        </trans-unit>
        <trans-unit id="fe584cd3d04227e8ee6e63e57235b2b1a239458e" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be BasicLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">タイプ &lt;code&gt;L&lt;/code&gt; をBasicLockableにするには、タイプ &lt;code&gt;L&lt;/code&gt; のオブジェクト &lt;code&gt;m&lt;/code&gt; について次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="a492045a60cf54bb3785e73eca1da2d9437cc013" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be Lockable, it must meet the above condition as well as the following:</source>
          <target state="translated">タイプ &lt;code&gt;L&lt;/code&gt; をロック可能にするには、上記の条件と次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="3192f26467193016e7a310e7cb38a3fb281f3879" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be TimedLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">タイプ &lt;code&gt;L&lt;/code&gt; をTimedLockableにするには、タイプ &lt;code&gt;L&lt;/code&gt; のオブジェクト &lt;code&gt;m&lt;/code&gt; について次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="e5e7522e5abd30c0f3d5e5a223c5721c59cbeef9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt; and for signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is the integer part of a/2b</source>
          <target state="translated">未署名のために &lt;code&gt;a&lt;/code&gt; および署名され、非負のために &lt;code&gt;a&lt;/code&gt; の値 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; / 2bの整数部分であります</target>
        </trans-unit>
        <trans-unit id="aebdb0e43e858256601ff6d8a7d5738865f2a1f9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the value of a * 2b</source>
          <target state="translated">符号なし &lt;code&gt;a&lt;/code&gt; の場合、 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; の値はa * 2bの値です</target>
        </trans-unit>
        <trans-unit id="d49c3968569060d907f70256e73011fe41b82ee7" translate="yes" xml:space="preserve">
          <source>For variables and other names introduced by simple declarations, the point of declaration is immediately after that name's &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; and before its initializer, if any:</source>
          <target state="translated">単純な宣言によって導入された変数やその他の名前の場合、宣言のポイントは、その名前の&lt;a href=&quot;declarations#Declarators&quot;&gt;宣言子の&lt;/a&gt;直後で、初期化子がある場合はその前です。</target>
        </trans-unit>
        <trans-unit id="4406791fdc0c802a309313fed6968b3cbed9aba4" translate="yes" xml:space="preserve">
          <source>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.</source>
          <target state="translated">変数の場合、宣言されている変数の型がその初期化子から自動的に推論されることを指定します。</target>
        </trans-unit>
        <trans-unit id="5c276069327cb6d9e2ff643e9fb634c6f1cb43de" translate="yes" xml:space="preserve">
          <source>For version (2), the number of arguments must be the same as the number of parameters in macro definition. For versions (3,4), the number of arguments must be more than(until C++20)at least as many as(since C++20) the number of parameters (not counting &lt;code&gt;...&lt;/code&gt;). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">バージョン（2）の場合、引数の数はマクロ定義のパラメーターの数と同じでなければなりません。バージョン（3、4）の場合、引数の数は（C ++ 20まで）少なくとも（C ++ 20以降）パラメータの数（数えないで &lt;code&gt;...&lt;/code&gt; ）よりも多くなければなりません。そうでなければ、プログラムの形式が正しくありません。識別子が機能表記にない場合、つまり、その後に括弧がない場合、識別子はまったく置き換えられません。</target>
        </trans-unit>
        <trans-unit id="1eb818e764a2afb52d153586d87b0ff7106e9cc9" translate="yes" xml:space="preserve">
          <source>For versions (3,4), replacement-list may contain the token sequence &lt;code&gt;__VA_OPT__ (&lt;/code&gt;content&lt;code&gt;)&lt;/code&gt;, which is replaced by content if &lt;code&gt;__VA_ARGS__&lt;/code&gt; is non-empty, and expands to nothing otherwise.</source>
          <target state="translated">バージョン（3、4）では、replacement-listにトークンシーケンス &lt;code&gt;__VA_OPT__ (&lt;/code&gt; content &lt;code&gt;)&lt;/code&gt; を含めることができます。これは、 &lt;code&gt;__VA_ARGS__&lt;/code&gt; が空でない場合はcontentに置き換えられ、それ以外の場合は何にも拡張されません。</target>
        </trans-unit>
        <trans-unit id="689abf1f4ab72838db75e84748d7996dea17600f" translate="yes" xml:space="preserve">
          <source>For virtual calls (if the bases are initialized), the same rules apply as the rules for the virtual calls from constructors and destructors: virtual member functions behave as if the dynamic type of &lt;code&gt;*this&lt;/code&gt; is the class that's being constructed (dynamic dispatch does not propagate down the inheritance hierarchy) and virtual calls (but not static calls) to &lt;a href=&quot;abstract_class&quot;&gt;pure virtual&lt;/a&gt; member functions are undefined behavior.</source>
          <target state="translated">仮想呼び出しの場合（ベースが初期化されている場合）、コンストラクターおよびデストラクターからの仮想呼び出しの規則と同じ規則が適用されます。仮想メンバー関数は、 &lt;code&gt;*this&lt;/code&gt; の動的型が構築されているクラスであるかのように動作します（動的ディスパッチは行われません）継承階層を下に伝搬）および&lt;a href=&quot;abstract_class&quot;&gt;純粋な仮想&lt;/a&gt;メンバー関数への仮想呼び出し（静的呼び出しではない）は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="0c5f085443078183be6555b610a3066515f2b25f" translate="yes" xml:space="preserve">
          <source>For zero-sized arrays,</source>
          <target state="translated">ゼロサイズの配列の場合。</target>
        </trans-unit>
        <trans-unit id="0a460a0808dc0afa3b1cab6d45b0c32f450b8082" translate="yes" xml:space="preserve">
          <source>Forcing a copy assignment operator to be generated by the compiler.</source>
          <target state="translated">コピー代入演算子をコンパイラで強制的に生成します。</target>
        </trans-unit>
        <trans-unit id="11ad1e8557a20546e9537fc0a5b3a329b83d8d13" translate="yes" xml:space="preserve">
          <source>Forcing a copy constructor to be generated by the compiler.</source>
          <target state="translated">コピーコンストラクタをコンパイラで強制的に生成します。</target>
        </trans-unit>
        <trans-unit id="dd180500aac427aa2facdbe0b7cd406cce37ac98" translate="yes" xml:space="preserve">
          <source>Forcing a move assignment operator to be generated by the compiler.</source>
          <target state="translated">コンパイラで強制的に移動代入演算子を生成します。</target>
        </trans-unit>
        <trans-unit id="b5ea5bcf5fc337ca9689a82c3a3c7580484f1408" translate="yes" xml:space="preserve">
          <source>Forcing a move constructor to be generated by the compiler.</source>
          <target state="translated">コンパイラで強制的にムーブのコンストラクタを生成します。</target>
        </trans-unit>
        <trans-unit id="72ef49edf9ca8e31454f8e3e5987fc43ac16422c" translate="yes" xml:space="preserve">
          <source>Form (3) is a special case of elaborated type specifier, usually referred to as</source>
          <target state="translated">形式(3)は、精巧な型指定子の特殊なケースで、通常は</target>
        </trans-unit>
        <trans-unit id="3851c6a3b646b09f934a18b67d308cc11979b8c6" translate="yes" xml:space="preserve">
          <source>Formal definition of</source>
          <target state="translated">の正式な定義</target>
        </trans-unit>
        <trans-unit id="617d00cd751356da85b2e1f1f2eca6aa12a756a0" translate="yes" xml:space="preserve">
          <source>Formal description</source>
          <target state="translated">形式的な説明</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="be2c3615928f7aa5bc5a7d980eb4d06a17642a73" translate="yes" xml:space="preserve">
          <source>Formally, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if, given any lvalue &lt;code&gt;t&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and any lvalue &lt;code&gt;u&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;, and let &lt;code&gt;C&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">正式に、 &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; 、任意の所与の左辺、場合にのみ満足される &lt;code&gt;t&lt;/code&gt; 型の &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; と任意左辺 &lt;code&gt;u&lt;/code&gt; 型の &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 、およびlet &lt;code&gt;C&lt;/code&gt; こと &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac3a456d751219d7a66e0d0371e02798d8d5d3ea" translate="yes" xml:space="preserve">
          <source>Formally, a substring &lt;code&gt;str&lt;/code&gt; is said to be</source>
          <target state="translated">正式には、部分文字列 &lt;code&gt;str&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="8819ae53d6eeeb966d61dd310165099d50cdc3e7" translate="yes" xml:space="preserve">
          <source>Formally, a template template-parameter &lt;code&gt;P&lt;/code&gt; is at least as specialized as a template template argument &lt;code&gt;A&lt;/code&gt; if, given the following rewrite to two function templates, the function template corresponding to &lt;code&gt;P&lt;/code&gt; is at least as specialized as the function template corresponding to &lt;code&gt;A&lt;/code&gt; according to the partial ordering rules for &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;. Given an invented class template &lt;code&gt;X &lt;/code&gt; with the template parameter list of &lt;code&gt;A&lt;/code&gt; (including default arguments):</source>
          <target state="translated">正式に、テンプレートテンプレートパラメータ &lt;code&gt;P&lt;/code&gt; は、テンプレートのテンプレート引数として特化少なくともようである &lt;code&gt;A&lt;/code&gt; 、場合、2つの関数テンプレートに次の書き換えを与え、対応する関数テンプレート &lt;code&gt;P&lt;/code&gt; は、対応する関数テンプレートとして特化したような少なくともある &lt;code&gt;A&lt;/code&gt; に従って&lt;a href=&quot;function_template&quot;&gt;関数テンプレートの&lt;/a&gt;部分的な順序規則。 &lt;code&gt;A&lt;/code&gt; のテンプレートパラメータリスト（デフォルトの引数を含む）を持つ発明されたクラステンプレート &lt;code&gt;X &lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="117e56a1f0fa17b3f88e2093765a4fbfc78944a1" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, *j...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">形式的には、[d_first、d_first +（last-first））の各反復子 &lt;code&gt;i&lt;/code&gt; を介して、[first、first +（i-d_first））のすべての &lt;code&gt;j&lt;/code&gt; に対する &lt;code&gt;init, *j...&lt;/code&gt; の一般化非可換合計の値を割り当てます &lt;code&gt;binary_op&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="67dce949f95f6583a76648b394095c1ec1ca39c5" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">形式的には、[d_first、d_first +（last-first））の各反復子 &lt;code&gt;i&lt;/code&gt; を介して、[first、first +（i-d_first &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; すべての &lt;code&gt;j&lt;/code&gt; に対して、initの一般化非可換合計の値、unary_op（* j）...を割り当てます。 ）） &lt;code&gt;binary_op&lt;/code&gt; 上で、</target>
        </trans-unit>
        <trans-unit id="95a3ed38da232217c4f6f08f54e48cb7d257ddec" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of.</source>
          <target state="translated">正式には、[d_first、d_first +（last-first））の各反復子 &lt;code&gt;i&lt;/code&gt; を通じて値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="42355d6a7c2d7676346a2158f0e06426adf8925e" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of:</source>
          <target state="translated">正式には、[d_first、d_first +（last-first））の各反復子 &lt;code&gt;i&lt;/code&gt; を介して、次の値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="aa803427d4e1d44c6149f49a34143aabb8a952e0" translate="yes" xml:space="preserve">
          <source>Formally, for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, count)&lt;/code&gt;, performs &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt;.</source>
          <target state="translated">正式に、それぞれに対する &lt;code&gt;i&lt;/code&gt; で &lt;code&gt;[0, count)&lt;/code&gt; 、実行 &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="554c2426b4e5c1f78a13a29231a721f516bd1cbf" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; and an lvalue &lt;code&gt;t&lt;/code&gt; that denotes the same object as &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;__ForwardingRange&lt;/code&gt; only if.</source>
          <target state="translated">形式的に、発現所与 &lt;code&gt;E&lt;/code&gt; よう &lt;code&gt;decltype((E))&lt;/code&gt; がある &lt;code&gt;T&lt;/code&gt; と左辺値 &lt;code&gt;t&lt;/code&gt; と同じオブジェクトを表す &lt;code&gt;E&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; のモデルは &lt;code&gt;__ForwardingRange&lt;/code&gt; 場合のみ。</target>
        </trans-unit>
        <trans-unit id="f43c3db9c814c3ddff2a854cf059e58f985b2721" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; only if.</source>
          <target state="translated">正式には、 &lt;code&gt;decltype((E))&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; であるような式 &lt;code&gt;E&lt;/code&gt; が与えられた場合、 &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; のみをモデル化します。</target>
        </trans-unit>
        <trans-unit id="067b1a2613c21e1fd48648c5caa1394000d7f227" translate="yes" xml:space="preserve">
          <source>Formally, given.</source>
          <target state="translated">形式的には、与えられた。</target>
        </trans-unit>
        <trans-unit id="b90f213e247d65d8f658b379e51068d2511abb68" translate="yes" xml:space="preserve">
          <source>Formally, if &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are expressions, and &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt;, then.</source>
          <target state="translated">正式には、 &lt;code&gt;E&lt;/code&gt; と &lt;code&gt;F&lt;/code&gt; が式であり、 &lt;code&gt;T&lt;/code&gt; が型 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt; である場合。</target>
        </trans-unit>
        <trans-unit id="67f89cac3a2bdd1a32a9d4e925980ecdcd1ff780" translate="yes" xml:space="preserve">
          <source>Formally, returns a value &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">形式的には、すべての値 &lt;code&gt;c&lt;/code&gt; に対して &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; になるような値 &lt;code&gt;e&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="ba8bfc3113f8f3e8c405a965d6f37d86be2d7991" translate="yes" xml:space="preserve">
          <source>Formally, returns the value &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; is true, and an unspecified value if no such &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="translated">形式的には、 &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; がtrueになるような値 &lt;code&gt;x&lt;/code&gt; を返し、そのような &lt;code&gt;x&lt;/code&gt; が存在しない場合は未指定の値を返します。</target>
        </trans-unit>
        <trans-unit id="52d033134dacb8018588f4302d9453d80ec19597" translate="yes" xml:space="preserve">
          <source>Formally, the</source>
          <target state="translated">形式的には</target>
        </trans-unit>
        <trans-unit id="52e0a6f1e0d63a4dd3bc991539c544e18482cfab" translate="yes" xml:space="preserve">
          <source>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</source>
          <target state="translated">形式的には、C++標準では浮動小数点演算の精度は保証されていません。</target>
        </trans-unit>
        <trans-unit id="95a4b2acf26b1c49aea8abebe466f09b5002e38b" translate="yes" xml:space="preserve">
          <source>Formally, the syntax is.</source>
          <target state="translated">形式的には、構文は</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">形式的には、不偏指数はlog</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">形式的には、不偏指数はlog</target>
        </trans-unit>
        <trans-unit id="8179a0c7fe36d2a8a17e5adad38978ddb099049d" translate="yes" xml:space="preserve">
          <source>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:</source>
          <target state="translated">形式的には、任意の2つの関数テンプレートのうちどちらがより専門的であるかを決定するために、部分順序付け処理は、まず、2つのテンプレートのうちの1つを以下のように変換する。</target>
        </trans-unit>
        <trans-unit id="3636bbcd81222a968d5588186dbdf6c4b0b042e0" translate="yes" xml:space="preserve">
          <source>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:</source>
          <target state="translated">形式的には、部分的な特殊化の間にmore-specialized-thanの関係を確立するために、それぞれが最初に以下のように架空の関数テンプレートに変換されます。</target>
        </trans-unit>
        <trans-unit id="f2967eb9e0cfcedd6a189b6a8d3866a634ebbc35" translate="yes" xml:space="preserve">
          <source>Formally.</source>
          <target state="translated">Formally.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="9d6e5b21d4a23bd5ccd62830a8a750d8fe1ca459" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; ファミリーの関数のフォーマット定数</target>
        </trans-unit>
        <trans-unit id="2baad9ad4884ebddda05c6c67af479131ae29e6b" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; ファミリーの関数のフォーマット定数</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">フォーマット変換</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">マクロ定数のフォーマット</target>
        </trans-unit>
        <trans-unit id="9316b4e7eba6949a72f828ee21024df921672e3c" translate="yes" xml:space="preserve">
          <source>Format observers</source>
          <target state="translated">フォーマットオブザーバー</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">フォーマット文字列</target>
        </trans-unit>
        <trans-unit id="c4bb81b6ba2e3eacfc477a97d7def7d80d2c55be" translate="yes" xml:space="preserve">
          <source>Formats monetary value and writes the result to output stream.</source>
          <target state="translated">貨幣価値をフォーマットし、その結果を出力ストリームに書き込みます。</target>
        </trans-unit>
        <trans-unit id="7c20d6ad01a878bb9e8639e10169a49131276aca" translate="yes" xml:space="preserve">
          <source>Formats the streamable object &lt;code&gt;s&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt; and the locale &lt;code&gt;loc&lt;/code&gt; (if provided).</source>
          <target state="translated">ストリーミングオブジェクトフォーマット &lt;code&gt;s&lt;/code&gt; フォーマットストリング使用 &lt;code&gt;fmt&lt;/code&gt; とロケール &lt;code&gt;loc&lt;/code&gt; （提供される場合）。</target>
        </trans-unit>
        <trans-unit id="8bf1052f7f8c855373309b9742ea3d34a8c56846" translate="yes" xml:space="preserve">
          <source>Formatted input</source>
          <target state="translated">フォーマットされた入力</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">フォーマットされた入出力</target>
        </trans-unit>
        <trans-unit id="c7cf7a590d478b0b7b99c49e642af36f47cd56e2" translate="yes" xml:space="preserve">
          <source>Formatted output</source>
          <target state="translated">フォーマットされた出力</target>
        </trans-unit>
        <trans-unit id="722101e27f69cbe90326b9ee974bad21c5f7f772" translate="yes" xml:space="preserve">
          <source>Formatted output functions &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt;, if they encounter the end of the output stream before completing output.</source>
          <target state="translated">フォーマットされた出力関数&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator &amp;lt;&amp;lt;&lt;/a&gt;、 &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt; （出力が完了する前に出力ストリームの終わりに遭遇した場合）。</target>
        </trans-unit>
        <trans-unit id="c36735a1b156faf0d8948786e00b3f1ee63bfe64" translate="yes" xml:space="preserve">
          <source>FormattedInputFunction</source>
          <target state="translated">FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="8ad283919e38bfa7958b6669077f83561656b04b" translate="yes" xml:space="preserve">
          <source>FormattedOutputFunction</source>
          <target state="translated">FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="4f6565ce2772bffe98b3ba5983af96ce7e5de363" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal representing an imaginary number.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 虚数を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="643fc7954cfd8223ed9cf2e31d62065c242ec93d" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing hours.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 時間を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="331255970e3e48a89f2154f44ef024e28fb6bd1c" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing microseconds.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; マイクロ秒を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="8c586fe6bccfd167b2ec9b0341a50e0e2e23b2bd" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing milliseconds.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; （ミリ秒）を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="aabdc8e30aa11c549d953403622d6b09da7416a8" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing minutes.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 分を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="b2b858860ebb5672d0b628f2489cbedb92290864" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing nanoseconds.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; ナノ秒を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="d804e0c1b4cad0bfbb3de1fe4b5fa00aa0254978" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing seconds.</source>
          <target state="translated">フォーム &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 秒を表すリテラルを。</target>
        </trans-unit>
        <trans-unit id="1f2764e36e954fe7d39b543d927e58cc08e2ae3b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the day value stored in &lt;code&gt;d&lt;/code&gt; formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!d.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; はに格納された日の値からなる &lt;code&gt;d&lt;/code&gt; 結果は、さもなければ単一進数字であるかどう先行ゼロと、小数点数としてフォーマット。その文字列を &lt;code&gt;os&lt;/code&gt; に挿入します。次に、 &lt;code&gt;!d.ok()&lt;/code&gt; の場合、文字列 &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; は &lt;code&gt;os&lt;/code&gt; に挿入されます。</target>
        </trans-unit>
        <trans-unit id="38eae2fb3ad7f9bb81e8d518abb33df758dc07a9" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the year value stored in &lt;code&gt;y&lt;/code&gt; formatted as a decimal number, left-padded with &lt;code&gt;0&lt;/code&gt; to four digits if the result would otherwise be less than four digits. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!y.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; はに格納された年の値からなる &lt;code&gt;y&lt;/code&gt; 左詰めの10進数としてフォーマット &lt;code&gt;0&lt;/code&gt; 〜4桁の結果がそれ以外の場合は以下4桁であるかどう。その文字列を &lt;code&gt;os&lt;/code&gt; に挿入します。次に、 &lt;code&gt;!y.ok()&lt;/code&gt; の場合、文字列 &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; を &lt;code&gt;os&lt;/code&gt; に挿入します。</target>
        </trans-unit>
        <trans-unit id="0d5578517ed64bd2435fafaf294658c0cb1801f2" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::day&lt;/code&gt; literal representing a day of the month in the calendar.</source>
          <target state="translated">フォーム &lt;code&gt;std::chrono::day&lt;/code&gt; カレンダーの月の日付を表すリテラル。</target>
        </trans-unit>
        <trans-unit id="07aea1146bfbc451baff20e77016224dc3f5174b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::year&lt;/code&gt; literal representing a year in the proleptic Gregorian calendar.</source>
          <target state="translated">フォーム &lt;code&gt;std::chrono::year&lt;/code&gt; 先発グレゴリオ暦で年を表すリテラル。</target>
        </trans-unit>
        <trans-unit id="820c807c48f38eb8ca42664fa731c03b51c0dc19" translate="yes" xml:space="preserve">
          <source>Forms a string literal of the desired type.</source>
          <target state="translated">希望する型の文字列リテラルを形成します。</target>
        </trans-unit>
        <trans-unit id="985e41dbd82d997c605a0a512d9497c566128eb1" translate="yes" xml:space="preserve">
          <source>Forms a string view of a character literal.</source>
          <target state="translated">文字リテラルの文字列ビューを形成します。</target>
        </trans-unit>
        <trans-unit id="70ef5d692d3abeefce2c77380edc61da30bbd98d" translate="yes" xml:space="preserve">
          <source>Forms can be nested and processed recursively: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; is an example of &lt;code&gt;type(*)(T)&lt;/code&gt;, where</source>
          <target state="translated">フォームはネストして再帰的に処理できます &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; は &lt;code&gt;type(*)(T)&lt;/code&gt; の例です。ここで、</target>
        </trans-unit>
        <trans-unit id="96d68418cb661c4b3699c2e8d5be8b57b843889b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;logical conjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical AND on the sequence of traits.</source>
          <target state="translated">タイプ特性 &lt;code&gt;B...&lt;/code&gt; の&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;論理結合&lt;/a&gt;を形成し、特性のシーケンスに対して効果的に論理ANDを実行します。</target>
        </trans-unit>
        <trans-unit id="abc06d4ed5fe67746f60bf85f949f812a573392b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;logical disjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical OR on the sequence of traits.</source>
          <target state="translated">フォームは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;論理和&lt;/a&gt;型の特性のの &lt;code&gt;B...&lt;/code&gt; 、効果的論理和形質の配列に行うことができます。</target>
        </trans-unit>
        <trans-unit id="bb06b9b7e348bda3d1bd2e01e574d860866f1b4f" translate="yes" xml:space="preserve">
          <source>Forms the logical negation of the type trait &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">型特性 &lt;code&gt;B&lt;/code&gt; の論理否定を形成します。</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">順方向宣言</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">順方向宣言</target>
        </trans-unit>
        <trans-unit id="a0a5ca500e9440c8915b30c97f259cacfbb1a922" translate="yes" xml:space="preserve">
          <source>Forward iterator to the new end of the range.</source>
          <target state="translated">範囲の新しい端にイテレータを送ります。</target>
        </trans-unit>
        <trans-unit id="55728db9a1113137c393ce6ac1e01d0996797010" translate="yes" xml:space="preserve">
          <source>Forward progress</source>
          <target state="translated">前進</target>
        </trans-unit>
        <trans-unit id="ad2924cf16dd4b5c687b5dd4c3d38f7f20d99988" translate="yes" xml:space="preserve">
          <source>ForwardIterator</source>
          <target state="translated">ForwardIterator</target>
        </trans-unit>
        <trans-unit id="967415c810ff974308b7e163c5a8b2ee4963dfdf" translate="yes" xml:space="preserve">
          <source>ForwardRange</source>
          <target state="translated">ForwardRange</target>
        </trans-unit>
        <trans-unit id="02f29ee395fe54e14061ef2943f36bed0af18091" translate="yes" xml:space="preserve">
          <source>Forwarding references</source>
          <target state="translated">リファレンスの転送</target>
        </trans-unit>
        <trans-unit id="9cc6112b2b655f82745fcb59748e093ab1fe8817" translate="yes" xml:space="preserve">
          <source>Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to</source>
          <target state="translated">転送参照は、関数引数の値カテゴリを保持する特別な種類の参照で、以下のようなことが可能です。</target>
        </trans-unit>
        <trans-unit id="2d1b43ed1d5df75c8cdb7fbed98fd0e15496fb8b" translate="yes" xml:space="preserve">
          <source>Four specializations are provided by the standard library.</source>
          <target state="translated">標準ライブラリには4つの専門分野が用意されています。</target>
        </trans-unit>
        <trans-unit id="646942bdd43335fac5c5cb8c90a98c4a1571691d" translate="yes" xml:space="preserve">
          <source>Four standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">標準ライブラリでは、4つの独立した(ロケールに依存しない)特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="6eb9522d427a2669dd67835d7011efde7feafc8c" translate="yes" xml:space="preserve">
          <source>Fourth version</source>
          <target state="translated">第四版</target>
        </trans-unit>
        <trans-unit id="67c664a3c5100ef6f1199beaf5c8ee1e3784d4ea" translate="yes" xml:space="preserve">
          <source>Free raw memory obtained from allocate_bytes</source>
          <target state="translated">allocate_bytesから取得したフリーローメモリ</target>
        </trans-unit>
        <trans-unit id="66c8be8d1a5492d1eb9655f15bf0380194107efe" translate="yes" xml:space="preserve">
          <source>Frees raw memory obtained by allocate_object</source>
          <target state="translated">allocate_objectで取得した生のメモリを解放します。</target>
        </trans-unit>
        <trans-unit id="2715bc5b3d7345dfa8bf763d473dced4c5997198" translate="yes" xml:space="preserve">
          <source>Freestanding and hosted implementations</source>
          <target state="translated">独立型およびホスト型の実装</target>
        </trans-unit>
        <trans-unit id="755e9516e294b0231da60ee53dcb1cf6956a6f7f" translate="yes" xml:space="preserve">
          <source>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</source>
          <target state="translated">友人宣言は部分的な特殊化を参照することはできませんが、完全な特殊化を参照することはできます。</target>
        </trans-unit>
        <trans-unit id="78f907cdd8f4e2ead952047583a3ce2951b50c9e" translate="yes" xml:space="preserve">
          <source>Friend function declaration</source>
          <target state="translated">フレンド関数宣言</target>
        </trans-unit>
        <trans-unit id="74ed844100eed25ad0c1bd3b12ca6cc5919b4157" translate="yes" xml:space="preserve">
          <source>Friend function definition</source>
          <target state="translated">フレンド関数定義</target>
        </trans-unit>
        <trans-unit id="cc53f78835350ac24156d967e62ee0b5c8a5687b" translate="yes" xml:space="preserve">
          <source>Friendship is not inherited (your friend's children are not your friends).</source>
          <target state="translated">友情は遺伝しない(友達の子供は友達ではない)。</target>
        </trans-unit>
        <trans-unit id="8c8cea4fdc1598ec00b1de75a422605f0af14cee" translate="yes" xml:space="preserve">
          <source>Friendship is not transitive (a friend of your friend is not your friend).</source>
          <target state="translated">友情は、他動詞ではありません(友だちの友だちは友だちではありません)。</target>
        </trans-unit>
        <trans-unit id="e8b58840737fe83d2eef7b8580aadc5bae0ab4f5" translate="yes" xml:space="preserve">
          <source>Full names</source>
          <target state="translated">フルネーム</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">関数オブジェクト</target>
        </trans-unit>
        <trans-unit id="f7f0e1bdfa2f3add115b52939d15e6fd3460937e" translate="yes" xml:space="preserve">
          <source>Function adaptors</source>
          <target state="translated">機能アダプタ</target>
        </trans-unit>
        <trans-unit id="8231e66ed9c1c9e042523416e1ad72237c2d2874" translate="yes" xml:space="preserve">
          <source>Function argument lists</source>
          <target state="translated">関数の引数リスト</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">機能体</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">関数呼び出し</target>
        </trans-unit>
        <trans-unit id="61f764306c5b4c873805f4d7503e407f01f0da37" translate="yes" xml:space="preserve">
          <source>Function call expression is similar in syntax to value initialization &lt;code&gt;T()&lt;/code&gt;, to &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt; expression &lt;code&gt;T(A1)&lt;/code&gt;, and to direct initialization of a temporary &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the name of a type.</source>
          <target state="translated">関数呼び出し式が初期値の構文と似ている &lt;code&gt;T()&lt;/code&gt; への&lt;a href=&quot;explicit_cast&quot;&gt;関数スタイルキャスト&lt;/a&gt;表現 &lt;code&gt;T(A1)&lt;/code&gt; 、及び、一時の直接の初期化に &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は名前でありますタイプの。</target>
        </trans-unit>
        <trans-unit id="55cb199824723ac48f856b32fde1674eff49a87b" translate="yes" xml:space="preserve">
          <source>Function call expressions returning &lt;code&gt;void&lt;/code&gt;, cast expressions to &lt;code&gt;void&lt;/code&gt;, and &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt; are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the &lt;code&gt;return&lt;/code&gt; statement in a function returning &lt;code&gt;void&lt;/code&gt;. In addition, throw-expressions may be used as the second and the third operands of the &lt;a href=&quot;operator_other&quot;&gt;conditional operator ?:&lt;/a&gt;.</source>
          <target state="translated">返す関数呼び出し式 &lt;code&gt;void&lt;/code&gt; に、キャスト式を &lt;code&gt;void&lt;/code&gt; 、および&lt;a href=&quot;throw&quot;&gt;スローイン式は&lt;/a&gt; prvalue式として分類されているが、それらは参照や関数の引数としてを初期化するために使用することはできません。それらは、破棄された値のコンテキスト（たとえば、コンマ演算子の左側のオペランドとして、それ自体の行で）や、 &lt;code&gt;void&lt;/code&gt; を返す関数の &lt;code&gt;return&lt;/code&gt; ステートメントで使用できます。さらに、throw-expressionsは、&lt;a href=&quot;operator_other&quot;&gt;条件演算子？：&lt;/a&gt;の2番目と3番目のオペランドとして使用できます。</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">関数呼び出しオペレータ</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">関数宣言</target>
        </trans-unit>
        <trans-unit id="8d84dffd70068ddd1111084e3623daad3386117d" translate="yes" xml:space="preserve">
          <source>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; and &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; for details.</source>
          <target state="translated">関数宣言は、どのスコープでも使用できます。クラススコープでの関数宣言により、クラスメンバー関数が導入されます（フレンド指定子が使用されていない場合）。詳細については、&lt;a href=&quot;member_functions&quot;&gt;メンバー関数&lt;/a&gt;と&lt;a href=&quot;friend&quot;&gt;フレンド関数&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="01a7dcd826dbbad15679402aaa257c1e8bee4fd2" translate="yes" xml:space="preserve">
          <source>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</source>
          <target state="translated">関数宣言子は、decl-specifier-seqが可能な場合、他の宣言子と混合することができます。</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">機能定義</target>
        </trans-unit>
        <trans-unit id="8a31e049889b12e1b53d0e991bba8a50561e7a03" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">関数は、最初の非空白文字が見つかるまで、空白文字（ &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt; によって決定される）を破棄します。次に、有効な浮動小数点表現を形成するためにできるだけ多くの文字を取り、それらを浮動小数点値に変換します。有効な浮動小数点値は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="268b166a91a60d5f1a938de3418f1d3678105197" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::isspace()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">関数は、最初の非空白文字が見つかるまで、空白文字（ &lt;code&gt;std::isspace()&lt;/code&gt; によって決定される）を破棄します。次に、有効な浮動小数点表現を形成するためにできるだけ多くの文字を取り、それらを浮動小数点値に変換します。有効な浮動小数点値は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="56d376c8d143e7051f331c1aba9bc9e6fccbf798" translate="yes" xml:space="preserve">
          <source>Function invocation</source>
          <target state="translated">関数呼び出し</target>
        </trans-unit>
        <trans-unit id="ec031b84374532b3dd5e02a9109e50cae284b830" translate="yes" xml:space="preserve">
          <source>Function macros for integer constants</source>
          <target state="translated">整数定数用の関数マクロ</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">最小幅整数定数用の関数マクロ</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">サポートされていない機能</target>
        </trans-unit>
        <trans-unit id="b248eacc8c468b679bd61ad8cb82d22de759fe43" translate="yes" xml:space="preserve">
          <source>Function object for computing remainders of divisions. Implements &lt;code&gt;operator%&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">除算の余りを計算するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;operator%&lt;/code&gt; を実装します。</target>
        </trans-unit>
        <trans-unit id="a4633ecd37c7996641d9e6e60f41f4acaad220fb" translate="yes" xml:space="preserve">
          <source>Function object for performing addition. Effectively calls &lt;code&gt;operator+&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">追加を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の 2つのインスタンスで &lt;code&gt;operator+&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="d149129b3c23a795999a21bc625bd934320c5a89" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise AND. Effectively calls &lt;code&gt;operator&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ビットごとのANDを実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator&amp;amp;&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="b599fdda8a6eff8b08fa4dda5e4633fab0dbe0ce" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise NOT. Effectively calls &lt;code&gt;operator~&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ビットごとのNOTを実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;operator~&lt;/code&gt; 効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="313209366a119d00dc320937bfc0bbb8786800ec" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise OR. Effectively calls &lt;code&gt;operator|&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ビットごとのORを実行するための関数オブジェクト。効果的に &lt;code&gt;operator|&lt;/code&gt; 呼び出す| 型の &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5887d43f2e0df69b82fff43b54f846c4704fa46" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise XOR. Effectively calls &lt;code&gt;operator^&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ビットごとのXORを実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;operator^&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="e180b41511a71768ffe2c960f01fb1039a41108e" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).</source>
          <target state="translated">比較を実行するための関数オブジェクト。関数呼び出し演算子のパラメータ型を引数から控除します(戻り値の型は控除しません)。</target>
        </trans-unit>
        <trans-unit id="56f077a1110154764933177a4a8a45a67a0e117f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator!=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特別な場合を除き、タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator!=&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3d8efff6ca90765aa3a8bc08e4dd6c03c3e58a69" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator==&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特別な場合を &lt;code&gt;operator==&lt;/code&gt; 、タイプ &lt;code&gt;T&lt;/code&gt; でoperator ==を呼び出します。</target>
        </trans-unit>
        <trans-unit id="60aea8fb12e1c43b673c06d961c8619b0f1469c4" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特殊化されていない限り、タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator&amp;gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="738acefb6a4d9540bfe0b153875600600ca1005f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特別な場合を除き、タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator&amp;gt;=&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2ed4fd907e2e5e744c2b2efa9d9bc109fe8439c7" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特殊化されていない限り、タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator&amp;lt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="86238797ec5cdcf632292c3e4d25c647b5a4693a" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">比較を実行するための関数オブジェクト。特殊化されていない限り、タイプ &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;operator&amp;lt;=&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="0fe5410430a56ab0ae8cbfda0c39393d3efaefd1" translate="yes" xml:space="preserve">
          <source>Function object for performing division. Effectively calls &lt;code&gt;operator/&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">除算を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の 2つのインスタンスで &lt;code&gt;operator/&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="12de586434654aa1a14b6b2d8a259de90a34392f" translate="yes" xml:space="preserve">
          <source>Function object for performing logical AND (logical conjunction). Effectively calls &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">論理AND（論理結合）を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="1490a0997baca27d81b16387b04a8b28fa19d7e6" translate="yes" xml:space="preserve">
          <source>Function object for performing logical NOT (logical negation). Effectively calls &lt;code&gt;operator!&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">論理NOT（論理否定）を実行するための関数オブジェクト。効果的に &lt;code&gt;operator!&lt;/code&gt; 呼び出します！タイプ &lt;code&gt;T&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="26fc81b06029a179ee570f03e59c7d8106976333" translate="yes" xml:space="preserve">
          <source>Function object for performing logical OR (logical disjunction). Effectively calls &lt;code&gt;operator||&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">論理OR（論理和）を実行するための関数オブジェクト。効果的に &lt;code&gt;operator||&lt;/code&gt; 呼び出す|| 型の &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="863b97dec6e3bad00c70886e69a7afbb1c4e16fb" translate="yes" xml:space="preserve">
          <source>Function object for performing multiplication. Effectively calls &lt;code&gt;operator*&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">乗算を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の 2つのインスタンスで &lt;code&gt;operator*&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="a134daaeb15195627f59ee24f26ecba80c6eb4fc" translate="yes" xml:space="preserve">
          <source>Function object for performing negation. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on an instance of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">否定を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; のインスタンスで &lt;code&gt;operator-&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="6be85bc0166110c97cce13deef82fe7cce65ca9c" translate="yes" xml:space="preserve">
          <source>Function object for performing subtraction. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">減算を実行するための関数オブジェクト。タイプ &lt;code&gt;T&lt;/code&gt; の 2つのインスタンスで &lt;code&gt;operator-&lt;/code&gt; を効果的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="05785bcc60d939df6f0a0f7578eb56a67e1b185f" translate="yes" xml:space="preserve">
          <source>Function objects</source>
          <target state="translated">関数オブジェクト</target>
        </trans-unit>
        <trans-unit id="b8f9cce63cec2dc22abc32a4cbf9907e736f87ee" translate="yes" xml:space="preserve">
          <source>Function objects, Function invocations, Bind operations and Reference wrappers</source>
          <target state="translated">関数オブジェクト、関数呼び出し、バインド操作、参照ラッパー</target>
        </trans-unit>
        <trans-unit id="474b3e14aec889f00fbd7fffa4899aaf67c18da3" translate="yes" xml:space="preserve">
          <source>Function overloads vs function specializations</source>
          <target state="translated">関数のオーバーロードと関数の特殊化</target>
        </trans-unit>
        <trans-unit id="05c625ce62f1567c6464e68f3d0c5ca596683e7c" translate="yes" xml:space="preserve">
          <source>Function parameter list</source>
          <target state="translated">機能パラメータ一覧</target>
        </trans-unit>
        <trans-unit id="cacf242390ee182c0b5703d0e286b16458b2d6ac" translate="yes" xml:space="preserve">
          <source>Function parameter pack (a form of &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, appears in a function parameter list of a variadic function template).</source>
          <target state="translated">関数パラメーターパック（&lt;a href=&quot;declarations&quot;&gt;declaratorの&lt;/a&gt;形式で、可変個関数テンプレートの関数パラメーターリストに表示されます）。</target>
        </trans-unit>
        <trans-unit id="ee2ed22b6c316767fa0eee64138df658812f8372" translate="yes" xml:space="preserve">
          <source>Function parameter scope</source>
          <target state="translated">機能パラメータの範囲</target>
        </trans-unit>
        <trans-unit id="16a39e4b6666353c50f59b56d3cce3eb5dbeca02" translate="yes" xml:space="preserve">
          <source>Function parameters are not allowed in default arguments (even if they are not evaluated)(until C++14) except if they are unevaluated(since C++14). Note that parameters that appear earlier in the parameter list are in &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">関数パラメーターは、評価されない場合（C ++ 14以降）を除き、（評価されない場合でも）（C ++ 14まで）デフォルト引数では許可されません。パラメータリストの前にあるパラメータは&lt;a href=&quot;scope&quot;&gt;スコープ内にある&lt;/a&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c545df3352143fe60a307ebf941a3169f4b04ba9" translate="yes" xml:space="preserve">
          <source>Function pointer conversions</source>
          <target state="translated">関数ポインタの変換</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">機能範囲</target>
        </trans-unit>
        <trans-unit id="d879bbf1375b073db057a0370df0b5d2aaf75d77" translate="yes" xml:space="preserve">
          <source>Function template</source>
          <target state="translated">関数テンプレート</target>
        </trans-unit>
        <trans-unit id="e8ac637a6e8fb2f46175ee490eb2eb83645238b8" translate="yes" xml:space="preserve">
          <source>Function template &lt;code&gt;std::mem_fn&lt;/code&gt; generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a &lt;code&gt;std::mem_fn&lt;/code&gt;.</source>
          <target state="translated">関数テンプレート &lt;code&gt;std::mem_fn&lt;/code&gt; は、メンバーへのポインターを格納、コピー、および呼び出すことができるメンバーへのポインターのラッパーオブジェクトを生成します。 &lt;code&gt;std::mem_fn&lt;/code&gt; を呼び出すときに、オブジェクトへの参照とポインター（スマートポインターを含む）の両方を使用できます。</target>
        </trans-unit>
        <trans-unit id="ba1b466469de4bedf72f07dd5b3b51bc92ecf5e1" translate="yes" xml:space="preserve">
          <source>Function template instantiation</source>
          <target state="translated">関数テンプレートのインスタンス化</target>
        </trans-unit>
        <trans-unit id="a76d53230697569d7c028ff1451f97505d469db4" translate="yes" xml:space="preserve">
          <source>Function template overloading</source>
          <target state="translated">関数テンプレートのオーバーロード</target>
        </trans-unit>
        <trans-unit id="86dd3fddcc75cfa4e063a703f32c8ede28f4c30d" translate="yes" xml:space="preserve">
          <source>Function template parameters are substituted (replaced by template arguments) twice:</source>
          <target state="translated">関数のテンプレートパラメータは2回置換(テンプレート引数に置き換え)されます。</target>
        </trans-unit>
        <trans-unit id="6027571a098596d5e87183ff7d586ec483f03343" translate="yes" xml:space="preserve">
          <source>Function template specialization</source>
          <target state="translated">関数テンプレート特化</target>
        </trans-unit>
        <trans-unit id="c03fc20cda6df9ef92fd64413e95464c0412a4fc" translate="yes" xml:space="preserve">
          <source>Function templates &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; are helper functions that generate an object of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, using &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; to determine the template argument of the result.</source>
          <target state="translated">関数テンプレート &lt;code&gt;ref&lt;/code&gt; および &lt;code&gt;cref&lt;/code&gt; は、型 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; オブジェクトを生成するヘルパー関数であり、&lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;テンプレート引数演繹&lt;/a&gt;を使用して、結果のテンプレート引数を決定します。</target>
        </trans-unit>
        <trans-unit id="d90c99af4d1617c8e3520279788821d8d6072cea" translate="yes" xml:space="preserve">
          <source>Function templates and non-template functions may be overloaded.</source>
          <target state="translated">関数テンプレートや非テンプレート関数に負荷がかかる場合があります。</target>
        </trans-unit>
        <trans-unit id="527a4bc836096e4223cdeb54a2dc838640d3aaaa" translate="yes" xml:space="preserve">
          <source>Function to pointer</source>
          <target state="translated">ポインタへの関数</target>
        </trans-unit>
        <trans-unit id="ccff159bf6b5506e0e1b9835119cc9060c666c2b" translate="yes" xml:space="preserve">
          <source>Function wrappers</source>
          <target state="translated">関数ラッパー</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">関数のようなマクロ</target>
        </trans-unit>
        <trans-unit id="a542b043e775e7bb5b171b48eca68e3eaf37af10" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">関数型マクロは、定義された識別子の各出現を replacement-list で置換し、さらにいくつかの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="1bc7ec84b7f54258ed54c7cecbe2e69587cb60b9" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all definitions of the same &lt;a href=&quot;inline&quot;&gt;inline function&lt;/a&gt; (which may be implicitly inline) all refer to the same object defined in one translation unit.</source>
          <target state="translated">同じ&lt;a href=&quot;inline&quot;&gt;インライン関数&lt;/a&gt;（暗黙的にインラインである場合があります）のすべての定義内の関数ローカル静的オブジェクトはすべて、1つの変換単位で定義された同じオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="fbeb9de485717bfd55eb5b969f4aef0b216aa354" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all function definitions are shared across all translation units (they all refer to the same object defined in one translation unit)</source>
          <target state="translated">すべての関数定義の関数ローカル静的オブジェクトは、すべての変換ユニットで共有されます(これらはすべて、1つの変換ユニットで定義された同じオブジェクトを参照します)。</target>
        </trans-unit>
        <trans-unit id="22b482f447a1cfcb8f938c680757e7b627882a11" translate="yes" xml:space="preserve">
          <source>Function-try-block</source>
          <target state="translated">Function-try-block</target>
        </trans-unit>
        <trans-unit id="36dbe687f7a701ccda0c0ab3d3368fc1726070a3" translate="yes" xml:space="preserve">
          <source>Function-try-block does not catch the exceptions thrown by the copy/move constructors and the destructors of the function parameters passed by value: those exceptions are thrown in context of the caller.</source>
          <target state="translated">Function-try-blockはcopymoveのコンストラクタやvalueで渡された関数パラメータのデストラクタで発生する例外をキャッチしません。</target>
        </trans-unit>
        <trans-unit id="62fa030d8057f6948ce260fe787ed5a6b93441e6" translate="yes" xml:space="preserve">
          <source>Function-try-block of the top-level function of a thread does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;thread-local&lt;/a&gt; objects (except for the constructors of function-scoped thread-locals).</source>
          <target state="translated">スレッドのトップレベル関数のFunction-try-blockは、&lt;a href=&quot;storage_duration&quot;&gt;スレッドローカル&lt;/a&gt;オブジェクトのコンストラクターおよびデストラクタからスローされた例外をキャッチしません（関数スコープのスレッドローカルのコンストラクターを除く）。</target>
        </trans-unit>
        <trans-unit id="e6221f912553a22b3b906841565a95ac6fe744e4" translate="yes" xml:space="preserve">
          <source>FunctionObject</source>
          <target state="translated">FunctionObject</target>
        </trans-unit>
        <trans-unit id="c504a5185db1d5f75bfd32087e1e44501fcf47f1" translate="yes" xml:space="preserve">
          <source>Functional cast</source>
          <target state="translated">機能性キャスト</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b4889f5791eb376ad73674ef2d3c06e94b724603" translate="yes" xml:space="preserve">
          <source>Functions and macro constants for signal management</source>
          <target state="translated">信号管理のための関数とマクロ定数</target>
        </trans-unit>
        <trans-unit id="a1141ae7da62060d933a86668311750ac59f208e" translate="yes" xml:space="preserve">
          <source>Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;.</source>
          <target state="translated">関数と関数への参照は関数オブジェクト型ではありませんが、関数からポインターへの&lt;a href=&quot;../language/implicit_cast&quot;&gt;暗黙的な変換の&lt;/a&gt;ために関数オブジェクト型が期待される場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="ab7bbe95387b8d4e9017d700d4c60ae66f3da45c" translate="yes" xml:space="preserve">
          <source>Functions are C++ entities that associate a sequence of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; (a</source>
          <target state="translated">関数は、一連の&lt;a href=&quot;statements&quot;&gt;ステートメント&lt;/a&gt;（a</target>
        </trans-unit>
        <trans-unit id="9a1ebfefe2d4935a5dd163de13ea3976c504e0ea" translate="yes" xml:space="preserve">
          <source>Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions are allowed, and may be used where functions themselves cannot.</source>
          <target state="translated">関数はオブジェクトではありません:関数の配列は存在せず、関数は値を渡したり他の関数から返したりすることはできません。関数へのポインタや参照は許可されており、関数自体が使用できない場合に使用することができます。</target>
        </trans-unit>
        <trans-unit id="e4cd68a9abe69d2fc916398ed73a57ddaba5e3ac" translate="yes" xml:space="preserve">
          <source>Functions differing only in their exception specification cannot be overloaded (just like the return type, exception specification is part of function type, but not part of the function signature)(since C++17).</source>
          <target state="translated">例外指定だけが異なる関数はオーバーロードできません(戻り値型と同じように、例外指定は関数型の一部ですが、関数シグネチャの一部ではありません)(C++17以降)。</target>
        </trans-unit>
        <trans-unit id="d805e16a2e1dab2e9501d00d8aa06488d3d1141d" translate="yes" xml:space="preserve">
          <source>Functions in input/output classes returning this type use &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; is an invalid value to signal an error</source>
          <target state="translated">この型を使用する入出力クラスの関数は、 &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; を使用してエラーを通知するには無効な値です</target>
        </trans-unit>
        <trans-unit id="f4f28c856ebb451338613595e08fe5dd22c841b5" translate="yes" xml:space="preserve">
          <source>Functions managing the current thread</source>
          <target state="translated">現在のスレッドを管理する関数</target>
        </trans-unit>
        <trans-unit id="d3e493f42a02a1130d7650420222293b27d1128f" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 渡される関数は、登録の逆の順序で呼び出されます。例外が関数の外に伝播しようとすると、 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。登録された関数を呼び出した後、 &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="2271b1375ac754084b518ec111ad83a20a6f3bb3" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 渡される関数は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="a4c76c24658f2c936074eb17b534063810ef4a85" translate="yes" xml:space="preserve">
          <source>Functions templates cannot be declared &lt;code&gt;virtual&lt;/code&gt;. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</source>
          <target state="translated">関数テンプレートは &lt;code&gt;virtual&lt;/code&gt; として宣言できません。これは、それ自体がテンプレートである関数にのみ適用されます。クラステンプレートの通常のメンバー関数は、仮想として宣言できます。</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">文字データに含まれる型を判定する機能</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">ワイド文字データに含まれる型を判定する機能</target>
        </trans-unit>
        <trans-unit id="268aa8a9dc8a94eb9552c1bc422fd7d569604150" translate="yes" xml:space="preserve">
          <source>Fundamental library concepts</source>
          <target state="translated">図書館の基本的な考え方</target>
        </trans-unit>
        <trans-unit id="9415eca058dab008a0c257d5b5372a414020f727" translate="yes" xml:space="preserve">
          <source>Fundamental types</source>
          <target state="translated">基本的な種類</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">言語によって定義された基本的な型</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">続きを読む</target>
        </trans-unit>
        <trans-unit id="90203b2e01951bcae33561da4c2fe607351b5912" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;auto&lt;/code&gt;and type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20) can appear in:</source>
          <target state="translated">さらに、 &lt;code&gt;auto&lt;/code&gt; およびtype-constraint &lt;code&gt;auto&lt;/code&gt; （C ++ 20以降）は次の場所で使用できます。</target>
        </trans-unit>
        <trans-unit id="6dc21edb8c36c3f6d406c872d0cb241b792a813e" translate="yes" xml:space="preserve">
          <source>Furthermore.</source>
          <target state="translated">Furthermore.</target>
        </trans-unit>
        <trans-unit id="ef3bf279dd511b3249e9a0fa2ada2e63ca452156" translate="yes" xml:space="preserve">
          <source>Future errors</source>
          <target state="translated">将来のエラー</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c00eeb89fd7b78411cbeb5ccec11fa4c97f179d" translate="yes" xml:space="preserve">
          <source>GCC 4.6 libstdc++</source>
          <target state="translated">GCC 4.6 libstdc++</target>
        </trans-unit>
        <trans-unit id="8678ed721c5d5bc588ebb7a34742eafcc58d8a66" translate="yes" xml:space="preserve">
          <source>GCC Inline Assembly HOWTO</source>
          <target state="translated">GCCインラインアセンブリHOWTO</target>
        </trans-unit>
        <trans-unit id="e28f7b13c864b2544bcffb8944485f05b95aa03f" translate="yes" xml:space="preserve">
          <source>GCC assembly with the attribute:</source>
          <target state="translated">属性を持つGCCアセンブリ。</target>
        </trans-unit>
        <trans-unit id="29dc240b146eb494ed0bbceef77ad1534442b61b" translate="yes" xml:space="preserve">
          <source>GCC assembly without the attribute: the entire function is serialized.</source>
          <target state="translated">属性を持たないGCCアセンブリ:関数全体がシリアル化されます。</target>
        </trans-unit>
        <trans-unit id="607e8f7d61ea73ecc2a3928fe014d54ac981f615" translate="yes" xml:space="preserve">
          <source>GLAGOLITIC CAPITAL LETTER AZU - COMBINING CYRILLIC LETTER IOTIFIED BIG YUS</source>
          <target state="translated">グラゴライトの大文字アズ-キリル文字を組み合わせたイオティファイドビッグユス</target>
        </trans-unit>
        <trans-unit id="770bd3164fd3f78b840dd2606eee557790bae82f" translate="yes" xml:space="preserve">
          <source>GNU libc function &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates the signal &lt;code&gt;SIGFPE&lt;/code&gt;. If the compiler option &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; was used, the handler for that signal may throw a user-defined C++ exception.</source>
          <target state="translated">GNU libc関数 &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; は、浮動小数点例外のトラップを有効にし、シグナル &lt;code&gt;SIGFPE&lt;/code&gt; を生成します。コンパイラオプション &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; が使用された場合、そのシグナルのハンドラはユーザー定義のC ++例外をスローする場合があります。</target>
        </trans-unit>
        <trans-unit id="7e7d86fda01350dd97d7deed580504fa4ea12720" translate="yes" xml:space="preserve">
          <source>GNU libstdc++ stores 4 additional members: three cached facets and a flag to indicate that fill was initialized.</source>
          <target state="translated">GNU libstdc++は4つの追加メンバを格納します:3つのキャッシュされたファセットと、 fillが初期化されたことを示すフラグです。</target>
        </trans-unit>
        <trans-unit id="262e4b5ffc0564ab9152ecabdaf6c1affcaea1bc" translate="yes" xml:space="preserve">
          <source>GOTW issue 47: Uncaught Exceptions</source>
          <target state="translated">GOTW 47号 捕まえられない例外</target>
        </trans-unit>
        <trans-unit id="143075ce23be9b2dbef6368dc5e0e4219829451a" translate="yes" xml:space="preserve">
          <source>Garbage collector support</source>
          <target state="translated">ごみ収集器対応</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c807e9f8f0554603e2d07bd5ea3e21f358d0409a" translate="yes" xml:space="preserve">
          <source>General purpose utilities: &lt;a href=&quot;utility/program&quot;&gt; program control&lt;/a&gt;, &lt;a href=&quot;memory/c&quot;&gt; dynamic memory allocation&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt; random numbers&lt;/a&gt;, &lt;a href=&quot;algorithm&quot;&gt; sort and search&lt;/a&gt;</source>
          <target state="translated">汎用ユーティリティ：&lt;a href=&quot;utility/program&quot;&gt;プログラム制御&lt;/a&gt;、&lt;a href=&quot;memory/c&quot;&gt;動的メモリ割り当て&lt;/a&gt;、&lt;a href=&quot;numeric/random&quot;&gt;乱数&lt;/a&gt;、&lt;a href=&quot;algorithm&quot;&gt;並べ替え、検索&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed31062b543a89f89f4324118c873e8e23d6d8a5" translate="yes" xml:space="preserve">
          <source>General-purpose utilities</source>
          <target state="translated">汎用ユーティリティ</target>
        </trans-unit>
        <trans-unit id="5c6d1d670f7f626ac925f247ce54a21001aced36" translate="yes" xml:space="preserve">
          <source>Generalized lambda-capture</source>
          <target state="translated">一般化されたラムダキャプチャ</target>
        </trans-unit>
        <trans-unit id="f356c8b2b591cd001b93f307940d89de652b1d90" translate="yes" xml:space="preserve">
          <source>Generalized range-based &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">一般化された範囲ベースの &lt;code&gt;for&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="42544cf1873411d097739bf7d82068c8b915ea3d" translate="yes" xml:space="preserve">
          <source>Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;*first&lt;/code&gt;, &lt;code&gt;*(first+1)&lt;/code&gt;, ... &lt;code&gt;*(last-1)&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; と &lt;code&gt;*first&lt;/code&gt; 、 &lt;code&gt;*(first+1)&lt;/code&gt; 、... &lt;code&gt;*(last-1)&lt;/code&gt; の &lt;code&gt;binary_op&lt;/code&gt; に対する一般化された合計、</target>
        </trans-unit>
        <trans-unit id="13dfcc134e2752a1f9a0a0493daeaa583d9e01a7" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, at the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">一般的に言って、疑似乱数ジェネレータは、プログラムの開始時に &lt;code&gt;rand()&lt;/code&gt; を呼び出す前に一度だけシードする必要があります。疑似乱数の新しいバッチを生成するたびに、シードを繰り返したり、再シードしたりしないでください。</target>
        </trans-unit>
        <trans-unit id="7ebbc49a3b2f1f41072b44a34d7a54d1bce22da9" translate="yes" xml:space="preserve">
          <source>Generates a non-deterministic uniformly-distributed random value.</source>
          <target state="translated">非決定論的な一様分布ランダム値を生成します。</target>
        </trans-unit>
        <trans-unit id="974bfaa70e23e754b8c317100b6cf3c9baf7cefa" translate="yes" xml:space="preserve">
          <source>Generates a pseudo-random value. The state of the engine is advanced by one position.</source>
          <target state="translated">擬似乱数値を生成します。エンジンの状態を1ポジション進めます。</target>
        </trans-unit>
        <trans-unit id="69477acbfb73a301833c0442c884476d728e54ee" translate="yes" xml:space="preserve">
          <source>Generates a random floating point number in range [0, 1).</source>
          <target state="translated">範囲[0,1]のランダムな浮動小数点数を生成します。</target>
        </trans-unit>
        <trans-unit id="e11bac75cd58a1ca2fdf3ef16eb35185ecf226b4" translate="yes" xml:space="preserve">
          <source>Generates a random value. The state of the underlying engine is advanced one or more times.</source>
          <target state="translated">ランダムな値を生成します。基礎となるエンジンの状態を1回以上進めます。</target>
        </trans-unit>
        <trans-unit id="045d154a63fd09f9bc95c348dc0baa989ebab1d6" translate="yes" xml:space="preserve">
          <source>Generates random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal (or Gaussian) random number distribution&lt;/a&gt;. It is defined as:   f(x; &amp;mu;,&amp;sigma;) =</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;正規（またはガウス）乱数分布&lt;/a&gt;に従って乱数を生成します。次のように定義されます：f（x;&amp;mu;、&amp;sigma;）=</target>
        </trans-unit>
        <trans-unit id="74b3ade82ac714c1951306b471876167535085c8" translate="yes" xml:space="preserve">
          <source>Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">関連する確率関数に従って分散される乱数を生成します。エントロピーは、 &lt;code&gt;g.operator()&lt;/code&gt; を呼び出すことによって取得されます。</target>
        </trans-unit>
        <trans-unit id="8d441fb5f62f87aca029a4bb398180b09920a3f5" translate="yes" xml:space="preserve">
          <source>Generation</source>
          <target state="translated">Generation</target>
        </trans-unit>
        <trans-unit id="742daa97a3eea8220673e99a3db1f627bdf6d93c" translate="yes" xml:space="preserve">
          <source>Generic (polymorphic) lambda expressions</source>
          <target state="translated">一般的な(多相)ラムダ式</target>
        </trans-unit>
        <trans-unit id="a3b12ef32437e95ff76df32c3bf2e29d863224ec" translate="yes" xml:space="preserve">
          <source>Generic components may, in addition, offer</source>
          <target state="translated">一般的なコンポーネントは、さらに、以下を提供してもよい。</target>
        </trans-unit>
        <trans-unit id="d399f4838f649a1dd72fc3c7d1626e48aca6fcc9" translate="yes" xml:space="preserve">
          <source>Generic locking algorithms</source>
          <target state="translated">一般的なロックアルゴリズム</target>
        </trans-unit>
        <trans-unit id="522f4aca708bf0b67f4969ccd2a81f0afbce9777" translate="yes" xml:space="preserve">
          <source>Generic mutex management</source>
          <target state="translated">汎用ミューテックス管理</target>
        </trans-unit>
        <trans-unit id="bb5f7091dca0b61fa982fa58c2f04caba2c88133" translate="yes" xml:space="preserve">
          <source>Generic pathname format</source>
          <target state="translated">一般的なパス名のフォーマット</target>
        </trans-unit>
        <trans-unit id="5062b24e22ad40ee77724d279398f1dbf438838e" translate="yes" xml:space="preserve">
          <source>Get area</source>
          <target state="translated">エリアを取得</target>
        </trans-unit>
        <trans-unit id="f30e54b151b7e1d903f56be15b95cfc3a9e8869c" translate="yes" xml:space="preserve">
          <source>Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ストリームの例外マスクを取得および設定します。例外マスクは、ストリームが &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt; タイプの例外をスローする発生時のエラー状態を決定します。</target>
        </trans-unit>
        <trans-unit id="b970edd37ceef3acb34a7c5e361913bd8492e2aa" translate="yes" xml:space="preserve">
          <source>Gets and sets the underlying string.</source>
          <target state="translated">文字列を取得・設定します。</target>
        </trans-unit>
        <trans-unit id="332452f1980fa4e174e790babca85d5c6e588e9e" translate="yes" xml:space="preserve">
          <source>Gets the default memory resource pointer.</source>
          <target state="translated">デフォルトのメモリリソースポインタを取得します。</target>
        </trans-unit>
        <trans-unit id="499d742f096a087b00e3a25ac2c61ce6526047bb" translate="yes" xml:space="preserve">
          <source>Getting the result</source>
          <target state="translated">結果の取得</target>
        </trans-unit>
        <trans-unit id="a31c54bbb19e0e2599a1d0ad74d19479e5b692ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, performs O(log N) applications of the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">所与の &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 述語の、実行O（Nログ）アプリケーション &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2de26a11901d553b8a58d6c3ba8e560899db14ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;},</source>
          <target state="translated">所与の &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; }、</target>
        </trans-unit>
        <trans-unit id="201a57a136c12310d1acc1180f1b02b9f2f6f001" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = last - first&lt;/code&gt;.</source>
          <target state="translated">与えられた &lt;code&gt;N = last - first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3e5ecd385ba57ca31705c6a420eb24ffafacec4" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, dereferenceable iterators of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">与えられた &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 、タイプのdereferenceableイテレータ &lt;code&gt;It&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd092018ae73c0887d7dc6c9b1bb5a5adc4b89b7" translate="yes" xml:space="preserve">
          <source>Given N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;,</source>
          <target state="translated">N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; 場合、</target>
        </trans-unit>
        <trans-unit id="a60f6d48405c975ae0935013623bdd24a66ebef7" translate="yes" xml:space="preserve">
          <source>Given a BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; and a pair of iterators &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt; or an iterator &lt;code&gt;iter&lt;/code&gt; and a value &lt;code&gt;value&lt;/code&gt;, the expression &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; or, respectively, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt;, must be &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; とイテレータのペア &lt;code&gt;iter1&lt;/code&gt; と &lt;code&gt;iter2&lt;/code&gt; 、またはイテレータ &lt;code&gt;iter&lt;/code&gt; と値 &lt;code&gt;value&lt;/code&gt; が与えられた場合、式 &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; またはそれぞれ &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt; 、&lt;a href=&quot;../language/implicit_cast&quot;&gt;状況に応じ&lt;/a&gt;て &lt;code&gt;bool&lt;/code&gt; に変換できる必要があります。</target>
        </trans-unit>
        <trans-unit id="8aa890934e1378f6d141dac2f7867c119b8ad1fa" translate="yes" xml:space="preserve">
          <source>Given a function parameter &lt;code&gt;P&lt;/code&gt; that depends on one or more type template parameters &lt;code&gt;T&lt;/code&gt;i, template template parameters &lt;code&gt;TT&lt;/code&gt;i, or non-type template parameters &lt;code&gt;I&lt;/code&gt;i, and the corresponding argument &lt;code&gt;A&lt;/code&gt;, deduction takes place if &lt;code&gt;P&lt;/code&gt; has one of the following forms:</source>
          <target state="translated">1つ以上のタイプテンプレートパラメーター &lt;code&gt;T&lt;/code&gt; i、テンプレートテンプレートパラメーター &lt;code&gt;TT&lt;/code&gt; i、または非タイプテンプレートパラメーター &lt;code&gt;I&lt;/code&gt; iに依存する関数パラメーター &lt;code&gt;P&lt;/code&gt; 、および対応する引数 &lt;code&gt;A&lt;/code&gt; が与えられると、 &lt;code&gt;P&lt;/code&gt; が次の形式のいずれかである場合、演繹が行われます。</target>
        </trans-unit>
        <trans-unit id="849104a88d07876b31798d027eae5e4b5ac7a9c0" translate="yes" xml:space="preserve">
          <source>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.</source>
          <target state="translated">サイズ空間のバッファへのポインタptrが与えられると、指定されたサイズのバイト数分だけアラインメントされたポインタを返し、空間の引数はアラインメントに使用されたバイト数分だけ減少します。最初にアラインメントされたアドレスが返される。</target>
        </trans-unit>
        <trans-unit id="1d1642375a13cf9d00a6f14be269e1b8dfaf5497" translate="yes" xml:space="preserve">
          <source>Given a set of types &lt;code&gt;Args...&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; meet the requirements for arguments to &lt;code&gt;ranges::swap&lt;/code&gt; above, &lt;code&gt;SwapT&lt;/code&gt; will satisfy &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt;. Otherwise, no function call operator of &lt;code&gt;SwapT&lt;/code&gt; participates in overload resolution.</source>
          <target state="translated">種類の集合が与えられる &lt;code&gt;Args...&lt;/code&gt; 場合は、 &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; への引数のための要件を満たし &lt;code&gt;ranges::swap&lt;/code&gt; 上記を、 &lt;code&gt;SwapT&lt;/code&gt; 満たす &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;SwapT&lt;/code&gt; の関数呼び出し演算子はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="cd88ec801294426ab54d23bc136aca37fe96b8e0" translate="yes" xml:space="preserve">
          <source>Given a user-defined &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&lt;/code&gt; for objects of type &lt;code&gt;T&lt;/code&gt;, implements the usual semantics of other comparison operators.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型のオブジェクトに対してユーザー定義の &lt;code&gt;operator==&lt;/code&gt; および &lt;code&gt;operator&amp;lt;&lt;/code&gt; を指定すると、他の比較演算子の通常のセマンティクスを実装します。</target>
        </trans-unit>
        <trans-unit id="9347968d88bdedbaad63962c44f19bc3e70fd1d7" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; が与えられた場合：</target>
        </trans-unit>
        <trans-unit id="c587de6b8b3e1339541445cfac7615e9dbb23ca9" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multimap&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;multimap&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="a14568942f46c8464d02bc68bb11bb1b20d8f671" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multiset&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;multiset&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="3e2459dd2b814290389adeffd53910165c623ff3" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; インスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="881f1c518159f483a92d230aff08438c975cfc40" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;unordered_map&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="fa31a301eaa86d94083d76755aeb6d15245d1d46" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multimap&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;unordered_multimap&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="f6d85ed3e34fe83d62419c16e466b796d53d7bae" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multiset&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;unordered_multiset&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="a229fa6402280d8d3988d3795c697a501535b4a0" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_set&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;unordered_set&lt;/code&gt; のインスタンス &lt;code&gt;c&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="585b276223e3efe88a4cec484dd924b01d338788" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;G&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind_front(f, args...)&lt;/code&gt;, when a glvalue &lt;code&gt;g&lt;/code&gt; designating &lt;code&gt;G&lt;/code&gt; is invoked in a function call expression &lt;code&gt;g(call_args...)&lt;/code&gt;, an invocation of the stored object takes place, as if by.</source>
          <target state="translated">オブジェクトの指定された &lt;code&gt;G&lt;/code&gt; に以前の呼び出しから得られた &lt;code&gt;bind_front(f, args...)&lt;/code&gt; 、場合glvalue &lt;code&gt;g&lt;/code&gt; 指定 &lt;code&gt;G&lt;/code&gt; れる関数呼び出し式で呼び出さ &lt;code&gt;g(call_args...)&lt;/code&gt; 記憶されたオブジェクトの呼び出しが行われ、のように。</target>
        </trans-unit>
        <trans-unit id="a88f34b4e5838dad793cf28d772a20e6a14e6fb1" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;g&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind&lt;/code&gt;, when it is invoked in a function call expression &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt;, an invocation of the stored object takes place, as if by &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt;, where &lt;code&gt;fd&lt;/code&gt; is a value of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; the values and types of the bound arguments &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; are determined as specified below.</source>
          <target state="translated">以前に &lt;code&gt;bind&lt;/code&gt; を呼び出して取得したオブジェクト &lt;code&gt;g&lt;/code&gt; が与えられ、関数呼び出し式 &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt; で呼び出されると、 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt; （ fd、&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V1&amp;gt;（v1）、&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V2&amp;gt;（v2）、...、&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;VN&amp;gt;（vN））、ここで &lt;code&gt;fd&lt;/code&gt; はタイプ &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 値ですdecay_t &amp;lt;F&amp;gt;バインドされた引数 &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; の値とタイプは、次のように決定されます。</target>
        </trans-unit>
        <trans-unit id="a8337adfa8cf3c8e162bcbe5e0229685e6eb60d8" translate="yes" xml:space="preserve">
          <source>Given the character sequence from the previous steps, if the first character equals &lt;code&gt;ct.widen('-')&lt;/code&gt;, calls &lt;code&gt;mp.neg_format()&lt;/code&gt; to obtain the formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, otherwise calls &lt;code&gt;mp.pos_format()&lt;/code&gt;, where &lt;code&gt;mp&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;.</source>
          <target state="translated">前の手順の文字シーケンスを &lt;code&gt;ct.widen('-')&lt;/code&gt; 、最初の文字がct.widen（ '-'）と等しい場合は、 &lt;code&gt;mp.neg_format()&lt;/code&gt; を呼び出してフォーマット &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; を取得します。それ以外の場合は、 &lt;code&gt;mp.pos_format()&lt;/code&gt; を呼び出します。ここで、 &lt;code&gt;mp&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; ファセットが &lt;code&gt;str.getloc()&lt;/code&gt; に組み込まれています。</target>
        </trans-unit>
        <trans-unit id="66236ee54dcad384d354db9941193df8b20deffb" translate="yes" xml:space="preserve">
          <source>Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of</source>
          <target state="translated">上述のように構築された候補関数の集合が与えられると、オーバーロード解決の次のステップでは、引数とパラメータを調べて集合を</target>
        </trans-unit>
        <trans-unit id="c0aebd42da085f11a7898d7938dcfcf81f34f4ad" translate="yes" xml:space="preserve">
          <source>Given the starting value s, a list of strides i</source>
          <target state="translated">開始値 s が与えられると,ストライド i のリスト</target>
        </trans-unit>
        <trans-unit id="93321ba8b5317191b60feb65e2cf919f7e2a81f1" translate="yes" xml:space="preserve">
          <source>Given.</source>
          <target state="translated">Given.</target>
        </trans-unit>
        <trans-unit id="c46a97000778eff7a9406aa7dac4bb058a740c4f" translate="yes" xml:space="preserve">
          <source>Gives well-defined results for reference types, void types, array types, and function types.</source>
          <target state="translated">参照型、Void型、配列型、関数型について、定義された結果を提供します。</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">グローバルオブジェクト</target>
        </trans-unit>
        <trans-unit id="8ecf59cbff938c3c09e7ac755a67fc60c8335206" translate="yes" xml:space="preserve">
          <source>Global replacements</source>
          <target state="translated">グローバルな置き換え</target>
        </trans-unit>
        <trans-unit id="6f85091c78ab312c0eeab087e50a90d21a6d8a82" translate="yes" xml:space="preserve">
          <source>Guaranteed copy elision through simplified &lt;a href=&quot;language/value_category&quot;&gt;value categories&lt;/a&gt;</source>
          <target state="translated">簡略化された&lt;a href=&quot;language/value_category&quot;&gt;値カテゴリ&lt;/a&gt;によるコピー省略の保証</target>
        </trans-unit>
        <trans-unit id="daf1a29d21388e553e2e351d8eb2ded2e9be0a7c" translate="yes" xml:space="preserve">
          <source>Guides (2-3) are needed because the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; constructors for &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;s are made templates to avoid causing ambiguities in existing code, and those templates do not support class template argument deduction.</source>
          <target state="translated">ので、ガイド（2-3）が必要とされている &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; のコンストラクタ &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; sが、既存のコードにあいまいさの原因を避けるためにテンプレートを作られて、それらのテンプレートがクラステンプレート引数控除をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="ab161f039e51e47e91c7fb547b04ada20d53b4a3" translate="yes" xml:space="preserve">
          <source>H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;What's In a Class? - The Interface Principle&quot;&lt;/a&gt; in C++ Report, 10(3)</source>
          <target state="translated">H. Sutter（1998）&lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;「クラスには何があるのか&lt;/a&gt; -C ++レポートのインターフェイス原則」、10（3）</target>
        </trans-unit>
        <trans-unit id="4d2fcf54f70e7b8f49c067c962c20ecc9c2156b7" translate="yes" xml:space="preserve">
          <source>H. Sutter (2000) &quot;Exceptional C++&quot;</source>
          <target state="translated">H.サター (2000)&quot;例外的なC++&quot;</target>
        </trans-unit>
        <trans-unit id="4dba1c99fa72599cb430192c2725ee29e7826d41" translate="yes" xml:space="preserve">
          <source>H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;When and How to Use Exceptions&quot;&lt;/a&gt; in Dr. Dobb's</source>
          <target state="translated">H.サッター（2004）ドブ博士の&lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;「例外と例外の使用方法」&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3726a2cbec5aa86ee541f35ad869f9d462e3d65" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004) &quot;C++ Coding Standards&quot; Item 73</source>
          <target state="translated">H.Sutter,A.A.Alexandrescu (2004)&quot;C++Coding Standards&quot; 項目 73</target>
        </trans-unit>
        <trans-unit id="3ee760973e367e7fcaab598e6a4779e4ff88cda5" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004), &quot;C++ Coding Standards&quot;, Item 70</source>
          <target state="translated">H.Sutter,A.A.Alexandrescu (2004),&quot;C++Coding Standards&quot;,項目70</target>
        </trans-unit>
        <trans-unit id="202043e89dc2aeb009dea78fe3ba6aecc90d862d" translate="yes" xml:space="preserve">
          <source>HANGZHOU NUMERAL ONE - HANGUL DOUBLE DOT TONE MARK</source>
          <target state="translated">杭州数字1-ハングルダブルドットトーンマーク</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">huge_valf,huge_val,huge_vall</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="71eafe8cf5a2cb341c2f05d96f0f6422891ac1dd" translate="yes" xml:space="preserve">
          <source>Handling of exception specification violations (removed in C++17)</source>
          <target state="translated">例外指定違反の処理(C++17 で削除</target>
        </trans-unit>
        <trans-unit id="5c4704b5df9665a78c88de802bae877af50465d2" translate="yes" xml:space="preserve">
          <source>Handling of failures in exception handling</source>
          <target state="translated">例外処理での失敗の処理</target>
        </trans-unit>
        <trans-unit id="ea1720079c69bfadf4103ddaa2b4cd30fc66377a" translate="yes" xml:space="preserve">
          <source>Handling of variable length argument lists</source>
          <target state="translated">可変長の引数リストの取り扱い</target>
        </trans-unit>
        <trans-unit id="0e8c641cc752e55897602b479a23cc749b022d01" translate="yes" xml:space="preserve">
          <source>Happens-before</source>
          <target state="translated">Happens-before</target>
        </trans-unit>
        <trans-unit id="94332d550f7e901bb03f8bebf16b0fe18a1b3ec5" translate="yes" xml:space="preserve">
          <source>Hard links typically cannot cross filesystem boundaries.</source>
          <target state="translated">ハードリンクは通常、ファイルシステムの境界を越えることができません。</target>
        </trans-unit>
        <trans-unit id="5c50832940f07dd15684fc07335b91ae9b50c034" translate="yes" xml:space="preserve">
          <source>Hardlinking to directories is typically restricted to the superuser.</source>
          <target state="translated">ディレクトリへのハードリンクは通常、スーパーユーザに制限されています。</target>
        </trans-unit>
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">ハードウェアは、 &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; によって参照されるオブジェクトが他の &lt;code&gt;T&lt;/code&gt; オブジェクトよりも厳密なアラインメントを持っていることを要求でき、atomic_ref上の &lt;code&gt;atomic_ref&lt;/code&gt; がロックフリーであるかどうかは、参照されるオブジェクトのアラインメントに依存します。</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">すべての非静的データメンバとビットフィールドが同じクラスで宣言されている (すべての派生クラスまたはすべてのベースクラスで宣言されている)</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">最初の非静的データメンバーと同じ型の基本クラスがない（&lt;a href=&quot;../language/ebo&quot;&gt;空の基本最適化を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">参照型の非静的データメンバを持たない</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">同じ型の基底クラスサブオブジェクトが 2 つもない (間接的な可能性がある)</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">仮想関数や仮想基底クラスを持たない</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;../language/default_constructor&quot;&gt;デフォルトコンストラクターがあり&lt;/a&gt;、それらはすべて&lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;自明&lt;/a&gt;または削除されており、少なくとも1つは削除されていません。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">ハッシュ関数は、プログラムの一回の実行内で、同じ入力に対して同じ結果を生成する必要があるだけです。これにより、衝突によるサービス拒否攻撃を防ぐ塩漬けハッシュが可能になります。</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">ハッシュ関数は例外を投げるべきではありません。</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">ハッシュポリシー</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">ハッシュサポート</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">ヘッダー名の前処理トークンは、 &lt;code&gt;#include&lt;/code&gt; ディレクティブ内でのみ形成されます。</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">に必要なヘッダ</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">ヒープの割り当て</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">ヒープ操作</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">ヘルパークラス</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">ヘルパークラス</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">ヘルパーの概念</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">ヘルパー関数 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;std::reference_wrapper&lt;/code&gt; オブジェクトの生成によく使用されます。</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">入出力のフォーマットを制御するヘルパー機能</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">ヘルパーオブジェクト</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">ヘルパーテンプレート</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">ヘルパーテンプレートのエイリアス</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">ヘルパーテンプレート</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">ヘルパーの種類</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">ヘルパー変数テンプレート</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">ヘルパー変数のテンプレート</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">ここで、&amp;mu;は&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;平均&lt;/a&gt;、&amp;sigma;は&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;標準偏差&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">ここで、sequence &lt;code&gt;= 0&lt;/code&gt; は純粋指定子と呼ばれ、宣言子の直後またはオプションのvirt-specifier（&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt;または&lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;）の後に表示されます。</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">ここで、&lt;b&gt;挿入&lt;/b&gt;とはコンテナに1つ以上の要素を追加するメソッドを指し、&lt;b&gt;消去&lt;/b&gt;とはコンテナから1つ以上の要素を削除するメソッドを指します。</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">エルミート多項式</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">16進エスケープシーケンスには長さの制限がなく、有効な16進数字ではない最初の文字で終了します。単一の16進エスケープシーケンスで表される値が、この文字列リテラルで使用される文字型（ &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;char16_t&lt;/code&gt; 、 &lt;code&gt;char32_t&lt;/code&gt; 、または &lt;code&gt;wchar_t&lt;/code&gt; ）で表される値の範囲に適合しない場合、結果は不定です。</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">16進数浮動小数点リテラル</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">16進浮動小数点フォーマットでは、 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 仕様で要求されているように、ストリーム精度の指定は無視されます。</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">上位レベルのメモリ管理ユーティリティ</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">C++の歴史</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">ホストにアクセスできない</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">時、分、秒</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">ただし、 &lt;code&gt;ForwardIt1&lt;/code&gt; および &lt;code&gt;ForwardIt2&lt;/code&gt; が&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;および &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; の要件を満たしている場合、述語の適用は行われません。</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">ただし、すべてのC ++コンパイラは&lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;2の補数&lt;/a&gt;表現を使用します。C++ 20以降、これは規格で許可されている唯一の表現であり、保証範囲は-2N-1です。</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">しかし、基底クラスのサブオブジェクトはそれほど制約を受けず、オブジェクトのレイアウトから完全に最適化することができます。</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">ただし、非&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorsの&lt;/a&gt;場合、イテレーターの増分数はO（N）です。</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;BidirIt&lt;/code&gt; は別途の要件を満たし&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorを&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt1&lt;/code&gt; と &lt;code&gt;InputIt2&lt;/code&gt; が&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;および &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; の要件を満たしている場合、述語のアプリケーションは作成されません（要素を確認せずにサイズの不一致が検出されます）。</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt&lt;/code&gt; は別途の要件を満たし&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIteratorを&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">ただし、 &lt;code&gt;InputIt&lt;/code&gt; または &lt;code&gt;ForwardIt&lt;/code&gt; がさらにLegacyRandomAccessIteratorの要件を満たしている&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;場合&lt;/a&gt;、複雑さは一定です。</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">ただし、テンプレート引数の推定に参加するすべてのパラメーターの推定が成功し、推定されないすべてのテンプレート引数が明示的に指定またはデフォルト設定されている場合、残りの関数パラメーターは対応する関数引数と比較されます。明示的に指定されたテンプレート引数を置き換える前に非依存であったタイプの残りの各パラメーター &lt;code&gt;P&lt;/code&gt; について、対応する引数 &lt;code&gt;A&lt;/code&gt; を暗黙的に &lt;code&gt;P&lt;/code&gt; に変換できない場合、演繹は失敗します。</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">ただし、宣言で&lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt;（C ++ 17以降）指定子を使用する場合、メンバーは完全な型を持つように宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">しかし、一の実装（libcのは++）を構築することが知られて &lt;code&gt;key_type&lt;/code&gt; と &lt;code&gt;mapped_type&lt;/code&gt; 二つの別々のアロケータを介してオブジェクトを &lt;code&gt;construct()&lt;/code&gt; 公開されている間違いなくむしろ据え付けるよりも、規格によって要求されるように、コール &lt;code&gt;value_type&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">しかし、(上記の構文では)宣言子の後に現れる属性は、関数自体ではなく、関数の型に適用されます。</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲線余弦は、複素平面内の関数全体であり、分岐カットはありません。虚数成分に対して周期的であり、周期は2&amp;pi;iです。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲関数</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲線正弦は複素平面内の関数全体であり、分岐カットはありません。虚数成分に対して周期的であり、周期は2&amp;pi;iです。</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">双曲線正接は、複雑な平野の分析関数であり、分岐カットはありません。これは、虚数成分に対して周期的であり、周期は&amp;pi;iであり、座標（0、&amp;pi;（1/2 + n））に虚数線に沿って1次の極を持っています。ただし、一般的な浮動小数点表現では&amp;pi;/ 2を正確に表現できないため、極エラーが発生する引数の値はありません。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">IOマニピュレータ</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">入出力エラー</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">IOフォーマットフラグは</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL CC++インラインアセンブリ</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559では、 &lt;code&gt;from==to&lt;/code&gt; は常にfromを返すこと &lt;code&gt;from&lt;/code&gt; 推奨しています。これらの関数 &lt;code&gt;to&lt;/code&gt; 代わりにに戻り、ゼロ周辺の動作に一貫性を &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; は &lt;code&gt;+0.0&lt;/code&gt; を返し、 &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; は &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">インバートアンダータイ</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE &amp;lt;R&amp;gt;（f、t1、t2、...、tN）</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112 は、POSIX 制御キ ャ ラ ク タ を Unicode キ ャ ラ ク タ U+0000...U+001F、U+007F...U+009F、U+2028、U+2029 (Unicode クラス Cc、Zl、Zp)と定義しています。</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112は、POSIXスペースキ ャ ラ ク タ を Unicode キ ャ ラ ク タ U+0009...U+000D、U+0020、U+1680、U+180E、U+2000...U+2006、U+2008...U+200A、U+2028、U+2029、U+205F、および U+3000 と定義しています。</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 週ベースの年</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">ISO C 言語標準では、C コンパイラは以下の 3 つのプラグマをサポートすることが要求されており、いくつかの C++コンパイラベンダは C++フロントエンドで程度の差こそあれ、これらをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Container::emplace_back&lt;/code&gt; 複雑さと同じです。</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">識別子の削除</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
