<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="42d66c9df47506c2bbd054315689658beb84bc9e" translate="yes" xml:space="preserve">
          <source>U+B0000 - U+BFFFD</source>
          <target state="translated">u+b0000-u+bfffd</target>
        </trans-unit>
        <trans-unit id="cdba1c6047783563972c12317b4d72868b21fd76" translate="yes" xml:space="preserve">
          <source>U+C0000 - U+CFFFD</source>
          <target state="translated">u+c0000-u+cfffd</target>
        </trans-unit>
        <trans-unit id="010072229c529f3ca79fb579b3df7190d32934a1" translate="yes" xml:space="preserve">
          <source>U+D0000 - U+DFFFD</source>
          <target state="translated">u+d0000-u+dfffd</target>
        </trans-unit>
        <trans-unit id="ce5b442ae1391ac6f3397af8e6e2ed8bbfa37b7f" translate="yes" xml:space="preserve">
          <source>U+E0000 - U+EFFFD</source>
          <target state="translated">u+e0000-u+efffd</target>
        </trans-unit>
        <trans-unit id="520d6df0bba5aba46938723a37a68ea22f05a23c" translate="yes" xml:space="preserve">
          <source>U+F900 - U+FD3D</source>
          <target state="translated">u+f900-u+fd3d</target>
        </trans-unit>
        <trans-unit id="163422b76168f04b02797dee7a00db38f358ee53" translate="yes" xml:space="preserve">
          <source>U+FD40 - U+FDCF</source>
          <target state="translated">u+fd40-u+fdcf</target>
        </trans-unit>
        <trans-unit id="fb7bec8d977e924e7257c5655dae76a42823e7a8" translate="yes" xml:space="preserve">
          <source>U+FDF0 - U+FE44</source>
          <target state="translated">u+fdf0-u+fe44</target>
        </trans-unit>
        <trans-unit id="04089c7fc7f2ca3bf063171c8d318a9d6ea6bbde" translate="yes" xml:space="preserve">
          <source>U+FE20 - U+FE2F</source>
          <target state="translated">u+fe20-u+fe2f</target>
        </trans-unit>
        <trans-unit id="f56e67971694a5871856f55e8563ac4dbbcaec84" translate="yes" xml:space="preserve">
          <source>U+FE47 - U+FFFD</source>
          <target state="translated">u+fe47-u+fffd</target>
        </trans-unit>
        <trans-unit id="270912477818594d05da0936d300cdd48568315a" translate="yes" xml:space="preserve">
          <source>U&lt;code&gt;( { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} )&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;( { &lt;/code&gt; arg1、arg2、... &lt;code&gt;} )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="931d496adbd3f197940b61b27f25bcf6e5ce6062" translate="yes" xml:space="preserve">
          <source>UB</source>
          <target state="translated">UB</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UBと最適化</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="2cfb9dd16496ce85eff96d27557f7b42dd5f480d" translate="yes" xml:space="preserve">
          <source>UCS2</source>
          <target state="translated">UCS2</target>
        </trans-unit>
        <trans-unit id="cc245ae082a0221ea07ed3630dd9a406b15ac831" translate="yes" xml:space="preserve">
          <source>UCS2(Windows)</source>
          <target state="translated">UCS2(Windows)</target>
        </trans-unit>
        <trans-unit id="fb192521136df48247e2057851a45e670921483e" translate="yes" xml:space="preserve">
          <source>UDL</source>
          <target state="translated">UDL</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="469dc1d6169a7065a141b529a6260202a1c8ab1a" translate="yes" xml:space="preserve">
          <source>UNDERTIE - CHARACTER TIE</source>
          <target state="translated">アンダータイ-キャラクタータイ</target>
        </trans-unit>
        <trans-unit id="505551a88f566bb8fb83e0abedb58180312ddfab" translate="yes" xml:space="preserve">
          <source>URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</source>
          <target state="translated">URBGと分布は、乱数値を生成するために一緒に使用するように設計されています。すべての乱数エンジンは、再現性のあるシミュレータで使用するために、特別にシード、シリアライズ、デシリアライズされていてもかまいません。</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="2b2540046f34663d3e4a6d43e9cf9715c955300b" translate="yes" xml:space="preserve">
          <source>UTF-16 big-endian</source>
          <target state="translated">エヌエフティーエフディーエル</target>
        </trans-unit>
        <trans-unit id="3e0f2acffc4ed45f148e707196e35bf9de816b83" translate="yes" xml:space="preserve">
          <source>UTF-16 little-endian</source>
          <target state="translated">UTF-16リトルエンディアン</target>
        </trans-unit>
        <trans-unit id="9d90671c2d02729e29282121f3418c32309d8132" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>
        </trans-unit>
        <trans-unit id="627eba919968fb21d35e780ba4de3a0334bac3b5" translate="yes" xml:space="preserve">
          <source>UTF-32(non-Windows)</source>
          <target state="translated">UTF-32(non-Windows)</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="a2cdcc963eb83efa7c23e1cb852551ce54343476" translate="yes" xml:space="preserve">
          <source>UTF-8 (no effect on endianness)</source>
          <target state="translated">UTF-8(エンディアンに影響なし</target>
        </trans-unit>
        <trans-unit id="e6f9cf72db2d174ebd905a64df572642f988ef15" translate="yes" xml:space="preserve">
          <source>Unary &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;plus and minus&lt;/a&gt;</source>
          <target state="translated">単項&lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;プラスとマイナス&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">単項演算子</target>
        </trans-unit>
        <trans-unit id="3b2a4a75a6716bd612609078150c84a2711d8a91" translate="yes" xml:space="preserve">
          <source>UnaryTypeTrait</source>
          <target state="translated">UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="487d4ab7256ac0a9d6c0537cc67b1af3240a7a6a" translate="yes" xml:space="preserve">
          <source>Unblocks all threads currently waiting for &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; を現在待機しているすべてのスレッドのブロックを解除します。</target>
        </trans-unit>
        <trans-unit id="a36f6dfc5a6d8e565414aa5eb95d57c3673c1b95" translate="yes" xml:space="preserve">
          <source>Undefined Behavior</source>
          <target state="translated">未定義の行動</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">未定義の動作とフェルマーの最後の定理</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">未定義の動作</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">未定義の行動がタイムトラベルになることがある(中でもタイムトラベルが一番ファンキーだけど)。</target>
        </trans-unit>
        <trans-unit id="148339d92ffb0ef43ac5c644f243daf7596715dc" translate="yes" xml:space="preserve">
          <source>Under a</source>
          <target state="translated">の下で</target>
        </trans-unit>
        <trans-unit id="9b9209c5de57506f2fda8e822d2a3ad3f311f55e" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are permitted, but not required to omit the copy and move(since C++11) construction of class objects even if the copy/move(since C++11) constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. This is an optimization: even when it takes place and the copy/move(since C++11) constructor is not called, it still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed:</source>
          <target state="translated">以下の状況下では、copymove(from C++11)コンストラクタとデストラクタが観測可能な副作用を持つ場合でも、クラス・オブジェクトの copy と move(from C++11)の構築を省略することができますが、省略する必要はありません。オブジェクトは、そうでなければコピーされて移動されるストレージに直接構築されます。これは最適化です。最適化が行われ、copymove(from C++11)コンストラクタが呼び出されなかった場合でも、(最適化が全く行われなかったかのように)コンストラクタが存在し、アクセス可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3bea3f4316b2cc744d56328e836cf72a7190a46d" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually:</source>
          <target state="translated">以下のような状況では、たとえcopymoveコンストラクタやデストラクタが観測可能な副作用を持っていたとしても、コンパイラはクラスオブジェクトのコピーと移動の構築を省略する必要があります。オブジェクトは、そうでなければコピーされて移動されるであろうストレージに直接構築されます。言語ルールでは、概念的にもコピー移動操作が行われないことが保証されているため、コピー移動コンストラクタは存在する必要も、アクセス可能である必要もありません。</target>
        </trans-unit>
        <trans-unit id="9c33868b413394e75c10c66bbcac09ee4be1866f" translate="yes" xml:space="preserve">
          <source>Under these conditions, it can be shown that &lt;code&gt;e&lt;/code&gt; is an equivalence relation, and &lt;code&gt;r&lt;/code&gt; induces a strict total ordering on the equivalence classes determined by &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">これらの条件下で、 &lt;code&gt;e&lt;/code&gt; は同値関係であり、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;e&lt;/code&gt; によって決定される同値クラスに厳密な全順序を誘導することを示すことができます。</target>
        </trans-unit>
        <trans-unit id="b828bc3cb0b877121715201877f23784c033074d" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt;  erf(</source>
          <target state="translated">&lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt; 場合、アンダーフローが保証されます &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt; *（sqrt（&amp;pi;）/ 2） erf（</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">CC++で整数オーバーフローを理解する</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">評価されていない表現</target>
        </trans-unit>
        <trans-unit id="28df9f930dfb483b42b3b26d6ba0e60a90d200c5" translate="yes" xml:space="preserve">
          <source>Unformatted input</source>
          <target state="translated">フォーマットされていない入力</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">フォーマットされていない入出力</target>
        </trans-unit>
        <trans-unit id="b123c392cb4c8cf5311ee23670ea9ec4b71c524c" translate="yes" xml:space="preserve">
          <source>Unformatted output</source>
          <target state="translated">フォーマットされていない出力</target>
        </trans-unit>
        <trans-unit id="1103a0808298976db7d8e2eb535bd8a9ef0b0697" translate="yes" xml:space="preserve">
          <source>UnformattedInputFunction</source>
          <target state="translated">UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="57c86519dc947e7a7668db91684400955bbea92e" translate="yes" xml:space="preserve">
          <source>UnformattedOutputFunction</source>
          <target state="translated">UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="746515815dbd70aa366c5c8ded38ceac411af5b5" translate="yes" xml:space="preserve">
          <source>Unicode characters in identifiers</source>
          <target state="translated">識別子の Unicode 文字</target>
        </trans-unit>
        <trans-unit id="54c4cd3614eda1ec572a80ea2561789d6ec07f9a" translate="yes" xml:space="preserve">
          <source>Unicode conversion facilities</source>
          <target state="translated">ユニコード変換機能</target>
        </trans-unit>
        <trans-unit id="518945c57eea6f988b28705fe9a73ae61f28aad7" translate="yes" xml:space="preserve">
          <source>Unicode string literals</source>
          <target state="translated">ユニコード文字列リテラル</target>
        </trans-unit>
        <trans-unit id="1d88fe66c0582c456f5ec5c8716a0f875d9594aa" translate="yes" xml:space="preserve">
          <source>Uniform container erasure</source>
          <target state="translated">均一な容器の消去</target>
        </trans-unit>
        <trans-unit id="2d5f1d913211ede3bdf584eacf2d1f866d30dd39" translate="yes" xml:space="preserve">
          <source>Uniform distributions</source>
          <target state="translated">均一な分布</target>
        </trans-unit>
        <trans-unit id="ebaf278dff4a479e5c381e2d14da13ed28569d5b" translate="yes" xml:space="preserve">
          <source>Uniform random bit generator requirements</source>
          <target state="translated">均一なランダムビット発生器の要件</target>
        </trans-unit>
        <trans-unit id="43fc79a87964e43367c8f806ef4c1bc6c3c17e50" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators</source>
          <target state="translated">均一ランダムビット発生器</target>
        </trans-unit>
        <trans-unit id="304d61b117a4be33152a4987bccb311ec8786d3d" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available;</source>
          <target state="translated">一様乱数ビット生成器(URBG)は、一様分布を有する整数列を生成する擬似乱数発生器である乱数エンジンと、利用可能な場合には真の乱数発生器との両方を含む。</target>
        </trans-unit>
        <trans-unit id="9961b884b0d41e9f96e9b47f18701458382481af" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">均一なランダムビットジェネレーターは、乱数ジェネレーターとして使用するためのものではありません：ランダムビットのソースとして使用されます（効率のためにバルクで生成されます）。 乱数（正式には、ランダム変量）を取得するために、任意の一様ランダムビットジェネレーターを任意の&lt;a href=&quot;../numeric/random&quot;&gt;乱数分布&lt;/a&gt;にプラグインできます。</target>
        </trans-unit>
        <trans-unit id="274ada2867567ab3047cbbf8de81549c088960b3" translate="yes" xml:space="preserve">
          <source>UniformRandomBitGenerator</source>
          <target state="translated">UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">初期化されていないスカラー</target>
        </trans-unit>
        <trans-unit id="78a4eb44ac157ac9e3cfb278647cea168bf4035b" translate="yes" xml:space="preserve">
          <source>Uninitialized storage</source>
          <target state="translated">初期化されていないストレージ</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">ユニオン宣言</target>
        </trans-unit>
        <trans-unit id="8b963a92c98e754dacda8255ebe746d63728ca26" translate="yes" xml:space="preserve">
          <source>Union-like classes</source>
          <target state="translated">ユニオン的なクラス</target>
        </trans-unit>
        <trans-unit id="3c64374ae8a1f69718dd9c2a053e7f58d07b77ab" translate="yes" xml:space="preserve">
          <source>Union-like classes can be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged unions&lt;/a&gt;.</source>
          <target state="translated">ユニオンのようなクラスを使用して、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;タグ付きユニオン&lt;/a&gt;を実装できます。</target>
        </trans-unit>
        <trans-unit id="b88a7a2c81e25c95a2b907495a6fc73639f9b55f" translate="yes" xml:space="preserve">
          <source>Unions cannot contain a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy-assignment&lt;/a&gt; operator, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;).</source>
          <target state="translated">ユニオンには、自明ではない特別なメンバー関数（ &lt;a href=&quot;copy_constructor&quot;&gt;コピーコンストラクター&lt;/a&gt; 、 &lt;a href=&quot;as_operator&quot;&gt;コピー代入&lt;/a&gt;演算子、または&lt;a href=&quot;destructor&quot;&gt;デストラクター&lt;/a&gt; ）を持つ非静的データメンバーを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="bfa43e96dbedcb883a94acbaaea9cf15eba0504f" translate="yes" xml:space="preserve">
          <source>Unique integer for use as pword/iword index.</source>
          <target state="translated">pwordiwordインデックスとして使用するための一意の整数。</target>
        </trans-unit>
        <trans-unit id="d66a64b1da303d5c4d195ea302bf616e42aaa173" translate="yes" xml:space="preserve">
          <source>Unit type intended for use as a well-behaved empty alternative in &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. In particular, a variant of non-default-constructible types may list &lt;code&gt;std::monostate&lt;/code&gt; as its first alternative: this makes the variant itself default-constructible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; で適切に動作する空の代替として使用するためのユニットタイプ。 特に、非デフォルト構築可能型のバリアントは、 &lt;code&gt;std::monostate&lt;/code&gt; を最初の代替としてリストする場合があります。これにより、バリアント自体がデフォルト構築可能になります。</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">Unix および Unix ライクなシステム (Linux、Mac OS X)</target>
        </trans-unit>
        <trans-unit id="efec0246344a5eba097c63d394ab6c8738a45789" translate="yes" xml:space="preserve">
          <source>Unknown permissions (e.g. when &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; is created without permissions)</source>
          <target state="translated">不明な権限（例： &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt;が権限なしで作成された場合）</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">不明な専門分野</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="2103e6143f9ffb325540052fdb6e95f6374d7553" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt;がサポートされていて &lt;code&gt;OFF&lt;/code&gt; に設定されていない限り、すべての浮動小数点演算は、中間結果の範囲と精度が無限であるかのように実行できます。つまり、丸めエラーと浮動小数点例外を省略した最適化が許可されます。 たとえば、C ++では、単一の融合型積和演算CPU命令または &lt;code&gt;a = x*x*x*x;&lt;/code&gt; 最適化で &lt;code&gt;(x*y) + z&lt;/code&gt; を実装できます。 &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt; a = tmp * tmp 。</target>
        </trans-unit>
        <trans-unit id="07db20d2d23583077e6ea6e7dac4ed0dbdee1a6b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.</source>
          <target state="translated">&lt;code&gt;sync_with_stdio(false)&lt;/code&gt; が発行されていない限り、フォーマットされた入力とフォーマットされていない入力の両方について、複数のスレッドからこれらのオブジェクトに同時にアクセスしても安全です。</target>
        </trans-unit>
        <trans-unit id="24cf8fcc45f1c3c9991d569649560b6a524615c5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.</source>
          <target state="translated">&lt;code&gt;sync_with_stdio(false)&lt;/code&gt; が発行されていない限り、フォーマットされた出力とフォーマットされていない出力の両方について、複数のスレッドからこれらのオブジェクトに同時にアクセスしても安全です。</target>
        </trans-unit>
        <trans-unit id="ffb634a2a2ce0ccfeec2cc3fe27d921270b24978" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">範囲エラーが発生しない限り、 &lt;a href=&quot;../fenv/fe_round&quot;&gt;現在の丸めモード&lt;/a&gt;は無視されます</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">範囲エラーが発生しない限り、 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; は発生しません（結果は正確です）</target>
        </trans-unit>
        <trans-unit id="7a8fedd6b20728353d81d9da733470bcfcd14b54" translate="yes" xml:space="preserve">
          <source>Unless a variable template was &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialized&lt;/a&gt; or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is used.</source>
          <target state="translated">変数テンプレートが&lt;a href=&quot;template_specialization&quot;&gt;明示的に特殊&lt;/a&gt;化または明示的にインスタンス化されていない限り、変数テンプレートの特殊化が使用されると、暗黙的にインスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="73ad983fb74c97b086aa0802f13da903aa886831" translate="yes" xml:space="preserve">
          <source>Unless noted otherwise, every expression used in a</source>
          <target state="translated">特に断りのない限り</target>
        </trans-unit>
        <trans-unit id="0e8d48b8c7d263f43322d50666aca5a3f152bb21" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from:</source>
          <target state="translated">特に指定がない限り、移動されたすべての標準ライブラリオブジェクトは、有効ではあるが指定されていない状態に置かれます。つまり、代入演算子のような前提条件のない関数だけが、移動した後のオブジェクト上で安全に使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="50f2a51822d2bc1f7472ad730cc910af100ceb07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, hash of a variant does not typically equal the hash of the contained value; this makes it possible to distinguish &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; holding the same value as different alternatives.</source>
          <target state="translated">&lt;a href=&quot;../optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt;とは異なり、バリアントのハッシュは通常、含まれている値のハッシュと同じではありません。 これにより、異なる値として同じ値を保持する &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; を区別することができます。</target>
        </trans-unit>
        <trans-unit id="338f8ce75fb81cb04c2ab9cbb733a6def87c3d13" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, it can be used in multipass algorithms.</source>
          <target state="translated">&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;および&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;とは異なり、マルチパスアルゴリズムで使用できます。</target>
        </trans-unit>
        <trans-unit id="612a7e68b15f6d911dae610df0e6c53ee095c272" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt;や&lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;とは異なり、これらの関数は挿入が行われなくても右辺値の引数から移動しないため、値が &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; などの移動のみのタイプであるマップを簡単に操作できます。 unique_ptr &amp;lt;foo &amp;gt;&amp;gt; 。 さらに、 &lt;code&gt;try_emplace&lt;/code&gt; は、 map_typeのキーと引数を別々に&lt;a href=&quot;emplace&quot;&gt;扱います&lt;/a&gt; 。これは、 &lt;code&gt;value_type&lt;/code&gt; （つまり、 &lt;code&gt;std::pair&lt;/code&gt; ）を構築するために引数を必要とするemplaceとは異なります。</target>
        </trans-unit>
        <trans-unit id="6875db19fce8401ca9aebbb20205b26bb728d1fd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt;や&lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;とは異なり、これらの関数は挿入が行われなくても右辺値引数から移動しないため、値が &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; などの移動のみのタイプであるマップを簡単に操作できます。 unique_ptr &amp;lt;foo &amp;gt;&amp;gt; 。 さらに、 &lt;code&gt;try_emplace&lt;/code&gt; は、 map_typeのキーと引数を別々に&lt;a href=&quot;emplace&quot;&gt;扱います&lt;/a&gt; 。これは、 &lt;code&gt;value_type&lt;/code&gt; （つまり、 &lt;code&gt;std::pair&lt;/code&gt; ）を構築するために引数を必要とするemplaceとは異なります。</target>
        </trans-unit>
        <trans-unit id="2de29ed23c34ba831619b83b8554947943971200" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; and string literals, &lt;code&gt;data()&lt;/code&gt; may return a pointer to a buffer that is not null-terminated. Therefore it is typically a mistake to pass &lt;code&gt;data()&lt;/code&gt; to a routine that takes just a &lt;code&gt;const CharT*&lt;/code&gt; and expects a null-terminated string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; や文字列リテラルとは異なり、 &lt;code&gt;data()&lt;/code&gt; はnullで終了していないバッファーへのポインターを返す場合があります。 したがって、 &lt;code&gt;const CharT*&lt;/code&gt; のみを受け取り、nullで終了する文字列を予期するルーチンに &lt;code&gt;data()&lt;/code&gt; を渡すのは、通常、誤りです。</target>
        </trans-unit>
        <trans-unit id="b42b73288e226f5ad79616019df229c7343f10e7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; has undefined behavior instead of returning &lt;code&gt;CharT()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; は &lt;code&gt;CharT()&lt;/code&gt; を返す代わりに未定義の動作をします。</target>
        </trans-unit>
        <trans-unit id="82cf3dbf0c22a41175cd7995812ae5e616d63672" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt;, this function does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt; とは異なり、この関数は静的ストレージを更新しません。ユーザーが指定した場所にパーサーの状態を保存します。</target>
        </trans-unit>
        <trans-unit id="4887cd4b1d808c0fb500939d898308b30c68c620" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::ranges::greater&lt;/code&gt; は、6つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;==&lt;/code&gt; および &lt;code&gt;!=&lt;/code&gt; がすべて有効であること（ &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;制約を介して）を必要とし、 &lt;code&gt;std::ranges::less&lt;/code&gt; に関して完全に定義されます:: ranges :: less 。 ただし、これらの概念では比較演算子の結果が一貫している必要があるため、実装では &lt;code&gt;operator&amp;gt;&lt;/code&gt; を直接自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="76b2faafc9a3dbd22464e63c0ec0383467b9c99f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; は、6つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;==&lt;/code&gt; および &lt;code&gt;!=&lt;/code&gt; が（ &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;制約を介して）有効である必要があり、 &lt;code&gt;std::ranges::less&lt;/code&gt; に関して完全に定義されます:: ranges :: less 。 ただし、これらの概念では比較演算子の結果が一貫している必要があるため、実装では &lt;code&gt;operator&amp;gt;=&lt;/code&gt; を直接自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="78dbcad5e4fbe558a33518be37657107f091659c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::ranges::less_equal&lt;/code&gt; では、6つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;==&lt;/code&gt; および &lt;code&gt;!=&lt;/code&gt; が（ &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;制約を介して）有効であり、完全に &lt;code&gt;std::ranges::less&lt;/code&gt; 定義されている必要があります:: ranges :: less 。 ただし、これらの概念では比較演算子の結果が一貫している必要があるため、実装では &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 直接自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="98c9c16f2e98cd689703db22c46385c7c82dbbfc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt;, this operator never inserts a new element into the container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt; とは異なり、この演算子はコンテナに新しい要素を挿入しません。</target>
        </trans-unit>
        <trans-unit id="83c22ec940642abd3fc1b2b3f91bda4fefd9187c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requires both &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt; constraint), and is entirely defined in terms of &lt;code&gt;std::ranges::equal_to&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator!=&lt;/code&gt; directly, because those concepts require the results of &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be consistent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; は &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; の両方が（ &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt;制約を介して）有効であることを必要とし、完全に &lt;code&gt;std::ranges::equal_to&lt;/code&gt; で定義されます。 ただし、これらの概念では &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; の結果が一致している必要があるため、実装では &lt;code&gt;operator!=&lt;/code&gt; を直接自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="a93ac31e396db5acf4776ae92718a031c6e2a35d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (which has &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;std::make_unique&lt;/code&gt; does not have an allocator-aware counterpart. A hypothetical &lt;code&gt;allocate_unique&lt;/code&gt; would be required to invent the deleter type &lt;code&gt;D&lt;/code&gt; for the &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; it returns which would contain an allocator object and invoke both &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; in its &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; ）とは異なり、 &lt;code&gt;std::make_unique&lt;/code&gt; はアロケーター対応のカウンターパートがありません。 アロケータオブジェクトを含み、その &lt;code&gt;operator()&lt;/code&gt; で &lt;code&gt;destroy&lt;/code&gt; とdeallocateの両方を呼び出す、それが返す &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; の削除タイプ &lt;code&gt;D&lt;/code&gt; を作成するには、仮想の &lt;code&gt;allocate_unique&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="bfa95d30700702ce194a65101a9f73a0be8c3e37" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the deleter of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is invoked even if the managed pointer is null.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; とは異なり、管理対象ポインタがnullであっても &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 削除機能が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bcc84ea13a79573b43e6585e6b696a907d0811f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;, this manipulator does not flush the stream.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; とは異なり、このマニピュレータはストリームをフラッシュしません。</target>
        </trans-unit>
        <trans-unit id="efa45df35e365dacc26b0c10d8f1d5381eb5b951" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, performs a bounds check and throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position in the bitset.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;pos&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; の有効な位置に対応していない場合、境界チェックを実行し、 std :: out_of_rangeをスローします。</target>
        </trans-unit>
        <trans-unit id="f987fe2de50e7bdc36ad5bea121ee3e9648279c4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;erase&lt;/code&gt; は異種のタイプを受け入れ、 &lt;code&gt;==&lt;/code&gt; 演算子を呼び出す前にコンテナーの値タイプへの変換を強制しません。</target>
        </trans-unit>
        <trans-unit id="173b793fffeab067a076675a0bbf0ba3c09de869" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;erase&lt;/code&gt; は異種のタイプを受け入れ、 &lt;code&gt;==&lt;/code&gt; 演算子を呼び出す前にコンテナーの値タイプへの変換を強制しません。</target>
        </trans-unit>
        <trans-unit id="4c977d4a7c4e43375bfbd8db6568cbdff01d3089" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;std::unique_ptr&lt;/code&gt; は&lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;を満たす任意のカスタムハンドルタイプを通じてオブジェクトを管理できます。 これにより、たとえば、 &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; を定義する &lt;code&gt;Deleter&lt;/code&gt; を提供することで、共有メモリにあるオブジェクトを管理できます。 または別の&lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;派手なポインタ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1573c755f58e9c4746c81740477c0b3b24dac236" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt;, does not throw exceptions: the behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is out of bounds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt; とは異なり、例外をスローしません &lt;code&gt;pos&lt;/code&gt; が範囲外の場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="6eba30f9f21127f9176b2a660cfad2f04c8b9efb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;static_cast&lt;/code&gt;, but like &lt;code&gt;const_cast&lt;/code&gt;, the &lt;code&gt;reinterpret_cast&lt;/code&gt; expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type.</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; とは異なり、 const_castと同様に 、 &lt;code&gt;const_cast&lt;/code&gt; 式はCPU命令にコンパイルされません（整数とポインターの間で変換する場合、またはポインターの表現がその型に依存する不明瞭なアーキテクチャーを除く）。 これは純粋にコンパイル時のディレクティブであり、new_type型であるかのように式を処理するようコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="f39585865906a9f2075869fd7919be30089c3370" translate="yes" xml:space="preserve">
          <source>Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.</source>
          <target state="translated">ルールオブスリーとは異なり、移動コンストラクタと移動の割り当てを提供しないことは、通常、エラーではなく最適化の機会を逃したことになります。</target>
        </trans-unit>
        <trans-unit id="57237dac9eb413318550844e3881a717ec402781" translate="yes" xml:space="preserve">
          <source>Unlike explicit constructors, which are only considered during &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; (which includes &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; such as &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;), converting constructors are also considered during &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt;, as part of &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;中にのみ考慮される明示的なコンストラクター（ &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;などの&lt;a href=&quot;explicit_cast&quot;&gt;明示的な変換&lt;/a&gt;を含む）とは異なり 、変換コンストラクターは、 &lt;a href=&quot;implicit_cast&quot;&gt;ユーザー定義の変換シーケンスの&lt;/a&gt;一部として、 &lt;a href=&quot;copy_initialization&quot;&gt;コピーの初期化&lt;/a&gt;中にも考慮されます 。</target>
        </trans-unit>
        <trans-unit id="0519031d106f159f57ffffbcb3c189318dbf95d8" translate="yes" xml:space="preserve">
          <source>Unlike for &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt;, the C++ standard does not explicitly require that &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; is unchanged by this function, but existing implementations do not change capacity. This means that they do not release the allocated memory (see also &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt; とは異なり、C ++標準では、 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; がこの関数によって変更されていないことを明示的に要求していませんが、既存の実装では容量は変更されません。 つまり、割り当てられたメモリを解放しません（ &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt; も参照 ）。</target>
        </trans-unit>
        <trans-unit id="005bffdc5ce748f5fa7ecab037e6b4ba23fd3f4c" translate="yes" xml:space="preserve">
          <source>Unlike formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; if the output fails.</source>
          <target state="translated">フォーマットされた出力関数とは異なり、この関数は出力が失敗した場合に &lt;code&gt;failbit&lt;/code&gt; を設定しません。</target>
        </trans-unit>
        <trans-unit id="c11ef1e4f5cbd932283bfef60dfc1f2ad7da6484" translate="yes" xml:space="preserve">
          <source>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.</source>
          <target state="translated">関数や関数への参照とは異なり、関数へのポインタはオブジェクトであるため、配列に格納したり、コピーしたり、代入したりすることができます。</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">ヘッダーガードとは異なり、このプラグマは、複数のファイルで同じマクロ名を誤って使用することを不可能にします。 一方、 &lt;code&gt;#pragma once&lt;/code&gt; では、ファイルシステムレベルのIDに基づいてファイルが除外されるため、プロジェクト内の複数の場所にヘッダーが存在する場合、ヘッダーが2回含まれないようにすることはできません。</target>
        </trans-unit>
        <trans-unit id="ee79da911cfc98f59e02246e9625087f966f6ee4" translate="yes" xml:space="preserve">
          <source>Unlike many related functions, this function is</source>
          <target state="translated">多くの関連関数とは異なり、この関数は</target>
        </trans-unit>
        <trans-unit id="c7ea1f99bf46737fd3a9eb5569bcdb5f3547a949" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operator for &lt;code&gt;atomic_ref&lt;/code&gt; does not return a reference to its left-hand argument. It returns a copy of the stored value instead.</source>
          <target state="translated">ほとんどの代入演算子とは異なり、 &lt;code&gt;atomic_ref&lt;/code&gt; の代入演算子は、左側の引数への参照を返しません。 代わりに、格納された値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="1a4db73f4f2b5f3d23685150e26ab0e326ffc436" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">ほとんどの代入演算子とは異なり、アトミック型の代入演算子は左辺の引数への参照を返しません。代わりに保存されている値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="3697fcced78a8dc2e1dd58511d1675942ea9902d" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">ほとんどの複合代入演算子とは異なり、 &lt;code&gt;atomic_ref&lt;/code&gt; の複合代入演算子は、左側の引数への参照を返しません。 代わりに、格納された値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="139203564aef61dc9e502ac41ea33308504a0622" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">ほとんどの複合代入演算子とは異なり、アトミック型の複合代入演算子は左手引数への参照を返しません。代わりに格納されている値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="dda22864e1900bb6a87e878513e661e3ee5d8ee4" translate="yes" xml:space="preserve">
          <source>Unlike most mathematical operations, the conversion of a floating-point value to text and back is</source>
          <target state="translated">ほとんどの数学演算とは異なり、浮動小数点値のテキストへの変換は</target>
        </trans-unit>
        <trans-unit id="76a29065db67fecaafea29ca64388623baf0bcbc" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;std::wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">他のほとんどの &lt;code&gt;std::wcstok&lt;/code&gt; とは異なり、 std :: wcstokの区切り文字は後続のトークンごとに異なる場合があり、前のトークンの内容に依存することさえあります。</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">他のほとんどのトークナイザーとは異なり、 &lt;code&gt;strtok&lt;/code&gt; の区切り文字は後続のトークンごとに異なる場合があり、前のトークンの内容に依存することさえあります。</target>
        </trans-unit>
        <trans-unit id="e499b26c05a23f391924b25bade94974b21959a1" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">ほとんどのプリインクリメント演算子およびプリデクリメント演算子とは異なり、 &lt;code&gt;atomic_ref&lt;/code&gt; のプリインクリメント演算子およびプリデクリメント演算子は、変更されたオブジェクトへの参照を返しません。 代わりに、格納された値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="247d65607595333e4901228f7023c088dbe9e552" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">多くのプリインクリメントおよびプリデクリメント演算子とは異なり、アトミック型のプリインクリメントおよびプリデクリメント演算子は、変更されたオブジェクトへの参照を返しません。代わりに保存されている値のコピーを返します。</target>
        </trans-unit>
        <trans-unit id="536f52cdb9582b6792ddf498c21f83ff3bc9d9a5" translate="yes" xml:space="preserve">
          <source>Unlike other formatting functions in C++ and C libraries, &lt;code&gt;std::to_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of formatting policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">C ++およびCライブラリの他のフォーマット関数とは異なり、 &lt;code&gt;std::to_chars&lt;/code&gt; はロケールに依存せず、割り当てもスローもされません。 他のライブラリ（ &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt; など）で使用されるフォーマットポリシーの小さなサブセットのみが提供されます。 これは、テキストベースの交換（JSONまたはXML）などの一般的なハイスループットコンテキストで役立つ、可能な限り最速の実装を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="960cf91e24a03ae762e9fec6a351793c82e6e03d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;begin()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">&lt;code&gt;std::valarray&lt;/code&gt; 引数を取る他の関数とは異なり、 &lt;code&gt;begin()&lt;/code&gt; は、valarraysを含む式から返される可能性がある置換型（式テンプレートによって生成される型など）を受け入れることができません。std &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; は移植できません、 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; を代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="07020cc0a6112afa1a94ca2a985fb8992ea81c5d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;end()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">&lt;code&gt;std::valarray&lt;/code&gt; 引数を取る他の関数とは異なり、 &lt;code&gt;end()&lt;/code&gt; は、valarrayを含む式から返される可能性のある置換型（式テンプレートによって生成される型など）を受け入れることができません。std &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; は移植できません、 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; を代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="82b08c1bafac008cc3356484b3bea8b8da199f4c" translate="yes" xml:space="preserve">
          <source>Unlike other parsing functions in C++ and C libraries, &lt;code&gt;std::from_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">C ++およびCライブラリの他の解析関数とは異なり、 &lt;code&gt;std::from_chars&lt;/code&gt; はロケールに依存せず、割り当てもスローもされません。 他のライブラリ（ &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt; など）で使用される解析ポリシーの小さなサブセットのみが提供されます。 これは、テキストベースの交換（JSONまたはXML）などの一般的なハイスループットコンテキストで役立つ、可能な限り最速の実装を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="bc22867a4de3145dca568d4e66ffa742bf46b614" translate="yes" xml:space="preserve">
          <source>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</source>
          <target state="translated">例外オブジェクトは他の一時的なオブジェクトとは異なり、キャッチ節のパラメータを初期化する際にlvalueの引数とみなされるため、lvalue参照でキャッチし、修正し、リスローすることができます。</target>
        </trans-unit>
        <trans-unit id="40e4049da792f251c064108725448595e7fb81c8" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; named requirement, &lt;code&gt;std::Destructible&lt;/code&gt; requires the destructor to be &lt;code&gt;noexcept(true)&lt;/code&gt;, not merely non-throwing when invoked, and allows reference types and array types.</source>
          <target state="translated">名前付きの&lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;要件とは異なり、 &lt;code&gt;std::Destructible&lt;/code&gt; は、呼び出されたときに単にスローされないだけでなく、デストラクタが &lt;code&gt;noexcept(true)&lt;/code&gt; である必要があり、参照型と配列型を許可します。</target>
        </trans-unit>
        <trans-unit id="f2ff26def44fad2ae044095e7f187e2f9c03b39d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; constructors, &lt;code&gt;std::make_shared&lt;/code&gt; does not allow a custom deleter.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; コンストラクターとは異なり、 &lt;code&gt;std::make_shared&lt;/code&gt; ではカスタム削除機能を使用できません。</target>
        </trans-unit>
        <trans-unit id="1c6f8d4294a5e322f2430ee23bff35686e775144" translate="yes" xml:space="preserve">
          <source>Unlike the primary template &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, this specialization does not perform a virtual function call when classifying characters. To customize the behavior, a derived class may provide a non-default classification table to the base class constructor.</source>
          <target state="translated">基本テンプレート &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; とは異なり、この特殊化は文字を分類するときに仮想関数呼び出しを実行しません。 動作をカスタマイズするために、派生クラスは、デフォルト以外の分類テーブルを基本クラスコンストラクターに提供できます。</target>
        </trans-unit>
        <trans-unit id="3a3c250893800a21b88186ef185aadaf831d7992" translate="yes" xml:space="preserve">
          <source>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</source>
          <target state="translated">プロモーションとは異なり、数値変換では、精度が損なわれる可能性があり、値が変化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cf90c59183d16b061b44fcdd59d790f2d00de63" translate="yes" xml:space="preserve">
          <source>Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</source>
          <target state="translated">他のアルゴリズムとは異なり、for_eachは、シーケンス内の要素のコピーが可能であっても、そのコピーを行うことはできません。</target>
        </trans-unit>
        <trans-unit id="db1ac6c9a5b777adb044dcf5cc2c8e1d9362ebb5" translate="yes" xml:space="preserve">
          <source>Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the &lt;code&gt;T&lt;/code&gt; object, and for deallocation of their shared memory block.</source>
          <target state="translated">std :: shared_ptrコンストラクターとは異なり、std :: allocate_sharedは個別のカスタム削除を受け入れません。提供されたアロケーターは、制御ブロックと &lt;code&gt;T&lt;/code&gt; オブジェクトの破棄、およびそれらの共有メモリブロックの割り当て解除に使用されます。</target>
        </trans-unit>
        <trans-unit id="66abfa107dcdc9f5699b86a1259047a6420b2c52" translate="yes" xml:space="preserve">
          <source>Unlike type template parameter declaration, template template parameter declaration can only use the keyword &lt;code&gt;class&lt;/code&gt; and not &lt;code&gt;typename&lt;/code&gt;.</source>
          <target state="translated">タイプテンプレートパラメータ宣言とは異なり、テンプレートテンプレートパラメータ宣言では &lt;code&gt;typename&lt;/code&gt; ではなくキーワード &lt;code&gt;class&lt;/code&gt; のみを使用できます。</target>
        </trans-unit>
        <trans-unit id="d675911d340ea7fe2bddf254d2a266f734dde906" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt;, additional directory separators are never introduced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt; とは異なり、追加のディレクトリセパレータは導入されません。</target>
        </trans-unit>
        <trans-unit id="9795510ddaf8f7b584f9cfa5390b07d1db4d7240" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex and releases ownership.</source>
          <target state="translated">関連するミューテックスのロックを解除し、所有権を解放します。</target>
        </trans-unit>
        <trans-unit id="f433ee5a4f5ef551015f8cbf8189774e6d42e0da" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex from shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;.</source>
          <target state="translated">関連するミューテックスを共有モードからロック解除します。 効果的に &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="961e1771431741648b7410afa7f25aec8f8bb6ba" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex if its level of ownership is &lt;code&gt;1&lt;/code&gt; (there was exactly one more call to &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; than there were calls to &lt;code&gt;unlock()&lt;/code&gt; made by this thread), reduces the level of ownership by 1 otherwise.</source>
          <target state="translated">所有権のレベルが &lt;code&gt;1&lt;/code&gt; の場合 （このスレッドによって行われた &lt;code&gt;unlock()&lt;/code&gt; の呼び出しよりも1つ多い &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; の呼び出しがあった場合）、ミューテックスのロックを解除し、それ以外の場合は所有権のレベルを1減らします。</target>
        </trans-unit>
        <trans-unit id="3292cba2e9fa684816c3433f5e680ff1211985aa" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex.</source>
          <target state="translated">ミューテックスのロックを解除します。</target>
        </trans-unit>
        <trans-unit id="e5ecb1ac5a3284b964b98f95170550776c6f7221" translate="yes" xml:space="preserve">
          <source>Unnamed functions can be generated by &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;.</source>
          <target state="translated">名前のない関数は、 &lt;a href=&quot;lambda&quot;&gt;ラムダ式で&lt;/a&gt;生成できます。</target>
        </trans-unit>
        <trans-unit id="f4abed0ca00f10480f822ed4f5c54c15d912133a" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces</source>
          <target state="translated">名前のない名前空間</target>
        </trans-unit>
        <trans-unit id="ce07e4c5885039551bddbc7d0f27189dfc040aaa" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;, which means that any name that is declared within an unnamed namespace has internal linkage.</source>
          <target state="translated">名前のない名前空間と、名前のない名前空間内で直接または間接的に宣言されたすべての名前空間には&lt;a href=&quot;storage_duration#Linkage&quot;&gt;内部リンケージ&lt;/a&gt;があります。つまり、名前のない名前空間内で宣言された名前には内部リンケージがあります。</target>
        </trans-unit>
        <trans-unit id="55c746743e689c2f62e5b9408423fdd2d1439715" translate="yes" xml:space="preserve">
          <source>Unordered associative containers</source>
          <target state="translated">順序のない連想コンテナ</target>
        </trans-unit>
        <trans-unit id="67512286f8974c10c046fc1f0f6675019780544f" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are &lt;a href=&quot;container&quot;&gt;Containers&lt;/a&gt; that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</source>
          <target state="translated">順不同の連想コンテナは、キーに基づいてオブジェクトの高速ルックアップを提供する&lt;a href=&quot;container&quot;&gt;コンテナ&lt;/a&gt;です。 最悪の場合の複雑さは線形ですが、ほとんどの操作で平均してはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="5721c8ff7733bb174444b2a6b021b024c56a1897" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are parametrized by &lt;code&gt;Key&lt;/code&gt;; &lt;code&gt;Hash&lt;/code&gt;, a &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; function object which acts as hash function on &lt;code&gt;Key&lt;/code&gt;; and &lt;code&gt;Pred&lt;/code&gt;, a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; evaluating equivalence between &lt;code&gt;Key&lt;/code&gt;s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; also have a mapped type &lt;code&gt;T&lt;/code&gt; associated with the &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">順不同の連想コンテナは &lt;code&gt;Key&lt;/code&gt; によってパラメータ化されます。 &lt;code&gt;Hash&lt;/code&gt; は、 &lt;code&gt;Key&lt;/code&gt; のハッシュ関数として機能する&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;関数オブジェクトです。 &lt;code&gt;Pred&lt;/code&gt; は、 &lt;code&gt;Key&lt;/code&gt; 間の同等性を評価する&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;です。 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; も、 &lt;code&gt;Key&lt;/code&gt; に関連付けられたマップタイプ &lt;code&gt;T&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="27d0b13503ae28a6d2a746765f82094c67a9edd8" translate="yes" xml:space="preserve">
          <source>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).</source>
          <target state="translated">順序のない連想コンテナは、ソートされていない(ハッシュ化されていない)データ構造を実装しており、素早く検索することができます(O(1)償却、O(n)ワーストケースの複雑さ)。</target>
        </trans-unit>
        <trans-unit id="b3e4ddc4a7977312b5ea810e7307eb4d25f9ced4" translate="yes" xml:space="preserve">
          <source>Unordered associative containers in the standard library</source>
          <target state="translated">標準ライブラリの非順序連想コンテナ</target>
        </trans-unit>
        <trans-unit id="9cbf323cb4f143925595576784d5b591b9699888" translate="yes" xml:space="preserve">
          <source>Unordered associative containers meet the requirements of &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the requirements of &lt;code&gt;value_type&lt;/code&gt; in &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; apply to &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; (not to &lt;code&gt;value_type&lt;/code&gt;).</source>
          <target state="translated">順不同の連想コンテナは、 &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;の要件を満たします。 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;value_type&lt;/code&gt; の要件はkey_typeとmapped_typeに適用されます（ value_typeには適用されません）。</target>
        </trans-unit>
        <trans-unit id="c05e882164dc6c352b2a91db5033a7f29679961d" translate="yes" xml:space="preserve">
          <source>Unordered dynamic initialization</source>
          <target state="translated">順序のない動的初期化</target>
        </trans-unit>
        <trans-unit id="6f584009e4c537a97fa6a23c2a4e0d998b8f9266" translate="yes" xml:space="preserve">
          <source>Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.</source>
          <target state="translated">無順序マップは、一意のキーを持つキーと値のペアを含む連想コンテナです。要素の検索、挿入、削除は平均的な一定時間の複雑さを持ちます。</target>
        </trans-unit>
        <trans-unit id="a040e6bfa2ff6a84c4d4e54ec666b82a142217ba" translate="yes" xml:space="preserve">
          <source>Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">unordered multimap は、等価なキー(unordered_multimap は各キー値の複数のコピーを含むことができます)をサポートし、別の型の値をキーに関連付けることができる無秩序な連想コンテナです。unordered_multimap クラスは順方向イテレータをサポートしています。検索、挿入、削除は平均的な一定時間の複雑さを持ちます。</target>
        </trans-unit>
        <trans-unit id="781e73a9d10b79ea8423bbe4c282e042b203ed02" translate="yes" xml:space="preserve">
          <source>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">順序のないマルチセットは、Key型のユニークでない可能性のあるオブジェクトの集合を含む連想コンテナです。検索、挿入、削除は平均的な一定時間の複雑さを持ちます。</target>
        </trans-unit>
        <trans-unit id="6c35c1e1852ab51c8cfda8139fbce10f60da69d7" translate="yes" xml:space="preserve">
          <source>Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">非順序化集合は、Key型のユニークなオブジェクトの集合を含む連想コンテナです。検索、挿入、削除は平均的な一定時間の複雑さを持ちます。</target>
        </trans-unit>
        <trans-unit id="20ec84b0a684780da8ecd14376ab54e3d64c049a" translate="yes" xml:space="preserve">
          <source>UnorderedAssociativeContainer</source>
          <target state="translated">UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="5ed38d76cf76e990be50933f309543cd72253e57" translate="yes" xml:space="preserve">
          <source>Unqualified and qualified name lookup rules for class members are detailed in &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">クラスメンバーの非修飾名および修飾名の検索ルールについては、 &lt;a href=&quot;lookup&quot;&gt;名前検索で&lt;/a&gt;詳しく説明しています 。</target>
        </trans-unit>
        <trans-unit id="a712c79b38b9542c96589abf3e1dda8d1042e2a4" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;abs&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;std::abs&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;abs&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;std::abs&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="fc119a198d533d4b0bbb7710d68460cff957292e" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;acos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;acos&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="f215557e10fbc19791a7df65c388833c1a7dd11c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;asin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;asin&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="9f3c5a7de17deb7da848c19ab6e3fce9f64dca13" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan2&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;atan2&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="fa3a701b0983c693521c1ddd5947f77acceaace8" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;atan&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="39d51e27856339476f1d01bf7073fed7dc2b3dbb" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;cos&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="dbf3b6db25b09f0814d7e5a7fef391df5875da2a" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cosh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;cosh&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="e8abb5dd0c771afacf6766178d00da2ba065a2ec" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;exp&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;exp&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="dd8575417503ea5be7c9d78fb49d54a74a502a5c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log10&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;log10&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="42fd42135c1c4e85d3b6e8229754e9d9e009486f" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;log&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="a8f42595543cd910c448cec8e9b024326f375da5" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;pow&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;pow&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="0b45579c9b454c00347186dba4b670a1612acd28" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;sin&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数依存のルックアップのために &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="609a5411e92bb2e442b9695a0c7f1a35b0bcda38" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sinh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;sinh&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="c0b2457b178abb1fbcd11ec0b12722a8184da253" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sqrt&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;sqrt&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="fa91ca5ff514fc595bf3f51f24fdd9e313d69b9c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;tan&lt;/code&gt; ）は、計算を実行するために使用されます。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="d2d13c70f9b62f9ac241cafdef0b167740b73e83" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tanh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非修飾関数（ &lt;code&gt;tanh&lt;/code&gt; ）を使用して計算を実行します。 そのような関数が利用できない場合、引数に依存するルックアップのために &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="5e538cf96d743b1733d4cf064e3d13d77d3aa646" translate="yes" xml:space="preserve">
          <source>Unqualified identifiers</source>
          <target state="translated">非限定的な識別子</target>
        </trans-unit>
        <trans-unit id="30683cf405f082292810a7676e96130ea1ebbac6" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup</source>
          <target state="translated">非修飾名検索</target>
        </trans-unit>
        <trans-unit id="42e9848a70274fa4e3ee76d98636ebc5974dc7bd" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup of the name used to the left of the function-call operator (and, equivalently, operator in an expression) is described in &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">関数呼び出し演算子（および同等の式の演算子）の左側に使用される名前の非修飾名ルックアップは、 &lt;a href=&quot;adl&quot;&gt;引数依存ルックアップで&lt;/a&gt;説明されています 。</target>
        </trans-unit>
        <trans-unit id="79648146553ba52f72840dfe58fd2d9c089e5fda" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup that finds static members of &lt;code&gt;B&lt;/code&gt;, nested types of &lt;code&gt;B&lt;/code&gt;, and enumerators declared in &lt;code&gt;B&lt;/code&gt; is unambiguous even if there are multiple non-virtual base subobjects of type &lt;code&gt;B&lt;/code&gt; in the inheritance tree of the class being examined:</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; の静的メンバー、 Bのネストされたタイプ、および &lt;code&gt;B&lt;/code&gt; で宣言された列挙子を検出する非修飾名のルックアップは、検査対象のクラスの継承ツリーにタイプ &lt;code&gt;B&lt;/code&gt; の非仮想ベースサブオブジェクトが複数ある場合でも明確です。</target>
        </trans-unit>
        <trans-unit id="f0214ce4cc35b4369eeab0b471b29274746a99bb" translate="yes" xml:space="preserve">
          <source>Unregisters a range earlier registered with &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt; 以前に登録された範囲の登録を解除します。</target>
        </trans-unit>
        <trans-unit id="866d0de5757a1581405e841976c7443463cb9f92" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">縮小とは無関係に、浮動小数点演算の中間結果は、その型で示されるものとは異なる範囲と精度を持つ場合があります &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="c38c9bea005b30ba6a290df566acf1664518f308" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration</source>
          <target state="translated">アンスコープ付き列挙</target>
        </trans-unit>
        <trans-unit id="6222e920759d4ffc44da225d807dad755988a0aa" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration type</source>
          <target state="translated">アンスコープされていない列挙型</target>
        </trans-unit>
        <trans-unit id="326065904fc6d55f14165c03f41503850d0a81df" translate="yes" xml:space="preserve">
          <source>Unsequenced execution policies are the only case where function calls are</source>
          <target state="translated">続かない実行ポリシーは、関数呼び出しが</target>
        </trans-unit>
        <trans-unit id="001f5aa9e95578bdbf624cdd233afcd23b9e1b0b" translate="yes" xml:space="preserve">
          <source>Unsets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">flagsで識別されるフォーマットフラグの設定を解除します。</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">符号なし整数演算は常にモジュロ2nで実行されます。</target>
        </trans-unit>
        <trans-unit id="73db4e2949bacc582e416479a510daae92386ab7" translate="yes" xml:space="preserve">
          <source>Unsigned integer of at least 32 bits</source>
          <target state="translated">32ビット以上の符号なし整数</target>
        </trans-unit>
        <trans-unit id="4e7bbf9fbab3d07bb38581701f9d99705350278e" translate="yes" xml:space="preserve">
          <source>Unsigned integer type (usually &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">符号なし整数型（通常は &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">符号なし整数:最大値</target>
        </trans-unit>
        <trans-unit id="6fe5f2a61d9b8437ce58885d4aebe34e13639a40" translate="yes" xml:space="preserve">
          <source>UnsignedIntegral</source>
          <target state="translated">UnsignedIntegral</target>
        </trans-unit>
        <trans-unit id="5097984a5f9238c911d1b186817d23c6f3bcfe68" translate="yes" xml:space="preserve">
          <source>Unspecified order</source>
          <target state="translated">指定されていない順序</target>
        </trans-unit>
        <trans-unit id="d37821663cc5797b1388ccb9821c1c66f6dc7be6" translate="yes" xml:space="preserve">
          <source>Unspecified.</source>
          <target state="translated">Unspecified.</target>
        </trans-unit>
        <trans-unit id="42bff37b51ec7b1fccab4a5d361519fa088bb006" translate="yes" xml:space="preserve">
          <source>Unsupported C headers</source>
          <target state="translated">サポートされていない C ヘッダ</target>
        </trans-unit>
        <trans-unit id="3910cc8152231b6ede905978fe57cac1a0d03d97" translate="yes" xml:space="preserve">
          <source>Until &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (a C++14 defect), unused parameters in &lt;a href=&quot;../language/type_alias&quot;&gt;alias templates&lt;/a&gt; were not guaranteed to ensure SFINAE and could be ignored, so earlier compilers require a more complex definition of &lt;code&gt;void_t&lt;/code&gt;, such as.</source>
          <target state="translated">&lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; （C ++ 14の欠陥）までは、 &lt;a href=&quot;../language/type_alias&quot;&gt;エイリアステンプレートの&lt;/a&gt;未使用のパラメーターはSFINAEを保証することが保証されておらず、無視される可能性があったため、以前のコンパイラーはなどのより複雑な &lt;code&gt;void_t&lt;/code&gt; の定義を必要とします。</target>
        </trans-unit>
        <trans-unit id="f7718ae633302ee609828ca76d3c8d3d51cfea89" translate="yes" xml:space="preserve">
          <source>Until C++11, &lt;code&gt;auto&lt;/code&gt; had the semantic of a &lt;a href=&quot;storage_duration&quot;&gt;storage duration specifier&lt;/a&gt;.</source>
          <target state="translated">C ++ 11までは、 &lt;code&gt;auto&lt;/code&gt; には&lt;a href=&quot;storage_duration&quot;&gt;ストレージ期間指定子の&lt;/a&gt;セマンティクスがありました。</target>
        </trans-unit>
        <trans-unit id="965548c423c2af9ebf773d28ec036a9f63c4b83f" translate="yes" xml:space="preserve">
          <source>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</source>
          <target state="translated">C++11 までは、構文の制限により、コンストラクタの初期化リストで集約初期化を使用できませんでした。</target>
        </trans-unit>
        <trans-unit id="9f555151d6b7d5f7a9ff7843af6a57a54b0a5819" translate="yes" xml:space="preserve">
          <source>Until C++11, classes that overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; were not CopyConstructible and thus weren't usable in the standard library containers. As of C++11, the standard library uses &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; whenever the address of an object is needed.</source>
          <target state="translated">C ++ 11までは、 &lt;code&gt;operator&amp;amp;&lt;/code&gt; をオーバーロードしたクラスはCopyConstructibleではなかったため、標準ライブラリコンテナーでは使用できませんでした。 C ++ 11以降、標準ライブラリはオブジェクトのアドレスが必要な場合は常に &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="9f5f5ea9e92fa642a1d809852878c2987d57848b" translate="yes" xml:space="preserve">
          <source>Until C++11, it was unspecified whether &lt;code&gt;basic_streambuf&lt;/code&gt; or any of its derived classes is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt;), and different C++ library implementations provided different options.</source>
          <target state="translated">C ++ 11までは、 &lt;code&gt;basic_streambuf&lt;/code&gt; またはその派生クラスのいずれかが&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; （ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG問題421&lt;/a&gt; ）であるかどうかは指定されておらず、C ++ライブラリの実装ごとに異なるオプションが提供されていました。</target>
        </trans-unit>
        <trans-unit id="328855c59d216dad3422e6e98a3125cd6d816dcf" translate="yes" xml:space="preserve">
          <source>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, they are allowed when aggregate initialization uses round parentheses.</source>
          <target state="translated">C++11 までは、集約初期化で絞り込み変換が許可されていましたが、C++20 以降、集約初期化で丸括弧を使用する場合に許可されることを除いては許可されなくなりました。</target>
        </trans-unit>
        <trans-unit id="6e17e7cb9fc8a5970b94833c26c3d5625cb274e1" translate="yes" xml:space="preserve">
          <source>Until C++11, the rounding direction of the quotient and the sign of the remainder in the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;built-in division and remainder operators&lt;/a&gt; was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;std::div&lt;/code&gt;.</source>
          <target state="translated">C ++ 11までは、 &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;組み込みの除算演算子と剰余演算子&lt;/a&gt;の商の丸め方向と剰余の符号は、いずれかのオペランドが負の場合、実装で定義されていましたが、 &lt;code&gt;std::div&lt;/code&gt; 明確に定義されていました。</target>
        </trans-unit>
        <trans-unit id="2dd75578b3cf163fd9cdf707fa3febbd8933afe1" translate="yes" xml:space="preserve">
          <source>Until C++11, which introduced &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt;, about the only thing a strictly conforming program could do in a signal handler was to assign a value to a &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; variable and promptly return.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt; を導入したC ++ 11まで、厳密に準拠するプログラムがシグナルハンドラーで実行できる唯一のことは、 &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; 変数に値を割り当てて、すぐに戻ることでした。</target>
        </trans-unit>
        <trans-unit id="4d3ae3907e74b1b45f48b10e1e68c5b46d8f4619" translate="yes" xml:space="preserve">
          <source>Until C++14, the direct-initialization form &lt;code&gt;T a {args..}&lt;/code&gt; did not permit brace elision.</source>
          <target state="translated">C ++ 14までは、直接初期化形式 &lt;code&gt;T a {args..}&lt;/code&gt; は中括弧省略を許可していませんでした。</target>
        </trans-unit>
        <trans-unit id="7f752f60fcef0ea971b808f8f6eaf483ad584079" translate="yes" xml:space="preserve">
          <source>Until C++17, a function could not return a tuple using list-initialization:</source>
          <target state="translated">C++17 までは、リスト初期化を使用してタプルを返すことができませんでした。</target>
        </trans-unit>
        <trans-unit id="58fb383e77b7fb0335ad97e0f3c210c1e1d6f098" translate="yes" xml:space="preserve">
          <source>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. &lt;code&gt;if(obj) { ... }&lt;/code&gt;) presented a problem: given a user-defined conversion function, such as &lt;code&gt;T::operator bool() const;&lt;/code&gt;, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant &lt;code&gt;bool&lt;/code&gt; could be converted to &lt;code&gt;int&lt;/code&gt;, allowing such code as &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; or &lt;code&gt;int i = obj;&lt;/code&gt;.</source>
          <target state="translated">C ++ 11で明示的な変換関数が導入されるまで、ブールコンテキストで使用できるクラス（たとえば &lt;code&gt;if(obj) { ... }&lt;/code&gt; ）を設計すると、 &lt;code&gt;T::operator bool() const;&lt;/code&gt; などのユーザー定義の変換関数が与えられると問題が発生しました:: operator bool（）const; 、暗黙の変換シーケンスでは、その関数呼び出しの後に標準の変換シーケンスを1つ追加できました。つまり、結果の &lt;code&gt;bool&lt;/code&gt; を &lt;code&gt;int&lt;/code&gt; に変換できるため、 &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; などのコードを使用できます。 または &lt;code&gt;int i = obj;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46999a4d771dcf596a583d2c8bf0dbc1bb017bc" translate="yes" xml:space="preserve">
          <source>Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.</source>
          <target state="translated">C++14 で変数テンプレートが導入されるまで、パラメトリック変数は通常、クラス テンプレートの静的データ メンバとして実装されるか、必要な値を返す constexpr 関数テンプレートとして実装されていました。</target>
        </trans-unit>
        <trans-unit id="c65bb8e4818155db56e2464c0be89b93b4aa7fb0" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of &lt;code&gt;setjmp&lt;/code&gt;, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; was executed, except for the non-&lt;a href=&quot;../../language/cv&quot;&gt;volatile&lt;/a&gt; local variables in &lt;code&gt;setjmp&lt;/code&gt;'s scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; のスコープに戻ると、すべてのアクセス可能なオブジェクト、浮動小数点ステータスフラグ、および抽象マシンの他のコンポーネントは、 &lt;code&gt;setjmp&lt;/code&gt; の &lt;a href=&quot;../../language/cv&quot;&gt;不揮発性&lt;/a&gt;ローカル変数を除いて、 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; が実行されたときと同じ値になりますのスコープ。その値は、setjmpの呼び出し以降に変更された場合、不確定です。</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; の大文字バージョン、または現在のCロケールに大文字バージョンがリストされていない場合は変更されていない &lt;code&gt;ch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e2fa3e294a40d353ff7bd0279d846fe85eb6a460" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mem_fn&lt;/code&gt; to store and execute a member function and a member object:</source>
          <target state="translated">&lt;code&gt;mem_fn&lt;/code&gt; を使用して、メンバー関数とメンバーオブジェクトを格納および実行します。</target>
        </trans-unit>
        <trans-unit id="ccd4cdfea5815983783eb398f954b34dd3308ca2" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="translated">ECMAScriptルールを使用して、 &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; 文字列を作成します（ &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;構文ドキュメント&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="7d2ca269005572f7dcc4f93975b5006fe75b32fe" translate="yes" xml:space="preserve">
          <source>Use POSIX</source>
          <target state="translated">POSIXを使用する</target>
        </trans-unit>
        <trans-unit id="59088c12cff257aabcfd96c2bff5eb6d63196ace" translate="yes" xml:space="preserve">
          <source>Use of an indeterminate value obtained by default-initializing a non-class variable of any type is &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt; (in particular, it may be a &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;trap representation&lt;/a&gt;), except in the following cases:</source>
          <target state="translated">次の場合を除いて、任意のタイプの非クラス変数をデフォルトで初期化することによって取得された不確定値の使用は、 &lt;a href=&quot;ub&quot;&gt;未定義の動作です&lt;/a&gt; （特に、 &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;トラップ表現&lt;/a&gt;である可能性があります）。</target>
        </trans-unit>
        <trans-unit id="1343357d8857f07ed216045e4630d2360702830a" translate="yes" xml:space="preserve">
          <source>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.</source>
          <target state="translated">pImplを使用するには、専用の翻訳ユニット(ヘッダのみのライブラリではpImplは使用できません)を必要とし、追加のクラスと一連の転送関数を導入し、アロケータを使用する場合は、公開インターフェースでアロケータ使用の実装詳細を公開します。</target>
        </trans-unit>
        <trans-unit id="5c95344b6a2f2f118527f061626aec54628cfeac" translate="yes" xml:space="preserve">
          <source>Use of this invalid value as an argument to any &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; member taking a value of this type is undefined behaviour</source>
          <target state="translated">この型の値を取得する &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; メンバーへの引数としてこの無効な値を使用すると、動作が未定義になります</target>
        </trans-unit>
        <trans-unit id="6eb61fe88f9155e92fd5505231d51581c0a1f378" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript regular expression grammar&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript正規表現文法を&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="0b59f8d4a6e7623991a4148e772aefe99cb9c959" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">基本的なPOSIX正規表現文法を使用します（ &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;文法ドキュメント&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4032118ad7e10c8a56fe81c51513bcd0f4198612" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">拡張POSIX正規表現文法を使用します（ &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;文法ドキュメント&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="efdfc5f80485169681a19ba23803d6f84ff4e293" translate="yes" xml:space="preserve">
          <source>Use the regular expression grammar used by the</source>
          <target state="translated">で使用する正規表現文法を使用します。</target>
        </trans-unit>
        <trans-unit id="b6f72b04e0e8a80cecbd0a1176096ac1763ecf62" translate="yes" xml:space="preserve">
          <source>Used as a more readable equivalent to the traditional &lt;a href=&quot;for&quot;&gt; for loop&lt;/a&gt; operating over a range of values, such as all elements in a container.</source>
          <target state="translated">コンテナー内のすべての要素など、値の範囲を操作する従来の&lt;a href=&quot;for&quot;&gt;forループ&lt;/a&gt;と同等の読みやすい形式で使用されます。</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">使用するフィールド</target>
        </trans-unit>
        <trans-unit id="df4ac21ba90d03bbec4f8d92680ff358bb022c1a" translate="yes" xml:space="preserve">
          <source>Used to mark a &lt;a href=&quot;../language/class_template&quot;&gt;template definition&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../language/class_template&quot;&gt;テンプレート定義&lt;/a&gt;をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="af59dbcc1c5fb76dabc78981244f1492f92bd30a" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type</source>
          <target state="translated">文字型を参照するために使用します。</target>
        </trans-unit>
        <trans-unit id="452240ee9951387e7059a7bfdc9cc878fb58e6e5" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type.</source>
          <target state="translated">文字種を参照するために使用します。</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">オブジェクトの実際のサイズを知る必要がある場合に使用します。</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">条件文を使ってループの残りの部分を無視するのが面倒な場合に使用します。</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">条件式や条件文を使ってループを終了させるのが面倒な場合に使用します。</target>
        </trans-unit>
        <trans-unit id="e80aa66e106a415e8288da7170c66b3a43f1b6c5" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using other statements.</source>
          <target state="translated">他のステートメントを使用して目的の場所に制御を移すことができない場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="7062a1fb9e1b49180bc64e78c1788d8e78b97581" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed based on a run-time or compile-time condition.</source>
          <target state="translated">ランタイムまたはコンパイル時の条件に基づいてコードを実行する必要がある場合に使用します。</target>
        </trans-unit>
        <trans-unit id="bf16483f532d4a8853cf1010caa2cb57d0f33c2f" translate="yes" xml:space="preserve">
          <source>Used where the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic object&lt;/a&gt; must be known and for static type identification.</source>
          <target state="translated">&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;ポリモーフィックオブジェクトの&lt;/a&gt; &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;動的タイプ&lt;/a&gt;が既知である必要がある場合、および静的タイプの識別に使用されます。</target>
        </trans-unit>
        <trans-unit id="42d90e90aadfee8047aec9690cf0574d0347d7d2" translate="yes" xml:space="preserve">
          <source>User code should usually use &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;, which provides a generic interface to convert time points between clocks, rather than call these functions directly.</source>
          <target state="translated">ユーザーコードは通常、 &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; 使用する必要があります。std:: chrono :: clock_castは 、これらの関数を直接呼び出すのではなく、クロック間の時間点を変換するための汎用インターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="22f079a53befe874a015e16af5dac8a9dbe1d7c3" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">グローバル&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;ユーザー置換バージョン</target>
        </trans-unit>
        <trans-unit id="beecf2d4915648f8f0efab35c62b4b57d5f5b1df" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">グローバル&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;および&lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;ユーザー置換バージョン</target>
        </trans-unit>
        <trans-unit id="36a2cff95d451b8ddda6e6fad777fc4eedb46043" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">グローバル&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt;および&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;ユーザー置換バージョン</target>
        </trans-unit>
        <trans-unit id="f9aac68f1811d0c886372a7b6aa12dfd47145f36" translate="yes" xml:space="preserve">
          <source>User specializations may define the member type &lt;code&gt;iterator_concept&lt;/code&gt; to one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;, to indicate conformance to the iterator concepts.</source>
          <target state="translated">ユーザーの特殊化では、メンバータイプ &lt;code&gt;iterator_concept&lt;/code&gt; を&lt;a href=&quot;iterator_tags&quot;&gt;イテレーターカテゴリタグの&lt;/a&gt; 1つに定義して、イテレーターの概念への適合を示すことができます。</target>
        </trans-unit>
        <trans-unit id="691620a9d9530e81a0d5cd25eb278071f62c4739" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
          <target state="translated">ユーザー定義リテラル</target>
        </trans-unit>
        <trans-unit id="d55e108d604fa5cfa1e00711a9ffe9ad9af9acb8" translate="yes" xml:space="preserve">
          <source>User-defined Literals for std::complex</source>
          <target state="translated">std::complex 用のユーザ定義リテラル</target>
        </trans-unit>
        <trans-unit id="66b100ca6f92096c7cc2adfb8fd94dcf564c734d" translate="yes" xml:space="preserve">
          <source>User-defined character traits may be used to provide &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;case-insensitive comparison&lt;/a&gt;.</source>
          <target state="translated">ユーザー定義の文字特性を使用して、 &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;大文字と小文字を区別しない比較&lt;/a&gt;を行うことができます。</target>
        </trans-unit>
        <trans-unit id="521384c0aef8e04b593ebebfeb20da581eaab716" translate="yes" xml:space="preserve">
          <source>User-defined classes and enumerations that implement the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; are required to overload the bitwise arithmetic operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt;, and may optionally overload the shift operators &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt;. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</source>
          <target state="translated">ビット&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;マスク&lt;/a&gt;算術演算子 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 、 &lt;code&gt;operator|&lt;/code&gt; をオーバーロードするには、 BitmaskTypeの要件を実装するユーザー定義のクラスと列挙が必要です。 、 &lt;code&gt;operator^&lt;/code&gt; 、 &lt;code&gt;operator~&lt;/code&gt; 、 &lt;code&gt;operator&amp;amp;=&lt;/code&gt; 、 &lt;code&gt;operator|=&lt;/code&gt; 、 &lt;code&gt;operator^=&lt;/code&gt; 、およびオプションでシフト演算 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt; 、および &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt; オーバーロードできます。 正規実装は通常、上記の2項算術演算子のパターンに従います。</target>
        </trans-unit>
        <trans-unit id="41ab182df7e7de75a62a46e254284df8495915ff" translate="yes" xml:space="preserve">
          <source>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for &lt;code&gt;operator[]&lt;/code&gt;: const and non-const variants:</source>
          <target state="translated">読み取りと書き込みの両方を可能にする配列のようなアクセスを提供するユーザー定義クラスは、通常、 &lt;code&gt;operator[]&lt;/code&gt; 2つのオーバーロードを定義します。constおよびnon-constバリアント：</target>
        </trans-unit>
        <trans-unit id="9759d0c809ae6bc40bb8a39c15779393d91b25b2" translate="yes" xml:space="preserve">
          <source>User-defined conversion function is invoked on the second stage of the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;, which consists of zero or one &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; or zero or one user-defined conversion function.</source>
          <target state="translated">ユーザー定義の変換関数は、ゼロまたは1つの&lt;a href=&quot;converting_constructor&quot;&gt;変換コンストラクター&lt;/a&gt;またはゼロまたは1つのユーザー定義の変換関数で構成される&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的な変換の&lt;/a&gt; 2番目のステージで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="43fb76a0004d3479d12ac1d1092e34daa13fde1a" translate="yes" xml:space="preserve">
          <source>User-defined conversions (both converting constructors and user-defined conversion functions) are prohibited from taking part in implicit conversion sequence where it would make it possible to apply more than one user-defined conversion. Specifically, they are not considered if the target of the conversion is the first parameter of a constructor or the implicit object parameter of a user-defined conversion function, and that constructor/user-defined conversion is a candidate for.</source>
          <target state="translated">ユーザ定義変換(変換コンストラクタとユーザ定義変換関数の両方)は、複数のユーザ定義変換を適用することが可能になるような暗黙の変換シーケンスに参加することが禁止されています。具体的には,変換の対象がコンストラクタの最初のパラメータまたはユーザ定義変換関数の暗黙のオブジェクトパラメータであり,そのコンストラクタ-ユーザ定義変換が候補となる場合は考慮されない。</target>
        </trans-unit>
        <trans-unit id="c8869104cf44d820cb55c49ce74b8353880870a6" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides</source>
          <target state="translated">ユーザー定義の控除ガイド</target>
        </trans-unit>
        <trans-unit id="ef26f7121e5a45ae6e617a4103dcbb63ab5dc3ab" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides do not have to be templates:</source>
          <target state="translated">ユーザー定義の控除ガイドはテンプレートである必要はありません。</target>
        </trans-unit>
        <trans-unit id="ada924d219c774c38ebbaa26b6b0ac7bd8284f27" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides must name a class template and must be introduced within the same semantic scope of the class template (which could be namespace or enclosing class) and, for a member class template, must have the same access, but deduction guides do not become members of that scope.</source>
          <target state="translated">ユーザー定義の推論ガイドは、クラス・テンプレートに名前を付け、そのクラス・テンプレートと同じセマンティック・スコープ(名前空間または包含クラス)内で導入されなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f7140ad8b86562edf1af76c7b4d2ecd3daf0a05" translate="yes" xml:space="preserve">
          <source>User-defined literals</source>
          <target state="translated">ユーザー定義のリテラル</target>
        </trans-unit>
        <trans-unit id="27875895c12b2d250978e1e13877f06ad81a62ef" translate="yes" xml:space="preserve">
          <source>User-defined literals (since C++11)</source>
          <target state="translated">ユーザー定義リテラル(C++11 以降</target>
        </trans-unit>
        <trans-unit id="f9e1a4e3fe3d8c4879519e8d07a0503e9a4c9e72" translate="yes" xml:space="preserve">
          <source>User-defined literals for string types</source>
          <target state="translated">文字列型のユーザー定義リテラル</target>
        </trans-unit>
        <trans-unit id="d0490dae080d561474031e5c0e2c4ef6347ced31" translate="yes" xml:space="preserve">
          <source>User-defined literals for time types</source>
          <target state="translated">時間タイプのユーザー定義リテラル</target>
        </trans-unit>
        <trans-unit id="fc5e25714db01eb56b2bf86b5e7921777fc9f4c1" translate="yes" xml:space="preserve">
          <source>User-defined overloads</source>
          <target state="translated">ユーザー定義のオーバーロード</target>
        </trans-unit>
        <trans-unit id="33745b553a69e48bb26d5d43ad7a22124cb88491" translate="yes" xml:space="preserve">
          <source>User-defined overloads of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; have no effect on constraint normalization.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; または &lt;code&gt;||&lt;/code&gt; のユーザー定義のオーバーロード 制約の正規化には影響しません。</target>
        </trans-unit>
        <trans-unit id="9d6ddc3c3044ee87f524355e003d05e7748d65d0" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;leap&lt;/code&gt; objects except by copying from existing &lt;code&gt;leap&lt;/code&gt; objects. The library implementation creates &lt;code&gt;leap&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">ユーザーは、既存の &lt;code&gt;leap&lt;/code&gt; オブジェクトからコピーしない限り、 &lt;code&gt;leap&lt;/code&gt; オブジェクトを構築できません。 ライブラリの実装は、タイムゾーンデータベースを初期化するときに &lt;code&gt;leap&lt;/code&gt; オブジェクトを作成し、これらのオブジェクトへの &lt;code&gt;const&lt;/code&gt; アクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="f9e764d8a62224f28652f9477d145424640947d7" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;link&lt;/code&gt; objects. The library implementation creates &lt;code&gt;link&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">ユーザーは &lt;code&gt;link&lt;/code&gt; オブジェクトを作成できません。 ライブラリの実装は、タイムゾーンデータベースを初期化するときに &lt;code&gt;link&lt;/code&gt; オブジェクトを作成し、これらのオブジェクトへの &lt;code&gt;const&lt;/code&gt; アクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="af2f54042c747b54c3093610083361c67a39fbfd" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;time_zone&lt;/code&gt; objects. The library implementation creates &lt;code&gt;time_zone&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">ユーザーは &lt;code&gt;time_zone&lt;/code&gt; オブジェクトを構築できません。 ライブラリ実装は、タイムゾーンデータベースを初期化するときに &lt;code&gt;time_zone&lt;/code&gt; オブジェクトを作成し、これらのオブジェクトへの &lt;code&gt;const&lt;/code&gt; アクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="946304840b5dd2cc7ea35261e0218a4ed1cc1b01" translate="yes" xml:space="preserve">
          <source>Users may derive from &lt;code&gt;view_base&lt;/code&gt; or specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for types which model &lt;code&gt;View&lt;/code&gt;, and specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for types which do not.</source>
          <target state="translated">ユーザーは、 &lt;code&gt;view_base&lt;/code&gt; をモデル化するタイプの場合はview_baseまたは &lt;code&gt;enable_view&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に特化し、 そうでないタイプの場合は &lt;code&gt;enable_view&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に特化できます。</target>
        </trans-unit>
        <trans-unit id="d77619d2d2aeedbc5912e54a11fc69314fc4b9b4" translate="yes" xml:space="preserve">
          <source>Users may specialize &lt;code&gt;common_type&lt;/code&gt; for types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; if.</source>
          <target state="translated">ユーザーは、タイプ &lt;code&gt;T1&lt;/code&gt; および &lt;code&gt;T2&lt;/code&gt; の &lt;code&gt;common_type&lt;/code&gt; を特化することができます。</target>
        </trans-unit>
        <trans-unit id="44312d9b5ba550e3bf714285fd931d65780211eb" translate="yes" xml:space="preserve">
          <source>Uses base class pword storage for runtime type identification of derived stream objects.</source>
          <target state="translated">派生ストリームオブジェクトのランタイム型識別に基底クラスのpwordストレージを使用します。</target>
        </trans-unit>
        <trans-unit id="435dd26a3c29e79ab39283f08d206249de9658d9" translate="yes" xml:space="preserve">
          <source>Uses native_handle to enable realtime scheduling of C++ threads on a POSIX system.</source>
          <target state="translated">native_handleを使用して、POSIXシステム上でC++スレッドのリアルタイムスケジューリングを可能にします。</target>
        </trans-unit>
        <trans-unit id="47d9c5030129b909d30f38ba61ff22e289ed4dc7" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to allocate &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">アロケータ &lt;code&gt;a&lt;/code&gt; を使用して、初期化されていないストレージの &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; バイトを割り当てます。</target>
        </trans-unit>
        <trans-unit id="5774066b9e43fa4c8cddba29af3f1729deeb9d50" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;a.deallocate(p, n)&lt;/code&gt;.</source>
          <target state="translated">アロケータ &lt;code&gt;a&lt;/code&gt; を使用して、 &lt;code&gt;a.deallocate(p, n)&lt;/code&gt; 呼び出すことにより、 &lt;code&gt;p&lt;/code&gt; が参照するストレージの割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="1ba97051617e132658e923e2cd0500400c48654b" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to allocate uninitialized storage.</source>
          <target state="translated">外部アロケータを使用して、初期化されていないストレージを割り当てます。</target>
        </trans-unit>
        <trans-unit id="b3f5f74569dd5173607ac926d852b70e7c657155" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to call the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">を呼び出すことにより、外部アロケータを使用して、 &lt;code&gt;p&lt;/code&gt; が指すオブジェクトのデストラクタを呼び出します。</target>
        </trans-unit>
        <trans-unit id="1233805d22778d94a1a1092f4fdeffec6effe4da" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt; 呼び出すことにより、外部アロケーターを使用して &lt;code&gt;p&lt;/code&gt; が参照するストレージの割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="9d6bd96d2b4bc007cec5dbc13bffdb43818c467e" translate="yes" xml:space="preserve">
          <source>Uses-allocator construction</source>
          <target state="translated">用途別割当工事</target>
        </trans-unit>
        <trans-unit id="e8ccfd79bce11a76a3f0a27cd61f22c4be4a0529" translate="yes" xml:space="preserve">
          <source>Using a member typedef or alias template in a constructor or constructor template's parameter list does not, by itself, render the corresponding parameter of the implicitly generated guide a non-deduced context.</source>
          <target state="translated">コンストラクタやコンストラクタテンプレートのパラメータリストでメンバ型定義やエイリアステンプレートを使用しても、それ自体では、暗黙的に生成されたガイドの対応するパラメータを非減算コンテキストにレンダリングすることはできません。</target>
        </trans-unit>
        <trans-unit id="3973ba3748f277f1b1247e46879f1a5b0ff12c85" translate="yes" xml:space="preserve">
          <source>Using this library may require additional compiler/linker options. GNU implementation requires linking with &lt;code&gt;-lstdc++fs&lt;/code&gt; and LLVM implementation requires linking with &lt;code&gt;-lc++fs&lt;/code&gt;.</source>
          <target state="translated">このライブラリを使用するには、追加のコンパイラ/リンカーオプションが必要な場合があります。 GNU実装では &lt;code&gt;-lstdc++fs&lt;/code&gt; とリンクする必要があり、LLVM実装では &lt;code&gt;-lc++fs&lt;/code&gt; とリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="478f8e8f8e40a23e1335aa300d9b135f2ed07fd9" translate="yes" xml:space="preserve">
          <source>Using-declaration</source>
          <target state="translated">Using-declaration</target>
        </trans-unit>
        <trans-unit id="e192f9ebd97a059b8b3818089ff571a2768e5ba3" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of a base class into the derived class definition, such as to expose a protected member of base as public member of derived. In this case, nested-name-specifier must name a base class of the one being defined. If the name is the name of an overloaded member function of the base class, all base class member functions with that name are introduced. If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class.</source>
          <target state="translated">使用宣言は、ベースクラスの保護されたメンバを派生クラスのパブリックメンバとして公開するなど、派生クラスの定義にベースクラスのメンバを導入します。この場合、nested-name-specifierは、定義されている基底クラスの名前を指定しなければなりません。その名前が基底クラスのオーバーロードされたメンバ関数の名前である場合、その名前を持つすべての基底クラスのメンバ関数が導入されます。派生クラスに同じ名前、パラメータ・リスト、および資格を持つメンバが既に存在する場合、派生クラス・メンバは、ベース・クラスから導入されたメンバを非表示またはオーバーライドします (競合しません)。</target>
        </trans-unit>
        <trans-unit id="647139d11b1988510ebdf137fbaac198034c6a6b" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of another namespace into current namespace or block scope.</source>
          <target state="translated">使用宣言は、他の名前空間のメンバを現在の名前空間やブロックスコープに導入します。</target>
        </trans-unit>
        <trans-unit id="96ab3f618e4bb79ceae244afaf56510df88fbaa8" translate="yes" xml:space="preserve">
          <source>Using-declarations</source>
          <target state="translated">Using-declarations</target>
        </trans-unit>
        <trans-unit id="89ce2da2bf0809daefed3588888e71ab6c4b17a5" translate="yes" xml:space="preserve">
          <source>Using-declarations can be used to introduce namespace members into other namespaces and block scopes, or to introduce base class members into derived class definitions.</source>
          <target state="translated">使用宣言を使用すると、名前空間のメンバを他の名前空間やブロック・スコープに導入したり、ベース・クラスのメンバを派生クラス定義に導入したりすることができます。</target>
        </trans-unit>
        <trans-unit id="1afd86105bb6b7eae3d1c2ff8ebac8080cc93c0b" translate="yes" xml:space="preserve">
          <source>Using-declarations cannot name &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, namespace, or a scoped enumerator. Each declarator in a using-declaration introduces one and only one name, for example using-declaration for an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; does not introduce any of its enumerators.</source>
          <target state="translated">using-declarationsは、 &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; 、名前空間、またはスコープ付き列挙子に名前を付けることはできません。 using-declarationの各宣言子は、1つの名前のみを紹介します。たとえば、 &lt;a href=&quot;enum&quot;&gt;列挙の&lt;/a&gt; using-declarationは、その列挙子を紹介しません。</target>
        </trans-unit>
        <trans-unit id="243bb7e4adba8af291f9b9518cc9a875ccf74e65" translate="yes" xml:space="preserve">
          <source>Using-declarations in derived classes cannot refer to specializations of template conversion functions from base classes.</source>
          <target state="translated">派生クラスでの使用宣言は,基底クラスからのテンプレート変換関数の特殊化を参照することはできません.</target>
        </trans-unit>
        <trans-unit id="890b0e8bf12e6e2f8622f4d2164034f01e35b67b" translate="yes" xml:space="preserve">
          <source>Using-directive does not add any names to the declarative region in which it appears (unlike the using-declaration), and thus does not prevent identical names from being declared.</source>
          <target state="translated">Using-directiveは、(Using-declarationとは異なり)出現する宣言領域に名前を追加しないので、同一の名前が宣言されることを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="9267f4ac5eb849d97bac3ea55d519f3646d7511f" translate="yes" xml:space="preserve">
          <source>Using-directives</source>
          <target state="translated">Using-directives</target>
        </trans-unit>
        <trans-unit id="e478a805aae96b5ada7799a77a72b64e59439220" translate="yes" xml:space="preserve">
          <source>Using-directives are allowed only in namespace &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and in block scope. From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</source>
          <target state="translated">usingディレクティブは、名前空間&lt;a href=&quot;scope&quot;&gt;スコープ&lt;/a&gt;とブロックスコープでのみ許可されます。 usingディレクティブの後の&lt;a href=&quot;lookup&quot;&gt;名前&lt;/a&gt;の非修飾名ルックアップの観点から、それが現れるスコープの終わりまで、namespace-nameからのすべての名前は、両方を含む最も近い囲み名前空間で宣言されているかのように見えますusing-directiveおよびnamespace-name。</target>
        </trans-unit>
        <trans-unit id="fe20c085207b808c419801ec01c3f2d69d1e53a9" translate="yes" xml:space="preserve">
          <source>Using-directives are transitive for the purposes of &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt;: if a scope contains a using-directive that nominates a namespace-name, which itself contains using-directive for some namespace-name-2, the effect is as if the using directives from the second namespace appear within the first. The order in which these transitive namespaces occur does not influence name lookup.</source>
          <target state="translated">usingディレクティブは、 &lt;a href=&quot;lookup&quot;&gt;修飾されていないルックアップ&lt;/a&gt;の目的で推移的です。スコープに、namespace-nameを指定するusingディレクティブが含まれ、それ自体が何らかのnamespace-name-2のusingディレクティブを含む場合、その効果は、 2番目のネームスペースは最初のネームスペース内に表示されます。 これらの推移的な名前空間の発生順序は、名前の検索に影響を与えません。</target>
        </trans-unit>
        <trans-unit id="90e771e57dbe271295562deb5815544ce47acec2" translate="yes" xml:space="preserve">
          <source>Usual &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt; is used for the identifier prefixed by &lt;code&gt;typename&lt;/code&gt;. Unlike the case with &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, the lookup rules do not change despite the qualifier:</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; で始まる識別子には、通常の&lt;a href=&quot;qualified_lookup&quot;&gt;修飾名ルックアップ&lt;/a&gt;が使用されます。 &lt;a href=&quot;elaborated_type_specifier&quot;&gt;エラボレートされた型指定子の&lt;/a&gt;場合とは異なり、修飾子があってもルックアップルールは変更されません。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="72c1f2942e6c2f59eb16eb2f336358c3428f04e8" translate="yes" xml:space="preserve">
          <source>Utilities library</source>
          <target state="translated">ユーティリティライブラリ</target>
        </trans-unit>
        <trans-unit id="c238357565249d5db64377b7321a861ff74e6a3d" translate="yes" xml:space="preserve">
          <source>Utility components</source>
          <target state="translated">ユーティリティーコンポーネント</target>
        </trans-unit>
        <trans-unit id="69be11f41a3c37842e99473568839d6e6c14c854" translate="yes" xml:space="preserve">
          <source>Utility library</source>
          <target state="translated">ユーティリティライブラリ</target>
        </trans-unit>
        <trans-unit id="6c204fbda83dad99b4764ac479029ca8981e718e" translate="yes" xml:space="preserve">
          <source>Utility metafunction that maps a sequence of any types to the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">任意の型のシーケンスを &lt;code&gt;void&lt;/code&gt; 型にマップするユーティリティメタ関数。</target>
        </trans-unit>
        <trans-unit id="b0d7fadc1640d7f4704fe07fafd860ef56a6519b" translate="yes" xml:space="preserve">
          <source>VERTICAL KANA REPEAT MARK - HANGUL JONGSEONG PHIEUPH-THIEUTH</source>
          <target state="translated">たてかなリピートマーク-ハングル・チョンソン・フィウプ・チース</target>
        </trans-unit>
        <trans-unit id="5a815286d91c46561b98d7d910a0542f7fa603a7" translate="yes" xml:space="preserve">
          <source>VULGAR FRACTION ONE QUARTER - VULGAR FRACTION THREE QUARTERS</source>
          <target state="translated">下品な分数4分の1-下品な分数4分の3</target>
        </trans-unit>
        <trans-unit id="2a85014316c857fc68366f2d4cfeef4ccca44072" translate="yes" xml:space="preserve">
          <source>Valid non-zero alignments that are weaker than another &lt;code&gt;alignas&lt;/code&gt; on the same declaration are ignored.</source>
          <target state="translated">同じ宣言の別の &lt;code&gt;alignas&lt;/code&gt; よりも弱い有効なゼロ以外のアラインメントは無視されます。</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f00df19eab61f9bc6b193ebf7f79f580e312b435" translate="yes" xml:space="preserve">
          <source>Value (hex)</source>
          <target state="translated">値(16進数)</target>
        </trans-unit>
        <trans-unit id="6ccf81011273d24c106e237774966bec5a3f3d04" translate="yes" xml:space="preserve">
          <source>Value (octal)</source>
          <target state="translated">値(8進数)</target>
        </trans-unit>
        <trans-unit id="842d5c71fd285df07d76b3a931200aef4027bbe5" translate="yes" xml:space="preserve">
          <source>Value array containing</source>
          <target state="translated">を含む値の配列</target>
        </trans-unit>
        <trans-unit id="8f9d98449ec4c8f79f22636316b3a0e923c947ef" translate="yes" xml:space="preserve">
          <source>Value array containing absolute values of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の絶対値を含む値の配列。</target>
        </trans-unit>
        <trans-unit id="bba712cfd9f7651aa772da136f89a61149be2ac1" translate="yes" xml:space="preserve">
          <source>Value array containing arc cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の逆余弦を含む値配列。</target>
        </trans-unit>
        <trans-unit id="918e7d00363d34ea17b81a2896797c2d5407de29" translate="yes" xml:space="preserve">
          <source>Value array containing arc sines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の逆正弦を含む値配列。</target>
        </trans-unit>
        <trans-unit id="7dd43aa4756d43fc4b8be056b5da614e7ae17fe0" translate="yes" xml:space="preserve">
          <source>Value array containing arc tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値のアークタンジェントを含む値配列。</target>
        </trans-unit>
        <trans-unit id="7a16b1209abeda990f5a71b8d2e227e0b6c93b82" translate="yes" xml:space="preserve">
          <source>Value array containing common logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の常用対数を含む値配列。</target>
        </trans-unit>
        <trans-unit id="a311ab5baa8093138875ac8a94b0cea46530bc77" translate="yes" xml:space="preserve">
          <source>Value array containing cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の余弦を含む値配列。</target>
        </trans-unit>
        <trans-unit id="67e25f3a01cf3ed1b997a81a0d9b1d557b7e592b" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic cosine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の双曲線余弦を含む値の配列。</target>
        </trans-unit>
        <trans-unit id="9d4fd3ea31174e2ad27a712e67ef9575efad3f21" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の双曲線正弦を含む値配列。</target>
        </trans-unit>
        <trans-unit id="2a5794dbb6788174721a7201fba5775845755af6" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic tangent of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の双曲線正接を含む値の配列。</target>
        </trans-unit>
        <trans-unit id="788503847d55a0b843da66ecc9eb7e909c8e81ea" translate="yes" xml:space="preserve">
          <source>Value array containing natural logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の自然対数を含む値の配列。</target>
        </trans-unit>
        <trans-unit id="8d94e0b0bb891cd281312eef3d7cafb82f9093c2" translate="yes" xml:space="preserve">
          <source>Value array containing sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の正弦を含む値配列。</target>
        </trans-unit>
        <trans-unit id="4bcd496b550ea36f6a6a5da52708746dfc984226" translate="yes" xml:space="preserve">
          <source>Value array containing square roots of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値の平方根を含む値の配列。</target>
        </trans-unit>
        <trans-unit id="acec93cb24e8ed07513e328851e06115700eaed0" translate="yes" xml:space="preserve">
          <source>Value array containing tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; の値のタンジェントを含む値配列。</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">価値のカテゴリー</target>
        </trans-unit>
        <trans-unit id="82a222afd8aa1f50591d47af3a1da440d1b6c1c9" translate="yes" xml:space="preserve">
          <source>Value initialization is performed in these situations:</source>
          <target state="translated">このような状況では、値の初期化が行われます。</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; の値</target>
        </trans-unit>
        <trans-unit id="f316bf9562d1f2536d1f98b558dad75f56bae376" translate="yes" xml:space="preserve">
          <source>Value of a floating-point or &lt;a href=&quot;../../types/is_integral&quot;&gt;Integral type&lt;/a&gt;</source>
          <target state="translated">浮動小数点&lt;a href=&quot;../../types/is_integral&quot;&gt;型&lt;/a&gt;または整数型の値</target>
        </trans-unit>
        <trans-unit id="8868e91c4a5c3eea6c88793879068066054670cd" translate="yes" xml:space="preserve">
          <source>Value of a type &lt;code&gt;Y&lt;/code&gt; whose &lt;a href=&quot;../container/node_handle&quot;&gt;node handles&lt;/a&gt; are compatible with X</source>
          <target state="translated">&lt;a href=&quot;../container/node_handle&quot;&gt;ノードハンドル&lt;/a&gt;がXと互換性があるタイプ &lt;code&gt;Y&lt;/code&gt; の値</target>
        </trans-unit>
        <trans-unit id="a6d7a9a5f8f421d8d8d1289caa1073e525a68c0c" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X::size_type&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="a3076d857f6bafe8bc4b757157d8b7e92030d350" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;X&lt;/code&gt; の値</target>
        </trans-unit>
        <trans-unit id="bdc99e4fc02f27b3e7f0e86f72aae50003652dc4" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple keys</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; が複数のキーをサポートする場合のタイプ &lt;code&gt;X&lt;/code&gt; の値</target>
        </trans-unit>
        <trans-unit id="d88b2ce84fd44f3d069f80a1cad885599a530444" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; が一意のキーをサポートする場合のタイプ &lt;code&gt;X&lt;/code&gt; の値</target>
        </trans-unit>
        <trans-unit id="b2e637fb234b0c6b9d295e0383f8ac972d2e9be2" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 型の値</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">値の範囲</target>
        </trans-unit>
        <trans-unit id="51127d011c590cc06c1287343706272a08f0dc2d" translate="yes" xml:space="preserve">
          <source>Value too large to be stored in data type</source>
          <target state="translated">値が大きすぎてデータ型に格納できません。</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">価値の変換</target>
        </trans-unit>
        <trans-unit id="60a41a8af03cf015b251f42ec4877faede44cfa3" translate="yes" xml:space="preserve">
          <source>Value transformations are conversions that change the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</source>
          <target state="translated">値の変換は、式の&lt;a href=&quot;value_category&quot;&gt;値のカテゴリ&lt;/a&gt;を変更する変換です。 これらは、式が別の値カテゴリの式を期待する演算子のオペランドとして表示されるときに必ず発生します。</target>
        </trans-unit>
        <trans-unit id="912f89db75340dd536695f5900751cb79605c44e" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions</source>
          <target state="translated">値に依存する表現</target>
        </trans-unit>
        <trans-unit id="1c83d35b39b8a1674f047686e39badc8092fea73" translate="yes" xml:space="preserve">
          <source>ValueSwappable</source>
          <target state="translated">ValueSwappable</target>
        </trans-unit>
        <trans-unit id="5cfdbdef621053e4c2adb3e5800cfd3510d6d549" translate="yes" xml:space="preserve">
          <source>ValueType</source>
          <target state="translated">ValueType</target>
        </trans-unit>
        <trans-unit id="e3d8fb1ed748d78b39416572c15d6566892835be" translate="yes" xml:space="preserve">
          <source>Values of &lt;code&gt;base&lt;/code&gt; other than 8, 10, or 16 reset &lt;code&gt;basefield&lt;/code&gt; to zero, which corresponds to decimal output and prefix-dependent input.</source>
          <target state="translated">&lt;code&gt;basefield&lt;/code&gt; 、または16以外の &lt;code&gt;base&lt;/code&gt; の値は、 basefieldをゼロにリセットします。これは、10進数の出力とプレフィックスに依存する入力に対応します。</target>
        </trans-unit>
        <trans-unit id="699b7fde74d4bad2ed32bf4fdac5cb581d05b675" translate="yes" xml:space="preserve">
          <source>Values of integer, floating-point, and enumeration types can be converted by &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, to any enumeration type. If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the underlying type.</source>
          <target state="translated">整数型、浮動小数点型、および列挙型の値は、 &lt;a href=&quot;static_cast&quot;&gt; &lt;code&gt;static_cast&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;explicit_cast&quot;&gt;明示的なキャスト&lt;/a&gt;によって、任意の列挙型に変換できます。 基になる型が固定されていない場合、ソース値（浮動小数点の場合は最初に列挙型の基になる型に変換されます）が範囲外の場合、結果は（C ++ 17まで）未定義の動作です（C ++ 17以降）。範囲は、ターゲット列挙のすべての列挙子を保持するのに十分な大きさの最小ビットフィールドで可能なすべての値です）。 それ以外の場合、結果は、基礎となる型への&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的な変換&lt;/a&gt;の結果と同じです。</target>
        </trans-unit>
        <trans-unit id="622c99b5f957359968fbce43706c282c2086981e" translate="yes" xml:space="preserve">
          <source>Values of unscoped enumeration type are &lt;a href=&quot;implicit_cast&quot;&gt;implicitly-convertible&lt;/a&gt; to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;. If the underlying type is fixed, the values can be converted to their promoted underlying type.</source>
          <target state="translated">スコープのない列挙型の値は、 &lt;a href=&quot;implicit_cast&quot;&gt;暗黙的&lt;/a&gt;に整数型に変換できます。 基になる型が固定されていない場合、値は、値の範囲全体を保持できる次のリストの最初の型に変換可能です： &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、 &lt;code&gt;long long&lt;/code&gt; 、または &lt;code&gt;unsigned long long&lt;/code&gt; 。 基になるタイプが固定されている場合、値はプロモートされる基になるタイプに変換できます。</target>
        </trans-unit>
        <trans-unit id="f8df93af76ffcc18fdab0d35c919d46adda08d0a" translate="yes" xml:space="preserve">
          <source>Values of zero will be replaced with implementation-specified defaults;</source>
          <target state="translated">ゼロの値は、実装で指定されたデフォルト値に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="052336d34e395136fdc7b0ea68de9e6ce0735430" translate="yes" xml:space="preserve">
          <source>Values returned from &lt;code&gt;lookup_classname&lt;/code&gt; can be bitwise or'ed together; the resulting value represents membership in either of the corresponding character classes</source>
          <target state="translated">&lt;code&gt;lookup_classname&lt;/code&gt; から返される値は、ビット単位または一緒にすることができます。 結果の値は、対応するいずれかの文字クラスのメンバーシップを表します</target>
        </trans-unit>
        <trans-unit id="df08eb1d25241fdec3135b3385380633b3feb713" translate="yes" xml:space="preserve">
          <source>Variable template(since C++14)</source>
          <target state="translated">変数テンプレート(C++14以降</target>
        </trans-unit>
        <trans-unit id="07e0c173abb12ff926e54a677500672fc6b6b986" translate="yes" xml:space="preserve">
          <source>Variable templates</source>
          <target state="translated">変数テンプレート</target>
        </trans-unit>
        <trans-unit id="bb8bc60fbcd37b30cc10bb1c4aefe4bd77138258" translate="yes" xml:space="preserve">
          <source>Variable templates cannot be used as &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;template template arguments&lt;/a&gt;.</source>
          <target state="translated">変数テンプレートは、 &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;テンプレートテンプレートの引数&lt;/a&gt;として使用できません。</target>
        </trans-unit>
        <trans-unit id="bf60c912c256eebe5d2b8b031ec6bed1e0afbc9c" translate="yes" xml:space="preserve">
          <source>Variable templates for type traits</source>
          <target state="translated">型の形質のための変数テンプレート</target>
        </trans-unit>
        <trans-unit id="d41def7a6d8846ea38dabfb67345e2e0a09f52e7" translate="yes" xml:space="preserve">
          <source>Variables declared at block scope with the specifier &lt;code&gt;static&lt;/code&gt; have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is &lt;a href=&quot;zero_initialization&quot;&gt;zero-&lt;/a&gt; or &lt;a href=&quot;constant_initialization&quot;&gt;constant-initialization&lt;/a&gt;, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 指定子を使用してブロックスコープで宣言された変数は、静的な保存期間を持ちますが、最初に制御がその宣言を通過するときに初期化されます （初期化が&lt;a href=&quot;zero_initialization&quot;&gt;ゼロ&lt;/a&gt;または&lt;a href=&quot;constant_initialization&quot;&gt;定数初期化&lt;/a&gt;である場合を除き、ブロックが最初に入力される前に実行できます）。 それ以降のすべての呼び出しでは、宣言はスキップされます。</target>
        </trans-unit>
        <trans-unit id="56198fe808c824ddba06784c100164faedd427c3" translate="yes" xml:space="preserve">
          <source>Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;std::scoped_lock&lt;/code&gt;)</source>
          <target state="translated">可変個の &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;std::scoped_lock&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">可変引数</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">バラエティ機能</target>
        </trans-unit>
        <trans-unit id="04c44e45105b6cf53a83ce33f663f4af86c9d0a7" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;) which take a &lt;a href=&quot;../language/variadic_arguments&quot;&gt;variable number of arguments&lt;/a&gt;.</source>
          <target state="translated">可変個の関数は、 &lt;a href=&quot;../language/variadic_arguments&quot;&gt;可変数の引数&lt;/a&gt;を取る関数（例： &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="8a308087e2905028e7ad5d2c240717d97448c333" translate="yes" xml:space="preserve">
          <source>Variadic templates</source>
          <target state="translated">バラエティーに富んだテンプレート</target>
        </trans-unit>
        <trans-unit id="40aa5342cc8cddbbe71fe77cdf48f02a16642a52" translate="yes" xml:space="preserve">
          <source>Various &lt;a href=&quot;utility&quot;&gt; utility components&lt;/a&gt;</source>
          <target state="translated">さまざまな&lt;a href=&quot;utility&quot;&gt;ユーティリティコンポーネント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43dfbbdcd916a0c6741ae6b7703f2bf5dd8096c3" translate="yes" xml:space="preserve">
          <source>Vector capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of pop_back() calls.</source>
          <target state="translated">小さいサイズにリサイズする際にベクターの容量が減ることはありません。 これは、同等の pop_back()コールのシーケンスで無効になるイテレータだけが無効になるのではなく、すべてのイテレータが無効になってしまうからです。</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; ディレクティブのバージョン（2）は、単純な関数のようなマクロを定義します。</target>
        </trans-unit>
        <trans-unit id="ae3376f429640ab77c59ef69b6eeee356493fa80" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; ディレクティブのバージョン（3）は、可変数の引数を持つ関数のようなマクロを定義します。 追加の引数（と呼ばれる</target>
        </trans-unit>
        <trans-unit id="3243986759cbfdbcf8f3fe70af12570a24f20c76" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; ディレクティブのバージョン（4）は、可変数の引数を持つ関数のようなマクロを定義しますが、通常の引数は定義しません。 引数（と呼ばれる</target>
        </trans-unit>
        <trans-unit id="1c26c7d8a48f6ecef280cf0b203307778072892d" translate="yes" xml:space="preserve">
          <source>Viable functions</source>
          <target state="translated">有効な機能</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="57dde08ae7e4931bf4b1d9d8203c8fb2aa6c4ddb" translate="yes" xml:space="preserve">
          <source>View of the substring &lt;code&gt;[pos, pos + rcount)&lt;/code&gt;.</source>
          <target state="translated">サブストリング &lt;code&gt;[pos, pos + rcount)&lt;/code&gt; ビュー。</target>
        </trans-unit>
        <trans-unit id="08776128bd18b59c55542f61081a01440f41b01c" translate="yes" xml:space="preserve">
          <source>ViewableRange</source>
          <target state="translated">ViewableRange</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c911ee9da5495317a3fd2048e2a77408d0f7651d" translate="yes" xml:space="preserve">
          <source>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.</source>
          <target state="translated">制約の違反はコンパイル時に、テンプレートのインスタンス化プロセスの早い段階で検出されます。</target>
        </trans-unit>
        <trans-unit id="9b18a97a2fd2836708868d06e1ce4ef84d86615c" translate="yes" xml:space="preserve">
          <source>Virtual and pure virtual functions</source>
          <target state="translated">仮想機能と純粋な仮想機能</target>
        </trans-unit>
        <trans-unit id="f68e04bd9e3e62f1affa5f5cd95daed9e7141704" translate="yes" xml:space="preserve">
          <source>Virtual base classes</source>
          <target state="translated">仮想基底クラス</target>
        </trans-unit>
        <trans-unit id="bb2875a5baa367827268a607eb3795f455c6012e" translate="yes" xml:space="preserve">
          <source>Virtual destructor</source>
          <target state="translated">バーチャルデストロイヤー</target>
        </trans-unit>
        <trans-unit id="5066038f5f1b55b5a2bc0bc13c582fae42181817" translate="yes" xml:space="preserve">
          <source>Virtual destructors</source>
          <target state="translated">バーチャルデストラクタ</target>
        </trans-unit>
        <trans-unit id="f6fe3c659ed8077db8d0b5920aa4b5764bff62d6" translate="yes" xml:space="preserve">
          <source>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</source>
          <target state="translated">仮想関数(宣言された仮想関数であっても、オーバーライドされた関数であっても)は、関連する制約を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="7f5fcb0f75cbb4813db427832ef8357c8c51c72a" translate="yes" xml:space="preserve">
          <source>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt; (that is, if the function's name appears to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">仮想関数は、派生クラスで動作をオーバーライドできるメンバー関数です。 非仮想関数とは対照的に、クラスの実際の型に関するコンパイル時の情報がない場合でも、オーバーライドされた動作は保持されます。 派生クラスが、基本クラスへのポインターまたは参照を使用して処理される場合、オーバーライドされた仮想関数を呼び出すと、派生クラスで定義された動作が呼び出されます。 この動作は、関数が&lt;a href=&quot;lookup&quot;&gt;修飾名ルックアップ&lt;/a&gt;を使用して選択された場合（つまり、関数の名前がスコープ解決演算子 &lt;code&gt;::&lt;/code&gt; の右側に表示される場合）に抑制されます。</target>
        </trans-unit>
        <trans-unit id="d022c012c3444ee6f002dccdfcd5905c70efa42e" translate="yes" xml:space="preserve">
          <source>Visible side-effects</source>
          <target state="translated">目に見える副作用</target>
        </trans-unit>
        <trans-unit id="30c3d8194815052f5f9f54a1fac519295b84ad3f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2010</source>
          <target state="translated">ビジュアルスタジオ2010</target>
        </trans-unit>
        <trans-unit id="a50605af7e7015b16739f3db40248d1a64076a37" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 Inline Assembler</source>
          <target state="translated">Visual Studio 2013インラインアセンブラ</target>
        </trans-unit>
        <trans-unit id="359a03f62e49986ef991446210499529db3fc418" translate="yes" xml:space="preserve">
          <source>Void expressions</source>
          <target state="translated">ボイド表現</target>
        </trans-unit>
        <trans-unit id="f135b48d956f6ca097c1656d0a1863579947c9fb" translate="yes" xml:space="preserve">
          <source>Void expressions have no</source>
          <target state="translated">ボイド式には</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">ボイド型</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="d7d72e040861a1f86b9b248b64986ff2db87de0a" translate="yes" xml:space="preserve">
          <source>WORD JOINER - TURNED DIGIT THREE</source>
          <target state="translated">ワードジョイナー-三桁になった</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="8c8066383629449e748934ef44df8baa244ceb3f" translate="yes" xml:space="preserve">
          <source>Waits for the result to become available. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.</source>
          <target state="translated">結果が利用可能になるのを待ちます。 指定された &lt;code&gt;timeout_duration&lt;/code&gt; が経過するか、結果が利用可能になるかの、いずれか早い方になるまでブロックします 。 戻り値は結果の状態を識別します。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="128348550537d17215c4e4e19183a94c6cae96fb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; to denote the type of the expression &lt;code&gt;e&lt;/code&gt;. (In other words, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is the equivalent of &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt;.).</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; を使用して、式 &lt;code&gt;e&lt;/code&gt; のタイプを示します。 （つまり、 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt; と同等です）。</target>
        </trans-unit>
        <trans-unit id="ff2d0e12c8d86e48e138480e627a03522625fd5b" translate="yes" xml:space="preserve">
          <source>Weak equality</source>
          <target state="translated">弱い平等</target>
        </trans-unit>
        <trans-unit id="cc0eeac220c48abd1f4d8a9066580d68089b7e2a" translate="yes" xml:space="preserve">
          <source>Weak ordering</source>
          <target state="translated">弱い注文</target>
        </trans-unit>
        <trans-unit id="5f9aead2f88dbe4721a67660c3e46cd95c9d01ce" translate="yes" xml:space="preserve">
          <source>Weakly parallel forward progress</source>
          <target state="translated">弱く平行して前進</target>
        </trans-unit>
        <trans-unit id="32d5d9f2881f15e8163749d6edac5a8dd285e442" translate="yes" xml:space="preserve">
          <source>WeaklyIncrementable</source>
          <target state="translated">WeaklyIncrementable</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="1d901e38ea200c08db624662589c69e315e01ff1" translate="yes" xml:space="preserve">
          <source>Week/day of the year</source>
          <target state="translated">年内の平日</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">Cプログラマーなら誰もが知っておくべき「未定義の動作」について #13</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">Cプログラマーなら誰もが知っておくべき「未定義の動作」について #23</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">Cプログラマーなら誰もが知っておくべき「未定義の動作」について #33</target>
        </trans-unit>
        <trans-unit id="5345ef8ed5a57eddad0fc38e73e7287b6270366c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, or &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as &lt;b&gt;mutable&lt;/b&gt;.</source>
          <target state="translated">&lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 、 &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 、または&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;が、独自の要件に加えてLegacyOutputIterator要件を満たしている場合、 &lt;b&gt;mutable&lt;/b&gt;と記述されます。</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">&lt;code&gt;__VA_ARGS__&lt;/code&gt; の前に &lt;code&gt;#&lt;/code&gt; が表示される場合 、展開された__VA_ARGS__全体が引用符で囲まれています。</target>
        </trans-unit>
        <trans-unit id="046623a30719eaa626e9121030272ea2805083f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, it is unspecified whether function (1) is declared.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が（おそらくcv修飾された） &lt;code&gt;void&lt;/code&gt; である場合、関数（1）が宣言されているかどうかは不定です。</target>
        </trans-unit>
        <trans-unit id="bf6dcc3dc3f6b7e5ebe9923c510cc70615782d54" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is an array type, it is unspecified whether these member functions are declared, and if they are, what their return type is, except that the declaration (not necessarily the definition) of these functions is well-formed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が配列型の場合、これらのメンバー関数が宣言されているかどうか、および宣言されている場合の戻り値の型は、これらの関数の宣言（必ずしも定義ではない）が整形式であることを除いて、不定です。</target>
        </trans-unit>
        <trans-unit id="97a2afc24ba5f22063e77c7d297d40d35897008d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が配列型でない場合、この関数が宣言されているかどうかは不定です。 関数が宣言されている場合、関数の宣言が正当であることが保証されていることを除いて、関数の戻り値の型は不定です。</target>
        </trans-unit>
        <trans-unit id="841913a7a092250d0d74debefdc20a6387cf98d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, the overloads (3), (4), and (6) enable &lt;code&gt;shared_from_this&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt;, and the overload (13) enables &lt;code&gt;shared_from_this&lt;/code&gt; with the pointer returned by &lt;code&gt;r.release()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が配列型でない場合、オーバーロード（3）、（4）、および（6）は &lt;code&gt;ptr&lt;/code&gt; で &lt;code&gt;shared_from_this&lt;/code&gt; を有効にし、オーバーロード（13）は &lt;code&gt;r.release()&lt;/code&gt; によって返されるポインターで &lt;code&gt;shared_from_this&lt;/code&gt; を有効にします。</target>
        </trans-unit>
        <trans-unit id="933697ca9b43c7b723b629859ce79b9ed2a3265c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt;, the following properties are guaranteed:</source>
          <target state="translated">&lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt; 場合、次のプロパティが保証されます。</target>
        </trans-unit>
        <trans-unit id="57eacd6a7d9600dd8cd2e42c3f2ae19d11ad628e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shared_ptr&lt;/code&gt; is created by calling &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When &lt;code&gt;shared_ptr&lt;/code&gt; is created via one of the &lt;code&gt;shared_ptr&lt;/code&gt; constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; 呼び出して &lt;code&gt;shared_ptr&lt;/code&gt; を作成すると、制御ブロックと管理対象オブジェクトの両方のメモリが単一の割り当てで作成されます。 管理対象オブジェクトは、制御ブロックのデータメンバーにインプレースで構築されます。 &lt;code&gt;shared_ptr&lt;/code&gt; がいずれかの &lt;code&gt;shared_ptr&lt;/code&gt; コンストラクターを介して作成される場合、管理対象オブジェクトと制御ブロックは別々に割り当てる必要があります。 この場合、制御ブロックは管理対象オブジェクトへのポインタを格納します。</target>
        </trans-unit>
        <trans-unit id="4833d1b8e7740b741eed936468b06c1d2f60499d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt; (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; it had when passed to the calling function.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; が&lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;転送参照&lt;/a&gt; （cv修飾されていない関数テンプレートパラメーターへの右辺値参照として宣言されている関数引数）である場合、このオーバーロードは、呼び出し元の関数に渡されたときに持っていた&lt;a href=&quot;../language/value_category&quot;&gt;値カテゴリを&lt;/a&gt;持つ別の関数に引数を転送します。</target>
        </trans-unit>
        <trans-unit id="f05559f6187d0eff998ef174b497dd5f9e035c58" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;lock_guard&lt;/code&gt; object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the &lt;code&gt;lock_guard&lt;/code&gt; object was created, the &lt;code&gt;lock_guard&lt;/code&gt; is destructed and the mutex is released.</source>
          <target state="translated">&lt;code&gt;lock_guard&lt;/code&gt; オブジェクトが作成されると、与えられたmutexの所有権を取得しようとします。 コントロールが &lt;code&gt;lock_guard&lt;/code&gt; オブジェクトが作成されたスコープを離れると、 &lt;code&gt;lock_guard&lt;/code&gt; が破棄され、ミューテックスが解放されます。</target>
        </trans-unit>
        <trans-unit id="e69de8ba0616baddc63eba743d4447e24a787005" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;scoped_lock&lt;/code&gt; object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the &lt;code&gt;scoped_lock&lt;/code&gt; object was created, the &lt;code&gt;scoped_lock&lt;/code&gt; is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_lock&lt;/code&gt; オブジェクトが作成されると、指定されたmutexの所有権を取得しようとします。 コントロールが &lt;code&gt;scoped_lock&lt;/code&gt; オブジェクトが作成されたスコープを離れると、 &lt;code&gt;scoped_lock&lt;/code&gt; が破棄され、ミューテックスが逆の順序で解放されます。 複数のミューテックスが指定されている場合は、デッドロック回避アルゴリズムが &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; よるかのように使用されます 。</target>
        </trans-unit>
        <trans-unit id="303d35d938cb833eac9338017dabe149a1c1712f" translate="yes" xml:space="preserve">
          <source>When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">基本クラスが多態的な使用を目的としている場合、そのデストラクタをパブリックおよび仮想として宣言する必要がある場合があります。 これは暗黙の移動をブロックし（暗黙のコピーを非推奨にする）、そのため、特別なメンバー関数をデフォルトとして宣言する必要があります&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a38cdff86c855a9f5b8dafef92329da17987f83a" translate="yes" xml:space="preserve">
          <source>When a block declaration appears &lt;a href=&quot;statements#Compound_statements&quot;&gt;inside a block&lt;/a&gt;, and an identifier introduced by a declaration was previously declared in an outer block, the &lt;a href=&quot;scope&quot;&gt;outer declaration is hidden&lt;/a&gt; for the remainder of the block.</source>
          <target state="translated">ブロック宣言がblock &lt;a href=&quot;statements#Compound_statements&quot;&gt;内にあり&lt;/a&gt; 、宣言によって導入された識別子が以前に外部ブロックで宣言されていた場合、 &lt;a href=&quot;scope&quot;&gt;外部宣言は&lt;/a&gt;ブロックの残りの部分に対して非表示になります。</target>
        </trans-unit>
        <trans-unit id="da9117b375eefc957e65150185d8008bdc45763a" translate="yes" xml:space="preserve">
          <source>When a class or variable(since C++14) template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations.</source>
          <target state="translated">クラスまたは変数(C++14 以降)のテンプレートがインスタンス化され、部分的な特殊化が利用可能な場合、コンパイラはプライマリ・テンプレートを使用するか、その部分的な特殊化のいずれかを使用するかを決定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="fea65df3178fced8b0ade7c9ce2a6ba4bc611c76" translate="yes" xml:space="preserve">
          <source>When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is</source>
          <target state="translated">クラステンプレートの特殊化が完全なオブジェクト型を必要とするコンテキストで参照される場合、関数テンプレートの特殊化が関数定義の存在を必要とするコンテキストで参照される場合、テンプレートは</target>
        </trans-unit>
        <trans-unit id="5769c7acaf1d2335b2ca90b0ec55efa0d236a336" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">クラスが &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;メンバーアクセス指定子&lt;/a&gt;を使用してベースから派生する場合、ベースクラスのすべてのパブリックおよび保護されたメンバーは、派生クラスのプライベートメンバーとしてアクセスできます（ベースのプライベートメンバーは、フレンドでない限りアクセスできません）。</target>
        </trans-unit>
        <trans-unit id="2fcd782f662cbfb240e5bd78fca278b024889cc7" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;protected&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">クラスが &lt;code&gt;protected&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;メンバーアクセス指定子&lt;/a&gt;を使用してベースから派生する場合、基本クラスのすべてのパブリックおよび保護されたメンバーは、派生クラスの保護されたメンバーとしてアクセスできます（ベースのプライベートメンバーは、フレンドでない限りアクセスできません）。</target>
        </trans-unit>
        <trans-unit id="774bfe4108db2bde44499cb4a6ab68ddca8b923c" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;public&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">クラスが &lt;code&gt;public&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;メンバーアクセス指定子&lt;/a&gt;を使用してベースから派生する場合、ベースクラスのすべてのパブリックメンバーは派生クラスのパブリックメンバーとしてアクセスでき、ベースクラスのすべての保護メンバーは派生クラスの保護メンバー（プライベートメンバー）としてアクセスできますベースの）は、友だちでない限りアクセスできません）。</target>
        </trans-unit>
        <trans-unit id="731c55e17d6e6e68ab60a46f9b70a72e60e6dd67" translate="yes" xml:space="preserve">
          <source>When a complete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">出力の完全な行をフラッシュする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; マニピュレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="c302c1bc7c6fed86bcea489bc973092937f86e79" translate="yes" xml:space="preserve">
          <source>When a coroutine begins execution, it performs the following:</source>
          <target state="translated">コアーチンが実行を開始すると、以下の処理を行います。</target>
        </trans-unit>
        <trans-unit id="f150d08af5c8d72aecd740bc32ce2f1f91de3c2d" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches a suspension point.</source>
          <target state="translated">コロチンが懸垂点に達すると</target>
        </trans-unit>
        <trans-unit id="0c56a2828a8dc079acafa0f6578250d1ca9ad491" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches the &lt;code&gt;co_return&lt;/code&gt; statement, it performs the following:</source>
          <target state="translated">コルーチンが &lt;code&gt;co_return&lt;/code&gt; ステートメントに到達すると、次の処理が実行されます。</target>
        </trans-unit>
        <trans-unit id="cf467bf3385d5e1232a7b50fd987d1bda1eb5b07" translate="yes" xml:space="preserve">
          <source>When a feature changes significantly, the macro will be updated accordingly.</source>
          <target state="translated">機能が大きく変更された場合は、それに応じてマクロが更新されます。</target>
        </trans-unit>
        <trans-unit id="a1204ab37d3f0482e454433db039fd14f2d10599" translate="yes" xml:space="preserve">
          <source>When a file is included, it is processed by &lt;a href=&quot;../language/translation_phases&quot;&gt;translation phases&lt;/a&gt; 1-4, which may include, recursively, expansion of the nested &lt;code&gt;#include&lt;/code&gt; directives. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively,</source>
          <target state="translated">ファイルがインクルードされると、ネストされた &lt;code&gt;#include&lt;/code&gt; ディレクティブの展開を再帰的に含めることができる&lt;a href=&quot;../language/translation_phases&quot;&gt;変換フェーズ&lt;/a&gt; 1〜4によって処理されます。 同じファイルが繰り返しインクルードされたり、ファイルにそれ自体が含まれているときに無限に再帰したりしないようにするには、</target>
        </trans-unit>
        <trans-unit id="0f6ee751ce2ae6f2e1fe4fc82e2efbe71ee15f4f" translate="yes" xml:space="preserve">
          <source>When a friend declaration refers to a full specialization of a function template, the keyword &lt;code&gt;inline&lt;/code&gt; and default arguments cannot be used.</source>
          <target state="translated">フレンド宣言が関数テンプレートの完全な特殊化を参照する場合、キーワード &lt;code&gt;inline&lt;/code&gt; とデフォルト引数は使用できません。</target>
        </trans-unit>
        <trans-unit id="dd03b884a832ad273a2adbacad6fb75f476bfdf0" translate="yes" xml:space="preserve">
          <source>When a function is invoked, e.g. in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function-call expression&lt;/a&gt;, the parameters are initialized from the arguments (either provided at the place of call or &lt;a href=&quot;default_arguments&quot;&gt;defaulted&lt;/a&gt;) and the statements in the function body are executed.</source>
          <target state="translated">関数が呼び出されたとき（関数&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;呼び出し式&lt;/a&gt;など）、パラメーターは引数（呼び出しの場所で提供されるか、 &lt;a href=&quot;default_arguments&quot;&gt;デフォルトで指定される&lt;/a&gt; ）から初期化され、関数本体のステートメントが実行されます。</target>
        </trans-unit>
        <trans-unit id="056da6db0024a8fc9e2178af3caa77a54e3aa303" translate="yes" xml:space="preserve">
          <source>When a function's return type is lvalue reference, the function call expression becomes an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;:</source>
          <target state="translated">関数の戻り値の型が左辺値参照の場合、関数呼び出し式は&lt;a href=&quot;value_category&quot;&gt;左辺値式に&lt;/a&gt;なります 。</target>
        </trans-unit>
        <trans-unit id="4616bf2b5d98e8563f41341866c844e7ac6e8d1f" translate="yes" xml:space="preserve">
          <source>When a function-style cast or declaration of a variable uses the name of a primary class template &lt;code&gt;C&lt;/code&gt; without an argument list as the type specifier, deduction will proceed as follows:</source>
          <target state="translated">関数スタイルのキャストまたは変数の宣言で、型指定子として引数リストなしのプライマリクラステンプレート &lt;code&gt;C&lt;/code&gt; の名前を使用すると、演繹は次のように行われます。</target>
        </trans-unit>
        <trans-unit id="703e91dee14a5d41272ff0618515064124c5ca74" translate="yes" xml:space="preserve">
          <source>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable &lt;code&gt;m&lt;/code&gt; is treated as an expression &lt;code&gt;(*this).m&lt;/code&gt;, and &lt;code&gt;*this&lt;/code&gt; is always implicitly captured by reference:</source>
          <target state="translated">ラムダが暗黙的なby-copyキャプチャを使用してメンバーをキャプチャする場合、そのメンバー変数のコピーは作成されません。メンバー変数 &lt;code&gt;m&lt;/code&gt; の使用は式 &lt;code&gt;(*this).m&lt;/code&gt; として扱われ、 &lt;code&gt;*this&lt;/code&gt; は常に暗黙的にキャプチャされます参照により：</target>
        </trans-unit>
        <trans-unit id="3ea6ad3dcd073f66ca30ba43dbc0f20952f4603c" translate="yes" xml:space="preserve">
          <source>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt;, not the global functions:</source>
          <target state="translated">ローカルクラスが非修飾関数またはクラスをフレンドとして宣言すると、グローバル関数ではなく、最も内側の非クラススコープ内の関数とクラスのみが&lt;a href=&quot;lookup&quot;&gt;検索され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8b46570618f5daf88923faf7d12da8873e3be80a" translate="yes" xml:space="preserve">
          <source>When a member is redeclared within the same class, it must do so under the same member access:</source>
          <target state="translated">同じクラス内でメンバを再宣言する場合は、同じメンバ・アクセスの下で再宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="f224ac0d371f052e58a2217d4de98b1976737b0e" translate="yes" xml:space="preserve">
          <source>When a non-static class member is used in any of the contexts where the &lt;code&gt;this&lt;/code&gt; keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; is automatically added before the name, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードが許可されているコンテキスト（非静的メンバー関数本体、メンバー初期化子リスト、デフォルトのメンバー初期化子）で非静的クラスメンバーが使用されている場合、暗黙の &lt;code&gt;this-&amp;gt;&lt;/code&gt; が名前の前に自動的に追加され、結果メンバーアクセス式（メンバーが仮想メンバー関数の場合は、仮想関数呼び出しになります）。</target>
        </trans-unit>
        <trans-unit id="c996fe1da1454bb286aadf030b85cfad7cae8fed" translate="yes" xml:space="preserve">
          <source>When a pointer to a protected member is formed, it must use a derived class in its declaration:</source>
          <target state="translated">保護されたメンバへのポインタが形成される場合、その宣言には派生クラスを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7fe22ece7b8d4604836b61b68f07304156388fd8" translate="yes" xml:space="preserve">
          <source>When a qualified name is used as a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, then &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt; of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:</source>
          <target state="translated">修飾名が&lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;として使用される場合、その修飾名の後に続く同じ宣言子で使用されているが、その前の名前ではない名前の&lt;a href=&quot;unqualified_lookup&quot;&gt;非修飾ルックアップ&lt;/a&gt;は、メンバーのクラスまたは名前空間のスコープで実行されます。</target>
        </trans-unit>
        <trans-unit id="7128500ddb4a19baad89fa94da4a6a51b2aa2144" translate="yes" xml:space="preserve">
          <source>When a signaling NaN is used as an argument to an arithmetic expression, the appropriate floating-point exception may be raised and the NaN is &quot;quieted&quot;, that is, the expression returns a quiet NaN.</source>
          <target state="translated">シグナリングNaNが算術式の引数として使用される場合、適切な浮動小数点例外が発生し、NaNが &quot;quieted&quot;、つまり式がquietなNaNを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="7f3acde83607f5ff6b438f0d494f026c16dc4d51" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">スレッドが &lt;code&gt;mutex&lt;/code&gt; を所有している場合、他のすべてのスレッドは、 &lt;code&gt;mutex&lt;/code&gt; の所有権を主張しようとすると、ブロックする（ &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; の&lt;/a&gt;呼び出しの場合）か、 &lt;code&gt;false&lt;/code&gt; 戻り値（ &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; の&lt;/a&gt;場合）を受け取ります。</target>
        </trans-unit>
        <trans-unit id="48235a61557c038c024774d3984da66f889dd511" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;recursive_mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;recursive_mutex&lt;/code&gt;.</source>
          <target state="translated">スレッドが &lt;code&gt;recursive_mutex&lt;/code&gt; を所有している場合、他のすべてのスレッドは、 &lt;code&gt;recursive_mutex&lt;/code&gt; の所有権を主張しようとすると、ブロックするか（ &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; の&lt;/a&gt;呼び出しの場合）、 &lt;code&gt;false&lt;/code&gt; 戻り値（ &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; の&lt;/a&gt;場合）を受け取ります。</target>
        </trans-unit>
        <trans-unit id="78d07a1734d460127f218d90a8985eff2cc5268d" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">スレッドがメモリロケーションから値を読み取るとき、初期値、同じスレッドに書き込まれた値、または別のスレッドに書き込まれた値が表示される場合があります。 スレッドから行われた書き込みが他のスレッドから見えるようになる順序の詳細については、 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="35914adcda38d9bc606dedbc8e87f226f4c33d60" translate="yes" xml:space="preserve">
          <source>When a unary fold is used with a pack expansion of length zero, only the following operators are allowed:</source>
          <target state="translated">長さ0のパック展開で単項折りを使う場合は、以下の演算子のみが許されます。</target>
        </trans-unit>
        <trans-unit id="a5725eb8b03373883cd17dd14b578f1aefe9ae18" translate="yes" xml:space="preserve">
          <source>When a union is initialized by aggregate initialization, only its first non-static data member is initialized.</source>
          <target state="translated">ユニオンが集約初期化によって初期化されると、その最初の非静的データメンバのみが初期化されます。</target>
        </trans-unit>
        <trans-unit id="75156726fb61b37daeae849a8c23a8d3e99ac431" translate="yes" xml:space="preserve">
          <source>When a user-defined class overloads the function call operator, &lt;code&gt;operator()&lt;/code&gt;, it becomes a &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; type. Many standard algorithms, from &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; accept objects of such types to customize behavior. There are no particularly notable canonical forms of &lt;code&gt;operator()&lt;/code&gt;, but to illustrate the usage.</source>
          <target state="translated">ユーザー定義クラスが関数呼び出し演算 &lt;code&gt;operator()&lt;/code&gt; オーバーロードすると、それは&lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;型になります。 &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; までの多くの標準アルゴリズムは、そのようなタイプのオブジェクトを受け入れて動作をカスタマイズします。 &lt;code&gt;operator()&lt;/code&gt; の特に注目すべき正規形はありませんが、使用法を説明するためのものです。</target>
        </trans-unit>
        <trans-unit id="48f53b62820f7fe3746951152075f1cdb1ddd004" translate="yes" xml:space="preserve">
          <source>When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt;, each argument that is a part of the variable argument list undergoes additional conversions known as</source>
          <target state="translated">可変個引数関数が呼び出されると、左辺値から右辺値、配列からポインタ、関数からポインタ&lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;への変換の&lt;/a&gt;後、可変引数リストの一部である各引数は、次のように知られる追加の変換を受けます。</target>
        </trans-unit>
        <trans-unit id="4fc2bc7f5954311ab6cd53cf773a77f33b1fad76" translate="yes" xml:space="preserve">
          <source>When a virtual function call is made, the type returned by the final overrider is &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the return type of the overridden function that was called:</source>
          <target state="translated">仮想関数呼び出しが行われると、最後のオーバーライドによって返される型は、呼び出されたオーバーライドされた関数の戻り型に&lt;a href=&quot;implicit_cast&quot;&gt;暗黙的に変換さ&lt;/a&gt;れます。</target>
        </trans-unit>
        <trans-unit id="93489141e89c6d227a8966329ac45e5e0c099d81" translate="yes" xml:space="preserve">
          <source>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class&amp;rsquo;s non-static data members, e.g. in a member &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor&amp;rsquo;s or destructor&amp;rsquo;s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</source>
          <target state="translated">仮想関数がコンストラクターまたはデストラクターから直接または間接的に呼び出されたとき（メンバーの&lt;a href=&quot;constructor&quot;&gt;初期化子リスト&lt;/a&gt;内のクラスの非静的データメンバーの構築中または破棄中を含む）、呼び出しが適用されるオブジェクトが作成中または破棄中のオブジェクトの場合、呼び出される関数は、コンストラクターまたはデストラクタのクラスの最後のオーバーライドであり、より派生したクラスでオーバーライドするものではありません。 つまり、構築中または破棄中は、より派生的なクラスは存在しません。</target>
        </trans-unit>
        <trans-unit id="c93bab45e9c1d0dfc9ec2e952c16e1c1852bb4fb" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include padding bits,(until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">弱い比較と交換がループを必要とし、強いものはループを必要としない場合、 &lt;code&gt;T&lt;/code&gt; のオブジェクト表現にパディングビットが含まれるか、（C ++ 20まで）トラップビットが含まれないか、複数のオブジェクト表現が提供されない限り、強いものが望ましい同じ値（たとえば、浮動小数点NaN）。 これらの場合、弱い比較と交換は、安定したオブジェクト表現にすばやく収束するため、通常は機能します。</target>
        </trans-unit>
        <trans-unit id="b549d145a45bd55485a97603e36455b405b7f9e4" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">弱い比較と交換がループを必要とし、強いものはループを必要としない場合、 &lt;code&gt;T&lt;/code&gt; のオブジェクト表現にトラップビットが含まれるか、同じ値に対して複数のオブジェクト表現（たとえば、浮動小数点NaN）が提供されない限り、強力なものが望ましい）。 これらの場合、弱い比較と交換は、安定したオブジェクト表現にすばやく収束するため、通常は機能します。</target>
        </trans-unit>
        <trans-unit id="3267a8eb3fe0cea3cd97459c2f9b3b8e6692761b" translate="yes" xml:space="preserve">
          <source>When active member of a union is switched by an assignment expression of the form &lt;code&gt;E1 = E2&lt;/code&gt; that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of &lt;code&gt;E1&lt;/code&gt; that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</source>
          <target state="translated">&lt;code&gt;E1 = E2&lt;/code&gt; のメンバーアクセスおよび配列の添え字のサブ式に表示される各ユニオンメンバーXについて、組み込みの代入演算子または自明な代入演算子のいずれかを使用するE1 = E2形式の割り当て式によって、ユニオンのアクティブメンバーが切り替えられた場合これは、自明ではない、または削除されたデフォルトコンストラクターを持つクラスではありません。Xの変更が型エイリアス規則の下で未定義の動作をする場合、X型のオブジェクトが指定されたストレージに暗黙的に作成されます。 初期化は行われず、その存続期間の開始は、左と右のオペランドの値の計算後、割り当ての前にシーケンスされます。</target>
        </trans-unit>
        <trans-unit id="d56d5c0d1a9783bd328d5ceefac5e3f1fa5681a7" translate="yes" xml:space="preserve">
          <source>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.</source>
          <target state="translated">すべてのテンプレート引数がデフォルトのテンプレート引数から指定、推論、または取得されている場合、関数パラメータリスト内のテンプレート引数の使用はすべて、対応するテンプレート引数に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b6e6698c4323b10a60e0746ae78192f4bab23b17" translate="yes" xml:space="preserve">
          <source>When allocating an object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; or an array of such objects, the new-expression passes the alignment requirement (wrapped in &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) as the second argument for the allocation function (for placement forms, &lt;code&gt;placement_params&lt;/code&gt; appear after the alignment, as the third, fourth, etc arguments). If overload resolution fails (which happens when a class-specific allocation function is defined with a different signature, since it hides the globals), overload resolution is attempted a second time, without alignment in the argument list. This allows alignment-unaware class-specific allocation functions to take precedence over the global alignment-aware allocation functions.</source>
          <target state="translated">配置要件が &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; またはそのようなオブジェクトの配列を超えるオブジェクトを割り当てる場合、new-expressionは配置要件（ &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ラップされている）を配置関数の2番目の引数として渡します（配置フォームの場合、 &lt;code&gt;placement_params&lt;/code&gt; 後には、 positioning_paramsが表示されます） 、3番目、4番目などの引数として）。 オーバーロードの解決が失敗した場合（グローバルを非表示にするため、クラス固有の割り当て関数が別のシグネチャで定義されている場合に発生します）、引数リストの調整なしで、もう一度オーバーロードの解決が試行されます。 これにより、整列に対応しないクラス固有の割り当て関数を、グローバルな整列に対応する割り当て関数よりも優先させることができます。</target>
        </trans-unit>
        <trans-unit id="32f253fd06f69fca2aca9bf86ab82833c3ab166b" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</source>
          <target state="translated">配置が &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; を超えるオブジェクトおよびオブジェクトの配列を割り当てる場合、配置フォームのオーバーロード解決は、通常のフォームの場合と同じように2回実行されます。</target>
        </trans-unit>
        <trans-unit id="fc6458ca664e9adb25872544f8c6cbc1b8d2ef56" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</source>
          <target state="translated">アライメントが &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; を超えるオブジェクトとオブジェクトの配列を割り当てる場合、オーバーロードの解決は2回実行されます。最初に、アライメント対応の関数シグネチャに対して、次にアライメント非対応の関数シグネチャに対してです。 これは、拡張配置のあるクラスに配置非対応のクラス固有の割り当て関数がある場合、呼び出されるのはグローバル配置対応の割り当て関数ではなく、その関数であることを意味します。 これは意図的なものです。クラスのメンバーは、そのクラスの処理方法を最もよく知っていることが求められます。</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">式の&lt;a href=&quot;eval_order&quot;&gt;評価&lt;/a&gt;がメモリロケーションに書き込み、別の評価が同じメモリロケーションを読み取るか変更するとき、式は</target>
        </trans-unit>
        <trans-unit id="f54b782cb8a2443df3f24c71942278de560d6c94" translate="yes" xml:space="preserve">
          <source>When an exception of type &lt;code&gt;E&lt;/code&gt; is thrown by any statement in compound-statement, it is matched against the types of the formal parameters &lt;code&gt;T&lt;/code&gt; of each catch-clause in handler-seq, in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</source>
          <target state="translated">タイプ &lt;code&gt;E&lt;/code&gt; の例外が複合文のステートメントによってスローされると、catch句がリストされている順に、handler-seqの各catch句の仮パラメータ &lt;code&gt;T&lt;/code&gt; のタイプと照合されます。 例外は、次のいずれかに該当する場合の一致です。</target>
        </trans-unit>
        <trans-unit id="141971b19d6009b0db3fb823a2039b332a4e6a99" translate="yes" xml:space="preserve">
          <source>When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.</source>
          <target state="translated">明示的なインスタンス化がクラス・テンプレートの専門化を名付ける場合、それは、以前に翻訳単位で明示的に専門化されていない、その非継承非テンプレート・メンバのそれぞれの同種の明示的なインスタンス化(宣言または定義)として機能します。この明示的なインスタンス化が定義である場合、この時点で定義されているメンバのみの明示的なインスタンス化定義でもあります。</target>
        </trans-unit>
        <trans-unit id="2e3df706304532f1fafe99d11c7b971952d33cd6" translate="yes" xml:space="preserve">
          <source>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:</source>
          <target state="translated">型または非型のテンプレート・パラメータを使用する式が関数パラメータ・リストまたは戻り値の型に現れた場合、その式はオーバーロードの目的で関数テンプレート・シグネチャの一部として残ります。</target>
        </trans-unit>
        <trans-unit id="d6a2958786f5f2e3f6b231cd1ab5ade2e4415a58" translate="yes" xml:space="preserve">
          <source>When an incomplete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">不完全な出力行をフラッシュする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; マニピュレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="ddca8d5dd1fab756efa48fbbb7d3a9d39e978269" translate="yes" xml:space="preserve">
          <source>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, or part of type-id in a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;) determine the constness or volatility of the object, as follows:</source>
          <target state="translated">オブジェクトが最初に作成されるとき、使用されるcv-qualifiers（decl-specifier-seqの一部、または&lt;a href=&quot;declarations&quot;&gt;宣言の宣言子の&lt;/a&gt;一部、または&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;のtype-idの一部である可能性があります ）は、次の定数または揮発性を決定します次のようなオブジェクト：</target>
        </trans-unit>
        <trans-unit id="d130a7fb0dc18dd843e992986efede0bda37daa7" translate="yes" xml:space="preserve">
          <source>When an object of class type X is passed to or returned from a function, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.</source>
          <target state="translated">クラス型 X のオブジェクトが関数に渡されるか、関数から返される場合、X の各コピーコンストラクタ、移動コンストラクタ、およびデストラクタが trivial または deleted のいずれかであり、X には少なくとも 1 つの削除されていないコピーコンストラクタまたは移動コンストラクタがある場合、実装では関数のパラメータまたは結果オブジェクトを保持するための一時オブジェクトを作成することができます。</target>
        </trans-unit>
        <trans-unit id="01dd171c098fe6b55329621a15cc7367dee5f1d4" translate="yes" xml:space="preserve">
          <source>When an object of class type is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; outside a &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; context, the candidate functions are all constructors of the class being initialized. The argument list is the expression list of the initializer.</source>
          <target state="translated">クラス型のオブジェクトが&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期化&lt;/a&gt;コンテキストの外で&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;または&lt;a href=&quot;default_initialization&quot;&gt;デフォルト&lt;/a&gt; 初期化される場合、候補関数はすべて、初期化されるクラスのコンストラクターです。 引数リストは、初期化子の式リストです。</target>
        </trans-unit>
        <trans-unit id="b112f8307a878b858abe15c415401e098531c633" translate="yes" xml:space="preserve">
          <source>When an object of class type is copy-initialized from an object of the same or derived class type, or default-initialized in a copy-initialization context, the candidate functions are all &lt;a href=&quot;converting_constructor&quot;&gt;converting constructors&lt;/a&gt; of the class being initialized. The argument list is the expression of the initializer.</source>
          <target state="translated">クラス型のオブジェクトが同じまたは派生クラス型のオブジェクトからコピー初期化されるか、コピー初期化コンテキストでデフォルト初期化されると、候補関数はすべて、初期化されるクラスの&lt;a href=&quot;converting_constructor&quot;&gt;コンストラクター&lt;/a&gt;を変換します。 引数リストは、初期化子の式です。</target>
        </trans-unit>
        <trans-unit id="6c417ae51346e00b8f2e04143715b97da243d164" translate="yes" xml:space="preserve">
          <source>When an object of non-aggregate class type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;, two-phase overload resolution takes place.</source>
          <target state="translated">非集合クラスタイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトが&lt;a href=&quot;list_initialization&quot;&gt;list-initializedの&lt;/a&gt;場合、2フェーズのオーバーロード解決が行われます。</target>
        </trans-unit>
        <trans-unit id="ae6288b4e0c89ad0ee91c5bb7ab0d2b10cfef5c7" translate="yes" xml:space="preserve">
          <source>When an object of some class &lt;code&gt;C&lt;/code&gt; is created, each non-static data member of non-reference type is allocated in some part of the object representation of &lt;code&gt;C&lt;/code&gt;. Whether reference members occupy any storage is implementation-defined, but their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is the same as that of the object in which they are members.</source>
          <target state="translated">あるクラス &lt;code&gt;C&lt;/code&gt; のオブジェクトが作成されると、非参照型の各非静的データメンバーが &lt;code&gt;C&lt;/code&gt; のオブジェクト表現の一部に割り当てられます。 参照メンバーがストレージを占有するかどうかは実装定義ですが、それらの&lt;a href=&quot;storage_duration&quot;&gt;ストレージ期間&lt;/a&gt;は、メンバーがメンバーであるオブジェクトのストレージ期間と同じです。</target>
        </trans-unit>
        <trans-unit id="63af81fffbdf1a90668b23768fdc0980bed3770a" translate="yes" xml:space="preserve">
          <source>When an object of type optional&amp;lt;T&amp;gt; is &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted to bool&lt;/a&gt;, the conversion returns &lt;code&gt;true&lt;/code&gt; if the object</source>
          <target state="translated">タイプoptional &amp;lt;T&amp;gt;のオブジェクトが&lt;a href=&quot;../language/implicit_cast&quot;&gt;コンテキストに応じてbool&lt;/a&gt;に変換されると 、オブジェクトが</target>
        </trans-unit>
        <trans-unit id="1564a3bf1abdab4804c3b45d781d0743bc25fc6d" translate="yes" xml:space="preserve">
          <source>When an operator appears in an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;, and at least one of its operands has a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; or an &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is used to determine the user-defined function to be called among all the functions whose signatures match the following:</source>
          <target state="translated">演算子が&lt;a href=&quot;expressions&quot;&gt;式&lt;/a&gt;に出現し、そのオペランドの少なくとも1つが&lt;a href=&quot;class&quot;&gt;クラス型&lt;/a&gt;または&lt;a href=&quot;enum&quot;&gt;列挙型&lt;/a&gt;である場合、 &lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;を使用して、シグニチャーが以下に一致するすべての関数の中で呼び出されるユーザー定義関数を決定します。</target>
        </trans-unit>
        <trans-unit id="fb0096bc731b7218f872e304d201c5d20ef5e918" translate="yes" xml:space="preserve">
          <source>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">スコープ外の列挙がクラスメンバーである場合、その列挙子にはクラスメンバーアクセス演算子を使用してアクセスできます &lt;code&gt;.&lt;/code&gt; および &lt;code&gt;-&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6f67767f1271f59038f6527a10110416f4a16657" translate="yes" xml:space="preserve">
          <source>When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.</source>
          <target state="translated">クラス型に適用した場合、結果はそのクラスのオブジェクトのサイズに加えて、そのようなオブジェクトを配列に配置するために必要な追加のパディングを加えたものとなります。</target>
        </trans-unit>
        <trans-unit id="ad0c1d3f6453f804c34d81d7a95f3f37e5786005" translate="yes" xml:space="preserve">
          <source>When applied to a class, the identifier &lt;code&gt;final&lt;/code&gt; appears at the beginning of the class definition, immediately after the name of the class.</source>
          <target state="translated">クラスに適用されると、識別子 &lt;code&gt;final&lt;/code&gt; は、クラス定義の先頭、クラス名の直後に表示されます。</target>
        </trans-unit>
        <trans-unit id="ebcafd6f66dd47f9f7ba53777289ab2dbc04fbca" translate="yes" xml:space="preserve">
          <source>When applied to a member function, the identifier &lt;code&gt;final&lt;/code&gt; appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">メンバー関数に適用される場合、識別子 &lt;code&gt;final&lt;/code&gt; は、メンバー関数宣言の構文またはクラス定義内のメンバー関数定義の&lt;a href=&quot;function&quot;&gt;宣言子の&lt;/a&gt;直後に表示されます。</target>
        </trans-unit>
        <trans-unit id="64935cc54ab77b2b7e3b4674a370a21df9f2ba1a" translate="yes" xml:space="preserve">
          <source>When applied to a pointer, the subscript expression is always an lvalue.</source>
          <target state="translated">ポインタに適用される場合、添え字式は常に lvalue です。</target>
        </trans-unit>
        <trans-unit id="3fa5cb2eff44efae521c7cddc759eb971197f991" translate="yes" xml:space="preserve">
          <source>When applied to a reference type, the result is the size of the referenced type.</source>
          <target state="translated">参照型に適用すると、結果は参照型のサイズになります。</target>
        </trans-unit>
        <trans-unit id="f4ae2ed79afdeb8f6c2a098503944e0bac2fe877" translate="yes" xml:space="preserve">
          <source>When applied to an array, the subscript expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; if the array is an lvalue, and an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; if it isn't(since C++11).</source>
          <target state="translated">配列に適用される場合、添え字式は、配列が&lt;a href=&quot;value_category&quot;&gt;左辺値の&lt;/a&gt;場合は左辺値であり、 &lt;a href=&quot;value_category&quot;&gt;そうで&lt;/a&gt;ない場合は左辺値です（C ++ 11以降）。</target>
        </trans-unit>
        <trans-unit id="b3759c1c966a143bdfd4814a06fb7b793ddc31c8" translate="yes" xml:space="preserve">
          <source>When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), otherwise typeid expression is resolved at compile time.</source>
          <target state="translated">多相型の式に適用される場合、typeid式の評価は実行時のオーバーヘッド(仮想テーブル検索)を伴う場合がありますが、そうでない場合はコンパイル時にtypeid式は解決されます。</target>
        </trans-unit>
        <trans-unit id="e5ed37890741158bbf054cf52a8ebbc0e73b98c9" translate="yes" xml:space="preserve">
          <source>When applied to an expression, &lt;code&gt;sizeof&lt;/code&gt; does &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;not evaluate the expression&lt;/a&gt;, and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Temporary materialization&lt;/a&gt;, however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object.(since C++17).</source>
          <target state="translated">式に適用した場合、 &lt;code&gt;sizeof&lt;/code&gt; は&lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;式を評価&lt;/a&gt;せず、式が多相オブジェクトを指定していても、結果は式の静的型のサイズになります。 左辺値から右辺値、配列からポインタ、関数からポインタへの変換は実行されません。 ただし、 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;一時的な実体化&lt;/a&gt;は（正式には）prvalue引数に対して実行されます。sizeofは結果オブジェクトのサイズを決定します（C ++ 17以降）。</target>
        </trans-unit>
        <trans-unit id="902efcbdae8639c2479afc412e93c5b16435e58a" translate="yes" xml:space="preserve">
          <source>When calling the allocation function, the new-expression passes the number of bytes requested as the first argument, of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, which is exactly &lt;code&gt;sizeof(T)&lt;/code&gt; for non-array &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">割り当て関数を呼び出すとき、new-expressionは、要求されたバイト数を &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; タイプの最初の引数として渡します。これは、非配列 &lt;code&gt;T&lt;/code&gt; の正確な &lt;code&gt;sizeof(T)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7aab9cd14cb0a3097419a3a095e5a8499afb16ff" translate="yes" xml:space="preserve">
          <source>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from context.</source>
          <target state="translated">コードが関数定義の存在を必要とするコンテキストで関数を参照し、この特定の関数が明示的にインスタンス化されていない場合、暗黙的なインスタンス化が発生します。 テンプレート引数のリストは、コンテキストから&lt;a href=&quot;template_argument_deduction&quot;&gt;推定&lt;/a&gt;できる場合は指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2f3a994250d478ff5309a561ec4f4f714968e84d" translate="yes" xml:space="preserve">
          <source>When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.</source>
          <target state="translated">コードが完全に定義された型を必要とするコンテキストでテンプレートを参照している場合、あるいは型の完全性がコードに影響を与え、この特定の型が明示的にインスタンス化されていない場合、暗黙のインスタンス化が発生します。例えば、この型のオブジェクトが構築されても、この型へのポインタが構築されていない場合などです。</target>
        </trans-unit>
        <trans-unit id="e579a073bc59e27215b96008dac2e50df4bb57db" translate="yes" xml:space="preserve">
          <source>When comparing entire containers for equality, &lt;code&gt;operator==&lt;/code&gt; for the corresponding container are usually preferred.</source>
          <target state="translated">コンテナー全体が等しいか &lt;code&gt;operator==&lt;/code&gt; を比較する場合、通常、対応するコンテナーのoperator ==が推奨されます。</target>
        </trans-unit>
        <trans-unit id="47745284a6ed97288740ca09ddbb9f643055ef39" translate="yes" xml:space="preserve">
          <source>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one built-in type to another built-in type, only one standard conversion sequence is allowed.</source>
          <target state="translated">コンストラクタやユーザ定義の変換関数への引数を考慮する場合,標準的な変換シーケンスは1つだけ許されます(そうでなければ,ユーザ定義の変換が事実上連鎖してしまう可能性があります)。ある組み込み型から別の組み込み型に変換する場合,標準的な変換シーケンスは1つだけ許されます。</target>
        </trans-unit>
        <trans-unit id="553ce681044a1dac36f2a3c93df19f57a9078616" translate="yes" xml:space="preserve">
          <source>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</source>
          <target state="translated">複数のブランチを持つ複雑なクラスを構築する場合、1 つのブランチに属するコンストラクタ内では、ポリモーフィズムはそのクラスとそのベースに制限されます。このサブ階層外のベースサブオブジェクトへのポインタや参照を取得し、仮想関数呼び出しを実行しようとした場合 (明示的なメンバアクセスを使用するなど)、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="aed446bf94f330e6e0b55d02da8f34b88ffea9e7" translate="yes" xml:space="preserve">
          <source>When copy elision occurs, the implementation treats the source and target of the omitted copy/move(since C++11) operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization (except that, if the parameter of the selected constructor is an rvalue reference to object type, the destruction occurs when the target would have been destroyed)(since C++17).</source>
          <target state="translated">コピーエリジョンが発生した場合、実装では、省略された copyymove(C++11 以降)操作のソースとターゲットを単に同じオブジェクトを参照する 2 つの異なる方法として扱い、そのオブジェクトの破棄は、最適化を行わずに 2 つのオブジェクトが破棄されていたであろう時期のいずれか遅い時期に発生します(ただし、選択されたコンストラクタのパラメータがオブジェクト型への rvalue 参照である場合は、ターゲットが破棄されていたであろう時期に破棄が発生します)(C++17 以降)。</target>
        </trans-unit>
        <trans-unit id="2dc86f028e3cfb1147dc7e004b4c16749351361e" translate="yes" xml:space="preserve">
          <source>When copying overlapping ranges, &lt;code&gt;std::copy&lt;/code&gt; is appropriate when copying to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::copy_backward&lt;/code&gt; is appropriate when copying to the right (end of the destination range is outside the source range).</source>
          <target state="translated">重複する範囲をコピーするとき、左にコピーする場合（コピー先の範囲の先頭がソース範囲外）に &lt;code&gt;std::copy_backward&lt;/code&gt; が適切ですが、右にコピーする場合（コピー先範囲の末尾がソース範囲外）にstd :: copy_backwardが適切です範囲）。</target>
        </trans-unit>
        <trans-unit id="63771776b0fe78c4297c086089bcc7b025dc8ded" translate="yes" xml:space="preserve">
          <source>When declaring a function, &lt;a href=&quot;except_spec&quot;&gt; exception specifications&lt;/a&gt; and &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifiers&lt;/a&gt; may be provided to limit the types of the exceptions a function may throw.</source>
          <target state="translated">関数を宣言するとき、関数がスローする例外のタイプを制限するために、 &lt;a href=&quot;except_spec&quot;&gt;例外指定&lt;/a&gt;と&lt;a href=&quot;noexcept_spec&quot;&gt;noexcept指定子&lt;/a&gt;が提供される場合があります。</target>
        </trans-unit>
        <trans-unit id="a46821f25349d54835cd348827a97ba1db7215ad" translate="yes" xml:space="preserve">
          <source>When defining a member of an explicitly specialized class template outside the body of the class, the syntax &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; is not used, except if it's a member of an explicitly specialized member class template, which is specialized as a class template, because otherwise, the syntax would require such definition to begin with &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; required by the nested template.</source>
          <target state="translated">明示的に特殊化されたクラステンプレートのメンバーをクラスの本体の外で定義する場合、それがクラステンプレートとして特殊化された明示的に特殊化されたメンバークラステンプレートのメンバーである場合を除いて、構文 &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; は使用されません。構文では、ネストされたテンプレートに必要な &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; 始まる定義が必要です。</target>
        </trans-unit>
        <trans-unit id="80a330b63ba0a84c45e73880291aa572a3efa1e6" translate="yes" xml:space="preserve">
          <source>When determining if two &lt;a href=&quot;dependent_name&quot;&gt;dependent expressions&lt;/a&gt; are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:</source>
          <target state="translated">2つの&lt;a href=&quot;dependent_name&quot;&gt;従属式&lt;/a&gt;が等しいかどうかを判別する場合、関係する従属名のみが考慮され、名前の検索結果は考慮されません。 同じテンプレートの複数の宣言が名前検索の結果で異なる場合、最初のそのような宣言が使用されます。</target>
        </trans-unit>
        <trans-unit id="7ef9fbc568a29fc667929a02fb6d63098b804ede" translate="yes" xml:space="preserve">
          <source>When directly used as the condition of &lt;a href=&quot;../language/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt; declaration&lt;/a&gt; or &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if statement&lt;/a&gt;, &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; 宣言&lt;/a&gt;または&lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr ifステートメント&lt;/a&gt;の条件として直接使用される場合 、 &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; 常に &lt;code&gt;true&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="18b778058d4f47bf64716da2bbf948a1a5fb94a5" translate="yes" xml:space="preserve">
          <source>When earlier tiebreakers, including partial ordering, failed to distinguish between two candidate function templates, the following rules apply:</source>
          <target state="translated">部分的な順序付けを含む以前のタイブレーカーでは、2つの候補関数テンプレートを区別できなかった場合、以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="c5dfcd38376374c25b198c54aa21d3fdad95c984" translate="yes" xml:space="preserve">
          <source>When enabled, for an object &lt;code&gt;o&lt;/code&gt; of type &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; that contains a value, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; evaluates to the same value as &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt;. For an optional that does not contain a value, the hash is unspecified.</source>
          <target state="translated">有効にすると、値が含まれる &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; タイプのオブジェクト &lt;code&gt;o&lt;/code&gt; に対して、 &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; は &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt; と同じ値に評価されますstd :: remove_const_t &amp;lt;T &amp;gt;&amp;gt;（）（* o） 。 値を含まないオプションの場合、ハッシュは指定されていません。</target>
        </trans-unit>
        <trans-unit id="903d975e1994ac3a37b90733c8025f08ecf31a3c" translate="yes" xml:space="preserve">
          <source>When enabled,(since C++17) for a given &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt;, this specialization ensures that &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt;.</source>
          <target state="translated">有効にすると、（C ++ 17以降）特定の &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt; 、この特殊化により &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ae5f22223dec57ebaf47feb7ebf7c7e201fce6" translate="yes" xml:space="preserve">
          <source>When entering a catch clause, if its formal parameter is a base class of the exception type, it is &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; from the base class subobject of the exception object. Otherwise, it is copy-initialized from the exception object (this copy is subject to &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">catch句を入力するときに、仮パラメータが例外タイプの基本クラスである場合、例外オブジェクトの基本クラスサブオブジェクトから&lt;a href=&quot;copy_initialization&quot;&gt;コピー初期化さ&lt;/a&gt;れます。 それ以外の場合は、例外オブジェクトからコピー初期化されます（このコピーは&lt;a href=&quot;copy_elision&quot;&gt;コピー削除の&lt;/a&gt;対象です）。</target>
        </trans-unit>
        <trans-unit id="16fd800e4f4545dc8c54147c76bdffd06523fe14" translate="yes" xml:space="preserve">
          <source>When erasing at either end of the deque, references to non-erased elements are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">dequeの両端で消去する場合、消去されていない要素への参照は、 &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt; によって無効化されません。</target>
        </trans-unit>
        <trans-unit id="3e154c534821f10918bbd1a0adb594ebb17181d9" translate="yes" xml:space="preserve">
          <source>When every character of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">出力のすべての文字をフラッシュする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; マニピュレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="3a9eae4e1a206e51541973ab38f172716a809f23" translate="yes" xml:space="preserve">
          <source>When every output operation needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">すべての出力操作をフラッシュする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; マニピュレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="de9fb1f75fc610360e59b80abf945bf3f980c7f7" translate="yes" xml:space="preserve">
          <source>When formatting a floating point value as hexfloat (i.e., when &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.</source>
          <target state="translated">浮動小数点値をhexfloatとしてフォーマットする場合（つまり、 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ）、ストリームの精度は使用されません。 代わりに、数値は常に、値を正確に表すのに十分な精度で出力されます。</target>
        </trans-unit>
        <trans-unit id="a40d58e1eae50e8055be19035d8b5887a01317a2" translate="yes" xml:space="preserve">
          <source>When given reference types, &lt;code&gt;common_reference&lt;/code&gt; attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.</source>
          <target state="translated">参照タイプを &lt;code&gt;common_reference&lt;/code&gt; すると、 common_referenceは、提供された参照タイプをすべてバインドできる参照タイプを見つけようとしますが、そのような参照タイプが見つからない場合は、非参照タイプを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="dd4bc57db1751ca1bef7fa50506950271e3c5d18" translate="yes" xml:space="preserve">
          <source>When indexing C++ containers, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, etc, the appropriate type is the member typedef &lt;code&gt;size_type&lt;/code&gt; provided by such containers. It is usually defined as a synonym for &lt;code&gt;std::size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; などのC ++コンテナにインデックスを &lt;code&gt;size_type&lt;/code&gt; 場合、適切なタイプは、そのようなコンテナによって提供されるメンバーtypedef size_typeです。 通常、 &lt;code&gt;std::size_t&lt;/code&gt; 同義語として定義されています。</target>
        </trans-unit>
        <trans-unit id="9ac68fbcc8bc1efc6049dde60f0e30093d3a91f7" translate="yes" xml:space="preserve">
          <source>When initialization of an object of non-class type cv1 &lt;code&gt;T&lt;/code&gt; requires a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to convert from an initializer expression of class type cv &lt;code&gt;S&lt;/code&gt;, the following functions are candidates:</source>
          <target state="translated">非クラス型cv1 &lt;code&gt;T&lt;/code&gt; のオブジェクトの初期化で、クラス型cv &lt;code&gt;S&lt;/code&gt; の初期化式から&lt;a href=&quot;cast_operator&quot;&gt;変換&lt;/a&gt;するユーザー定義の変換関数が必要な場合 、次の関数が候補になります。</target>
        </trans-unit>
        <trans-unit id="f2f9ef8bbb329e61c10d08ae998e3ab7e71030d3" translate="yes" xml:space="preserve">
          <source>When initializing from a single argument of a type that is a specialization of the class template at issue, copying deduction is generally preferred over wrapping by default:</source>
          <target state="translated">問題のクラステンプレートの特殊化である型の単一引数から初期化する場合、一般的にデフォルトではラッピングよりもコピー推論の方が優先されます。</target>
        </trans-unit>
        <trans-unit id="d46960739a911c065792d3eb6a771bd67fb54134" translate="yes" xml:space="preserve">
          <source>When inserting a range, the range version of &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; is generally preferable as it preserves the correct capacity growth behavior, unlike &lt;code&gt;reserve()&lt;/code&gt; followed by a series of &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">範囲を挿入するときは、 &lt;code&gt;reserve()&lt;/code&gt; の後に一連の &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt; が続くのとは異なり、範囲のバージョンの &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; が正しい容量増加動作を維持するため、通常は望ましいバージョンです。</target>
        </trans-unit>
        <trans-unit id="906401050b55fc9b72b5d2421e9144fbb190452a" translate="yes" xml:space="preserve">
          <source>When inserting at either end of the deque, references are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">両端キューの両端に挿入する場合、参照は &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt; によって無効化されません。</target>
        </trans-unit>
        <trans-unit id="d58dc4a9c1d64bc2047ee755578c50f3b966be84" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic&lt;/code&gt; は、浮動小数点型 &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;long double&lt;/code&gt; のいずれかでインスタンス化されると、 &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;などの浮動小数点型に適した追加のアトミック操作を提供します。</target>
        </trans-unit>
        <trans-unit id="552f6dfa495a4acb2aa66f36a0ba5bf21b95fae5" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; は、浮動小数点型 &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;long double&lt;/code&gt; のいずれかでインスタンス化されると、 &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;などの浮動小数点型に適した追加のアトミック操作を提供します。</target>
        </trans-unit>
        <trans-unit id="5bac602845c57306b8db9e963ef0dfc1cad72696" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;std::atomic&lt;/code&gt; は、次の整数型のいずれかでインスタンス化されると、 &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; 、 fetch_xorなどの整数型に適した追加のアトミック操作を提供します。</target>
        </trans-unit>
        <trans-unit id="baa8ebba32798819cb5a6086f1e8129674336cd6" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; は、次の整数型のいずれかでインスタンス化されると、 &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; 、 fetch_xorなどの整数型に適した追加のアトミック操作を提供します。</target>
        </trans-unit>
        <trans-unit id="503d40b06333e935efd323a580b4acbb78349e5a" translate="yes" xml:space="preserve">
          <source>When it is needed to interpret the bytes of an object as a value of a different type, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;or &lt;a href=&quot;../numeric/bit_cast&quot;&gt;&lt;code&gt;std::bit_cast&lt;/code&gt;&lt;/a&gt;(since C++20)can be used:</source>
          <target state="translated">オブジェクトのバイトを別の型の値として解釈する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; または&lt;a href=&quot;../numeric/bit_cast&quot;&gt; &lt;code&gt;std::bit_cast&lt;/code&gt; &lt;/a&gt; （C ++ 20以降）を使用できます。</target>
        </trans-unit>
        <trans-unit id="5281af908beb7c5eb475c7aeb21afb60dcc9c864" translate="yes" xml:space="preserve">
          <source>When language specifications nest, the innermost specification is the one that is in effect.</source>
          <target state="translated">言語仕様がネストした場合、最も内側にある仕様が有効な仕様となります。</target>
        </trans-unit>
        <trans-unit id="016122add2c9877f6072526697f450c52a1f6394" translate="yes" xml:space="preserve">
          <source>When making an explicit call to the conversion function, the type-id is greedy: it is the longest possible sequence of tokens that is a valid type id (including attributes, if any):</source>
          <target state="translated">変換関数を明示的に呼び出す場合,type-idは貪欲です:有効なtype-id(属性がある場合は,属性を含む)であるトークンの最長のシーケンスです。</target>
        </trans-unit>
        <trans-unit id="c7b5147658508bc213c62aa761a47793df025adb" translate="yes" xml:space="preserve">
          <source>When moving overlapping ranges, &lt;code&gt;std::move&lt;/code&gt; is appropriate when moving to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::move_backward&lt;/code&gt; is appropriate when moving to the right (end of the destination range is outside the source range).</source>
          <target state="translated">オーバーラップする範囲を移動するとき、 &lt;code&gt;std::move&lt;/code&gt; は左に移動するとき（宛先範囲の先頭がソース範囲外）に適切 &lt;code&gt;std::move_backward&lt;/code&gt; が、 std :: move_backwardは右に移動するとき（宛先範囲の末尾がソース範囲外）に適切です範囲）。</target>
        </trans-unit>
        <trans-unit id="bcc9e1f7b6bbebc1441b5e338721e2a64a3a6fc2" translate="yes" xml:space="preserve">
          <source>When no more matches are found, copies the remaining non-matched characters to &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; where &lt;code&gt;last_m&lt;/code&gt; is a copy of the last match found.</source>
          <target state="translated">一致するものが見つからない場合は、一致しない残りの文字を &lt;code&gt;out&lt;/code&gt; &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; に &lt;code&gt;last_m&lt;/code&gt; コピーします。ここで、 last_mは最後に見つかった一致。</target>
        </trans-unit>
        <trans-unit id="a989818254cf8030ca8ff78fd514d37b03472368" translate="yes" xml:space="preserve">
          <source>When one of them is found by &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;normal unqualified lookup&lt;/a&gt; for the name to the left of the function-call operator, it inhibits &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">それらの1つが、関数呼び出し演算子の左側にある名前の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;通常の非修飾ルックアップ&lt;/a&gt;によって検出された場合 、 &lt;a href=&quot;../../language/adl&quot;&gt;引数依存のルックアップを禁止します&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1514e0d97ec7c21ec7cdc4fc2229658217c2a1d3" translate="yes" xml:space="preserve">
          <source>When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;lock-free&lt;/a&gt; -- it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).</source>
          <target state="translated">1つ以上のロックフリーアトミック関数が同時に実行されると、それらの少なくとも1つが完了することが保証されます（すべての標準ライブラリロックフリー操作は&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;ロックフリーです&lt;/a&gt; -ライブロックできないことを確認するのは実装の仕事です）キャッシュラインを継続的に盗むなど、他のスレッドによって無期限に）。</target>
        </trans-unit>
        <trans-unit id="c525266500bfb2286ded86306e069bde3c22c32c" translate="yes" xml:space="preserve">
          <source>When one statement is expected, but multiple statements need to be executed in sequence (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or a loop), a compound statement may be used:</source>
          <target state="translated">1つのステートメントが期待されているが、複数のステートメントを順番に実行する必要がある場合（たとえば、 &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;ステートメントまたはループ内）、複合ステートメントを使用できます。</target>
        </trans-unit>
        <trans-unit id="99ceddfac8288288bcf4a468dfcdde568e2b94f6" translate="yes" xml:space="preserve">
          <source>When only one thread that is not blocked in a standard library function executes an &lt;a href=&quot;../atomic&quot;&gt;atomic function&lt;/a&gt; that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;obstruction-free&lt;/a&gt;).</source>
          <target state="translated">標準ライブラリ関数でブロックされていない1つのスレッドのみがロックフリーの&lt;a href=&quot;../atomic&quot;&gt;アトミック関数&lt;/a&gt;を実行すると、その実行は必ず完了します（標準ライブラリのロックフリー操作はすべて&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;妨害なしです&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="be17634a4507a825d9841a9ec6ecaee80238b41e" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; and &lt;code&gt;*p++&lt;/code&gt; are parsed as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; and &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; or &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">式を解析する場合、上記の表のいくつかの行に優先順位でリストされている演算子は、より低い優先順位でその下にある行にリストされている演算子よりも（括弧によって）引数に強くバインドされます。 たとえば、式 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; および &lt;code&gt;*p++&lt;/code&gt; は &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; および &lt;code&gt;*(p++)&lt;/code&gt; として解析され、 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; または &lt;code&gt;(*p)++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">桁数のない指数で終わる不完全な浮動小数点値を解析する場合（変換指定子 &lt;code&gt;%f&lt;/code&gt; を使用して &lt;code&gt;&quot;100er&quot;&lt;/code&gt; を解析する場合など）、シーケンス &lt;code&gt;&quot;100e&quot;&lt;/code&gt; （おそらく有効な浮動小数点数の最長の接頭辞）が消費されます、 &lt;code&gt;&quot;r&quot;&lt;/code&gt; が残ったまま、マッチングエラーが発生します（消費されたシーケンスを浮動小数点数に変換できません）。 一部の既存の実装はこのルールに従わず、ロールバックして &lt;code&gt;&quot;100&quot;&lt;/code&gt; のみを消費し、 &lt;code&gt;&quot;er&quot;&lt;/code&gt; を残します（例えば、 &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibcバグ1765）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f862fd02527b95bbe0a34ac38eb69a8e6f210d9f" translate="yes" xml:space="preserve">
          <source>When performing N:M conversions, this function may return &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; after consuming all source characters (&lt;code&gt;from_next == from_end&lt;/code&gt;). This means that another internal character is needed to complete the conversion (e.g. when converting UTF-16 to UTF-8, if the last character in the source buffer is a high surrogate).</source>
          <target state="translated">N：M変換を実行する場合、この関数は、すべてのソース文字（ &lt;code&gt;from_next == from_end&lt;/code&gt; ）を消費した後に &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; 返す場合があります。 これは、変換を完了するために別の内部文字が必要であることを意味します（たとえば、ソースバッファーの最後の文字が上位サロゲートである場合、UTF-16をUTF-8に変換するとき）。</target>
        </trans-unit>
        <trans-unit id="73238300a6abe634b092cd3c78bfa124e710c17c" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">一致を実行する場合、すべてのマーク付き部分式 &lt;code&gt;(expr)&lt;/code&gt; は、マークなし部分式 &lt;code&gt;(?:expr)&lt;/code&gt; として扱われます。 提供された &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 構造には一致が保存されておらず、 &lt;code&gt;mark_count()&lt;/code&gt; はゼロです</target>
        </trans-unit>
        <trans-unit id="c20cd38801efcb855e60aac217866665e1148ddd" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">一致を実行する場合、すべてのマーク付き部分式 &lt;code&gt;(expr)&lt;/code&gt; は、マークなし部分式 &lt;code&gt;(?:expr)&lt;/code&gt; として扱われます。 提供された &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 構造には一致が保存されておらず、 &lt;code&gt;mark_count()&lt;/code&gt; はゼロです</target>
        </trans-unit>
        <trans-unit id="f4f7d6dbe3d540b5d3f8d4a7ca45e962b95c0edb" translate="yes" xml:space="preserve">
          <source>When placeholder types (either &lt;code&gt;auto&lt;/code&gt; or &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list.</source>
          <target state="translated">プレースホルダータイプ（ &lt;code&gt;auto&lt;/code&gt; または&lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt; ）が関数宣言または関数テンプレート宣言のパラメーターリストにある場合、宣言は関数テンプレートを宣言し、プレースホルダーごとに1つの発明されたテンプレートパラメーターがテンプレートパラメーターリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="641c7fd3577d0edc6efac99f2f76379fc6931592" translate="yes" xml:space="preserve">
          <source>When reading characters, &lt;code&gt;std::istream_iterator&lt;/code&gt; skips whitespace by default (unless disabled with &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; or equivalent), while &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; does not. In addition, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">文字を読み取るとき、 &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; はスキップしませんが、 &lt;code&gt;std::istream_iterator&lt;/code&gt; はデフォルトで空白をスキップします（ &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; または同等のもので無効にしない限り）。 さらに、 &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; は、1文字ごとに監視オブジェクトを構築および破棄するオーバーヘッドを回避するため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="1ab1d2134a41c9628e2098e71305ab92b1cd2216" translate="yes" xml:space="preserve">
          <source>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</source>
          <target state="translated">例外を再スローする際には、例外オブジェクトが継承を使用する(典型的な)場合にオブジェクトのスライスを避けるために、第2の形式を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f9fb914caea510cf6dfabbb484a007b28ab4e8a3" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">シグナルハンドラーが関数に設定され、シグナルが発生した場合、シグナルハンドラーの開始の直前に &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; が実行されるかどうかは、実装で定義されます。 また、実装は、シグナルハンドラの実行中に、実装によって定義された信号のセットが発生するのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">符号付き整数の算術演算がオーバーフローした場合（結果が結果の型に収まらない場合）の動作は未定義です。表現の規則（通常は2の補数）に従ってラップアラウンドする場合があり、一部のプラットフォームまたはコンパイラーによってトラップされる場合がありますオプション（GCCおよびClangの &lt;code&gt;-ftrapv&lt;/code&gt; など）、または&lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;コンパイラーによって&lt;/a&gt;完全に最適化される場合があります。</target>
        </trans-unit>
        <trans-unit id="9deeffc3f0edffbc9e7bf40fc167f8af90637021" translate="yes" xml:space="preserve">
          <source>When some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrain algorithms&lt;/a&gt; that usually return an iterator or a subrange of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; take a particular rvalue &lt;code&gt;Range&lt;/code&gt; argument that does not models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;dangling&lt;/code&gt; will be returned instead to avoid returning potentially dangling results.</source>
          <target state="translated">通常、イテレータまたは&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; の&lt;/a&gt;サブ範囲を返すいくつかの&lt;a href=&quot;../algorithm/ranges&quot;&gt;制約アルゴリズム&lt;/a&gt;が、説明のみの概念&lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; を&lt;/a&gt;モデル化しない特定の右辺値 &lt;code&gt;Range&lt;/code&gt; 引数を取る場合、潜在的にぶら下がっている結果が返されないように、 &lt;code&gt;dangling&lt;/code&gt; が代わりに返されます。</target>
        </trans-unit>
        <trans-unit id="8b1e13bc5e72c1d99187d326eff8cc95c6a2ce2a" translate="yes" xml:space="preserve">
          <source>When specializing a function template, its template arguments can be omitted if &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; can provide them from the function arguments:</source>
          <target state="translated">関数テンプレートを特殊化するとき、 &lt;a href=&quot;template_argument_deduction&quot;&gt;テンプレート引数の推論&lt;/a&gt;が関数引数からそれらを提供できる場合は、そのテンプレート引数を省略できます。</target>
        </trans-unit>
        <trans-unit id="ca2cbab4c43c7973149386ddec137d524c3e9fe8" translate="yes" xml:space="preserve">
          <source>When string literal concatenation takes place in &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt;, user-defined string literals are concatenated as well, and their ud-suffixes are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</source>
          <target state="translated">&lt;a href=&quot;translation_phases&quot;&gt;変換フェーズ6&lt;/a&gt;で文字列リテラルの連結が行われると、ユーザー定義の文字列リテラルも連結され、それらのud-suffixは連結の目的で無視されます。ただし、連結されたすべてのリテラルに1つのサフィックスのみが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="1799979c98bbbebaef89ed6f1828299ab2b6a5e5" translate="yes" xml:space="preserve">
          <source>When such member function is declared in class X, it performs conversion from X to conversion-type-id:</source>
          <target state="translated">このようなメンバ関数がクラスXで宣言されると,Xから変換型IDへの変換を行う。</target>
        </trans-unit>
        <trans-unit id="1b9fe1265be0c139fe6cde0ba421b142a03ada23" translate="yes" xml:space="preserve">
          <source>When template arguments are provided, or, for &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;function&lt;/a&gt; and &lt;a href=&quot;deduction_guide&quot;&gt;class&lt;/a&gt;(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a</source>
          <target state="translated">テンプレート引数が提供されるか、または&lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;関数&lt;/a&gt;と&lt;a href=&quot;deduction_guide&quot;&gt;クラス&lt;/a&gt; （C ++ 17以降）のテンプレートのみが推定されると、それらはテンプレートパラメーターの代わりに使用され、</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">になったときに</target>
        </trans-unit>
        <trans-unit id="aa5703929047ae870cd9bedc4f9eebb911b80493" translate="yes" xml:space="preserve">
          <source>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</source>
          <target state="translated">引数がクラス・テンプレートである場合、パラメータをマッチングさせる際には、プライマリ・テンプレートのみが考慮されます。部分的な特殊化がある場合は、このテンプレート・テンプレート・パラメータに基づく特殊化がたまたまインスタンス化された場合にのみ考慮されます。</target>
        </trans-unit>
        <trans-unit id="657c97ad1dccca00440cdc8eb7bd687219c46fbe" translate="yes" xml:space="preserve">
          <source>When the asynchronous operation is ready to send a result to the creator, it can do so by modifying</source>
          <target state="translated">非同期操作が結果を作成者に送信する準備ができたときには</target>
        </trans-unit>
        <trans-unit id="b3e1fc309740231aa065058d4a26e16a2e51f547" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a user-defined literal with ud-suffix&lt;code&gt;X&lt;/code&gt;, it performs &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;unqualified name lookup&lt;/a&gt;, looking for a function with the name &lt;code&gt;operator &quot;&quot; X&lt;/code&gt;. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</source>
          <target state="translated">コンパイラーがud-suffix &lt;code&gt;X&lt;/code&gt; を持つユーザー定義リテラルを検出すると、 &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;修飾子なしの名前検索を&lt;/a&gt;実行して、名前 &lt;code&gt;operator &quot;&quot; X&lt;/code&gt; を持つ関数を探します。 ルックアップで宣言が見つからない場合、プログラムの形式は正しくありません。 さもないと、</target>
        </trans-unit>
        <trans-unit id="a6e3ba42f8de770e69687876d93e30231038db0e" translate="yes" xml:space="preserve">
          <source>When the compiler encounters an unknown name in a program, it associates it with the declaration that introduced the name by means of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, except for the &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; in template declarations and definitions (for those names, the compiler determines whether they name a type, a template, or some other entity, which may require &lt;a href=&quot;dependent_name&quot;&gt;explicit disambiguation&lt;/a&gt;).</source>
          <target state="translated">コンパイラは、プログラムで不明な名前を検出すると、テンプレートの宣言と定義の&lt;a href=&quot;dependent_name&quot;&gt;従属名&lt;/a&gt;を除いて、 &lt;a href=&quot;lookup&quot;&gt;名前検索&lt;/a&gt;によって名前を導入した宣言と関連付けます（これらの名前については、コンパイラは型に名前を付けるかどうかを決定します） 、テンプレート、または&lt;a href=&quot;dependent_name&quot;&gt;明確な明確化&lt;/a&gt;が必要な場合があるその他のエンティティ）。</target>
        </trans-unit>
        <trans-unit id="3ffc67b2c989f365607047bd77316e5ecdadcda9" translate="yes" xml:space="preserve">
          <source>When the condition variable is notified, a timeout expires, or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;spurious wakeup&lt;/a&gt; occurs, the thread is awakened, and the mutex is atomically reacquired. The thread should then check the condition and resume waiting if the wake up was spurious.</source>
          <target state="translated">条件変数が通知されると、タイムアウトが発生するか、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;偽のウェイクアップ&lt;/a&gt;が発生し、スレッドがウェイクアップされ 、ミューテックスがアトミックに再取得されます。 次に、スレッドは状態を確認し、ウェイクアップが誤っていた場合は待機を再開します。</target>
        </trans-unit>
        <trans-unit id="16dd5023449c37e3ee571367f3544e6dbf21123f" translate="yes" xml:space="preserve">
          <source>When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following:</source>
          <target state="translated">コアーチンの状態が co_return または uncaught exception を介して終了したか、そのハンドルを介して破棄されたために破棄された場合、次のような処理を行います。</target>
        </trans-unit>
        <trans-unit id="d296094acb938c3d5a36e0feef5bea491289a47a" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being copy constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">デフォルトのアロケータが使用される場合、これにより、キーがキーからコピーされ、マップされた値が&lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initializedになります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9fddcbdad59ebcc2389e29ab9d251d255ff093b" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being move constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">デフォルトのアロケータを使用すると、キーから移動される &lt;code&gt;key&lt;/code&gt; が作成され、マップされた値が&lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initializedになります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="31f633e1dfad19457b495484c1fbe0072bbb264f" translate="yes" xml:space="preserve">
          <source>When the default semantics are not suitable, such as when the members must be compared out of order, or must use a comparison that's different from their natural comparison, then the programmer can write &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; and let the compiler generate the appropriate relational operators. The kind of relational operators generated depends on the return type of the user-defined &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">メンバーを順不同で比較する必要がある場合や、自然な比較とは異なる比較を使用する必要がある場合など、デフォルトのセマンティクスが適切でない場合、プログラマーは &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; を記述してコンパイラーに適切な関係演算子を生成させることができます。 。 生成される関係演算子の種類は、ユーザー定義の &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 戻り値の型によって異なります&amp;lt;=&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">配列の要素型が別の配列である場合、その配列は多次元であると言われています。</target>
        </trans-unit>
        <trans-unit id="8371d69254feffac85782c93e2437f4715cd1cb6" translate="yes" xml:space="preserve">
          <source>When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">初期化子がprvalueの場合、移動コンストラクター呼び出しは、（C ++ 17以降）作成されない（C ++ 17以降）最適化されることがよくあり&lt;a href=&quot;copy_elision&quot;&gt;ます&lt;/a&gt; 。 コピーの省略を参照してください。</target>
        </trans-unit>
        <trans-unit id="10770c6e57727da2d2faacfcf5bbaf211dbc1a9b" translate="yes" xml:space="preserve">
          <source>When the left operand has reference type, the assignment operator modifies the referred-to object.</source>
          <target state="translated">左のオペランドが参照型を持つ場合、代入演算子は参照先オブジェクトを変更します。</target>
        </trans-unit>
        <trans-unit id="0d0dbe17faf8b2da57c150cba1c216b9daf8702b" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">メンバー型 &lt;code&gt;pointer&lt;/code&gt; が生のポインター型ではない場合、それは一般に「ファンシーポインター」と呼ばれます。 このようなポインターは、セグメント化されたメモリアーキテクチャをサポートするために導入され、未加工のポインターによってアクセスされる同種の仮想アドレス空間とは異なるアドレス空間に割り当てられたオブジェクトにアクセスするために現在使用されています。 ファンシーポインターの例としては、マッピングアドレスに依存しないポインター&lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost :: interprocess :: offset_ptr&lt;/a&gt;があります。これにより、 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; などのノードベースのデータ構造を、共有メモリに割り当てたり、別のアドレスにマップされたメモリマップファイルを割り当てることができます。すべてのプロセス。 ファンシーポインターは、クラステンプレート &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; 介して、それらを提供したアロケーターとは独立して使用できます。</target>
        </trans-unit>
        <trans-unit id="e345263d3c16be0359604e2c7e37e80d322c6999" translate="yes" xml:space="preserve">
          <source>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; unless its type was an lvalue reference type, or unless its type is a class type(since C++20).</source>
          <target state="translated">非型テンプレートパラメーターの名前がクラステンプレートの本文内の式で使用されている場合、その型が左辺値参照型でないか、またはその型がクラス型でない限り、変更不可能な&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;です（C ++以降20）。</target>
        </trans-unit>
        <trans-unit id="0dd4c2cd3956549ff3cdd1f8a7caf6b32e2cea01" translate="yes" xml:space="preserve">
          <source>When the noexcept-specification of a function template specialization is</source>
          <target state="translated">関数テンプレートの特殊化のnoexcept-指定が</target>
        </trans-unit>
        <trans-unit id="cc159284033553cbafc104d522a5cf1ae76e1549" translate="yes" xml:space="preserve">
          <source>When the number of variants is zero or one, the invocation of the callable object is implemented in constant time, i.e. it does not depend on &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">バリアントの数が0または1の場合、呼び出し可能オブジェクトの呼び出しは一定の時間で実装されます。つまり、 &lt;code&gt;sizeof...(Types)&lt;/code&gt; 依存しません。</target>
        </trans-unit>
        <trans-unit id="b8b02aaeadad3d163b0d5be165966951d5f6a133" translate="yes" xml:space="preserve">
          <source>When the parameter-list is not empty, an optional comma may precede a &lt;code&gt;...&lt;/code&gt; signifying a variadic function. This provides compatibility with C (which added a requirement for a comma when it adopted function prototypes from C++).</source>
          <target state="translated">parameter-listが空でない場合、オプションのコンマが可変長関数を表す &lt;code&gt;...&lt;/code&gt; の前にある場合があります 。 これは、Cとの互換性を提供します（C ++からの関数プロトタイプを採用したときに、コンマの要件が追加されました）。</target>
        </trans-unit>
        <trans-unit id="eadbea007ec076285100c5cbd07b8a2dc8928700" translate="yes" xml:space="preserve">
          <source>When the parser encounters the character sequence &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself and not as the first character of the alternative token &lt;code&gt;&amp;lt;:&lt;/code&gt;. Thus &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; won't be wrongly treated as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">パーサーが文字シーケンス &lt;code&gt;&amp;lt;::&lt;/code&gt; を検出し、後続の文字が &lt;code&gt;:&lt;/code&gt; でも &lt;code&gt;&amp;gt;&lt;/code&gt; でもない場合、 &lt;code&gt;&amp;lt;&lt;/code&gt; は、それ自体が前処理トークンとして扱われ、代替トークン &lt;code&gt;&amp;lt;:&lt;/code&gt; の最初の文字として扱われません。 したがって、 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; として誤って処理されることはありません。</target>
        </trans-unit>
        <trans-unit id="8cc2032d32ca7885f140b25a96dcbee6c5397ce4" translate="yes" xml:space="preserve">
          <source>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (&lt;code&gt;operator++&lt;/code&gt; or &lt;code&gt;operator--&lt;/code&gt;) is called with an integer argument &lt;code&gt;0&lt;/code&gt;. Typically, it is implemented as &lt;code&gt;T operator++(int)&lt;/code&gt;, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</source>
          <target state="translated">式に後置インクリメントとデクリメントが現れると、対応するユーザー定義関数（ &lt;code&gt;operator++&lt;/code&gt; または &lt;code&gt;operator--&lt;/code&gt; ）が整数引数 &lt;code&gt;0&lt;/code&gt; で呼び出されます 。 通常、これは &lt;code&gt;T operator++(int)&lt;/code&gt; として実装され、引数は無視されます。 後置インクリメントおよびデクリメント演算子は、通常、プレフィックスバージョンに関して実装されます。</target>
        </trans-unit>
        <trans-unit id="fd043f49a212d5450703bb9a052e4fa639f20396" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt;.</source>
          <target state="translated">regexライブラリが2つの文字 &lt;code&gt;c1&lt;/code&gt; と &lt;code&gt;c2&lt;/code&gt; に一致する必要があり、フラグ &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合 、それは &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="a73f957522574e9d880fc3def8f3dd16383a3e89" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt;.</source>
          <target state="translated">regexライブラリが2つの文字 &lt;code&gt;c1&lt;/code&gt; と &lt;code&gt;c2&lt;/code&gt; に一致する必要があり、フラグ &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合 、 &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="59285875d0142d5e8a1eb450e8a3f9927249ea97" translate="yes" xml:space="preserve">
          <source>When the result of specializing an alias template is a dependent &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, subsequent substitutions apply to that template-id:</source>
          <target state="translated">エイリアステンプレートを特殊化した結果が従属&lt;a href=&quot;templates#template-id&quot;&gt;template-idである&lt;/a&gt;場合、後続の置換はそのtemplate-idに適用されます。</target>
        </trans-unit>
        <trans-unit id="7e5e471d5aa433ec3a110b9d7e72faf3a90a04a9" translate="yes" xml:space="preserve">
          <source>When the same function template specialization matches more than one overloaded function template (this often results from &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;),</source>
          <target state="translated">同じ関数テンプレートの特殊化が複数のオーバーロードされた関数テンプレートに一致する場合（これは多くの場合、 &lt;a href=&quot;template_argument_deduction&quot;&gt;テンプレート引数の推定&lt;/a&gt;から生じます ）、</target>
        </trans-unit>
        <trans-unit id="b2ff5fd15b40403883483bc89510d97f14914365" translate="yes" xml:space="preserve">
          <source>When the target type is</source>
          <target state="translated">対象となるタイプが</target>
        </trans-unit>
        <trans-unit id="511cb27754af79d62f22a1bf71b871d3d288ebcd" translate="yes" xml:space="preserve">
          <source>When the template-name of a simple-template-id names a constrained non-function template or a constrained template template-parameter, but not a member template that is a member of an unknown specialization, and all template-arguments in the simple-template-id are non-dependent, the associated constraints of the constrained template must be satisfied:</source>
          <target state="translated">simple-template-id のテンプレート名が、制約付きの非関数テンプレートや制約付きテンプレートテンプレートパラメータの名前であって、未知の特殊化のメンバテンプレートではない場合、 simple-template-id 内のすべてのテンプレート引数が非依存である場合、制約付きテンプレートの関連する制約が満たされなければなりません。</target>
        </trans-unit>
        <trans-unit id="adb827bd0954ef807560ec125638e405788fa858" translate="yes" xml:space="preserve">
          <source>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</source>
          <target state="translated">依存型で宣言されている非型のテンプレートパラメータPに対応する引数の値を式から演繹すると、Pの型のテンプレートパラメータはその値の型から演繹されます。</target>
        </trans-unit>
        <trans-unit id="a1b257f783065293c124a619280ef8e578d72775" translate="yes" xml:space="preserve">
          <source>When this is the case, member functions &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;equal_range&lt;/code&gt; accept arguments of types other than &lt;code&gt;Key&lt;/code&gt; and expect that &lt;code&gt;Hash&lt;/code&gt; is callable with values of those types, and that &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is a transparent comparison function such as &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">この場合、メンバー関数 &lt;code&gt;find&lt;/code&gt; 、 &lt;code&gt;contains&lt;/code&gt; 、 &lt;code&gt;count&lt;/code&gt; 、および &lt;code&gt;equal_range&lt;/code&gt; は、 &lt;code&gt;Key&lt;/code&gt; 以外の型の引数を受け入れ、 &lt;code&gt;Hash&lt;/code&gt; がそれらの型の値で呼び出し可能であり、 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; が &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt; などの透過的な比較関数であることを期待します。 ：equal_to &amp;lt;&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="22fbcacb8ea8a01e09177002c1cd6a745c7d8006" translate="yes" xml:space="preserve">
          <source>When three-way comparison (such as &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt;) is provided, all six relational operators may be expressed through that:</source>
          <target state="translated">3者間比較（ &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt; ）が提供されている場合、6つの関係演算子すべてが次のように表現されます。</target>
        </trans-unit>
        <trans-unit id="1f2f2e919801487fefca6150ecd5b3b80daddef7" translate="yes" xml:space="preserve">
          <source>When three-way comparison is not required (such as when providing a &lt;code&gt;Compare&lt;/code&gt; argument to standard algorithms such as &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt;), &lt;a href=&quot;../locale/operator()&quot;&gt;&lt;code&gt;std::locale::operator()&lt;/code&gt;&lt;/a&gt; may be more appropriate.</source>
          <target state="translated">3者間比較が必要ない場合（ &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; などの標準アルゴリズムに &lt;code&gt;Compare&lt;/code&gt; 引数を提供する場合など）、 &lt;a href=&quot;../locale/operator()&quot;&gt; &lt;code&gt;std::locale::operator()&lt;/code&gt; &lt;/a&gt;方が適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="3b2aec7feac4af597a17debffe4c87be12d0ecab" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;template argument&lt;/a&gt;, &lt;code&gt;class T&lt;/code&gt; is a type template parameter named &lt;code&gt;T&lt;/code&gt;, not an unnamed non-type parameter whose type &lt;code&gt;T&lt;/code&gt; is introduced by elaborated type specifier.</source>
          <target state="translated">&lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;テンプレート引数&lt;/a&gt;として使用する場合、 &lt;code&gt;class T&lt;/code&gt; はTという名前のタイプテンプレートパラメーターであり、型 &lt;code&gt;T&lt;/code&gt; が詳細な型指定子によって導入される名前のない非型パラメーターではありません。</target>
        </trans-unit>
        <trans-unit id="a89f99191dc9016965a45193765f04ce9fd16336" translate="yes" xml:space="preserve">
          <source>When used as a function argument and when &lt;a href=&quot;overload_resolution&quot;&gt;two overloads&lt;/a&gt; of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, and likewise with copy and move assignment operators).</source>
          <target state="translated">関数の引数として使用し、関数の&lt;a href=&quot;overload_resolution&quot;&gt;2つのオーバーロード&lt;/a&gt;が利用可能で、一方が右辺値参照パラメーターを取り、もう一方が左辺値参照をconstパラメーターに取る場合、右辺値は右辺値参照オーバーロードにバインドします（したがって、コピーコンストラクターと移動コンストラクターの両方が利用可能な場合） 、rvalue引数は&lt;a href=&quot;move_constructor&quot;&gt;moveコンストラクターを&lt;/a&gt;呼び出し、同様にcopyおよびmove割り当て演算子を使用します）。</target>
        </trans-unit>
        <trans-unit id="f8ea00edd25f46b83546909c33b9f68661ba3e16" translate="yes" xml:space="preserve">
          <source>When used as an argument in a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder &lt;code&gt;_N&lt;/code&gt; is replaced by the corresponding Nth unbound argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 式の引数として使用すると、プレースホルダーオブジェクトは生成された関数オブジェクトに格納され、その関数オブジェクトが非バインド引数で呼び出されると、各プレースホルダー &lt;code&gt;_N&lt;/code&gt; は対応するN番目の非バインド引数に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4c90e24b8efd2362ba00ffddb7c37e312b7e82c3" translate="yes" xml:space="preserve">
          <source>When used at class scope, variable template declares a static data member template.</source>
          <target state="translated">クラススコープで使用される場合、変数templateは静的データメンバテンプレートを宣言します。</target>
        </trans-unit>
        <trans-unit id="d3e7747ab6e5ee83d7abf31291a18569eac0496f" translate="yes" xml:space="preserve">
          <source>When used immediately after whitespace-delimited input, e.g. after &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;, &lt;code&gt;getline&lt;/code&gt; consumes the endline character left on the input stream by &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;, and returns immediately. A common solution is to ignore all leftover characters on the line of input with &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; before switching to line-oriented input.</source>
          <target state="translated">空白で区切られた入力の直後、たとえば &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; 直後に使用した場合。 &lt;a href=&quot;../../io/cin&quot;&gt;std :: cin&lt;/a&gt; &amp;gt;&amp;gt; n; 、 &lt;code&gt;getline&lt;/code&gt; は、 &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;オペレーター&amp;gt;&amp;gt;&lt;/a&gt;によって入力ストリームに残されたエンドライン文字を消費し、すぐに戻ります。 一般的な解決策は、 &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; 、入力行に残っている文字をすべて無視することです。 行指向の入力に切り替える前。</target>
        </trans-unit>
        <trans-unit id="810ee96ebb349b821e1635ff4d35660a0d38207d" translate="yes" xml:space="preserve">
          <source>When used in a class definition, &lt;code&gt;final&lt;/code&gt; specifies that this class may not appear in the base-specifier-list of another class definition (in other words, cannot be derived from). The program is ill-formed (a compile-time error is generated) otherwise. &lt;code&gt;final&lt;/code&gt; can also be used with a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; definition, in which case it has no effect (other than on the outcome of &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;), since unions cannot be derived from).</source>
          <target state="translated">クラス定義で使用する場合、 &lt;code&gt;final&lt;/code&gt; は、このクラスが別のクラス定義のbase-specifier-listに表示されない（つまり、派生できない）ことを指定します。 それ以外の場合、プログラムの形式は正しくありません（コンパイル時エラーが生成されます）。 &lt;code&gt;final&lt;/code&gt; は、 &lt;a href=&quot;union&quot;&gt;共用体&lt;/a&gt;定義とともに使用することもできます。その場合、（ &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt; 結果以外に）影響はありません。共用体は派生できないためです）。</target>
        </trans-unit>
        <trans-unit id="9305de135bb255cca457fdbece5abb6dd9a1674a" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt;または&lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elifの&lt;/a&gt;制御式で使用すると、すべての符号付き整数定数は &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 型のように動作し、すべての符号なし整数定数は &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt; 型のように動作します。</target>
        </trans-unit>
        <trans-unit id="8b903d2e014bf8406262e3731d09165f67923eb1" translate="yes" xml:space="preserve">
          <source>When used in a virtual function declaration or definition, &lt;code&gt;final&lt;/code&gt; ensures that the function is virtual and specifies that it may not be overridden by derived classes. The program is ill-formed (a compile-time error is generated) otherwise.</source>
          <target state="translated">仮想関数の宣言または定義で使用される場合、 &lt;code&gt;final&lt;/code&gt; は関数が仮想であることを保証し、派生クラスによってオーバーライドされないように指定します。 それ以外の場合、プログラムの形式は正しくありません（コンパイル時エラーが生成されます）。</target>
        </trans-unit>
        <trans-unit id="1a6b7e3d85e506288364ecfff9f25bf551cd3185" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt;, parses the character input as a monetary value, as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;in&lt;/code&gt;, and stores the value in &lt;code&gt;mon&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; 式で使用すると、文字入力を、現在in &lt;code&gt;in&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; れているロケールのstd :: money_getファセットで指定された金額として解析し、値を &lt;code&gt;mon&lt;/code&gt; に格納します。</target>
        </trans-unit>
        <trans-unit id="dba580a9fb7386ece9bcb9047821c34efdbd2cc6" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt;, parses the character input as a date/time value according to format string &lt;code&gt;fmt&lt;/code&gt; according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the input stream &lt;code&gt;in&lt;/code&gt;. The resultant value is stored in a &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;tmb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt; 式で使用した場合、の入力ストリーム &lt;code&gt;in&lt;/code&gt; 現在組み込まれているロケールの &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; ファセットに従って、フォーマット文字列 &lt;code&gt;fmt&lt;/code&gt; に従って文字入力を日付/時刻値として解析します。 結果の値は、 &lt;code&gt;tmb&lt;/code&gt; が指す &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; オブジェクトに格納されます。</target>
        </trans-unit>
        <trans-unit id="8f6b6002a8d5ee59f8db2c3ad5177196e34c65dc" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt;, converts the monetary value &lt;code&gt;mon&lt;/code&gt; to its character representation as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">式で使用される場合 &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; は、金額の値 &lt;code&gt;mon&lt;/code&gt; を、現在 &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; れているロケールのstd :: money_putファセットで指定された文字表現に変換 &lt;code&gt;out&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf45d63014365fd6dcec8ecebade756fbe4b1751" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt;, converts the date and time information from a given calendar time &lt;code&gt;tmb&lt;/code&gt; to a character string according to format string &lt;code&gt;fmt&lt;/code&gt;, as if by calling &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt;, or analog (depending on &lt;code&gt;CharT&lt;/code&gt;), according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the output stream &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt; で &lt;code&gt;tmb&lt;/code&gt; すると、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt; 呼び出すのと同じように、日付と時刻の情報が指定されたカレンダー時刻tmbからフォーマット文字列 &lt;code&gt;fmt&lt;/code&gt; に従って文字列に変換されます。 、またはアナログ（ &lt;code&gt;CharT&lt;/code&gt; に依存 ）。現在、出力ストリーム &lt;code&gt;out&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; いるロケールのstd :: time_putファセットによる。</target>
        </trans-unit>
        <trans-unit id="c4b7fe6253074e6b867e1474688d0f2693a1f7d0" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;out&lt;/code&gt; is an output stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and, for overloads 2-4, &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;, which inserts into &lt;code&gt;out&lt;/code&gt; a sequence of characters &lt;code&gt;seq&lt;/code&gt; constructed as follows:</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt; で使用 &lt;code&gt;out&lt;/code&gt; と、 outは &lt;code&gt;char_type&lt;/code&gt; がCharTに等しい出力ストリームであり、オーバーロード2〜4の場合、 &lt;code&gt;traits_type&lt;/code&gt; は &lt;code&gt;Traits&lt;/code&gt; に等しくなり、 outに挿入さ &lt;code&gt;out&lt;/code&gt; &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;として動作します。次のように構築された一連の文字 &lt;code&gt;seq&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d8ac1ad4097229286f1a455e696150cbe6d78fe1" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt;, clears all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; または &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt; で使用すると、 &lt;code&gt;mask&lt;/code&gt; 指定に従って、ストリーム &lt;code&gt;out&lt;/code&gt; または &lt;code&gt;in&lt;/code&gt; のすべてのフォーマットフラグをクリアします。</target>
        </trans-unit>
        <trans-unit id="921ff88652686f85b631d9ceb7c724eb668d404a" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; sets the fill character of the stream &lt;code&gt;out&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">式で使用すると、 &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; はストリーム &lt;code&gt;out&lt;/code&gt; の塗りつぶし文字をcに設定し &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cb9f3afac80724df521c61b025e7c53651f4eb2" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt;, sets all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; または &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt; で使用すると、 &lt;code&gt;mask&lt;/code&gt; 指定に従って、ストリーム &lt;code&gt;out&lt;/code&gt; または &lt;code&gt;in&lt;/code&gt; のすべてのフォーマットフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="a87b307fde755e230f472b8260a494dc64a86904" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt;, sets the &lt;code&gt;precision&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; または &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt; で使用すると、ストリーム &lt;code&gt;out&lt;/code&gt; または &lt;code&gt;in&lt;/code&gt; の &lt;code&gt;precision&lt;/code&gt; パラメーターを正確に &lt;code&gt;n&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="c6a94f6a0cf9d3d1d83f0c666f4d933e3aa6770f" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt;, sets the &lt;code&gt;width&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; または &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt; で使用 &lt;code&gt;out&lt;/code&gt; 場合、ストリームoutまたは &lt;code&gt;in&lt;/code&gt; の &lt;code&gt;width&lt;/code&gt; パラメーターを正確に &lt;code&gt;n&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="101375a819be934deee54d8762c9258b209a7717" translate="yes" xml:space="preserve">
          <source>When used with &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;, the size of an array may be zero; such an array has no elements:</source>
          <target state="translated">&lt;a href=&quot;new&quot;&gt;new []-expression&lt;/a&gt;と共に使用すると、配列のサイズがゼロになる場合があります。 そのような配列には要素がありません：</target>
        </trans-unit>
        <trans-unit id="b5d2f5c5efbba3505a9a104fbd815a3de55bb31d" translate="yes" xml:space="preserve">
          <source>When used with a (non-const) object that has copy-on-write semantics, the range-based for loop may trigger a deep copy by (implicitly) calling the non-const &lt;code&gt;begin()&lt;/code&gt; member function. If that is undesirable (for instance because the loop is not actually modifying the object), &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; can be used:</source>
          <target state="translated">コピーオンライトセマンティクスを持つ（非const）オブジェクトで使用される場合、範囲ベースのforループは、非const &lt;code&gt;begin()&lt;/code&gt; メンバー関数を（暗黙的に）呼び出すことにより、ディープコピーをトリガーします。 これが望ましくない場合（たとえば、ループが実際にオブジェクトを変更していないため）、 &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="bf6c1868cc765347d09cc64a36b7be944f8dd8fb" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">非変換ロケール（デフォルトのロケールは非変換）を使用する場合、 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 内のこの関数のオーバーライドは、ゼロコピーバルクI / O用に最適化される場合があります（ &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt; をオーバーライドすることにより） ）。</target>
        </trans-unit>
        <trans-unit id="0986776c60c5c2e2615f44185f446f8dc94a3805" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">非変換ロケール（デフォルトのロケールは非変換）を使用する場合、 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 内のこの関数のオーバーライドは、ゼロコピーバルクI / O用に最適化される可能性があります（ &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt; をオーバーライドすることにより） ）。</target>
        </trans-unit>
        <trans-unit id="cbe8e117435e8afed934a7b78bf92466217654af" translate="yes" xml:space="preserve">
          <source>When using parallel execution policy, it is the programmer's responsibility to avoid data races and deadlocks:</source>
          <target state="translated">並列実行ポリシーを使用する場合、データ競合やデッドロックを回避するのはプログラマの責任です。</target>
        </trans-unit>
        <trans-unit id="7dd97b15bcdd677ac393fd1531f4ab0a23cce05d" translate="yes" xml:space="preserve">
          <source>When working with the C++ container library, the proper type for the difference between iterators is the member typedef &lt;code&gt;difference_type&lt;/code&gt;, which is often synonymous with &lt;code&gt;std::ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">C ++コンテナーライブラリを使用する場合、イテレーター間の違いの適切な型は、メンバーtypedefの &lt;code&gt;difference_type&lt;/code&gt; であり、多くの場合 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; と同義です 。</target>
        </trans-unit>
        <trans-unit id="744601d71e0a622aae7e049c96112c98fceb410b" translate="yes" xml:space="preserve">
          <source>When writing characters, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">文字を書き込むときは、 &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; 方が効率的です。これは、監視オブジェクトを1文字につき1回作成および破棄するオーバーヘッドを回避できるためです。</target>
        </trans-unit>
        <trans-unit id="6d6a0d2f37c6465daaf393a9cbcafd860707692e" translate="yes" xml:space="preserve">
          <source>Whenever a reference is bound to a temporary or to a subobject thereof, the lifetime of the temporary is extended to match the lifetime of the reference, with the following exceptions:</source>
          <target state="translated">参照が一時オブジェクトまたはそのサブオブジェクトにバインドされている場合はいつでも、一時オブジェクトの有効期間は、以下の例外を除いて、参照の有効期間と一致するように拡張されます。</target>
        </trans-unit>
        <trans-unit id="a47ec6b9ae119d13c79d3ecadb3d357577c88006" translate="yes" xml:space="preserve">
          <source>Whenever an attempt is made to read or modify the stored value of an object of type &lt;code&gt;DynamicType&lt;/code&gt; through a glvalue of type &lt;code&gt;AliasedType&lt;/code&gt;, the behavior is undefined unless one of the following is true:</source>
          <target state="translated">タイプ &lt;code&gt;AliasedType&lt;/code&gt; の glvalueを介してタイプ &lt;code&gt;DynamicType&lt;/code&gt; のオブジェクトの格納された値を読み取ったり変更しようとしたりするときは常に、次のいずれかに該当しない限り、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9101581b76be4f749934d75b25f2b3f56089760f" translate="yes" xml:space="preserve">
          <source>Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.</source>
          <target state="translated">引数がいくつかの C++基本型である場合、ADL に関連する名前空間は存在しません。したがって、これらのシナリオは上記の非 ADL の例と同じです。</target>
        </trans-unit>
        <trans-unit id="77eef7bb821cc1a1b8c9c6ab0b0e1de54272ecdc" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;std::memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">&lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;厳密なエイリアス&lt;/a&gt;が2つの異なる型の値と同じメモリの検査を禁止している場合、 &lt;code&gt;std::memcpy&lt;/code&gt; を使用して値を変換できます。</target>
        </trans-unit>
        <trans-unit id="c53cccdafaba481597a722fa2959cf7a851c2ce1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;weak_this&lt;/code&gt; is the hidden mutable &lt;code&gt;std::weak_ptr&lt;/code&gt; member of &lt;code&gt;std::shared_from_this&lt;/code&gt;. The assignment to the &lt;code&gt;weak_this&lt;/code&gt; member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt;&lt;code&gt;shared_from_this()&lt;/code&gt;&lt;/a&gt; would share ownership with the &lt;code&gt;shared_ptr&lt;/code&gt; created by this raw pointer constructor.</source>
          <target state="translated">&lt;code&gt;weak_this&lt;/code&gt; は、 &lt;code&gt;std::weak_ptr&lt;/code&gt; shared_from_thisの隠された変更可能なstd :: weak_ptrメンバーです。 &lt;code&gt;weak_this&lt;/code&gt; メンバーへの割り当てはアトミックではなく、同じオブジェクトへの同時アクセスの可能性と競合します。 これにより、今後の&lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt; &lt;code&gt;shared_from_this()&lt;/code&gt; の&lt;/a&gt;呼び出しで、この生のポインターコンストラクターによって作成された &lt;code&gt;shared_ptr&lt;/code&gt; と所有権が共有されます。</target>
        </trans-unit>
        <trans-unit id="328d7d83b15b53db0928e0b402874f758e429540" translate="yes" xml:space="preserve">
          <source>Where R is the ordering category type defined above.</source>
          <target state="translated">ここで、Rは、上記で定義された順序カテゴリタイプである。</target>
        </trans-unit>
        <trans-unit id="582de0628906c31348c3039934a0f8563d8361ee" translate="yes" xml:space="preserve">
          <source>Where a constant expression is grammatically required, including:</source>
          <target state="translated">定数式が文法的に必要なところでは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a8ebf782644f9429bc1fc6810b05c7e9c3c03635" translate="yes" xml:space="preserve">
          <source>Where applicable, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt;, &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;, and, if available, &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;, are usually preferred over direct use of SFINAE.</source>
          <target state="translated">通常、SFINAEを直接使用するよりも、 &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;タグディスパッチ&lt;/a&gt; 、 &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; 、および使用可能な場合は&lt;a href=&quot;constraints&quot;&gt;コンセプト&lt;/a&gt;が推奨されます。</target>
        </trans-unit>
        <trans-unit id="c16c807394bc564276f7b672bb496e133719e00a" translate="yes" xml:space="preserve">
          <source>Where built-in operators return &lt;code&gt;bool&lt;/code&gt;, most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">組み込み演算子が &lt;code&gt;bool&lt;/code&gt; を返す場合、ほとんどの&lt;a href=&quot;operators&quot;&gt;ユーザー定義のオーバーロード&lt;/a&gt;も &lt;code&gt;bool&lt;/code&gt; を返すため、ユーザー定義演算子を組み込みと同じように使用できます。 ただし、ユーザー定義の演算子オーバーロードでは、任意の型を戻り型として使用できます（ &lt;code&gt;void&lt;/code&gt; を含む）。</target>
        </trans-unit>
        <trans-unit id="1889e8caa29d75a1818f0a931ca52b8fe1415229" translate="yes" xml:space="preserve">
          <source>Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">class-name は、現在のクラス (またはクラス・テンプレートの現在のインスタンス)の名前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="03f3df53bc82d8371ebdee50da2998db2016a301" translate="yes" xml:space="preserve">
          <source>Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">class_name は、現在のクラス (またはクラス・テンプレートの現在のインスタンス)の名前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d7ad86ffa9afba91a0ed8ad0042113ba1987e71e" translate="yes" xml:space="preserve">
          <source>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; and rvalue &lt;code&gt;v = c[i];&lt;/code&gt; usage, operator[] may return a proxy. see for example &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コンテナーの要素への直接アクセスが望まれないか不可能である場合、または左辺値 &lt;code&gt;c[i] = v;&lt;/code&gt; 区別する場合。 および右辺値 &lt;code&gt;v = c[i];&lt;/code&gt; 使用法、operator []はプロキシを返すことがあります。 たとえば &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="7544bd14fb0127b9e675324fe322b59d1667847a" translate="yes" xml:space="preserve">
          <source>Where necessary, the compiler may implicitly define the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, and the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;.</source>
          <target state="translated">コンパイラーは、必要に応じて、 &lt;a href=&quot;default_constructor&quot;&gt;デフォルトのコンストラクター&lt;/a&gt; 、 &lt;a href=&quot;copy_constructor&quot;&gt;コピーコンストラクター&lt;/a&gt; 、 &lt;a href=&quot;move_constructor&quot;&gt;移動コンストラクター&lt;/a&gt; 、 &lt;a href=&quot;as_operator&quot;&gt;コピー割り当て演算子&lt;/a&gt; 、 &lt;a href=&quot;move_operator&quot;&gt;移動割り当て演算子&lt;/a&gt; 、および&lt;a href=&quot;destructor&quot;&gt;デストラクターを&lt;/a&gt;暗黙的に定義します 。</target>
        </trans-unit>
        <trans-unit id="0d39fc5aa0a8a0218582cd66f3e979536d5af157" translate="yes" xml:space="preserve">
          <source>Where the input for &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imaginary&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.  If an error occurs calls &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; と &lt;code&gt;imaginary&lt;/code&gt; 入力は &lt;code&gt;T&lt;/code&gt; に変換可能でなければなりません。 エラーが発生した場合は &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="f939b6cebddd88e076c47ab7052d80f4f9691f8f" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; が数学ライブラリ関数によって生成されるかどうかは、一般的には指定されていませんが、関数の説明で明示的に指定できます（例： &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0ef570637f0306b69eab32021437454f7aeaff6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; bit fields that aren't explicitly &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; are signed or unsigned.</source>
          <target state="translated">明示的に &lt;code&gt;signed&lt;/code&gt; または &lt;code&gt;unsigned&lt;/code&gt; れていない &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; 、および &lt;code&gt;long long&lt;/code&gt; ビットフィールドが署名されているか、署名されていないか。</target>
        </trans-unit>
        <trans-unit id="21520e7d3c4c9457f0b61f7da5be4c28fb0b2934" translate="yes" xml:space="preserve">
          <source>Whether implemented or not, this function is normally called by &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; if the get area is empty.</source>
          <target state="translated">実装されているかどうかにかかわらず、この関数は通常、get領域が空の場合に &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="be104b12a99ce4ffaccf474c68581deb485380ae" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">操作が成功したかどうかに関係なく、ストリームはファイルに関連付けられなくなり、 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; によって割り当てられたバッファーは、自動割り当てが使用されていた場合、関連付けも解除され、割り当て解除されます。</target>
        </trans-unit>
        <trans-unit id="d46a08839feaec08adbd051313d8939dc9b21b97" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; uses pos_format for formatting positive values and neg_format for formatting negative values, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; uses neg_format for parsing all monetary values: it assumes that neg_format is compatible with pos_format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; は正の値のフォーマットにpos_formatを使用し、負の値のフォーマットに &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 使用しますが、 std :: money_getはすべての通貨値の解析にneg_formatを使用します。neg_formatはpos_formatと互換性があると想定しています。</target>
        </trans-unit>
        <trans-unit id="4882bae700593de48c423f4a185a6a87fc8e0168" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;codecvt&lt;/code&gt; supports N:M conversions (e.g. UTF-16 to UTF-8, where two internal characters may be necessary to decide what external characters to output), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; can only use &lt;code&gt;codecvt&lt;/code&gt; facets that define a 1:N conversion, that is it must be able to process one internal character at a time when writing to a file.</source>
          <target state="translated">&lt;code&gt;codecvt&lt;/code&gt; はN：M変換（たとえば、出力する外部文字を決定するために2つの内部文字が必要な場合があるUTF-16からUTF-8）を &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; ますが、 std :: basic_filebufは1：N変換を定義する &lt;code&gt;codecvt&lt;/code&gt; ファセットのみを使用できます。つまり、ファイルに書き込むときに一度に1つの内部文字を処理できる必要があります。</target>
        </trans-unit>
        <trans-unit id="ce692aaa12dee04f1b7857662f9696d7b39d104a" translate="yes" xml:space="preserve">
          <source>While all fundamental types &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; are integer types, a library may define exact types that aren't integers, e.g. a rational arithmetics type representing fractions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; であるすべての基本的な型 &lt;code&gt;T&lt;/code&gt; は整数型ですが、ライブラリは整数ではない正確な型を定義する場合があります（分数を表す有理算術型など）。</target>
        </trans-unit>
        <trans-unit id="5c6831ef0dd5db6345bc002124c0babc32834531" translate="yes" xml:space="preserve">
          <source>While in C++, the scope of the init-statement and the scope of statement are one and the same, in C the scope of statement is nested within the scope of init-statement:</source>
          <target state="translated">C++ではinit-statementのスコープとstatementのスコープは同じものですが、C++ではstatementのスコープはinit-statementのスコープの中に入れ子になっています。</target>
        </trans-unit>
        <trans-unit id="f6a198ae06795de880db0e81ff4942b69fa0d198" translate="yes" xml:space="preserve">
          <source>While it's not true for fundamental C++ floating-point types, a third-party floating-point type &lt;code&gt;T&lt;/code&gt; may exist such that &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">基本的なC ++浮動小数点型には当てはまりませんが、 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; というサードパーティの浮動小数点型 &lt;code&gt;T&lt;/code&gt; が存在する場合があります（） 。</target>
        </trans-unit>
        <trans-unit id="bdb7f0b47137662d6f73c67c92fda0e6b0d6c3b8" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">狭い文字列は &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt; 提供しますが、これにより必要な出力バッファーサイズを決定できますが、広い文字列に相当するものはありません。バッファーサイズを決定するために、プログラムで &lt;code&gt;std::swprintf&lt;/code&gt; を呼び出して確認する必要がある場合があります。結果の値、およびより大きなバッファを再割り当てし、成功するまで再試行します。</target>
        </trans-unit>
        <trans-unit id="2aad7bc15a2badfcfdc2770354ab9bdb48f5b39a" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">狭い文字列は &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt; 提供しますが、これにより必要な出力バッファーサイズを決定できますが、広い文字列に相当するものはありません。バッファーサイズを決定するために、プログラムは &lt;code&gt;std::vswprintf&lt;/code&gt; を呼び出す必要がある場合があります。結果の値、およびより大きなバッファを再割り当てし、成功するまで再試行します。</target>
        </trans-unit>
        <trans-unit id="3d1b9b2d47483d07a008f2f3460cb714ec262b09" translate="yes" xml:space="preserve">
          <source>While objects of any complete type and cv pointers to void may be thrown as exception objects, all standard library functions throw anonymous temporary objects by value, and the types of those objects are derived (directly or indirectly) from &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;. User-defined exceptions usually follow this pattern.&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">完全なタイプのオブジェクトとvoidへのcvポインターは例外オブジェクトとしてスローされる可能性がありますが、すべての標準ライブラリ関数は値によって匿名の一時オブジェクトをスローし、それらのオブジェクトのタイプは &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; から（直接的または間接的に）派生します 。 ユーザー定義の例外は通常、このパターンに従います。 &lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd014792b0e30b26904af64ce06af14ab14dade5" translate="yes" xml:space="preserve">
          <source>While the names &quot;gptr&quot; and &quot;egptr&quot; refer to the get area, the name &quot;eback&quot; refers to the end of the putback area: stepping backwards from gptr, characters can be put back until eback.</source>
          <target state="translated">gptr &quot;と &quot;egptr &quot;という名前は取得領域を意味し、&quot;eback &quot;という名前はputback領域の終わりを意味します。</target>
        </trans-unit>
        <trans-unit id="e6aed0f8bf11c0e2ccb4abb52781539645453846" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">署名に &lt;code&gt;const &amp;amp;&lt;/code&gt; を含める必要はありませんが、関数はそれに渡されたオブジェクトを変更してはならず、 &lt;a href=&quot;../../language/value_category&quot;&gt;値のカテゴリに&lt;/a&gt;関係なく、type（おそらくconst） &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; のすべての値を受け入れることができる必要があります （したがって、 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; は許可されません） 、 &lt;code&gt;Type1&lt;/code&gt; の場合も、 Type1の場合、移動はコピーと同じです（C ++ 11以降））。</target>
        </trans-unit>
        <trans-unit id="b82e35d8b86e026d1b1ef3ee87feedc4e74f5048" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">署名に &lt;code&gt;const &amp;amp;&lt;/code&gt; を含める必要はありませんが、関数はそれに渡されたオブジェクトを変更してはならず、 &lt;a href=&quot;../language/value_category&quot;&gt;値のカテゴリに&lt;/a&gt;関係なく、type（おそらくconst） &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; のすべての値を受け入れることができる必要があります （したがって、 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; は許可されません） 、 &lt;code&gt;Type1&lt;/code&gt; の場合も、 Type1の場合、移動はコピーと同じです（C ++ 11以降））。</target>
        </trans-unit>
        <trans-unit id="90970ed5fc36e4c5fcc7d19dbc8d5693453a089b" translate="yes" xml:space="preserve">
          <source>While the stream is frozen, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; will not reallocate the buffer and the &lt;code&gt;destructor&lt;/code&gt; will not deallocate the buffer (thereby causing a memory leak).</source>
          <target state="translated">ストリームがフリーズしている間、 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; はバッファを再割り当てせず、 &lt;code&gt;destructor&lt;/code&gt; はバッファの割り当てを解除しません（それにより、メモリリークが発生します）。</target>
        </trans-unit>
        <trans-unit id="51e02d156ab35053fbad0f57e42b76301b58ea18" translate="yes" xml:space="preserve">
          <source>While the variable declared in the range_declaration is usually used in the loop_statement, doing so is not required.</source>
          <target state="translated">range_declarationで宣言された変数は通常loop_statementで使用されますが、その必要はありません。</target>
        </trans-unit>
        <trans-unit id="6c5f647e812d8ac720bd9936607ee574df0ff21f" translate="yes" xml:space="preserve">
          <source>While throw-expression can be used to transfer control to an arbitrary block of code up the execution stack, for arbitrary reasons (similar to &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;), its intended usage is error handling.</source>
          <target state="translated">throw-expressionは、制御を実行スタックの任意のコードブロックに転送するために使用できますが、（ &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; と同様の）任意の理由により、その意図された使用法はエラー処理です。</target>
        </trans-unit>
        <trans-unit id="721c1b250c710b24bfafaf9daadc9fa8642ecac8" translate="yes" xml:space="preserve">
          <source>While with &lt;code&gt;copy_options::recursive&lt;/code&gt;, the subdirectories are also copied, with their content, recursively.</source>
          <target state="translated">&lt;code&gt;copy_options::recursive&lt;/code&gt; と、サブディレクトリもその内容とともに再帰的にコピーされます。</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">ワイドキャラクター</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">ワイドな文字配列操作</target>
        </trans-unit>
        <trans-unit id="6808058d5dd776d7c4d9454174f9c39df21f19c7" translate="yes" xml:space="preserve">
          <source>Wide character representation of &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; is a valid single-byte character in the initial shift state, &lt;code&gt;WEOF&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;(unsigned char)c&lt;/code&gt; が初期シフト状態で有効な1バイト文字の場合、 &lt;code&gt;c&lt;/code&gt; のワイド文字表現。それ以外の場合、 &lt;code&gt;WEOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab38913ae786de6e808a7c7241557b1856fc368e" translate="yes" xml:space="preserve">
          <source>Wide string manipulation</source>
          <target state="translated">ワイドな文字列操作</target>
        </trans-unit>
        <trans-unit id="e56ba2339bc3a2c7efd4a4f1ffa763681a4e7ccb" translate="yes" xml:space="preserve">
          <source>Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt;). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically &lt;code&gt;CharT(-1)&lt;/code&gt;.</source>
          <target state="translated">拡大は常にワイド文字を返しますが、基本的なソース文字セットの文字（ラテン文字、数字、およびC ++プログラムの作成に必要な句読点）のみが、一意で明確に定義された拡大変換を持つことが保証されます。 （ &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt; によって）可逆にする。 実際には、マルチバイト表現が1バイトであるすべての文字は通常、対応するワイド文字に拡大され、残りの可能な1バイト値は通常、同じプレースホルダー値（通常は &lt;code&gt;CharT(-1)&lt;/code&gt; )にマップされます。</target>
        </trans-unit>
        <trans-unit id="15d388cfaf360c5681944037eaaad4926f0761c9" translate="yes" xml:space="preserve">
          <source>Widening, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">拡張に成功した場合、 &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; で認識されているすべての文字分類カテゴリが保持されます。</target>
        </trans-unit>
        <trans-unit id="4e27d3de30e21293ff54a527696fb3dc557516fd" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; to its wide character equivalent.</source>
          <target state="translated">シングルバイト文字 &lt;code&gt;c&lt;/code&gt; を対応するワイド文字に拡張します。</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">データモデル別のビット幅</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">ウィン16 API</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">ウィン32エーピーアイ</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">ウィン64 API</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">&lt;code&gt;#pragma once&lt;/code&gt; では、同じヘッダーが表示されます。</target>
        </trans-unit>
        <trans-unit id="1d949445faea1f549e171010cf3291f2a325074c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;N = l - f&lt;/code&gt;, for all &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt;, &lt;code&gt;f[floor(&lt;table&gt;
&lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;)]&lt;/code&gt; does not compare less than &lt;code&gt;f[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N = l - f&lt;/code&gt; 場合、すべての &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt; に対して、 &lt;code&gt;f[floor(&lt;table&gt; &lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;)]&lt;/code&gt; &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; i-1 &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 2 &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; ）]は &lt;code&gt;f[i]&lt;/code&gt; 未満を比較しません。</target>
        </trans-unit>
        <trans-unit id="b0d81a9b5de91fa98a2d0ef9f4c7f4ecf47988e3" translate="yes" xml:space="preserve">
          <source>With \n instead of endl, the output would be the same, but may not appear in real time.</source>
          <target state="translated">endl の代わりに \n を使うと、出力は同じになりますが、リアルタイムでは出てこないかもしれません。</target>
        </trans-unit>
        <trans-unit id="47777a8b463cd5f1e3501816b2ffaa3ea107991e" translate="yes" xml:space="preserve">
          <source>With floating point types &lt;code&gt;std::to_string&lt;/code&gt; may yield unexpected results as the number of significant digits in the returned string can be zero, see the example.</source>
          <target state="translated">浮動小数点型の &lt;code&gt;std::to_string&lt;/code&gt; では、返される文字列の有効桁数がゼロになる可能性があるため、予期しない結果が生じる可能性があります。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="884b3b619e3ef18e83dc71855fd6e34d05de7659" translate="yes" xml:space="preserve">
          <source>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after usual arithmetic conversions), and the result of the binary minus operator is the result of subtracting the second operand from the first (after usual arithmetic conversions), except that, if the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">算術型または列挙型のオペランドの場合、バイナリプラスの結果はオペランドの合計であり（通常の算術変換後）、バイナリマイナス演算子の結果は最初のオペランドから2番目のオペランドを減算した結果です（通常の算術変換後）。 ）、ただし、型がIEEE浮動小数点演算をサポートしている場合（ &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; 参照）、</target>
        </trans-unit>
        <trans-unit id="fa16b9931c1f17c4f80ec1a246f1cc250c5dd37a" translate="yes" xml:space="preserve">
          <source>With the default allocator, this requirement is equivalent to the validity of &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;, which accepts class types with accessible destructors and all scalar types, but rejects array types, function types, reference types, and void.</source>
          <target state="translated">デフォルトのアロケータでは、この要件は、アクセス可能なデストラクタを持つクラス型とす​​べてのスカラー型を受け入れますが、配列型、関数型、参照型、およびvoidを拒否する &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; の有効性と同等です。</target>
        </trans-unit>
        <trans-unit id="b4fea2c438a60cf674bf6a42d287a393b3f62920" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;complex.h&lt;/code&gt; , each &lt;code&gt;xxx.h&lt;/code&gt; header included in the C++ standard library places in the global namespace each name that the corresponding &lt;code&gt;cxxx&lt;/code&gt; header would have placed in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;code&gt;complex.h&lt;/code&gt; を除いて、C ++標準ライブラリに含まれる各 &lt;code&gt;xxx.h&lt;/code&gt; ヘッダーは、対応する &lt;code&gt;cxxx&lt;/code&gt; ヘッダーが &lt;code&gt;std&lt;/code&gt; ネームスペースに配置した各名前をグローバルネームスペースに配置します。</target>
        </trans-unit>
        <trans-unit id="5d30f232b7061443bee920972c5d82807b94d345" translate="yes" xml:space="preserve">
          <source>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">C ++ 11の移動セマンティクスの導入により、値カテゴリが再定義され、式の2つの独立したプロパティが特徴付けられています&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7eedc43562dbda358e0af8f66b618c9779da2ba" translate="yes" xml:space="preserve">
          <source>Within a catch-clause, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; can be used to capture the exception in an &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; may be used to build nested exceptions.</source>
          <target state="translated">catch-clause内では、 &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; を使用して例外を &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; でき、 std :: throw_with_nestedを使用してネストされた例外を作成できます。</target>
        </trans-unit>
        <trans-unit id="245bc5b44f72c46518d49f6231bcdddbab7bc492" translate="yes" xml:space="preserve">
          <source>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the</source>
          <target state="translated">クラステンプレート定義(そのメンバ関数と入れ子になったクラスを含む)の中で、いくつかの名前は</target>
        </trans-unit>
        <trans-unit id="bc89bf6548ea7d54b0a391d0d3c8b9447ce5c361" translate="yes" xml:space="preserve">
          <source>Within a scope, &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; can be used to associate the name with its declaration.</source>
          <target state="translated">スコープ内では、 &lt;a href=&quot;lookup&quot;&gt;非修飾名ルックアップ&lt;/a&gt;を使用して、名前をその宣言に関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="00817315634a43af97703fb51abe4ea2bd10d529" translate="yes" xml:space="preserve">
          <source>Within a template definition, certain names are deduced to belong to an</source>
          <target state="translated">テンプレート定義の中で、特定の名前は</target>
        </trans-unit>
        <trans-unit id="7119f9b6e9a5c41a2215c5c5ab587c351e88a0e6" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/cv&quot;&gt;volatile glvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are</source>
          <target state="translated">実行のスレッド内では、 &lt;a href=&quot;../language/cv&quot;&gt;揮発性のglvalue&lt;/a&gt;を介したアクセス（読み取りと書き込み）は、次のような観察可能な副作用（他の揮発性アクセスを含む）を過ぎて並べ替えることはできません。</target>
        </trans-unit>
        <trans-unit id="6eda1a3a6846d50df7adc54351dedaf50fda69c3" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">可変引数を使用する関数の本体内で、これらの引数の値には、 &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt;ライブラリ機能&lt;/a&gt;を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="af7aded55b08b8ee429002640a601104c0c3e5cf" translate="yes" xml:space="preserve">
          <source>Within the body of a lambda, any use of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:</source>
          <target state="translated">ラムダの本体内では、自動ストレージ期間を持つ任意の変数での&lt;a href=&quot;decltype&quot;&gt;decltypeの&lt;/a&gt;使用は、それがキャプチャされてodrで使用されたかのようになります。</target>
        </trans-unit>
        <trans-unit id="078ca0cc0ac40495d119f9a3fdddbbaaae3dc64d" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, each identifier that names a non-static member is implicitly transformed to a class member access expression &lt;code&gt;this-&amp;gt;member&lt;/code&gt;.</source>
          <target state="translated">非静的&lt;a href=&quot;member_functions&quot;&gt;メンバー関数&lt;/a&gt;の本体内で、非静的メンバーを指定する各識別子は、クラスメンバーアクセス式 &lt;code&gt;this-&amp;gt;member&lt;/code&gt; に暗黙的に変換されます。</target>
        </trans-unit>
        <trans-unit id="79f7c80c73c316c30ac1674843481cc4326e1a44" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt; E (e.g. an identifier) that resolves to a non-type non-static member of X or of a base class of X, is transformed to a member access expression &lt;code&gt;(*this).E&lt;/code&gt; (unless it's already a part of a member access expression). This does not occur in template definition context, so a name may have to be prefixed with &lt;code&gt;this-&amp;gt;&lt;/code&gt; explicitly to become &lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;.</source>
          <target state="translated">Xの非静的メンバー関数の本体内で、Xの非タイプ非静的メンバーまたはXの基本クラスの非静的メンバーに解決される&lt;a href=&quot;expressions&quot;&gt;id式&lt;/a&gt; E（たとえば、識別子）は、メンバーアクセスに変換されます。式 &lt;code&gt;(*this).E&lt;/code&gt; （既にメンバーアクセス式の一部でない場合）。 これはテンプレート定義のコンテキストでは発生しないため、 &lt;a href=&quot;dependent_name&quot;&gt;依存&lt;/a&gt;するようにするには、名前の前に &lt;code&gt;this-&amp;gt;&lt;/code&gt; を明示的に付ける必要がある場合があります 。</target>
        </trans-unit>
        <trans-unit id="ff9fb1990c434e938a6a0e2d84512b173b30aeb8" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any unqualified-id that resolves to a static member, an enumerator or a nested type of X or of a base class of X, is transformed to the corresponding qualified-id.</source>
          <target state="translated">X の非静的メンバ関数のボディ内で、静的メンバ、列挙子、X の入れ子型、または X の基底クラスに解決する未修飾 ID は、対応する修飾 ID に変換されます。</target>
        </trans-unit>
        <trans-unit id="5ba9b5ad1328d649ca86d8f4a5d41ae2a5633cf1" translate="yes" xml:space="preserve">
          <source>Within the function body, the function-local predefined variable &lt;code&gt;__func__&lt;/code&gt; is defined as if by.</source>
          <target state="translated">関数本体内では、関数ローカルの事前定義変数 &lt;code&gt;__func__&lt;/code&gt; がbyのように定義されています。</target>
        </trans-unit>
        <trans-unit id="f89ece3e05e483d8d6633832e929cb8220c8daba" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A may be</source>
          <target state="translated">同じスレッド内では、評価Aは</target>
        </trans-unit>
        <trans-unit id="c72f89b6f5d83e25d732495d891540e02b9e90aa" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A that is</source>
          <target state="translated">同じスレッド内で</target>
        </trans-unit>
        <trans-unit id="25258e5219c6e5baefb975484506b38b6aa8362b" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">クラステンプレートの特殊化または部分的な特殊化のスコープ内で、注入されたクラス名がタイプ名として使用される場合、これはテンプレート名の後にクラステンプレートの特殊化または部分的な特殊化のテンプレート引数が続くのと同等です。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 内 。</target>
        </trans-unit>
        <trans-unit id="ce2fab5742c8b33bc0537c80ea3b8dcc2cc835e1" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template, the name of the template without a parameter list is an injected class name, and can be used as a type. In that case, class argument deduction does not happen and template parameters must be supplied explicitly:</source>
          <target state="translated">クラステンプレートの範囲内では、パラメータリストのないテンプレート名は、注入されたクラス名であり、型として使用することができます。その場合、クラス引数の推論は行われず、テンプレートのパラメータは明示的に与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="05619ddfa2c0d81e8a6ead6a708344745a722242" translate="yes" xml:space="preserve">
          <source>Without std::flush, the output would be the same, but may not appear in real time.</source>
          <target state="translated">std::flushがなければ、出力は同じですが、リアルタイムでは表示されないかもしれません。</target>
        </trans-unit>
        <trans-unit id="d0f55a4102a27df1431160445b96e34d20fd4f3d" translate="yes" xml:space="preserve">
          <source>Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.</source>
          <target state="translated">std::unitbuf や他の明示的なフラッシュがなければ、出力は同じですが、リアルタイムでは表示されません。</target>
        </trans-unit>
        <trans-unit id="682b37a0a9239f633eb0a18ad35c5e23fe316950" translate="yes" xml:space="preserve">
          <source>Working with a &lt;code&gt;priority_queue&lt;/code&gt; is similar to managing a &lt;a href=&quot;../algorithm/make_heap&quot;&gt; heap&lt;/a&gt; in some random access container, with the benefit of not being able to accidentally invalidate the heap.</source>
          <target state="translated">&lt;code&gt;priority_queue&lt;/code&gt; の操作は、ランダムアクセスコンテナーでの&lt;a href=&quot;../algorithm/make_heap&quot;&gt;ヒープの&lt;/a&gt;管理と似ていますが、 ヒープを誤って無効にできないという利点があります。</target>
        </trans-unit>
        <trans-unit id="8065f27e56565b08250cf2bdf011c92725655e0d" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">メンバー関数ポインターのラッパー。 呼び出すメンバー関数が &lt;code&gt;operator()&lt;/code&gt; へのポインターとして渡されるクラスインスタンス。</target>
        </trans-unit>
        <trans-unit id="a56128931adfe376f6d1c4233b2aee9d4414fed0" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">メンバー関数ポインターのラッパー。 呼び出すメンバー関数が &lt;code&gt;operator()&lt;/code&gt; への参照として渡されるクラスインスタンス。</target>
        </trans-unit>
        <trans-unit id="dd35487a2eb7da40332f7fc41452378d92a72445" translate="yes" xml:space="preserve">
          <source>Writable</source>
          <target state="translated">Writable</target>
        </trans-unit>
        <trans-unit id="a9b6a4bb633bad2e9e1e0bcdbb56726b9e0e6146" translate="yes" xml:space="preserve">
          <source>Write to end</source>
          <target state="translated">最後に書き込む</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">文字 &lt;code&gt;ch&lt;/code&gt; を &lt;code&gt;stdout&lt;/code&gt; に書き込みます。 内部的には、文字は書き込まれる直前に &lt;code&gt;unsigned char&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="a96b7df507ca67492643e29e1db1884cf6663933" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">文字 &lt;code&gt;ch&lt;/code&gt; を指定された出力ストリーム &lt;code&gt;stream&lt;/code&gt; に書き込みます 。</target>
        </trans-unit>
        <trans-unit id="001712686d4b96e8257e062bf8257f5854fb0c91" translate="yes" xml:space="preserve">
          <source>Writes a horizontal tab character.</source>
          <target state="translated">水平タブ文字を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b8a7060cb09fe871077059dd6f46ca33bbda1f49" translate="yes" xml:space="preserve">
          <source>Writes a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">リテラル &lt;code&gt;%&lt;/code&gt; 文字を書き込みます。</target>
        </trans-unit>
        <trans-unit id="cb18b1353d53796c65bfab0bce5e3151631b33c0" translate="yes" xml:space="preserve">
          <source>Writes a newline character.</source>
          <target state="translated">改行文字を書きます。</target>
        </trans-unit>
        <trans-unit id="6924072c304541be0f3e71e77883f2ec6c6a9d14" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of a thread identifier &lt;code&gt;id&lt;/code&gt; to the output stream &lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">スレッド識別子 &lt;code&gt;id&lt;/code&gt; のテキスト表現を出力ストリーム &lt;code&gt;ost&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="767a6e009054da5918825851e61b1c02bbbf738a" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;os&lt;/code&gt;. The formatting flags and fill character of &lt;code&gt;os&lt;/code&gt; are unchanged.</source>
          <target state="translated">分布パラメーターと内部状態のテキスト表現を &lt;code&gt;os&lt;/code&gt; に書き込みます。 &lt;code&gt;os&lt;/code&gt; のフォーマットフラグと塗りつぶし文字は変更されていません。</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">ワイド文字 &lt;code&gt;ch&lt;/code&gt; を &lt;code&gt;stdout&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">ワイド文字 &lt;code&gt;ch&lt;/code&gt; を指定された出力ストリーム &lt;code&gt;stream&lt;/code&gt; に書き込みます 。 &lt;code&gt;putwc()&lt;/code&gt; はマクロとして実装でき、 &lt;code&gt;stream&lt;/code&gt; 複数回評価できます 。</target>
        </trans-unit>
        <trans-unit id="bb34f2576c279e7725c583723fccb0fc6a3511eb" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 繰り返し実行するかのように、nullで終了する文字列 &lt;code&gt;str&lt;/code&gt; と1つの追加の改行文字 &lt;code&gt;'\n'&lt;/code&gt; からすべての文字を出力ストリーム &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="5a503bcd94956c4103d38ea588d00af71b7d3a70" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 繰り返し実行するかのように、nullで終了する文字列 &lt;code&gt;str&lt;/code&gt; からすべての文字を出力ストリーム &lt;code&gt;stream&lt;/code&gt; に書き込みます 。</target>
        </trans-unit>
        <trans-unit id="83ab79edfcdea5e94d3e192eb9d45b8f6bebd9bf" translate="yes" xml:space="preserve">
          <source>Writes every wide character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt; 繰り返し実行するかのように、nullで終了するワイド文字列 &lt;code&gt;str&lt;/code&gt; からすべてのワイド文字を出力ストリーム &lt;code&gt;stream&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="a9b88a484ae89e6d4131f01f0c94c90cbf9dc18c" translate="yes" xml:space="preserve">
          <source>Writes one character to the output sequence.</source>
          <target state="translated">1 文字を出力シーケンスに書き込みます。</target>
        </trans-unit>
        <trans-unit id="3aeb20d4e3a246faca11563fb03064671edc3f42" translate="yes" xml:space="preserve">
          <source>Writes some data from the put area to the associated character sequence (to the file).</source>
          <target state="translated">put 領域から関連する文字列にデータを書き込みます(ファイルに)。</target>
        </trans-unit>
        <trans-unit id="74f04ede6f753ddec049a69f229f7dc13079d99c" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week of the year as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">ISO 8601年の週を10進数で書き出します。結果が一桁の場合は、0が接頭辞となります。</target>
        </trans-unit>
        <trans-unit id="f7d029ddd98ce63f15114123e69a3596edcb4ab0" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week-based year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">ISO 8601週ベースの年を10進数で書き出します。結果が4桁未満の場合は、0から4桁の数字を左寄せします。</target>
        </trans-unit>
        <trans-unit id="0cc1164d46d9e7c267ced7895e6152ab0b695562" translate="yes" xml:space="preserve">
          <source>Writes the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ISOの曜日を10進数（1〜7）で書き込みます。月曜日は &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="71166ded75b14ffa703a04ab3f28950a6779e502" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">月の曜日を10進数で書き出します。結果が10進数1桁の場合は、0が接頭辞となります。</target>
        </trans-unit>
        <trans-unit id="b0f7893ae9d8e28cab469762cfa8b52ab87190ba" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with a space.</source>
          <target state="translated">月の曜日を10進数で書き出します。結果が10進数1桁の場合は、先頭にスペースを付けます。</target>
        </trans-unit>
        <trans-unit id="1626fbac11740992d51707eebf9b1bc3e70c4e3f" translate="yes" xml:space="preserve">
          <source>Writes the day of the year as a decimal number (January 1 is &lt;code&gt;001&lt;/code&gt;). If the result is less than three digits, it is left-padded with 0 to three digits.</source>
          <target state="translated">年間通算日を10進数として書き込みます（1月1日は &lt;code&gt;001&lt;/code&gt; ）。 結果が3桁未満の場合は、0から3桁が左側に埋め込まれます。</target>
        </trans-unit>
        <trans-unit id="c029d304cd7d0c5128b916f1b7935a6092ee6d60" translate="yes" xml:space="preserve">
          <source>Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">時間(12時間時計)を10進数で書き出します。結果が1桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="d586ae48a03fbce6cab63eb6156b184051a469fd" translate="yes" xml:space="preserve">
          <source>Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">時間(24時間時計)を10進数で書き出します。結果が一桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="67151c9d086e78a6b607bc1d8cdeea642b931db1" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the ISO 8601 week-based year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">ISO 8601週ベースの年の小数点以下2桁を書き込みます。結果が1桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="9ff9a700dc66f1c252bd7007b0facde18742ff7d" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">年の下2桁の小数点以下の数字を書き込みます。結果が1桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="30b48d91697b9f629d02ce9d83e7a421c921e234" translate="yes" xml:space="preserve">
          <source>Writes the locale's 12-hour clock time.</source>
          <target state="translated">ロケールの12時間の時刻を記述します。</target>
        </trans-unit>
        <trans-unit id="a971b059080c39ac822e661aea1c87ec25348313" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated month name.</source>
          <target state="translated">ロケールの短縮形の月名を書き込みます。</target>
        </trans-unit>
        <trans-unit id="f672aa4e85699374012ee1a535ef52d6be86123e" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated weekday name.</source>
          <target state="translated">ロケールの平日の省略形の名前を書きます。</target>
        </trans-unit>
        <trans-unit id="a93c6febd8287cd73094f5c7fa21ffc07a57cd24" translate="yes" xml:space="preserve">
          <source>Writes the locale's date and time representation.</source>
          <target state="translated">ロケールの日付と時刻の表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="8990ab22cb03b6694ce6cb909d61b54ae50e921c" translate="yes" xml:space="preserve">
          <source>Writes the locale's date representation.</source>
          <target state="translated">ロケールの日付表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="1dec9978ca81332b5e90610cec498718c6ecefef" translate="yes" xml:space="preserve">
          <source>Writes the locale's equivalent of the AM/PM designations associated with a 12-hour clock.</source>
          <target state="translated">ロケールのAMPM指定と同等のものを、12時間時計に関連付けて書き込みます。</target>
        </trans-unit>
        <trans-unit id="4bd0b778c0ca16103f3037347259706f50406b6f" translate="yes" xml:space="preserve">
          <source>Writes the locale's full month name.</source>
          <target state="translated">ロケールの完全な月名を書き込みます。</target>
        </trans-unit>
        <trans-unit id="dbcf68702a0a2c1386e6fd13ec2cac6f00c12942" translate="yes" xml:space="preserve">
          <source>Writes the locale's full weekday name.</source>
          <target state="translated">ロケールの完全な平日の名前を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ba5f45187c6fabe4410c47f297770de07e96243b" translate="yes" xml:space="preserve">
          <source>Writes the locale's time representation.</source>
          <target state="translated">ロケールの時間表現を書き込みます。</target>
        </trans-unit>
        <trans-unit id="fc68d043b917adc440f4f576ac7e4b54287ebed4" translate="yes" xml:space="preserve">
          <source>Writes the minute as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">分を10進数で書き出します。結果が1桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="c30fe76679f32dcce8e852b50af05cbd5aefe9f6" translate="yes" xml:space="preserve">
          <source>Writes the month as a decimal number (January is &lt;code&gt;01&lt;/code&gt;). If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">月を10進数として書き込みます（Januaryは &lt;code&gt;01&lt;/code&gt; ）。 結果が1桁の場合は、先頭に0が付きます。</target>
        </trans-unit>
        <trans-unit id="8032e3a64c8132ccb6ad44a63e27ef9ad4339e8a" translate="yes" xml:space="preserve">
          <source>Writes the offset from UTC in the ISO 8601 format. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC. If the offset is zero, &lt;code&gt;+0000&lt;/code&gt; is used.</source>
          <target state="translated">UTCからのオフセットをISO 8601形式で書き込みます。 たとえば、 &lt;code&gt;-0430&lt;/code&gt; はUTCから4時間30分遅れていることを示します。 オフセットがゼロの場合、 &lt;code&gt;+0000&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="9d76d87840d6936192aee3cda5289202c38d7018" translate="yes" xml:space="preserve">
          <source>Writes the representation of the matched subsequence &lt;code&gt;m&lt;/code&gt; to the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">一致したサブシーケンス &lt;code&gt;m&lt;/code&gt; の表現を出力ストリーム &lt;code&gt;os&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="17feef3d0503048639900d16af24c9e6fe4685c7" translate="yes" xml:space="preserve">
          <source>Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with 0.</source>
          <target state="translated">秒を10進数として書き込みます。秒数が10未満の場合は、結果の先頭に0を付けます。</target>
        </trans-unit>
        <trans-unit id="1a73b5e51c193b1deccbfaf669b4db12b0a55d6d" translate="yes" xml:space="preserve">
          <source>Writes the time zone abbreviation.</source>
          <target state="translated">タイムゾーンの略語を書き込みます。</target>
        </trans-unit>
        <trans-unit id="1d8938025c2761da9ede064d18f5ef84dcf58261" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">その年の週号を10進数で書きます。その年の最初の月曜日が第01週の初日となります。それ以前の同じ年の日は00週目になります。結果が一桁の場合は、先頭に0を付けます。</target>
        </trans-unit>
        <trans-unit id="370c8fdb39d9f2b4190c27cb6e07474705f3c637" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">その年の週号を10進数で書きます。その年の最初の日曜日が01週目の初日となります。それ以前の同じ年の日は00週目になります。結果が一桁の場合は0が先頭になります。</target>
        </trans-unit>
        <trans-unit id="dbdae9db0bd7c298a373f28a7cd0509bbbb5b272" translate="yes" xml:space="preserve">
          <source>Writes the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">曜日を10進数（0-6）として書き込み &lt;code&gt;0&lt;/code&gt; 。日曜日は0です。</target>
        </trans-unit>
        <trans-unit id="bb21ea8cdea47573e1038fbae721d5dca3fb901b" translate="yes" xml:space="preserve">
          <source>Writes the year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">年を10進数で書き出します。結果が4桁未満の場合は、0から4桁の数字を左寄せします。</target>
        </trans-unit>
        <trans-unit id="26249ba8d699dd0df931793d3da64b00c7c31d1d" translate="yes" xml:space="preserve">
          <source>Writes the year divided by 100 using floored division. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">フロアー除算を使用して、100で割った年を書き込みます。結果が10進数1桁の場合は、先頭に0を付けます。</target>
        </trans-unit>
        <trans-unit id="a77785063b2874f1bbee1b042250317d98d6b33a" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;os&lt;/code&gt; the textual representation of &lt;code&gt;x&lt;/code&gt;'s current state. In the output, adjacent numbers are separated by one or more space characters. If &lt;code&gt;os&lt;/code&gt;'s fmtflags are not set to &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt;, the behavior may be undefined.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の現在の状態のテキスト表現を &lt;code&gt;os&lt;/code&gt; に書き込みます。 出力では、隣接する番号は1つ以上のスペース文字で区切られます。 &lt;code&gt;os&lt;/code&gt; のfmtflagsが &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt; に設定されていない場合、動作が定義されていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d621d908346c0bfe11eb811537d53c64ce8ec02" translate="yes" xml:space="preserve">
          <source>Writes to fields</source>
          <target state="translated">フィールドへの書き込み</target>
        </trans-unit>
        <trans-unit id="00c192b84cfa44d2bd75c59846c86d17a1e44b25" translate="yes" xml:space="preserve">
          <source>Writes uncommitted changes to the underlying output sequence.</source>
          <target state="translated">コミットされていない変更を、その下にある出力シーケンスに書き込みます。</target>
        </trans-unit>
        <trans-unit id="15ec5b51c4d780460bc9101843d2786a8b364326" translate="yes" xml:space="preserve">
          <source>Writes up to &lt;code&gt;count&lt;/code&gt; binary objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">指定された配列 &lt;code&gt;buffer&lt;/code&gt; から出力ストリーム &lt;code&gt;stream&lt;/code&gt; に、最大で &lt;code&gt;count&lt;/code&gt; 個のバイナリオブジェクトを書き込みます 。 オブジェクトは、各オブジェクトを &lt;code&gt;unsigned char&lt;/code&gt; の配列として再解釈し、各オブジェクトが &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 回呼び出して、それらの &lt;code&gt;unsigned char&lt;/code&gt; を順に &lt;code&gt;stream&lt;/code&gt; に書き込むかのように書き込まれます 。 ストリームのファイル位置インジケーターは、書き込まれた文字数だけ進みます。</target>
        </trans-unit>
        <trans-unit id="c8447596ae9170966e015adf6c315155e2268bda" translate="yes" xml:space="preserve">
          <source>Writing to the character array accessed through &lt;code&gt;c_str()&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; を介してアクセスされる文字配列への書き込みは、未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="93cad4f773cccfbb33c80bc8546680efa75c09a4" translate="yes" xml:space="preserve">
          <source>X and X</source>
          <target state="translated">XとX</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">シングルトータルオーダーではBの前にXとXが表示される</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">X引数</target>
        </trans-unit>
        <trans-unit id="4ca65c470ec6016fed78ab6aef93dd257702b23f" translate="yes" xml:space="preserve">
          <source>X, X</source>
          <target state="translated">X,X</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X,Y は</target>
        </trans-unit>
        <trans-unit id="9ea35756029154e9210bcca0b65c206107747ec2" translate="yes" xml:space="preserve">
          <source>X, and X</source>
          <target state="translated">X、そしてX</target>
        </trans-unit>
        <trans-unit id="565e6a618c216015d885283111a97727e2c3f173" translate="yes" xml:space="preserve">
          <source>X, and X is</source>
          <target state="translated">Xであり、Xは</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Y引数</target>
        </trans-unit>
        <trans-unit id="ba12622aee8e1cee306fb2ae1705d34dc28d369e" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before F in thread B</source>
          <target state="translated">スレッドBのFよりも前にYが配列されています。</target>
        </trans-unit>
        <trans-unit id="ed1a905ea4a6fcc0ca7ba73cce1620307e6d6ffa" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before FB in thread B</source>
          <target state="translated">YはスレッドBのFB前に配列されています。</target>
        </trans-unit>
        <trans-unit id="3850869b7a202e66b87556b87c42f6e3bad33150" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or by the &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt;)</source>
          <target state="translated">Yは、X（またはXで始まる&lt;a href=&quot;memory_order&quot;&gt;リリースシーケンス&lt;/a&gt; ）によって書き込まれた値を読み取ります。</target>
        </trans-unit>
        <trans-unit id="1038aa0966244ed387fbcfee4940af4843ba1a40" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or the value would be written by &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt; if X were a release operation)</source>
          <target state="translated">YはXによって書き込まれた値を読み取ります（または、Xが解放操作の場合、値は&lt;a href=&quot;memory_order&quot;&gt;Xを先頭とする解放シーケンス&lt;/a&gt;によって書き込まれます）</target>
        </trans-unit>
        <trans-unit id="4d77689f2569037f676a633b110bf28151defd7c" translate="yes" xml:space="preserve">
          <source>Y, and Y is</source>
          <target state="translated">Yであり、Yは</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="869ef4891ca6fa4509dc520e3f6640c9b0cfae4a" translate="yes" xml:space="preserve">
          <source>Year, day, month</source>
          <target state="translated">年、日、月</target>
        </trans-unit>
        <trans-unit id="915f26f629fd3d6f51a4b7d5990e0b50d4471157" translate="yes" xml:space="preserve">
          <source>Year, month, day</source>
          <target state="translated">年、月、日</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="f1e34b1b0b0addb32d44f2528bede851abf77e03" translate="yes" xml:space="preserve">
          <source>Yes, except erased element(s)</source>
          <target state="translated">消去された要素を除く</target>
        </trans-unit>
        <trans-unit id="7ed1f0e98f8b97a0cbc079098f9b970f72dbe20e" translate="yes" xml:space="preserve">
          <source>Yield-expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.</source>
          <target state="translated">Yield-expressionは呼び出し元に値を返し、現在のコルーチンを一時停止します。</target>
        </trans-unit>
        <trans-unit id="1791a81aeb4f78d0ab4f9096c83089810fc43595" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; if for some &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; and &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</source>
          <target state="translated">収量 &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; および &lt;code&gt;d&lt;/code&gt; の場合、 &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; および &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="729d384e3fcd3d72644a0c1418ba7a729b79ac57" translate="yes" xml:space="preserve">
          <source>ZERO WIDTH SPACE - ZERO WIDTH JOINER</source>
          <target state="translated">ゼロ幅空間-ゼロ幅ジョイナー</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; と &lt;code&gt;rhs&lt;/code&gt; が等しい場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="917c36f59225ed77c40603a32141411ab5f9fea6" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, one plus the base-2 logarithm of &lt;code&gt;x&lt;/code&gt;, with any fractional part discarded.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がゼロの場合はゼロ。 それ以外の場合は、1に &lt;code&gt;x&lt;/code&gt; の 2を底とする対数を加え、小数部分は破棄されます。</target>
        </trans-unit>
        <trans-unit id="0f17813fad92e667b30a4557d41d38bf185f1f8c" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がゼロの場合はゼロ。 それ以外の場合は、 &lt;code&gt;x&lt;/code&gt; 以下の2の最大のべき乗。</target>
        </trans-unit>
        <trans-unit id="405ae0fba6c1904278eb371bc24b47d81b1d7d3c" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed in the following situations:</source>
          <target state="translated">ゼロ初期化は以下のような状況で行われます。</target>
        </trans-unit>
        <trans-unit id="a1be729d580f443d76655de63a066d43b5c754d5" translate="yes" xml:space="preserve">
          <source>Zero or more of the following:</source>
          <target state="translated">以下のうちゼロ以上。</target>
        </trans-unit>
        <trans-unit id="d00bedfb8c02a9e78a0c8655d079c8a74339369e" translate="yes" xml:space="preserve">
          <source>Zero otherwise</source>
          <target state="translated">そうでなければゼロ</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="c1734847a74561b4543b119ae934914f50b4cfb4" translate="yes" xml:space="preserve">
          <source>[-x3</source>
          <target state="translated">[-x3</target>
        </trans-unit>
        <trans-unit id="d750010a709171aa3f400cbe019efe556b93b506" translate="yes" xml:space="preserve">
          <source>[0,</source>
          <target state="translated">[0,</target>
        </trans-unit>
        <trans-unit id="e61dea886117af6d2ec7f9dcb7bd9a3411c6e61f" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;ranges::begin(E)&lt;/code&gt;, &lt;code&gt;ranges::end(E)&lt;/code&gt;) denotes a range, and</source>
          <target state="translated">[ &lt;code&gt;ranges::begin(E)&lt;/code&gt; 、 &lt;code&gt;ranges::end(E)&lt;/code&gt; ）は範囲を示し、</target>
        </trans-unit>
        <trans-unit id="228f7d207920fb84335fac5b2b06ed7b472ece9e" translate="yes" xml:space="preserve">
          <source>[deleted]</source>
          <target state="translated">[deleted]</target>
        </trans-unit>
        <trans-unit id="73a877ccfe464539ac89cb8083cf71234db18da5" translate="yes" xml:space="preserve">
          <source>[first,first)</source>
          <target state="translated">[first,first)</target>
        </trans-unit>
        <trans-unit id="7231a3611aa5bad8f818b0f7bb419a3d1200483d" translate="yes" xml:space="preserve">
          <source>[first,last)</source>
          <target state="translated">[first,last)</target>
        </trans-unit>
        <trans-unit id="2855c5627ea838aafc570baf3e8f5ddda039170b" translate="yes" xml:space="preserve">
          <source>[last,last)</source>
          <target state="translated">[last,last)</target>
        </trans-unit>
        <trans-unit id="51f320773f671463a4338fa2cd7489e0a7d0a19d" translate="yes" xml:space="preserve">
          <source>[nothrow-]swappable traits</source>
          <target state="translated">ノットロー]スワップ可能な形質</target>
        </trans-unit>
        <trans-unit id="2706c6dc283ec831e2ea7c5771adc61d0195a5e5" translate="yes" xml:space="preserve">
          <source>[static]</source>
          <target state="translated">[static]</target>
        </trans-unit>
        <trans-unit id="44fed6b6252fc5fda7cc744792424bdd0b7b1020" translate="yes" xml:space="preserve">
          <source>[static](C++11)</source>
          <target state="translated">[static](C++11)</target>
        </trans-unit>
        <trans-unit id="e4b4e5b6ec02f085b66944f0e3a63cac3c002038" translate="yes" xml:space="preserve">
          <source>[static](C++17)</source>
          <target state="translated">[static](C++17)</target>
        </trans-unit>
        <trans-unit id="0352562c44ca57a96c86a8ce2c63b508390a988b" translate="yes" xml:space="preserve">
          <source>[static](C++20)</source>
          <target state="translated">[static](C++20)</target>
        </trans-unit>
        <trans-unit id="85894ee8b74956e4f1ad040534bebb4a92408ba9" translate="yes" xml:space="preserve">
          <source>[static](optional)</source>
          <target state="translated">[static](optional)</target>
        </trans-unit>
        <trans-unit id="e621ceda2c534b69cb910cae3059eb9ff125986d" translate="yes" xml:space="preserve">
          <source>[virtual]</source>
          <target state="translated">[virtual]</target>
        </trans-unit>
        <trans-unit id="986bbf2f9f0c3cbbc6546d685166748b60c20798" translate="yes" xml:space="preserve">
          <source>[virtual](C++11)</source>
          <target state="translated">[virtual](C++11)</target>
        </trans-unit>
        <trans-unit id="8af4f9130ab9142006b068ed0c1ed35271abd3b0" translate="yes" xml:space="preserve">
          <source>[virtual](implicitly declared)</source>
          <target state="translated">仮想](暗黙のうちに宣言された)</target>
        </trans-unit>
        <trans-unit id="a80e5ea0695ed7f04f7f2926fafe2f96aa4dcb23" translate="yes" xml:space="preserve">
          <source>[x2</source>
          <target state="translated">[x2</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">ラジアンを返します。</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">]を返します。</target>
        </trans-unit>
        <trans-unit id="056353e23af4506e74d7003cb38640abbea6a449" translate="yes" xml:space="preserve">
          <source>]1/2</source>
          <target state="translated">]1/2</target>
        </trans-unit>
        <trans-unit id="2543ff7b78f94174e33e9adeb84f297edc54fffa" translate="yes" xml:space="preserve">
          <source>_1, _2, _3, _4, ...</source>
          <target state="translated">_1,_2,_3,_4,...</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="ce0bc0efbd8965b4d82a11aa07f4fab94777d3af" translate="yes" xml:space="preserve">
          <source>__STDCPP_DEFAULT_NEW_ALIGNMENT__</source>
          <target state="translated">__STDCPP_DEFAULT_NEW_ALIGNMENT__</target>
        </trans-unit>
        <trans-unit id="db9a3eaebbc58b7b2dff63e6d1078194a02871a4" translate="yes" xml:space="preserve">
          <source>__STDCPP_STRICT_POINTER_SAFETY__</source>
          <target state="translated">__STDCPP_STRICT_POINTER_SAFETY__</target>
        </trans-unit>
        <trans-unit id="950ee9617b60ace35791cfba67c4eda35d86e1d5" translate="yes" xml:space="preserve">
          <source>__STDCPP_THREADS__</source>
          <target state="translated">__STDCPP_THREADS__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="d950e8ee18472fe83432e8178dd5392fac322513" translate="yes" xml:space="preserve">
          <source>__bool_true_false_are_defined</source>
          <target state="translated">__bool_true_false_are_defined</target>
        </trans-unit>
        <trans-unit id="a6268e3a2fc1725738e330bb09c9305b72ece231" translate="yes" xml:space="preserve">
          <source>__cplusplus</source>
          <target state="translated">__cplusplus</target>
        </trans-unit>
        <trans-unit id="e03702be2b6d9f308bc474cdb111403f31d2ea87" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_bases</source>
          <target state="translated">__cpp_aggregate_bases</target>
        </trans-unit>
        <trans-unit id="78f7eebcfee8baee7f506621f7ceff180ebb38c2" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_nsdmi</source>
          <target state="translated">__cpp_aggregate_nsdmi</target>
        </trans-unit>
        <trans-unit id="aecf58d673edcb66d050d3e2e7eba5a0afe4185c" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_paren_init</source>
          <target state="translated">__cpp_aggregate_paren_init</target>
        </trans-unit>
        <trans-unit id="4db17205b03376efcf08532704df0a94b80ff2e1" translate="yes" xml:space="preserve">
          <source>__cpp_alias_templates</source>
          <target state="translated">__cpp_alias_templates</target>
        </trans-unit>
        <trans-unit id="1b50ffd26242db4d6bb36e8a073d57b42af92dbe" translate="yes" xml:space="preserve">
          <source>__cpp_aligned_new</source>
          <target state="translated">__cpp_aligned_new</target>
        </trans-unit>
        <trans-unit id="27d2797bf877b1368535c5fbc7789bf8e7a43d75" translate="yes" xml:space="preserve">
          <source>__cpp_attributes</source>
          <target state="translated">__cpp_attributes</target>
        </trans-unit>
        <trans-unit id="fa07d30cba0187822a54da7812f67ef73fb0b29b" translate="yes" xml:space="preserve">
          <source>__cpp_binary_literals</source>
          <target state="translated">__cpp_binary_literals</target>
        </trans-unit>
        <trans-unit id="9233221aaacde95fdd55b38eb0f389324843a986" translate="yes" xml:space="preserve">
          <source>__cpp_capture_star_this</source>
          <target state="translated">__cpp_capture_star_this</target>
        </trans-unit>
        <trans-unit id="fbff2a2d3bc0732868b008428dd2e17daf86c9d1" translate="yes" xml:space="preserve">
          <source>__cpp_char8_t</source>
          <target state="translated">__cpp_char8_t</target>
        </trans-unit>
        <trans-unit id="35879cf6edddadc7f07576b594f812ccd01e0e28" translate="yes" xml:space="preserve">
          <source>__cpp_conditional_explicit</source>
          <target state="translated">__cpp_conditional_explicit</target>
        </trans-unit>
        <trans-unit id="6554a18ee88c8522382d28ab36f8ebd7e175fe13" translate="yes" xml:space="preserve">
          <source>__cpp_constexpr</source>
          <target state="translated">__cpp_constexpr</target>
        </trans-unit>
        <trans-unit id="e1c9cd84aa5ce04eef2027ea160ca3290b7ad000" translate="yes" xml:space="preserve">
          <source>__cpp_coroutines</source>
          <target state="translated">__cpp_coroutines</target>
        </trans-unit>
        <trans-unit id="1a2e5b6980d3ec352ab8610b6aebe0331f7c85de" translate="yes" xml:space="preserve">
          <source>__cpp_decltype</source>
          <target state="translated">__cpp_decltype</target>
        </trans-unit>
        <trans-unit id="30e058b311be2115aab20cb7ab797af4bf73322c" translate="yes" xml:space="preserve">
          <source>__cpp_decltype_auto</source>
          <target state="translated">__cpp_decltype_auto</target>
        </trans-unit>
        <trans-unit id="242a749b73f040bf68fa933b9175781fd85d21c1" translate="yes" xml:space="preserve">
          <source>__cpp_deduction_guides</source>
          <target state="translated">__cpp_deduction_guides</target>
        </trans-unit>
        <trans-unit id="3a8bdd7fb017e4f5b12dd8b2fab50c0f9a716657" translate="yes" xml:space="preserve">
          <source>__cpp_delegating_constructors</source>
          <target state="translated">__cpp_delegating_constructors</target>
        </trans-unit>
        <trans-unit id="975250ed39319bc10f0e4f6ba32b904cf175257c" translate="yes" xml:space="preserve">
          <source>__cpp_enumerator_attributes</source>
          <target state="translated">__cpp_enumerator_attributes</target>
        </trans-unit>
        <trans-unit id="3b5c1d2ec9a03cdd0631a101d55a030f176f3d74" translate="yes" xml:space="preserve">
          <source>__cpp_fold_expressions</source>
          <target state="translated">__cpp_fold_expressions</target>
        </trans-unit>
        <trans-unit id="dd54e558a55e90a31a278a30b8a17bd0470a27e5" translate="yes" xml:space="preserve">
          <source>__cpp_generic_lambdas</source>
          <target state="translated">__cpp_generic_lambdas</target>
        </trans-unit>
        <trans-unit id="5851aabfab46bf1cf3f38d2a662260f69f39fefc" translate="yes" xml:space="preserve">
          <source>__cpp_guaranteed_copy_elision</source>
          <target state="translated">__cpp_guaranteed_copy_elision</target>
        </trans-unit>
        <trans-unit id="64dc522012e8e37b94c68ea1e95e711e0d899c02" translate="yes" xml:space="preserve">
          <source>__cpp_hex_float</source>
          <target state="translated">__cpp_hex_float</target>
        </trans-unit>
        <trans-unit id="3817658cc0a09b582191a5b7ff9d3c12fb638b2d" translate="yes" xml:space="preserve">
          <source>__cpp_if_constexpr</source>
          <target state="translated">__cpp_if_constexpr</target>
        </trans-unit>
        <trans-unit id="01e50fa24457c5e9436a8e8e470f75ec87f89e94" translate="yes" xml:space="preserve">
          <source>__cpp_impl_destroying_delete</source>
          <target state="translated">__cpp_impl_destroying_delete</target>
        </trans-unit>
        <trans-unit id="10f562ee8727c9aeeefccee7e22065b234af8837" translate="yes" xml:space="preserve">
          <source>__cpp_impl_three_way_comparison</source>
          <target state="translated">__cpp_impl_three_way_comparison</target>
        </trans-unit>
        <trans-unit id="8372b211ab7aa3d2db5ef6dbe4bf9e84d46edd52" translate="yes" xml:space="preserve">
          <source>__cpp_inheriting_constructors</source>
          <target state="translated">__cpp_inheriting_constructors</target>
        </trans-unit>
        <trans-unit id="8db78a428ed6164ef434f29d445b397d48025bd3" translate="yes" xml:space="preserve">
          <source>__cpp_init_captures</source>
          <target state="translated">__cpp_init_captures</target>
        </trans-unit>
        <trans-unit id="3331bad3edb7735ec64c6916056cfc10590dcf69" translate="yes" xml:space="preserve">
          <source>__cpp_initializer_lists</source>
          <target state="translated">__cpp_initializer_lists</target>
        </trans-unit>
        <trans-unit id="81e37cead058df9398dca1e6d13208a976c4012c" translate="yes" xml:space="preserve">
          <source>__cpp_inline_variables</source>
          <target state="translated">__cpp_inline_variables</target>
        </trans-unit>
        <trans-unit id="3c68286ccf869158575094937b8b2a98ffb48599" translate="yes" xml:space="preserve">
          <source>__cpp_lambdas</source>
          <target state="translated">__cpp_lambdas</target>
        </trans-unit>
        <trans-unit id="2590a0ceb1649ffba013a25521809a21cd1284de" translate="yes" xml:space="preserve">
          <source>__cpp_namespace_attributes</source>
          <target state="translated">__cpp_namespace_attributes</target>
        </trans-unit>
        <trans-unit id="30cc60a82cc1d4477a2e07c1fa7a6a64cc1023c3" translate="yes" xml:space="preserve">
          <source>__cpp_noexcept_function_type</source>
          <target state="translated">__cpp_noexcept_function_type</target>
        </trans-unit>
        <trans-unit id="2593d2642e9db46e71f999b1bc148024d6d0b831" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_args</source>
          <target state="translated">__cpp_nontype_template_args</target>
        </trans-unit>
        <trans-unit id="1892415e299d418abcb2ce3608af04f19ac199e1" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_auto</source>
          <target state="translated">__cpp_nontype_template_parameter_auto</target>
        </trans-unit>
        <trans-unit id="8e2497a317030abf3388ed8fcdc0f581460fd74b" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_class</source>
          <target state="translated">__cpp_nontype_template_parameter_class</target>
        </trans-unit>
        <trans-unit id="6f298ec98a281e895e57730ee42e4b685bf1d6e1" translate="yes" xml:space="preserve">
          <source>__cpp_nsdmi</source>
          <target state="translated">__cpp_nsdmi</target>
        </trans-unit>
        <trans-unit id="7844fe22ff8583f864600cf24c8acf071a07a268" translate="yes" xml:space="preserve">
          <source>__cpp_range_based_for</source>
          <target state="translated">__cpp_range_based_for</target>
        </trans-unit>
        <trans-unit id="e94a403428d4ea97b6f263dbcb0874c541f05fc8" translate="yes" xml:space="preserve">
          <source>__cpp_raw_strings</source>
          <target state="translated">__cpp_raw_strings</target>
        </trans-unit>
        <trans-unit id="2a807128a5985f4aedc323c209f0b26cf031ddc5" translate="yes" xml:space="preserve">
          <source>__cpp_ref_qualifiers</source>
          <target state="translated">__cpp_ref_qualifiers</target>
        </trans-unit>
        <trans-unit id="ec7f8108d8bd7c3189219118c4b92ebae110f376" translate="yes" xml:space="preserve">
          <source>__cpp_return_type_deduction</source>
          <target state="translated">__cpp_return_type_deduction</target>
        </trans-unit>
        <trans-unit id="a27448bb794e05840712bcbb343a4cbf12fadae2" translate="yes" xml:space="preserve">
          <source>__cpp_rvalue_references</source>
          <target state="translated">__cpp_rvalue_references</target>
        </trans-unit>
        <trans-unit id="28d6e14e6e0b8b130a165866cca9649aa7e9d864" translate="yes" xml:space="preserve">
          <source>__cpp_sized_deallocation</source>
          <target state="translated">__cpp_sized_deallocation</target>
        </trans-unit>
        <trans-unit id="d77473f1a619fc342dfc9123063a318297214d20" translate="yes" xml:space="preserve">
          <source>__cpp_static_assert</source>
          <target state="translated">__cpp_static_assert</target>
        </trans-unit>
        <trans-unit id="af80adf8b09bcfceb7e7134decd3d99ebd88c373" translate="yes" xml:space="preserve">
          <source>__cpp_structured_bindings</source>
          <target state="translated">__cpp_structured_bindings</target>
        </trans-unit>
        <trans-unit id="5456a2323fecac083d969b4421be5b3b5e785149" translate="yes" xml:space="preserve">
          <source>__cpp_template_template_args</source>
          <target state="translated">__cpp_template_template_args</target>
        </trans-unit>
        <trans-unit id="ddc5e77386a83826283ed12a4b5d3455f2275f1a" translate="yes" xml:space="preserve">
          <source>__cpp_threadsafe_static_init</source>
          <target state="translated">__cpp_threadsafe_static_init</target>
        </trans-unit>
        <trans-unit id="a51600d8c1a1f10a16f1e43b746d8821a1ba5bff" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_characters</source>
          <target state="translated">__cpp_unicode_characters</target>
        </trans-unit>
        <trans-unit id="696ac6453d6507dd7871ba65e03fe52e19383ef5" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_literals</source>
          <target state="translated">__cpp_unicode_literals</target>
        </trans-unit>
        <trans-unit id="fcfb6a809b1f0636cfdcac8dcaf0a56faf741fe9" translate="yes" xml:space="preserve">
          <source>__cpp_user_defined_literals</source>
          <target state="translated">__cpp_user_defined_literals</target>
        </trans-unit>
        <trans-unit id="793fd52dc655ccacc0d8fa1b3bf368e5266577b4" translate="yes" xml:space="preserve">
          <source>__cpp_variable_templates</source>
          <target state="translated">__cpp_variable_templates</target>
        </trans-unit>
        <trans-unit id="b2c1a1181d35bf405e3ead748a7662168e324024" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_templates</source>
          <target state="translated">__cpp_variadic_templates</target>
        </trans-unit>
        <trans-unit id="423eb61df1fcdbb8fb8c6511db90aa6fb0318eaf" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_using</source>
          <target state="translated">__cpp_variadic_using</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="d66612ccc3a3c60bbf9be396b2e583b9ad6f732e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt;式</target>
        </trans-unit>
        <trans-unit id="578b0d09cf884cabb2256541be565e3232f4a2d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;式</target>
        </trans-unit>
        <trans-unit id="0c35fd85853bd90c9dea0e943c9e3e345e596a8c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; that accepts every possible alternative from every variant</source>
          <target state="translated">すべてのバリアントから可能なすべての選択肢を受け入れる&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f547d6f47fe102ed4af5089aaf331e46cb4bd5e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/lambda&quot;&gt;closure&lt;/a&gt; type</source>
          <target state="translated">&lt;a href=&quot;../language/lambda&quot;&gt;閉鎖&lt;/a&gt;タイプ</target>
        </trans-unit>
        <trans-unit id="e0406f8e858cd057dce3f1a1bd186c9b49e3cd51" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo-destructor call&lt;/a&gt; (if &lt;code&gt;It&lt;/code&gt; is a scalar type)</source>
          <target state="translated">&lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;疑似デストラクター呼び出し&lt;/a&gt; （スカラー型の場合）</target>
        </trans-unit>
        <trans-unit id="2f2aa4051bfd7ae365b4f4b11cedb58bbfd66b3e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; whose result type is convertible to &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">結果の型が &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt; 変換可能なUniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="3f35df8d2006030e7d4d979822b8a81b4761ea9f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">初期値を繰り返しインクリメントして生成されたシーケンスで構成される&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1b66b4d9a0ae57bf6f377005ad0ae6842f473ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">別の&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;最初のN個の要素で構成されるビュー</target>
        </trans-unit>
        <trans-unit id="ae981f6c70dcb78f089b85eeb651ce9e721b682b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; を&lt;/a&gt;フラット化することで得られたシーケンスからなるView</target>
        </trans-unit>
        <trans-unit id="e20442d4936a5775a6caf427d491901e50216ebf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">各要素に変換関数を適用するシーケンスの&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="289a5f74d80c8aa744c90c4ee3868ed8609c9f49" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">他の&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;要素の&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a94750304f2970083f4213aac2cf32daebafda1d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">区切り文字を使用して別の&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;を分割することで得られた部分範囲のビュー</target>
        </trans-unit>
        <trans-unit id="3a4653cdeeb9369cc880c44c330b4bacc547ec37" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">述語を満たす&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;の要素で構成される&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c2fbed5ca96d4b2858696b97f8e59367cd9ca66" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">指定された値の単一の要素を含む&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7f3a3db304dcf5be7bc978bb2552c12c8bc06fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;すべての要素を含む&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af11d84750e4dccfceeeab50c1f40114755c03a1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">別の双方向ビューの要素を逆の順序で反復する&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8c8ad0f2aa5b2688c79e49a80f74556ff5bb1c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../types/is_scalar&quot;&gt;scalar type&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../types/is_scalar&quot;&gt;スカラー型&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="c5f1f7ebf1a60286c3263705f1ff2699892ba31a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">順序関係を確立する&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b54276a912036a81a33307973d33e286dfbef1ac" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;bit field&lt;/i&gt;&lt;/a&gt; type can be converted to &lt;code&gt;int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise to &lt;code&gt;unsigned int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise no integral promotions apply;</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;ビットフィールドの&lt;/i&gt;&lt;/a&gt;値の範囲全体を表すことができる場合、 &lt;i&gt;ビットフィールド&lt;/i&gt;タイプは &lt;code&gt;int&lt;/code&gt; に変換できます。 &lt;i&gt;ビットフィールドの&lt;/i&gt;値の範囲全体を表すことができる場合、 &lt;code&gt;unsigned int&lt;/code&gt; に変換できます。それ以外の場合、整数のプロモーションは適用されません。</target>
        </trans-unit>
        <trans-unit id="04be27008e83afb2d331f92d72c2fab2182c7c06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; name, such as &lt;code&gt;operator bool&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;operator bool&lt;/code&gt; などの&lt;a href=&quot;cast_operator&quot;&gt;ユーザー定義の変換関数&lt;/a&gt;名。</target>
        </trans-unit>
        <trans-unit id="842b9bb73f31c7a70a7a8e8933647e7f312f7d30" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. The class name declared becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;クラス宣言&lt;/a&gt; 。 宣言したクラス名がテンプレート名になります。</target>
        </trans-unit>
        <trans-unit id="58329cef5c48b9dd6d75ade29a0076bc7230f05a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;class#Member_specification&quot;&gt;クラスメンバー宣言&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="197dcdb99acb57525f9c2a6fe89a245471fd8142" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt; &lt;code&gt;bool&lt;/code&gt; 型のコンテキスト変換された定数式&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b40006546d705539bc635f3175ea4d35431ac2da" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;constraint expression&lt;/a&gt; which restricts the template parameters accepted by this function template</source>
          <target state="translated">この関数テンプレートが受け入れるテンプレートパラメータを制限する&lt;a href=&quot;constraints&quot;&gt;制約式&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbc4d6e8690db53ad192b32cd88e3433f51c72d3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;requires-expression&lt;/a&gt;, such as &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt; &lt;a href=&quot;constraints&quot;&gt;-expression&lt;/a&gt; } ;</target>
        </trans-unit>
        <trans-unit id="6a7178c89e852f09b520cb3d8d0a0704888c1d34" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints#Concepts&quot;&gt;concept&lt;/a&gt; name, optionally qualified, optionally followed by a template argument list enclosed in &amp;lt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;constraints#Concepts&quot;&gt;概念&lt;/a&gt;名、オプションで修飾、オプションで&amp;lt;&amp;gt;で囲まれたテンプレート引数リストが後に続く</target>
        </trans-unit>
        <trans-unit id="e54b0edc591fc30ea27121f4b241249a88d6dd05" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a named variable, whose type is the type of the element of the sequence represented by range_expression, or a reference to that type. Often uses the &lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt; for automatic type deduction</source>
          <target state="translated">名前付き変数の&lt;a href=&quot;declarations&quot;&gt;宣言&lt;/a&gt; 。型はrange_expressionで表されるシーケンスの要素の型、またはその型への参照です。 多くの場合、自動型推定のために自動&lt;a href=&quot;auto&quot;&gt;指定子&lt;/a&gt;を使用します</target>
        </trans-unit>
        <trans-unit id="feba1f8215a9e5044f736d79557f6d6af77814ce" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a single variable with a brace-or-equals &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;. the initializer is evaluated before each iteration, and if the value of the declared variable converts to &lt;code&gt;false&lt;/code&gt;, the loop is exited.</source>
          <target state="translated">中括弧または等しい&lt;a href=&quot;initialization&quot;&gt;イニシャライザ&lt;/a&gt;を使用した単一変数の&lt;a href=&quot;declarations&quot;&gt;宣言&lt;/a&gt; 。 初期化子は各反復の前に評価され、宣言された変数の値が &lt;code&gt;false&lt;/code&gt; に変換されると、ループが終了します。</target>
        </trans-unit>
        <trans-unit id="9b8e7399060c9f5d9013f6aa031f2daeaf247245" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable. The declared variable name becomes a template name.</source>
          <target state="translated">変数の&lt;a href=&quot;declarations&quot;&gt;宣言&lt;/a&gt; 。 宣言した変数名がテンプレート名になります。</target>
        </trans-unit>
        <trans-unit id="0d19b02053245fd658744be05acb66f6795dfec5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a loop counter variable with initializer, but it may declare arbitrary many variables</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;単純な宣言&lt;/a&gt; 、通常はイニシャライザを使用したループカウンタ変数の宣言ですが、任意の多くの変数を宣言する場合があります</target>
        </trans-unit>
        <trans-unit id="c20d095ecceecc0d92c5b636f980edf3d560c27f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a &lt;a href=&quot;structured_binding&quot;&gt;structured binding declaration&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;単純な宣言&lt;/a&gt; 、通常はイニシャライザを使用した変数の宣言ですが、任意の多数の変数を宣言したり、 &lt;a href=&quot;structured_binding&quot;&gt;構造化されたバインディング宣言に&lt;/a&gt;することもできます</target>
        </trans-unit>
        <trans-unit id="c035c17095b570541b804043bd0d5c99497e6655" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a decomposition declaration</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;単純な宣言&lt;/a&gt; 、通常はイニシャライザを使用した変数の宣言ですが、任意の多数の変数を宣言するか、分解宣言にすることができます</target>
        </trans-unit>
        <trans-unit id="4b734860e87e75b35551beb9fadebdf9940d0be6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or structured bindings</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;単純な宣言&lt;/a&gt; 、通常は初期化子を使用した変数の宣言ですが、任意の多数の変数または構造化バインディングを宣言する場合があります</target>
        </trans-unit>
        <trans-unit id="2201d89e3d55486c60323b0565f06038ff02c6ab" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations#Simple_declaration&quot;&gt;simple declaration&lt;/a&gt; or &lt;a href=&quot;function#Function_definition&quot;&gt;function definition&lt;/a&gt; at namespace scope;</source>
          <target state="translated">名前空間スコープでの&lt;a href=&quot;declarations#Simple_declaration&quot;&gt;単純な宣言&lt;/a&gt;または&lt;a href=&quot;function#Function_definition&quot;&gt;関数定義&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8bcda74ea89e3702ab08c50656a296f15b010fd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Literals&quot;&gt;literal&lt;/a&gt; (except for &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;), such as &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;nullptr&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;42&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;nullptr&lt;/code&gt; などの&lt;a href=&quot;expressions#Literals&quot;&gt;リテラル&lt;/a&gt; （ &lt;a href=&quot;string_literal&quot;&gt;文字列リテラル&lt;/a&gt;を除く）。</target>
        </trans-unit>
        <trans-unit id="8446974ce0d221e5eb27350acb15252dd76acf23" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, e.g. &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt;, or any parenthesized expression</source>
          <target state="translated">&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;一次式&lt;/a&gt; 、例えば &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 、 std :: is_integral &amp;lt;T&amp;gt; :: value 、 &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; 、または括弧で囲まれた式</target>
        </trans-unit>
        <trans-unit id="500e95ea5cc0ecd68e30742d9d61e3323034d850" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt; where the type of at least one parameter uses the placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; or &lt;code&gt;Concept auto&lt;/code&gt;: the template parameter list will have one invented parameter for each placeholder (see Abbreviated function templates below</source>
          <target state="translated">少なくとも1つのパラメーターのタイプがプレースホルダー&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;または &lt;code&gt;Concept auto&lt;/code&gt; を使用する&lt;a href=&quot;function&quot;&gt;関数宣言&lt;/a&gt; ：テンプレートパラメーターリストには、プレースホルダーごとに1つの発明されたパラメーターがあります（以下の省略された関数テンプレートを参照）</target>
        </trans-unit>
        <trans-unit id="cf8f5a052390f7a051f82e9f9d21d32ee1c4a82a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;. The function name declared becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;関数宣言&lt;/a&gt; 。 宣言した関数名がテンプレート名になります。</target>
        </trans-unit>
        <trans-unit id="c2f7755c6029f6a2726cac9e6db3c67772cad590" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;trailing return type&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;末尾の戻り型&lt;/a&gt; 、</target>
        </trans-unit>
        <trans-unit id="7edca23af0f84105b599f5a7b5d639d2bc955bbd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; in a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt; (including friend function declarations), outside of default arguments;</source>
          <target state="translated">デフォルトの引数以外の&lt;a href=&quot;class#Member_specification&quot;&gt;クラスメンバー宣言&lt;/a&gt; （フレンド関数宣言を含む）の&lt;a href=&quot;function#Parameter_list&quot;&gt;パラメーター宣言&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c118f25111af636da74b78a8eacfb1f5f20cd6c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;function&quot;&gt;declarator for a function or function template&lt;/a&gt; whose name is qualified, outside of default arguments;</source>
          <target state="translated">デフォルトの引数の外で、名前が修飾さ&lt;a href=&quot;function&quot;&gt;れている関数または関数テンプレートの宣言子の&lt;/a&gt; &lt;a href=&quot;function#Parameter_list&quot;&gt;パラメーター宣言&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1184f488a359d5c1d1504b481c38dad94714e6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; outside of default arguments;</source>
          <target state="translated">デフォルト引数以外の&lt;a href=&quot;lambda&quot;&gt;ラムダ式の&lt;/a&gt; &lt;a href=&quot;function#Parameter_list&quot;&gt;パラメーター宣言&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="642baf6869f125ceaec67c589e398539c6e7f6ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement</source>
          <target state="translated">&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;ステートメント</target>
        </trans-unit>
        <trans-unit id="c907e534b1c94f336b7e2cf57a58189deb97fe5d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast&quot;&gt;standard conversion&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, or &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; to type &lt;code&gt;T*&lt;/code&gt; or &lt;code&gt;T&amp;amp;&lt;/code&gt;, except when converting from the &lt;a href=&quot;../types/null&quot;&gt;null pointer constant&lt;/a&gt; or from a &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;pointer to void&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../types/null&quot;&gt;nullポインター定数&lt;/a&gt;から、または&lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;ポインターからvoidへの&lt;/a&gt;変換時を除いて、 &lt;a href=&quot;implicit_cast&quot;&gt;標準の変換&lt;/a&gt; 、 &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; 、または&lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;からタイプ &lt;code&gt;T*&lt;/code&gt; または &lt;code&gt;T&amp;amp;&lt;/code&gt; への変換。</target>
        </trans-unit>
        <trans-unit id="ff7412a5c700e7e775fdf95f63af3f717686860b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;function pointer conversion&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;関数ポインタ変換&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd862ebece74d9a647884bc1f7ae05595e84d3dd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversion&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;資格変換&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78294718f1c4d725f8f92854d2e7408626ebcedd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt;, such as &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;[](int x){ return x * x; }&lt;/code&gt; などの&lt;a href=&quot;lambda&quot;&gt;ラムダ式&lt;/a&gt; } ;</target>
        </trans-unit>
        <trans-unit id="84b39eaf4ad707d4a4dec485e938308dab148b12" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;sequence of names and scope resolution operators &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;名前とスコープ解決演算子のシーケンス &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9cefe53156bc46a61aba49ceb2bcf93ec727d8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; that supports attempted lock acquisition</source>
          <target state="translated">ロック取得の試行をサポートする&lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2e74295624d6557dcdd2cc01e3b042f422a51a5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">順序関係を確立する&lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9fc14a958079406695f087786e7323e37febb5f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/clock&quot;&gt;Clock&lt;/a&gt; that does not throw exceptions</source>
          <target state="translated">例外をスローしない&lt;a href=&quot;named_req/clock&quot;&gt;時計&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8f9bb45156d6a61bb73c330f242efbcd3e0fcea" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that for inputs with different values has a low probability of giving the same output</source>
          <target state="translated">異なる値の入力に対して同じ出力を与える可能性が低い&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea59a46b0fa1e2f0e7670029ccdde75669c8d886" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for one argument without modifying it</source>
          <target state="translated">変更せずに1つの引数に対して &lt;code&gt;bool&lt;/code&gt; 値に変換可能な値を返す&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b54d733aca75c1dec32ecb63027a79406e738ca0" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for two arguments without modifying them</source>
          <target state="translated">2つの引数を変更せずに &lt;code&gt;bool&lt;/code&gt; に変換可能な値を返す&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60356dec3126ca424603f3524c2c59c0f4d0e0b3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">データの競合と連続して一貫した同期から保護する&lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78a14075ec6e560d582c534d1ea3a8368ec01c15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that supports timed lock acquisition</source>
          <target state="translated">時限ロック取得をサポートする&lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2420df90cbe1b6e70248694fed79e630531d3b06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">共有所有権セマンティクスをサポートする&lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79e44acb7900ed6728581d5d8a9042f7e17f14c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; that transforms the output of another &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</source>
          <target state="translated">別の&lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngineの&lt;/a&gt;出力を変換するRandomNumberEngine</target>
        </trans-unit>
        <trans-unit id="e17ffa05e7a19b50f16c2ab3c2e4a41b726df14f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">データの競合と順次一貫した同期から保護する&lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="782471ed828c26fe873bde60284584c9dc102f92" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">共有所有権セマンティクスをサポートする&lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0093b4c5c45dc52be9aea4ff3837e330ec42b4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer&quot;&gt;pointer type&lt;/a&gt; (to object or to function);</source>
          <target state="translated">（オブジェクトまたは関数への） &lt;a href=&quot;pointer&quot;&gt;ポインタ型&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae90d6992e65874408f2a555b237871969050472" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt; (to member object or to member function);</source>
          <target state="translated">&lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;メンバー型&lt;/a&gt; （メンバーオブジェクトまたはメンバー関数への）へのポインター 。</target>
        </trans-unit>
        <trans-unit id="089b5759d49b3f3e3e05a4ed136cf4cb2e556331" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, if any name that appears to the left of &lt;code&gt;::&lt;/code&gt; is a</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; の左側に表示される名前が</target>
        </trans-unit>
        <trans-unit id="49c176e338afd9bd3c2793dd3aab24e8628e50cf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, whose qualifier is the</source>
          <target state="translated">&lt;a href=&quot;qualified_lookup&quot;&gt;修飾名&lt;/a&gt; 。修飾子は</target>
        </trans-unit>
        <trans-unit id="906617abbba3f5b3395186a0beb57b664902cb46" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">初期値を繰り返しインクリメントして生成されたシーケンスで構成される&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="584a08c6718b46b2d5bafb7362ec47101daa6021" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">別の&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;最初のN個の要素で構成されるビュー</target>
        </trans-unit>
        <trans-unit id="87aecd3717fd037445fe9653742baf83e68058f8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; of &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; を&lt;/a&gt;フラット化することで得られたシーケンスからなるView</target>
        </trans-unit>
        <trans-unit id="a37c7d31d124ed7013e20399a2b928cc3860b13d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">各要素に変換関数を適用するシーケンスの&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15d88520977b781a636bb3e5929f30daaf0cc794" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">他の&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;要素の&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a744d52e04d21449948de57a486e1984145b091d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">区切り文字を使用して別の&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;を分割することで得られた部分範囲のビュー</target>
        </trans-unit>
        <trans-unit id="ea2a829aa46d29fe3671781db0df1002a16f9f56" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">述語を満たす&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;の要素で構成される&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3270d31c1a13794c926d9de62c84a1561042e839" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">指定された値の単一の要素を含む&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ee5c0dac3dcdfb720bfc6c40ed3163b50c59d15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;すべての要素を含む&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="569c82165b27db13ed5aaf3e2bd4eadc158f3978" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">別の双方向ビューの要素を逆の順序で反復する&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65f096eb23ce29a61ddace2d9bc3762ad47d07e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, such as &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; などの&lt;a href=&quot;string_literal&quot;&gt;文字列リテラル&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="f91dfaeafd98f430989545790f287e35b5f20dc9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;string_literal&quot;&gt;文字列リテラル&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="191a5a89aef337a4a629add8645510717aab9bf2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;default argument of a type template parameter&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;タイプテンプレートパラメータのデフォルト引数&lt;/a&gt; 、または</target>
        </trans-unit>
        <trans-unit id="25def632dd3eeeb127af967f287d3c112d182fe9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; name followed by its argument list, such as &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt; などの&lt;a href=&quot;templates&quot;&gt;テンプレート&lt;/a&gt;名とそれに続く引数リスト</target>
        </trans-unit>
        <trans-unit id="552d64c54cb700af2ff2ba1111b75b5ffde66790" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; where either</source>
          <target state="translated">&lt;a href=&quot;templates#template-id&quot;&gt;テンプレートID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="663fb41f0d766e7269a5347cbd45d461e373d362" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;catch-clause&lt;/a&gt; for an exception of type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&amp;amp;&lt;/code&gt;, or &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;T&amp;amp;&lt;/code&gt; 、または &lt;code&gt;T*&lt;/code&gt; 例外の&lt;a href=&quot;try_catch&quot;&gt;catch節&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="208a7da5d29804a28adcf5b9f0314d6ff0dd0293" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;try_catch&quot;&gt;トライブロック&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e94d0262c8aa644df44502fbb216fd3ee7762db" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;user_literal&quot;&gt;user-defined literal operator&lt;/a&gt; name, such as &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;operator &quot;&quot; _km&lt;/code&gt; などの&lt;a href=&quot;user_literal&quot;&gt;ユーザー定義のリテラル演算子&lt;/a&gt;名。</target>
        </trans-unit>
        <trans-unit id="99934e9b58a1babae9be931f9f2fea4fc18fc0ee" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;すべての要素を含む&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="316d511c8aa53b7526805d4e5457d26523ec3796" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;p&lt;/code&gt; into</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; を挿入する &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbd12644c821ad9dd5361ab305ce3eacebcd4452" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;ptr&lt;/code&gt; into</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; を挿入する &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4b2b6efcf66147f984a4f4c3f1b193be394563b" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated character/wide character string, or an input iterator that points to a null-terminated character/wide character sequence. The character type must be one of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 、ヌル終了文字/ワイド文字列へのポインタ、またはヌル終了文字/ワイド文字シーケンスを指す入力反復子。 文字タイプは、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;char8_t&lt;/code&gt; 、（C ++ 20以降） &lt;code&gt;char16_t&lt;/code&gt; 、 &lt;code&gt;char32_t&lt;/code&gt; 、 &lt;code&gt;wchar_t&lt;/code&gt; のいずれかである必要があります</target>
        </trans-unit>
        <trans-unit id="6b73bd2673de988b6a6630c49706a06b3e5e3bc7" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; representing the hash value.</source>
          <target state="translated">ハッシュ値を表す &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d166a98420f3d07a1a5cfa0f15025354bc8ab03" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object to compare</source>
          <target state="translated">比較する &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; オブジェクト</target>
        </trans-unit>
        <trans-unit id="d5b6a5305c4cd7829271fc0bef5a5469bcdbe9cb" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; type representing the tick period of the clock, in seconds</source>
          <target state="translated">クロックのティック周期を秒で表す &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="28c282d6688b8d9817fe3654bc3aea6ec9948374" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; オブジェクト</target>
        </trans-unit>
        <trans-unit id="5c15ad055910b7bab983130d3d0318587f713ea8" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct containing the constructor options</source>
          <target state="translated">コンストラクタオプションを含む &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 構造体</target>
        </trans-unit>
        <trans-unit id="54930ae4d23e136dcc5b456eec1ed82612b38402" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e940f25cbf8cd2aa56592576ed0c20278acc2bff" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; that will be viewed by this &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; によって表示される &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; またはstd :: weak_ptr</target>
        </trans-unit>
        <trans-unit id="ecdb524f3aba763d3ff8829b8227e31bef82cacf" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;basic_string&lt;/code&gt; used to initialize the buffer</source>
          <target state="translated">バッファの初期化に使用される &lt;code&gt;basic_string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e668eabf5840cd34ea3e0f28321b311fe77422" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">コピーする &lt;code&gt;duration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b0c69e8badd1554c8a8794737ab30e685ebbeb0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then A precedes Y in S c) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; フェンスY、次に &lt;code&gt;memory_order_seq_cst&lt;/code&gt; フェンスXの場合、SでYの前にAが続きますc）</target>
        </trans-unit>
        <trans-unit id="f0b51354e700071d41d8e696cc9589f3f0e23e24" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then X precedes Y in S</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; フェンスY、次にSでXがYに先行する</target>
        </trans-unit>
        <trans-unit id="9d2d1cf5df9aa21b5f43d6c3730e0127bacfd20a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;mutex&lt;/code&gt; from the time that it successfully calls either &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; until it calls &lt;a href=&quot;mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; が&lt;/a&gt;正常に呼び出されてから、それが&lt;a href=&quot;mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; を&lt;/a&gt;呼び出すまでの &lt;code&gt;mutex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="863d62328d5f1e3a0af927034efd3cb49a858007" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;recursive_mutex&lt;/code&gt; for a period of time that starts when it successfully calls either &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. During this period, the thread may make additional calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. The period of ownership ends when the thread makes a matching number of calls to &lt;a href=&quot;recursive_mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; を&lt;/a&gt;正常に呼び出したときに開始する期間のrecursive_mutex 。 この間、スレッドは&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;をさらに呼び出す場合があります。 所有権の期間は、スレッドが同じ数の&lt;a href=&quot;recursive_mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;を解除する呼び出しを行うと終了します。</target>
        </trans-unit>
        <trans-unit id="60b02f0b0cd6b462a069eb540be8a96dc7f7ee1a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;regex_iterator&lt;/code&gt; to compare to</source>
          <target state="translated">比較する &lt;code&gt;regex_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f914aa0db45d26f593fbd3b3acb0736aa4d7f34" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::chrono::local_info&lt;/code&gt; describing the result of the conversion attempt</source>
          <target state="translated">変換試行の結果を説明する &lt;code&gt;std::chrono::local_info&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e92b7ebf5ac6699b0419aafc5019fd69e5b495d1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">状態を &lt;code&gt;*this&lt;/code&gt; に転送する &lt;code&gt;std::future&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45c38558d576f7077eb936fedf2e6993f71552d0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering &lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::partial_ordering &lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="6cb6d8aec9d0d7086c8d7b490355b651816e9f71" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering&lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::partial_ordering&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="2abc4eda553b7e2119f385f0dd8fe079b5901fc1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::shared_future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">状態を &lt;code&gt;*this&lt;/code&gt; に転送する &lt;code&gt;std::shared_future&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea1ec8d4b72649962e567349201f78a7aecef264" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_equality&lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::strong_equality&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="842ba00de4d8ab8dd4f532e899b87cf7099a8622" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_ordering&lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::strong_ordering&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="0253836014928024de0859d29625df2f344d46ad" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_equality&lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::weak_equality&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="f76354e64cc6e23de23245adc7499dc00576366f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering &lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::weak_ordering &lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="05358986f183ddf4595d8859a958cc712f0ab225" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering&lt;/code&gt; value to check</source>
          <target state="translated">チェックする &lt;code&gt;std::weak_ordering&lt;/code&gt; 値</target>
        </trans-unit>
        <trans-unit id="d9610770cf81d239e7a04362e6d0fadfaa64deec" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;sub_match&lt;/code&gt;, &lt;code&gt;basic_string&lt;/code&gt;, pointer to a null-terminated string or a character to compare</source>
          <target state="translated">&lt;code&gt;sub_match&lt;/code&gt; 、 &lt;code&gt;basic_string&lt;/code&gt; 、nullで終わる文字列へのポインタ、または比較する文字</target>
        </trans-unit>
        <trans-unit id="63b26ec0d5fac3c3232b5ffc726c7befaaed3d72" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;time_point&lt;/code&gt; to convert from</source>
          <target state="translated">変換 &lt;code&gt;time_point&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816fe47038210aaf21ca1a99d9e95e7a3f42b5cc" translate="yes" xml:space="preserve">
          <source>a FIFO (also known as pipe) file</source>
          <target state="translated">先入れ先出しファイル</target>
        </trans-unit>
        <trans-unit id="54a9c6eed1e0626765604b3dcde6dced86c39ba2" translate="yes" xml:space="preserve">
          <source>a UTF-8 encoded &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, a pointer to a null-terminated multibyte string, or an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">UTF-8エンコードされた &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; 、nullで終了するマルチバイト文字列へのポインター、またはnullで終了するマルチバイト文字列を指すchar値型の入力イテレーター</target>
        </trans-unit>
        <trans-unit id="d879d1e4b9050e4ddcaaf4d1177df97586b36972" translate="yes" xml:space="preserve">
          <source>a base class subobject, or</source>
          <target state="translated">基底クラスサブオブジェクト</target>
        </trans-unit>
        <trans-unit id="f4918892ac7e83e823a2320d1ac12b97395fb22e" translate="yes" xml:space="preserve">
          <source>a basic stream output function</source>
          <target state="translated">基本ストリーム出力機能</target>
        </trans-unit>
        <trans-unit id="b40f7d626aeddea7dd6317df88183469b83e1e8c" translate="yes" xml:space="preserve">
          <source>a basic_ostream of the same type to swap with</source>
          <target state="translated">とスワップするための同じタイプの basic_ostream</target>
        </trans-unit>
        <trans-unit id="7bf28d638858caf4f712e1c44d5c9646f9188b75" translate="yes" xml:space="preserve">
          <source>a basic_string used as a source used to initialize the regex</source>
          <target state="translated">正規表現の初期化に使われるソースとして使われる basic_string です。</target>
        </trans-unit>
        <trans-unit id="6e9b8e3d4e8d4b69f9fcb8e7bf96871b00610a3b" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the collate facet category</source>
          <target state="translated">collat​​eファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="9f85b8ca8bc6020d25703e2cd3d781082f967763" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the ctype facet category</source>
          <target state="translated">ctypeファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="a9222a22156a69a4cc22429a74768f81e03c8001" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the messages facet category</source>
          <target state="translated">メッセージファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="952a4bcb614afbf75d9c9379f3e6fad36cbc2407" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the monetary facet category</source>
          <target state="translated">通貨ファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="a321349b7f9b76dc26dc645283a6f6c0d3935161" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the numeric facet category</source>
          <target state="translated">数値ファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="b2849fb686ecb1e5989a880cd4bb3d2e85d8c6f8" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the time facet category</source>
          <target state="translated">時間ファセットカテゴリを示す &lt;code&gt;category&lt;/code&gt; タイプのビットマスク値</target>
        </trans-unit>
        <trans-unit id="5378f3a4e98f36da8d1cc7ac9fde2e0f766b8ce0" translate="yes" xml:space="preserve">
          <source>a block special file</source>
          <target state="translated">ブロック特殊ファイル</target>
        </trans-unit>
        <trans-unit id="31510aaf6cad0411c7217a1f61ae7d5e0d11e988" translate="yes" xml:space="preserve">
          <source>a callable object used to determine equality</source>
          <target state="translated">呼び出し可能オブジェクト</target>
        </trans-unit>
        <trans-unit id="16cbd5bc356bd1da4d6938d770e5e05cf23f18f0" translate="yes" xml:space="preserve">
          <source>a callable object used to hash the elements of the string</source>
          <target state="translated">文字列の要素をハッシュ化するために使用される呼び出し可能なオブジェクト。</target>
        </trans-unit>
        <trans-unit id="e104c12ef41e3cdab35da94692fcec6545e90e82" translate="yes" xml:space="preserve">
          <source>a callable to initialize the</source>
          <target state="translated">を初期化するための呼び出し可能な</target>
        </trans-unit>
        <trans-unit id="a43b347761e3e1642f174ca5ec98e18e3c558b21" translate="yes" xml:space="preserve">
          <source>a callable used to initialize &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; を初期化するために使用される呼び出し可能オブジェクト</target>
        </trans-unit>
        <trans-unit id="dc6aead76d9ee30f0a5c5d4684ed174e264c2836" translate="yes" xml:space="preserve">
          <source>a cast expression to lvalue reference type, such as &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt; などのlvalue参照型へのキャスト式。</target>
        </trans-unit>
        <trans-unit id="9115722d18c29f111bc7117bd95ced839664bc51" translate="yes" xml:space="preserve">
          <source>a cast expression to non-reference type, such as &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt;, or &lt;code&gt;(int)42&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt; 、または &lt;code&gt;(int)42&lt;/code&gt; などの非参照型へのキャスト式。</target>
        </trans-unit>
        <trans-unit id="e763fd172d6152f43975ef5910f0aa8ba9d50062" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to function type, such as &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt; など、関数タイプへの右辺値参照へのキャスト式。</target>
        </trans-unit>
        <trans-unit id="be2abbbe2e0dfe771f0371f123450bb9bd07c9bb" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to object type, such as &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt; など、オブジェクトタイプへの右辺値参照へのキャスト式。</target>
        </trans-unit>
        <trans-unit id="53484ba10b1e424e0b9496d35157e69373bf554a" translate="yes" xml:space="preserve">
          <source>a character from the source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character,</source>
          <target state="translated">ソース文字セットから単一引用符（ &lt;code&gt;'&lt;/code&gt; ）、バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）を除いた文字、または改行文字</target>
        </trans-unit>
        <trans-unit id="242427c6b2eafcaf248ee1b9d7c883407593539a" translate="yes" xml:space="preserve">
          <source>a character input stream</source>
          <target state="translated">もじにゅうりょくストリーム</target>
        </trans-unit>
        <trans-unit id="0efbbee14797deed6a7056276c65b5e154453b0a" translate="yes" xml:space="preserve">
          <source>a character output stream</source>
          <target state="translated">もじしゅつりょくストリーム</target>
        </trans-unit>
        <trans-unit id="70a6bbc7a457f3e06d375719052224054e262911" translate="yes" xml:space="preserve">
          <source>a character range to use</source>
          <target state="translated">使用する文字範囲</target>
        </trans-unit>
        <trans-unit id="f1cf02ceb7cec86411208ea818ed5141785e1a23" translate="yes" xml:space="preserve">
          <source>a character range to use, represented as &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated multibyte string, or as an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; 、nullで終了するマルチバイト文字列へのポインター、またはnullで終了するマルチバイト文字列を指すchar値型の入力反復子として表される、使用する文字範囲</target>
        </trans-unit>
        <trans-unit id="1736d8d35a09815a4736564ec0af7bbafefb5389" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string</source>
          <target state="translated">文字列の末尾と比較するための文字列または一文字</target>
        </trans-unit>
        <trans-unit id="eb17e0910a8a3e8109807493a04ca35e79111c97" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string view</source>
          <target state="translated">文字列ビューの最後に比較する文字列または単一の文字。</target>
        </trans-unit>
        <trans-unit id="792cac041ed6c9d94e7546b52a466c7057d1833f" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string</source>
          <target state="translated">文字列の先頭と比較する文字列または一文字</target>
        </trans-unit>
        <trans-unit id="cf6ca109dc96019eacef9105cfc32c6bb8adf9f3" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string view</source>
          <target state="translated">文字列ビューの先頭と比較する文字列または一文字</target>
        </trans-unit>
        <trans-unit id="a36ddc3729dac1840b73df74f47d5b5381de7021" translate="yes" xml:space="preserve">
          <source>a character special file</source>
          <target state="translated">文字専用ファイル</target>
        </trans-unit>
        <trans-unit id="a5250d7e3929a03629a280317471b3d3c146b682" translate="yes" xml:space="preserve">
          <source>a class type (&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) that:</source>
          <target state="translated">次のようなクラスタイプ（ &lt;code&gt;class&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; または &lt;code&gt;union&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f075c0a2aeaae5daa8fce7ca9d846ae302099ae2" translate="yes" xml:space="preserve">
          <source>a class type that contains allocation information</source>
          <target state="translated">割り当て情報を含むクラス型</target>
        </trans-unit>
        <trans-unit id="691a4be3772ad8ef069a61765f06c1d8bc2961d8" translate="yes" xml:space="preserve">
          <source>a class/function/variable template</source>
          <target state="translated">クラス関数変数テンプレート</target>
        </trans-unit>
        <trans-unit id="8af3fd16bec574be1984ea9e734c9bf45f25959e" translate="yes" xml:space="preserve">
          <source>a comma-separated list of parameters like in a function declaration, except that default arguments are not allowed and it cannot end with an ellipsis (other than one signifying a pack expansion). These parameters have no storage, linkage or lifetime, and are only used to assist in specifying requirements. These parameters are in scope until the closing &lt;code&gt;} &lt;/code&gt; of the requirement-seq.</source>
          <target state="translated">関数宣言の場合と同様に、パラメーターのコンマ区切りリスト。ただし、デフォルトの引数は許可されておらず、省略記号（パック展開を示すもの以外）で終了することはできません。 これらのパラメーターにはストレージ、リンケージ、または存続時間はなく、要件の指定を支援するためにのみ使用されます。 これらのパラメーターは、requirement-seqの終了 &lt;code&gt;} &lt;/code&gt; まで有効です。</target>
        </trans-unit>
        <trans-unit id="f11728936e3c6825ff0c40fb8190cad46110b798" translate="yes" xml:space="preserve">
          <source>a comma-separated list of zero or more &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;captures&lt;/a&gt;, optionally beginning with a capture-default.</source>
          <target state="translated">0個以上の&lt;a href=&quot;lambda#Lambda_capture&quot;&gt;キャプチャの&lt;/a&gt;コンマ区切りリスト。オプションで、capture-defaultで始まります。</target>
        </trans-unit>
        <trans-unit id="34fd2e1333d218ba0d65569377b79829eed062f3" translate="yes" xml:space="preserve">
          <source>a compatible &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;</source>
          <target state="translated">互換性のある&lt;a href=&quot;../node_handle&quot;&gt;ノードハンドル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12cf74b9d504b7de17cb8733f3089bb0c746c26c" translate="yes" xml:space="preserve">
          <source>a complex number determined by &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;theta&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; と &lt;code&gt;theta&lt;/code&gt; によって決定される複素数。</target>
        </trans-unit>
        <trans-unit id="832f4c5d564988716ce6fc985261dbaeef18716f" translate="yes" xml:space="preserve">
          <source>a complex number type</source>
          <target state="translated">複素数型</target>
        </trans-unit>
        <trans-unit id="87f7888775f37c05d22b86f373fe58cc238751cb" translate="yes" xml:space="preserve">
          <source>a complex or scalar value of matching type (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;)</source>
          <target state="translated">一致するタイプの複素数またはスカラー値（ &lt;code&gt;float&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、 &lt;code&gt;long double&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b420ae5c7d6bcd895849ec43707c9cd9b5295f2a" translate="yes" xml:space="preserve">
          <source>a compound type constructed from a dependent type</source>
          <target state="translated">従属型から構成される複合型</target>
        </trans-unit>
        <trans-unit id="3e10ceabf9c0862a21d4c968a88d28cf606e6ae4" translate="yes" xml:space="preserve">
          <source>a concept (&lt;a href=&quot;constraints&quot;&gt;constraints and concepts&lt;/a&gt;) (since C++20)</source>
          <target state="translated">概念（ &lt;a href=&quot;constraints&quot;&gt;制約と概念&lt;/a&gt; ）（C ++ 20以降）</target>
        </trans-unit>
        <trans-unit id="705840ece91c45959e8d8b85562f78f90621fb91" translate="yes" xml:space="preserve">
          <source>a constant &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of &lt;code&gt;path&lt;/code&gt;, except that for dereferenceable iterators &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;path::iterator&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, there is no requirement that &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are bound to the same object</source>
          <target state="translated">&lt;code&gt;value_type&lt;/code&gt; が &lt;code&gt;path&lt;/code&gt; の定数&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 。ただし、 &lt;code&gt;path::iterator&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; のpath :: iteratorタイプの逆参照可能なイテレータ &lt;code&gt;a&lt;/code&gt; とbの場合を除き、 &lt;code&gt;*b&lt;/code&gt; と* bが同じオブジェクトにバインドされている必要はありません。</target>
        </trans-unit>
        <trans-unit id="0861d8f96c22cf00ddd38be06d579dc5846fa4bb" translate="yes" xml:space="preserve">
          <source>a constant expression of the same type as the type of condition after conversions and &lt;a href=&quot;implicit_cast&quot;&gt;integral promotions&lt;/a&gt;</source>
          <target state="translated">変換および&lt;a href=&quot;implicit_cast&quot;&gt;整数昇格&lt;/a&gt;後の条件のタイプと同じタイプの定数式</target>
        </trans-unit>
        <trans-unit id="fa1e013cc131d9284341359f6bccff749d73ab2d" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt; 型の定数</target>
        </trans-unit>
        <trans-unit id="2092e802512bd4b6672ffecf3059eab3c2dc675a" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;size_t&lt;/code&gt; signifying that the &lt;code&gt;span&lt;/code&gt; has dynamic extent</source>
          <target state="translated">&lt;code&gt;span&lt;/code&gt; に動的範囲があることを示す &lt;code&gt;size_t&lt;/code&gt; 型の定数</target>
        </trans-unit>
        <trans-unit id="43883e62b71e2ce20764378f921e1463f7c5e2fb" translate="yes" xml:space="preserve">
          <source>a constructor for a base or member that the implicit definition of the constructor would call is</source>
          <target state="translated">コンストラクタの暗黙の定義で呼び出されるベースまたはメンバのコンストラクタは</target>
        </trans-unit>
        <trans-unit id="1e0e47bbea0419696dda53a2c740d527152ed34a" translate="yes" xml:space="preserve">
          <source>a container (such as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) of non-recursive &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;s&lt;/a&gt; that forms the recursion stack</source>
          <target state="translated">再帰スタックを形成する非再帰的な&lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; の&lt;/a&gt;コンテナ（ &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6da0ef251a56bef0d297d95fb6f03dcddc9d4d68" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;begin&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; メソッドを持つコンテナ</target>
        </trans-unit>
        <trans-unit id="3ab7db750fffecfbea2fd7f3a1826d7a47ff6dfd" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;data()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;data()&lt;/code&gt; メソッドを持つコンテナ</target>
        </trans-unit>
        <trans-unit id="d42aaf6f8dfa2ceb1302ac9a7aae99e65ad76dd7" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rbegin&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;rbegin&lt;/code&gt; メソッドを持つコンテナー</target>
        </trans-unit>
        <trans-unit id="8a255f3578bec602079f216affbbb6421964db15" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rend&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;rend&lt;/code&gt; メソッドを持つコンテナ</target>
        </trans-unit>
        <trans-unit id="d76e199c3451be874b54d52909a700c365bc58d9" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;size&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; メソッドを持つコンテナー</target>
        </trans-unit>
        <trans-unit id="5936962ad861e75e91156317d373da013aa2a18b" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;empty&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; メソッドを持つコンテナ</target>
        </trans-unit>
        <trans-unit id="8eecf2dba113b51a014b2681b5af4fc06cf180a3" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;end&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; メソッドを持つコンテナ</target>
        </trans-unit>
        <trans-unit id="32ae34e0c2ff3b97cd9427b79233b671fd97c530" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator</source>
          <target state="translated">ベース()イテレータのコピー</target>
        </trans-unit>
        <trans-unit id="7332ce803122087bfbb9401270891b4faedd3f1f" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator, the name is for exposition only</source>
          <target state="translated">base()イテレータのコピー。</target>
        </trans-unit>
        <trans-unit id="311bf83f22bc4bb383f24fd37ba3cb18d0aeb36d" translate="yes" xml:space="preserve">
          <source>a copy of the value returned by &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; によって返された値のコピー</target>
        </trans-unit>
        <trans-unit id="6f958f7a6a78be01a6805b5c1af1d682eeb8a134" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of a dependent type</source>
          <target state="translated">従属型の cv-qualified 版</target>
        </trans-unit>
        <trans-unit id="fc96c9e2930591a8d0a0e1f5aef8a747ab1ae764" translate="yes" xml:space="preserve">
          <source>a declaration</source>
          <target state="translated">宣言</target>
        </trans-unit>
        <trans-unit id="de382bf6f6303f1d66d3ee9fa105e4cb909ae0fb" translate="yes" xml:space="preserve">
          <source>a default member initializer (for default constructor only) is</source>
          <target state="translated">デフォルトのメンバのイニシャライザ(デフォルトのコンストラクタのみ)は</target>
        </trans-unit>
        <trans-unit id="c35c5385471cf8ca008de727f3a8bb03a39d8fc4" translate="yes" xml:space="preserve">
          <source>a default-constructed &lt;code&gt;path()&lt;/code&gt; followed by</source>
          <target state="translated">デフォルトで構築された &lt;code&gt;path()&lt;/code&gt; の後に</target>
        </trans-unit>
        <trans-unit id="3720dd36cc49fe927d2449b3b2fe294001d00344" translate="yes" xml:space="preserve">
          <source>a definition of a variable for which &lt;a href=&quot;default_initialization&quot;&gt;no initialization is performed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;default_initialization&quot;&gt;初期化が実行されない&lt;/a&gt;変数の定義。</target>
        </trans-unit>
        <trans-unit id="8574bc2dee7611873d6999d1419b5b65057eda6e" translate="yes" xml:space="preserve">
          <source>a definition of a variable of non-literal type</source>
          <target state="translated">非リテラル型変数の定義</target>
        </trans-unit>
        <trans-unit id="bf8e57bf98d46c7f4282d67c960acf8da327fef4" translate="yes" xml:space="preserve">
          <source>a definition of a variable of static or thread &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;</source>
          <target state="translated">静的またはスレッド&lt;a href=&quot;storage_duration&quot;&gt;ストレージ期間の&lt;/a&gt;変数の定義</target>
        </trans-unit>
        <trans-unit id="39cd8bcb29b6ae12a4df802c4fe0c9397f3f8893" translate="yes" xml:space="preserve">
          <source>a deleter to copy from</source>
          <target state="translated">からコピーする削除子</target>
        </trans-unit>
        <trans-unit id="94a71c43d37808b7131ebf1bfafb843815bd7985" translate="yes" xml:space="preserve">
          <source>a deleter to use to destroy the object</source>
          <target state="translated">オブジェクトを破壊するために使用する削除子</target>
        </trans-unit>
        <trans-unit id="24ff51d02f7ddaf5794e2da95d7baf8bf41c271f" translate="yes" xml:space="preserve">
          <source>a deterministic &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, defined by the seed</source>
          <target state="translated">シードによって定義された確定的な&lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="534eb8b60097429551e576498f52d179c2f4e5dd" translate="yes" xml:space="preserve">
          <source>a directory</source>
          <target state="translated">ディレクトリ</target>
        </trans-unit>
        <trans-unit id="8bddca722adcb261998df0de3bb3c97a6c748832" translate="yes" xml:space="preserve">
          <source>a directory entry</source>
          <target state="translated">ディレクトリ項目</target>
        </trans-unit>
        <trans-unit id="927fd0565fdd62ffef9d7df984e6c6f5ed72f85d" translate="yes" xml:space="preserve">
          <source>a directory_iterator</source>
          <target state="translated">ディレクトリイテレータ</target>
        </trans-unit>
        <trans-unit id="867723c6d0ee2b6557184f124ed60f12f45d1dd0" translate="yes" xml:space="preserve">
          <source>a discarded-value expression.</source>
          <target state="translated">廃棄された値の式。</target>
        </trans-unit>
        <trans-unit id="336c91ab3bd545d36262022c4abcf1ea256c10d5" translate="yes" xml:space="preserve">
          <source>a disjunctive clause subsumes a conjunctive clause if and only if there is an atomic constraint &lt;code&gt;U&lt;/code&gt; in the disjunctive clause and an atomic constraint &lt;code&gt;V&lt;/code&gt; in the conjunctive clause such that &lt;code&gt;U&lt;/code&gt; subsumes &lt;code&gt;V&lt;/code&gt;;</source>
          <target state="translated">選言節は、論理積節にアトミック制約 &lt;code&gt;U&lt;/code&gt; があり、論理積節にアトミック制約 &lt;code&gt;V&lt;/code&gt; があり、 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;V&lt;/code&gt; を包摂する場合にのみ、論理積節を包摂します。</target>
        </trans-unit>
        <trans-unit id="6b5747ff852acba8c48d1a6cb5da34fc9e296730" translate="yes" xml:space="preserve">
          <source>a duration to copy from</source>
          <target state="translated">コピーする期間</target>
        </trans-unit>
        <trans-unit id="c350a90cf1671cc555d57758875af84ffdbe33a9" translate="yes" xml:space="preserve">
          <source>a family of classes (&lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;nested classes&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;member_template&quot;&gt;ネストされたクラス&lt;/a&gt;である&lt;a href=&quot;class_template&quot;&gt;クラスの&lt;/a&gt;ファミリー（ クラステンプレート ）</target>
        </trans-unit>
        <trans-unit id="7ac66b538aae3ff5b2eebbb9164d6b15968c2655" translate="yes" xml:space="preserve">
          <source>a family of functions (&lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;member functions&lt;/a&gt;</source>
          <target state="translated">関数のファミリー（ &lt;a href=&quot;function_template&quot;&gt;関数テンプレート&lt;/a&gt; ）。 &lt;a href=&quot;member_template&quot;&gt;メンバー関数の&lt;/a&gt;場合があります。</target>
        </trans-unit>
        <trans-unit id="b225fab8be27928cedcf387d1202d942115cf6f7" translate="yes" xml:space="preserve">
          <source>a family of variables (&lt;a href=&quot;variable_template&quot;&gt;variable template&lt;/a&gt;) (since C++14)</source>
          <target state="translated">変数のファミリー（ &lt;a href=&quot;variable_template&quot;&gt;変数テンプレート&lt;/a&gt; ）（C ++ 14以降）</target>
        </trans-unit>
        <trans-unit id="fa031b408b61feecac632070eb11680ef7afef0a" translate="yes" xml:space="preserve">
          <source>a function call expression that calls a function (or a constructor) that is not declared &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;constexpr&quot;&gt;constexprとして&lt;/a&gt;宣言されていない関数（またはコンストラクター）を呼び出す関数呼び出し式</target>
        </trans-unit>
        <trans-unit id="1cc0ab25d190ee32f3fbd65c276911c0bf316acb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is lvalue reference, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt;, &lt;code&gt;str1 = str2&lt;/code&gt;, or &lt;code&gt;++it&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt; 、 &lt;code&gt;str1 = str2&lt;/code&gt; 、または &lt;code&gt;++it&lt;/code&gt; のような、戻り値の型が左辺値参照である関数呼び出しまたはオーバーロードされた演算子式。</target>
        </trans-unit>
        <trans-unit id="fe3271b2a2bdf8654d96145285508cb27eb7fa3c" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is non-reference, such as &lt;code&gt;str.substr(1, 2)&lt;/code&gt;, &lt;code&gt;str1 + str2&lt;/code&gt;, or &lt;code&gt;it++&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;str.substr(1, 2)&lt;/code&gt; 、 &lt;code&gt;str1 + str2&lt;/code&gt; 、 &lt;code&gt;it++&lt;/code&gt; など、戻り値の型が非参照である関数呼び出しまたはオーバーロードされた演算子式。</target>
        </trans-unit>
        <trans-unit id="0aac9ce8ff230dee25d75b3c0b2e89e1a93af6fb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to function;</source>
          <target state="translated">関数呼び出しまたはオーバーロードされた演算子式で、その戻り値の型は関数への rvalue 参照です。</target>
        </trans-unit>
        <trans-unit id="06b3616b9a0b9e911ad389bfd163627a7c1c34bc" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as &lt;code&gt;std::move(x)&lt;/code&gt;;</source>
          <target state="translated">関数呼び出しまたはオーバーロードされた演算子式。戻り型は &lt;code&gt;std::move(x)&lt;/code&gt; などのオブジェクトへの右辺値参照です。</target>
        </trans-unit>
        <trans-unit id="89282f06fce2e206dcc5d91b9a98ea7c21e34204" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function which is declared, but not defined</source>
          <target state="translated">宣言されているが定義されていない &lt;code&gt;constexpr&lt;/code&gt; 関数への関数呼び出し</target>
        </trans-unit>
        <trans-unit id="10915ad1ef913f2efda469b6ef4db5fda7260bf8" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function/constructor template instantiation where the instantiation fails to satisfy &lt;a href=&quot;constexpr&quot;&gt;constexpr function/constructor&lt;/a&gt; requirements.</source>
          <target state="translated">インスタンス化が&lt;a href=&quot;constexpr&quot;&gt;constexpr関数/コンストラクターの&lt;/a&gt;要件を満たせない、 &lt;code&gt;constexpr&lt;/code&gt; 関数/コンストラクターテンプレートのインスタンス化への関数呼び出し。</target>
        </trans-unit>
        <trans-unit id="1a1e14620347e6a891947bb343ed08d832b480d5" translate="yes" xml:space="preserve">
          <source>a function object type. The behavior is undefined if its return type is not one of the five comparison category types (strong_equality, weak_equality, strong_ordering, weak_ordering, or partial_ordering)</source>
          <target state="translated">関数のオブジェクト型を指定します。その戻り値の型が5つの比較カテゴリ型(strong_equality、weak_equality、strong_ordering、weak_ordering、またはpartial_ordering)のいずれかでない場合、この動作は定義されません。</target>
        </trans-unit>
        <trans-unit id="8d0e3c882e6f573300e1c9692eab26458b8cdc46" translate="yes" xml:space="preserve">
          <source>a function type whose exception specification is value-dependent</source>
          <target state="translated">例外指定が値に依存する関数型</target>
        </trans-unit>
        <trans-unit id="e47b118e9260ac46b886dbed4343d2d945bd3192" translate="yes" xml:space="preserve">
          <source>a glvalue</source>
          <target state="translated">膠着値</target>
        </trans-unit>
        <trans-unit id="7ba358203ed2199073a8967bad6e8c7ab1203303" translate="yes" xml:space="preserve">
          <source>a glvalue (&amp;ldquo;generalized&amp;rdquo; lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function;</source>
          <target state="translated">glvalue（「一般化された」lvalue）は、その評価がオブジェクト、ビットフィールド、または関数のアイデンティティを決定する式です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
