<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="1cefc4c9c8c79e1f5ffc310e3b76ce47f7f95b53" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, and its iterators must satisfy the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">要素を格納するために使用する基になるコンテナーのタイプ。コンテナーは&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;の要件を満たしている必要があり、そのイテレーターは&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;の要件を満たしている必要があります。さらに、通常のセマンティクスで次の機能を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="42baf44de229b353e2dc10d945c14ad4f7f1e2dd" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">要素を格納するために使用する基になるコンテナーのタイプ。コンテナは&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;の要件を満たしている必要があります。さらに、通常のセマンティクスで次の機能を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b1400789f4da2eef8d9f804a8241c3f62471b09" translate="yes" xml:space="preserve">
          <source>The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type:</source>
          <target state="translated">エイリアステンプレートを特殊化する際に生成される型は、それ自身の型を直接または間接的に利用することはできません。</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">すべての浮動小数点型ステータスフラグをまとめて表す型.</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">浮動小数点環境全体を表す型</target>
        </trans-unit>
        <trans-unit id="e0d3b983420a08441dc26163e85fa14573af6da4" translate="yes" xml:space="preserve">
          <source>The type trait template &lt;code&gt;regex_traits&lt;/code&gt; supplies &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with the set of types and functions necessary to operate on the type &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">タイプ特性テンプレート &lt;code&gt;regex_traits&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; に、タイプ &lt;code&gt;CharT&lt;/code&gt; の操作に必要なタイプと関数のセットを提供します。</target>
        </trans-unit>
        <trans-unit id="a7ff3701335c6b61f893828424d0d4397e6f94e7" translate="yes" xml:space="preserve">
          <source>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, &lt;code&gt;E2&lt;/code&gt;. If &lt;code&gt;E2&lt;/code&gt; is a temporary expression(since C++17), the result of the expression is that temporary expression(since C++17). If &lt;code&gt;E2&lt;/code&gt; is a bit-field, the result is a bit-field.</source>
          <target state="translated">コンマ式の結果のタイプ、値、および値カテゴリーは、第2オペランド &lt;code&gt;E2&lt;/code&gt; のタイプ、値、および値カテゴリーとまったく同じです。場合 &lt;code&gt;E2&lt;/code&gt; は（C ++ 17以降）の一時的な表現である、式の結果は（C ++ 17以降）は、一時的な表現です。場合 &lt;code&gt;E2&lt;/code&gt; がビットフィールドで、結果はビットフィールドです。</target>
        </trans-unit>
        <trans-unit id="201b401441e563392e93db134426f0b5823a14fe" translate="yes" xml:space="preserve">
          <source>The type-based overloads (5-12) fail to compile if the types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are the same.</source>
          <target state="translated">タイプベースのオーバーロード（5-12）は、タイプ &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; が同じである場合、コンパイルに失敗します。</target>
        </trans-unit>
        <trans-unit id="a8ad5442d02de3fb2204cec5285533422e5d8a60" translate="yes" xml:space="preserve">
          <source>The typedef-names are aliases for existing types, and are not declarations of new types. Typedef cannot be used to change the meaning of an existing type name (including a typedef-name). Once declared, a typedef-name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.</source>
          <target state="translated">typedef名は既存の型のエイリアスであり、新しい型の宣言ではありません。typedefは、既存の型名(typedef-nameを含む)の意味を変更するためには使用できません。一度宣言された型定義名は、再度同じ型を参照するために再宣言することができます。型定義名は、それらが見えるスコープ内でのみ有効です:異なる関数やクラスの宣言では、同じ名前の型を異なる意味で定義することができます。</target>
        </trans-unit>
        <trans-unit id="208a0dcd155f30aca58e4747af4e8c084fcc2a94" translate="yes" xml:space="preserve">
          <source>The typeid expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; which refers to an object with &lt;a href=&quot;static&quot;&gt;static storage duration&lt;/a&gt;, of the polymorphic type &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; or of some type derived from it.</source>
          <target state="translated">typeid式は、多相型 &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../types/type_info&quot;&gt;std :: type_info&lt;/a&gt;またはそれから派生したいくつかの型の&lt;a href=&quot;static&quot;&gt;静的ストレージ期間&lt;/a&gt;を持つオブジェクトを参照する&lt;a href=&quot;value_category&quot;&gt;lvalue式&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7e208b7b23417d25a7cf6cca148a35ee8446742b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;TC::rep&lt;/code&gt;, &lt;code&gt;TC::duration&lt;/code&gt;, and &lt;code&gt;TC::time_point&lt;/code&gt; satisfy the requirements of &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;, &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;TC::rep&lt;/code&gt; 、 &lt;code&gt;TC::duration&lt;/code&gt; 、および &lt;code&gt;TC::time_point&lt;/code&gt; は、&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;、&lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;、&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;、&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;、&lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;、&lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;、および&lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;の要件を満たします。</target>
        </trans-unit>
        <trans-unit id="61760bebb6411fc7a1b89f4a6a4d2b47b837a78f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;BidirIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;BidirIt&lt;/code&gt; のオブジェクトを逆参照して、暗黙的にそれらの両方に変換できるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="10efac4cd9ec3d4ae0fd700440a7ab91e4529fc8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、 &lt;code&gt;ForwardIt&lt;/code&gt; タイプのオブジェクトが逆参照され、暗黙的にそれらの両方に変換されるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="cfb5cffb02876fdfc335e83f9d620b313612c1b0" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt&lt;/code&gt; のオブジェクトが逆参照され、暗黙的にそれらの両方に変換されるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="3c179ed315abab6c17ee556701b26c5d282772f2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;RandomIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;RandomIt&lt;/code&gt; のオブジェクトが逆参照され、暗黙的にそれらの両方に変換されるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="193be796c5e76cc692dcacf4d03a9c74c36dcc11" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;, and an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; タイプのオブジェクトようなものでなければならない &lt;code&gt;T&lt;/code&gt; は暗黙の両方に変換することができる &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; 、およびタイプのオブジェクト &lt;code&gt;ForwardIt&lt;/code&gt; 逆参照することができ、次いで、暗黙の両方に変換 &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4447fe84d3b9ebfd730e495965e02d0c7f2a157" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; タイプのオブジェクトようなものでなければならない &lt;code&gt;T&lt;/code&gt; は暗黙それらの両方に変換することができます。</target>
        </trans-unit>
        <trans-unit id="55aca5b917e7d46505eef0c5864d5092e23045de" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; が逆参照され、暗黙的にそれらの両方に変換されるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c2c308d3a55373567a39aa9cf81fb0182d8c2878" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to both of them. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; オブジェクトを暗黙的にそれらの両方に変換できるようなタイプである必要があります。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;OutputIt&lt;/code&gt; のオブジェクトを逆参照してタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="86218894e5a217ad2ba71c5d5b88c13c7c91af26" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; オブジェクトを逆参照して、暗黙的にそれらの両方に変換できるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="255e7b7cb8a9a07dcebb8ff409c528b78435bb0c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;ForwardIt1&lt;/code&gt; と &lt;code&gt;ForwardIt2&lt;/code&gt; のオブジェクトを逆参照して、それぞれ暗黙的に &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; に変換できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="8bf40db03397e57c92c014d425524b6be371768c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt1&lt;/code&gt; および &lt;code&gt;InputIt2&lt;/code&gt; のオブジェクトを逆参照して、それぞれ暗黙的に &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; に変換できるようなタイプである必要があります。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;OutputIt&lt;/code&gt; のオブジェクトを逆参照してタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="ea66afd749f321b8a7fbd2dfec0b25993b20d429" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;Type3&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt1&lt;/code&gt; および &lt;code&gt;InputIt2&lt;/code&gt; のオブジェクトを逆参照して、それぞれ暗黙的に &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; に変換できるようなタイプである必要があります。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;Type3&lt;/code&gt; のオブジェクトにタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="697ca99a8e5d22b550dc1162bfdf3113cb87ca5b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt1&lt;/code&gt; および &lt;code&gt;InputIt2&lt;/code&gt; のオブジェクトを逆参照して、それぞれ暗黙的に &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; に変換できるようなタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="c5097f11a8110609e26afb57ed62da129a5503cf" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;InputIt1&lt;/code&gt; と &lt;code&gt;InputIt2&lt;/code&gt; のオブジェクトを逆参照して、暗黙的に &lt;code&gt;Type1&lt;/code&gt; と &lt;code&gt;Type2&lt;/code&gt; の両方に変換できるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8c30caab1908aa629ad3fea15c152763576c8875" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;Type3&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">タイプ &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; および &lt;code&gt;Type3&lt;/code&gt; のオブジェクトをそれぞれ暗黙的に &lt;code&gt;Type1&lt;/code&gt; および &lt;code&gt;Type2&lt;/code&gt; に変換できるようなタイプでなければなりません。タイプ &lt;code&gt;Ret&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトにタイプ &lt;code&gt;Ret&lt;/code&gt; の値を割り当てることができるようなタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="50e24e2bc41cc279e1a3c9515fef0b78775237a9" translate="yes" xml:space="preserve">
          <source>The types in the parameter pack &lt;code&gt;T&lt;/code&gt; shall each be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound. Otherwise, the behavior is undefined.</source>
          <target state="translated">パラメータパック &lt;code&gt;T&lt;/code&gt; の型は、それぞれ完全な型、（場合によってはcv修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列になります。それ以外の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="fa81b9c4cb4ce5f942c1234f0bfa8aee24861f94" translate="yes" xml:space="preserve">
          <source>The types of the placeholder objects are &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, their default copy/move constructors do not throw exceptions, and for any placeholder &lt;code&gt;_N&lt;/code&gt;, the type &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; is defined and is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">プレースホルダーオブジェクトのタイプは&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;と&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructibleであり&lt;/a&gt;、それらのデフォルトのコピー/移動コンストラクターは例外をスローしません。プレースホルダー &lt;code&gt;_N&lt;/code&gt; の場合、タイプ &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; が定義され、 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt; から派生します &amp;lt;int、N&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="75478ba3404fb0cfdef1c92955897a42cd9e34cf" translate="yes" xml:space="preserve">
          <source>The types used to determine the order depend on the context:</source>
          <target state="translated">順序を決定するために使用されるタイプは、コンテキストに依存します。</target>
        </trans-unit>
        <trans-unit id="81e4b2422bd4fd5cd5d02082af7aa37f47bd2430" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;istrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; の一般的な実装は、1つの非派生データメンバー、つまり &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 型のオブジェクトのみを保持します。</target>
        </trans-unit>
        <trans-unit id="48a376de82dbe48c2684a6707ba9148135410249" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;ostrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; の一般的な実装は、1つの非派生データメンバー、つまり &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 型のオブジェクトのみを保持します。</target>
        </trans-unit>
        <trans-unit id="4926fe384c3bbd6e8ecfe4635962d969889b9270" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;strstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strstream&lt;/code&gt; の一般的な実装は、1つの非派生データメンバー、 &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 型のオブジェクトのみを保持します。</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">単項演算子の式は、次のような形をしています。</target>
        </trans-unit>
        <trans-unit id="b22b858c0fd42effe64ef379a02aba7e1e499dac" translate="yes" xml:space="preserve">
          <source>The unary operator &lt;code&gt;co_await&lt;/code&gt; suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define &lt;code&gt;operator co_await&lt;/code&gt;, or be convertible to such type by means of the current coroutine's &lt;code&gt;Promise::await_transform&lt;/code&gt;.</source>
          <target state="translated">単項演算子 &lt;code&gt;co_await&lt;/code&gt; はコルーチンを中断し、制御を呼び出し元に戻します。そのオペランドは式であり、その型は &lt;code&gt;operator co_await&lt;/code&gt; 定義するか、現在のコルーチンの &lt;code&gt;Promise::await_transform&lt;/code&gt; を使用してそのような型に変換可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="36a5614de76d4b58b628c43d48b3afb8e58937c2" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単項述語型は、述語のパラメーター型に変換可能 &lt;code&gt;argument_type&lt;/code&gt; メンバー型argument_typeを定義する必要があります。 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; への別の呼び出しから取得された単項関数オブジェクト非推奨の &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; から派生した関数オブジェクトと同様に、この型が定義されています。</target>
        </trans-unit>
        <trans-unit id="7c177ac717f26cdcf71092d833a69d98891213b9" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not1&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単項述語型は、述語のパラメーター型に変換可能 &lt;code&gt;argument_type&lt;/code&gt; メンバー型argument_typeを定義する必要があります。 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;std::not1&lt;/code&gt; への別の呼び出しから取得された単項関数オブジェクト非推奨の &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; から派生した関数オブジェクトと同様に、この型が定義されています。</target>
        </trans-unit>
        <trans-unit id="9a8868abcc7899aa017c841a57e1f892c57cdec6" translate="yes" xml:space="preserve">
          <source>The underlying array is a &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporary&lt;/a&gt; array of type &lt;code&gt;const T[N]&lt;/code&gt;, in which each element is &lt;a href=&quot;../language/copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;temporary object&lt;/a&gt;, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;binding a reference to a temporary&lt;/a&gt; (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</source>
          <target state="translated">基本となる配列は、型 &lt;code&gt;const T[N]&lt;/code&gt; &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;一時&lt;/a&gt;配列です。各要素は、元の初期化リストの対応する要素から&lt;a href=&quot;../language/copy_initialization&quot;&gt;コピー初期化されます&lt;/a&gt;（ナロー変換は無効です）。配列からのinitializer_listオブジェクトの初期化は&lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;、一時への参照のバインドと&lt;/a&gt;まったく同じように配列の寿命を延長することを除いて、基になる配列の寿命は他の&lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;一時オブジェクト&lt;/a&gt;と同じです（非例外の初期化などの同じ例外を除いて） -staticクラスメンバー）。基になる配列は、読み取り専用メモリに割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="4eb3a7f051a86b23a775a499c1446a22117e43f7" translate="yes" xml:space="preserve">
          <source>The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for &lt;code&gt;std::initializer_list&lt;/code&gt; is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</source>
          <target state="translated">元の初期化子リストオブジェクトの有効期間が終了した後、基になる配列が存在することは保証されません。 &lt;code&gt;std::initializer_list&lt;/code&gt; のストレージは指定されていません（つまり、状況に応じて、自動、一時、または静的な読み取り専用メモリになる場合があります）。</target>
        </trans-unit>
        <trans-unit id="7eadf4d50d87bb977c930c01738a9f8d29a30fb0" translate="yes" xml:space="preserve">
          <source>The underlying engine.</source>
          <target state="translated">根底にあるエンジン。</target>
        </trans-unit>
        <trans-unit id="97e77189c09808726f0123e32d74be4afcdbd112" translate="yes" xml:space="preserve">
          <source>The underlying iterator is assigned the value of the underlying iterator of &lt;code&gt;other&lt;/code&gt;, i.e. &lt;code&gt;other.base()&lt;/code&gt;.</source>
          <target state="translated">基礎となるイテレーターには、 &lt;code&gt;other&lt;/code&gt; の基礎となるイテレーターの値、つまり &lt;code&gt;other.base()&lt;/code&gt; が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="b646602f4defaa19568e9e4e03c04b49576b8ef7" translate="yes" xml:space="preserve">
          <source>The underlying iterator.</source>
          <target state="translated">基礎となるイテレータ。</target>
        </trans-unit>
        <trans-unit id="79cf0218a59dc2d4dbf82fe2261c98e6c65758c3" translate="yes" xml:space="preserve">
          <source>The unevaluated operands are considered to be</source>
          <target state="translated">評価されていないオペランドは</target>
        </trans-unit>
        <trans-unit id="979a12b00a42a8fc276019493ceedcb85eb1918e" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt; if they fails to extract any characters.</source>
          <target state="translated">文字の抽出に失敗した場合、フォーマットされていない入力関数&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abe9991ee5e0486321d659e85ed0325fe1bbb797" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/read&quot;&gt;&lt;code&gt;basic_istream::read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/peek&quot;&gt;&lt;code&gt;basic_istream::peek&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../basic_istream/getline&quot;&gt;&lt;code&gt;basic_istream::getline&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream.</source>
          <target state="translated">ストリームの最後に到達したときの、フォーマットされていない入力関数&lt;a href=&quot;../basic_istream/read&quot;&gt; &lt;code&gt;basic_istream::read&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../basic_istream/peek&quot;&gt; &lt;code&gt;basic_istream::peek&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../basic_istream/getline&quot;&gt; &lt;code&gt;basic_istream::getline&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e384fd665d52aa51e3748fff4ef48a28e7937c70" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union.</source>
          <target state="translated">ユニオンは、その最大のデータ・メンバーを保持するために必要なだけの大きさになります。他のデータ・メンバは、その最大のメンバの一部として同じバイト数で割り当てられます。この割り当ての詳細は実装で定義されており、最近書き込まれたものではないユニオンのメンバから読み出すことは未定義の動作です。多くのコンパイラは、非標準の言語拡張として、組合の非アクティブなメンバを読み込む機能を実装しています。</target>
        </trans-unit>
        <trans-unit id="e952952a6e837db3083d43ddef77a18d33df5f91" translate="yes" xml:space="preserve">
          <source>The unordered associative containers &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; use specializations of the template &lt;code&gt;std::hash&lt;/code&gt; as the default hash function.</source>
          <target state="translated">順序付けされていない連想コンテナ &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; は、テンプレート &lt;code&gt;std::hash&lt;/code&gt; 特殊化をデフォルトのハッシュ関数として使用します。</target>
        </trans-unit>
        <trans-unit id="fb9ee6c51de186554c2e06f60fe8377ba45da283" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is sorted.</source>
          <target state="translated">要素が昇順でソートされる &lt;code&gt;first&lt;/code&gt; から始まる最大範囲の上限。つまり、範囲 &lt;code&gt;[first, it)&lt;/code&gt; がソートされる最後の反復子 &lt;code&gt;it&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="153cc2e9c85ca94fbb56ca3af1786c3042753255" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">上位の最大範囲の最初のバインド &lt;code&gt;first&lt;/code&gt; であります</target>
        </trans-unit>
        <trans-unit id="0a7c6b2e95b8914f758d75e392b6d55f793089e4" translate="yes" xml:space="preserve">
          <source>The use of the class key &lt;code&gt;union&lt;/code&gt; results in a &lt;a href=&quot;union&quot;&gt;union definition&lt;/a&gt;, which defines a class that holds only one of its data members at a time.</source>
          <target state="translated">クラスキーの使用 &lt;code&gt;union&lt;/code&gt; で結果&lt;a href=&quot;union&quot;&gt;組合の定義&lt;/a&gt;時に一つだけのデータメンバのを保持するクラスを定義します。</target>
        </trans-unit>
        <trans-unit id="7c930b3ae6f3ca4c4f3a29eb336a3a8321980de8" translate="yes" xml:space="preserve">
          <source>The user-defined callback function is not allowed to throw exceptions.</source>
          <target state="translated">ユーザー定義のコールバック関数は例外を投げることができません。</target>
        </trans-unit>
        <trans-unit id="7440e695d7d2b47e772a3f0ba0922c8f1015cfd1" translate="yes" xml:space="preserve">
          <source>The user-defined conversion functions are considered to be members of the</source>
          <target state="translated">ユーザ定義の変換関数は,ユーザ定義の変換関数が</target>
        </trans-unit>
        <trans-unit id="a2449ea9418355b1634632974372ad5423959cfe" translate="yes" xml:space="preserve">
          <source>The using-directive &lt;code&gt;using namespace std;&lt;/code&gt; at any namespace scope introduces every name from the namespace &lt;code&gt;std&lt;/code&gt; into the global namespace (since the global namespace is the nearest namespace that contains both &lt;code&gt;std&lt;/code&gt; and any user-declared namespace), which may lead to undesirable name collisions. This, and other using directives are generally considered bad practice at file scope of a header file.</source>
          <target state="translated">&lt;code&gt;using namespace std;&lt;/code&gt; ディレクティブ。任意の名前空間スコープで、名前空間 &lt;code&gt;std&lt;/code&gt; からすべての名前をグローバル名前空間に導入します（グローバル名前空間は &lt;code&gt;std&lt;/code&gt; とユーザー宣言の名前空間の両方を含む最も近い名前空間であるため）、これは望ましくない名前の衝突につながる可能性があります。これ、およびその他のusingディレクティブは、ヘッダーファイルのファイルスコープでは一般的に悪い習慣と見なされています。</target>
        </trans-unit>
        <trans-unit id="a0a29bcf7f924ca3c9afb16892af9ad80008618f" translate="yes" xml:space="preserve">
          <source>The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-operator is present and the expression is a prvalue. In those cases the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a reference that binds to the temporary variable &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from the prvalue expression, extending its lifetime. As usual, the binding will fail if &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a non-const lvalue reference:</source>
          <target state="translated">ref-operatorが存在し、式がprvalueである場合、一時的な参照バインディング（ライフタイムエクステンションを含む）の通常のルールが適用されます。これらの場合、隠し変数 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; は、prvalue式から&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;具体化さ&lt;/a&gt;れた一時変数にバインドする参照であり、その寿命を延ばします。いつものように、 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; が非定数の左辺値参照の場合、バインディングは失敗します。</target>
        </trans-unit>
        <trans-unit id="d143db4cb73d031e48783561f534e5977a6951dc" translate="yes" xml:space="preserve">
          <source>The utility functions &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt;, and &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; may be used to explicitly create an object following the above protocol, and &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; can be used to prepare the argument list that matches the flavor of uses-allocator construction expected by the type.</source>
          <target state="translated">効用関数は、 &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt; 、及び &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; 上記プロトコルに従ってオブジェクトを作成する明示的に使用することができる、と &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; によって期待される用途・アロケータ構造の味と一致する引数リストを調製するために使用することができますタイプ。</target>
        </trans-unit>
        <trans-unit id="fe1efdbf774195a43f57a666949496b9864e4331" translate="yes" xml:space="preserve">
          <source>The valid values (inherited from &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt;) are:</source>
          <target state="translated">有効な値（ &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt; から継承）は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ea8585806be7732f5b1559533a0afabee4e31468" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;false&lt;/code&gt; (the default) indicates that any flush will be postponed until a call to emit.</source>
          <target state="translated">値 &lt;code&gt;false&lt;/code&gt; （デフォルト）は、発行を呼び出すまでフラッシュが延期されることを示します。</target>
        </trans-unit>
        <trans-unit id="bec74bfd762b8f94824661d08795516a39875971" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; is used to indicate that either the destination range is too short to receive the results of the conversion or the input is truncated in the middle of an otherwise valid multibyte character.</source>
          <target state="translated">値 &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; は、変換先の範囲が短すぎて変換の結果を受け取ることができないか、入力が有効なマルチバイト文字の途中で切り捨てられていることを示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="b59da2ec2014ac9c518b1aadf220e6d3e58b2e01" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;true&lt;/code&gt; makes flushes apply immediately.</source>
          <target state="translated">値が &lt;code&gt;true&lt;/code&gt; の場合、フラッシュがすぐに適用されます。</target>
        </trans-unit>
        <trans-unit id="b297662cf0a9d877fef1ea088b887dc762885510" translate="yes" xml:space="preserve">
          <source>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have complete type except when the prvalue is not materialized, such as(since C++17) when used as the operand of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (or as the right operand of a &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;built-in comma operator expression&lt;/a&gt; that is the operand of &lt;code&gt;decltype&lt;/code&gt;).</source>
          <target state="translated">関数呼び出し式の値カテゴリは、関数が関数への左辺値参照または右辺値参照を返す場合は左辺値、関数がオブジェクトへの右辺値参照を返す場合はx値、そうでない場合はprvalueです。関数呼び出し式がオブジェクトタイプのprvalueである場合、prvalueが具体化されていない場合（C ++ 17以降）が&lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;のオペランドとして（または&lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;組み込みの&lt;/a&gt; &lt;code&gt;decltype&lt;/code&gt; のオペランドである-inコンマ演算子式）。</target>
        </trans-unit>
        <trans-unit id="67e47b55490dd997d102458418a048c6890cf272" translate="yes" xml:space="preserve">
          <source>The value comparison function object.</source>
          <target state="translated">値の比較関数オブジェクト。</target>
        </trans-unit>
        <trans-unit id="e3315b1caebdb1fc309be2d0ec78502282dc56fc" translate="yes" xml:space="preserve">
          <source>The value computed by the three-argument version of this function is the distance of the point &lt;code&gt;(x,y,z)&lt;/code&gt; from the origin &lt;code&gt;(0,0,0)&lt;/code&gt;.</source>
          <target state="translated">この関数の3つの引数のバージョンによって計算される値は、原点 &lt;code&gt;(0,0,0)&lt;/code&gt; からの点 &lt;code&gt;(x,y,z)&lt;/code&gt; の距離です。</target>
        </trans-unit>
        <trans-unit id="f316342cf5de6fdab5febb1bc73226832477d458" translate="yes" xml:space="preserve">
          <source>The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">この関数の2つの引数のバージョンで計算された値は、長さが &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の辺を持つ直角三角形の斜辺の長さ、または原点 &lt;code&gt;(0,0)&lt;/code&gt; &lt;code&gt;(x,y)&lt;/code&gt; からの点（x、y）の距離です。）、または複素数の大きさ &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が指すアトミックオブジェクトが以前に保持していた値。</target>
        </trans-unit>
        <trans-unit id="5b53ba13c1b7ad772fd50ae6d7f505fae71221a4" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; の&lt;a href=&quot;../memory_order#Modification_order&quot;&gt;変更順序&lt;/a&gt;でこの関数の効果の直前の値。</target>
        </trans-unit>
        <trans-unit id="21ba436ae4d60c1b3df6f313a5e847a739f28e04" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*obj&lt;/code&gt; の&lt;a href=&quot;memory_order#Modification_order&quot;&gt;変更順序&lt;/a&gt;でこの関数の効果の直前の値。</target>
        </trans-unit>
        <trans-unit id="2ad12bc074bf532e8969a9847c8c0936a889cc81" translate="yes" xml:space="preserve">
          <source>The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.</source>
          <target state="translated">得られた値は、t個のイエスノ実験のシーケンスにおける成功数であり、それぞれが確率pで成功している。</target>
        </trans-unit>
        <trans-unit id="33a4fa47add8b297d431d6dce6cb94e9aeac4af7" translate="yes" xml:space="preserve">
          <source>The value obtained is the probability of exactly i occurrences of a random event if the expected,</source>
          <target state="translated">得られた値は、期待された場合のランダムな事象が正確にi回発生する確率である。</target>
        </trans-unit>
        <trans-unit id="873f84075d8ee3fa467aeba44e733298e1a32864" translate="yes" xml:space="preserve">
          <source>The value obtained is the time/distance until the next random event if random events occur at constant rate &amp;lambda; per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.</source>
          <target state="translated">ランダムイベントが時間/距離の単位あたり一定のレート&amp;lambda;で発生する場合、取得される値は次のランダムイベントまでの時間/距離です。たとえば、この分布は、ガイガーカウンターのクリック間の時間、またはDNA鎖の点変異間の距離を表します。</target>
        </trans-unit>
        <trans-unit id="baf914d043e381313277e30f951edd923276b030" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; is the number of base-10 digits that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change, that is, any number with this many significant decimal digits can be converted to a value of type &lt;code&gt;T&lt;/code&gt; and back to decimal form, without change due to rounding or overflow. For base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; types, it is the value of &lt;a href=&quot;digits&quot;&gt;digits&lt;/a&gt; (&lt;code&gt;digits-1&lt;/code&gt; for floating-point types) multiplied by log</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; IS式で表すことができ、ベース10桁の数 &lt;code&gt;T&lt;/code&gt; で変化せずに、この多くの重要な桁を有する任意の数の値に変換することができます。入力 &lt;code&gt;T&lt;/code&gt; 四捨五入またはオーバーフローに変更することなく、小数形成し、バック。塩基ため&lt;a href=&quot;radix&quot;&gt;基数&lt;/a&gt;タイプ、それがの値である&lt;a href=&quot;digits&quot;&gt;桁&lt;/a&gt;（ &lt;code&gt;digits-1&lt;/code&gt; の浮動小数点タイプの）ログを乗じ</target>
        </trans-unit>
        <trans-unit id="c32d6df5f25bd1c67469d66fa412b07db9fb23e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; is the number of digits in base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; の値は、&lt;a href=&quot;radix&quot;&gt;基数&lt;/a&gt;の桁数であり、タイプ &lt;code&gt;T&lt;/code&gt; で変更せずに表すことができます。整数型の場合、これは符号ビットとパディングビット（存在する場合）をカウントしないビット数です。浮動小数点型の場合、これは仮数の桁数です。</target>
        </trans-unit>
        <trans-unit id="0efce6844d5328b9d552d5e22fa416002bf69dda" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifies the floating-point types that support &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;subnormal values&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; の値は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;非正規値&lt;/a&gt;をサポートする浮動小数点型を識別します。</target>
        </trans-unit>
        <trans-unit id="818565d8873864260ed4bd3755ec119254a0a789" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべての浮動小数点タイプの &lt;code&gt;T&lt;/code&gt; 非正規化損失として非正規化数を生成するのではなく不正確な結果（下記参照）場合の精度の損失を検出します。</target>
        </trans-unit>
        <trans-unit id="49fe53c8f4920123566acbcd270a4d7a6cb8ff5d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべてのタイプの &lt;code&gt;T&lt;/code&gt; 異なる特別な値として正の無限大を表すことができます。この定数はすべての浮動小数点型で意味が &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 場合にtrueであることが保証されています。</target>
        </trans-unit>
        <trans-unit id="72efab69a379a3baec3c747ef72e6384302c8f11" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべてのタイプの &lt;code&gt;T&lt;/code&gt; 特別な値を表すことができるが、「QUIET &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;ない-A-数&lt;/a&gt;」。この定数はすべての浮動小数点型で意味が &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 場合にtrueであることが保証されています。</target>
        </trans-unit>
        <trans-unit id="13d78c72e37aa6610d8da4c27392455c38353258" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべてのタイプの &lt;code&gt;T&lt;/code&gt; 「シグナリング特別な価値表現できる&lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;ない-A-数&lt;/a&gt;」。この定数はすべての浮動小数点型で意味が &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 場合にtrueであることが保証されています。</target>
        </trans-unit>
        <trans-unit id="f98212fab0bd1fe8a4594e818456712a7e96f5af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that represent a finite set of values. While all fundamental types are bounded, this constant would be &lt;code&gt;false&lt;/code&gt; in a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; for a library-provided arbitrary precision arithmetic type.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; すべての算術タイプの &lt;code&gt;T&lt;/code&gt; 値の有限集合を表します。基本的な型はすべて制限されていますが、ライブラリが提供する任意精度の算術型の &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 特殊化では、この定数は &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="a3bc9c048c67471591b1728199b12d7c643bc09a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that use exact representation.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; すべての算術タイプの &lt;code&gt;T&lt;/code&gt; の正確な表現を使用します。</target>
        </trans-unit>
        <trans-unit id="0de1e0807da9a49f5b6ab2b0b1d4bdf3282315d4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; which fulfill the requirements of IEC 559 (&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;) standard. If &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; are also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべての浮動小数点タイプの &lt;code&gt;T&lt;/code&gt; IEC 559（の要件満たす&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;）規格。もし &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、その後 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; 、と &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; もあります &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5566e2270326a63be00f7caa114991c2e742497" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise. This constant is meaningful for all specializations.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべての整数演算のタイプの &lt;code&gt;T&lt;/code&gt; 及び &lt;code&gt;false&lt;/code&gt; そうでありません。この定数は、すべての専門分野にとって意味があります。</target>
        </trans-unit>
        <trans-unit id="658be2ec18bfcdb89b874906fd0e9a2788a963dc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that are possible to (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range &lt;code&gt;[min(), max()]&lt;/code&gt;, the value returned by such operation differs from the expected value by a multiple of &lt;code&gt;max()-min()+1&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 全て算術タイプの &lt;code&gt;T&lt;/code&gt; に可能であるハンドルである、モジュロ演算でオーバフロー（C ++ 11まで）、もし加算の結果、減算、乗算、このタイプの除算は &lt;code&gt;[min(), max()]&lt;/code&gt; の範囲外になります。このような操作によって返される値は、期待値と &lt;code&gt;max()-min()+1&lt;/code&gt; の倍数で異なります。</target>
        </trans-unit>
        <trans-unit id="31c7c70df24e3cc025f30c7660467183acd0bc12" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all signed arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for the unsigned types. This constant is meaningful for all specializations.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべての符号付き算術タイプの &lt;code&gt;T&lt;/code&gt; 及び &lt;code&gt;false&lt;/code&gt; 符号なしのタイプの。この定数は、すべての専門分野にとって意味があります。</target>
        </trans-unit>
        <trans-unit id="c387cb47b15566bbeed0c9ac97ac7422cc757b9c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T&lt;/code&gt; for which there exists a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; すべてのために &lt;code&gt;T&lt;/code&gt; の専門が存在するために &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6c251458907976d9505f9f19b57f15d678ee8d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type &lt;code&gt;T&lt;/code&gt;, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; 一意のタイプのすべての異なる値表現するために必要なベース10桁の数である &lt;code&gt;T&lt;/code&gt; を、テキストにシリアライズ/デシリアライズするために必要なように、。この定数は、すべての浮動小数点型で意味があります。</target>
        </trans-unit>
        <trans-unit id="95ede15e1ccfe9c08910652785a578f9aff770fc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; 最大の正の数である &lt;code&gt;n&lt;/code&gt; よう10N</target>
        </trans-unit>
        <trans-unit id="4428910011b11510b83f35d9325633de507bd21f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; 最大の正の数である &lt;code&gt;n&lt;/code&gt; ようRN-1</target>
        </trans-unit>
        <trans-unit id="3a8e50309322655b0b34d76c3ee924a26b2a1631" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; 最も低い負の数である &lt;code&gt;n&lt;/code&gt; よう10N</target>
        </trans-unit>
        <trans-unit id="d7d35efd9d6ad828da236c558d6eb68513df2887" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; 最も低い負の数である &lt;code&gt;n&lt;/code&gt; ようRN-1</target>
        </trans-unit>
        <trans-unit id="67d3622bd53f05bb8c505d5f1632f3a6e465c7e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;decimal floating-point types&lt;/a&gt; or for third-party &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;binary-coded decimal&lt;/a&gt; integers. This constant is meaningful for all specializations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; の値は、型の表現で使用される数値システムのベースです。すべてのバイナリ数値型の場合は2ですが、たとえば、IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;10進浮動小数点型の&lt;/a&gt;場合やサードパーティの&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;バイナリコード10進&lt;/a&gt;整数の場合は10になります。この定数は、すべての専門分野にとって意味があります。</target>
        </trans-unit>
        <trans-unit id="ad3e3b6d189c403f77654a78e8b8fce06565fd64" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifies the rounding style used by the floating-point type &lt;code&gt;T&lt;/code&gt; whenever a value that is not one of the exactly repesentable values of &lt;code&gt;T&lt;/code&gt; is stored in an object of that type.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; 浮動小数点型で使用される識別丸めスタイル &lt;code&gt;T&lt;/code&gt; の正確repesentableのいずれかの値ではない値たび &lt;code&gt;T&lt;/code&gt; は、そのタイプのオブジェクトに格納されています。</target>
        </trans-unit>
        <trans-unit id="929804192ce1c0c75b72779392cd6ef40eb4db5c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that test results of floating-point expressions for underflow before rounding.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; すべての浮動小数点タイプの &lt;code&gt;T&lt;/code&gt; その丸めの前にアンダーフローのための浮動小数点式の試験結果。</target>
        </trans-unit>
        <trans-unit id="f1ed74039ebf1d42dca61166c833be8f6cd7f491" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that have at least one value that, if used as an argument to an arithmetic operation, will generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trap&lt;/a&gt;.</source>
          <target state="translated">値 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 全て算術タイプの &lt;code&gt;T&lt;/code&gt; 演算の引数として使用される場合、生成する、こと少なくとも一つの値有する&lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;トラップ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7772c8f78a06c27107be30f83bed9d48e68fe602" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(rv)&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">値 &lt;code&gt;T(rv)&lt;/code&gt; の値に相当する &lt;code&gt;rv&lt;/code&gt; 初期化する前に。</target>
        </trans-unit>
        <trans-unit id="e603736762efe81e0cad9751283ad8e5a1c288ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(v)&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;T(v)&lt;/code&gt; の値に相当する &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8ede44778ad8d0c527731cf4a992de2cbbc6337" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is a/2b</source>
          <target state="translated">&lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; の値はa / 2bです</target>
        </trans-unit>
        <trans-unit id="0e75326e3adb574a4a577f0c6f90eb22555c8d18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the unique value congruent to a * 2b</source>
          <target state="translated">&lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; の値は、a * 2bに一致する一意の値です</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">成功した場合は &lt;code&gt;base&lt;/code&gt; の値、それ以外の場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;errno&lt;/code&gt; がある &lt;code&gt;​0​&lt;/code&gt; プログラム起動時、およびライブラリ関数はに正の整数を書き込むことが許可されているが、 &lt;code&gt;errno&lt;/code&gt; にエラーが発生したかどうかにかかわらず、ライブラリ関数は、保存決して &lt;code&gt;​0​&lt;/code&gt; で &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;math_errhandling&lt;/code&gt; の値は、浮動小数点演算子と&lt;a href=&quot;../math&quot;&gt;関数&lt;/a&gt;によって実行されるエラー処理のタイプを示します。</target>
        </trans-unit>
        <trans-unit id="7588ffd7a3be6d286f7a94c5cb61054a64fe7ac0" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;required_alignment&lt;/code&gt; is the required alignment for an object to be referenced by an atomic reference, which is at least &lt;code&gt;alignof(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;required_alignment&lt;/code&gt; の値は、アトミック参照によって参照されるオブジェクトに必要な配置です。少なくとも &lt;code&gt;alignof(T)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a34573176a6c9f015786e0ff510ba4a79a46897b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;t&lt;/code&gt; はの値に相当し &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="236ee56b867559bead4e59b54a4e12b218879b5a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; の値は、初期化前の &lt;code&gt;rv&lt;/code&gt; の値と同じです。</target>
        </trans-unit>
        <trans-unit id="29aad058a8f1625b999d87663e4e7194ff6bfb72" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;u&lt;/code&gt; がの値に相当し &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c88528c3373936092717d4d0ad525f88f8c4c725" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; の値は変更されません。</target>
        </trans-unit>
        <trans-unit id="1e00c73d0ffbf3ea2f54f0b446263ab8f6d39011" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;std::contract_violation&lt;/code&gt; argument passed to the violation handler is otherwise implementation-defined.</source>
          <target state="translated">違反ハンドラに渡される &lt;code&gt;std::contract_violation&lt;/code&gt; 引数の値は、それ以外の場合は実装定義です。</target>
        </trans-unit>
        <trans-unit id="50fc3e65512141062b28f772c21ab1b1ae455710" translate="yes" xml:space="preserve">
          <source>The value of the atomic variable before the call.</source>
          <target state="translated">呼び出し前のアトミック変数の値。</target>
        </trans-unit>
        <trans-unit id="a3e86cc39cfa2d8064dc4c87f48911c38b5823b0" translate="yes" xml:space="preserve">
          <source>The value of the character pointed to by the</source>
          <target state="translated">が指す文字の値。</target>
        </trans-unit>
        <trans-unit id="a2c309bf2bbc046c6f48e885d2ea4de4c5bf6803" translate="yes" xml:space="preserve">
          <source>The value of the character that was pointed to by the</source>
          <target state="translated">が指し示した文字の値。</target>
        </trans-unit>
        <trans-unit id="1d70250e3d2b884af86af7d39be631bda55177ff" translate="yes" xml:space="preserve">
          <source>The value of the character that was read and consumed in case of success, or &lt;code&gt;Traits::eof()&lt;/code&gt; in case of failure.</source>
          <target state="translated">成功した場合に読み取られて消費された文字の値。失敗した場合は &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f39527ddfa65bb2b87383657aeac9ba9fbcb938" translate="yes" xml:space="preserve">
          <source>The value of the device entropy, or zero if not applicable.</source>
          <target state="translated">デバイスのエントロピーの値、該当しない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="9650465fffa6e1c6a542896eedb2d7c139c42b4e" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;std::ilogb&lt;/code&gt; によって返される指数の値は、標準化の要件が異なるため、 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; によって再調整される指数より常に1小さくなります。std &lt;code&gt;std::ilogb&lt;/code&gt; によって返される指数 &lt;code&gt;e&lt;/code&gt; の場合、| arg * re</target>
        </trans-unit>
        <trans-unit id="296087b3564287e313cec1b7f024f1690f7740f9" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;std::logb&lt;/code&gt; によって返される指数の値は、正規化の要件が異なるため、 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; によって再調整される指数より常に1小さくなります。std &lt;code&gt;std::logb&lt;/code&gt; によって返される指数 &lt;code&gt;e&lt;/code&gt; の場合、| arg * re</target>
        </trans-unit>
        <trans-unit id="1875dc13670139d279ca0c0bbdce2d158a5cdbab" translate="yes" xml:space="preserve">
          <source>The value of the next character. If the input sequence has been exhausted, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">次の文字の値。入力シーケンスが使い果たされた場合、 &lt;code&gt;Traits::eof()&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="753fa9ec46bd8acaa1bc2b9508919ca2004c1c39" translate="yes" xml:space="preserve">
          <source>The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though &lt;code&gt;operator()&lt;/code&gt;, the stored value is passed as one of the arguments, the other argument is passed as an argument of &lt;code&gt;operator()&lt;/code&gt;. The resulting function object is an unary function.</source>
          <target state="translated">パラメータの値は、構築時にオブジェクトに渡され、オブジェクト内に保存されます。 &lt;code&gt;operator()&lt;/code&gt; を介して関数オブジェクトが呼び出されるたびに、格納された値が引数の1つとして渡され、他の引数は &lt;code&gt;operator()&lt;/code&gt; の引数として渡されます。結果の関数オブジェクトは単項関数です。</target>
        </trans-unit>
        <trans-unit id="fba7a209e09ccfdda21dc54ae2df8a504208cb4c" translate="yes" xml:space="preserve">
          <source>The value of the referenced object before the call.</source>
          <target state="translated">呼び出し前の参照オブジェクトの値。</target>
        </trans-unit>
        <trans-unit id="579ea98c704ce031e4e668b7afec012ffc8fd162" translate="yes" xml:space="preserve">
          <source>The value of the referenced object, immediately preceding the effects of this function.</source>
          <target state="translated">この関数の効果の直前にある、参照されるオブジェクトの値。</target>
        </trans-unit>
        <trans-unit id="7e259073fe670a628dfb34370ab4b87683b659c4" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with both the macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt;, where defined, with the member function &lt;code&gt;is_lock_free&lt;/code&gt; and non-member function &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この定数の値は、メンバー関数 &lt;code&gt;is_lock_free&lt;/code&gt; および非メンバー関数 &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt; で定義されたマクロ &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt; の両方と一致しています。</target>
        </trans-unit>
        <trans-unit id="50845a026f496d39a63c3b0808c04361d0c8d58a" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with the result of member function &lt;code&gt;is_lock_free&lt;/code&gt;.</source>
          <target state="translated">この定数の値は、メンバー関数 &lt;code&gt;is_lock_free&lt;/code&gt; の結果と一致しています。</target>
        </trans-unit>
        <trans-unit id="3403e199b11ef7fa0931fa58eddb8861252d4576" translate="yes" xml:space="preserve">
          <source>The value of type &lt;code&gt;char_type&lt;/code&gt; to use as the decimal separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;L'.'&lt;/code&gt;.</source>
          <target state="translated">小数点記号として使用する &lt;code&gt;char_type&lt;/code&gt; 型の値。 &lt;code&gt;std::numpunct&lt;/code&gt; の標準的な特殊化は &lt;code&gt;'.'&lt;/code&gt; 返します。と &lt;code&gt;L'.'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d17479026d3ea907d688db9d63f82d0f2b54dabe" translate="yes" xml:space="preserve">
          <source>The value or reference, if any, returned by the above call to &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">上記の &lt;code&gt;Container::emplace_back&lt;/code&gt; 呼び出しによって返される値または参照（ある場合）。</target>
        </trans-unit>
        <trans-unit id="c811b075e6e49eb2c35eb490d71ce4d51653f77f" translate="yes" xml:space="preserve">
          <source>The value previously held by the flag pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">以前に &lt;code&gt;p&lt;/code&gt; が指すフラグが保持していた値。</target>
        </trans-unit>
        <trans-unit id="2e567269120efb53b09110c26a8c4b9df966cef5" translate="yes" xml:space="preserve">
          <source>The value represented by the digit &lt;code&gt;c&lt;/code&gt; in base &lt;code&gt;I&lt;/code&gt; if the character &lt;code&gt;c&lt;/code&gt; is a valid digit in base &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">文字 &lt;code&gt;c&lt;/code&gt; がベース &lt;code&gt;I&lt;/code&gt; の有効な数字である場合、ベース &lt;code&gt;I&lt;/code&gt; の数字 &lt;code&gt;c&lt;/code&gt; で表される値</target>
        </trans-unit>
        <trans-unit id="6f109c11a81bea0070c0d68dbb9891509f2180fe" translate="yes" xml:space="preserve">
          <source>The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.</source>
          <target state="translated">この値は、一連の独立した yesno 試行(それぞれが確率 p で成功する)において、正確に k 個の成功が発生するまでに失敗した回数を表します。</target>
        </trans-unit>
        <trans-unit id="8e434c235337a8e747f5dea3bd883fac3c017159" translate="yes" xml:space="preserve">
          <source>The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.</source>
          <target state="translated">この値は、単一の成功を得るために必要な yesno トライアル(それぞれが確率 p で成功する)の数を表しています。</target>
        </trans-unit>
        <trans-unit id="bf46f4d3ca59d9f0505163079a8aeb0e0dc873f3" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">&lt;code&gt;clock()&lt;/code&gt; が返す値は、実装によってはラップアラウンドする場合があります。たとえば、32ビットの &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; を使用するマシンでは、2147秒または36分後にラップします。</target>
        </trans-unit>
        <trans-unit id="ad4cdd680a12e6dfddb5ab5b51fcd6bb72586940" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; によって返される値。</target>
        </trans-unit>
        <trans-unit id="2f06ccf9b4233e6226d4ee4962b6bec1aa785187" translate="yes" xml:space="preserve">
          <source>The value returned by the called function.</source>
          <target state="translated">呼び出された関数が返す値。</target>
        </trans-unit>
        <trans-unit id="601b8abd8b6436ee946fa9803b76f69133a0a540" translate="yes" xml:space="preserve">
          <source>The value returned by this conversion function is a pointer to a function with C++ &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; that, when invoked, has the same effect as invoking the closure object's function call operator directly.</source>
          <target state="translated">この変換関数によって返される値は、C ++ &lt;a href=&quot;language_linkage&quot;&gt;言語リンケージ&lt;/a&gt;を持つ関数へのポインターであり、呼び出されると、クロージャーオブジェクトの関数呼び出し演算子を直接呼び出すのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="fdd035144b0ab851484c1c365e56cbd1dcc1b54a" translate="yes" xml:space="preserve">
          <source>The value returned shall be independent of the case of the characters in the sequence.</source>
          <target state="translated">返される値は、シーケンス内の文字の大文字小文字に依存しないものとする。</target>
        </trans-unit>
        <trans-unit id="b7fb32b3c03551e69bd2a36e0056ba4535fa1910" translate="yes" xml:space="preserve">
          <source>The value that is held by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; が指すアトミックオブジェクトが保持する値。</target>
        </trans-unit>
        <trans-unit id="833d5a34e8e09458e1d01611adfdc9d19f4256ea" translate="yes" xml:space="preserve">
          <source>The value that results from assigning or initializing a signed bit field with a value out of range, or from incrementing a signed bit field past its range.</source>
          <target state="translated">範囲外の値を持つ符号付きビットフィールドを代入または初期化した結果、または符号付きビットフィールドをその範囲を超えてインクリメントした結果の値。</target>
        </trans-unit>
        <trans-unit id="da945c5370b89f1c8352311f12a54ddba345a51b" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;RandomIt1&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RandomIt1&lt;/code&gt; の値の型は、&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;、&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;、&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignableである&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="cf2f9d6307fbcb0677baa700e9f0dbc912c45998" translate="yes" xml:space="preserve">
          <source>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become &lt;code&gt;false&lt;/code&gt;. All other values become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">値0（整数、浮動小数点、およびスコープ外の列挙）、およびnullポインターとnullポインターからメンバーへの値は &lt;code&gt;false&lt;/code&gt; になります。他のすべての値は &lt;code&gt;true&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="7ba8effa4c27f0ba732998c45f3421c98781d70d" translate="yes" xml:space="preserve">
          <source>The values in the returned struct may differ from those supplied to the constructor in the following ways:</source>
          <target state="translated">返される構造体の値は、以下の方法でコンストラクタに与えられる値とは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sep_by_space&lt;/code&gt; 、 &lt;code&gt;n_sep_by_space&lt;/code&gt; 、 &lt;code&gt;int_p_sep_by_space&lt;/code&gt; 、 &lt;code&gt;int_n_sep_by_space&lt;/code&gt; の値は、次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sign_posn&lt;/code&gt; 、 &lt;code&gt;n_sign_posn&lt;/code&gt; 、 &lt;code&gt;int_p_sign_posn&lt;/code&gt; 、 &lt;code&gt;int_n_sign_posn&lt;/code&gt; の値は次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="33abc0ae5b48791fecb22e74c9f73d03bb18aa24" translate="yes" xml:space="preserve">
          <source>The values of the member typedefs are as follows.</source>
          <target state="translated">メンバの型定義の値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">これらのマクロの値（ &lt;code&gt;__FILE__&lt;/code&gt; および &lt;code&gt;__LINE__&lt;/code&gt; を除く）は、変換単位全体で一定です。これらのマクロを再定義または未定義にしようとすると、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="98bfbbcd22ae41d5573869cfcb9522362b10fb4c" translate="yes" xml:space="preserve">
          <source>The version of this function provided in the standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; does the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 標準ライブラリ特殊化で提供されるこの関数のバージョンは、次のことを行います。</target>
        </trans-unit>
        <trans-unit id="a622961aafca050ec72f078b30740b239e4cfd26" translate="yes" xml:space="preserve">
          <source>The versions (1-4) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. Versions (1-8) are</source>
          <target state="translated">&lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; ヘッダーが含まれていない場合でも、バージョン（1〜4）は各変換単位で暗黙的に宣言されます。バージョン（1-8）は</target>
        </trans-unit>
        <trans-unit id="b0b7d7c2aa828b9a641d26b6867ec8872ed88500" translate="yes" xml:space="preserve">
          <source>The weak forms ((1) and (3)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">関数の弱い形式（（1）と（3））は、誤って失敗することを許可されます。つまり、等しい場合でも &lt;code&gt;*obj != *expected&lt;/code&gt; ように動作します。比較と交換がループ内にある場合、弱いバージョンを使用すると、一部のプラットフォームでパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="053ece5439dd03785d396cff64f13b7779aae0c4" translate="yes" xml:space="preserve">
          <source>The weak forms (1-2) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*this != expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">関数の弱い形式（1-2）は、誤って失敗することが許可されています。つまり、 &lt;code&gt;*this != expected&lt;/code&gt; が等しい場合でも予期されるように動作します。比較と交換がループ内にある場合、弱いバージョンを使用すると、一部のプラットフォームでパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="61282ad563d58ac6dca223420c82a6fda52cb8a1" translate="yes" xml:space="preserve">
          <source>The weakest alignment (the smallest alignment requirement) is the alignment of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, which equals 1; the largest</source>
          <target state="translated">最も弱い配置（最小の配置要件）は、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;signed char&lt;/code&gt; 、および &lt;code&gt;unsigned char&lt;/code&gt; の配置であり、1に等しい。最大</target>
        </trans-unit>
        <trans-unit id="6636ab7a40ed20b3758bf9d6aa3f53a69dfb3fd6" translate="yes" xml:space="preserve">
          <source>The weekday value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に格納されている曜日の値。</target>
        </trans-unit>
        <trans-unit id="147c41b97d63a5ff943a4dff64e656850433bca6" translate="yes" xml:space="preserve">
          <source>The whitespace skipping is performed by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;, which reads and discards the characters classified as whitespace by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the stream's imbued locale.</source>
          <target state="translated">空白のスキップは、 &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt; コンストラクターによって実行され、ストリームの組み込みロケールの &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; ファセットによって空白として分類された文字を読み取り、破棄します。</target>
        </trans-unit>
        <trans-unit id="28861a2e9cac8a64e7e6c9de02d8f4ad1d432f65" translate="yes" xml:space="preserve">
          <source>The width property of the stream will be reset to zero (meaning &quot;unspecified&quot;) if any of the following functions are called:</source>
          <target state="translated">以下の関数のいずれかが呼び出された場合、ストリームの幅プロパティはゼロにリセットされます(「不特定」を意味します)。</target>
        </trans-unit>
        <trans-unit id="75482b7330efd238856a66fa9534aa457b8aac86" translate="yes" xml:space="preserve">
          <source>The written character, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; on success.</source>
          <target state="translated">書かれた文字は、に変換 &lt;code&gt;int_type&lt;/code&gt; で &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; 、成功しました。</target>
        </trans-unit>
        <trans-unit id="1270ca56a41a6e7f02e1f97ce0b715f2fb7199a2" translate="yes" xml:space="preserve">
          <source>The year value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; に保存される年の値。</target>
        </trans-unit>
        <trans-unit id="d323f4076e0841438d41510cd53cbcfb9286a841" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;replacement&lt;/code&gt; is appended as if by &lt;code&gt;operator+=(replacement)&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;operator+=(replacement)&lt;/code&gt; のように &lt;code&gt;replacement&lt;/code&gt; が追加されます。</target>
        </trans-unit>
        <trans-unit id="373a08cad37838d1afc67f2d26d81125cf6dd627" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;std::launder(p)&lt;/code&gt; returns a value of type &lt;code&gt;T*&lt;/code&gt; that points to the object &lt;code&gt;X&lt;/code&gt;. Otherwise, the behavior is undefined.</source>
          <target state="translated">次に &lt;code&gt;std::launder(p)&lt;/code&gt; は、オブジェクト &lt;code&gt;X&lt;/code&gt; を指す &lt;code&gt;T*&lt;/code&gt; 型の値を返します。それ以外の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a8cef55836d6512dfe4dc252602d2fb2a942c56d" translate="yes" xml:space="preserve">
          <source>Then converts the argument &lt;code&gt;dir&lt;/code&gt; to a value &lt;code&gt;whence&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; as follows:</source>
          <target state="translated">次に、引数 &lt;code&gt;dir&lt;/code&gt; を次のように &lt;code&gt;int&lt;/code&gt; 型の &lt;code&gt;whence&lt;/code&gt; 値に変換します。</target>
        </trans-unit>
        <trans-unit id="d114c31b8c85d68931469ea5e0153732743033d0" translate="yes" xml:space="preserve">
          <source>Then for the expression &lt;code&gt;w1 == w2&lt;/code&gt; and &lt;code&gt;w1 != w2&lt;/code&gt; either or both objects may be replaced by an</source>
          <target state="translated">次に、式 &lt;code&gt;w1 == w2&lt;/code&gt; および &lt;code&gt;w1 != w2&lt;/code&gt; 場合、いずれかまたは両方のオブジェクトを</target>
        </trans-unit>
        <trans-unit id="5664e9f77aa6963c92dfdd8b0b7e6f96d1c31677" translate="yes" xml:space="preserve">
          <source>Then performs move-assignment by moving all contents from &lt;code&gt;other&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;other&lt;/code&gt; is not associated with a stream, and &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;other&lt;/code&gt; will not produce any output.</source>
          <target state="translated">次に、一時ストレージ、ラップされたストリームポインター、ポリシー、および他のすべての状態（ミューテックスポインターなど）を含む &lt;code&gt;other&lt;/code&gt; からすべてのコンテンツを移動することにより、移動割り当てを実行します。移動後、 &lt;code&gt;other&lt;/code&gt; はストリームに関連付けられず、 &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt; になります。基底クラスのプットエリアのメンバーポインタは &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;other&lt;/code&gt; ヌルであることが保証されています。moved-from &lt;code&gt;other&lt;/code&gt; を破棄しても、出力は生成されません。</target>
        </trans-unit>
        <trans-unit id="688a34f8e387e542a111a325ed5ac02b72fbb6e9" translate="yes" xml:space="preserve">
          <source>Then repositions the file pointer, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt; 呼び出すのと同じように、ファイルポインターの位置を変更します。</target>
        </trans-unit>
        <trans-unit id="7c6cd6761eff74a4e8721e60e098e84a0745d88f" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;str&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">次に、結果のシーケンス（ &lt;code&gt;str&lt;/code&gt; の内容とパディング）の各文字を、 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 呼び出すのと同じように出力ストリーム &lt;code&gt;os&lt;/code&gt; に格納します。ここで、 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89dd54897998475390b292a027e7346fd0e80fba" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;v&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">次に、結果のシーケンス（ &lt;code&gt;v&lt;/code&gt; の内容とパディング）の各文字を、 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 呼び出すのと同じように出力ストリーム &lt;code&gt;os&lt;/code&gt; に格納します。ここで、 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b71560ffb9f745af8a0de8c02270fff34828d1a4" translate="yes" xml:space="preserve">
          <source>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</source>
          <target state="translated">その場合、テンプレート1の方がテンプレート2よりも特化していることになります。テンプレートの順番を切り替えた後に上記の条件が満たされていれば、テンプレート1よりもテンプレート2の方が専門性が高い。そうでなければ、どちらのテンプレートも他のテンプレートよりも専門性が高いとは言えません。引き分けの場合,一方の関数テンプレートに後続のパラメータパックがあり,他方の関数テンプレートにパラメータパックがない場合,パラメータが省略されたテンプレートの方が,パラメータパックが空のテンプレートよりも専門性が高いとみなされます.</target>
        </trans-unit>
        <trans-unit id="d3271caf912e95526fbf0f4e50e8dacc62c22392" translate="yes" xml:space="preserve">
          <source>Then the function behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if any &lt;code&gt;ios_base::iostate&lt;/code&gt; flags are set, the function sets &lt;code&gt;failbit&lt;/code&gt; and returns. Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt;.</source>
          <target state="translated">その後、関数は&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;として動作します。監視オブジェクトを作成して確認した後、 &lt;code&gt;ios_base::iostate&lt;/code&gt; フラグが設定されている場合、関数は &lt;code&gt;failbit&lt;/code&gt; を設定して戻ります。それ以外の場合は、 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="36f34a067b6d5809ad8db68785a0d829422e3317" translate="yes" xml:space="preserve">
          <source>Then this function in the class &lt;code&gt;Derived&lt;/code&gt; is also</source>
          <target state="translated">次に、クラス &lt;code&gt;Derived&lt;/code&gt; のこの関数も</target>
        </trans-unit>
        <trans-unit id="7f48f8e860002b0a6fca10b3b58cdef248ff8167" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;awaiter.await_ready()&lt;/code&gt; is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is &lt;code&gt;false&lt;/code&gt; then.</source>
          <target state="translated">次に、 &lt;code&gt;awaiter.await_ready()&lt;/code&gt; が呼び出されます（これは、結果の準備ができているか、同期して完了できることがわかっている場合に、中断によるコストを回避するためのショートカットです）。その結果、boolにコンテキスト変換された場合は &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="8f56bc35fde57e5d45735f7118718bf8634008b7" translate="yes" xml:space="preserve">
          <source>Then, a dot character is appended to the generic-format view of the pathname, if &lt;code&gt;replacement&lt;/code&gt; is not empty or does not begin with a dot character.</source>
          <target state="translated">次に、 &lt;code&gt;replacement&lt;/code&gt; が空でないか、ドット文字で始まらない場合は、ドット名がパス名の総称形式ビューに追加されます。</target>
        </trans-unit>
        <trans-unit id="7a8ce560ef479ac7bd437cfaae9fee813911dce4" translate="yes" xml:space="preserve">
          <source>Then, closes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, regardless of whether any of the preceding calls succeeded or failed.</source>
          <target state="translated">次に、先行する呼び出しが成功したか失敗したかに関係なく、 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 呼び出してファイルを閉じます。</target>
        </trans-unit>
        <trans-unit id="bb70360ec88c4bb9dac2644a98645695f52f42d5" translate="yes" xml:space="preserve">
          <source>Then, for the expressions &lt;code&gt;p1 == p2&lt;/code&gt;, &lt;code&gt;p1 != p2&lt;/code&gt;, &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt;&lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt;, &lt;code&gt;p1 - p2&lt;/code&gt;} either or both objects may be replaced by an</source>
          <target state="translated">次に、式 &lt;code&gt;p1 == p2&lt;/code&gt; 、 &lt;code&gt;p1 != p2&lt;/code&gt; 、 &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt; &lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt; 、 &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt; 、 &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt; 、 &lt;code&gt;p1 - p2&lt;/code&gt; }のいずれかまたは両方のオブジェクトを</target>
        </trans-unit>
        <trans-unit id="03792c753032d7cb9233d55af244f2b35fa6ba5a" translate="yes" xml:space="preserve">
          <source>Then, if &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt;, adds &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copies of the fill character &lt;code&gt;out.fill()&lt;/code&gt; either at the end of the sequence (if &lt;code&gt;ios_base::left&lt;/code&gt; is set in &lt;code&gt;out.flags()&lt;/code&gt;) or at the beginning of the sequence (in all other cases).</source>
          <target state="translated">次に、 &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt; 場合、シーケンスの最後のいずれかにフィル文字 &lt;code&gt;out.fill()&lt;/code&gt; の &lt;code&gt;out.width()-seq.size()&lt;/code&gt; コピーを追加します（ &lt;code&gt;ios_base::left&lt;/code&gt; は、 &lt;code&gt;out.flags()&lt;/code&gt; で設定されるか、シーケンスの先頭に設定されます（他のすべての場合）。</target>
        </trans-unit>
        <trans-unit id="9b66cf1ae7e463d5761dc0c8e4b85c87a42f6ae4" translate="yes" xml:space="preserve">
          <source>Then, if the character encoding is fixed-width (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returns some positive number &lt;code&gt;width&lt;/code&gt;, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt;.</source>
          <target state="translated">次に、文字エンコードが固定幅の場合（ &lt;code&gt;codecvt::encoding()&lt;/code&gt; は正の数値 &lt;code&gt;width&lt;/code&gt; を返し、 &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt; ようにファイルポインターを移動します。</target>
        </trans-unit>
        <trans-unit id="1588837f0abae43644f6a59f2a7e9d05829935b3" translate="yes" xml:space="preserve">
          <source>Then, if the current emit-on-sync policy is &lt;code&gt;true&lt;/code&gt;, makes a call to &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">次に、現在の発信時同期ポリシーが &lt;code&gt;true&lt;/code&gt; の場合、は発信&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="e328ed3f5e3fe95a687636b98322058fa4cd84c4" translate="yes" xml:space="preserve">
          <source>Then, move-assigns the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt; from the corresponding member of &lt;code&gt;other&lt;/code&gt; (after this move-assignment, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns a null pointer and destruction of &lt;code&gt;other&lt;/code&gt; produces no output) and &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-assigns&lt;/a&gt; the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (this swaps all stream state variables except for &lt;code&gt;rdbuf&lt;/code&gt; between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;).</source>
          <target state="translated">その後、ラップされた動きは、割り当て &lt;code&gt;std::basic_syncbuf&lt;/code&gt; の対応するメンバーから &lt;code&gt;other&lt;/code&gt; （この動き割当後 &lt;code&gt;other.get_wrapped()&lt;/code&gt; のヌルポインタと破壊返し &lt;code&gt;other&lt;/code&gt; 出力を生成しません）と&lt;a href=&quot;../basic_ostream/operator=&quot;&gt;ムーブ割り当てる&lt;/a&gt;基地 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; （このスワップを除くすべてのストリーム状態変数 &lt;code&gt;rdbuf&lt;/code&gt; の間 &lt;code&gt;*this&lt;/code&gt; および &lt;code&gt;other&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cac51d51872e9519bbc0bc669f0606d196b2f4a3" translate="yes" xml:space="preserve">
          <source>Then, the awaiter object is obtained, as follows:</source>
          <target state="translated">そして、以下のようにして待ち受けオブジェクトを取得する。</target>
        </trans-unit>
        <trans-unit id="6b9e0d6ed6f7b1751b629f6e3ddc80ecb32c6693" translate="yes" xml:space="preserve">
          <source>Then, whether &lt;code&gt;to&lt;/code&gt; already existed or was just created, iterates over the files contained in &lt;code&gt;from&lt;/code&gt; as if by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; and for each directory entry, recursively calls &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt;, where</source>
          <target state="translated">次に、すでに存在しているか、作成されたかにかかわら &lt;code&gt;to&lt;/code&gt; 、 &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; &lt;a href=&quot;directory_entry&quot;&gt;std :: filesystem :: directory_entry&lt;/a&gt;＆x：&lt;a href=&quot;directory_iterator&quot;&gt;std :: filesystem :: directory_iterator&lt;/a&gt;（from））および各ディレクトリエントリのように、 &lt;code&gt;from&lt;/code&gt; に含まれるファイルを反復します。、再帰呼び出しは &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt; 、場所</target>
        </trans-unit>
        <trans-unit id="e9125d469bb8f6aff93d3721871c0958a43dafdd" translate="yes" xml:space="preserve">
          <source>Then, x1 and x2 are</source>
          <target state="translated">とすると、x1とx2は</target>
        </trans-unit>
        <trans-unit id="c5bb0afc7219a935f5a73b87436c78d57282e9f3" translate="yes" xml:space="preserve">
          <source>Then.</source>
          <target state="translated">Then.</target>
        </trans-unit>
        <trans-unit id="dcb618e3bc4e6760e6d24a1d8c4732cdb2523ec0" translate="yes" xml:space="preserve">
          <source>Theoretical maximum allocation size.</source>
          <target state="translated">理論上の最大割当サイズ。</target>
        </trans-unit>
        <trans-unit id="7dcca98b4934dc33e5546547c327611fcc667809" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">ISO646以外の文字を使用するいくつかの演算子およびその他のトークンには、代替スペルがあります。言語のすべての点で、各代替トークンは、スペルを除いて、プライマリトークンとまったく同じように動作します（&lt;a href=&quot;../preprocessor/replace&quot;&gt;文字列化演算子&lt;/a&gt;はスペルを表示することができます）。2文字の代替トークンは「ダイグラフ」と呼ばれることもあります</target>
        </trans-unit>
        <trans-unit id="8e6f3eaebb9a3927bc985adcb62df7d15d191025" translate="yes" xml:space="preserve">
          <source>There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:</source>
          <target state="translated">浮動小数点型の例外が発生したときに C++の例外を自動的に生成するために使用できるコンパイラ拡張機能があります。</target>
        </trans-unit>
        <trans-unit id="3f225f0e74f08c0d0f2caf0e296a39e971ff8239" translate="yes" xml:space="preserve">
          <source>There are five available return types:</source>
          <target state="translated">リターンは5種類用意されています。</target>
        </trans-unit>
        <trans-unit id="c8b561cc0eef33e481077a8d77db9eb795dcf585" translate="yes" xml:space="preserve">
          <source>There are five(until C++17)six(since C++17) kinds of iterators: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;(since C++17).</source>
          <target state="translated">：5~6（17 ++ Cまで）イテレータの種類（C ++ 17以降）があり&lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;、&lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;、&lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;、&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;、及び&lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;（C以降++ 17）。</target>
        </trans-unit>
        <trans-unit id="9778100d7798733f17cf489450cafd2088023fa7" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">符号ビットとペイロードが異なる多くの異なるNaN値があります &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; およびstd :: numeric_limits :: quiet_NaNを参照してください。</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">ペイロードと符号ビットによって区別される多くの異なるNaN値があります。ペイロードの内容とマクロ &lt;code&gt;NAN&lt;/code&gt; によって生成されたNaNの符号ビットは、実装によって定義されます。</target>
        </trans-unit>
        <trans-unit id="a956cc8cb0205c1b4676cee813cb10d9f4679af6" translate="yes" xml:space="preserve">
          <source>There are many types for which equality makes sense, but not less-than ordering: a common example are the complex numbers, or any pair of numbers in general:</source>
          <target state="translated">等価が意味をなすタイプはたくさんありますが、順序以下ではありません:一般的な例としては複素数や一般的な数字のペアがあります。</target>
        </trans-unit>
        <trans-unit id="694fc92221739aa50089385fa6fdb3ce4ff4a1f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt; for bit fields: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; and &lt;code&gt;int b : 1 {0}&lt;/code&gt; are ill-formed.</source>
          <target state="translated">ビットフィールドの&lt;a href=&quot;data_members#Member_initialization&quot;&gt;デフォルトのメンバー初期化子&lt;/a&gt;はありません &lt;code&gt;int b : 1 = 0;&lt;/code&gt; および &lt;code&gt;int b : 1 {0}&lt;/code&gt; 形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="db2de29aa1d33752b78c0dd7d6ec96850ff5a7be" translate="yes" xml:space="preserve">
          <source>There are no arrays of references or arrays of functions.</source>
          <target state="translated">参照の配列や関数の配列はありません。</target>
        </trans-unit>
        <trans-unit id="37439af54c020a64a12e9c758da796ee25c34c35" translate="yes" xml:space="preserve">
          <source>There are no bit field &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;: lvalue-to-rvalue conversion always produces an object of the underlying type of the bit field.</source>
          <target state="translated">ビットフィールド&lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;はありません。lvalueからrvalueへの変換では、常にビットフィールドの基になる型のオブジェクトが生成されます。</target>
        </trans-unit>
        <trans-unit id="f39ab94881006d285c7e811db2e42c17ba7a7d98" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls).</source>
          <target state="translated">生成されるランダムシーケンスの品質については保証されません。過去に、 &lt;code&gt;rand()&lt;/code&gt; の一部の実装では、生成されるシーケンスのランダム性、分布、および周期に重大な欠点がありました（1つのよく知られた例では、下位ビットは呼び出し間で &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;0&lt;/code&gt; の間で交互に入れ替わりました）。</target>
        </trans-unit>
        <trans-unit id="991d3d81eb996d06aa3347bc77bacaef91a6483e" translate="yes" xml:space="preserve">
          <source>There are no negative integer literals. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the literal, which may involve implicit type conversions.</source>
          <target state="translated">負の整数リテラルはありません。 &lt;code&gt;-1&lt;/code&gt; などの式は、リテラルで表される値に&lt;a href=&quot;operator_arithmetic&quot;&gt;単項マイナス演算子&lt;/a&gt;を適用します。これには、暗黙的な型変換が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="bcb7f46103fbd100a4f9cb6ff99abb2c28199213" translate="yes" xml:space="preserve">
          <source>There are no optional references; a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with a reference type. Alternatively, an &lt;code&gt;optional&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; may be used to hold a reference. In addition, a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with the tag types &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">オプションの参照はありません。参照型で &lt;code&gt;optional&lt;/code&gt; をインスタンス化すると、プログラムの形式が正しくありません。または、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; &lt;code&gt;optional&lt;/code&gt; を使用して、参照を保持することもできます。さらに、タグ型 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt; &lt;code&gt;optional&lt;/code&gt; してオプションをインスタンス化すると、プログラムの形式が正しくなくなります。</target>
        </trans-unit>
        <trans-unit id="8419f6809e1cf19b6fb3b6a22f4638d4c5849b20" translate="yes" xml:space="preserve">
          <source>There are no overload for pointers to non-static member, pointers to volatile, or function pointers (other than the ones with signatures accepted by the (10-12) overloads). Attempting to output such objects invokes implicit conversion to &lt;code&gt;bool&lt;/code&gt;, and, for any non-null pointer value, the value &lt;code&gt;1&lt;/code&gt; is printed (unless &lt;code&gt;boolalpha&lt;/code&gt; was set, in which case &lt;code&gt;true&lt;/code&gt; is printed).</source>
          <target state="translated">非静的メンバーへのポインター、揮発性へのポインター、または関数ポインターへのオーバーロードはありません（（10-12）オーバーロードで受け入れられるシグネチャを持つものを除く）。このようなオブジェクトを出力しようとすると、 &lt;code&gt;bool&lt;/code&gt; への暗黙の変換が呼び出され、null以外のポインター値の場合は、値 &lt;code&gt;1&lt;/code&gt; が出力されます（ &lt;code&gt;boolalpha&lt;/code&gt; が設定されていない場合、 &lt;code&gt;true&lt;/code&gt; が出力されます）。</target>
        </trans-unit>
        <trans-unit id="3e3662fa8ed3550ea700d26fee022c4ac95bb7d6" translate="yes" xml:space="preserve">
          <source>There are no pointers to &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and there are no pointers to &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;. Typically, mentions of &quot;pointers&quot; without elaboration do not include pointers to (non-static) members.</source>
          <target state="translated">ポインタはありません&lt;a href=&quot;reference&quot;&gt;参照は、&lt;/a&gt;およびへのポインタが存在しない&lt;a href=&quot;bit_field&quot;&gt;ビットフィールドは&lt;/a&gt;。通常、詳細な説明のない「ポインター」の言及には、（静的でない）メンバーへのポインターは含まれません。</target>
        </trans-unit>
        <trans-unit id="337c29a8a2b7567bb32c86a4abf4bf2501e7a2ab" translate="yes" xml:space="preserve">
          <source>There are no references to &lt;code&gt;void&lt;/code&gt; and no references to references.</source>
          <target state="translated">参照はありません &lt;code&gt;void&lt;/code&gt; と参照への参照を。</target>
        </trans-unit>
        <trans-unit id="1deb84f794c63103b9555294bae8bd9107563871" translate="yes" xml:space="preserve">
          <source>There are no standard complexity guarantees, typical implementations behave similar to &lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;.</source>
          <target state="translated">標準的な複雑さの保証はありません。一般的な実装は&lt;a href=&quot;../../container/vector/insert&quot;&gt;std :: vector :: insert&lt;/a&gt;と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="5ef11a32cf3433c799eb8a56e867da73440715a2" translate="yes" xml:space="preserve">
          <source>There are non-member function template equivalents for all member functions of &lt;code&gt;std::atomic&lt;/code&gt;. Those non-member functions may be additionally overloaded for types that are not specializations of &lt;code&gt;std::atomic&lt;/code&gt;, but are able to guarantee atomicity. The only such type in the standard library is &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic&lt;/code&gt; すべてのメンバー関数に対応する非メンバー関数テンプレートがあります。これらの非メンバー関数は、 &lt;code&gt;std::atomic&lt;/code&gt; 特殊化ではないがアトミック性を保証できるタイプの場合、さらにオーバーロードされる可能性があります。標準ライブラリでこのようなタイプは &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7e79772c53f1ce2b7a68f39acb9950fc2f71b6e0" translate="yes" xml:space="preserve">
          <source>There are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance), see &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup#Member_function_definition&lt;/a&gt;.</source>
          <target state="translated">仮想継承が関係する場合のクラスメンバーの非修飾名ルックアップには特別なルールがあります（&lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;優先&lt;/a&gt;ルールと呼ばれることもあります）。unqualified_lookup＃Member_function_definitionを参照してください。</target>
        </trans-unit>
        <trans-unit id="9a402f4ecfc55e94136a1e80cc1d6a5286b19956" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section, refer to individual member function pages for more detail.</source>
          <target state="translated">このセクションでは、まだいくつかの不正確な点がありますので、詳細は各メンバーの機能ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="941295990d20765c0666a8c77b5e2c06086eb3fc" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section. Refer to individual member function pages for more detail.</source>
          <target state="translated">まだまだ不正確な部分があります。詳細は各メンバー機能のページを参照してください。</target>
        </trans-unit>
        <trans-unit id="fbc45885aff604aaea2abb7208dd0c18b8bc3d95" translate="yes" xml:space="preserve">
          <source>There are three conventions of passing an allocator &lt;code&gt;alloc&lt;/code&gt; to a constructor of some type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型のコンストラクタにアロケータ &lt;code&gt;alloc&lt;/code&gt; を渡すには、3つの規則があります。</target>
        </trans-unit>
        <trans-unit id="eb2f200b57b0d8a9c6686c50668bd2b80b8b6b29" translate="yes" xml:space="preserve">
          <source>There are three types of constraints:</source>
          <target state="translated">制約には3つのタイプがあります。</target>
        </trans-unit>
        <trans-unit id="0f09bbf4176190877beb129c86ae3e9c8e358d71" translate="yes" xml:space="preserve">
          <source>There are three types of null-terminated strings:</source>
          <target state="translated">ヌル文字で終端する文字列には3つのタイプがあります。</target>
        </trans-unit>
        <trans-unit id="7c2a33396de83eb35e9628e69e71f05f450481e2" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enumerations:</source>
          <target state="translated">列挙には2つの種類があります。</target>
        </trans-unit>
        <trans-unit id="6f669e5024934effcd4278fb23f0f95ad252bc52" translate="yes" xml:space="preserve">
          <source>There are two exceptions from that:</source>
          <target state="translated">そこには2つの例外があります。</target>
        </trans-unit>
        <trans-unit id="36231641abbbc5cce8b62cf3185cc936bfddd00e" translate="yes" xml:space="preserve">
          <source>There are two kinds of implementations defined by the C++ standard:</source>
          <target state="translated">C++標準で定義されている実装には、2 種類あります。</target>
        </trans-unit>
        <trans-unit id="e504119c92fe73e0c1cae5141f8e4e4cd1909108" translate="yes" xml:space="preserve">
          <source>There are two versions of &lt;code&gt;std::unique_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; は2つのバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="31bf78ac4643c55ed74c0dfba62be6194d38f599" translate="yes" xml:space="preserve">
          <source>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage(since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) as long as all of the following is true:</source>
          <target state="translated">プログラムに複数の定義が存在する可能性があります。ただし、各定義が異なる変換単位にある限り、クラス型、列挙型、外部リンケージ付きのインライン関数、外部リンケージ付きのインライン変数（C ++以降） 17）、クラステンプレート、非静的関数テンプレート、クラステンプレートの静的データメンバー、クラステンプレートのメンバー関数、部分的なテンプレートの特殊化、&lt;a href=&quot;constraints&quot;&gt;コンセプト&lt;/a&gt;（C ++ 20以降）、ただし、以下のすべてに該当する場合：</target>
        </trans-unit>
        <trans-unit id="3787f2ae99932166a7dcbb82d18d8948ed35d334" translate="yes" xml:space="preserve">
          <source>There exists an atomic object M,</source>
          <target state="translated">原子物体Mが存在する。</target>
        </trans-unit>
        <trans-unit id="79c74ac70167e62133877fbfab7ff339ffa4b43b" translate="yes" xml:space="preserve">
          <source>There exists an atomic read Y (with any memory order) in thread B</source>
          <target state="translated">スレッド B には、(任意のメモリ順序で)アトミックリード Y が存在します。</target>
        </trans-unit>
        <trans-unit id="7b325c9ba4bba31055eea3a7f3839a38f5af398a" translate="yes" xml:space="preserve">
          <source>There exists an atomic write X (with any memory order) that modifies M in thread A</source>
          <target state="translated">スレッド A の M を変更する(任意のメモリ順序で)アトミック書き込み X が存在します。</target>
        </trans-unit>
        <trans-unit id="b5311041dd1561f12757a5b111f905e8cf9ceb71" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">各変換指定子のアクションの後に&lt;a href=&quot;../../language/eval_order&quot;&gt;シーケンスポイント&lt;/a&gt;があります。これにより、複数の &lt;code&gt;%n&lt;/code&gt; 結果を同じ変数に格納することができます。また、端的なケースとして、同じ呼び出し内で以前の &lt;code&gt;%n&lt;/code&gt; によって変更された文字列を出力することもできます。</target>
        </trans-unit>
        <trans-unit id="3baee1a6a7acc4dbecfba1cab14149a6beefecea" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">各変換指定子のアクションの後に&lt;a href=&quot;../../language/eval_order&quot;&gt;シーケンスポイント&lt;/a&gt;があります。これにより、複数のフィールドを同じ「シンク」変数に格納できます。</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">さまざまな実装に &lt;code&gt;gamma&lt;/code&gt; という名前の非標準関数がありますが、その定義には一貫性がありません。たとえば、glibcと4.2BSDバージョンの &lt;code&gt;gamma&lt;/code&gt; は &lt;code&gt;lgamma&lt;/code&gt; を実行しますが、4.4BSDバージョンの &lt;code&gt;gamma&lt;/code&gt; は &lt;code&gt;tgamma&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="b9f50508274427b995c9b808fe7d2253e68aed64" translate="yes" xml:space="preserve">
          <source>There is a single total order S on all &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, including fences, that satisfies the following constraints:</source>
          <target state="translated">すべての &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作（フェンスを含む）には、次の制約を満たす単一の合計順序Sがあります。</target>
        </trans-unit>
        <trans-unit id="d4002dc28152d428b1e9f887a2afb18cb864b3ff" translate="yes" xml:space="preserve">
          <source>There is a special case for a zero-length array (&lt;code&gt;N == 0&lt;/code&gt;). In that case, &lt;code&gt;array.begin() == array.end()&lt;/code&gt;, which is some unique value. The effect of calling &lt;code&gt;front()&lt;/code&gt; or &lt;code&gt;back()&lt;/code&gt; on a zero-sized array is undefined.</source>
          <target state="translated">長さがゼロの配列（ &lt;code&gt;N == 0&lt;/code&gt; ）には特別なケースがあります。その場合、 &lt;code&gt;array.begin() == array.end()&lt;/code&gt; 、これはいくつかのユニークな値です。サイズがゼロの配列での &lt;code&gt;front()&lt;/code&gt; または &lt;code&gt;back()&lt;/code&gt; の呼び出しの影響は定義されていません。</target>
        </trans-unit>
        <trans-unit id="4c58212f0810e755496085c2333304612a8c9ba1" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</source>
          <target state="translated">配列型の左辺値と右辺値からポインタ型の右辺値&lt;a href=&quot;implicit_cast&quot;&gt;へ&lt;/a&gt;の暗黙的な変換があります。これは、配列の最初の要素へのポインタを構築します。この変換は、配列が予期されていないコンテキストで配列が表示される場合に常に使用されますが、ポインターは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="adb96efa8dd15697ca7b238b3ac30f5bc2029721" translate="yes" xml:space="preserve">
          <source>There is no &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; の配列形式と非配列形式から取得したポインターを区別することができないため、ポインター型からの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;クラステンプレート引数の推定&lt;/a&gt;はありません。</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">等号演算子 &lt;code&gt;==&lt;/code&gt; の代替スペル（ &lt;code&gt;eq&lt;/code&gt; など）はありません。サポートされているすべての文字セットに &lt;code&gt;=&lt;/code&gt; が含まれているためです。</target>
        </trans-unit>
        <trans-unit id="6359bb2da55b35e94c9ad0b9d3423bdf850ab557" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the same &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; instance will be referred to by all evaluations of the typeid expression on the same type, although &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; of those type_info objects would be identical, as would be their &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">同じ &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; インスタンスが同じタイプのtypeid式のすべての評価によって参照されるという保証はありませんが、これらのtype_infoオブジェクトの &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; は、それらのstdと同様に同じです &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46c70b420b1fd4cd4eb814c6e21ea48fec268ba0" translate="yes" xml:space="preserve">
          <source>There is no move constructor: moving from an object derived from &lt;code&gt;shared_from_this&lt;/code&gt; does not transfer its shared identity.</source>
          <target state="translated">移動コンストラクターはありません &lt;code&gt;shared_from_this&lt;/code&gt; から派生したオブジェクトから移動しても、共有IDは転送されません。</target>
        </trans-unit>
        <trans-unit id="c081f6007cfe842825dd149d42264efa0313278f" translate="yes" xml:space="preserve">
          <source>There is no non-member function equivalent of this static member constant because non-member functions take pointers to atomic types, and therefore aren't as useful in &lt;a href=&quot;../../language/constant_expression&quot;&gt;constant expressions&lt;/a&gt;.</source>
          <target state="translated">非メンバー関数はアトミック型へのポインターを取るため、&lt;a href=&quot;../../language/constant_expression&quot;&gt;定数式&lt;/a&gt;ではあまり役に立たないため、この静的メンバー定数に相当する非メンバー関数はありません。</target>
        </trans-unit>
        <trans-unit id="b70d83494235e850b17f2e48a3299bb098ff2e94" translate="yes" xml:space="preserve">
          <source>There is no portable way to define primary sort key in terms of &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; since the conversion from the collation key returned by &lt;code&gt;std::collate::transform()&lt;/code&gt; to the primary equivalence key is locale-specific, and if the user replaces the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet, that conversion is no longer known to the standard library's &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt;. Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return an empty string unless the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet), in which case &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion.</source>
          <target state="translated">&lt;code&gt;std::collate::transform()&lt;/code&gt; によって返された照合キーから主等価キーへの変換はロケール固有であり、ユーザーが置き換えた場合、 &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; ソートキーをstd :: localeの観点から定義するポータブルな方法はありません。 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ファセットが、その変換はもはや標準ライブラリのに知られていない &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 標準ライブラリの特殊化は、現在組み込まれているロケールの &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ファセットがユーザーによって置き換えられず、システム提供の &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ファセットと一致しない限り、空の文字列を返します。この場合、 &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; &amp;lt;charT&amp;gt; :: transform（first、last） が実行され、それが生成するソートキーが、ロケール固有の変換を使用して、予想される主ソートキーに変換されます。</target>
        </trans-unit>
        <trans-unit id="3f7acf604b21fa7efd6ebb9fae0bd32cd0e76516" translate="yes" xml:space="preserve">
          <source>There is no separate tag for &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIteratorに&lt;/a&gt;個別のタグはありません。</target>
        </trans-unit>
        <trans-unit id="cb42e4a03c1413932f97ef53ea3df59cf6f0618f" translate="yes" xml:space="preserve">
          <source>There is no specialization for C strings. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</source>
          <target state="translated">C文字列の特殊化はありません。 &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; は、ポインタの値（メモリアドレス）のハッシュを生成します。文字配列の内容は調べません。</target>
        </trans-unit>
        <trans-unit id="932b5b0c5bba8ae4965a8c49c5fcc30eedb86b32" translate="yes" xml:space="preserve">
          <source>There is no standard-compliant way for the user to construct a &lt;code&gt;future_error&lt;/code&gt; prior to C++17. C++11 and C++14 depict an exposition-only public constructor taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, and some implementations provide such a constructor.</source>
          <target state="translated">ユーザーがC ++ 17より前に &lt;code&gt;future_error&lt;/code&gt; を作成するための標準準拠の方法はありません。C ++ 11とC ++ 14は、 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; を取る説明専用のパブリックコンストラクターを示しており、一部の実装ではそのようなコンストラクターを提供しています。</target>
        </trans-unit>
        <trans-unit id="1a76b382fdb365f1f430efc3fd3ffef21f74d56b" translate="yes" xml:space="preserve">
          <source>There is no way to explicitly specify template arguments to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;, &lt;a href=&quot;cast_operator&quot;&gt;conversion functions&lt;/a&gt;, and constructors, because they are called without the use of the function name.</source>
          <target state="translated">関数名を使用せずに呼び出されるため、&lt;a href=&quot;operators&quot;&gt;オーバーロードされた演算子&lt;/a&gt;、&lt;a href=&quot;cast_operator&quot;&gt;変換関数&lt;/a&gt;、コンストラクターにテンプレート引数を明示的に指定する方法はありません。</target>
        </trans-unit>
        <trans-unit id="cfe1eeb34c7bedb3e0ea6d678c0bd6012a61623b" translate="yes" xml:space="preserve">
          <source>There is one exception: an erasure which deletes the last element of a &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">例外が1つあります &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 最後の要素を削除する消去です。</target>
        </trans-unit>
        <trans-unit id="341db5eb1053e74392cf71602cdbdbaadad998bb" translate="yes" xml:space="preserve">
          <source>There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said</source>
          <target state="translated">cv-qualifier の制限の増加順による部分的な順序付けがあります.型は,次のように言うことができます.</target>
        </trans-unit>
        <trans-unit id="89bd5d5858a6e7136749a6ba025c5ec9f6ed276d" translate="yes" xml:space="preserve">
          <source>There's no way to access the time zone pointer when &lt;code&gt;TimeZonePtr&lt;/code&gt; is a move-only type.</source>
          <target state="translated">&lt;code&gt;TimeZonePtr&lt;/code&gt; が移動のみのタイプの場合、タイムゾーンポインターにアクセスする方法はありません。</target>
        </trans-unit>
        <trans-unit id="e85687808f760523e3241d93ae510041ac781f16" translate="yes" xml:space="preserve">
          <source>Therefore, private members can be transferred to implementation as-is, and push_back can forward to an implementation that does not use T in the interface either:</source>
          <target state="translated">そのため、プライベートメンバはそのまま実装に転送することができ、push_backはインターフェイスでもTを使わない実装に転送することができます。</target>
        </trans-unit>
        <trans-unit id="99d6d9ce6d1c6685dc210a906c540e2a567fe084" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;演繹ガイド&lt;/a&gt;は、unordered_mapがイテレーター範囲（オーバーロード（1,3-5））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,6-8））からの演繹を可能にするために提供されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、どちらも &lt;code&gt;Hash&lt;/code&gt; も &lt;code&gt;Pred&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、および &lt;code&gt;Hash&lt;/code&gt; 整数型ではありません。</target>
        </trans-unit>
        <trans-unit id="d838aa17089c69886e8a6da521887bdae3d66e6e" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;演繹ガイド&lt;/a&gt;は、unordered_multimapがイテレーター範囲（オーバーロード（1,3-5））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,6-8））からの演繹を可能にするために提供されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、どちらも &lt;code&gt;Hash&lt;/code&gt; も &lt;code&gt;Pred&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、および &lt;code&gt;Hash&lt;/code&gt; 整数型ではありません。</target>
        </trans-unit>
        <trans-unit id="71a2bff7b98f49c9c4e24066b486d0981c520060" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;code&gt;Allocator&lt;/code&gt;, &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (3), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイドを&lt;/a&gt;するために設けられている &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; コンテナタイプ（過負荷（1,3））下にあるからとイテレータ範囲（過負荷（2））からの控除を許可する場合、この過のみオーバーロード解決に関与 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たします&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータは&lt;/a&gt;、 &lt;code&gt;Comp&lt;/code&gt; 満足していない &lt;code&gt;Allocator&lt;/code&gt; 、 &lt;code&gt;Container&lt;/code&gt; ない満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータを&lt;/a&gt;、過負荷（3）のために、そして場合 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e10d57340ef11936ebd04620951a44a41b981f3" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ために提供されており、暗黙的な控除ガイドで見逃されたエッジケースを説明します。</target>
        </trans-unit>
        <trans-unit id="12b353145b514386eb3d03070811d07e0bad084c" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; に提供され、暗黙的な控除ガイドで見逃されたエッジケース、特にコピー不可能な引数と配列からポインターへの変換を説明します。</target>
        </trans-unit>
        <trans-unit id="0d7729eb7a1438721d7721c8ec45ca17c31eb830" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、反復子の範囲（オーバーロード（1,3））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,4））からの控除を可能にするマルチセット用に提供されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; の満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たし&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、そして &lt;code&gt;Comp&lt;/code&gt; ありません満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70a6bdbef179c3a4732cac088b62e8b6f4ff8948" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、基になるコンテナータイプからの控除を可能にするキュー用に提供されています。場合には、このオーバーロードは、オーバーロード解決に関与する &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、及び &lt;code&gt;Container&lt;/code&gt; ない満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;場合、及び、過負荷のために（2） &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d564ca21e1c30be4928dd9500b875ed1d963057" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for set to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレーター範囲（オーバーロード（1,3））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,4））からの控除を可能にするために設定されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; の満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たし&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、そして &lt;code&gt;Comp&lt;/code&gt; ありません満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13ef785aba459afe56d345cd56062fe469f5d0da" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、基になるコンテナータイプからの控除を可能にするスタック用に提供されています。場合には、このオーバーロードは、オーバーロード解決に関与する &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、及び &lt;code&gt;Container&lt;/code&gt; ない満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;場合、及び、過負荷のために（2） &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dafdd32c659086dffb3edda268826ae9c158e33" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、unordered_multisetに対して提供され、イテレーター範囲（オーバーロード（1,3,4））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,5.6））からの控除を可能にします。場合は、このオーバーロードはオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、どちらも &lt;code&gt;Hash&lt;/code&gt; も &lt;code&gt;Pred&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータは&lt;/a&gt;、 &lt;code&gt;Hash&lt;/code&gt; 整数型ではありません。</target>
        </trans-unit>
        <trans-unit id="9bb6043ae0763bf108698a03aeb652cc5820df07" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">これらの&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、unordered_setに対して提供され、イテレーターの範囲（オーバーロード（1,3,4））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,5.6））からの控除を可能にします。場合は、このオーバーロードはオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、どちらも &lt;code&gt;Hash&lt;/code&gt; も &lt;code&gt;Pred&lt;/code&gt; 満足&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータは&lt;/a&gt;、 &lt;code&gt;Hash&lt;/code&gt; 整数型ではありません。</target>
        </trans-unit>
        <trans-unit id="998a40ef4627e5e01e4248114651ccad38e51377" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;operator/&lt;/code&gt; overloads provide a conventional syntax for the creation of Gregorian calendar dates.</source>
          <target state="translated">これらの &lt;code&gt;operator/&lt;/code&gt; オーバーロードは、グレゴリオ暦の日付を作成するための従来の構文を提供します。</target>
        </trans-unit>
        <trans-unit id="74e2c10444921183c350121d5ff7c2b2d260e16b" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used with associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable).</source>
          <target state="translated">これらのアルゴリズムは、 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; などの連想コンテナでは使用できません。ForwardItはMoveAssignableタイプを逆参照しないためです（これらのコンテナのキーは変更できません）。</target>
        </trans-unit>
        <trans-unit id="dc6f538fd8e7e831a029d42e6c3295c5ce6547d3" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">これらは、標準で定義されているディレクティブです。標準は他のディレクティブの動作を定義していません。それらは無視されるか、いくつかの有用な意味を持つか、またはコンパイル時エラーを引き起こす可能性があります。それ以外の場合は無視されますが、プリプロセッサが完了すると、ソースコードから削除されます。一般的な非標準の拡張機能は、 &lt;code&gt;#warning&lt;/code&gt; ディレクティブで、コンパイル中にユーザー定義のメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="ec4ebc2b939ff4d66f10267f6f032b0dd31634b9" translate="yes" xml:space="preserve">
          <source>These are type categories defined by the core language. They are included here as named requirements only for consistency.</source>
          <target state="translated">これらはコア言語で定義された型カテゴリです。ここでは、一貫性を保つためだけに、名前付きの要件として挙げています。</target>
        </trans-unit>
        <trans-unit id="41f69a0ad4c5384189f3c5f07ef1de6088dafb43" translate="yes" xml:space="preserve">
          <source>These attributes may be applied to labels and statements (other than declaration-statements). They may not be simultaneously applied to the same label or statement.</source>
          <target state="translated">これらの属性は、ラベルと文(宣言文以外)に適用することができます。これらの属性は、同じラベルやステートメントに同時に適用することはできません。</target>
        </trans-unit>
        <trans-unit id="f1b3468a96579cdd8f43ddee81097dc1e729403b" translate="yes" xml:space="preserve">
          <source>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via &lt;code&gt;unsigned char&lt;/code&gt;). See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;core issue 2051&lt;/a&gt;.</source>
          <target state="translated">これらの箇条書きは、C ++では起こり得ない状況を説明しているため、上記の説明では省略されています。Cでは、集合コピーと割り当ては集合オブジェクト全体にアクセスします。ただし、C ++では、このようなアクションは常にメンバー関数呼び出しを通じて実行され、オブジェクト全体ではなく個々のサブオブジェクトにアクセスします（または、共用体の場合は、 &lt;code&gt;unsigned char&lt;/code&gt; を介してオブジェクト表現をコピーします）。&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;コア問題2051を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e2e85ea89bf8851056faa66c86c8a89f763163c" translate="yes" xml:space="preserve">
          <source>These classes encapsulate a regular expression and the results of matching a regular expression within a target sequence of characters.</source>
          <target state="translated">これらのクラスは、正規表現と、対象となる文字列の中で正規表現をマッチさせた結果をカプセル化しています。</target>
        </trans-unit>
        <trans-unit id="5187a740adf841afb17f5f37d5efc0eafaa7fbe7" translate="yes" xml:space="preserve">
          <source>These constants are duplicated from &lt;code&gt;std::regex_constants&lt;/code&gt;:</source>
          <target state="translated">これらの定数は &lt;code&gt;std::regex_constants&lt;/code&gt; から複製されます：</target>
        </trans-unit>
        <trans-unit id="19ba3734849d9efa52a071b6c74031883732795a" translate="yes" xml:space="preserve">
          <source>These constants provide a portable way to access the L1 data cache line size.</source>
          <target state="translated">これらの定数は、L1 データキャッシュのラインサイズにアクセスするためのポータブルな方法を提供します。</target>
        </trans-unit>
        <trans-unit id="5aeef84fd68b04dfd62540295b4e58ffbc1ad7c5" translate="yes" xml:space="preserve">
          <source>These constructors additionally do not participate in overload resolution if the expression &lt;code&gt;d(ptr)&lt;/code&gt; is not well-formed, or if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">さらに、これらのコンストラクターは、式 &lt;code&gt;d(ptr)&lt;/code&gt; が整形式でない場合、または &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、オーバーロード解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="2cd12e66c1b571e2605eacf313edfc5ca3855042" translate="yes" xml:space="preserve">
          <source>These constructors are typically called by the constructors of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらのコンストラクターは、通常、 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; コンストラクターによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7ee89583b6197fe5f3d8e0eab3b74e26c4d4069c" translate="yes" xml:space="preserve">
          <source>These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of &lt;code&gt;lexically_relative&lt;/code&gt; and &lt;code&gt;lexically_proximate&lt;/code&gt;, see &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;proximate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これらの変換は純粋に字句です。それらはパスが存在することをチェックせず、シンボリックリンクをたどらず、ファイルシステムにまったくアクセスしません。 &lt;code&gt;lexically_relative&lt;/code&gt; および &lt;code&gt;lexically_proximate&lt;/code&gt; の対応するシンボリックリンクについては、&lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;proximate&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3b066eecc1428c4afc05b8473b0ce8b6682781dc" translate="yes" xml:space="preserve">
          <source>These conversions model the type conversion applied to all function arguments when passed by value.</source>
          <target state="translated">これらの変換は,値で渡されたときにすべての関数引数に適用される型変換をモデル化します。</target>
        </trans-unit>
        <trans-unit id="1f828b6e7c5612d3683245cf9a5d3fa76a3dbee3" translate="yes" xml:space="preserve">
          <source>These fictional constructors are public members of the hypothetical class type. They are explicit if the guide was formed from an explicit constructor. If overload resolution fails, the program is ill-formed. Otherwise, the return type of the selected &lt;code&gt;F&lt;/code&gt; template specialization becomes the deduced class template specialization.</source>
          <target state="translated">これらの架空のコンストラクターは、架空のクラス型のパブリックメンバーです。ガイドが明示的なコンストラクターから形成された場合、それらは明示的です。過負荷の解決に失敗した場合、プログラムの形式が正しくありません。それ以外の場合、選択した &lt;code&gt;F&lt;/code&gt; テンプレート特殊化の戻り値の型は、推定クラステンプレート特殊化になります。</target>
        </trans-unit>
        <trans-unit id="9e1185e2ec5ad6dc826827fc0bc8b26aeb766d26" translate="yes" xml:space="preserve">
          <source>These function templates are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">これらの関数テンプレートは、通常の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; が引数の関連クラスである場合にのみ、&lt;a href=&quot;../../language/adl&quot;&gt;引数依存ルックアップで&lt;/a&gt;見つけることができます。これにより、 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; している場合に望ましくない変換が行われなくなります。</target>
        </trans-unit>
        <trans-unit id="043baecb502250e4140c666b26e06dd43b796356" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_sys&lt;/code&gt; and &lt;code&gt;from_sys&lt;/code&gt;.</source>
          <target state="translated">これらの関数テンプレートはオプションです。実装は、代わりに &lt;code&gt;to_sys&lt;/code&gt; および &lt;code&gt;from_sys&lt;/code&gt; を提供することを選択できます。</target>
        </trans-unit>
        <trans-unit id="f7805c9adadba15da9ce1789282d1fdeae7db0ab" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_utc&lt;/code&gt; and &lt;code&gt;from_utc&lt;/code&gt;.</source>
          <target state="translated">これらの関数テンプレートはオプションです。実装は、代わりに &lt;code&gt;to_utc&lt;/code&gt; および &lt;code&gt;from_utc&lt;/code&gt; を提供することを選択できます。</target>
        </trans-unit>
        <trans-unit id="7487a9c951b04abd0ea64aae0657bd6c80e75211" translate="yes" xml:space="preserve">
          <source>These function templates behave as if they.</source>
          <target state="translated">これらの関数テンプレートは、あたかもそれらがあるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="419d5c3b82807fda6edd67b01bc6da49f1a27023" translate="yes" xml:space="preserve">
          <source>These functions are defined in terms of member functions of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">これらの関数は、 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; メンバー関数の観点から定義されています。</target>
        </trans-unit>
        <trans-unit id="706bfb2aebd27a90d3a3878dfe394992ff31ffb1" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">これらの関数は、通常の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; が引数の関連クラスである場合にのみ、&lt;a href=&quot;../../language/adl&quot;&gt;引数依存ルックアップで&lt;/a&gt;見つけることができます。これにより、 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; している場合に望ましくない変換が行われなくなります。</target>
        </trans-unit>
        <trans-unit id="2f3e6ab375e463f1612d61a87d214ea836c037d5" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">これらの関数は、通常の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; が引数の関連クラスである場合に、引数&lt;a href=&quot;../../language/adl&quot;&gt;依存ルックアップで&lt;/a&gt;のみ見つけることができます。</target>
        </trans-unit>
        <trans-unit id="71d3bc1bc9cc67bb93448628acb0478629973b75" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">これらの関数は、通常の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; が引数の関連クラスである場合に、引数&lt;a href=&quot;../../language/adl&quot;&gt;依存ルックアップで&lt;/a&gt;のみ見つけることができます。</target>
        </trans-unit>
        <trans-unit id="9cafa0c4c816e506567effd571a10a76ae52acd3" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">これらの関数は、通常の&lt;a href=&quot;../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; が引数の関連クラスである場合にのみ、&lt;a href=&quot;../language/adl&quot;&gt;引数依存ルックアップで&lt;/a&gt;見つけることができます。</target>
        </trans-unit>
        <trans-unit id="13ae74af435260e5a8fc58a9b3b8f8b649c48761" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">これらの関数は、通常の&lt;a href=&quot;../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; が引数の関連クラスである場合に、引数&lt;a href=&quot;../language/adl&quot;&gt;依存ルックアップで&lt;/a&gt;のみ見つけることができます。</target>
        </trans-unit>
        <trans-unit id="96489aaabbabce3adba15d3840295fb8191f8911" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;span&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;span&lt;/code&gt; 右辺値が &lt;code&gt;std::ranges::begin&lt;/code&gt; および &lt;code&gt;std::ranges::end&lt;/code&gt; で機能するように提供されており、反復子のぶら下がりを防ぐためにデフォルトで右辺値引数を拒否します。</target>
        </trans-unit>
        <trans-unit id="5f45f69461ef9381b69148d33ccefcd3eafb9116" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;string_view&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;string_view&lt;/code&gt; 右辺値が &lt;code&gt;std::ranges::begin&lt;/code&gt; および &lt;code&gt;std::ranges::end&lt;/code&gt; で動作するようにするために提供され、イテレータのぶら下がりを防ぐためにデフォルトで右辺値引数を拒否します。</target>
        </trans-unit>
        <trans-unit id="be2ae68f22369098426dd815dea838deb2f9b140" translate="yes" xml:space="preserve">
          <source>These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.</source>
          <target state="translated">これらの関数は通常、ポインタの値がキーとして使用されるグローバルハッシュテーブルに格納されたミューテックスを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="326f105b45787866cfe222f982d0d9e27243f9ff" translate="yes" xml:space="preserve">
          <source>These functions are used to apply the regular expression encapsulated in a regex to a target sequence of characters.</source>
          <target state="translated">これらの関数は、正規表現でカプセル化された正規表現を対象の文字列に適用するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7585335f42669921d2b1bf3e543316f127948a1e" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid or if there is a size mismatch. Specifically:</source>
          <target state="translated">これらの関数は、必要な代入操作が無効な場合やサイズの不一致があった場合、過負荷解決には参加しません(コピー代入演算子の場合はdeletedと定義されます)。具体的には</target>
        </trans-unit>
        <trans-unit id="d30d68da83412d7ae98ce606334319e3d70b73d8" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid. Specifically:</source>
          <target state="translated">これらの関数は、必要な代入操作が無効な場合、過負荷解決には参加しない(コピー代入演算子の場合は削除と定義される)。具体的には</target>
        </trans-unit>
        <trans-unit id="cafe750e84a77bd66ed9b0e48c90443f0b94fd28" translate="yes" xml:space="preserve">
          <source>These functions do not throw exceptions.</source>
          <target state="translated">これらの関数は例外をスローしません。</target>
        </trans-unit>
        <trans-unit id="6ee20f7717337989ef84b3eb0d3af4c0f3efbcb1" translate="yes" xml:space="preserve">
          <source>These functions effectively yield an approximation of the meaning of the argument path &lt;code&gt;p&lt;/code&gt; in an environment where &lt;code&gt;*this&lt;/code&gt; is the starting directory.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;*this&lt;/code&gt; が開始ディレクトリである環境で、引数パス &lt;code&gt;p&lt;/code&gt; の意味の近似を効果的に生成します。</target>
        </trans-unit>
        <trans-unit id="b7da2559e16d851f64895f9b8ce4e64008d143d3" translate="yes" xml:space="preserve">
          <source>These functions provide access to the program-wide time zone database.</source>
          <target state="translated">これらの機能は、プログラム全体のタイムゾーンデータベースへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="e5ab52d07da85043f4b5804364445cb1d17fd3ed" translate="yes" xml:space="preserve">
          <source>These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.</source>
          <target state="translated">これらの関数は,3 者間比較の結果を取り,6 つの関係演算子のいずれかの結果に変換します.</target>
        </trans-unit>
        <trans-unit id="09dc533f744ccd968da17e107b1a623a70147eb2" translate="yes" xml:space="preserve">
          <source>These functions were deprecated in favor of the specializations of the &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; template: &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; テンプレートの特殊化のために廃止されました： &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8ebef2701474b9ea6a2624b079221ae9fed097b" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">これらのハッシュは、対応する &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; クラスのハッシュと同じです。Sが標準的なbasic_stringタイプの1つである場合、SVは対応する文字列ビュータイプであり、sはSタイプのオブジェクトであり、次に &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04c0518ba136c51c78f2d27b7888f66813a53b9f" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; classes: If S is one of these string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">これらのハッシュは、対応する &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; クラスのハッシュに等しい：Sがこれらの文字列型の1つである場合、SVは対応する文字列ビュー型であり、sはS型のオブジェクトであり、次に &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="378bbcb4a72a73dada77e96ee58fc0765cdcf81d" translate="yes" xml:space="preserve">
          <source>These headers are allowed to also declare the same names in the &lt;code&gt;std&lt;/code&gt; namespace, and the corresponding &lt;code&gt;cxxx&lt;/code&gt; headers are allowed to also declare the same names in the global namespace: including &amp;lt;cstdlib&amp;gt; definitely provides &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; and may also provide &lt;code&gt;::malloc&lt;/code&gt;. Including &amp;lt;stdlib.h&amp;gt; definitely provides &lt;code&gt;::malloc&lt;/code&gt; and may also provide &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;. This applies even to functions and function overloads that are not part of C standard library.</source>
          <target state="translated">これらのヘッダーは、 &lt;code&gt;std&lt;/code&gt; 名前空間で同じ名前を宣言することもでき、対応する &lt;code&gt;cxxx&lt;/code&gt; ヘッダーは、グローバル名前空間で同じ名前を宣言することもできます。&amp;lt;cstdlib&amp;gt;を含めると、確実に &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; が提供され、 &lt;code&gt;::malloc&lt;/code&gt; も提供される場合があります。。&amp;lt;stdlib.h&amp;gt;をインクルードすると、確実に &lt;code&gt;::malloc&lt;/code&gt; が提供され、 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; も提供される場合があります。これは、C標準ライブラリの一部ではない関数と関数オーバーロードにも適用されます。</target>
        </trans-unit>
        <trans-unit id="9c301ca8ee91cc2dc03b93b934d87b55d872e6ac" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらのメンバー型は、 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; から継承して取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="269f91543a7d747d3318687896f196744a919ccf" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらの部材の種類は継承することによって得ることが要求される &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b52b486a05c84f8a4581d34abd369500f9977646" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらのメンバータイプは、 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt; から継承して取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="a01f1d5ca0fbf0d6be5d6ec44fedf3a57f36c70d" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらのメンバータイプは、 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt; から継承して取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae3da083cb674670645135b104ff6e1e31af7384" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらのメンバー型は、 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; から継承して取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="6dd91df6ca3cc382c9fe0e450bbf5c087b01c8bc" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">これらの非メンバー関数により、範囲ベースのforループで &lt;code&gt;directory_iterator&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="d44ff77d7541183f5d7e43423582626b5049a546" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;recursive_directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">これらの非メンバー関数により、範囲ベースのforループで &lt;code&gt;recursive_directory_iterator&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="f216125f2ad7bca05acbed754c42e867a1a09cab" translate="yes" xml:space="preserve">
          <source>These non-member functions provide a generic interface for containers, plain arrays, and &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの非メンバー関数は、コンテナー、プレーン配列、および &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 汎用インターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="b6245e0fb4125a31e0f987895270819c57ced919" translate="yes" xml:space="preserve">
          <source>These objects are guaranteed to be initialized during or before the first time an object of type &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; is constructed and are available for use in the constructors and destructors of static objects with &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is included before the object is defined).</source>
          <target state="translated">これらのオブジェクトは、タイプ &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; オブジェクトが最初に構築されるときまたはその前に初期化されることが保証され、&lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;順序付けされた初期化を&lt;/a&gt;持つ静的オブジェクトのコンストラクターおよびデストラクタで使用できます（ &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; がオブジェクトが定義される前に含まれます）。</target>
        </trans-unit>
        <trans-unit id="e1ea5b16593fd62c406fa74578d8a51e69297d84" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">これらの演算子は、名前空間で宣言されている &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; 両方、 &lt;code&gt;literals&lt;/code&gt; と &lt;code&gt;chrono_literals&lt;/code&gt; はインライン名前空間です。これらの演算子へのアクセスは、 &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 、および名前空間std :: literals :: chrono_literalsの &lt;code&gt;using namespace std::literals&lt;/code&gt; により得ることができます。</target>
        </trans-unit>
        <trans-unit id="c775ca0f064f8efbb0eebd72489c895fca0cd5d9" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::complex_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;complex_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::complex_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt;.</source>
          <target state="translated">これらの演算子は、名前空間で宣言されている &lt;code&gt;std::literals::complex_literals&lt;/code&gt; 両方、 &lt;code&gt;literals&lt;/code&gt; と &lt;code&gt;complex_literals&lt;/code&gt; はインライン名前空間です。これらの演算子へのアクセスは、 &lt;code&gt;using namespace std::complex_literals&lt;/code&gt; &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt; 、および名前空間std :: literals :: complex_literalsの &lt;code&gt;using namespace std::literals&lt;/code&gt; によって得ることができます。</target>
        </trans-unit>
        <trans-unit id="23ceae8d0ac1ad1f53f34bde5fef4212a07b1d5a" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt;.</source>
          <target state="translated">これらの演算子は、名前空間で宣言されている &lt;code&gt;std::literals::string_literals&lt;/code&gt; 両方、 &lt;code&gt;literals&lt;/code&gt; と &lt;code&gt;string_literals&lt;/code&gt; はインライン名前空間です。これらの演算子へのアクセスは、 &lt;code&gt;using namespace std::string_literals&lt;/code&gt; &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt; 、および名前空間std :: literals :: string_literalsの &lt;code&gt;using namespace std::literals&lt;/code&gt; により得ることができます。</target>
        </trans-unit>
        <trans-unit id="37f431af515778abb156bc8a341491c98c563acc" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_view_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_view_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt;.</source>
          <target state="translated">これらの演算子は、名前空間で宣言されている &lt;code&gt;std::literals::string_view_literals&lt;/code&gt; 両方、 &lt;code&gt;literals&lt;/code&gt; と &lt;code&gt;string_view_literals&lt;/code&gt; はインライン名前空間です。これらの演算子へのアクセスは、 &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt; &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt; 、および名前空間std :: literals :: string_view_literalsの &lt;code&gt;using namespace std::literals&lt;/code&gt; によって得ることができます。</target>
        </trans-unit>
        <trans-unit id="be85bd7cbe4be2517bbbe6791661ad5c07a4cbe3" translate="yes" xml:space="preserve">
          <source>These operators are sometimes implemented as &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;.</source>
          <target state="translated">これらの演算子は、&lt;a href=&quot;friend&quot;&gt;フレンド関数&lt;/a&gt;として実装される場合があります。</target>
        </trans-unit>
        <trans-unit id="71b614f00aac3b3aedb1ef8cf1ee4d989be39411" translate="yes" xml:space="preserve">
          <source>These operators were not &lt;code&gt;constexpr&lt;/code&gt; in C++11, this was corrected in C++14.</source>
          <target state="translated">これらの演算子はC ++ 11では &lt;code&gt;constexpr&lt;/code&gt; ではなく、C ++ 14で修正されました。</target>
        </trans-unit>
        <trans-unit id="86bd9326b779710e8e7e30da617be0d3ac76c4df" translate="yes" xml:space="preserve">
          <source>These overloads do not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">これらのオーバーロードは、以下の条件を満たさない限り、オーバーロードの解決には参加しません。</target>
        </trans-unit>
        <trans-unit id="e48cfeb3277137050ec5b9718b8d37fe7f54cb7e" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type.</source>
          <target state="translated">これらのオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;Deleter&lt;/code&gt; がポインター型でない場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="88f134a2bed08d434e838bcdda34ccb397f8eca8" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if the corresponding &lt;code&gt;from_stream&lt;/code&gt; expression is well-formed.</source>
          <target state="translated">これらのオーバーロードは、対応する &lt;code&gt;from_stream&lt;/code&gt; 式が整形式である場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="a2d116b1f38656e4ef14e8e4c82c85d94f84a468" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if.</source>
          <target state="translated">これらのオーバーロードは、以下の場合にのみオーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="78f7dc8ed866031cd5d45fb8e30c10dc7cab0d38" translate="yes" xml:space="preserve">
          <source>These pair-wise comparisons are applied to all viable functions. If exactly one viable function is better than all others, overload resolution succeeds and this function is called. Otherwise, compilation fails.</source>
          <target state="translated">これらのペア比較は,すべての実行可能な関数に適用されます.1つの実行可能な関数が他のすべての関数よりも優れている場合、オーバーロードの解決に成功し、その関数が呼び出されます。そうでなければ,コンパイルは失敗します.</target>
        </trans-unit>
        <trans-unit id="87d3e33f926d43ebf3e0bc3d2ed5785d5f7e359f" translate="yes" xml:space="preserve">
          <source>These pointer arithmetic operators allow pointers to satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements.</source>
          <target state="translated">これらのポインター算術演算子により、ポインターは&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;要件を満たすことができます。</target>
        </trans-unit>
        <trans-unit id="91cc6d32c62a3af187353d24cb8355a046134850" translate="yes" xml:space="preserve">
          <source>These specializations make it possible to use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt;). To use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with other character types (for example, &lt;code&gt;char32_t&lt;/code&gt;), a user-provided trait class must be used.</source>
          <target state="translated">これらの特殊化により、 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; （別名 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; ）および &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; （別名 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt; ）を使用できるようになります。使用するに &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; （例えば、他の文字の種類と &lt;code&gt;char32_t&lt;/code&gt; を）、ユーザー提供の形質クラスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fb1d3f8496237287e2630d9516276eb8186eeef" translate="yes" xml:space="preserve">
          <source>These transformation traits were required</source>
          <target state="translated">これらの変換形質が必要とされました。</target>
        </trans-unit>
        <trans-unit id="25f1f4bdd72a09c080801d8fffb8ec4bf62a753c" translate="yes" xml:space="preserve">
          <source>These two alias templates are used by some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrained algorithms&lt;/a&gt; to avoid returning potentially dangling iterators or views.</source>
          <target state="translated">これらの2つのエイリアステンプレートは、潜在的にぶら下がっているイテレータまたはビューを返さないようにするために、いくつかの&lt;a href=&quot;../algorithm/ranges&quot;&gt;制約付きアルゴリズム&lt;/a&gt;によって使用されます。</target>
        </trans-unit>
        <trans-unit id="c7a8b1fbd19de341e5ad49bc78a2acbfda770aec" translate="yes" xml:space="preserve">
          <source>These type transformations honor reference collapse rules:</source>
          <target state="translated">これらの型変換は、参照崩しルールを尊重します。</target>
        </trans-unit>
        <trans-unit id="dbcace5dd757886bde993d55984f6189eef2a5ad" translate="yes" xml:space="preserve">
          <source>These values are constants, and do not reflect the changes to the rounding made by &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt;. The changed values may be obtained from &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの値は定数であり、 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; によって行われた丸めの変更を反映していません。変更された値は &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt; から取得できます。</target>
        </trans-unit>
        <trans-unit id="ce671f14cf50f53efd465a7781656ad990f4484e" translate="yes" xml:space="preserve">
          <source>They are commonly used as a convenient shortcut for long or deeply-nested namespaces.</source>
          <target state="translated">これらは、長い名前空間や深く入れ子になっている名前空間の便利なショートカットとして一般的に使用されています。</target>
        </trans-unit>
        <trans-unit id="0c8a84aed3ced580611d15354b0869a722fa11d7" translate="yes" xml:space="preserve">
          <source>They are used to specify locking strategies for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらは、 &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; ロック戦略を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="11cfa3f63f9b9843169a75987765b90b1df36aef" translate="yes" xml:space="preserve">
          <source>They can also be used to implement pass-by-reference semantics in function calls:</source>
          <target state="translated">また、関数呼び出しでの参照渡しセマンティクスの実装にも使用できます。</target>
        </trans-unit>
        <trans-unit id="404264233979032de1c13fb29f764da6094435a2" translate="yes" xml:space="preserve">
          <source>Third version</source>
          <target state="translated">第三版</target>
        </trans-unit>
        <trans-unit id="674677ba31e30e4e6af559bc6fc67687b54c0a70" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレータ範囲からの控除を可能にする &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; ために提供されています。</target>
        </trans-unit>
        <trans-unit id="4c01d9032d07a333deef547c5311682cb32b0369" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides).</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、配列とサイズからの控除を可能にする &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; ために提供されています（ポインターとサイズからの控除は、暗黙のガイドでカバーされていることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="080faae34fcef190f2de9f444682b5ad95d98c79" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、dequeがイテレーター範囲からの控除を可能にするために提供されています。このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;と &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a6452884a208e722e9625cf9199c504d50511f4" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、forward_listがイテレーター範囲からの控除を可能にするために提供されています。このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;と &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="491ded200502330a3077bffc8f20aba48e33a32f" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレータ範囲からの控除を可能にするためにリストに提供されています。このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;と &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d250c6703a67ce4010a480cdc0512de03c8d6af8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for map to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレーター範囲（オーバーロード（1,3））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,4））からの控除を可能にするためにマップに提供されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; の満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たし&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、そして &lt;code&gt;Comp&lt;/code&gt; ありません満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="472f8efb63db0b27b39e33719d752a5b58fa4ac0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレータ範囲（オーバーロード（1,3））および &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （オーバーロード（2,4））からの控除を可能にするマルチマップ用に提供されています。場合は、これらのオーバーロードが唯一のオーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; の満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;、 &lt;code&gt;Alloc&lt;/code&gt; 満たし&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;、そして &lt;code&gt;Comp&lt;/code&gt; ありません満たしてい&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="404371bbe2687bcdbddb8c17f22af8568b34d514" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;../../language/deduction_guide&quot;&gt;控除ガイド&lt;/a&gt;は、イテレーターの範囲からの控除を可能にするためにベクターに提供されています。このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;と &lt;code&gt;Alloc&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/allocator&quot;&gt;アロケータ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d19a67c2a590fb3edea166f3993c75495030081" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is only defined if the capture list of the lambda-expression is empty. It is a public, constexpr,(since C++17) non-virtual, non-explicit, const noexcept(since C++14) member function of the closure object. It is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator of the lambda is an immediate function.(since C++20).</source>
          <target state="translated">この&lt;a href=&quot;cast_operator&quot;&gt;ユーザー定義の変換関数&lt;/a&gt;は、ラムダ式のキャプチャリストが空の場合にのみ定義されます。これは、クロージャオブジェクトのパブリック、constexpr、（C ++ 17以降）非仮想、非明示的、const noexcept（C ++ 14以降）メンバー関数です。ラムダの関数呼び出し演算子が&lt;a href=&quot;consteval&quot;&gt;即時関数である&lt;/a&gt;場合、これは即時関数です（C ++ 20以降）。</target>
        </trans-unit>
        <trans-unit id="9dd4d9a7e5470c751564a0b43d9bb48488ca73ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; は、主にデバッグ用です。フォーマットを制御するには、 &lt;code&gt;std::chrono::format&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="bdeeb8bd8306a58bb3de2426d5fca261070137d1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. When used with non-default stream flags, the output may be surprising:</source>
          <target state="translated">この &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; は、主にデバッグ用です。デフォルト以外のストリームフラグと一緒に使用すると、出力が意外になる場合があります。</target>
        </trans-unit>
        <trans-unit id="45d5bafe4e82677bb34e8489531cf8b9395463b2" translate="yes" xml:space="preserve">
          <source>This algorithm is a more general form of &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt;, which can be expressed in terms of &lt;code&gt;std::partition_point&lt;/code&gt; with the predicate &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt;.</source>
          <target state="translated">このアルゴリズムは &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt; より一般的な形式であり、述語 &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt; 持つ &lt;code&gt;std::partition_point&lt;/code&gt; 観点から表現できます。}）; 。</target>
        </trans-unit>
        <trans-unit id="823f5a9d51f4a4e6c775e32f3efd9551b4b6ecbf" translate="yes" xml:space="preserve">
          <source>This algorithm is different from &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt;, not only in efficiency, but also in that this algorithm finds the</source>
          <target state="translated">このアルゴリズムは &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt; とは異なり、効率だけでなく、このアルゴリズムは</target>
        </trans-unit>
        <trans-unit id="25bb18b7071a3878825d2611ae20fefcf112dcd2" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce less.</source>
          <target state="translated">このアルゴリズムは、 &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; と同様のタスクを実行します。どちらも2つのソート済み入力範囲を使用し、両方の入力からの要素を使用してソート済み出力を生成します。これら2つのアルゴリズムの違いは、同等のものを比較する両方の入力範囲からの値を処理することです（&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;に関する注記を参照）。同等の値が最初の範囲で &lt;code&gt;n&lt;/code&gt; 回、2番目の範囲で &lt;code&gt;m&lt;/code&gt; 回出現した場合、 &lt;code&gt;std::merge&lt;/code&gt; はすべての &lt;code&gt;n+m&lt;/code&gt; のオカレンスを出力しますが、 &lt;code&gt;std::set_union&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; オカレンスのみを出力します。したがって、 &lt;code&gt;std::merge&lt;/code&gt; 正確に &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; （first1、last1）+を出力します&lt;a href=&quot;../iterator/distance&quot;&gt;std :: distance&lt;/a&gt;（first2、last2）の値と &lt;code&gt;std::set_union&lt;/code&gt; は、生成される量が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="7d29fc2206a5224dabc98e893d9a9b64464432d3" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce fewer.</source>
          <target state="translated">このアルゴリズムは、 &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; と同様のタスクを実行します。どちらも2つのソート済み入力範囲を使用し、両方の入力からの要素を使用してソート済み出力を生成します。これら2つのアルゴリズムの違いは、同等のものを比較する両方の入力範囲からの値を処理することです（&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;に関する注記を参照）。同等の値が最初の範囲で &lt;code&gt;n&lt;/code&gt; 回、2番目の範囲で &lt;code&gt;m&lt;/code&gt; 回出現した場合、 &lt;code&gt;std::merge&lt;/code&gt; はすべての &lt;code&gt;n+m&lt;/code&gt; のオカレンスを出力しますが、 &lt;code&gt;std::set_union&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; オカレンスのみを出力します。したがって、 &lt;code&gt;std::merge&lt;/code&gt; 正確に &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; （first1、last1）+を出力します&lt;a href=&quot;../iterator/distance&quot;&gt;std :: distance&lt;/a&gt;（first2、last2）の値と &lt;code&gt;std::set_union&lt;/code&gt; は、生成される数が少ない場合があります。</target>
        </trans-unit>
        <trans-unit id="67039572a7b1266afd41cb596fd8e9903073b309" translate="yes" xml:space="preserve">
          <source>This allows &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; operators, and other move-aware functions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt;) to be automatically selected when suitable.</source>
          <target state="translated">これにより、&lt;a href=&quot;move_constructor&quot;&gt;移動コンストラクター&lt;/a&gt;、&lt;a href=&quot;move_operator&quot;&gt;移動割り当て&lt;/a&gt;演算子、およびその他の移動対応関数（例： &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt; ）が適切なときに自動的に選択されます。</target>
        </trans-unit>
        <trans-unit id="6b23439395d3de2ec476135a3b042e5160bd72c2" translate="yes" xml:space="preserve">
          <source>This allows objects of small class types, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::span&lt;/code&gt;, to be passed to or returned from functions in registers.</source>
          <target state="translated">これにより、 &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;std::span&lt;/code&gt; などの小さなクラス型のオブジェクトを、レジスター内の関数に渡したり、関数から返したりすることができます。</target>
        </trans-unit>
        <trans-unit id="1ba1397263db3733d0fec3f4eee183f7dd40c32d" translate="yes" xml:space="preserve">
          <source>This also makes it possible to capture by const reference, with &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; or similar.</source>
          <target state="translated">これにより、 &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; などを使用して、const参照でキャプチャすることもできます。</target>
        </trans-unit>
        <trans-unit id="b270e0b13927c9c7d55e1dcef0f35f6860aa9231" translate="yes" xml:space="preserve">
          <source>This applies even to variants of non-class types:</source>
          <target state="translated">これは、非クラス型のバリアントにも適用されます。</target>
        </trans-unit>
        <trans-unit id="c7b69ba009614b0512956cea74a4d37944d632b2" translate="yes" xml:space="preserve">
          <source>This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.</source>
          <target state="translated">これはクラス・テンプレートのメンバに適用されます:そのメンバがプログラムで使用されない限り、インスタンス化されず、定義も必要ありません。</target>
        </trans-unit>
        <trans-unit id="afda8940351e810bc83ac7a0844c6ee697d190f3" translate="yes" xml:space="preserve">
          <source>This attribute applies to the name of the function being declared in function declarations only. The behavior is undefined if the function with this attribute actually returns.</source>
          <target state="translated">この属性は、関数宣言で宣言されている関数の名前にのみ適用されます。この属性を持つ関数が実際に戻ってきた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a6310c0c875c2cc4202df04650e9b8684a1ea09d" translate="yes" xml:space="preserve">
          <source>This attribute can appear in the declaration of the following entities:</source>
          <target state="translated">この属性は,次のエンティティの宣言に現れることができる。</target>
        </trans-unit>
        <trans-unit id="48e9f5d2fd561ba7f787f00554eb0339866d9697" translate="yes" xml:space="preserve">
          <source>This attribute is allowed in declarations of the following names or entities:</source>
          <target state="translated">この属性は、以下の名前または実体の宣言で許可されています。</target>
        </trans-unit>
        <trans-unit id="bc9a88af611a842f4ad52d91eb1d0dc9725b08e4" translate="yes" xml:space="preserve">
          <source>This attribute may appear in two situations:</source>
          <target state="translated">この属性は2つの状況で出現する可能性があります。</target>
        </trans-unit>
        <trans-unit id="492617afde39ac181a5c63ce324178dcbd2c9236" translate="yes" xml:space="preserve">
          <source>This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">この属性は、どのような変換ユニットでも、関数の最初の宣言またはそのパラメータの一つに現れなければなりません。他の翻訳ユニットにおける関数の最初の宣言、またはそのパラメータの一つに使用されていない場合、そのプログラムは不定形である。</target>
        </trans-unit>
        <trans-unit id="da819209a9e30721dffd50c194d372495640b66c" translate="yes" xml:space="preserve">
          <source>This class defines the type of objects thrown as exceptions to report errors from the regular expressions library.</source>
          <target state="translated">このクラスは、正規表現ライブラリからエラーを報告するための例外としてスローされるオブジェクトの型を定義します。</target>
        </trans-unit>
        <trans-unit id="d05fe9ff7a9efe7a6be4213effba38b5678ca3d8" translate="yes" xml:space="preserve">
          <source>This class is designed for use as key in associative containers, both ordered and unordered.</source>
          <target state="translated">このクラスは、連想コンテナのキーとして使用するために設計されています。</target>
        </trans-unit>
        <trans-unit id="c77922f02193571f4c08570b0423206a1a325b4d" translate="yes" xml:space="preserve">
          <source>This class is used to ensure that the default C++ streams (&lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.</source>
          <target state="translated">このクラスは、デフォルトのC ++ストリーム（ &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; など）が適切に初期化および破棄されるようにするために使用されます。このクラスは、そのインスタンスの作成数を追跡し、最初のインスタンスが構築されるときにC ++ストリームを初期化し、最後のインスタンスが破棄されるときに出力ストリームをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="4782fa86482a6f5000533d5566f5443e1b31c285" translate="yes" xml:space="preserve">
          <source>This class template is the preferred comparison predicate when building associative containers with &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as keys, that is,</source>
          <target state="translated">このクラステンプレートは、キーとして &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; を使用して連想コンテナーを構築する場合に推奨される比較述語です。</target>
        </trans-unit>
        <trans-unit id="d4129ee928b19fe777216b3fc0a11eb88a14da35" translate="yes" xml:space="preserve">
          <source>This class template makes the implicit character conversion functionality of &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; available for any &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このクラステンプレートにより、 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; の暗黙的な文字変換機能を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="67af0e94f21d7e3028f080552ccfa30f81f3903f" translate="yes" xml:space="preserve">
          <source>This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</source>
          <target state="translated">この分類により、テンプレート定義の時点(インスタンス化ではなく)で以下のようなエラーを検出することができます。</target>
        </trans-unit>
        <trans-unit id="58ce9513b35dc96e87c0d70ac154af849efb1443" translate="yes" xml:space="preserve">
          <source>This constructor does not participate in overload resolution if &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; と同じタイプの場合、このコンストラクターはオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="a905969e8e69e6e88d275ad307f8717581731297" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;InputIt&lt;/code&gt; が整数型の場合 &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="7a2d779c18396eab1ee0e06cc486a3335e7edd14" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;InputIt&lt;/code&gt; が整数型の場合 &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="11411ad8214fe6e6c7202887522fc136fe3e90db" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;InputIt&lt;/code&gt; が整数型の場合 &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="d0215f7826bd287562237b0c5f6bbd13fcaf0661" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;InputIt&lt;/code&gt; が整数型の場合 &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="16d9b8332d1923e6161015fdc9a2cff3bdfaa0b6" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;constexpr&lt;/code&gt; if every operation it performs is &lt;code&gt;constexpr&lt;/code&gt;. For the empty tuple &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt;, it is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;constexpr&lt;/code&gt; するすべての操作がconstexprである場合は &lt;code&gt;constexpr&lt;/code&gt; です。空のタプル &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt; 場合、それは &lt;code&gt;constexpr&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="39b96837fbee6ff8b11f2afbe55d19be8b5237f0" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、少なくとも1つの &lt;code&gt;i&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; &amp;lt;const Ti＆、Ti&amp;gt; :: valueが &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="533bf2fceb953a9339da3a3efe2403151289bf62" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;U &amp;amp;&amp;amp;、T&amp;gt;が &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="956eea7f4a03a0995417ca7671e86890da8c691a" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;U1 &amp;amp;&amp;amp;、first_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;U2 &amp;amp;&amp;amp;、second_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="00d14d163d5ca5d7a526cb55477d4d3d44718aa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;const U＆、T&amp;gt;が &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="703819705f083463e0d7af074684609042e9b532" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const U1＆、first_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const U2＆、second_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b2d388bc3de25d32e823ab3902c5cb2c7f0bb128" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const first_type＆、first_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const second_type＆、second_type&amp;gt;が &lt;code&gt;false&lt;/code&gt; の場合にのみ &lt;code&gt;explicit&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7c083a7d9073cd96386cc41c8aa08c4631002fa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if either &lt;code&gt;first_type&lt;/code&gt; or &lt;code&gt;second_type&lt;/code&gt; is not implicitly default-constructible.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;first_type&lt;/code&gt; または &lt;code&gt;second_type&lt;/code&gt; のいずれかが暗黙的にデフォルトで構築可能でない場合にのみ &lt;code&gt;explicit&lt;/code&gt; 的です。</target>
        </trans-unit>
        <trans-unit id="9e3f4b55350fb3f6d920bcec2b1f50c5260e2934" translate="yes" xml:space="preserve">
          <source>This constructor is ill-formed if &lt;code&gt;Deleter&lt;/code&gt; is of pointer or reference type.</source>
          <target state="translated">&lt;code&gt;Deleter&lt;/code&gt; がポインター型または参照型の場合、このコンストラクターの形式は正しくありません。</target>
        </trans-unit>
        <trans-unit id="8f4ffe9c6a9e19f1b0de1f70aa1c6912c5d13790" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">このコンストラクタは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6429d3c8a00cca9524476fd5e7bc85b284721fa1" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if all of the following is true:</source>
          <target state="translated">このコンストラクタは、以下のすべてが真の場合にのみオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="5189004f2798523a38b087278bd624f438a82960" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; がどちらも &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="4726fe3e137ecc9cfdc444c3524298098da680a8" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; 両方が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="b97d7fbb9211117804e8e5c015e20e35239347ae" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このコンストラクターは、 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; がどちらも &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="efe7ac6a6eaa86bb5c97cb1a9afabf3305f77bd2" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このコンストラクタは、 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; がどちらも &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="a9636e46cd99b7aa6a5346c674ec8170c547d2f3" translate="yes" xml:space="preserve">
          <source>This container is an aggregate type with the same semantics as a struct holding a &lt;a href=&quot;../language/array&quot;&gt;C-style array&lt;/a&gt;&lt;code&gt;T[N]&lt;/code&gt; as its only non-static data member. Unlike a C-style array, it doesn't decay to &lt;code&gt;T*&lt;/code&gt; automatically. As an aggregate type, it can be initialized with &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; given at most &lt;code&gt;N&lt;/code&gt; initializers that are convertible to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt;.</source>
          <target state="translated">このコンテナーは、&lt;a href=&quot;../language/array&quot;&gt;Cスタイルの配列&lt;/a&gt; &lt;code&gt;T[N]&lt;/code&gt; を唯一の非静的データメンバーとして保持する構造体と同じセマンティクスを持つ集計型です。Cスタイルの配列とは異なり、自動的に &lt;code&gt;T*&lt;/code&gt; 減衰しません。骨材の種類として、それがで初期化することができる&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;集約初期&lt;/a&gt;高々所与 &lt;code&gt;N&lt;/code&gt; に変換されイニシャライザ &lt;code&gt;T&lt;/code&gt; ： &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf0aa51a2fd1da025ddbd712b50083980038a0d" translate="yes" xml:space="preserve">
          <source>This conversion models the act of reading a value from a memory location into a CPU register.</source>
          <target state="translated">この変換は、メモリロケーションからCPUレジスタに値を読み出す動作をモデル化しています。</target>
        </trans-unit>
        <trans-unit id="486e8ea678d2260d566d72fdb476e2364e350e4a" translate="yes" xml:space="preserve">
          <source>This declaration may declare &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; and non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; and &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, member &lt;a href=&quot;typedef&quot;&gt;typedefs&lt;/a&gt;, member &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;nested_classes&quot;&gt;nested classes&lt;/a&gt;. It may also be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">この宣言では、&lt;a href=&quot;static&quot;&gt;静的&lt;/a&gt;および非静的&lt;a href=&quot;data_members&quot;&gt;データメンバー&lt;/a&gt;と&lt;a href=&quot;member_functions&quot;&gt;メンバー関数&lt;/a&gt;、メンバーの&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;、メンバーの&lt;a href=&quot;enum&quot;&gt;列挙&lt;/a&gt;、&lt;a href=&quot;nested_classes&quot;&gt;ネストされたクラスを&lt;/a&gt;宣言できます。&lt;a href=&quot;friend&quot;&gt;友達の宣言の&lt;/a&gt;場合もあります。</target>
        </trans-unit>
        <trans-unit id="790f40ee47446044b6d23c3286797ccea1e6e155" translate="yes" xml:space="preserve">
          <source>This declaration must declare a constructor, destructor, or user-defined type &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt;. It can only be used as part of a &lt;a href=&quot;templates&quot;&gt;template declaration&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt;, or explicit instantiation.</source>
          <target state="translated">この宣言では、コンストラクタ、デストラクタ、またはユーザー定義の型&lt;a href=&quot;cast_operator&quot;&gt;変換関数を&lt;/a&gt;宣言する必要があります。&lt;a href=&quot;templates&quot;&gt;テンプレート宣言&lt;/a&gt;、&lt;a href=&quot;template_specialization&quot;&gt;明示的な特殊&lt;/a&gt;化、または明示的なインスタンス化の一部としてのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b21c4afc7d9f44a231494182ce929f3873dbd60e" translate="yes" xml:space="preserve">
          <source>This definition is treated as a definition of a namespace with unique name and a</source>
          <target state="translated">この定義は、一意の名前を持つ名前空間の定義として扱われ</target>
        </trans-unit>
        <trans-unit id="f5d805f6f41052ad913a678cd3a3f6f56d5cd6ca" translate="yes" xml:space="preserve">
          <source>This destruction is empty: the members of this &lt;code&gt;basic_streambuf&lt;/code&gt; (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt; to be deleted through a pointer to base class.</source>
          <target state="translated">この破棄は空です。このデストラクタが戻った後、この &lt;code&gt;basic_streambuf&lt;/code&gt; のメンバー（ポインタとロケール）は、通常のオブジェクト破棄シーケンスに従って破棄されます。ただし、パブリック仮想として宣言されているため、 &lt;code&gt;std::basic_streambuf&lt;/code&gt; から派生したオブジェクトを、基本クラスへのポインターを介して削除できます。</target>
        </trans-unit>
        <trans-unit id="566d630222759bb1a22c3aebcb32a3363161c684" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying stream buffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the stream buffers.</source>
          <target state="translated">このデストラクタは、基になるストリームバッファ（ &lt;code&gt;rdbuf()&lt;/code&gt; ）に対して操作を実行しません。std &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; などの派生ストリームのデストラクタは、ストリームバッファのデストラクタの呼び出しを担当します。</target>
        </trans-unit>
        <trans-unit id="131f49f893678b58d7f7539c38777963fe7160b1" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying streambuffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived input streams such as &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the streambuffers.</source>
          <target state="translated">このデストラクタは、基になるストリーム &lt;code&gt;rdbuf()&lt;/code&gt; （rdbuf（））に対して何の操作も実行しません。std &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; などの派生入力ストリームのデストラクタは、ストリームバッファのデストラクタの呼び出しを担当します。</target>
        </trans-unit>
        <trans-unit id="1b99959c6ca09f07071faff9ad3d0e8aafb11452" translate="yes" xml:space="preserve">
          <source>This destructor is &lt;code&gt;virtual&lt;/code&gt; because the base class destructor, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt;&lt;code&gt;ios_base::~ios_base&lt;/code&gt;&lt;/a&gt; is virtual.</source>
          <target state="translated">基本デストラクタである&lt;a href=&quot;../ios_base/~ios_base&quot;&gt; &lt;code&gt;ios_base::~ios_base&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;virtual&lt;/code&gt; ため、このデストラクタは仮想です。</target>
        </trans-unit>
        <trans-unit id="e7593a44c2d3c23ae4a80ac5cc6624863832641b" translate="yes" xml:space="preserve">
          <source>This destructor is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Types...&lt;/code&gt; すべての &lt;code&gt;T_i&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、このデストラクタは簡単です...</target>
        </trans-unit>
        <trans-unit id="6df8c5501bb72be0811f778d216bdc599b74a410" translate="yes" xml:space="preserve">
          <source>This destructor is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このデストラクタは通常、 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; デストラクタによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bb5e9bde864785c69be529012ab31825d767db62" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C++ source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C++ file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">このディレクティブは、別の言語で記述されたファイルからC ++ソースファイルを生成する自動コード生成ツールによって使用されます。その場合、生成されたC ++ファイルに行番号と元の（人間が編集可能な）ソースファイルのファイル名を参照する &lt;code&gt;#line&lt;/code&gt; ディレクティブを挿入できます。</target>
        </trans-unit>
        <trans-unit id="2160c0fc9b1d6f99749583e4a431b1db823b687a" translate="yes" xml:space="preserve">
          <source>This element acts as a placeholder; attempting to access it results in undefined behavior.</source>
          <target state="translated">この要素はプレースホルダとして機能し、アクセスしようとすると未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="e1d92326ee038395416fb47c3929e52bba4b4b4a" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale.</source>
          <target state="translated">この例では、ロケールの他の部分を変更することなく、他の言語の通貨書式規則を適用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="699b77b3a2b284060799465bf0aef3eb6c604dfb" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale.</source>
          <target state="translated">この例では、ロケールの他の部分を変更することなく、他の言語の数字の句読点の規則を適用する方法を実証しています。</target>
        </trans-unit>
        <trans-unit id="03a8f1b5ffb01757d8be09e129dc569a5400d2fc" translate="yes" xml:space="preserve">
          <source>This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; to observe changes to the atomics &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in opposite order.</source>
          <target state="translated">この例は、順次順序付けが必要な状況を示しています。スレッド &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;d&lt;/code&gt; がアトミック &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; への変更を逆の順序で観察することが可能であるため、他の順序ではアサートがトリガーされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c12e1f3885c29be2bfca0cfe53639bf6159022e" translate="yes" xml:space="preserve">
          <source>This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.</source>
          <target state="translated">この例では、ポインタを媒介とした発行のための依存関係順同期を示します。整数データは、データ依存関係によって文字列へのポインタに関連していないため、その値はコンシューマでは未定義です。</target>
        </trans-unit>
        <trans-unit id="6b01d954af477e04c266f80ede6e5280ccdc0a60" translate="yes" xml:space="preserve">
          <source>This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class &lt;code&gt;T&lt;/code&gt;. Also, perfect forwarding of parameter packs is demonstrated.</source>
          <target state="translated">この例は、クラス &lt;code&gt;T&lt;/code&gt; のコンストラクターの引数へのパラメーターの完全な転送を示しています。また、パラメータパックの完全な転送も示されています。</target>
        </trans-unit>
        <trans-unit id="41d2d00ba30c148282801448fd5c841e57daf05e" translate="yes" xml:space="preserve">
          <source>This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale.</source>
          <target state="translated">この例では、GB18030 を意識したロケールから codecvt ファセットを使用して GB18030 エンコードされたファイルを読み取る様子を示しています。</target>
        </trans-unit>
        <trans-unit id="4d303a5fae16ce79fa6d0c697ce2d0fc19b5301e" translate="yes" xml:space="preserve">
          <source>This example demonstrates the Euler's identity ei&amp;pi;</source>
          <target state="translated">この例は、オイラーのアイデンティティを示しています。</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">この例では、clock()の時間と実時間の違いを示しています。</target>
        </trans-unit>
        <trans-unit id="ec322c19fb258d9310f125341429ba2dbaa4630e" translate="yes" xml:space="preserve">
          <source>This example displays information about the execution time of a function call:</source>
          <target state="translated">この例では、関数呼び出しの実行時間に関する情報を表示します。</target>
        </trans-unit>
        <trans-unit id="b6a1d0dea16b8362b800d36d34e475e44374f92b" translate="yes" xml:space="preserve">
          <source>This example measures the execution time of a function.</source>
          <target state="translated">この例では、関数の実行時間を測定します。</target>
        </trans-unit>
        <trans-unit id="f9f8065b3b5128d3a408cb9f21a45bf456306b8f" translate="yes" xml:space="preserve">
          <source>This example prints current time using the &quot;C&quot; locale with the time_put facet replaced by various time_put_byname facets.</source>
          <target state="translated">この例では、&quot;C&quot; ロケールを使用して現在の時刻を表示します。</target>
        </trans-unit>
        <trans-unit id="4b380662a79a86a43a8e6ddbc4fae89b7137cd02" translate="yes" xml:space="preserve">
          <source>This example shows a 10 seconds block.</source>
          <target state="translated">この例では、10秒のブロックを示しています。</target>
        </trans-unit>
        <trans-unit id="68e2616f4fe4dbb587d170dace9a4de7c97af570" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; can be used to protect shared data.</source>
          <target state="translated">この例は、 &lt;code&gt;lock&lt;/code&gt; と &lt;code&gt;unlock&lt;/code&gt; を使用して共有データを保護する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b265f51b6f5d54fac0a395f6360e177b329bb440" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">この例は、 &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; をスレッド間のシグナルとして使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="7e9ee0c7c7b464f5720460296151cb05bd7054a5" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">この例は、 &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; をスレッド間のシグナルとして使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="9cc1e77d4a4ec9dcaa9ce1202b289473c0fe3f32" translate="yes" xml:space="preserve">
          <source>This example shows how a &lt;code&gt;mutex&lt;/code&gt; can be used to protect a &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; shared between two threads.</source>
          <target state="translated">この例は、 &lt;code&gt;mutex&lt;/code&gt; を使用して2つのスレッド間で共有される &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; を保護する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="648fa6a16a6dcfeed9894c57ffbd6224f1ffea42" translate="yes" xml:space="preserve">
          <source>This example shows how to define several custom duration types and convert between types:</source>
          <target state="translated">この例では、複数のカスタム・デュレーション・タイプを定義し、タイプ間で変換する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="0af6770609a4caa5cf880a836ce6717cfed6d527" translate="yes" xml:space="preserve">
          <source>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda declaration can be stored in &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">この例は、ラムダをジェネリックアルゴリズムに渡す方法と、ラムダ宣言の結果のオブジェクトを &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; オブジェクトに格納する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="ccfdcc1737a5e9e6732e2a5414a8ae4ca8c5cc92" translate="yes" xml:space="preserve">
          <source>This example shows how to use a namespace to create a class that already has been named in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">この例は、名前空間を使用して、 &lt;code&gt;std&lt;/code&gt; 名前空間ですでに名前が付けられているクラスを作成する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="4812778eaab911430b4291ca314167dcaef2c221" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; families of functions.</source>
          <target state="translated">この例外がスローされることで &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; 機能の家族。</target>
        </trans-unit>
        <trans-unit id="a6233e2c685f108dd3cbe5ebed91c5d014b2b2b2" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; and functions that call it (such as the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; that takes a &lt;code&gt;std::chrono::local_time&lt;/code&gt;).</source>
          <target state="translated">この例外は、 &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; およびそれを呼び出す関数（ &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; コンストラクターでstd :: chrono :: local_timeを &lt;code&gt;std::chrono::local_time&lt;/code&gt; ）によってスローされます。</target>
        </trans-unit>
        <trans-unit id="d06332298cae245fc7de591665ed289988d734a8" translate="yes" xml:space="preserve">
          <source>This exception is thrown by member functions of &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例外は、 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt; メンバー関数によってスローされます。</target>
        </trans-unit>
        <trans-unit id="61d73663b9152dc36fe73750ad1a87fd639e49c2" translate="yes" xml:space="preserve">
          <source>This feature is used in template metaprogramming.</source>
          <target state="translated">この機能はテンプレートのメタプログラミングで使用されます。</target>
        </trans-unit>
        <trans-unit id="ebe57327a03912c16a8791570ac9fd18d3a3f421" translate="yes" xml:space="preserve">
          <source>This form automatically provides &lt;a href=&quot;exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;, but prohibits resource reuse.</source>
          <target state="translated">このフォームは自動的に&lt;a href=&quot;exceptions&quot;&gt;強力な例外保証を&lt;/a&gt;提供しますが、リソースの再利用を禁止します。</target>
        </trans-unit>
        <trans-unit id="a5c081dc7229ad13536ca7204c599487bcfa19aa" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by the following code:</source>
          <target state="translated">この関数（二重引数用）は、次のコードで実装されているかのように動作します（ &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; を発生させない自由を除く）。</target>
        </trans-unit>
        <trans-unit id="6a68eec804ec3c10883600f6bcfaeb90b1f9c1d6" translate="yes" xml:space="preserve">
          <source>This function and the related types are deprecated as of C++11 in favor of the more general &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from plain functions.</source>
          <target state="translated">この関数と関連する型は、より一般的な &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; により、C ++ 11で非推奨になりました。どちらも、プレーンな関数から呼び出し可能なアダプター互換の関数オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="8855f9b9dc1d262207716dd8128c053ea2ad8bb0" translate="yes" xml:space="preserve">
          <source>This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from member functions.</source>
          <target state="translated">この関数と関連する型はC ++ 11で廃止され、より一般的な &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; を優先してC ++ 17で削除されました。どちらもメンバー関数から呼び出し可能なアダプター互換の関数オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="9d11c6f40fc460580b4545f369d83a5f3011308f" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">この関数は,ソートされるシーケンスと同じサイズの一時バッファの割り当てを試みます.割り当てに失敗した場合は,効率の悪いアルゴリズムが選択されます.</target>
        </trans-unit>
        <trans-unit id="0dc2280353aa9f39b639bbe5806d955bd65f2c7d" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">この関数は一時的なバッファの割り当てを試みます。割り当てに失敗した場合は、効率の悪いアルゴリズムが選択されます。</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">この関数は、以下のように実装されている場合の動作をします。</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">この関数は、文字を順番に読み取り、一致する文字が見つかるとすぐに停止するかのように動作します &lt;code&gt;ptr&lt;/code&gt; が指す配列が &lt;code&gt;count&lt;/code&gt; よりも小さいが、一致が配列内で見つかった場合の動作は明確です。</target>
        </trans-unit>
        <trans-unit id="70a20794d71c34f9a147e7b2e7b15ccb7dd382d5" translate="yes" xml:space="preserve">
          <source>This function can be used when implementing &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; and &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;:</source>
          <target state="translated">この関数は、&lt;a href=&quot;../language/move_operator&quot;&gt;移動代入演算子&lt;/a&gt;と&lt;a href=&quot;../language/move_constructor&quot;&gt;移動コンストラクターを&lt;/a&gt;実装するときに使用できます。</target>
        </trans-unit>
        <trans-unit id="074233c87f0a8381f8c33e772677b1882b2b89cc" translate="yes" xml:space="preserve">
          <source>This function can make a write position available if the stringbuf is open for output (&lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt;): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input (&lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt;), then &lt;code&gt;overflow&lt;/code&gt; also increases the size of the get area by moving &lt;code&gt;egptr()&lt;/code&gt; to point just past the new write position.</source>
          <target state="translated">この関数は、stringbufが出力用に開いている場合（ &lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt; ）に書き込み位置を利用可能にすることができます。この場合、現在のバッファー全体を保持するのに十分な大きさのバッファーを再割り当て（または最初に割り当て）します。少なくとももう1文字。stringbufも入力用に開いている場合（ &lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt; ）、 &lt;code&gt;overflow&lt;/code&gt; は、 &lt;code&gt;egptr()&lt;/code&gt; を移動して新しい書き込み位置のすぐ後ろを指すようにすることで、get領域のサイズも大きくします。</target>
        </trans-unit>
        <trans-unit id="80dad3848a318d7ecb43c15430bc70acc0b353eb" translate="yes" xml:space="preserve">
          <source>This function detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt;, std::signbit is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">この関数は、ゼロ、無限大、およびNaNの符号ビットを検出します。一緒に &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt; 、はstd :: signbitがNaNの符号を検討する2つだけのポータブルな方法の一つです。</target>
        </trans-unit>
        <trans-unit id="8e1aa01daec415e7f5af69e6b0d04848557bd2e6" translate="yes" xml:space="preserve">
          <source>This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, container constructors, etc, and, in low-level library code, &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;.</source>
          <target state="translated">この関数は、コンストラクタを呼び出したり、メモリを初期化したりすることはありません。対応する割り当て解除関数が呼び出されることを保証できる、すぐに使用できるスマートポインターはありません。C ++でのメモリ割り当ての推奨される方法は、RAII対応関数 &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; 、コンテナーコンストラクターなどを使用し、低レベルのライブラリコードでは&lt;a href=&quot;../../language/new&quot;&gt;new-expressionを使用すること&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d4587b2ca7a4f0c1305b825fddf8669b0a594052" translate="yes" xml:space="preserve">
          <source>This function does not commit any changes to the filesystem.</source>
          <target state="translated">この関数はファイルシステムへの変更をコミットしません。</target>
        </trans-unit>
        <trans-unit id="9a9157bc8e19134921e346295ad23635f0edc637" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; がtrueでない限り、この関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="34f86c4c962be5f53b674478758ba7b4aac25784" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; is true for all i from 0 to &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">この関数は、0から &lt;code&gt;sizeof...(Types)&lt;/code&gt; までのすべてのiで &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; がtrueでない限り、オーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="430ec4ee0ab3ae68ef199618d00c231487c566a4" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; でない限り、この関数はオーバーロードの解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="93f49364b5d0b6ce3643e79ff41e9aa02af91573" translate="yes" xml:space="preserve">
          <source>This function exploits the signature compatibility between hinted insert for associative containers (such as &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;) and positional insert for sequential containers (such as &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">この関数は、連想コンテナのヒント挿入（ &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; ）と順次コンテナの位置挿入（ &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; ）の間の署名の互換性を利用します。</target>
        </trans-unit>
        <trans-unit id="77f1becd52cdb4bb82d9005b4cfb7fd4243343b4" translate="yes" xml:space="preserve">
          <source>This function has no effect. Memory used by a &lt;code&gt;monotonic_buffer_resource&lt;/code&gt;, as its name indicates, increases monotonically until the resource is destroyed.</source>
          <target state="translated">この関数は効果がありません。 &lt;code&gt;monotonic_buffer_resource&lt;/code&gt; が使用するメモリは、その名前が示すように、リソースが破棄されるまで単調に増加します。</target>
        </trans-unit>
        <trans-unit id="003c7fca2e592f4d453e6d2795ce41a60cc8ae9a" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currenly exclusively locked by any other thread.</source>
          <target state="translated">この関数は、ミューテックスが現在他のスレッドによって排他的にロックされていない場合でも、誤って失敗して &lt;code&gt;false&lt;/code&gt; を返すことができます。</target>
        </trans-unit>
        <trans-unit id="4aff8f3ce667147891a0800fe1ffe344229b2457" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currently locked by any other thread.</source>
          <target state="translated">この関数は、ミューテックスが他のスレッドによってロックされていない場合でも、誤って失敗して &lt;code&gt;false&lt;/code&gt; を返すことができます。</target>
        </trans-unit>
        <trans-unit id="581170c63a0c34f4d8ef486e52f25f659195a185" translate="yes" xml:space="preserve">
          <source>This function is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator (or specialization, for generic lambdas) is an immediate function.</source>
          <target state="translated">関数呼び出し演算子（または汎用ラムダの場合は特殊化）が&lt;a href=&quot;consteval&quot;&gt;即時関数である&lt;/a&gt;場合、この関数は即時関数です。</target>
        </trans-unit>
        <trans-unit id="7d1b9d31c1cd20909db730ecb0adb4933d6936b7" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (or another &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; that was given a &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; as the allocator to use).</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; （または、使用するアロケーターとして &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; が指定された別の &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）などのアロケーター対応オブジェクトによって（ &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; を介して）呼び出されます）。</target>
        </trans-unit>
        <trans-unit id="f22521ea8de0d211401620c2c0ceeebcc98c2413" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, that was given a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; as the allocator to use. Since &lt;code&gt;inner_allocator&lt;/code&gt; is itself an instance of &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, this function will also be called when the allocator-aware objects constructed through this function start constructing their own members.</source>
          <target state="translated">この関数は、使用するアロケータとして &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; が指定された &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; などのアロケータ対応オブジェクトによって（ &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; を介して）呼び出されます。 &lt;code&gt;inner_allocator&lt;/code&gt; 自体は &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; インスタンスなので、この関数は、この関数によって構築されたアロケータ対応オブジェクトが独自のメンバーの構築を開始したときにも呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1604a10d0bd65894de0fdd375bd44a25850704e0" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; オブジェクトをスワップするときに自動的に呼び出されます。直接呼び出す必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="0e78d40edd5ecace775e3b468b3346c7031f470e" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; オブジェクトをスワップするときに自動的に呼び出されます。直接呼び出す必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="c4734f8a6748c0cb4415534ce967c7c8880cdda2" translate="yes" xml:space="preserve">
          <source>This function is called by &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; and in other situations when finalizing a state-dependent multibyte character sequence.</source>
          <target state="translated">この関数は、状態に依存するマルチバイト文字シーケンスをファイナライズするときに、 &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="32de367add154511d8a09e86e9af636ea74ff7b5" translate="yes" xml:space="preserve">
          <source>This function is called by the constructor of &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; when given an &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; 引数が指定されたときに &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; コンストラクターによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cbcb817100be7c6ebcd72951487118723a0a15af" translate="yes" xml:space="preserve">
          <source>This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary.</source>
          <target state="translated">この関数は、すべての標準ライブラリコンテナのコピーコンストラクタから呼び出されます。これにより、コンストラクタの引数で使用されるアロケータがコンテナがコピーされていることを認識し、必要に応じて状態を変更することができます。</target>
        </trans-unit>
        <trans-unit id="bfb34e88abba67d43669caa31797e35aed808cba" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_fstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">この関数は、ストリームオブジェクトがスコープ外になり、通常は直接呼び出されない場合に、basic_fstream のデストラクタによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9586654e6d5f24f563ef041033abacd3e6aaef3e" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ifstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">この関数は、ストリームオブジェクトがスコープ外になり、通常は直接呼び出されない場合に basic_ifstream のデストラクタによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0b0b9fa6d17fdf350f225d78773a873a4f6a210f" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ofstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">この関数は、ストリームオブジェクトがスコープ外になり、通常は直接呼び出されない場合に、basic_ofstreamのデストラクタによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ae182d564b01a9cc3f1cbb5dd2383b385c515a22" translate="yes" xml:space="preserve">
          <source>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</source>
          <target state="translated">この関数は、関数呼び出し演算子(汎用ラムダの場合は特殊化)がconstexprであればconstexprです。</target>
        </trans-unit>
        <trans-unit id="6cb839c1449d28abb8b1ad7d5627544f12403184" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiple times to obtain successive tokens from the same string.</source>
          <target state="translated">この関数は、同じ文字列から連続したトークンを取得するために複数回呼び出されるように設計されています。</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">この関数は、同じ文字列から連続したトークンを取得するために、何度も呼び出されるように設計されています。</target>
        </trans-unit>
        <trans-unit id="776743886aba3fc5ea926a51a096528c0531353d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">この関数は破壊的です。文字列 &lt;code&gt;str&lt;/code&gt; の要素に &lt;code&gt;'\0'&lt;/code&gt; 文字を書き込みます。特に、&lt;a href=&quot;../../language/string_literal&quot;&gt;文字列リテラル&lt;/a&gt;は &lt;code&gt;strtok&lt;/code&gt; の最初の引数として使用できません。</target>
        </trans-unit>
        <trans-unit id="aaae01573deddc58b640a93ca69e57c3af20acb3" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;std::wcstok&lt;/code&gt;.</source>
          <target state="translated">この関数は破壊的です。文字列 &lt;code&gt;str&lt;/code&gt; の要素に &lt;code&gt;L'\0'&lt;/code&gt; 文字を書き込みます。特に、ワ​​イド文字列リテラルは &lt;code&gt;std::wcstok&lt;/code&gt; 最初の引数として使用できません。</target>
        </trans-unit>
        <trans-unit id="ae117e98847c242edb80799fb082fc22f8c51c75" translate="yes" xml:space="preserve">
          <source>This function is different from a typical &lt;code&gt;overflow()&lt;/code&gt; which moves the contents of the buffer to the associated character sequence because for a &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, the buffer and the associated sequence are one and the same.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 場合、バッファーと関連付けられたシーケンスが1つで同じであるため、バッファーの内容を関連付けられた文字シーケンスに移動する一般的な &lt;code&gt;overflow()&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="bf7eaed7da997c4b5d39d94135b3ff5c00bc6632" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">この関数は、式 &lt;code&gt;ps&lt;/code&gt; が一度だけ評価されることを除いて、型 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; の非表示オブジェクトの &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; の呼び出しと同等です。</target>
        </trans-unit>
        <trans-unit id="9101f15eeb95d6b33b0fdb8d4808ce7c08cccbd4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; 変換状態が影響を受けないことを除いて、呼び出しstd :: mbtowc（（wchar_t *）0、s、n）と &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1963bc98196193cc320458fc455ddd3e328dde8a" translate="yes" xml:space="preserve">
          <source>This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used.</source>
          <target state="translated">この関数は、アプリケーション・コードで直接使用されることはほとんどありません。その代わりに、非メンバ比較演算子のいずれかが使用されます。</target>
        </trans-unit>
        <trans-unit id="403f2759a06c2803350631fa5d221bae46fd2b6b" translate="yes" xml:space="preserve">
          <source>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable.</source>
          <target state="translated">この関数は、管理されているオブジェクトがスレッド間で共有されている場合、本質的にマンネリ化します。特に、偽の結果は使用する前に陳腐化する可能性があります。真の結果は信頼性があります。</target>
        </trans-unit>
        <trans-unit id="452207e6d60059763d001256a30bc736ba869131" translate="yes" xml:space="preserve">
          <source>This function is intended to replace &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;. Unlike std::bind, it does not support arbitrary argument rearrangement and has no special treatment for nested bind-expressions. On the other hand, it pays attention to the value category of the call wrapper object and propagates exception specification of the underlying call operator.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; を置き換えることを目的としています。std :: bindとは異なり、任意の引数の再配置をサポートしておらず、ネストされたバインド式に対する特別な処理はありません。一方、コールラッパーオブジェクトの値カテゴリに注意を払い、基になるコールオペレーターの例外指定を伝達します。</target>
        </trans-unit>
        <trans-unit id="bc919d55a6f87a71a7f9eff45b45a6e0e62a8ce5" translate="yes" xml:space="preserve">
          <source>This function is not expected to be called directly: it is called through &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt;&lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は直接呼び出されることは想定されていません&lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt; &lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt; &lt;/a&gt;介して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="57e7dd85f600e213ae40f7d97225e1e1697e505f" translate="yes" xml:space="preserve">
          <source>This function is not fully implemented in some standard libraries. For example, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc++&lt;/a&gt; always returns zero even though the device is non-deterministic. In comparison, Microsoft Visual C++ implementation always returns 32, and &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; returns 10.</source>
          <target state="translated">この関数は、一部の標準ライブラリでは完全に実装されていません。たとえば、デバイスが非決定的であっても、&lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc ++は&lt;/a&gt;常にゼロを返します。対照的に、Microsoft Visual C ++実装は常に32を返し、&lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt;は10を返します。</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">この関数はロケール依存ではなく、コピーする &lt;code&gt;wchar_t&lt;/code&gt; オブジェクトの値に注意を払いません。nullと無効な文字もコピーされます。</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">この関数はロケールに依存せず、検査する &lt;code&gt;wchar_t&lt;/code&gt; オブジェクトの値に注意を払いません。nullと無効なワイド文字も比較されます。</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">この関数はロケールに依存せず、関数が書き込む &lt;code&gt;wchar_t&lt;/code&gt; オブジェクトの値に注意を払いません。nullや無効なワイド文字も書き込まれます。</target>
        </trans-unit>
        <trans-unit id="cc19c16caa38c36df06e04a2db5301e73e2f5836" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match collation order.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; とは異なり、ロケールに依存しません。また、異なるUnicodeブロックの文字が一緒に使用される場合、またはコード単位の順序が照合順序と一致しない場合、順序は意味がない場合があります。</target>
        </trans-unit>
        <trans-unit id="743f719e1c7876947aef41d3da4d327b2152c1ab" translate="yes" xml:space="preserve">
          <source>This function is not overloaded for the types &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted &lt;a href=&quot;operator_ltlt2&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;</source>
          <target state="translated">この関数は、フォーマットされた&lt;a href=&quot;operator_ltlt2&quot;&gt;演算子&lt;/a&gt;とは異なり、 &lt;code&gt;signed char&lt;/code&gt; または &lt;code&gt;unsigned char&lt;/code&gt; 型ではオーバーロードされません&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">この関数はゼロの符号に敏感である必要はありませんが、実装によっては、一方の引数が+0で他方の引数が-0の場合、+0が返されることを追加で強制しているものもあります。</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">この関数はゼロの符号に敏感である必要はありませんが、実装によっては、一方の引数が+0で他方の引数が-0の場合、-0が返されることを追加で強制しているものもあります。</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">この関数はスレッドセーフである必要はありません。getenvへの別の呼び出し、およびPOSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv（）&lt;/a&gt;、&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv（）&lt;/a&gt;、および&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv（）への&lt;/a&gt;呼び出しは、以前の呼び出しによって返されたポインタを無効にするか、以前の呼び出しから取得した文字列を変更する場合があります。</target>
        </trans-unit>
        <trans-unit id="f78d178d130886a2b5afb503f15940c3ad73bbf9" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたエラーの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="a2abffafc50a2795cbfb3627bf5fb2f042437061" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたエラー条件の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="e653a40d5b5f3d4ecc32e287a36ac0f0a3489976" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; で指定されたエラーの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="da22a8cee5382549c532104db50c4ef68f7574e4" translate="yes" xml:space="preserve">
          <source>This function is not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">この関数は、通常の&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非修飾&lt;/a&gt;または&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;修飾ルックアップ&lt;/a&gt;からは見えず、 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; が引数の関連クラスである場合に、引数&lt;a href=&quot;../../language/adl&quot;&gt;依存ルックアップで&lt;/a&gt;のみ見つけることができます。これにより、 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; している場合に望ましくない変換が行われなくなります。</target>
        </trans-unit>
        <trans-unit id="356a2955e71eb2ff664ad638e29c0c881711ba2c" translate="yes" xml:space="preserve">
          <source>This function is optional, it may return &lt;code&gt;no_order&lt;/code&gt; in every case.</source>
          <target state="translated">この関数はオプションであり、どの場合でも &lt;code&gt;no_order&lt;/code&gt; を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="ffa5bc6979d4d788a32f52d1a8c3d6238bb88fba" translate="yes" xml:space="preserve">
          <source>This function is optional. If not implemented, this function returns &lt;code&gt;​0​&lt;/code&gt; (since the base class version &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; gets called).</source>
          <target state="translated">この機能はオプションです。実装されていない場合、この関数は返す &lt;code&gt;​0​&lt;/code&gt; （基底クラスバージョン以降 &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; 呼び出されます）。</target>
        </trans-unit>
        <trans-unit id="94f083987e438e8f45398655d60ea441662342f7" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_filebuf&lt;/code&gt;.</source>
          <target state="translated">この関数は仮想保護されており、 &lt;code&gt;pubsetbuf()&lt;/code&gt; または &lt;code&gt;std::basic_filebuf&lt;/code&gt; から派生したユーザー定義クラスのメンバー関数からのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e90def3890bd5c122a703d2eae4d728a21e862ac" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_stringbuf&lt;/code&gt;.</source>
          <target state="translated">この関数は仮想保護されており、 &lt;code&gt;pubsetbuf()&lt;/code&gt; または &lt;code&gt;std::basic_stringbuf&lt;/code&gt; から派生したユーザー定義クラスのメンバー関数からのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b7f492276aa00c278aeca31b34dc935f13689be2" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::strstreambuf&lt;/code&gt;.</source>
          <target state="translated">この関数は仮想保護されており、 &lt;code&gt;pubsetbuf()&lt;/code&gt; または &lt;code&gt;std::strstreambuf&lt;/code&gt; から派生したユーザー定義クラスのメンバー関数からのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="503edf2bb2eb0295ac5dcd3fad68fe3498303d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with C. If the compatibility is not required, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; may be initialized through their non-default constructors.</source>
          <target state="translated">この関数は、Cとの互換性のために提供されています。互換性が必要ない場合は、 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; デフォルト以外のコンストラクターで初期化できます。</target>
        </trans-unit>
        <trans-unit id="0233eac438664696f470dcb4a6305de8bdfaa672" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="translated">この関数は、他の関数がホスト環境を変更しない限り、スレッドセーフです（複数のスレッドから呼び出してもデータ競合は発生しません）。特に、POSIX関数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv（）&lt;/a&gt;、&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv（）&lt;/a&gt;、および&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv（）&lt;/a&gt;は、同期せずに呼び出された場合にデータ競合を引き起こします。</target>
        </trans-unit>
        <trans-unit id="a752e45b1c1e76a0bf7ba715c5f6c403c0eed278" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt; へのすべての呼び出し</target>
        </trans-unit>
        <trans-unit id="a166d5bd1c79123ccec86898cc471f7c6a1e389e" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_new_handler&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;std::set_new_handler&lt;/code&gt; へのすべての呼び出し</target>
        </trans-unit>
        <trans-unit id="0f8d53be444102a8285b0653a05c85e675ae55c4" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_terminate&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;std::set_terminate&lt;/code&gt; へのすべての呼び出し</target>
        </trans-unit>
        <trans-unit id="2c7aea13c02b97924864411502ae4053e055e059" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;std::set_unexpected&lt;/code&gt; へのすべての呼び出し</target>
        </trans-unit>
        <trans-unit id="12d270b8becf9b193ce734289e056a679cfdfc26" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。以前の &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1ab230cef40ffc4e792b092936b1dc96c9a5607" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; への以前の呼び出し</target>
        </trans-unit>
        <trans-unit id="419521c15e45c9bfd4ee0de0dfa28aaf76875995" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; への以前の呼び出し</target>
        </trans-unit>
        <trans-unit id="991dd801c88141cd8662fd187f9759911775d74d" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">この関数はスレッドセーフです。 &lt;code&gt;std::set_unexpected&lt;/code&gt; への以前の呼び出し</target>
        </trans-unit>
        <trans-unit id="b2b7ba4b79851f8176eac8ec16e5a1575927b2d7" translate="yes" xml:space="preserve">
          <source>This function is thread-safe; concurrent access by multiple threads does not result in a data race.(since C++14).</source>
          <target state="translated">この関数はスレッドセーフです。複数のスレッドによる同時アクセスでデータ競合が発生することはありません。</target>
        </trans-unit>
        <trans-unit id="6c9ad1a43ed57cf75b0c052d412e9c8c3e821c79" translate="yes" xml:space="preserve">
          <source>This function is typically accessed through &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt;.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt; 介してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="8638be2f7c43a80edc7dee020c03393b731e9858" translate="yes" xml:space="preserve">
          <source>This function is typically called by &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt; によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="db17dd608d932664bed4bd45648d18848b7cdb88" translate="yes" xml:space="preserve">
          <source>This function is typically called through the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; インターフェースを介して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6b70e23981de2eddfb5cf1b279f2272ffbaab4c5" translate="yes" xml:space="preserve">
          <source>This function is used by the standard library containers when inserting, copying, or moving elements.</source>
          <target state="translated">この関数は、標準ライブラリコンテナが要素を挿入、コピー、移動する際に使用します。</target>
        </trans-unit>
        <trans-unit id="1c6ccf8ad1ccab32debfac40525ef074436c2ec6" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;std::strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strxfrm&lt;/code&gt; を使用してすべての文字列を一度だけ変換し、その後変換された文字列を &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; と比較する方が効率的であるため、この関数は、同じ文字列または文字列のセットを使用して複数のロケール依存の比較を行うときに使用されます。</target>
        </trans-unit>
        <trans-unit id="ca9d1d936d9fcef21052e9b31a8d09c354e45148" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;std::wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::wcsxfrm&lt;/code&gt; を使用してすべての文字列を一度だけ変換し、その後変換されたワイド文字列を &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; と比較する方が効率的であるため、この関数は、同じワイド文字列またはワイド文字列のセットを使用して複数のロケール依存の比較を行うときに使用されます:: wcscmp。</target>
        </trans-unit>
        <trans-unit id="5926d0f12bf7b7909e57150c062279d2ee706942" translate="yes" xml:space="preserve">
          <source>This function is useful in generic programming, since it uses &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; as fallbacks when &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is not available.</source>
          <target state="translated">この関数は、 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; が使用できない場合のフォールバックとして&amp;lt;および &lt;code&gt;==&lt;/code&gt; を使用するため、一般的なプログラミングで役立ちます。</target>
        </trans-unit>
        <trans-unit id="be58b3707f3fcdf36615b4d19faec6a6dc05f29c" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;std::remquo&lt;/code&gt;, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">この関数は、周期が浮動小数点値として正確に表現できる周期関数を実装する場合に役立ちます。非常に大きな &lt;code&gt;x&lt;/code&gt; の sin（&amp;pi;x）を計算するときに &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 直接呼び出すと、大きなエラーが発生する可能性がありますが、関数の引数が &lt;code&gt;std::remquo&lt;/code&gt; を使用して最初に削減されます。商の下位ビットを使用して、期間内の結果の符号とオクタントを決定できます。残りは、高精度で値を計算するために使用できます。</target>
        </trans-unit>
        <trans-unit id="9314ee2e726c67b60305538d50add991082d26bc" translate="yes" xml:space="preserve">
          <source>This function is usually case-insensitive.</source>
          <target state="translated">この関数は通常、大文字小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="6c9ee1f3188431817a670ceef41258274cd55d11" translate="yes" xml:space="preserve">
          <source>This function may be used as an alternative to &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;. The trade-offs are:</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; 代わりに使用できます。トレードオフは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0255ee7edd077c96e23883d7db760fc3da2e3d71" translate="yes" xml:space="preserve">
          <source>This function may be used e.g. in the implementation of &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; to use bulk character copy instead of calling &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; if it is known that the locale imbued in the &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; does not perform any conversions.</source>
          <target state="translated">この関数は、の実装で使用される例もあり &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; の代わりに呼び出しの使用バルク文字のコピーに &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; ている場合 &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; れたロケールは変換を行わないことがわかっています。</target>
        </trans-unit>
        <trans-unit id="332c6aa9bcea925b9a927e3ad7173bbcf6a2f86d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">この関数は、呼び出し元から発生する可能性のある浮動小数点例外を非表示にする必要があるサブルーチンの先頭で使用できます。一部の例外のみを抑制し、他の例外を報告する必要がある場合、ノンストップモードは通常、不要な例外をクリアした後に &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; 呼び出して終了します。</target>
        </trans-unit>
        <trans-unit id="653f6e88a7890bf08216060f0a91617ba728c746" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; への以前の呼び出しによって確立されたノンストップモードを終了するために使用できます。</target>
        </trans-unit>
        <trans-unit id="23b1aaf9597250b14a85a5f063ebcaa36211aeee" translate="yes" xml:space="preserve">
          <source>This function may be used to output object representations, i.e. binary output.</source>
          <target state="translated">この関数は、オブジェクト表現、すなわちバイナリ出力を出力するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="856950bcb4c9f3dcc5895c41de9e090f268e6ccd" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;sleep_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">この関数は、スケジューリングまたはリソース競合の遅延により、 &lt;code&gt;sleep_duration&lt;/code&gt; よりも長くブロックされる場合があります。</target>
        </trans-unit>
        <trans-unit id="6c2d0b323f5f9df1da55d663b9642600ad42960c" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">この関数は、スケジューリングまたはリソース競合の遅延が原因で、 &lt;code&gt;timeout_duration&lt;/code&gt; よりも長くブロックされる場合があります。</target>
        </trans-unit>
        <trans-unit id="88aa144342c719b2d0cf02f7ae6cd001dc8b8b1c" translate="yes" xml:space="preserve">
          <source>This function may implement selection sampling or reservoir sampling.</source>
          <target state="translated">この関数は、選択サンプリングまたはリザーバサンプリングを実装することができます。</target>
        </trans-unit>
        <trans-unit id="f6b6f1463d12ffb2bc42127132a8ac643fc238fe" translate="yes" xml:space="preserve">
          <source>This function may not be thread-safe.</source>
          <target state="translated">この関数はスレッドセーフではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="a4a88b9d5b7b6f8931799bf82d9c71dd06343e4a" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">この関数は、 &lt;code&gt;stream&lt;/code&gt; が開いているファイルに関連付けられた後で、他の操作（ &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 呼び出しが失敗した場合を除く）の前にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="19731f6b76843a49446fd5784cfb942c7dfca160" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;std::setbuf&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">この関数は、 &lt;code&gt;stream&lt;/code&gt; が開いているファイルに関連付けられた後で、他の操作（ &lt;code&gt;std::setbuf&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 呼び出しが失敗した場合を除く）の前にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="717983186dc4c6865ae3eed7bfe5f5461be1682a" translate="yes" xml:space="preserve">
          <source>This function moves the &lt;code&gt;src&lt;/code&gt; pointer to the end of the converted multibyte string. This doesn't happen if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、変換されたマルチバイト文字列の末尾に &lt;code&gt;src&lt;/code&gt; ポインターを移動します。 &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 場合、これは起こりません。</target>
        </trans-unit>
        <trans-unit id="53568c58dccc50911b4df0d8fe32be0fd89e385d" translate="yes" xml:space="preserve">
          <source>This function never modifies the file, only the get area of the in-memory buffer.</source>
          <target state="translated">この関数はファイルを変更することはなく、メモリ内バッファの取得領域のみを取得します。</target>
        </trans-unit>
        <trans-unit id="a3149df38d014eb7ad815af8ec580ac7ae565936" translate="yes" xml:space="preserve">
          <source>This function object provides owner-based (as opposed to value-based) mixed-type ordering of both &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. The order is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by &lt;code&gt;get()&lt;/code&gt; are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">この関数オブジェクトは、 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 両方の所有者ベースの（値ベースではなく）混合タイプの順序を提供します。順序は、 &lt;code&gt;get()&lt;/code&gt; によって取得された生のポインタの値が異なる場合でも（たとえば、同じオブジェクト内の異なるサブオブジェクトを指しているため）、2つのスマートポインタが両方とも空であるか、所有権を共有している場合にのみ、同等に比較されます。 。</target>
        </trans-unit>
        <trans-unit id="501340bd50fbe27100db1419cc8b73a966d53dac" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;std::feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">この関数は、最新のI / O操作で報告されたストリームの状態を報告するだけで、関連するデータソースは調べません。たとえば、最新のI / Oが &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; で、ファイルの最後のバイトを返した場合、 &lt;code&gt;std::feof&lt;/code&gt; はゼロを返します。次の &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; 失敗し、ストリームの状態を</target>
        </trans-unit>
        <trans-unit id="7ad9af23b2df5c7bd59daf117807cb419335155c" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as set by the most recent I/O operation; it does not examine the associated data source. For example, if the most recent I/O was a &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; which returned the last byte of a file, &lt;code&gt;eof()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The next &lt;code&gt;get()&lt;/code&gt; fails to read anything and sets the &lt;code&gt;eofbit&lt;/code&gt;. Only then does &lt;code&gt;eof()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">この関数は、最新のI / O操作で設定されたストリームの状態のみを報告します。関連するデータソースは調べません。たとえば、最新のI / Oがファイルの最後のバイトを返す&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;であった場合、 &lt;code&gt;eof()&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; を返します。次の &lt;code&gt;get()&lt;/code&gt; は何も読み取れず、 &lt;code&gt;eofbit&lt;/code&gt; を設定します。 &lt;code&gt;eof()&lt;/code&gt; 初めて、eof（）は &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="982c99a7d72d510dc31dfb3379380b9b994f3b5b" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/objects&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically only meaningful for trivially-copyable objects with no padding. For example, &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will not compare their contents, and &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;struct{char c; int n;}&lt;/code&gt; will compare the padding bytes whose values may differ when the values of &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are the same.</source>
          <target state="translated">この関数は、オブジェクト値ではなく&lt;a href=&quot;../../language/objects&quot;&gt;オブジェクト表現を&lt;/a&gt;読み取り、通常、パディングのない単純なコピー可能なオブジェクトに対してのみ意味があります。例えば、 &lt;code&gt;memcmp()&lt;/code&gt; 型の2つのオブジェクト間 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; その内容を比較せず、 &lt;code&gt;memcmp()&lt;/code&gt; 型の2つのオブジェクト間 &lt;code&gt;struct{char c; int n;}&lt;/code&gt; は、 &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の値が同じ場合に値が異なる可能性があるパディングバイトを比較します。</target>
        </trans-unit>
        <trans-unit id="3b2572fd11a91d196e72bf228b8fdec17f7a295e" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;true&lt;/code&gt; immediately after construction or an increment. Recursion can be disabled via &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、構築またはインクリメントの直後に &lt;code&gt;true&lt;/code&gt; を返します。再帰は &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt; で無効にできます。</target>
        </trans-unit>
        <trans-unit id="36528001254a3bd82486f8ac96e239eda107e919" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. In addition, it modifies the static &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object which may be shared with &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は静的データへのポインタを返し、スレッドセーフではありません。さらに、 &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt; と共有できる静的 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; オブジェクトを変更します。POSIXはこの関数を廃止し、代わりに &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; を推奨しています。</target>
        </trans-unit>
        <trans-unit id="b1f290d85406220b6b3adbcd72ba71618d9d4c4a" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は静的データへのポインタを返し、スレッドセーフではありません。POSIXはこの関数を廃止し、代わりに &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; を推奨しています。</target>
        </trans-unit>
        <trans-unit id="2c08549c92d5f75cd55b61fde267f92bfcf2bd81" translate="yes" xml:space="preserve">
          <source>This function template does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 両方が &lt;code&gt;true&lt;/code&gt; でない限り、この関数テンプレートはオーバーロード解決に参加しません。</target>
        </trans-unit>
        <trans-unit id="e017cba1b1d7f0a849984253cc947eb2d5f913c0" translate="yes" xml:space="preserve">
          <source>This function template is &lt;code&gt;constexpr&lt;/code&gt; if and only if each of &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt; and the types of all subobjects of &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt;:</source>
          <target state="translated">この関数テンプレートは、 &lt;code&gt;To&lt;/code&gt; 、 &lt;code&gt;From&lt;/code&gt; のそれぞれ、および &lt;code&gt;To&lt;/code&gt; と &lt;code&gt;From&lt;/code&gt; のすべてのサブオブジェクトのタイプの場合にのみ &lt;code&gt;constexpr&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d23f50db250e473fa7ba998015f5ef4335528d35" translate="yes" xml:space="preserve">
          <source>This function was deprecated in C++17 and removed in C++20 because &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; is only an approximation in multithreaded environment (see Notes in &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">この関数はC ++ 17で廃止され、C ++ 20で削除されました。 &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; は、use_countがマルチスレッド環境での概算にすぎないためです（ &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; の注を参照）。</target>
        </trans-unit>
        <trans-unit id="c95a6c84f8a7a3d63141f96f96d764fc5141f797" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;, and having to call &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;construct&lt;/code&gt;, and &lt;code&gt;deallocate&lt;/code&gt; individually.</source>
          <target state="translated">この関数は、完全に特殊化されたアロケーター &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; で使用するために導入されましたが、 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; から &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; に再バインドする必要を回避するショートカットとして、あらゆる特殊化で役立ちます。&amp;gt;、および &lt;code&gt;allocate&lt;/code&gt; 、 &lt;code&gt;construct&lt;/code&gt; 、および &lt;code&gt;deallocate&lt;/code&gt; を個別に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="cdecbddba7a122a33bb2e1a5f3720fe34c7dff59" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、完全に特殊化されたアロケーター &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; で使用するために導入されましたが、 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; から &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; に再バインドする必要を回避するショートカットとして、あらゆる特殊化で役立ちます。&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="2ae120608bb11c2db86fc6eaad00ab05ea738813" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization.</source>
          <target state="translated">この関数は、完全に特殊化されたアロケータ &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; で使用するために導入されましたが、どの特殊化でも役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="afc3c5ff95ee968755d1d67223367b55662ab586" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数のバイト文字列の類似体は &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; ではなくstd :: &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a2cb86dd21cb66b4b0098463876ae7c777232781" translate="yes" xml:space="preserve">
          <source>This function, if defined, is the inverse of &lt;code&gt;pointer_to&lt;/code&gt;, and exists as the customization point to be called by &lt;a href=&quot;../to_address&quot;&gt;&lt;code&gt;std::to_address&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数は、定義されている場合、 &lt;code&gt;pointer_to&lt;/code&gt; の逆であり、&lt;a href=&quot;../to_address&quot;&gt; &lt;code&gt;std::to_address&lt;/code&gt; &lt;/a&gt;によって呼び出されるカスタマイズポイントとして存在します。</target>
        </trans-unit>
        <trans-unit id="2345f7fbcd183e468d0ac0a235350d0b6c2895ee" translate="yes" xml:space="preserve">
          <source>This functions invalidates all pointers and references to elements in the array.</source>
          <target state="translated">この関数は,配列の要素へのポインタや参照をすべて無効にします.</target>
        </trans-unit>
        <trans-unit id="5e4969b70b796f9ee282c9f3e8a0064ce14f7b5c" translate="yes" xml:space="preserve">
          <source>This header contains forward declarations for the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーには、&lt;a href=&quot;../io&quot;&gt;入力/出力&lt;/a&gt;ライブラリの前方宣言が含まれています。</target>
        </trans-unit>
        <trans-unit id="a9faf08967a6670c687da4edbcf69fb38e394a6f" translate="yes" xml:space="preserve">
          <source>This header is for &lt;a href=&quot;../string/byte&quot;&gt;C-style null-terminated byte strings&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../string/byte&quot;&gt;Cスタイルのヌル終了バイト文字列用&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="15d0710db508b245029a9ef7a8057846c8c18ceb" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../algorithm&quot;&gt;algorithm&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../algorithm&quot;&gt;アルゴリズム&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="58c127bf99321a87db0770e187db96005473b488" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../atomic&quot;&gt;atomic operations&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../atomic&quot;&gt;アトミック操作&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="e7de3a818aa933f4120df06f08cef712f022314a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono&quot;&gt;date and time&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../chrono&quot;&gt;日時&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="7df038a6142795810cf58cc3edc5892a6604ef81" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono/c&quot;&gt;C-style date and time&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../chrono/c&quot;&gt;Cスタイルの日付と時刻&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="fc145a04217e02f635144bea666233647838e7fd" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../concepts&quot;&gt;concepts&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../concepts&quot;&gt;概念&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="920e039f9619877e9581d36218e4eb4ba48fec2f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;container&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../container&quot;&gt;コンテナ&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="acbb3dd4e1d46d22f68d17b978a7136be93e2436" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;containers&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../container&quot;&gt;コンテナ&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="6b732c1d1cd4791f71bccf52bcce002f80d4d61f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../error&quot;&gt;error handling&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../error&quot;&gt;エラー処理&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="d135ae9415d668b3740baa8d1c6202b3114e61db" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../filesystem&quot;&gt;filesystem support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../filesystem&quot;&gt;ファイルシステムサポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="a2b0a9ff42b16169188356ee975f844196e0ec79" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/Output&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../io&quot;&gt;入出力&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="b25ea2a66813773c5a403aa1ec3e976f8574b721" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../io&quot;&gt;入出力&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="0686693c4046ba7c301b43bc07e6f7bdc8f026ab" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;input/output&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../io&quot;&gt;入出力&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="5dc95614835592456bfaab6702f6224650e49b18" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/c&quot;&gt;C-style input/output&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../io/c&quot;&gt;Cスタイルの入出力&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="741ade6dc30c88b9370c305e6f3e63644225b886" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/manip&quot;&gt;Input/output manipulators&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../io/manip&quot;&gt;入力/出力マニピュレーター&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="7cb909214b55ea54c4a3636e2ff95e66a61c1e7b" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../iterator&quot;&gt;iterator&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../iterator&quot;&gt;イテレータ&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="09eabf0e3af531f8459c8a3e9d34d078049d494f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;Localization&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../locale&quot;&gt;ローカリゼーション&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="e0027a344c3001e03b17fff554e048e844e18b05" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;localization&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../locale&quot;&gt;ローカリゼーション&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="1909ccb2df983190ad8b340b81a78cddcac0bc66" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library, in particular provides &lt;a href=&quot;../memory/new&quot;&gt;low level memory management&lt;/a&gt; features.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../memory&quot;&gt;動的メモリ管理&lt;/a&gt;ライブラリの一部であり、特に&lt;a href=&quot;../memory/new&quot;&gt;低レベルのメモリ管理&lt;/a&gt;機能を提供します。</target>
        </trans-unit>
        <trans-unit id="923f654a5fb3f2b4a9e337168f6734bf9fb2d4f9" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../memory&quot;&gt;動的メモリ管理&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="dbf3371c4bdf5d7b9e212f0bbd00a12907e1875c" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric&quot;&gt;numeric&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../numeric&quot;&gt;数値&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="83d799881dc970620d81655aaa5b6c445cc22101" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../numeric/fenv&quot;&gt;浮動小数点環境&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="5ec3ff74347947b9a2d2ce7512f774f5d52354a7" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/random&quot;&gt;pseudo-random number generation&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../numeric/random&quot;&gt;疑似乱数生成&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="732e0c7c47f9d69b203e65c610a0bfd158dff524" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../numeric/ratio&quot;&gt;コンパイル時の有理算術&lt;/a&gt;ライブラリーの一部です。</target>
        </trans-unit>
        <trans-unit id="c1ad47862381ddb91c08db8090600c5d4bf4e4dc" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../ranges&quot;&gt;ranges&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../ranges&quot;&gt;範囲&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="d97fc3d50637471b41b3efb43e5a6b0e3a2b4a01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../regex&quot;&gt;regular expressions&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../regex&quot;&gt;正規表現&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="a2342c5c0987e5fec030e1218936937ec44df653" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string&quot;&gt;strings&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../string&quot;&gt;文字列&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="92a5be8272a47414f0e0bdc904667ee202af3267" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/byte&quot;&gt;null-terminated byte strings&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../string/byte&quot;&gt;ヌル終了バイト文字列&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="15b12e7c5f34f001bead642c260ad11a6ffaa39d" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../string/multibyte&quot;&gt;ヌル終了マルチバイト文字列&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="2c42908621e154cf0ec843b46350efa2d0035aee" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/wide&quot;&gt;C-style null-terminated wide strings&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../string/wide&quot;&gt;Cスタイルのヌル終了ワイド文字列&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="1fa75679068a99053300a010d141f6d8edb54561" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../thread&quot;&gt;thread support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../thread&quot;&gt;スレッドサポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="5d0c64faa54ec66b25a58a11c78064009bdd8b01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, in particular it's part of the &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../types&quot;&gt;タイプサポート&lt;/a&gt;ライブラリの一部であり、特に&lt;a href=&quot;../types/climits&quot;&gt;C数値制限インターフェイス&lt;/a&gt;の一部です。</target>
        </trans-unit>
        <trans-unit id="65d3f063deae384355d6746093849a4b449165a4" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, providing &lt;a href=&quot;../types/integer&quot;&gt;fixed width integer types&lt;/a&gt; and part of &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../types&quot;&gt;型サポート&lt;/a&gt;ライブラリの一部であり、&lt;a href=&quot;../types/integer&quot;&gt;固定幅の整数型&lt;/a&gt;と&lt;a href=&quot;../types/climits&quot;&gt;C数値制限インターフェイスの&lt;/a&gt;一部を提供します。</target>
        </trans-unit>
        <trans-unit id="436886a411e9e8d5ffe11352a732faef34f88757" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../types&quot;&gt;タイプサポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="7edf0c9c8e7cef800a48133a201ddbc070132a48" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;types support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../types&quot;&gt;タイプサポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="58facb47ff5cf9d880e42e8852e016436ed3f78a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;general utility&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../utility&quot;&gt;一般的なユーティリティ&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="31843b16c0e12afb62de520dcdac5733f6cee8c2" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;utility&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../utility&quot;&gt;ユーティリティ&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="b3ee827480d7d8d279e03c27c6ed6cca87cad739" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility#Language_support&quot;&gt;language support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../utility#Language_support&quot;&gt;言語サポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="a4ff4d258bc17960105e2ea2601ffd3a5889df5f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/functional&quot;&gt;function objects&lt;/a&gt; library and provides the standard &lt;a href=&quot;../utility/hash&quot;&gt;hash function&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは&lt;a href=&quot;../utility/functional&quot;&gt;関数オブジェクト&lt;/a&gt;ライブラリの一部であり、標準の&lt;a href=&quot;../utility/hash&quot;&gt;ハッシュ関数&lt;/a&gt;を提供します。</target>
        </trans-unit>
        <trans-unit id="9ac972c91cec61981b8a812ec6acfd57ff806586" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/program&quot;&gt;program support&lt;/a&gt; library.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../utility/program&quot;&gt;プログラムサポート&lt;/a&gt;ライブラリの一部です。</target>
        </trans-unit>
        <trans-unit id="e22299e67c4b7f2d10a4eb976dbfff224a6c2122" translate="yes" xml:space="preserve">
          <source>This header is part of the null-terminated &lt;a href=&quot;../string/wide&quot;&gt;wide&lt;/a&gt; and &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; strings libraries. It also provides some &lt;a href=&quot;../io/c&quot;&gt;C-style I/O&lt;/a&gt; functions and conversion from &lt;a href=&quot;../chrono/c&quot;&gt;C-style Date&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは、ヌルで終了する&lt;a href=&quot;../string/wide&quot;&gt;ワイド&lt;/a&gt;および&lt;a href=&quot;../string/multibyte&quot;&gt;マルチバイト&lt;/a&gt;文字列ライブラリの一部です。また、いくつかの&lt;a href=&quot;../io/c&quot;&gt;CスタイルのI / O&lt;/a&gt;関数と、&lt;a href=&quot;../chrono/c&quot;&gt;CスタイルのDate&lt;/a&gt;からの変換も提供します。</target>
        </trans-unit>
        <trans-unit id="d0be451883776fa4f5f243412345fc9b51386469" translate="yes" xml:space="preserve">
          <source>This header provides miscellaneous utilities. Symbols defined here are used by several library components.</source>
          <target state="translated">このヘッダは雑多なユーティリティを提供します。ここで定義されているシンボルは、いくつかのライブラリコンポーネントで使用されます。</target>
        </trans-unit>
        <trans-unit id="3d8521103b2fed33ffe104b06e729876d4b7f2c8" translate="yes" xml:space="preserve">
          <source>This header provides support for &lt;a href=&quot;../utility/variadic&quot;&gt;C-style variadic functions&lt;/a&gt;.</source>
          <target state="translated">このヘッダーは、&lt;a href=&quot;../utility/variadic&quot;&gt;Cスタイルの可変関数の&lt;/a&gt;サポートを提供します。</target>
        </trans-unit>
        <trans-unit id="1f5444765226ce0bdb5af9dadf8c355721e6f565" translate="yes" xml:space="preserve">
          <source>This header supplies implementation-dependent information about the standard library (such as implementation-specific library version macros).</source>
          <target state="translated">このヘッダは、標準ライブラリに関する実装依存の情報(実装固有のライブラリバージョンマクロなど)を提供します。</target>
        </trans-unit>
        <trans-unit id="e3d2a98c9481a36d1f279d320f5b70a26a7e3330" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="9a392d9aa2ebe01e48b3d01961d845f5d0588e04" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="21d14ed988bc023e0af2e53864603e6cda2885be" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="68c78f91644f281b447ad60cdbb1634c09a9119a" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="02e483f5fd629df3b87fff596e49a80d8b8c0425" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="e6e03bbb8695dbcceecc16e98c0e964b5fefd852" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、もともと &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="d59783125b891e429043f2f2d5f576fd72a06c1c" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、元は &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="02fccbdf35494b28df2accdc8d41b5a89580c3c0" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="db14ba2bad874c7dde2374ac32527f2c381efc33" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、もともと &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="53af078bd74b84f0423e1e9211b917adea77b920" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="4fc6197b328bad98f05fff68010e58025c14a9b1" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="98d8ce7d2ea217c30464e6a8895e55e50e6eb6dd" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="4db152ded5e9f8b82696d238d20533a05044bdc8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="dbf2ebc0d4f0372f0d23dcfc1ff48e2cc5e172fa" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="552c8fb5c454bd957020620ff32c98f913c6ec6f" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="f1fc778831b537c9627fb3177ad740d51c764464" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="ea55cad81c5a499ab61c2f336f793e79c2cde22b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="c4e4679e2a1edfcea3588f047e41db14f9335c2e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="b100c9fc2e0568f0798665b7418667c38edba953" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="f9724180e3c20c4e3ccde319664bad3907db8ef2" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="6d57c16a998701ee531191c284ccfc0598fb9ad8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、もともと &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="aeb4dad38844729f6a773adfa6b26a2500e3724e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、もともと &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="78466c124900e096d16d9eac15396f90464c889b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、もともと &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="1bc1e66e0693def74a913c9f83e9fd4b6579b986" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="a2e4ff735f64305108a77807fb191c4cc62d9e14" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="16d7a74374a4accebff96ae1f6f2de097d3b0cae" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このヘッダーは、最初は &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; としてC標準ライブラリにありました。</target>
        </trans-unit>
        <trans-unit id="aedb64fc9e75ef3b36a2ef43e03fc20db3e03e5b" translate="yes" xml:space="preserve">
          <source>This holds for every objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that are not aliases of one another.</source>
          <target state="translated">これは、お互いのエイリアスではないすべてのオブジェクト &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; に当てはまります。</target>
        </trans-unit>
        <trans-unit id="05ebbbf417474068cc1404af21d2b363f30ea1c1" translate="yes" xml:space="preserve">
          <source>This implies that the class has no &lt;a href=&quot;../language/virtual&quot;&gt;virtual functions&lt;/a&gt; or &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtual base classes&lt;/a&gt;.</source>
          <target state="translated">これは、クラスに&lt;a href=&quot;../language/virtual&quot;&gt;仮想関数&lt;/a&gt;または&lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;仮想基本クラス&lt;/a&gt;がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="2f0ae52b3b410d1e9be7d3f883c6f57fc4873c3a" translate="yes" xml:space="preserve">
          <source>This includes &lt;a href=&quot;type-id&quot;&gt;integral types&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointer types&lt;/a&gt;, &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, as well as enumeration types with no custom &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; overload, but excludes floating-point types.</source>
          <target state="translated">これには、&lt;a href=&quot;type-id&quot;&gt;整数型&lt;/a&gt;、&lt;a href=&quot;pointer&quot;&gt;ポインター型&lt;/a&gt;、&lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;メンバー型へのポインター&lt;/a&gt;、 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 、およびカスタム &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; オーバーロードのない列挙型が含まれますが、浮動小数点型は含まれません。</target>
        </trans-unit>
        <trans-unit id="d9b2e0a6f64a6667926bbe46e5290f95959e8907" translate="yes" xml:space="preserve">
          <source>This information is provided via specializations of the &lt;code&gt;numeric_limits&lt;/code&gt; template. The standard library makes available specializations for all arithmetic types:</source>
          <target state="translated">この情報は、 &lt;code&gt;numeric_limits&lt;/code&gt; テンプレートの特殊化を介して提供されます。標準ライブラリは、すべての算術型に利用可能な特殊化を提供します。</target>
        </trans-unit>
        <trans-unit id="30fa8f162edae84e00655c850b76032946d786f6" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">これは、&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt;場合 &lt;code&gt;V&lt;/code&gt; のモデル&lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt;場合 &lt;code&gt;V&lt;/code&gt; のモデル&lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; &lt;/a&gt;そう。</target>
        </trans-unit>
        <trans-unit id="8b29d4dc98b35c7b6aae2a923e6c330c4c737570" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Advanceable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Decrementable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Incrementable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">これは、&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; &lt;/a&gt;もし &lt;code&gt;W&lt;/code&gt; モデル_Advanceable、&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt;場合 &lt;code&gt;W&lt;/code&gt; モデル_Decrementable、&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt;場合 &lt;code&gt;W&lt;/code&gt; モデル&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Incrementable&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; &lt;/a&gt;そう。</target>
        </trans-unit>
        <trans-unit id="ab311fc847c477a15d5b1d9860db2b6b4cc68c90" translate="yes" xml:space="preserve">
          <source>This is a copy of the the private mutable &lt;code&gt;weak_ptr&lt;/code&gt; member that is part of &lt;code&gt;enable_shared_from_this&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;enable_shared_from_this&lt;/code&gt; の一部であるプライベートな可変の &lt;code&gt;weak_ptr&lt;/code&gt; メンバーのコピーです。</target>
        </trans-unit>
        <trans-unit id="9c2a70dd0a39c1457e77f347c24e87c6d5cad7cb" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.</source>
          <target state="translated">これは C++で予約済みのキーワードの一覧です。これらのキーワードは言語によって使用されるため、再定義やオーバーロードでは使用できません。</target>
        </trans-unit>
        <trans-unit id="317fe1d241fce7e8d40b91008c64f80e35d56f6c" translate="yes" xml:space="preserve">
          <source>This is a low-level data structure; typical conversions from &lt;code&gt;local_time&lt;/code&gt; to &lt;code&gt;sys_time&lt;/code&gt; will use it implicitly rather than explicitly.</source>
          <target state="translated">これは低レベルのデータ構造です。 &lt;code&gt;local_time&lt;/code&gt; から &lt;code&gt;sys_time&lt;/code&gt; への一般的な変換では、明示的にではなく暗黙的に使用します。</target>
        </trans-unit>
        <trans-unit id="06fb932be30caede5a481a8189299e404a6d4974" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C++ language constructs.</source>
          <target state="translated">これは、C++言語のコアコンストラクトの参照です。</target>
        </trans-unit>
        <trans-unit id="e31b548ee1fbca7fa6d3494affb746a0a1a2457c" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the largest value representable by the type &lt;code&gt;std::size_t&lt;/code&gt;, used as the return type of &lt;code&gt;index()&lt;/code&gt; when &lt;code&gt;valueless_by_exception()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;std::size_t&lt;/code&gt; 型で表現可能な最大値に等しい特別な値であり、 &lt;code&gt;valueless_by_exception()&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合に &lt;code&gt;index()&lt;/code&gt; の戻り型として使用されます。</target>
        </trans-unit>
        <trans-unit id="a39c0c855473751858895d7068c8ca7b082d5f62" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index.</source>
          <target state="translated">これは、タイプ &lt;code&gt;size_type&lt;/code&gt; で表現できる最大値に等しい特別な値です。正確な意味はコンテキストによって異なりますが、通常は、文字列インデックスを期待する関数による文字列の終了インジケーターとして、または文字列インデックスを返す関数によるエラーインジケーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="8ef208e1bc26501dbfeecb667b7796cbd9eef4a6" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of view indicator by the functions that expect a view index or as the error indicator by the functions that return a view index.</source>
          <target state="translated">これは、タイプ &lt;code&gt;size_type&lt;/code&gt; で表現できる最大値に等しい特別な値です。正確な意味はコンテキストによって異なりますが、一般的には、ビューインデックスを予期する関数によるビュー終了インジケーターとして、またはビューインデックスを返す関数によるエラーインジケーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="2d9f89f3207c56d0f6ab075de354388d63d28553" translate="yes" xml:space="preserve">
          <source>This is a specialized allocator-aware container. It can only be default created, obtained from &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, or modified by &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt;. Because &lt;code&gt;std::match_results&lt;/code&gt; holds &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine &lt;code&gt;std::match_results&lt;/code&gt; if the original character sequence was destroyed or iterators to it were invalidated for other reasons.</source>
          <target state="translated">これは、専用のアロケータ対応コンテナです。デフォルトでのみ作成、 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; から取得、または &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; によって変更できます。 &lt;code&gt;std::match_results&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; esを保持するため、それぞれが一致した元の文字シーケンスへのイテレータのペアであるため、元の文字シーケンスが破壊されたか、イテレータがあった場合に &lt;code&gt;std::match_results&lt;/code&gt; を調べることは未定義の動作です。他の理由で無効にされました。</target>
        </trans-unit>
        <trans-unit id="dcbd4929cfc88985415e596c60e165a57a093570" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このI / Oマニピュレータである、それはのような表現で呼ばれることも &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; いずれかの &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; の任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937bf19df4c0af79385dda35f013197f369e8f37" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、I / Oマニピュレータである、それはのような表現で呼ばれることも &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; 任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b42315a6cd8a7f333df8749952b733651d2fec90" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、のような表現で呼ばれることも、I / Oマニピュレータある &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; 任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70463fd9c90aded7947bc0ce3158695492cf938d" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、のような表現で呼ばれることも、I / Oマニピュレータある &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; 任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf76b611f62f218dd5340fb19c1a0b0493038e0e" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、I / Oマニピュレータである、それはのような表現で呼ばれることも &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; 任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b963cb12fe265e17a4ede1e827c0c6875636dad" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、のような表現で呼ばれることも、I / Oマニピュレータある &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; 任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0de5a017268c93f9adb1760286b7389369587a" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、のような表現で呼ばれることも、I / Oマニピュレータある &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; の任意のため &lt;code&gt;in&lt;/code&gt; のタイプは &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf2205ff27f5d190edd20850443509692eb70e0" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これはI / Oマニピュレータです。それは、次のような表現で呼ばれることも &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; 任意のための &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現で &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; の任意のために &lt;code&gt;in&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9f3502e7e7df95e12c9da2ae171edd9ba6a04db" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これはI / Oマニピュレータです。それは、次のような表現で呼ばれることも &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; いずれかの &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; かのような表現と &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; いずれかの &lt;code&gt;in&lt;/code&gt; タイプの &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c0b02e3721ebe7f5ac3c4b5ffc6c0f2d28f4fc9" translate="yes" xml:space="preserve">
          <source>This is an N:M conversion facet, and cannot be used with &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これはN：M変換ファセットであり、 &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; （内部エンコーディングと外部エンコーディング間の1：N変換（UTF-32 / UTF-8など）のみを許可する）では使用できません。このファセットは &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="8f532dd6dda7ce4e7fef9024ca6a90c38fdddd97" translate="yes" xml:space="preserve">
          <source>This is an input-only I/O manipulator, it may be called with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは入力専用のI / Oマニピュレーターです &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 型のすべての &lt;code&gt;in&lt;/code&gt; に対して &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; などの式で呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e42acc2eabf231ad6ab330a8662f12700cd267a5" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、出力専用I / Oマニピュレータであり、それはのような式で呼ばれてもよい &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; 任意用 &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60e12fb0d661bde8d9b081c1cd879d866b874d0f" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、出力専用I / Oマニピュレータであり、それはのような式で呼ばれてもよい &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; 任意用 &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="651708b37cd7ae8cdbb511a6453c7ac66edb7063" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、出力専用I / Oマニピュレータであり、それはのような式で呼ばれてもよい &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; 任意用 &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb0b93b12bb860d769cac7587fe1bddc043d0e17" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、出力専用I / Oマニピュレータであり、それはのような式で呼ばれてもよい &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; 任意用 &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297f17cae564feba63e3617363eb17ca7ff29374" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、出力専用I / Oマニピュレータであり、それはのような式で呼ばれてもよい &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; 任意用 &lt;code&gt;out&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="042aa022f3538e0380d9238f1617babc4f91044d" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="6d1a687deef64a2de24aab2940536db537dc7c30" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="8519863f445ff4dc4073c63885010fc835c9d17f" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="36ff5f6b7bbdd8db83afcceb063e1cc859a416c7" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="82ad146be2cb4f18f794320cb99236e3f0e5a7de" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="786b3029313db82a7b7425ea04d749d77cb88554" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; および &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="acd8409ce8140988c0f9cd5273c17f072a8e1133" translate="yes" xml:space="preserve">
          <source>This is no longer allowed in C++17. Instead the array form &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; should be used.</source>
          <target state="translated">これはC ++ 17では許可されなくなりました。代わりに、配列形式 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="873c5086291117573f8d6d6edce6a8a27dcea191" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from (i.e. returned by &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt;) until the first time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">これは、デフォルトで構築または（すなわちによって返さから移動されませんでした先物のためのケースで &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt; 最初まで）時間 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cf0f969d26a72355354c117d383b2d725eed3830" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from. Unlike &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::shared_future&lt;/code&gt;'s shared state is not invalidated when &lt;code&gt;get()&lt;/code&gt; is called.</source>
          <target state="translated">これは、デフォルトで構築または移動されなかった先物にのみ当てはまります。 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;get()&lt;/code&gt; が呼び出されたときに &lt;code&gt;std::shared_future&lt;/code&gt; の共有状態は無効になりません。</target>
        </trans-unit>
        <trans-unit id="654479f728093b995df666411bdb28aa8834e6ea" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">これは、&lt;a href=&quot;../language/typeid&quot;&gt;typeid&lt;/a&gt;演算子によって返されるクラスです。</target>
        </trans-unit>
        <trans-unit id="a54fb420dbec256007f5b5fe39b66f1e973e225c" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">これは、&lt;a href=&quot;language/typeid&quot;&gt;typeid&lt;/a&gt;演算子によって返されるクラスです。</target>
        </trans-unit>
        <trans-unit id="b68e57b066a7bc6709ae7f2c462030b2b3f61772" translate="yes" xml:space="preserve">
          <source>This is the continuous counterpart of &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; 継続的な対応物です。</target>
        </trans-unit>
        <trans-unit id="4bd023e111f5d2be5d722aa1cd31d0bb87464c42" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with an empty initializer.</source>
          <target state="translated">これは、変数が空のイニシャライザで構築されたときに行われる初期化です。</target>
        </trans-unit>
        <trans-unit id="e592a74f67ac1f9613e037ec54f2110302e91afd" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with no initializer.</source>
          <target state="translated">イニシャライザがない状態で変数を構築したときに行われる初期化です。</target>
        </trans-unit>
        <trans-unit id="df01ca6b36b691a562048440349e8dc25830ccb7" translate="yes" xml:space="preserve">
          <source>This is the iterator returned by member functions &lt;code&gt;rbegin()&lt;/code&gt; and &lt;code&gt;rend()&lt;/code&gt; of the standard library containers.</source>
          <target state="translated">これは、標準ライブラリコンテナのメンバー関数 &lt;code&gt;rbegin()&lt;/code&gt; および &lt;code&gt;rend()&lt;/code&gt; によって返されるイテレータです。</target>
        </trans-unit>
        <trans-unit id="f5ad9a77cced8620a8dd7901ec2fb07df1c2718e" translate="yes" xml:space="preserve">
          <source>This is the only publicly accessible and defined constructor.</source>
          <target state="translated">これは、唯一公開されている定義済みのコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="678d1fe5005da438d1e76e438f6b694064724ab0" translate="yes" xml:space="preserve">
          <source>This is the only way to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to a definite value: the value held after any other initialization is unspecified.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; を明確な値に初期化する唯一の方法です。他の初期化後に保持される値は指定されていません。</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">ほとんどのマルチバイトエンコーディング(UTF-8など)では、それらの文字をエンコードするためにシングルバイトを使用しているため、これは通常ASCII文字セットの文字に対して可能です。</target>
        </trans-unit>
        <trans-unit id="4d2e82e79a4c00e49cbeb6cd456e401a3f7c67b6" translate="yes" xml:space="preserve">
          <source>This is used to capture move-only types with a capture such as &lt;code&gt;x = std::move(x)&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;x = std::move(x)&lt;/code&gt; などのキャプチャで移動のみのタイプをキャプチャするために使用されます。</target>
        </trans-unit>
        <trans-unit id="0d03b82ce1e09a94b53a9663441cf142803eed2e" translate="yes" xml:space="preserve">
          <source>This is used, for example, by &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt;, which may have to allocate new storage and then move or copy elements from old storage to new storage. If an exception occurs during this operation, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; undoes everything it did to this point, which is only possible if &lt;code&gt;std::move_if_noexcept&lt;/code&gt; was used to decide whether to use move construction or copy construction. (unless copy constructor is not available, in which case move constructor is used either way and the strong exception guarantee may be waived).</source>
          <target state="translated">これは、たとえば &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; によって使用され、新しいストレージを割り当ててから、要素を古いストレージから新しいストレージに移動またはコピーする必要があります。この操作中に例外が発生した場合、 &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; はこの時点までに行ったすべての操作を取り消します。これは、 &lt;code&gt;std::move_if_noexcept&lt;/code&gt; を使用して移動構築とコピー構築のどちらを使用するかを決定した場合にのみ可能です。 （コピーコンストラクターが使用できない場合を除き、その場合、ムーブコンストラクターはいずれかの方法で使用され、強力な例外保証が免除される場合があります）。</target>
        </trans-unit>
        <trans-unit id="65497cbcaeca38825fa3feca97f3678010e28f07" translate="yes" xml:space="preserve">
          <source>This lookup with the reversed arguments order makes it possible to write just one &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; to generate all comparisons between &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;const char*&lt;/code&gt;, both ways. See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for more detail.</source>
          <target state="translated">引数の順序を逆にしてこのルックアップを行うと、1つの &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; を記述して、 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;const char*&lt;/code&gt; 間のすべての比較を両方の方法で生成できます。詳細については、&lt;a href=&quot;default_comparisons&quot;&gt;デフォルトの比較&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7c00bd2988f8e6fd1c69153710829dd41df339f1" translate="yes" xml:space="preserve">
          <source>This macro is primarily provided for compatibility with C; it behaves the same as the constructor of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このマクロは主にCとの互換性のために提供されています。これは &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; コンストラクターと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="69dae22caf55af4023255754b9c726f9f5527dad" translate="yes" xml:space="preserve">
          <source>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</source>
          <target state="translated">これにより、値による構造体の返り値を渡すことにペナルティを課すABIであっても、基礎となる整数型と同じ既存の呼び出し規約を享受できる新しい整数型(SafeIntなど)を導入することが可能になります。</target>
        </trans-unit>
        <trans-unit id="1fced9487368a0914863ecd65a116e588baecbc7" translate="yes" xml:space="preserve">
          <source>This makes it possible to move out of an object in scope that is no longer needed:</source>
          <target state="translated">これにより、不要になったスコープ内のオブジェクトを移動させることが可能になります。</target>
        </trans-unit>
        <trans-unit id="9c4ec0eda49a5a6eec06bfb350abc5e50dec706c" translate="yes" xml:space="preserve">
          <source>This manipulator is typically used with &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt;, when the associated output buffer needs to be null-terminated to be processed as a C string.</source>
          <target state="translated">このマニピュレータは通常、関連する出力バッファをC文字列として処理するためにnullで終了する必要がある場合に、 &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt; とともに使用されます。</target>
        </trans-unit>
        <trans-unit id="0d033cddb2872a1515d402a6be03415f6aa84c5a" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O. In most other usual interactive I/O scenarios, &lt;code&gt;std::endl&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;. Use of &lt;code&gt;std::endl&lt;/code&gt; in place of &lt;code&gt;'\n'&lt;/code&gt;, encouraged by some sources, may significantly degrade output performance.</source>
          <target state="translated">このマニピュレーターを使用して、出力の行をすぐに生成できます。たとえば、長時間実行プロセスからの出力を表示するとき、複数のスレッドのアクティビティをログに記録したり、予期せずクラッシュする可能性のあるプログラムのログアクティビティを記録したりできます。生成されたプロセスが画面I / Oを実行する場合は、 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 呼び出す前に &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; の明示的なフラッシュも必要です。他のほとんどの通常のインタラクティブI / Oシナリオでは、 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; からの入力、 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; への出力、またはプログラムの終了により &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; 強制的に呼び出されるため、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; と一緒に使用すると &lt;code&gt;std::endl&lt;/code&gt; は冗長になります。.flush（）。 &lt;code&gt;'\n'&lt;/code&gt; 代わりに &lt;code&gt;std::endl&lt;/code&gt; 使用は、一部のソースで推奨されており、出力パフォーマンスを大幅に低下させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c4f2d1bbb43a26f1c14fa7b3e243baca9ad4d3dc" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce an incomplete line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O (a common example is &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; on Windows). In most other usual interactive I/O scenarios, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;.</source>
          <target state="translated">このマニピュレータを使用して、不完全な出力行をすぐに生成できます。たとえば、長時間実行プロセスからの出力、複数のスレッドのアクティビティのログ、または予期せずクラッシュする可能性のあるプログラムのログのアクティビティを表示する場合などです。生成されたプロセスが画面I / Oを実行する場合（一般的な例はWindowsの &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; （ &quot;pause&quot;））、 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 呼び出す前に &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; の明示的なフラッシュも必要です。他のほとんどの通常のインタラクティブI / Oシナリオでは、 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; からの入力、 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; への出力、またはプログラムの終了により &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; 強制的に呼び出されるため、 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; と一緒に使用すると &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; は冗長になります。。流す（）。</target>
        </trans-unit>
        <trans-unit id="b8bc45ac3ed46d59a0178ef3c27e45979eabda25" translate="yes" xml:space="preserve">
          <source>This may be used to avoid unnecessary &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; fences when the dependency chain leaves function scope (and the function does not have the &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; attribute).</source>
          <target state="translated">これは、依存関係チェーンが関数のスコープを離れた場合（および関数に &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; &lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carry_dependency&lt;/a&gt; ]]属性がない場合）、不要な &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; フェンスを回避するために使用できます。</target>
        </trans-unit>
        <trans-unit id="56eb878738bcafe0dda45a9b25b2771a66434232" translate="yes" xml:space="preserve">
          <source>This may happen if the pointer is assigned to:</source>
          <target state="translated">ポインタが代入されている場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="263227da37307b0a3267455a4c633b69bc493839" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;match[i].position()&lt;/code&gt; gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to &lt;code&gt;regex_search&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;match[i].position()&lt;/code&gt; は、ターゲットシーケンスの先頭からのオフセットを提供します。これは、多くの場合、 &lt;code&gt;regex_search&lt;/code&gt; への呼び出しで渡されたシーケンスからのオフセットと同じではありません。</target>
        </trans-unit>
        <trans-unit id="2cdccbba38d49dbd4067105548f38475359bb552" translate="yes" xml:space="preserve">
          <source>This means that in a conforming implementation, including this header has no effect.</source>
          <target state="translated">これは、適合する実装では、このヘッダを含めても何の効果もないことを意味します。</target>
        </trans-unit>
        <trans-unit id="558bc6404fe9a7280ef6a558ff20ea8606c413a8" translate="yes" xml:space="preserve">
          <source>This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.</source>
          <target state="translated">これは、要素にエイリアスが存在しないことを意味し、このプロパティを使用してある種の最適化を行うことができます。</target>
        </trans-unit>
        <trans-unit id="81b15552e359daa797fa96a9d36a5f3772826f69" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.</source>
          <target state="translated">この仕組みでは、関数呼び出し式として書き換える以外に、演算子のテンプレート引数を指定する構文がないため、テンプレート演算子を利用することができます。</target>
        </trans-unit>
        <trans-unit id="baabe2e811ea477176a6b1ba57aacf61a6c0bf94" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</source>
          <target state="translated">この仕組みでは、関数呼び出し式として書き換える以外に、演算子のテンプレート引数を指定する構文がないため、テンプレート演算子を利用することができます。</target>
        </trans-unit>
        <trans-unit id="631b5699cc80fd8b4a70a5399e59151e856f7a18" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; invokes undefined behavior. Note that &lt;code&gt;basic_ios&lt;/code&gt; is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary.</source>
          <target state="translated">このメンバー関数は保護されています。関連付けられたストリームバッファーが &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; と、派生ストリームクラスstd :: basic_istreamおよび &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; のコンストラクターによって呼び出されます。この関数が呼び出されるまで、デフォルトで構築された &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; すべてのメンバー関数（デストラクタを含む）は未定義の動作を呼び出します。 &lt;code&gt;basic_ios&lt;/code&gt; は仮想基本クラスであるため、そのコンストラクターは直接派生したクラスのコンストラクターによって呼び出されないため、2段階の初期化が必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ff0b24c8b1bcff91c847b5b05e80e90bc1f2ed8" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the move constructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; needs to be made aware of the stream's new location so that its public member functions can access it.</source>
          <target state="translated">このメンバー関数は保護されています： &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; などの派生ストリームのmoveコンストラクターによって呼び出されます。基本クラスを構築し、ストリームバッファーを移動した後の最後のステップとして、最も派生したストリームのみが呼び出されます。クラスはストリームバッファーを正しく移動する方法を知っていますが、 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; は、そのパブリックメンバー関数がアクセスできるように、ストリームの新しい場所を認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c3c6a60b1284f57464c304d4f49e3141a9265a5" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the protected move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;, which, in turn, are called by the public move constructors of the further derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">このメンバー関数は保護されています。これは、派生ストリームクラス &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; の保護されたmoveコンストラクターによって呼び出され、次に、 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; などの派生ストリームクラスのpublic moveコンストラクターによって呼び出されます:: basic_ofstreamは、関連するストリームバッファを正しく移動する方法を知っています。</target>
        </trans-unit>
        <trans-unit id="6018aedea85c8af7152a8d08f9289d2de94a185f" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the swap member functions of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated stream buffers.</source>
          <target state="translated">このメンバー関数は保護されています。派生ストリームクラス &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; のスワップメンバー関数によって呼び出されます。これらの関数は、関連付けられたストリームバッファーを正しくスワップする方法を知っています。</target>
        </trans-unit>
        <trans-unit id="194eca0c3ce225b7c17b35f16086bbd18ea24522" translate="yes" xml:space="preserve">
          <source>This metafunction is a convenient way to leverage &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; to conditionally remove functions from &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; based on type traits and to provide separate function overloads and specializations for different type traits. &lt;code&gt;std::enable_if&lt;/code&gt; can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.</source>
          <target state="translated">このメタ関数は、&lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt;を活用して、型特性に基づいて関数を&lt;a href=&quot;../language/overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;から条件付きで削除し、異なる型特性に個別の関数オーバーロードと特殊化を提供する便利な方法です。 &lt;code&gt;std::enable_if&lt;/code&gt; は、追加の関数引数（演算子のオーバーロードには適用されません）、戻り値の型（コンストラクターとデストラクターには適用されません）、またはクラステンプレートまたは関数テンプレートパラメーターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="a1422282434c61f7b9a780c953c50b153fde9dfb" translate="yes" xml:space="preserve">
          <source>This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context:</source>
          <target state="translated">このメタ関数は、 SFINAE コンテキスト内の不正な型を検出するためのテンプレートメタプログラミングで使用されます。</target>
        </trans-unit>
        <trans-unit id="1a68dc4a214d5a2f0c86986f5fcbb662600bbbaa" translate="yes" xml:space="preserve">
          <source>This only applies if the arithmetic is two's complement which is only required for the &lt;a href=&quot;../types/integer&quot;&gt;exact-width integer types&lt;/a&gt;. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</source>
          <target state="translated">これは、算術演算が2の補数の場合にのみ適用され&lt;a href=&quot;../types/integer&quot;&gt;ます&lt;/a&gt;。これは、正確な幅の整数型にのみ必要です。ただし、現時点では、C ++コンパイラを備えたすべてのプラットフォームで2の補数演算が使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="28bba53040cc59e4ebfb5e6b23947d5f3e555523" translate="yes" xml:space="preserve">
          <source>This operation</source>
          <target state="translated">この操作</target>
        </trans-unit>
        <trans-unit id="ee376cb133ce3fa6134bf19377f3a3fc9a03d186" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">この操作は通常、&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;融合型積和演算&lt;/a&gt; CPU命令としてハードウェアに実装されます。ハードウェアでサポートされている場合、適切な &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; マクロが定義されることが期待されますが、多くの実装では、マクロが定義されていない場合でもCPU命令を利用します。</target>
        </trans-unit>
        <trans-unit id="677f69ad7dd084269c9619b79f0d75fdd900458e" translate="yes" xml:space="preserve">
          <source>This operation is stable: for equivalent elements in the two lists, the elements from &lt;code&gt;*this&lt;/code&gt; shall always precede the elements from &lt;code&gt;other&lt;/code&gt;, and the order of equivalent elements of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; does not change.</source>
          <target state="translated">この操作は安定しています。2つのリストの同等の要素の場合、 &lt;code&gt;*this&lt;/code&gt; の要素は常に &lt;code&gt;other&lt;/code&gt; の要素の前にあり、 &lt;code&gt;*this&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; の同等の要素の順序は変わりません。</target>
        </trans-unit>
        <trans-unit id="e1a54e7ed923b5cbda29b41bb3cef5210c3e3c16" translate="yes" xml:space="preserve">
          <source>This operator does not check whether the optional contains a value! You can do so manually by using &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; or simply &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt;. Alternatively, if checked access is needed, &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">この演算子は、オプションに値が含まれているかどうかをチェックしません！ &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; または単に &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt; を使用して手動で行うことができます。または、チェック済みアクセスが必要な場合は、 &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="76837e505361cd0d1e62fe926fca10a41668aadc" translate="yes" xml:space="preserve">
          <source>This operator is declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to this operator can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">この演算子は、名前空間で宣言されている &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; 両方、 &lt;code&gt;literals&lt;/code&gt; と &lt;code&gt;chrono_literals&lt;/code&gt; はインライン名前空間です。この演算子へのアクセスはして得ることができる &lt;code&gt;using namespace std::literals&lt;/code&gt; 、 &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; 、および &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c90a4015c270f47b35bf150eaa6f8ff8b7041fe0" translate="yes" xml:space="preserve">
          <source>This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; or &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt;. Such loops execute the loop's body only if the input operation succeeded.</source>
          <target state="translated">この演算子により、ストリームへの参照をループ条件として返すストリームおよび関数を使用できるようになり、 &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; や &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt; などの慣用的なC ++入力ループになります。{...}。このようなループは、入力操作が成功した場合にのみ、ループの本体を実行します。</target>
        </trans-unit>
        <trans-unit id="70eb80993771f43d98c8f63a162d2abf81c3b412" translate="yes" xml:space="preserve">
          <source>This order determines the order in which constraints are instantiated when checking for satisfaction.</source>
          <target state="translated">この順序は、満足度をチェックする際に制約がインスタンス化される順序を決定します。</target>
        </trans-unit>
        <trans-unit id="ebf5e8fbc6ec56b576aeb159cdeac4bba0a41f70" translate="yes" xml:space="preserve">
          <source>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この順序付けは、通常 &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; 介して、共有およびウィークポインターを連想コンテナーのキーとして使用できるようにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="e1a82251ba96a19d119ca9bfa58e9f2f497a9f62" translate="yes" xml:space="preserve">
          <source>This overload does not subtract the parsed offset (if any) from the parsed timestamp, unlike the &lt;code&gt;from_stream&lt;/code&gt; overloads for the &lt;code&gt;time_point&lt;/code&gt; of other clocks.</source>
          <target state="translated">このオーバーロードは、他のクロックの &lt;code&gt;time_point&lt;/code&gt; の &lt;code&gt;from_stream&lt;/code&gt; オーバーロードとは異なり、解析されたタイムスタンプから解析されたオフセット（存在する場合）を減算しません。</target>
        </trans-unit>
        <trans-unit id="4bf7c4e2eb5387c99cb1a1ffeb6f0e5e88754a17" translate="yes" xml:space="preserve">
          <source>This overload doesn't participate in overload resolution if &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is not</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; がそうでない場合、このオーバーロードはオーバーロード解決に参加しません</target>
        </trans-unit>
        <trans-unit id="bc6f7584722885d728d6854cb8736855f9270a48" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (1) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; が整数型の場合、このオーバーロードはオーバーロード（1）と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="1fa4602d949f8f6973ff6fea1f4b9e68fc722e4c" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (3) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; が整数型の場合、このオーバーロードはオーバーロード（3）と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="7a8485de9a7d7bca2cd829541418ca26242baca3" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (6) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; が整数型の場合、このオーバーロードはオーバーロード（6）と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="70e5d40a020e1e29942bf932764b7fdcf68a80bf" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rbegin&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; はメンバー関数 &lt;code&gt;rbegin&lt;/code&gt; がないため、このオーバーロードが必要です。過負荷をするために必要ではない &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; それはの面で実装されているため &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ade89453e12ddb644d64137481026bf6616fd814" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rend&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; はメンバー関数 &lt;code&gt;rend&lt;/code&gt; がないため、このオーバーロードが必要です。 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; て実装されているため、std :: crendにオーバーロードは必要ありません。</target>
        </trans-unit>
        <trans-unit id="83116be95b91d59c09d4b41fc31292dca9c27808" translate="yes" xml:space="preserve">
          <source>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</source>
          <target state="translated">このオーバーロードにより、式の結果(関数呼び出しなど)を転送参照引数の元の値カテゴリとしてrvalueまたはlvalueで転送することが可能になります。</target>
        </trans-unit>
        <trans-unit id="814368a4e79aa44fdd2b8a96b22ebf135a87ef17" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true.  Note that &lt;code&gt;lock&lt;/code&gt; must be acquired before entering this method, and it is reacquired after &lt;code&gt;wait(lock)&lt;/code&gt; exits, which means that &lt;code&gt;lock&lt;/code&gt; can be used to guard access to &lt;code&gt;pred()&lt;/code&gt;.</source>
          <target state="translated">この過負荷は、特定の条件がtrueになるのを待つ間、偽の目覚めを無視するために使用できます。このメソッドに入る前に &lt;code&gt;lock&lt;/code&gt; 取得する必要があり、 &lt;code&gt;wait(lock)&lt;/code&gt; の終了後にロックが再取得されることに注意してください。つまり、 &lt;code&gt;pred()&lt;/code&gt; へのアクセスを保護するために &lt;code&gt;lock&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="7a8eb3282f5afae84e29833c36cc610e1de569a0" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious wakeups.</source>
          <target state="translated">このオーバーロードは、スプリアスなウェイクアップを無視するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="7c7c9be7921bc5aca3e14ee52c3bb2b260dbf024" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if</source>
          <target state="translated">このオーバーロードは、以下の場合にのみオーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="337c9fa9042558efca853cc7d8b71cfcdf68fa7c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type. The program is ill-formed if this constructor is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;Deleter&lt;/code&gt; がポインター型でない場合にのみ、オーバーロード解決に参加します。このコンストラクタが&lt;a href=&quot;../../language/deduction_guide&quot;&gt;クラステンプレート引数deduction&lt;/a&gt;によって選択されている場合、プログラムの形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="bdb1577a846fa638ef9c34146d7b837c8cfaff57" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;</source>
          <target state="translated">このオーバーロードは、すべての &lt;code&gt;i&lt;/code&gt; に対して &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロードの解決に参加します</target>
        </trans-unit>
        <trans-unit id="a2aee11b4d79b3a5270ceef56a825350cf5c37c2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; 両方が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="f2c027e2ce963431b11c8b99a81bfd995a2cc23b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="687473bac79368096aa9ed3ccf13fad71a9af81b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; がtrueの場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="1224a3aab62459562f6b5317091c0ef8684c06e6" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (3).</source>
          <target state="translated">場合には、このオーバーロードは、オーバーロード解決に関与 &lt;code&gt;InputIt&lt;/code&gt; はとしての資格&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;過負荷（3）を用いて曖昧さを避けるために、。</target>
        </trans-unit>
        <trans-unit id="4a089419777f0efe565129e644b4712117969f47" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as an &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; のとしての資格&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a09d792b815aa7158d605c39a17d568db1e73837" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (2).</source>
          <target state="translated">場合には、このオーバーロードは、オーバーロード解決に関与 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;過負荷（2）との曖昧さを避けるために、。</target>
        </trans-unit>
        <trans-unit id="f321cae2fd6e4fe1eb7c60fdcbc221e29351732f" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">このオーバーロードは、場合にのみ、オーバーロードの解決に参加 &lt;code&gt;InputIt&lt;/code&gt; 満たす&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84fbda8e9476b834f4eff0a23e019d728cbe538b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;N == 0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;N == 0&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="5843b6cae5eeb5b966317747e078206da1c4f50c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an unsigned integer type (that is, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, or an extended unsigned integer type).</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;T&lt;/code&gt; が符号なし整数型（つまり、 &lt;code&gt;unsigned char&lt;/code&gt; 、 &lt;code&gt;unsigned short&lt;/code&gt; 、 &lt;code&gt;unsigned int&lt;/code&gt; 、 &lt;code&gt;unsigned long&lt;/code&gt; 、 &lt;code&gt;unsigned long long&lt;/code&gt; 、または拡張された符号なし整数型）である場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="c6e60dbde6c8fbc3507ef1d94ecfd0c08c022a59" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 特殊化でない場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="29384bbe452ccd42b0340a2c398a159c418dc484" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; and &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; are both true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; と &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; 両方が &lt;code&gt;Types...&lt;/code&gt; すべての &lt;code&gt;T_i&lt;/code&gt; に当てはまる場合にのみ、オーバーロードの解決に参加します...</target>
        </trans-unit>
        <trans-unit id="dc0ee950915984baafe9981e2de7fbbd58afb03e" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; is a valid expression.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; が有効な式である場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="213ea4feb3d364f895c517e5bb074dd31d585156" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; and both &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; are &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; で、 &lt;code&gt;To&lt;/code&gt; と &lt;code&gt;From&lt;/code&gt; の両方が&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;型である場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="114c800d36b0c72a9adfc7fc9888fa4bbb2bb7e2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; あり、 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; がすべての &lt;code&gt;i&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロードの解決に参加します。</target>
        </trans-unit>
        <trans-unit id="47f721ed5d5ad88fd42fa2395ca7086485e17473" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 両方が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します</target>
        </trans-unit>
        <trans-unit id="2f1425caf63dd41a44a75daddc54c5b669d9e819" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 両方が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加します</target>
        </trans-unit>
        <trans-unit id="db813f0c83ff1627df30808c046963cca19b044a" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; および &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; あり、 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合にのみ、オーバーロード解決に参加しますすべての &lt;code&gt;i&lt;/code&gt; ために。</target>
        </trans-unit>
        <trans-unit id="bfc7e8a0241026e6c0b8875fd31fd121edcd01be" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt;.</source>
          <target state="translated">このオーバーロードは、 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; で、 &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt; 場合にのみ、オーバーロード解決に参加します。</target>
        </trans-unit>
        <trans-unit id="bea87dfd18560dbaabd48c593a450285fb991964" translate="yes" xml:space="preserve">
          <source>This page describes the core language feature adopted for C++20. For named type requirements used in the specification of the standard library, see &lt;a href=&quot;../named_req&quot;&gt;named requirements&lt;/a&gt;. For the Concepts TS version of this feature, see &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">このページでは、C ++ 20に採用されたコア言語機能について説明します。標準ライブラリの仕様で使用される名前付きタイプの要件については、&lt;a href=&quot;../named_req&quot;&gt;名前付き要件を&lt;/a&gt;参照してください。この機能のコンセプトTSバージョンについては、&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;こちらを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="88455b072941af9e8a59177f52c213a26676d97c" translate="yes" xml:space="preserve">
          <source>This partial code fragment illustrates how &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:</source>
          <target state="translated">この部分的なコードフラグメントは、 &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; を使用して、スレッドローカルが破壊されている最中に、スレッドローカルに依存するデータにアクセスしないようにする方法を示しています。</target>
        </trans-unit>
        <trans-unit id="7c5fecf341fbcf23eb1c8bab2cc52b3d4ac7b65d" translate="yes" xml:space="preserve">
          <source>This problem may be worked around using init-statement:</source>
          <target state="translated">この問題はinit-statementを使用することで回避できるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6fb590b83ec483a8b56a2365c3f69fb2ed4d882e" translate="yes" xml:space="preserve">
          <source>This process is called</source>
          <target state="translated">このプロセスは、以下のように呼ばれています。</target>
        </trans-unit>
        <trans-unit id="a7c693f3363fc29f57e0a818f5fcc2fa68ec620d" translate="yes" xml:space="preserve">
          <source>This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping).</source>
          <target state="translated">このプログラムは、与えられた文字列の最初と最後に同時に見つかる最長の部分文字列を、逆の順序で決定します(重複する可能性があります)。</target>
        </trans-unit>
        <trans-unit id="eafef78a966daecd6d7bcd73bf31b0e1e5ad496e" translate="yes" xml:space="preserve">
          <source>This program simulates throwing 6-sided dice.</source>
          <target state="translated">このプログラムは、6面サイコロを投げるシミュレーションを行います。</target>
        </trans-unit>
        <trans-unit id="2ea85151fe97fd5e5b0aa44d16e405ebe318a32c" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt;&lt;code&gt;basic_streambuf::sungetc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt;&lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt;&lt;/a&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">この保護された仮想関数は、パブリック関数&lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt; &lt;code&gt;basic_streambuf::sungetc&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt; &lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt; &lt;/a&gt;（次に、&lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt;によって呼び出されます）によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="996fa56c79f2b555734e9e9593669a195ee9fc8b" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;) when either:</source>
          <target state="translated">この保護された仮想関数は、次のいずれかの場合に、パブリック関数 &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; （次に、&lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt;によって呼び出される）によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="01f04b9a6bf8f295e5a70f9d8714851ba0b2aba1" translate="yes" xml:space="preserve">
          <source>This regenerates the hash table.</source>
          <target state="translated">これはハッシュテーブルを再生成します。</target>
        </trans-unit>
        <trans-unit id="2062b86cfcefc181f616f82dcb480679b9c947da" translate="yes" xml:space="preserve">
          <source>This rule also appears in the C++ Core Guidelines as &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: If you can avoid defining default operations, do&lt;/a&gt;.</source>
          <target state="translated">このルールは、C ++コアガイドラインでも&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20&lt;/a&gt;として表示されます。デフォルトの操作を定義しないようにできる場合は、を実行してください。</target>
        </trans-unit>
        <trans-unit id="4ac284d6084ae4faac12c7c88cba2efd5c565f23" translate="yes" xml:space="preserve">
          <source>This rule applies during overload resolution of function templates: When &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;substituting&lt;/a&gt; the explicitly specified or &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced type&lt;/a&gt; for the template parameter fails, the specialization is discarded from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt; instead of causing a compile error.</source>
          <target state="translated">このルールは、関数テンプレートのオーバーロードの解決時に適用されます。テンプレートパラメーターの明示的に指定または&lt;a href=&quot;template_argument_deduction&quot;&gt;推定された型の&lt;/a&gt;&lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;置換&lt;/a&gt;が失敗すると、コンパイルエラーを発生させる代わりに、特殊化が&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロードセット&lt;/a&gt;から破棄されます。</target>
        </trans-unit>
        <trans-unit id="d7cbe3e2801d332154dbf0acb579c831d5324d92" translate="yes" xml:space="preserve">
          <source>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</source>
          <target state="translated">このルールにより、型ベースのエイリアス解析が可能になります。このルールでは、コンパイラは、ある型の glvalue を通して読み込まれた値が、別の型の glvalue への書き込みによって変更されないと仮定します (上記の例外を除いて)。</target>
        </trans-unit>
        <trans-unit id="0ed01ea49dcd8fc7a8834c7e1f6f57d09b9ceaaf" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.</source>
          <target state="translated">このセクションでは、C++プログラミング言語を記述する際に使用される特定の用語と概念の定義を提供します。</target>
        </trans-unit>
        <trans-unit id="28ad28e60d5a5cc2b8a106dc95cfe732a7105f9e" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that all objects of type &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; この特殊化は、タイプ &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; すべてのオブジェクトがサポートすることを他のライブラリコンポーネントに通知します</target>
        </trans-unit>
        <trans-unit id="8c6b990eab9edf93292f6979537f3edb00a094bd" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informs other library components that values of type &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; are enumerations that hold error codes, which makes them implicitly convertible and assignable to objects of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; この特殊化は、タイプ &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; 値がエラーコードを保持する列挙型であることを他のライブラリコンポーネントに通知し、エラーコードを暗黙的に変換し、タイプ &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; オブジェクトに割り当てられるようにします。</target>
        </trans-unit>
        <trans-unit id="bdc8c9de3fc6d0e6ce5408d37d8e773fda6b9547" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that tuples support</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; この特殊化は、タプルがサポートする他のライブラリコンポーネントに通知します</target>
        </trans-unit>
        <trans-unit id="038a0d1d441b9b41c30e5117e6ae3ac1df058c8d" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 特殊化は、 &lt;code&gt;char&lt;/code&gt; 型の文字分類機能をカプセル化します。仮想関数を使用する汎用 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; とは異なり、この特殊化はテーブルルックアップを使用して文字を分類します（これは一般的に高速です）。</target>
        </trans-unit>
        <trans-unit id="fe9803ffee86bd599903f2123e0bb2aa07aae79a" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Like its base class &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; and unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt;, table lookup is used to classify characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; この特殊化は、 &lt;code&gt;char&lt;/code&gt; 型の文字分類機能をカプセル化します。基本クラス &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; と同様に、汎用 &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; とは異なり、文字の分類にはテーブル検索が使用されます。</target>
        </trans-unit>
        <trans-unit id="3ddf81e9b15f2fdf0bb22d822a3952f3ead8b84b" translate="yes" xml:space="preserve">
          <source>This specification may appear only on lambda-declarator or on a function declarator that is the top-level(until C++17) declarator of a function, variable, or non-static data member, whose type is a function type, a pointer to function type, a reference to function type, a pointer to member function type. It may appear on the declarator of a parameter or on the declarator of a return type.</source>
          <target state="translated">この仕様は、ラムダ宣言子、または関数型、関数型へのポインタ、関数型へのポインタ、関数型への参照、メンバ関数型へのポインタを型とする関数、変数、または非静的データ メンバの最上位(C++17 まで)宣言子である関数宣言子にのみ現れることがあります。これは、パラメータの宣言子、または戻り値型の宣言子に現れることがあります。</target>
        </trans-unit>
        <trans-unit id="95164148c00adc35d63c91ae48d3bfe549e3eabc" translate="yes" xml:space="preserve">
          <source>This swap function is protected: it is called by the swap member functions of the derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">このスワップ関数は保護されています。関連するストリーム &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; を正しくスワップする方法を知っている &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; やstd :: basic_istringstreamなどの派生ストリームクラスのスワップメンバー関数によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="203ee242898fb95403122a811df27a6f5e11668f" translate="yes" xml:space="preserve">
          <source>This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style &lt;code&gt;f(int n...)&lt;/code&gt; and C-style &lt;code&gt;f(int n, ...)&lt;/code&gt;.</source>
          <target state="translated">可変個引数のこの構文は、省略記号の前にコンマなしで1983 C ++で導入されました。C89がC ++の関数プロトタイプを採用したとき、C89は構文をコンマを必要とするものに置き換えました。互換性のために、C ++ 98はC ++スタイルの &lt;code&gt;f(int n...)&lt;/code&gt; とCスタイルの &lt;code&gt;f(int n, ...)&lt;/code&gt; 両方を受け入れます。</target>
        </trans-unit>
        <trans-unit id="90ab5c64e037f5bd0606d3f5a893f7a9a8254324" translate="yes" xml:space="preserve">
          <source>This technical specification is supported by GCC as of version 6.1 (requires &lt;code&gt;-fgnu-tm&lt;/code&gt; to enable). An older variant of this specification was &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;supported in GCC&lt;/a&gt; as of 4.7.</source>
          <target state="translated">この技術仕様はバージョン6.1の時点でGCCによってサポートされています（有効にするには &lt;code&gt;-fgnu-tm&lt;/code&gt; が必要です）。この仕様の古いバリアントは、4.7の時点&lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;でGCC&lt;/a&gt;でサポートされていました。</target>
        </trans-unit>
        <trans-unit id="419df6ad5807d184b62cd3a9400a351c6d85612c" translate="yes" xml:space="preserve">
          <source>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.</source>
          <target state="translated">この手法は、安定した ABI で C++ライブラリ・インターフェースを構築し、コンパイル時の依存性を軽減するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a685713d9d750fdc943f666575768010c6772551" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">このテンプレートは、ユーザー定義タイプに特化することができる &lt;code&gt;T&lt;/code&gt; 実現する&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;とを</target>
        </trans-unit>
        <trans-unit id="25830dd69fe1f966afb7508601b149f9651d15fd" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">このテンプレートは、ユーザー定義型に特化して、その型が &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 自動変換に適格であることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="921636ccd7ae628df6b1d450ba1978e54fd38c56" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">このテンプレートは、ユーザー定義型に特化して、その型が &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 自動変換に適格であることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="f8d9894e4d5b931e86a98ac460a720072feb42c9" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the assignment expression: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">この特性は、割り当て式の直接のコンテキスト以外では何もチェックしません &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;U&lt;/code&gt; の使用によりテンプレートの特殊化、暗黙的に定義された特別なメンバー関数の生成などがトリガーされ、それらにエラーがある場合、実際の割り当てはコンパイルされない場合があります。 &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; コンパイルされ、 &lt;code&gt;true&lt;/code&gt; に評価されます。</target>
        </trans-unit>
        <trans-unit id="eb8840cec417013032e8555b42ffbfcba15618b0" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the swap expressions: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">この特性は、スワップ式の直接のコンテキスト以外では何もチェックしません &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;U&lt;/code&gt; を使用すると、テンプレートの特殊化、暗黙的に定義された特別なメンバー関数の生成などがトリガーされ、それらにエラーがある場合、実際のスワップはコンパイルされない場合があります。 &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; コンパイルされ、 &lt;code&gt;true&lt;/code&gt; に評価されます。</target>
        </trans-unit>
        <trans-unit id="98c54288dcf9d77d236eeecd6daa6884dc0b5970" translate="yes" xml:space="preserve">
          <source>This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.</source>
          <target state="translated">この特性は、オブジェクト表現をバイト配列としてハッシュすることで、型が正しくハッシュされているかどうかを判断できるようにするために導入されました。</target>
        </trans-unit>
        <trans-unit id="aea90bedb8f6381211ab3408991531636fb5ffc1" translate="yes" xml:space="preserve">
          <source>This type can be specialized if the representation &lt;code&gt;Rep&lt;/code&gt; requires a specific implementation to return these duration objects.</source>
          <target state="translated">このタイプは、表現 &lt;code&gt;Rep&lt;/code&gt; がこれらの期間オブジェクトを返すために特定の実装を必要とする場合に特化できます。</target>
        </trans-unit>
        <trans-unit id="0087c0a1dcbf0b0f0625fe12349f4e248d5e9491" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy_file&quot;&gt;&lt;code&gt;copy_file()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">このタイプは、&lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;copy_file&quot;&gt; &lt;code&gt;copy_file()&lt;/code&gt; &lt;/a&gt;関数の動作を制御する使用可能なオプションを表します。</target>
        </trans-unit>
        <trans-unit id="9e417e5db45320da2073da483bb3a5847a750f26" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このタイプは、&lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; の&lt;/a&gt;動作を制御する使用可能なオプションを表します。</target>
        </trans-unit>
        <trans-unit id="ed15c087ab4da8efef6f8cef5da62d8cc51d1d4d" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the function &lt;a href=&quot;permissions&quot;&gt;&lt;code&gt;permissions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このタイプは、関数&lt;a href=&quot;permissions&quot;&gt; &lt;code&gt;permissions()&lt;/code&gt; の&lt;/a&gt;動作を制御する使用可能なオプションを表します。</target>
        </trans-unit>
        <trans-unit id="19b6990a7534cc1c45af33110b91b0350924b0e8" translate="yes" xml:space="preserve">
          <source>This type represents file access permissions. &lt;code&gt;perms&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">このタイプは、ファイルアクセス許可を表します。 &lt;code&gt;perms&lt;/code&gt; は&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;の要件を満たします（つまり、ビット型演算子 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 、 &lt;code&gt;operator|&lt;/code&gt; 、 &lt;code&gt;operator^&lt;/code&gt; 、 &lt;code&gt;operator~&lt;/code&gt; 、 &lt;code&gt;operator&amp;amp;=&lt;/code&gt; 、 &lt;code&gt;operator|=&lt;/code&gt; 、および &lt;code&gt;operator^=&lt;/code&gt; がこの型に対して定義されています）。</target>
        </trans-unit>
        <trans-unit id="157a64e0ec4c85a12b01b53324ef0dcdfb157238" translate="yes" xml:space="preserve">
          <source>This type requirement is deprecated in the C++ standard. All of its uses have been replaced by the more refined type requirements, such as &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;.</source>
          <target state="translated">この型の要件は、C ++標準では非推奨です。その使用法はすべて、&lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;などのより洗練された型要件に置き換えられました。</target>
        </trans-unit>
        <trans-unit id="23b4cbf67168a660a04e5a36fcd5bf13a48ffa59" translate="yes" xml:space="preserve">
          <source>This type trait is used by &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;. It may also be used by custom allocators or wrapper types to determine whether the object or member being constructed is itself capable of using an allocator (e.g. is a container), in which case an allocator should be passed to its constructor.</source>
          <target state="translated">このタイプの特性は、 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; によって使用されます。カスタムアロケーターまたはラッパータイプで使用して、構築中のオブジェクトまたはメンバー自体がアロケーターを使用できるかどうか（コンテナーなど）を判別することもできます。その場合、アロケーターをコンストラクターに渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="99d2afd28d674bc31d956763a004b7cd9b730d51" translate="yes" xml:space="preserve">
          <source>This type trait may be specialized for user-provided types that may be used as iterators. The standard library provides two partial specializations for pointer types T*, which makes it possible to use all iterator-based algorithms with raw pointers.</source>
          <target state="translated">この型特徴は、イテレータとして使用される可能性のあるユーザ提供型に対して特化されてもよい。標準ライブラリはポインタ型T*に対して2つの部分的な特殊化を提供しており、これにより、生のポインタを用いたすべてのイテレータベースのアルゴリズムを使用することが可能になります。</target>
        </trans-unit>
        <trans-unit id="c5c25f5c1d60bf97a090f5b80fe5a2c0ab183ce7" translate="yes" xml:space="preserve">
          <source>This type trait predates the &lt;a href=&quot;../language/alignof&quot;&gt;alignof keyword&lt;/a&gt;, which can be used to obtain the same value with less verbosity.</source>
          <target state="translated">このタイプの特性は、&lt;a href=&quot;../language/alignof&quot;&gt;alignofキーワード&lt;/a&gt;よりも古いものであり、冗長性を低くして同じ値を取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="e0410ce23d7ebcff7e3be952fdf86650da4cb323" translate="yes" xml:space="preserve">
          <source>This value typically reflects the theoretical limit on the size of the container, at most &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt;. At runtime, the size of the container may be limited to a value smaller than &lt;code&gt;max_size()&lt;/code&gt; by the amount of RAM available.</source>
          <target state="translated">この値は通常、コンテナのサイズの理論上の制限を反映しています。多くても &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt; です。実行時に、コンテナーのサイズは、使用可能なRAMの量によって &lt;code&gt;max_size()&lt;/code&gt; より小さい値に制限される場合があります。</target>
        </trans-unit>
        <trans-unit id="277c3ad089ba0f3cf12d3db7126822c9d80a4896" translate="yes" xml:space="preserve">
          <source>This variable has block scope and static storage duration:</source>
          <target state="translated">この変数は、ブロックスコープと静的な保存期間を持っています。</target>
        </trans-unit>
        <trans-unit id="fae180c729e28c3be7b371f92b90451d0013d47d" translate="yes" xml:space="preserve">
          <source>Those data members that correspond to captures without initializers are &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</source>
          <target state="translated">初期化子なしのキャプチャに対応するこれらのデータメンバーは、ラムダ式が評価されるときに&lt;a href=&quot;direct_initialization&quot;&gt;直接初期化&lt;/a&gt;されます。イニシャライザを使用したキャプチャに対応するものは、イニシャライザの必要に応じて初期化されます（コピーまたは直接初期化の可能性があります）。配列がキャプチャされる場合、配列要素はインデックスの昇順で直接初期化されます。データメンバーが初期化される順序は、それらが宣言される順序です（指定されていません）。</target>
        </trans-unit>
        <trans-unit id="f4a567a9b52d0caa922bc0235781e01fdf5d4c89" translate="yes" xml:space="preserve">
          <source>Thousands separator and decimal point characters are inserted as required by &lt;code&gt;mp.grouping()&lt;/code&gt;, &lt;code&gt;mp.frac_digits()&lt;/code&gt;, &lt;code&gt;mp.decimal_point()&lt;/code&gt;, and &lt;code&gt;mp.thousands_sep()&lt;/code&gt;, and the resulting string is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">&lt;code&gt;mp.grouping()&lt;/code&gt; 、 &lt;code&gt;mp.frac_digits()&lt;/code&gt; 、 &lt;code&gt;mp.decimal_point()&lt;/code&gt; 、および &lt;code&gt;mp.thousands_sep()&lt;/code&gt; の必要に応じて、数千の区切り文字と小数点文字が挿入され、結果の文字列は、 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; が現れる出力シーケンスに配置されます書式設定パターン。</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">スレッドの安全性</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">スレッドサポート</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">スレッドサポートライブラリ</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">スレッドとデータレース</target>
        </trans-unit>
        <trans-unit id="c1492359cb9886c9909e1a4316a9b1847c65e9e9" translate="yes" xml:space="preserve">
          <source>Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a &lt;a href=&quot;thread/thread&quot;&gt;constructor argument&lt;/a&gt;. The return value of the top-level function is ignored and if it terminates by throwing an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. The top-level function may communicate its return value or an exception to the caller via &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or by modifying shared variables (which may require synchronization, see &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">スレッドは、関連するスレッドオブジェクトが構築されるとすぐに実行を開始し（OSスケジューリングの遅延が保留中）、&lt;a href=&quot;thread/thread&quot;&gt;コンストラクター引数&lt;/a&gt;として提供されるトップレベルの関数から始まります。トップレベル関数の戻り値は無視され、例外がスローされて終了した場合は、 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; が呼び出されます。トップレベル関数は、 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; を介して、または共有変数を変更することによって、戻り値または例外を呼び出し元に通知する場合があります（同期が必要な場合があります &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 参照してください）。</target>
        </trans-unit>
        <trans-unit id="f4eb730a2ea2fcff234ce55322a48d3d91657b7e" translate="yes" xml:space="preserve">
          <source>Threads enable programs to execute across several processor cores.</source>
          <target state="translated">スレッドを使用することで、複数のプロセッサコアにまたがってプログラムを実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="a246e49f5181769dcbe8963551805985ea8e8c89" translate="yes" xml:space="preserve">
          <source>Three conditions where &lt;code&gt;std::bad_array_new_length&lt;/code&gt; should be thrown:</source>
          <target state="translated">&lt;code&gt;std::bad_array_new_length&lt;/code&gt; がスローされる3つの条件：</target>
        </trans-unit>
        <trans-unit id="b9e36378830759894e6fe278bd9aa261b8ff8830" translate="yes" xml:space="preserve">
          <source>Three-way comparison</source>
          <target state="translated">三元比較</target>
        </trans-unit>
        <trans-unit id="762d1a20f1e0eccc439b6c76140f77d0e64ffbd4" translate="yes" xml:space="preserve">
          <source>Three-way comparison can be automatically generated for class types, see &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt;.</source>
          <target state="translated">クラスタイプに対して3者間比較を自動的に生成でき&lt;a href=&quot;default_comparisons&quot;&gt;ます&lt;/a&gt;。デフォルトの比較を参照してください。</target>
        </trans-unit>
        <trans-unit id="89dc893d701abc8f17f1b70a529a23fb35201ff0" translate="yes" xml:space="preserve">
          <source>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (&lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; or one of the classes derived from it) as both the left operand and return type. Such operators are known as</source>
          <target state="translated">標準ライブラリ全体で、ビットごとのシフト演算子は、左のオペランドと戻りの型の両方として、一般にI / Oストリーム（ &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; またはそこから派生したクラスの1つ）でオーバーロードされます。このような演算子は次のように知られています</target>
        </trans-unit>
        <trans-unit id="f13c54f785e2da5ceb32427977752efac6c1f5cc" translate="yes" xml:space="preserve">
          <source>Throw any exception thrown by the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">現在インストールされている &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; によってスローされた例外をスローします。</target>
        </trans-unit>
        <trans-unit id="0ab6516c23d4a4cf955f60f3139340567e17455c" translate="yes" xml:space="preserve">
          <source>Throwing an exception is used to signal errors from functions, where &quot;errors&quot; are typically limited to only the following&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">例外のスローは、関数からのエラーを通知するために使用されます。「エラー」は通常、次の&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;のみに制限され&lt;sup id=&quot;cite_ref-3&quot;&gt;ます&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="7c890cb1e360c745fea29256ca1365d6a4c1baf1" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt;; may also any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; もし &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt; 。また、 &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; の呼び出しによってスローされた例外もあります。</target>
        </trans-unit>
        <trans-unit id="ef7207c238414b15063664465aad815055211c96" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 場合 &lt;code&gt;new_cap&lt;/code&gt; がより大きい &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e238d5140b17c25d7cced51cc7d8f65270714a" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if the length of the constructed string would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (for example, if &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; for (2)). Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 構成された文字列の長さを超える場合 &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; （例えば、 &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; のための（2））。 &lt;code&gt;Allocator::allocate&lt;/code&gt; 呼び出すとスローされる場合があります。</target>
        </trans-unit>
        <trans-unit id="5bd5e3a71ffb663ec4af5da4ee91146199c73db9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; もし &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0988508382bdadbf64519b871fd4199f1f7e88db" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if no such &lt;code&gt;time_zone&lt;/code&gt; can be found.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; そのような場合 &lt;code&gt;time_zone&lt;/code&gt; 見つからないことができます。</target>
        </trans-unit>
        <trans-unit id="0b00d37fc6c817e49da501c1d4283379499ed17c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; when errors occur, including errors from the underlying operating system that would prevent &lt;code&gt;lock&lt;/code&gt; from meeting its specifications. The mutex is not locked in the case of any exception being thrown.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 妨げるような基礎となるオペレーティングシステムからエラーを含むエラーが発生し、 &lt;code&gt;lock&lt;/code&gt; その仕様を満たしてからを。例外がスローされた場合、ミューテックスはロックされません。</target>
        </trans-unit>
        <trans-unit id="442b654cd69e928843823a7f4be327a06a469dea" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with error condition &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if the launch policy equals &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and the implementation is unable to start a new thread (if the policy is &lt;code&gt;async|deferred&lt;/code&gt; or has additional bits set, it will fall back to deferred or the implementation-defined policies in this case), or &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory for the internal data structures could not be allocated.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; エラー条件とを &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; 起動ポリシーが等しい場合 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; し、実装はポリシーがある場合（新しいスレッドを開始することができません &lt;code&gt;async|deferred&lt;/code&gt; または追加のビットがセットされています、この場合は据え置きポリシーまたは実装定義のポリシーにフォールバックします。または、内部データ構造のメモリを割り当てることができなかった場合は &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="7fd45fe2a76b5c26edcf480fd318099061d96452" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; かの &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; スローされます。</target>
        </trans-unit>
        <trans-unit id="61e7abab0e5d103b8f9ee327388ae0a478e7343f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if allocation fails.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 割り当てが失敗した場合。</target>
        </trans-unit>
        <trans-unit id="610b978856ae75c3eef4b6f3051d9b89a88b02ba" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; if any variant in &lt;code&gt;vars&lt;/code&gt; is &lt;a href=&quot;valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">例外 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; における任意の変形場合 &lt;code&gt;vars&lt;/code&gt; ある&lt;a href=&quot;valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ccf84cf2370a76be5d96fc6954ac7aa274274a8" translate="yes" xml:space="preserve">
          <source>Throws an exception if storage of the requested size and alignment cannot be obtained.</source>
          <target state="translated">要求されたサイズとアラインメントのストレージが得られない場合に例外をスローします。</target>
        </trans-unit>
        <trans-unit id="78d4655bb8c331d30d35c5dca21382a3023d8907" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exception derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; if a random number could not be generated.</source>
          <target state="translated">乱数を生成できなかった場合、 &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; から派生した実装定義の例外をスローします。</target>
        </trans-unit>
        <trans-unit id="c71eb890289859862d506be6577481a6155d7187" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exceptions derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">失敗すると &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; から派生した実装定義の例外をスローします。</target>
        </trans-unit>
        <trans-unit id="7035dd91c99b009a7736d3114cd02d3205a59146" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by &lt;code&gt;T&lt;/code&gt;'s constructor. If an exception is thrown, the previously contained object (if any) has been destroyed, and &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のコンストラクターによってスローされたすべての例外をスローします。例外がスローされた場合、以前に含まれていたオブジェクト（存在する場合）は破棄され、 &lt;code&gt;*this&lt;/code&gt; は値が含まれていません。</target>
        </trans-unit>
        <trans-unit id="c4b5347955a68d7b49fb60df96bc4c1fe1be392e" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のコンストラクターによってスローされたすべての例外をスローします。</target>
        </trans-unit>
        <trans-unit id="62b00b9bd5afe726c1c402b63375bc4866d56f7c" translate="yes" xml:space="preserve">
          <source>Throws no exceptions, unless the construction of &lt;code&gt;fd&lt;/code&gt; throws.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; の構築がスローされない限り、例外はスローされません。</target>
        </trans-unit>
        <trans-unit id="2e4fed0e085b765b71b25a3a55fd75c68b497a32" translate="yes" xml:space="preserve">
          <source>Throws no exceptions.</source>
          <target state="translated">例外はありません。</target>
        </trans-unit>
        <trans-unit id="c77dbbe1f17eaa70afe33271369b7e39a68c956a" translate="yes" xml:space="preserve">
          <source>Throws nothing unless calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource throws.</source>
          <target state="translated">アップストリームメモリリソースでthrow &lt;code&gt;allocate()&lt;/code&gt; を呼び出さない限り、何もスローしません。</target>
        </trans-unit>
        <trans-unit id="3473cebcbcfaf057526db12532a7e05950b9a394" translate="yes" xml:space="preserve">
          <source>Throws nothing.</source>
          <target state="translated">何も投げない。</target>
        </trans-unit>
        <trans-unit id="d36a7251aa285e37e60059fda10d55905771330c" translate="yes" xml:space="preserve">
          <source>Throws only if an operation on &lt;code&gt;dest&lt;/code&gt; throws.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; に対する操作がスローした場合にのみスローされます。</target>
        </trans-unit>
        <trans-unit id="1ec2a611e5f00a6feb428658f1aa68f1b6da7754" translate="yes" xml:space="preserve">
          <source>Throws the previously captured exception object, referred to by the exception pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">例外ポインタ &lt;code&gt;p&lt;/code&gt; によって参照される、以前にキャプチャされた例外オブジェクトをスローします。</target>
        </trans-unit>
        <trans-unit id="bcec7ea351c0f526e56ea2d8f983f85ec1b9038a" translate="yes" xml:space="preserve">
          <source>Thus, replacing the throwing single object deallocation functions (1,3) is sufficient to handle all deallocations.</source>
          <target state="translated">このように、投げる単一オブジェクトの解放関数(1,3)を置き換えるだけで、すべての解放を処理することができます。</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">時間操作</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">時間帯</target>
        </trans-unit>
        <trans-unit id="848d63dd0e0417a6a6d0653d6feba98b946a8d6e" translate="yes" xml:space="preserve">
          <source>Time point</source>
          <target state="translated">タイムポイント</target>
        </trans-unit>
        <trans-unit id="99536a3f0c0c578df6810c5e30a06d3b2da45179" translate="yes" xml:space="preserve">
          <source>Time point (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">タイムポイント（ &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b99a31f7aded92da84e5f21bdba7429ff03b583d" translate="yes" xml:space="preserve">
          <source>Time point family</source>
          <target state="translated">タイムポイントファミリー</target>
        </trans-unit>
        <trans-unit id="3e17e972e7d70a2b0ea19965e0edbbdd317996ef" translate="yes" xml:space="preserve">
          <source>Time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object on success or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;time&lt;/code&gt; cannot be represented as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">成功 &lt;code&gt;time&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; オブジェクトとしてのエポックからの時間、または時間を &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; オブジェクトとして表すことができない場合は &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baff479affe7646bf932c42ec983a595bbc4b1cf" translate="yes" xml:space="preserve">
          <source>Time tracking (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;), C-style date and time (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">時間の追跡（例： &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; ）、Cスタイルの日付と時刻（例： &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eea79afd832854a3b24153b928ee9c62c7457dbe" translate="yes" xml:space="preserve">
          <source>Time zone</source>
          <target state="translated">タイムゾーン</target>
        </trans-unit>
        <trans-unit id="932d3e6f9a587b1ed93ccda36b7118239840479f" translate="yes" xml:space="preserve">
          <source>Time zone pointer (denoted &lt;code&gt;zone&lt;/code&gt;)</source>
          <target state="translated">タイムゾーンポインター（ &lt;code&gt;zone&lt;/code&gt; と表示）</target>
        </trans-unit>
        <trans-unit id="40349a8ed2b426d8558214c08ff878c9b7836d5c" translate="yes" xml:space="preserve">
          <source>TimedLockable</source>
          <target state="translated">TimedLockable</target>
        </trans-unit>
        <trans-unit id="7a1979526d24991a3fdc66189422c80b7c9499d1" translate="yes" xml:space="preserve">
          <source>TimedMutex</source>
          <target state="translated">TimedMutex</target>
        </trans-unit>
        <trans-unit id="3d854366021896ce0345060f9138ad581720da11" translate="yes" xml:space="preserve">
          <source>To access the variadic arguments from the function body, the following library facilities are provided:</source>
          <target state="translated">関数本体から可変引数にアクセスするために、以下のライブラリ機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="2c3649f8d8e3f7fb8fa9a2e0b81692c7c0d56f26" translate="yes" xml:space="preserve">
          <source>To avoid data races, once a shared pointer is passed to any of these functions, it cannot be accessed non-atomically. In particular, you cannot dereference such a shared_ptr without first atomically loading it into another shared_ptr object, and then dereferencing through the second object.</source>
          <target state="translated">データ競合を避けるために、一度これらの関数に共有ポインタが渡されると、非原子的にアクセスすることはできません。特に、このような共有ポインタを別の shared_ptr オブジェクトにアトム的にロードしてから、2 番目のオブジェクトを介して参照を解除することはできません。</target>
        </trans-unit>
        <trans-unit id="7c35636471d229cbd245a9382f85e9b6dce24337" translate="yes" xml:space="preserve">
          <source>To avoid these quirks, &lt;code&gt;result_of&lt;/code&gt; is often used with reference types as &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt;. For example:</source>
          <target state="translated">これらの癖を回避するために、 &lt;code&gt;result_of&lt;/code&gt; は、 &lt;code&gt;F&lt;/code&gt; やArgs &lt;code&gt;Args...&lt;/code&gt; などの参照型でよく使用されます。例えば：</target>
        </trans-unit>
        <trans-unit id="9af4209978b81d53f6e3f0d4dfaa5d56a5095a25" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary copying of the exception object and object slicing, the best practice for catch clauses is to catch by reference.&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">例外オブジェクトとオブジェクトスライスの不必要なコピーを避けるために、catch句のベストプラクティスは参照によってキャッチすることです。&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32227a48661c43cebdc36000ab948c6c4f0e7732" translate="yes" xml:space="preserve">
          <source>To be included in the set of viable functions, the candidate function must satisfy the following:</source>
          <target state="translated">実行可能な関数の集合に含まれるためには、候補関数は以下の条件を満たさなければならない。</target>
        </trans-unit>
        <trans-unit id="1d9269c47d9ba025b6ff347184af6dae00b4781f" translate="yes" xml:space="preserve">
          <source>To call the function,</source>
          <target state="translated">関数を呼び出すこと。</target>
        </trans-unit>
        <trans-unit id="3e00e2418f0d13b96de319ccb14e33b157fe6ecf" translate="yes" xml:space="preserve">
          <source>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.</source>
          <target state="translated">関数テンプレートの呼び出しをコンパイルするには、コンパイラは、非テンプレート・オーバーロード、テンプレート・オーバーロード、テンプレート・オーバーロードの特殊化のいずれかを決定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="648fa0a42ad74259537f74f99862470566d205e4" translate="yes" xml:space="preserve">
          <source>To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a</source>
          <target state="translated">cv-qualified 型への参照やポインタを,以下のように変換します.</target>
        </trans-unit>
        <trans-unit id="479a613a1f4b0b411389efeda8d5cbee450b5792" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">閉じた間隔[a、b]にわたる分布を作成するには、 &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 2番目のパラメーターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="d960d66e52b0039243dd579fef5b5e0189abe40c" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">閉じた間隔[a、b]にわたる分布を作成するには、 &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 2番目のパラメーターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="99e393ae840d4dfdfd8ab0ea9c4989b21f3b3380" translate="yes" xml:space="preserve">
          <source>To declare a variadic function, an ellipsis is used as the last parameter, e.g. &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic arguments&lt;/a&gt; for additional detail on the syntax, automatic argument conversions and the alternatives.</source>
          <target state="translated">可変個関数を宣言するには、最後のパラメーターとして省略記号を使用します。例： &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt; 。構文、自動引数変換、および代替の詳細については、&lt;a href=&quot;../language/variadic_arguments&quot;&gt;可変引数&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="22cd3be1d2fb287ce824540ee1391a62cb561144" translate="yes" xml:space="preserve">
          <source>To ensure that the program benefits from the optimizations enabled by &lt;code&gt;assume_aligned&lt;/code&gt;, it is important to access the object via its return value:</source>
          <target state="translated">&lt;code&gt;assume_aligned&lt;/code&gt; によって有効化された最適化からプログラムが確実に恩恵を受けるには、戻り値を介してオブジェクトにアクセスすることが重要です。</target>
        </trans-unit>
        <trans-unit id="525fd31bb668048344f8a31de0c1142305eb7415" translate="yes" xml:space="preserve">
          <source>To generate enough entropy, &lt;code&gt;generate_canonical()&lt;/code&gt; will call &lt;code&gt;g()&lt;/code&gt; exactly k times, where \(k = max(1, \lceil \frac{b}{log_2 R} \rceil)\)k = max(1, &amp;lceil; b / log</source>
          <target state="translated">十分なエントロピーを生成するために、 &lt;code&gt;generate_canonical()&lt;/code&gt; は &lt;code&gt;g()&lt;/code&gt; を正確にk回呼び出します。ここで、\（k = max（1、\ lceil \ frac {b} {log_2 R} \ rceil）\）k = max（1、&amp;lceil;b /ログ</target>
        </trans-unit>
        <trans-unit id="2c0e3e28251239ee8bfb2240bdd1fc0f1ed54c3c" translate="yes" xml:space="preserve">
          <source>To grant access to additional functions or classes to protected or private members, a &lt;a href=&quot;friend&quot;&gt;friendship declaration&lt;/a&gt; may be used.</source>
          <target state="translated">保護されたメンバーまたはプライベートメンバーに追加の関数またはクラスへのアクセスを許可するには、&lt;a href=&quot;friend&quot;&gt;友情宣言&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="878939687f32a6c24537c7a73b290843588b7164" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal &lt;code&gt;nullptr&lt;/code&gt;, the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the integer value &lt;code&gt;​0​&lt;/code&gt; may be used.</source>
          <target state="translated">ヌルへのポインタを初期化するか、または既存のポインタにヌル値を割り当てるために、ヌル・ポインタリテラル &lt;code&gt;nullptr&lt;/code&gt; 、ヌルポインタ定数の &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 、または&lt;a href=&quot;implicit_cast&quot;&gt;暗黙の変換&lt;/a&gt;、整数値から &lt;code&gt;​0​&lt;/code&gt; 使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="e3122235602ec384e5e6446cb56e5141efaef34c" translate="yes" xml:space="preserve">
          <source>To iterate over the current directory, construct the iterator as &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; instead of &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">、カレントディレクトリを反復処理としてのイテレータを構築するために &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; の代わりに、 &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="724317f9ed9523d1d5aa4de4bf63c61feb5cf73f" translate="yes" xml:space="preserve">
          <source>To make ADL examine a user-defined namespace, either &lt;code&gt;std::vector&lt;/code&gt; should be replaced by a user-defined class or its element type should be a user-defined class:</source>
          <target state="translated">ADLでユーザー定義の名前空間を調べるには、 &lt;code&gt;std::vector&lt;/code&gt; をユーザー定義のクラスで置き換えるか、その要素型をユーザー定義のクラスにする必要があります。</target>
        </trans-unit>
        <trans-unit id="9dacb8ab35ec1963dda5bb3c402d87f89eb9adc7" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. For example, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; to choose between move and copy when the elements need to be relocated.</source>
          <target state="translated">強力な例外保証を可能にするために、ユーザー定義の移動コンストラクターは例外をスローしてはなりません。たとえば、 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; は、要素を再配置する必要がある場合に &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; を使用して移動とコピーのどちらを選択するかを決定します。</target>
        </trans-unit>
        <trans-unit id="fbaf135ff4214aca3306677fb2ad01282f0bd0a8" translate="yes" xml:space="preserve">
          <source>To match a template template argument &lt;code&gt;A&lt;/code&gt; to a template template parameter &lt;code&gt;P&lt;/code&gt;, each of the template parameters of &lt;code&gt;A&lt;/code&gt; must match corresponding template parameters of &lt;code&gt;P&lt;/code&gt; exactly(until C++17)&lt;code&gt;P&lt;/code&gt; must be at least as specialized as &lt;code&gt;A&lt;/code&gt;(since C++17). If &lt;code&gt;P&lt;/code&gt;'s parameter list includes a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, zero or more template parameters (or parameter packs) from &lt;code&gt;A&lt;/code&gt;'s template parameter list are matched by it.</source>
          <target state="translated">テンプレートテンプレート引数 &lt;code&gt;A&lt;/code&gt; をテンプレートテンプレートパラメーター &lt;code&gt;P&lt;/code&gt; に一致させるには、 &lt;code&gt;A&lt;/code&gt; の各テンプレートパラメーターが &lt;code&gt;P&lt;/code&gt; の対応するテンプレートパラメーターと完全に一致する必要があります（C ++ 17まで） &lt;code&gt;P&lt;/code&gt; は少なくとも &lt;code&gt;A&lt;/code&gt; と同じくらい特殊化されている必要があります（C ++ 17）。 &lt;code&gt;P&lt;/code&gt; のパラメーターリストに&lt;a href=&quot;parameter_pack&quot;&gt;パラメーターパックが&lt;/a&gt;含まれている場合、 &lt;code&gt;A&lt;/code&gt; のテンプレートパラメーターリストの0個以上のテンプレートパラメーター（またはパラメーターパック）がそれに一致します。</target>
        </trans-unit>
        <trans-unit id="1653fef798170fad22ce8f246671d9967ebf88bf" translate="yes" xml:space="preserve">
          <source>To provide multidimensional array access semantics, e.g. to implement a 3D array access &lt;code&gt;a[i][j][k] = x;&lt;/code&gt;, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading &lt;code&gt;operator()&lt;/code&gt; instead, so that 3D access expressions have the Fortran-like syntax &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</source>
          <target state="translated">多次元配列アクセスのセマンティクスを提供するには、たとえば3D配列アクセスを実装するには &lt;code&gt;a[i][j][k] = x;&lt;/code&gt; 、operator []は、2D平面への参照を返す必要があります。2D平面には、1D行への参照を返す独自のoperator []が必要です。これには、要素への参照を返すoperator []が必要です。この複雑さを回避するために、一部のライブラリは代わりに &lt;code&gt;operator()&lt;/code&gt; のオーバーロードを選択し、3Dアクセス式がFortranに似た構文 &lt;code&gt;a(i, j, k) = x;&lt;/code&gt; 持つようにします。</target>
        </trans-unit>
        <trans-unit id="106dedcf05132b51eabb9b06f962997250951fc9" translate="yes" xml:space="preserve">
          <source>To refer to a static member &lt;code&gt;m&lt;/code&gt; of class &lt;code&gt;T&lt;/code&gt;, two forms may be used: qualified name &lt;code&gt;T::m&lt;/code&gt; or member access expression &lt;code&gt;E.m&lt;/code&gt; or &lt;code&gt;E-&amp;gt;m&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression that evaluates to &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt; respectively. When in the same class scope, the qualification is unnecessary:</source>
          <target state="translated">静的メンバを参照するために &lt;code&gt;m&lt;/code&gt; クラスの &lt;code&gt;T&lt;/code&gt; 、2つの形式が使用されてもよい：修飾名 &lt;code&gt;T::m&lt;/code&gt; またはメンバアクセス式 &lt;code&gt;E.m&lt;/code&gt; または &lt;code&gt;E-&amp;gt;m&lt;/code&gt; 、 &lt;code&gt;E&lt;/code&gt; は、に評価される式であり、 &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T*&lt;/code&gt; それぞれ。同じクラススコープ内の場合、修飾は不要です。</target>
        </trans-unit>
        <trans-unit id="3726bd5210fa66b99d1405f1d23513ff4e9a847a" translate="yes" xml:space="preserve">
          <source>To reopen an existing namespace (formally, to be an</source>
          <target state="translated">既存の名前空間を再オープンするには(正式には</target>
        </trans-unit>
        <trans-unit id="6766595568bdee575215126dcd221dc1330e2532" translate="yes" xml:space="preserve">
          <source>To replace the managed object while supplying a new deleter as well, move assignment operator may be used.</source>
          <target state="translated">管理されているオブジェクトを置換しながら新しい削除器を供給するために、移動代入演算子を使用することができます。</target>
        </trans-unit>
        <trans-unit id="f22138cc2032a2d9e0e8461eb5887bb980094c3c" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators&quot;&gt;user-defined operator==&lt;/a&gt;.</source>
          <target state="translated">この要件を満たすために、組み込みの&lt;a href=&quot;../language/operator_comparison&quot;&gt;比較演算子&lt;/a&gt;を持たない型は、&lt;a href=&quot;../language/operators&quot;&gt;ユーザー定義の演算子==&lt;/a&gt;を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="129c710e9009508a2e1a7fdb48457bda967c930d" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;user-defined operator&amp;lt;&lt;/a&gt;</source>
          <target state="translated">この要件を満たすために、組み込み&lt;a href=&quot;../language/operator_comparison&quot;&gt;比較演算子&lt;/a&gt;を持たない型は、&lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;ユーザー定義演算子&lt;/a&gt;を提供する必要があります&amp;lt;</target>
        </trans-unit>
        <trans-unit id="17417ca14266e537b698e5e14276654d4c17a975" translate="yes" xml:space="preserve">
          <source>To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (decrementing requires stronger ordering to safely destroy the control block).</source>
          <target state="translated">参照カウンタは、通常の当量使用してインクリメントされ、スレッドの安全要件を満たすために &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; （減分は、制御ブロックを破壊安全に強い順序付けを必要とします）。</target>
        </trans-unit>
        <trans-unit id="8878bda84316e640272f36cf3fc4a73005bafae8" translate="yes" xml:space="preserve">
          <source>To simplify management of dynamically-allocated objects, the result of a new-expression is often stored in a</source>
          <target state="translated">動的に割り当てられたオブジェクトの管理を簡単にするために、新しい式の結果はしばしば</target>
        </trans-unit>
        <trans-unit id="72759510b678f958968f4cb0b51ad3056400cce9" translate="yes" xml:space="preserve">
          <source>To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.</source>
          <target state="translated">最後の2つの条件をテストするために、コンパイラは最初にイニシャライザの試行定数評価を行ってもよい。この場合の結果に依存することは推奨されません。</target>
        </trans-unit>
        <trans-unit id="2ef767a66957791708ed92649c40f252de18b675" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; (&lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; (&lt;/code&gt; arg1、arg2、... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd5e6c8eaf332caffe8f6fbe44a90cd7d1b98a0" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">TObjectを &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指示子 &lt;code&gt;=&lt;/code&gt; 引数1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指定子 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8524224705b06e86014d7113489a9fa766f785d6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; arg1、arg2、... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa04374ca1b3d5854920daae3a860b764cf4bc1" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg1、arg2、... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad21f03c3b6e98547a57e446e234ea4a3bc549c4" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73dc4cf67a69ee8abf0145c5834683df2e89c44e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8be85a4e1d42709d6cc3339f92d0ed646df7afbf" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;= {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;= {&lt;/code&gt; arg1、arg2、... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="749c4b6dafadee83198511f34995fe4793451e2c" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">TObjectを &lt;code&gt;=&lt;/code&gt; &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指示子 &lt;code&gt;=&lt;/code&gt; 引数1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指定子 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d34b7b6a63046c11e32cb28d0bfdc320edb9c6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;other&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; その他 &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0bdecf7ffe3b07ea0bd6237e1e29b32609b1b3" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709755aaf5485c722f9b0e75a1395ff736803b24" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg1、arg2、... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61782cc12972859d36df728c91f3cae207b1187e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f01015bfa0f56ac60d1e5a7cf450991d276e29b7" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{};&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;{};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb24f2589165d45d6ccb527543d8886fc657afc" translate="yes" xml:space="preserve">
          <source>Together with identifiers they are known as</source>
          <target state="translated">識別子と一緒に</target>
        </trans-unit>
        <trans-unit id="3eff2f682c2bec3252c55e73a2e17235c924d9ac" translate="yes" xml:space="preserve">
          <source>Toggles each &lt;code&gt;bool&lt;/code&gt; in the vector (replaces with its opposite value).</source>
          <target state="translated">ベクトルの各 &lt;code&gt;bool&lt;/code&gt; を切り替えます（反対の値に置き換えます）。</target>
        </trans-unit>
        <trans-unit id="f77fbd9a82d243179f6ff219e1e46df3d7caa6d5" translate="yes" xml:space="preserve">
          <source>Too many files open in system</source>
          <target state="translated">システムで開いているファイルが多すぎる</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">シンボリックリンクのレベルが高すぎる</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">リンクが多すぎる</target>
        </trans-unit>
        <trans-unit id="171702bf2e722b21f3bd6c8ccb2927b1ba5f9e5e" translate="yes" xml:space="preserve">
          <source>Total ordering relation opposite to &lt;code&gt;a &amp;lt; b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a &amp;lt; b&lt;/code&gt; とは逆の合計順序関係</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">完全なシーケンシャル順序付けは、すべてのマルチコアシステムでフルメモリフェンスCPU命令を必要とします。これは、影響を受けるメモリアクセスをすべてのコアに伝播させるため、パフォーマンスのボトルネックになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="ef3b5b7a3bf5164b6e6ee23c058ba72528930808" translate="yes" xml:space="preserve">
          <source>Trade-offs / usage notes</source>
          <target state="translated">トレードオフの使用上の注意</target>
        </trans-unit>
        <trans-unit id="7cf26da75debf6bbf1e4104795dc48892c4d5484" translate="yes" xml:space="preserve">
          <source>Trailing return type, useful if the return type depends on argument names, such as &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; or is complicated, such as in &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</source>
          <target state="translated">後続の戻り値の型。戻り値の型が &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; などの引数名に依存する場合に役立ちます。&amp;lt;class T、class U&amp;gt; auto add（T t、U u）-&amp;gt; decltype（t + u）; または、 &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt; などのように複雑である</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="cd91d96e3393ae0f62bad1c5ed125449050e450f" translate="yes" xml:space="preserve">
          <source>Transaction-safe functions</source>
          <target state="translated">トランザクションセーフ機能</target>
        </trans-unit>
        <trans-unit id="79ed6ec4dd6c977b5231ac5a3a3185c0bc9188fd" translate="yes" xml:space="preserve">
          <source>Transaction-safe virtual functions</source>
          <target state="translated">トランザクションセーフな仮想関数</target>
        </trans-unit>
        <trans-unit id="28bf6d401ae77b97e36abdf2221c6cfe2e85fc1e" translate="yes" xml:space="preserve">
          <source>Transactional memory</source>
          <target state="translated">トランザクションメモリ</target>
        </trans-unit>
        <trans-unit id="76f8221e9e089679019e2f0fa532136f150e6dc7" translate="yes" xml:space="preserve">
          <source>Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are.</source>
          <target state="translated">トランザクションメモリは、トランザクション内のステートメントのグループを組み合わせた同時実行同期メカニズムです。</target>
        </trans-unit>
        <trans-unit id="6b317497e33c505c0091e508e0f819e953607bb9" translate="yes" xml:space="preserve">
          <source>Transfers control to one of the several statements, depending on the value of a condition.</source>
          <target state="translated">条件の値に応じて、いくつかのステートメントのうちの1つに制御を移します。</target>
        </trans-unit>
        <trans-unit id="3ae0e89e8b68942479d9172eed374b0285eee3cc" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally.</source>
          <target state="translated">無条件に支配権を譲渡する。</target>
        </trans-unit>
        <trans-unit id="1f702e1322ae9e879ee08e3f62c5bdb1e12300d8" translate="yes" xml:space="preserve">
          <source>Transfers elements from one list to another.</source>
          <target state="translated">あるリストから別のリストに要素を移動します。</target>
        </trans-unit>
        <trans-unit id="3de309422c516a3c7cf8622a78d8e35f6e1be1eb" translate="yes" xml:space="preserve">
          <source>Transfers the shared state of &lt;code&gt;*this&lt;/code&gt;, if any, to a &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; object. Multiple &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; objects may reference the same shared state, which is not possible with &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; の共有状態があれば、それを &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; オブジェクトに転送します。複数の &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; オブジェクトが同じ共有状態を参照する場合がありますが、これは &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; では不可能です。</target>
        </trans-unit>
        <trans-unit id="17a159e3083a2a40c26d036cc1b99d55a3a0d7c4" translate="yes" xml:space="preserve">
          <source>Transform the elements of the output range according to the following algorithm:</source>
          <target state="translated">以下のアルゴリズムに従って出力範囲の要素を変換します。</target>
        </trans-unit>
        <trans-unit id="0d2ad20c7dacbba2fdbdd4ce378e8828c433c3a1" translate="yes" xml:space="preserve">
          <source>TransformationTrait</source>
          <target state="translated">TransformationTrait</target>
        </trans-unit>
        <trans-unit id="7bfde37a73ea6090d21989590088e7aade736914" translate="yes" xml:space="preserve">
          <source>TransformationTraits Redux</source>
          <target state="translated">トランスフォーメーションの特徴を再編集しました。</target>
        </trans-unit>
        <trans-unit id="4ce48d092354c3cfaf58f19e47f595e8893390a1" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an exclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;exclusive&quot; means that the i-th input element is not included in the i-th sum.</source>
          <target state="translated">範囲の変換の各要素は &lt;code&gt;[first, last)&lt;/code&gt; と &lt;code&gt;unary_op&lt;/code&gt; 、次に使用排他的プレフィックス和演算算出 &lt;code&gt;binary_op&lt;/code&gt; と、結果として得られる範囲にわたるを &lt;code&gt;init&lt;/code&gt; 初期値として、とで範囲先頭に結果を書き込む &lt;code&gt;d_first&lt;/code&gt; 。 「排他的」とは、i番目の入力要素がi番目の合計に含まれないことを意味します。</target>
        </trans-unit>
        <trans-unit id="76499db2839b046f9ef84418dd0b227738ab59b2" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an inclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, optionally with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;inclusive&quot; means that the i-th input element is included in the i-th sum.</source>
          <target state="translated">範囲の変換の各要素は &lt;code&gt;[first, last)&lt;/code&gt; と &lt;code&gt;unary_op&lt;/code&gt; 、次に使用包括プレフィックス和演算算出 &lt;code&gt;binary_op&lt;/code&gt; 任意に、得られた範囲に亘っを &lt;code&gt;init&lt;/code&gt; 初期値として、とで範囲先頭に結果を書き込む &lt;code&gt;d_first&lt;/code&gt; 。「含む」とは、i番目の入力要素がi番目の合計に含まれることを意味します。</target>
        </trans-unit>
        <trans-unit id="1c65f6d1ba0f638d5024c5624db7ea27406001c1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">変換は、ヌル終端バイト文字列がによって指さ &lt;code&gt;src&lt;/code&gt; 2つの形質転換された文字列を比較するように実装定義形式に &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; で、元の文字列を比較すると同じ結果が得られる &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; 現在のCロケールでは、。</target>
        </trans-unit>
        <trans-unit id="b23c453442ba4c19cf270e32634b19b7e31b8f29" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が指すnullで終了するワイド文字列を実装定義形式に変換します。変換された2つの文字列を &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; と比較すると、現在のCロケールで元の文字列を &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; と比較した場合と同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="e9473bce26df240bf7fc3c05c82131b0eac3181d" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the next permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the first permutation (as if by &lt;code&gt;std::sort(first, last)&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; を、 &lt;code&gt;operator&amp;lt;&lt;/code&gt; または &lt;code&gt;comp&lt;/code&gt; に関して辞書式順序で並べられたすべての順列のセットから次の順列に変換します。そのような順列が存在する場合は &lt;code&gt;true&lt;/code&gt; を返し、そうでない場合は（ &lt;code&gt;std::sort(first, last)&lt;/code&gt; よるかのように）最初の順列に範囲を変換し、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fb941d77364b3c591f0e4eb102ebc186c04f6079" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the previous permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the last permutation (as if by &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">範囲 &lt;code&gt;[first, last)&lt;/code&gt; を、 &lt;code&gt;operator&amp;lt;&lt;/code&gt; または &lt;code&gt;comp&lt;/code&gt; に関して辞書式順序で並べられたすべての順列のセットから、前の順列に変換します。そのような順列が存在する場合は &lt;code&gt;true&lt;/code&gt; を返し、そうでない場合は範囲​​を最後の順列に変換し（ &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt; ）、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5c2ca105c8eba32a022ebfb50e700557700476d5" translate="yes" xml:space="preserve">
          <source>Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.</source>
          <target state="translated">外部参照を満たすために必要な翻訳ユニット、インスタンス化ユニット、ライブラリコンポーネントは、その実行環境での実行に必要な情報を含むプログラムイメージに集められます。</target>
        </trans-unit>
        <trans-unit id="7d38d008dd097b51dab00ca0d0265de5ece13e59" translate="yes" xml:space="preserve">
          <source>Transparent operator functors (&lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</source>
          <target state="translated">透過的な演算子ファンクタ（ &lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f559c0b6272ddc2453ea357e3fd076a9c199929c" translate="yes" xml:space="preserve">
          <source>Tries to lock each of the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; by calling &lt;code&gt;try_lock&lt;/code&gt; in order beginning with the first.</source>
          <target state="translated">与えられたの各ロックしようと&lt;a href=&quot;../named_req/lockable&quot;&gt;ロック可能では&lt;/a&gt;オブジェクト &lt;code&gt;lock1&lt;/code&gt; 、 &lt;code&gt;lock2&lt;/code&gt; 、 &lt;code&gt;...&lt;/code&gt; 、 &lt;code&gt;lockn&lt;/code&gt; 呼び出すことによって &lt;code&gt;try_lock&lt;/code&gt; を最初から順にします。</target>
        </trans-unit>
        <trans-unit id="c4193e3be0c6f62e0de2fa977aca25d7c84cd476" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;.</source>
          <target state="translated">ブロックせずに、関連するミューテックスを共有モードでロックしようとします。効果的に &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="445a39a47a50a54d92796a9b19a41f46bc55486e" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">関連付けられたミューテックスを共有モードでロックしようとします。指定された &lt;code&gt;timeout_duration&lt;/code&gt; が経過するか、ロックが取得されるかのいずれか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。効果的に &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5d62e4c34ffec7ca2a5475cc557db13010bc5bb6" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">関連付けられたミューテックスを共有モードでロックしようとします。指定された &lt;code&gt;timeout_time&lt;/code&gt; に達するか、ロックが取得されるまで、どちらか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。 &lt;code&gt;timeout_time&lt;/code&gt; に達するまでよりも長い間ブロックされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="04ec6c6d28a28396ea8160dff620c7f0dfdc1cb4" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt;.</source>
          <target state="translated">ブロックせずに関連するミューテックスをロックしようとします。効果的に &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6391979884d59018323155d5442d884835e91f04" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">関連するミューテックスをロックしようとします。指定された &lt;code&gt;timeout_duration&lt;/code&gt; が経過するか、ロックが取得されるかのいずれか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。効果的に &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9a394eb5a6a96eb4cd0cc26ea32b6b9f1cd9d182" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">関連するミューテックスをロックしようとします。指定された &lt;code&gt;timeout_time&lt;/code&gt; に達するか、ロックが取得されるまで、どちらか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。 &lt;code&gt;timeout_time&lt;/code&gt; に達するまでよりも長い間ブロックされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="72f71ef27869580f57937ef46f54e56b64d5c90b" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the shared lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">共有モードでmutexをロックしようとします。指定された &lt;code&gt;timeout_duration&lt;/code&gt; が経過するか、共有ロックが取得されるまで、どちらか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="df7a6fe3b4499e718fdf154332580ad7e0556935" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">共有モードでmutexをロックしようとします。指定された &lt;code&gt;timeout_time&lt;/code&gt; に達するか、ロックが取得されるまで、どちらか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b6575b72289c55a38b072b5941884cdd93486461" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">共有モードでmutexをロックしようとします。すぐに戻ります。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="aaf4054705ad98c056fff4ec6d5fb719dbed8bab" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">mutexをロックしようとします。指定された &lt;code&gt;timeout_duration&lt;/code&gt; が経過するか、ロックが取得されるかのいずれか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2674b35e9268fb4c504fe5e2d2bb178899b976f5" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">mutexをロックしようとします。指定された &lt;code&gt;timeout_time&lt;/code&gt; に達するか、ロックが取得されるまで、どちらか早い方までブロックします。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e62eb4cb137d58a9975627d408c2d834c1eb07b2" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">mutexをロックしようとします。すぐに戻ります。ロックの取得に成功すると &lt;code&gt;true&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角関数</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="624b7d0a9acb19117360ca1ff7b46aba679ee393" translate="yes" xml:space="preserve">
          <source>Trigraphs (removed in C++17)</source>
          <target state="translated">トリグラフ(C++17 で削除されました。</target>
        </trans-unit>
        <trans-unit id="69f8428973485177159d95cfc6a7d68111da93c3" translate="yes" xml:space="preserve">
          <source>Trivial copy assignment operator</source>
          <target state="translated">トリビアルコピー代入演算子</target>
        </trans-unit>
        <trans-unit id="16966819b78d2f2d7ddd3b34badb4de1f0eb65b0" translate="yes" xml:space="preserve">
          <source>Trivial copy constructor</source>
          <target state="translated">トリビアルコピーコンストラクタ</target>
        </trans-unit>
        <trans-unit id="488ca1baf6cc68b8aa948384e1e53809bfb207a8" translate="yes" xml:space="preserve">
          <source>Trivial default constructor</source>
          <target state="translated">トリビアルなデフォルトコンストラクタ</target>
        </trans-unit>
        <trans-unit id="1418411e56b71fbadd57e0c387a8ef7df89b350e" translate="yes" xml:space="preserve">
          <source>Trivial destructor</source>
          <target state="translated">トリビアルデストロイヤー</target>
        </trans-unit>
        <trans-unit id="763ea1f3e981b84a927acd942aec71e9eacc4358" translate="yes" xml:space="preserve">
          <source>Trivial move assignment operator</source>
          <target state="translated">トリビアルムーブ代入演算子</target>
        </trans-unit>
        <trans-unit id="3f57a92cdd79d69c213d32b4b4bd7fbcb0c55720" translate="yes" xml:space="preserve">
          <source>Trivial move constructor</source>
          <target state="translated">トリビアルムーブのコンストラクタ</target>
        </trans-unit>
        <trans-unit id="80e20b4c9b75f288215983370eace6b3830f2454" translate="yes" xml:space="preserve">
          <source>TrivialClock</source>
          <target state="translated">TrivialClock</target>
        </trans-unit>
        <trans-unit id="ca5b69f8f16141b8ecbd3e5d55417b7f08e4df66" translate="yes" xml:space="preserve">
          <source>TrivialType</source>
          <target state="translated">TrivialType</target>
        </trans-unit>
        <trans-unit id="739bada034f0d62036e7eca3d1c171b7fb2990b4" translate="yes" xml:space="preserve">
          <source>TriviallyCopyable</source>
          <target state="translated">TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="2c34bab22f35dd84ab5cbfaaab89a66cdb64744f" translate="yes" xml:space="preserve">
          <source>Try blocks</source>
          <target state="translated">ブロックを試す</target>
        </trans-unit>
        <trans-unit id="ac5f250a73945a1c4524cddeb6862a489849434a" translate="yes" xml:space="preserve">
          <source>Try blocks provide the ability to catch exceptions thrown when executing other statements.</source>
          <target state="translated">Try ブロックは、他のステートメントを実行する際にスローされる例外をキャッチする機能を提供します。</target>
        </trans-unit>
        <trans-unit id="44a77a68bb962e7ff3fb9dc11c9de3319527edbe" translate="yes" xml:space="preserve">
          <source>Tt&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tt &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc53d2c6ca548777a6fc9b944e807c006a2c9d96" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;match_results&lt;/code&gt; are equal if the following conditions are met:</source>
          <target state="translated">次の条件が満たされている場合、2つの &lt;code&gt;match_results&lt;/code&gt; は等しくなります。</target>
        </trans-unit>
        <trans-unit id="d1e05e300f7cf45c9afa0f4cbce3042b969f9a51" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;memory_resource&lt;/code&gt;s compare equal if and only if memory allocated from one &lt;code&gt;memory_resource&lt;/code&gt; can be deallocated from the other and vice versa.</source>
          <target state="translated">二つ &lt;code&gt;memory_resource&lt;/code&gt; の Sは、IF等しい比較して一方から割り当てられたメモリ場合にのみ &lt;code&gt;memory_resource&lt;/code&gt; は、他の、およびその逆から割り当てを解除することができます。</target>
        </trans-unit>
        <trans-unit id="18e2cfdfc01b97bd020c553267d7b3079b8d27e3" translate="yes" xml:space="preserve">
          <source>Two accesses to the same object of type &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler. For each signal handler invocation, evaluations performed by the thread invoking a signal handler can be divided into two groups A and B, such that no evaluations in B</source>
          <target state="translated">型 &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; の同じオブジェクトへの2つのアクセスは、1つ以上がシグナルハンドラーで発生した場合でも、両方が同じスレッドで発生した場合、データ競合を引き起こしません。シグナルハンドラーの呼び出しごとに、シグナルハンドラーを呼び出すスレッドによって実行される評価は、AとBの2つのグループに分けられます。</target>
        </trans-unit>
        <trans-unit id="af211090fdec69c271770be6c158a8a93a7a9156" translate="yes" xml:space="preserve">
          <source>Two atomic constraints are considered</source>
          <target state="translated">2つの原子制約を考慮</target>
        </trans-unit>
        <trans-unit id="281cdcd9fceacdd0a42e26b288d042b3cef41c39" translate="yes" xml:space="preserve">
          <source>Two consecutive left square bracket tokens (&lt;code&gt;[[&lt;/code&gt;) may only appear when introducing an attribute-specifier or inside an attribute argument.</source>
          <target state="translated">2つの連続する左大括弧トークン（ &lt;code&gt;[[&lt;/code&gt; ）は、属性指定子を導入する場合、または属性引数の内部にのみ表示できます。</target>
        </trans-unit>
        <trans-unit id="60290606d4c62d76f3da7e32e693534176b08979" translate="yes" xml:space="preserve">
          <source>Two convenience typedefs are provided by the standard library.</source>
          <target state="translated">標準ライブラリでは、2つの便利な型定義が提供されています。</target>
        </trans-unit>
        <trans-unit id="7aa31cc07dd369014ec64e33766626d690657b52" translate="yes" xml:space="preserve">
          <source>Two empty ranges are lexicographically</source>
          <target state="translated">2つの空の範囲は語彙的に</target>
        </trans-unit>
        <trans-unit id="6b78b90a2edac1ec50aec2ddead8be1711dcb40b" translate="yes" xml:space="preserve">
          <source>Two expressions involving template parameters are called</source>
          <target state="translated">テンプレートパラメータを含む2つの式は</target>
        </trans-unit>
        <trans-unit id="401bc70a8b4f3d2ca441828fbf93f9236de2257b" translate="yes" xml:space="preserve">
          <source>Two function templates are considered</source>
          <target state="translated">2つの関数テンプレートが考えられます。</target>
        </trans-unit>
        <trans-unit id="9a61fe0c1252c74ede2b7eafa0a43c49b8412afe" translate="yes" xml:space="preserve">
          <source>Two functions with the same name and the same parameter list in the same namespace cannot have two different language linkages (note, however, that linkage of a parameter may permit such overloading, as in the case of &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt;). Likewise, two variables in the same namespace cannot have two different language linkages.</source>
          <target state="translated">同じ名前空間の同じ名前と同じパラメーターリストを持つ2つの関数は、2つの異なる言語リンケージを持つことはできません（ただし、パラメーターのリンケージにより、 &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt; 場合のように、そのようなオーバーロードが許可される場合があります）。同様に、同じ名前空間内の2つの変数に2つの異なる言語リンケージを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="4eb187c84dda2874b690bed58603b32136278ed1" translate="yes" xml:space="preserve">
          <source>Two global basic_istream objects are provided by the standard library.</source>
          <target state="translated">標準ライブラリでは、2つのグローバルなbasic_istreamオブジェクトが提供されています。</target>
        </trans-unit>
        <trans-unit id="c90f6f3b7bfcc952e158fda77bf6551f5a0e53dd" translate="yes" xml:space="preserve">
          <source>Two instances of &lt;code&gt;std::exception_ptr&lt;/code&gt; compare equal only if they are both null or both point at the same exception object.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 2つのインスタンスは、それらが両方ともnullであるか、両方が同じ例外オブジェクトを指している場合にのみ等しいと比較します。</target>
        </trans-unit>
        <trans-unit id="88171adec9acfe4a9d538ee2177a7d8b88253347" translate="yes" xml:space="preserve">
          <source>Two lists of contract conditions are the same if they contain the same contract conditions in the same order. Two contract conditions are the same if they are the same kind of contract condition and have the same contract-level and the same predicate. Two predicates are the same if they would satisfy the &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;one-definition rule&lt;/a&gt; were they to appear in function definitions, except for the renaming of function and template parameters and return value identifiers (if any).</source>
          <target state="translated">同じ契約条件が同じ順序で含まれている場合、契約条件の2つのリストは同じです。2つの契約条件は、それらが同じ種類の契約条件であり、同じ契約レベルおよび同じ述語を持つ場合、同じです。2つの述語は、関数とテンプレートのパラメーターの名前の変更と戻り値の識別子（ある場合）を除いて、&lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;1つの定義の規則&lt;/a&gt;を満たしていれば、関数の定義に現れれば同じです。</target>
        </trans-unit>
        <trans-unit id="0977497139bae8229d1cacd7b1fe5a5dee1adc52" translate="yes" xml:space="preserve">
          <source>Two objects</source>
          <target state="translated">二つのオブジェクト</target>
        </trans-unit>
        <trans-unit id="86ee35dfa9a139a871795ed018153e9a56ec14e3" translate="yes" xml:space="preserve">
          <source>Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">このタイプの2つのオブジェクトは逆参照でき、結果の値は、 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; とユーザー定義の &lt;code&gt;swap()&lt;/code&gt; の両方が表示されるコンテキストで非修飾関数呼び出し &lt;code&gt;swap()&lt;/code&gt; を使用して交換できます。</target>
        </trans-unit>
        <trans-unit id="e1ee0382cebdb37edb5b66d39ad57ccf190aa34e" translate="yes" xml:space="preserve">
          <source>Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; members of their POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat structure&lt;/a&gt;, obtained as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;, are equal.</source>
          <target state="translated">パスが解決する2つの候補エンティティが同じデバイスの同じ場所にある場合、2つのパスは同じファイルシステムエンティティに解決されると見なされます。POSIXのために、この手段は、こと &lt;code&gt;st_dev&lt;/code&gt; フィールドと &lt;code&gt;st_ino&lt;/code&gt; のそれらのPOSIXのメンバー&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat構造体&lt;/a&gt;のPOSIXたかのようにして得られた、&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;STATは&lt;/a&gt;、等しいです。</target>
        </trans-unit>
        <trans-unit id="437b76b7571ce600be5aa3f3e921a20de1e39123" translate="yes" xml:space="preserve">
          <source>Two ranges are compared element by element.</source>
          <target state="translated">2つの範囲を要素ごとに比較します。</target>
        </trans-unit>
        <trans-unit id="8ec06cfed5aca5636f6337ef590ec50fe665f57a" translate="yes" xml:space="preserve">
          <source>Two ranges are considered equal if they have the same number of elements and, for every iterator &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first1,last1)&lt;/code&gt;, &lt;code&gt;*i&lt;/code&gt; equals &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt;. The overloads (1,2,5,6) use &lt;code&gt;operator==&lt;/code&gt; to determine if two elements are equal, whereas overloads (3,4,7,8) use the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">2つの範囲は、要素の数が同じである場合に等しいと見なされ、範囲 &lt;code&gt;[first1,last1)&lt;/code&gt; すべての反復子 &lt;code&gt;i&lt;/code&gt; について、 &lt;code&gt;*i&lt;/code&gt; は &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt; と等しくなります。オーバーロード（1,2,5,6）は、 &lt;code&gt;operator==&lt;/code&gt; を使用して2つの要素が等しいかどうかを判別しますが、オーバーロード（3,4,7,8）は、指定されたバイナリ述語 &lt;code&gt;p&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1f3d6e085b1a690a184f8a241caaace1cd422427" translate="yes" xml:space="preserve">
          <source>Two specializations are provided by the standard library.</source>
          <target state="translated">標準ライブラリでは、2つの専門化が提供されています。</target>
        </trans-unit>
        <trans-unit id="9ea29714490f77c2342f60db455484af8982a069" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also defined:</source>
          <target state="translated">また、一般的な文字型のための2つの専門化も定義されています。</target>
        </trans-unit>
        <trans-unit id="395a556fd3ef9112d9577c9ebc5df6fd4309e718" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also provided:</source>
          <target state="translated">また、一般的な文字種のための2つの専門化も用意されています。</target>
        </trans-unit>
        <trans-unit id="abc68b66bf994ad49ab50a82c81510a0ae793170" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are defined:</source>
          <target state="translated">一般的な文字タイプのための2つの専門化が定義されています。</target>
        </trans-unit>
        <trans-unit id="644226c6c6857e7526a3f749326009205374c9cd" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; 2つの特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="38cc0b6c98f9bf0b6f230727bb0b37ccdc3ce423" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;std::regex_traits&lt;/code&gt; are defined by the standard library:</source>
          <target state="translated">&lt;code&gt;std::regex_traits&lt;/code&gt; 2つの特殊化は、標準ライブラリによって定義されています。</target>
        </trans-unit>
        <trans-unit id="1c45317442511240ca7c73c4b544304cf52c5c50" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) full specializations and two partial specializations are provided by the standard library:</source>
          <target state="translated">標準ライブラリでは、2つのスタンドアロン (ロケールに依存しない)完全な特殊化と2つの部分的な特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="f02ffd61fc180d1f64496b8d587f3d5cce7df2b7" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">標準ライブラリでは、2つの独立した(ロケールに依存しない)特殊化が提供されています。</target>
        </trans-unit>
        <trans-unit id="2cf5b83a88ef7188b905ff555b89323fdaa04f77" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types are called</source>
          <target state="translated">2つの標準レイアウトの非ユニオンクラスタイプは、以下のように呼ばれます。</target>
        </trans-unit>
        <trans-unit id="1b0ea8abccf06468ba7e2e711860c3d383b65c96" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types may have a</source>
          <target state="translated">2つの標準レイアウトの非ユニオン・クラス・タイプには</target>
        </trans-unit>
        <trans-unit id="2034537c92fce35c44c1810a5621d0a63f6246c5" translate="yes" xml:space="preserve">
          <source>Two standard-layout unions are called</source>
          <target state="translated">2つの標準的なレイアウトの組合は、以下のように呼ばれています。</target>
        </trans-unit>
        <trans-unit id="cb0d34718d67d002a55c599c7fb017311e7a205d" translate="yes" xml:space="preserve">
          <source>Two strings are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; と &lt;code&gt;rhs&lt;/code&gt; の両方のサイズが等しく、 &lt;code&gt;lhs&lt;/code&gt; の各文字が &lt;code&gt;rhs&lt;/code&gt; の同じ位置にある同等の文字を持っている場合、2つの文字列は等しくなります。</target>
        </trans-unit>
        <trans-unit id="d818143c3e7668e852c1ed4b1bfcf0387a3c91b0" translate="yes" xml:space="preserve">
          <source>Two typedefs for the common case where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;bool&lt;/code&gt; である一般的な場合の2つのtypedef が提供されています。</target>
        </trans-unit>
        <trans-unit id="ab704f0a65282b62f2101424e6b2f0abfc336948" translate="yes" xml:space="preserve">
          <source>Two views are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has an equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; と &lt;code&gt;rhs&lt;/code&gt; の両方のサイズが等しく、 &lt;code&gt;lhs&lt;/code&gt; の各文字が同じ位置にある &lt;code&gt;rhs&lt;/code&gt; の同等の文字を持っている場合、2つのビューは等しくなります。</target>
        </trans-unit>
        <trans-unit id="e4adb4f5d7d971d5f33d8bf32d6573b59f4c2c1c" translate="yes" xml:space="preserve">
          <source>Two-way comparison</source>
          <target state="translated">双方向比較</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="7d5b0442ddd6e6a3b47c1fb7cfdb53626e952034" translate="yes" xml:space="preserve">
          <source>Type SFINAE</source>
          <target state="translated">SFINAE型</target>
        </trans-unit>
        <trans-unit id="c78ea93e5901f3567162bc1f5cabf9c0cb321ce8" translate="yes" xml:space="preserve">
          <source>Type U is swappable with type T if, for any object u of type U and any object t of type T,</source>
          <target state="translated">U型の任意のオブジェクトuとT型の任意のオブジェクトtについて、U型はT型とスワップ可能です。</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="5e72885576f31f0e1d9c64866f5a1621945f1d64" translate="yes" xml:space="preserve">
          <source>Type alias is a name that refers to a previously defined type (similar to &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;).</source>
          <target state="translated">タイプエイリアスは、以前に定義されたタイプを参照する名前です（&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;と同様）。</target>
        </trans-unit>
        <trans-unit id="1722c89a494d0f4cd3e0c044b1bcfcd056571bad" translate="yes" xml:space="preserve">
          <source>Type alias, alias template (since C++11)</source>
          <target state="translated">型エイリアス、エイリアステンプレート(C++11以降</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">タイプエイリアス</target>
        </trans-unit>
        <trans-unit id="cd126df756f5f399b0ed73a4824b22f02643ea98" translate="yes" xml:space="preserve">
          <source>Type aliases are provided for &lt;code&gt;bool&lt;/code&gt; and all integral types listed above, as follows:</source>
          <target state="translated">タイプエイリアスは、次のように、 &lt;code&gt;bool&lt;/code&gt; および上記のすべての整数型に提供されます。</target>
        </trans-unit>
        <trans-unit id="0621d5c6fbe8bcf7d94a8aeaee4b8e9171cf0f16" translate="yes" xml:space="preserve">
          <source>Type aliasing</source>
          <target state="translated">タイプエイリアシング</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">タイプ分類</target>
        </trans-unit>
        <trans-unit id="faebe1b53837fa610eefb9f421b0013abc2c2ee3" translate="yes" xml:space="preserve">
          <source>Type deduction does not consider implicit conversions (other than type adjustments listed above): that's the job for &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which happens later.</source>
          <target state="translated">型の推論では、暗黙の変換（上記の型調整以外）は考慮されません。これは、後で発生する&lt;a href=&quot;overload_resolution&quot;&gt;オーバーロード解決&lt;/a&gt;の仕事です。</target>
        </trans-unit>
        <trans-unit id="6b6c1979aa63474d39a31dd947373aa3f5876803" translate="yes" xml:space="preserve">
          <source>Type identification</source>
          <target state="translated">タイプの識別</target>
        </trans-unit>
        <trans-unit id="8e2511e093ef713b765be9963ac67a42b99f36a7" translate="yes" xml:space="preserve">
          <source>Type modification templates create new type definitions by applying modifications on a template parameter. The resulting type can then be accessed through &lt;code&gt;type&lt;/code&gt; member typedef.</source>
          <target state="translated">タイプ変更テンプレートは、テンプレートパラメータに変更を適用することにより、新しいタイプ定義を作成します。結果の型には、 &lt;code&gt;type&lt;/code&gt; メンバーtypedefを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="077701eb2407963fce08e9b207dd8581a8385722" translate="yes" xml:space="preserve">
          <source>Type modifications</source>
          <target state="translated">タイプの変更</target>
        </trans-unit>
        <trans-unit id="476a2ca549c0288e513cdd3a95b50bf4cb76b469" translate="yes" xml:space="preserve">
          <source>Type naming</source>
          <target state="translated">タイプ命名</target>
        </trans-unit>
        <trans-unit id="2885fa4c886876dbf27aa8c6e61e019d3364b3e1" translate="yes" xml:space="preserve">
          <source>Type operations</source>
          <target state="translated">タイプ操作</target>
        </trans-unit>
        <trans-unit id="d05a5058829543344892b6ea903ebf7acc0cbacb" translate="yes" xml:space="preserve">
          <source>Type properties</source>
          <target state="translated">タイプのプロパティ</target>
        </trans-unit>
        <trans-unit id="712780a85df08fbd996eeeec1c3d3e6e3b629d3c" translate="yes" xml:space="preserve">
          <source>Type relationships</source>
          <target state="translated">タイプの関係</target>
        </trans-unit>
        <trans-unit id="c4153f3895b73933a5c58c3f766c82d580c4d612" translate="yes" xml:space="preserve">
          <source>Type requirements</source>
          <target state="translated">タイプの要件</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">タイプ指定子</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">タイプサポート</target>
        </trans-unit>
        <trans-unit id="d99c924b5e5c496d209cd1138d79fd4d82ae89bd" translate="yes" xml:space="preserve">
          <source>Type support (basic types, RTTI, type traits)</source>
          <target state="translated">タイプ対応(基本タイプ、RTTI、タイプ特性</target>
        </trans-unit>
        <trans-unit id="86913cb67681548c98606e442d98428c1ae65742" translate="yes" xml:space="preserve">
          <source>Type template parameter</source>
          <target state="translated">タイプテンプレートパラメータ</target>
        </trans-unit>
        <trans-unit id="4a285087e3a01a1f61420542eebe3d7ad0cbe7d5" translate="yes" xml:space="preserve">
          <source>Type template parameter cannot be deduced from the type of a function default argument:</source>
          <target state="translated">型テンプレート・パラメータは、関数のデフォルト引数の型から推論することはできません。</target>
        </trans-unit>
        <trans-unit id="b3802db54ebe40c4f9d8e147e5ec66e48e2b252c" translate="yes" xml:space="preserve">
          <source>Type traits</source>
          <target state="translated">タイプ特性</target>
        </trans-unit>
        <trans-unit id="2824df384c0d515b0957ced6c76365b01bfeb9fa" translate="yes" xml:space="preserve">
          <source>Type traits (since C++11)</source>
          <target state="translated">型の特徴(C++11 以降</target>
        </trans-unit>
        <trans-unit id="fb365f218572167960956b20fa3e4a8fab51cd73" translate="yes" xml:space="preserve">
          <source>Type traits defines a compile-time template-based interface to query or modify the properties of types.</source>
          <target state="translated">Type traitsは、型のプロパティを問い合わせたり変更したりするためのコンパイル時のテンプレートベースのインターフェースを定義しています。</target>
        </trans-unit>
        <trans-unit id="d26fb74bad254a05310c922f3a48638fd66d9e0c" translate="yes" xml:space="preserve">
          <source>Type traits variable templates (&lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt;, etc)</source>
          <target state="translated">タイプ特性変数テンプレート（ &lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="1ce3ad96399788f64f133fb490b5f7a722f3d935" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions</source>
          <target state="translated">タイプに依存した表現</target>
        </trans-unit>
        <trans-unit id="9923b968817bae672aedebaea069d1e0f05c3d5f" translate="yes" xml:space="preserve">
          <source>Type-id</source>
          <target state="translated">Type-id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="6b028941a936328652669d0fdcfadace96df8cb3" translate="yes" xml:space="preserve">
          <source>Typedefs and specializations</source>
          <target state="translated">型定義と特殊化</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="14a6b912930173876d4ddc87ab0ee1e78929d71f" translate="yes" xml:space="preserve">
          <source>Types allowed for integer literals</source>
          <target state="translated">整数リテラルで使用できる型</target>
        </trans-unit>
        <trans-unit id="0aebd15ac247c772915a487e8beaa6ae702bbaf4" translate="yes" xml:space="preserve">
          <source>Types are grouped in various categories based on their properties:</source>
          <target state="translated">タイプは、その特性に応じて様々なカテゴリーに分類されています。</target>
        </trans-unit>
        <trans-unit id="432f7a9995f3c47c26ea06ac5e31bfbd1ce7f343" translate="yes" xml:space="preserve">
          <source>Types defined in all function definitions are also the same in all translation units.</source>
          <target state="translated">すべての関数定義で定義された型は、すべての翻訳単位でも同じです。</target>
        </trans-unit>
        <trans-unit id="f4721af617a03c18f8008b522a45437293348f79" translate="yes" xml:space="preserve">
          <source>Types of lookup</source>
          <target state="translated">ルックアップの種類</target>
        </trans-unit>
        <trans-unit id="7b0613fc7fabdfb018b52d357936b837a2cab911" translate="yes" xml:space="preserve">
          <source>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as</source>
          <target state="translated">名前のない型は、C++プログラムで参照する必要があることがよくあります。</target>
        </trans-unit>
        <trans-unit id="b2566175d7363d465c10ed984db01277b4e1b9cf" translate="yes" xml:space="preserve">
          <source>Types without a move constructor, but with a copy constructor that accepts &lt;code&gt;const T&amp;amp;&lt;/code&gt; arguments, satisfy &lt;code&gt;std::is_move_constructible&lt;/code&gt;.</source>
          <target state="translated">moveコンストラクターはないが、 &lt;code&gt;const T&amp;amp;&lt;/code&gt; 引数を受け入れるコピーコンストラクターがある型は、 &lt;code&gt;std::is_move_constructible&lt;/code&gt; 満たします。</target>
        </trans-unit>
        <trans-unit id="70739c5bd846379403ad7504d3db0427e14c707a" translate="yes" xml:space="preserve">
          <source>Types...</source>
          <target state="translated">Types...</target>
        </trans-unit>
        <trans-unit id="fbbef98f2687c637a775659b0dc25c3eaf7a67c3" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when &lt;a href=&quot;operators#Assignment_operator&quot;&gt;copy-and-swap idiom&lt;/a&gt; can be used.</source>
          <target state="translated">&lt;a href=&quot;operators#Assignment_operator&quot;&gt;コピーアンドスワップイディオム&lt;/a&gt;を使用できる場合のコピー割り当て演算子の一般的な宣言。</target>
        </trans-unit>
        <trans-unit id="918b3549bbd396e01bbb7e6f14e565a830f15731" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance).</source>
          <target state="translated">コピーアンドスワップイディオムが使用できない場合の典型的なコピー代入演算子の宣言(非スワップ型や性能低下)。</target>
        </trans-unit>
        <trans-unit id="f8ce748f05c8c5befc02b9aebb0d8d634d05750d" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy constructor.</source>
          <target state="translated">コピーコンストラクタの典型的な宣言。</target>
        </trans-unit>
        <trans-unit id="73cd36e771bfce67068d8e880baa5998fadf8c14" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move assignment operator.</source>
          <target state="translated">移動代入演算子の典型的な宣言。</target>
        </trans-unit>
        <trans-unit id="21fff4e24aeaedc99f5d443b9c3e1bb3e8fe60f0" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move constructor.</source>
          <target state="translated">移動コンストラクタの典型的な宣言。</target>
        </trans-unit>
        <trans-unit id="d37091da1e22a1f61c981f61d556e4bc6ba5eecd" translate="yes" xml:space="preserve">
          <source>Typical implementation holds an instance of a &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; as a member object.</source>
          <target state="translated">典型的な実装は &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; インスタンスをメンバーオブジェクトとして保持します。</target>
        </trans-unit>
        <trans-unit id="06d4cc727848bd1fdf903e8119b98940ee7e586c" translate="yes" xml:space="preserve">
          <source>Typical implementation holds member constants corresponding to all values of fmtflags, iostate, openmode, and seekdir shown below, member variables to maintain current precision, width, and formatting flags, the exception mask, the buffer error state, a resizeable container holding the callbacks, the currently imbued locale, the private storage, and a static integer variable for xalloc().</source>
          <target state="translated">典型的な実装では、以下に示す fmtflags,iostate,openmode,seekdir の全ての値に対応するメンバ定数、現在の精度、幅、書式設定フラグを維持するためのメンバ変数、例外マスク、バッファエラー状態、コールバックを保持するリサイズ可能なコンテナ、現在埋め込まれているロケール、プライベートストレージ、xalloc()用の静的整数変数を保持しています。</target>
        </trans-unit>
        <trans-unit id="588a768f54b40d99ef1543297e7072645cb90743" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_osyncstream&lt;/code&gt; holds only one member: the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; 一般的な実装は、ラップされた &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 1つのメンバーのみを保持します。</target>
        </trans-unit>
        <trans-unit id="a9aa2b00209f5ddcdf5c18ed5a9a504d20d2daca" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_syncbuf&lt;/code&gt; holds a pointer to the wrapped &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;, a boolean flag indicating whether the buffer will transmit its contents to the wrapped buffer on sync (flush), a boolean flag indicating a pending flush when the policy is to not emit on sync, an internal buffer that uses &lt;code&gt;Allocator&lt;/code&gt; (such as std::string), and a pointer to a mutex used to synchronize emit between multiple threads accessing the same wrapped stream buffer (these mutexes may be in a hash map with pointers to basic_streambuf objects used as keys).</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 一般的な実装は、ラップされた &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; へのポインターを保持します。これは、バッファーがその内容を同期（フラッシュ）時にラップされたバッファーに送信するかどうかを示すブールフラグ、ポリシーが有効な場合に保留中のフラッシュを示すブールフラグです。同期時に &lt;code&gt;Allocator&lt;/code&gt; しないようにするには、Allocatorを使用する内部バッファー（std :: stringなど）、および同じラップされたストリームバッファーにアクセスする複数のスレッド間で発行を同期するために使用されるミューテックスへのポインター（これらのミューテックスは、キーとして使用されるbasic_streambufオブジェクトへのポインター）。</target>
        </trans-unit>
        <trans-unit id="7250127c92df894b58e56d580f5f517195bd7d5f" translate="yes" xml:space="preserve">
          <source>Typical implementation of a &lt;code&gt;std::strstreambuf&lt;/code&gt; holds four private data members:</source>
          <target state="translated">&lt;code&gt;std::strstreambuf&lt;/code&gt; 一般的な実装は、4つのプライベートデータメンバーを保持します。</target>
        </trans-unit>
        <trans-unit id="ef6d40404da26e1e6eadc90e2e0a92c1349c9710" translate="yes" xml:space="preserve">
          <source>Typical implementation of the &lt;code&gt;std::basic_streambuf&lt;/code&gt; base class holds only the six &lt;code&gt;CharT*&lt;/code&gt; pointers and a copy of &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as data members. In addition, implementations may keep cached copies of locale facets, which are invalidated whenever &lt;code&gt;imbue()&lt;/code&gt; is called. The concrete buffers such as &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_streambuf&lt;/code&gt; 基本クラスの一般的な実装は、6つの &lt;code&gt;CharT*&lt;/code&gt; ポインターと &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; コピーのみをデータメンバーとして保持します。さらに、実装はロケールファセットのキャッシュされたコピーを保持する場合があり、 &lt;code&gt;imbue()&lt;/code&gt; が呼び出されるたびに無効になります。 &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; などの具象バッファーは、 &lt;code&gt;std::basic_streambuf&lt;/code&gt; から派生します。</target>
        </trans-unit>
        <trans-unit id="7cd7cae1a881bd65509f3fc54f4e619c9e90350a" translate="yes" xml:space="preserve">
          <source>Typical implementations either.</source>
          <target state="translated">典型的な実装はどちらか。</target>
        </trans-unit>
        <trans-unit id="9e133aef83ccff0d4f3491a9890dd2084b61042d" translate="yes" xml:space="preserve">
          <source>Typical implementations of &lt;code&gt;std::basic_stringbuf&lt;/code&gt; hold an object of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; or equivalent resizeable sequence container directly as a data member and use it as both the controlled character sequence (the array where the six pointers of &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; are pointing to) and as the associated character sequence (the source of characters for all input operations and the target for the output).</source>
          <target state="translated">&lt;code&gt;std::basic_stringbuf&lt;/code&gt; 一般的な実装は、タイプ &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; オブジェクトまたは同等のサイズ変更可能なシーケンスコンテナーをデータメンバーとして直接保持し、両方を制御された文字シーケンス（ &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 6つのポインターが指す配列）として使用します）および関連する文字シーケンス（すべての入力操作の文字のソースおよび出力のターゲット）として。</target>
        </trans-unit>
        <trans-unit id="68f2d8f77480725b5e25bbfbe1250bd18f26ff6c" translate="yes" xml:space="preserve">
          <source>Typical implementations use hardware transactional memory where supported and to the limits that it is available (e.g. until the changeset is saturated) and fall back to software transactional memory, usually implemented with optimistic concurrency: if another transaction updated some of the variables used by a transaction, it is silently retried. For that reason, retriable transactions (&quot;atomic blocks&quot;) can only call transaction-safe functions.</source>
          <target state="translated">典型的な実装では、サポートされているハードウェア・トランザクショ ナル・メモリを使用し、利用可能な限界まで(例えば、チェンジセットが飽和するまで)ハードウェア・トランザクショ ナル・メモリを使用し、ソフトウェア・トランザクショナル・メモリにフォールバックします。そのため、再試行可能なトランザクション(「アトミックブロック」)は、トランザクションセーフな関数のみを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">この順序付けの一般的な使用例には、まれに書き込まれる同時データ構造（ルーティングテーブル、構成、セキュリティポリシー、ファイアウォールルールなど）への読み取りアクセスと、ポインターを介したパブリケーションを伴うパブリッシャーサブスクライバーの状況、つまりプロデューサーがポインターをパブリッシュするときが含まれます。コンシューマが情報にアクセスできるようにします。プロデューサがメモリに書き込んだ他のすべてをコンシューマが認識できるようにする必要はありません（弱く順序付けされたアーキテクチャでは、コストのかかる操作になる可能性があります）。そのようなシナリオの例は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dcc9e60517620bd3f403ef0a6408dee8d18e7887" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">緩和されたメモリの順序付けの一般的な用途は、 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 参照カウンタなどの増分カウンタです。これは、原子性のみを必要とし、順序付けや同期は必要ないためです（shared_ptrカウンタを減らすには、デストラクタとの取得と解放の同期が必要です）。</target>
        </trans-unit>
        <trans-unit id="d1c41b285173ad8718230a87a1a5d2d17b3b7903" translate="yes" xml:space="preserve">
          <source>Typical use of iword storage is to pass information (e.g. custom formatting flags) from user-defined I/O manipulators to user-defined &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or to user-defined formatting facets imbued into standard streams.</source>
          <target state="translated">iwordストレージの一般的な用途は、ユーザー定義のI / Oマニピュレータからユーザー定義の &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; および &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; または標準ストリームに組み込まれたユーザー定義のフォーマットファセットに情報（たとえば、カスタムフォーマットフラグ）を渡すことです。</target>
        </trans-unit>
        <trans-unit id="a0c7297f2b0ebce4780a49bd855246e6cc47d6d3" translate="yes" xml:space="preserve">
          <source>Typical uses of &lt;code&gt;std::launder&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 一般的な用途は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f88c003eb42b9ea1375635c3ec171fc7d9d436f1" translate="yes" xml:space="preserve">
          <source>Typically called by the appropriate constructors of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">通常、 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 適切なコンストラクターによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b96ee3f3e487127e3b6fea8c21cfa2b830940d4d" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常、 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; コンストラクターによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="47bd33f18f5f8634e7375df48b7f7fb6bccdec60" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常、 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; コンストラクターによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3d635d5eec3d8618476f770fe4d864ab867b778b" translate="yes" xml:space="preserve">
          <source>Typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常、 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; デストラクタによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f750e5d2112c892940c039aca52de35a7711eef8" translate="yes" xml:space="preserve">
          <source>Typically, once &lt;code&gt;operator&amp;lt;&lt;/code&gt; is provided, the other relational operators are implemented in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">通常、 &lt;code&gt;operator&amp;lt;&lt;/code&gt; が提供されると、他の関係演算子が &lt;code&gt;operator&amp;lt;&lt;/code&gt; に関して実装されます。</target>
        </trans-unit>
        <trans-unit id="41f3db6f3ed64eb215d6838b5f2754196444b79e" translate="yes" xml:space="preserve">
          <source>U+00A8</source>
          <target state="translated">U+00A8</target>
        </trans-unit>
        <trans-unit id="853cbdaa93204f86fe9e28c7fa4f0cdff4d3b9bc" translate="yes" xml:space="preserve">
          <source>U+00AA</source>
          <target state="translated">U+00AA</target>
        </trans-unit>
        <trans-unit id="dd5c9cc4b863c82bc928546a1f85d66803a8211b" translate="yes" xml:space="preserve">
          <source>U+00AD</source>
          <target state="translated">U+00AD</target>
        </trans-unit>
        <trans-unit id="5b12a6b1423f6d50cbadc422ccde7e82e285061a" translate="yes" xml:space="preserve">
          <source>U+00AF</source>
          <target state="translated">U+00AF</target>
        </trans-unit>
        <trans-unit id="7b152417fcfe4c5eb703ff0a0c4980c4a5bdcc7f" translate="yes" xml:space="preserve">
          <source>U+00B2 - U+00B5</source>
          <target state="translated">u+00b2-u+00b5</target>
        </trans-unit>
        <trans-unit id="a000abf8eda220f3b5a2485e895780d87238cc05" translate="yes" xml:space="preserve">
          <source>U+00B7 - U+00BA</source>
          <target state="translated">u+00b7-u+00ba</target>
        </trans-unit>
        <trans-unit id="3e0f991583121de4997412ddc791f2cce64673ed" translate="yes" xml:space="preserve">
          <source>U+00BC - U+00BE</source>
          <target state="translated">u+00bc-u+00be</target>
        </trans-unit>
        <trans-unit id="8da270e5988e53f6a16cfbbffdc343231a853e7f" translate="yes" xml:space="preserve">
          <source>U+00C0 - U+00D6</source>
          <target state="translated">u+00c0-u+00d6</target>
        </trans-unit>
        <trans-unit id="21a7086c2d62117c31f8128dd2f55f8f6e915e24" translate="yes" xml:space="preserve">
          <source>U+00D8 - U+00F6</source>
          <target state="translated">u+00d8-u+00f6</target>
        </trans-unit>
        <trans-unit id="bf28cde9daefd91ebc927ccb81f1551b46c4d078" translate="yes" xml:space="preserve">
          <source>U+00F8 - U+167F</source>
          <target state="translated">u+00f8-u+167f</target>
        </trans-unit>
        <trans-unit id="a317fb85190fd3c7b724d3aedb81fe25713813f0" translate="yes" xml:space="preserve">
          <source>U+0300 - U+036F</source>
          <target state="translated">u+0300-u+036f</target>
        </trans-unit>
        <trans-unit id="820e59791c5dbc98084a89fd4c68a5caddd9a3e8" translate="yes" xml:space="preserve">
          <source>U+10000 - U+1FFFD</source>
          <target state="translated">u+10000-u+1fffd</target>
        </trans-unit>
        <trans-unit id="172792565a185595c59af72f4ae5f6a9a6e9ad8f" translate="yes" xml:space="preserve">
          <source>U+1681 - U+180D</source>
          <target state="translated">U+1681-U+180D</target>
        </trans-unit>
        <trans-unit id="d84a34f5a6d7a409f7d9c6df8ad6471fbc79b9b0" translate="yes" xml:space="preserve">
          <source>U+180F - U+1FFF</source>
          <target state="translated">u+180f-u+1fff</target>
        </trans-unit>
        <trans-unit id="f3c3d44148796e35a5035d711e351a1697c2759f" translate="yes" xml:space="preserve">
          <source>U+1DC0 - U+1DFF</source>
          <target state="translated">u+1dc0-u+1dff</target>
        </trans-unit>
        <trans-unit id="330cb234316d66348fc89aff6e84b6015dadcf43" translate="yes" xml:space="preserve">
          <source>U+20000 - U+2FFFD</source>
          <target state="translated">u+20000-u+2fffd</target>
        </trans-unit>
        <trans-unit id="5b3b9b21095522acbe168717fae555c1cfa7a1f4" translate="yes" xml:space="preserve">
          <source>U+200B - U+200D</source>
          <target state="translated">u+200b-u+200d</target>
        </trans-unit>
        <trans-unit id="3214f797fec510b86bf1cbf6434d683974a2248a" translate="yes" xml:space="preserve">
          <source>U+202A - U+202E</source>
          <target state="translated">u+202a-u+202e</target>
        </trans-unit>
        <trans-unit id="e97d49eff3295448f03d9e228444cd7f9a6734e9" translate="yes" xml:space="preserve">
          <source>U+203F - U+2040</source>
          <target state="translated">U+203F-U+2040</target>
        </trans-unit>
        <trans-unit id="0c09a7a1795e4fec0be94dc7e91b80a0bf26947f" translate="yes" xml:space="preserve">
          <source>U+2054</source>
          <target state="translated">U+2054</target>
        </trans-unit>
        <trans-unit id="cdc2d82bb3995d9b19eb2ac346b26a7a77b2e28c" translate="yes" xml:space="preserve">
          <source>U+2060 - U+218F</source>
          <target state="translated">U+2060-U+218F</target>
        </trans-unit>
        <trans-unit id="dc13f074c0cd31a6bc8af3c06df64a92b1be84c7" translate="yes" xml:space="preserve">
          <source>U+20D0 - U+20FF</source>
          <target state="translated">u+20d0-u+20ff</target>
        </trans-unit>
        <trans-unit id="46981b50f5cdfcf424f38b4b3c8b461b58872a28" translate="yes" xml:space="preserve">
          <source>U+2460 - U+24FF</source>
          <target state="translated">u+2460-u+24ff</target>
        </trans-unit>
        <trans-unit id="8e2adfcb84ba00df4ef947391a6eab237e18db97" translate="yes" xml:space="preserve">
          <source>U+2776 - U+2793</source>
          <target state="translated">U+2776-U+2793</target>
        </trans-unit>
        <trans-unit id="0ef4d0c6e728306dc714d1b3534d9c4ee993dccf" translate="yes" xml:space="preserve">
          <source>U+2C00 - U+2DFF</source>
          <target state="translated">u+2c00-u+2dff</target>
        </trans-unit>
        <trans-unit id="acd49fd22f227c59f753777c2766efc982471a9a" translate="yes" xml:space="preserve">
          <source>U+2E80 - U+2FFF</source>
          <target state="translated">u+2e80-u+2fff</target>
        </trans-unit>
        <trans-unit id="e220b857ae2172b856a1a2e9b7ea31ff3edb4b96" translate="yes" xml:space="preserve">
          <source>U+30000 - U+3FFFD</source>
          <target state="translated">u+30000-u+3fffd</target>
        </trans-unit>
        <trans-unit id="311cc5830e93c014a42f3cfe3f333942cdff5c89" translate="yes" xml:space="preserve">
          <source>U+3004 - U+3007</source>
          <target state="translated">U+3004-U+3007</target>
        </trans-unit>
        <trans-unit id="3518418be013a416f360fbc05bd7961da58adcba" translate="yes" xml:space="preserve">
          <source>U+3021 - U+302F</source>
          <target state="translated">U+3021-U+302F</target>
        </trans-unit>
        <trans-unit id="22bc0729fee97afe351038d4206a56bdf37b8cc5" translate="yes" xml:space="preserve">
          <source>U+3031 - U+D7FF</source>
          <target state="translated">u+3031-u+d7ff</target>
        </trans-unit>
        <trans-unit id="75623274217241111dd8aadc0414c3684e3527d1" translate="yes" xml:space="preserve">
          <source>U+40000 - U+4FFFD</source>
          <target state="translated">u+40000-u+4fffd</target>
        </trans-unit>
        <trans-unit id="ad684b1e2d51f2021e6096ff323c755de9835267" translate="yes" xml:space="preserve">
          <source>U+50000 - U+5FFFD</source>
          <target state="translated">u+50000-u+5fffd</target>
        </trans-unit>
        <trans-unit id="f48e64f1d20e3e1aa5cf849c51bec6aec208261d" translate="yes" xml:space="preserve">
          <source>U+60000 - U+6FFFD</source>
          <target state="translated">u+60000-u+6fffd</target>
        </trans-unit>
        <trans-unit id="27a70a77fa9d62033c98d2e43a4e257bfcba0a32" translate="yes" xml:space="preserve">
          <source>U+70000 - U+7FFFD</source>
          <target state="translated">u+70000-u+7fffd</target>
        </trans-unit>
        <trans-unit id="e47ee2f5ce5c5823a3427abfdcb793008f1f9afa" translate="yes" xml:space="preserve">
          <source>U+80000 - U+8FFFD</source>
          <target state="translated">u+80000-u+8fffd</target>
        </trans-unit>
        <trans-unit id="ae42c9725173d1af60cd9ee4fec2a5e915a289c9" translate="yes" xml:space="preserve">
          <source>U+90000 - U+9FFFD</source>
          <target state="translated">u+90000-u+9fffd</target>
        </trans-unit>
        <trans-unit id="a29e4d5dbda0a54f8aba629dfae926d4d31c7fa4" translate="yes" xml:space="preserve">
          <source>U+A0000 - U+AFFFD</source>
          <target state="translated">u+a0000-u+afffd</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
