<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="cd4c4c97f36b2b62de11c34b4a27a2c761742b55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvs server&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvsサーバー&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e49a24547f58bd02d543075f89ceed8c90d6d7d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dcommit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dcommit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29a1329a0153d69adbf79d22da2d86026099cd1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dadae45c2e0ed49ab92c21e51924b9c5c51ce2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;disable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;disable&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b451ef329785424729c63e2a3017984d3e643c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;export-marks&lt;/em&gt; &amp;lt;ファイル&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35b45d112a98b2ca1521e95769372073007c885a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;export&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069adc38be838320ed1d0aece7752fcbc214a54a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fetch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d558b04f07f16944ece2169a0e3c3823b9025f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt; &amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;を&lt;em&gt;フェッチし&lt;/em&gt;ます</target>
        </trans-unit>
        <trans-unit id="89dcac1ec2e46569b3edf183125a808da46f4c6f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;find-rev&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;find-rev&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1073814f068a39c89b0eede6d041e1faf4e59ac8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;forget&lt;/em&gt; &amp;lt;pathspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&amp;lt;pathspec&amp;gt;を&lt;em&gt;忘れる&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f8f3fbb6ffe3b51991811f0c6531319170fdb21" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;gc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;gc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4af622a2a4f28a61d7a9f24cb930fffc6ba76491" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;get-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;get-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a9d6d2f21ff1ec0d69ee63760f22a3c5cbb084b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; (-p|--patch) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt;（-p | --patch）[&amp;lt;tree-ish&amp;gt;] [-] [&amp;lt;pathspec&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="228e3a4db67759d57c887f137171bceae52a6f8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;ブランチ&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d8ead8dfc114c4f20b9d6ce6d106f2bc2ef44cf5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; -b|-B &amp;lt;new_branch&amp;gt; [&amp;lt;start point&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; -b | -B &amp;lt;new_branch&amp;gt; [&amp;lt;開始ポイント&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="e4b2375b489fba132766f1463af8f72171dbc00f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;ブランチ&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9e1ee40d06e7050bf76fabde96c6e18bcdee66c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;commit&amp;gt;</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;コミット&amp;gt;</target>
        </trans-unit>
        <trans-unit id="617a45295c12feb378bd11060f09979d655ab681" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [-f | --ours | --theirs | -m | --conflict = &amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file = &amp;lt;file&amp;gt; [--pathspec-file- nul]</target>
        </trans-unit>
        <trans-unit id="f1d51fb50a15426c11b22d89a456ad62c37302f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [-f | --ours | --theirs | -m | --conflict = &amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="8c3a4a5dff582db446092ec31dff7ac07f6c56f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;inetdサーバーとしての&lt;em&gt;gitデーモン&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="644cb16bb367018811de44ec6a0f22813d106722" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server for virtual hosts</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;仮想ホストのinetdサーバーとしての&lt;em&gt;gitデーモン&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56394bb621be1c3ea64a9da0cc7c453f78c851ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as regular daemon for virtual hosts</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;仮想ホストの通常の&lt;em&gt;デーモン&lt;/em&gt;としての&lt;em&gt;gitデーモン&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb95273e719d9bbb038ef063d4fe7199f2a7aaf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1c0820ca6bb0780c196ed7a86287e4ecc94f9478" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] &amp;lt;コミット&amp;gt; &amp;lt;コミット&amp;gt; [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="0bddd1875bfd788184caf49193c3ba66e07b6e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] &amp;lt;コミット&amp;gt; [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="41d3be1f649e59b3792c69f12f6776a563b79a47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] &amp;lt;コミット&amp;gt; .. &amp;lt;コミット&amp;gt; [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="bf5568faf67d40bb88542b7b67ef397df7105ffc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] &amp;lt;コミット&amp;gt; ... &amp;lt;コミット&amp;gt; [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e447147bf3a29d6c97f55baf3c69e97f18f8eee8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [&amp;lt;commit&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] --cached [&amp;lt;コミット&amp;gt;] [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="61d1c1e990e80e06e13a4eafe5a8bc5038d40599" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --no-index [--] &amp;lt;path&amp;gt; &amp;lt;path&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] --no-index [-] &amp;lt;パス&amp;gt; &amp;lt;パス&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6d86328721afc22cd489583dfba8df6685359245" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;オプション&amp;gt;] [-] [&amp;lt;パス&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e3453c9e134e20e25559107f3911fd6230cd8bc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git push&lt;/em&gt; uses a pair of commands, &lt;em&gt;git send-pack&lt;/em&gt; on your local machine, and &lt;em&gt;git-receive-pack&lt;/em&gt; on the remote machine. The communication between the two over the network internally uses an SSH connection.</source>
          <target state="translated">&lt;em&gt;git push&lt;/em&gt;は、ローカルマシンでは&lt;em&gt;git send-pack&lt;/em&gt;、リモートマシンでは&lt;em&gt;git-receive-packの&lt;/em&gt; 2つのコマンドを使用します。ネットワーク上の2つの間の通信は、内部でSSH接続を使用します。</target>
        </trans-unit>
        <trans-unit id="fcf93dc31f705fddbb9194212d483f563999e11e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git receive-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git receive-pack &amp;lt;引数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc127848493f760fe053476520e3d12a67e1a15a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt;（--patch | -p）[&amp;lt;tree-ish&amp;gt;] [-] [&amp;lt;pathspec&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e0143ed9ababaeb97962f5daf71b285ee855acf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;モード&amp;gt;] [&amp;lt;コミット&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9c8b6cc4b08d5db74f9966c865d7bdbc3e8057ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="3db1e64e46be79d2a9c84117847b63d5ab92c79c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file = &amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="0c6a869ee4e5a3eb64f1df2a1d1670adf970a316" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-archive &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git upload-archive &amp;lt;引数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2be43a079baf397e7d9b3bb2f1f647a64854d22" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git upload-pack &amp;lt;引数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6b0677a6a48058174b9c4662c9d2ba987db8c81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;group&lt;/em&gt; (or &lt;em&gt;true&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;グループ&lt;/em&gt;（または&lt;em&gt;true&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="55040b4473f65b2a2bbdfd28a71977476093b889" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;import-marks&lt;/em&gt; &amp;lt;ファイル&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41133af30f1b5a3e614609c0efa62b0bd14788f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7615a0bee74b428678cd3952d9a38bbd50138b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;インポート&lt;/em&gt; &amp;lt;名前&amp;gt;</target>
        </trans-unit>
        <trans-unit id="026584f5175b5bbc2ceb1f268e18940c0011aaec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;info&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;info&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0a5f718f14de716a46db8b2404578b5920000d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;init&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;init&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="286e2b7b70dbf3ef029c4799f2f0e629b0a5aef4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list for-push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プッシュ用のリスト&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be49361f1b70e440beb1d6cf2176c292c8e2abc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;list&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a100b4c5979c283ac452823f58dbcc9e5048c7b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971c241f477dec4b57be5fc29faa14ab335706fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;mkdirs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;mkdirs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35b67dffbe62b7476ce92342433b831e27d5bcee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;no-private-update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;no-private-update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b76f729b2c8dd001b33a3965716abefb37454800" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option atomic&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションアトミック&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="c33bb338d193ab16d7a0168b421e3b698bb0bcbe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option check-connectivity&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションcheck-connectivity&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9c99d5f55da3961c68109a0e1d9a50e706a2120b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option cloning&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションの複製&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="04bd7fa50536660a2d31774812bb98fb7a2abdff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option deepen-relative {'true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションdeepen-relative {'true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="a98d1a36ae5cdad2003ea22f14ad851505cf3847" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option depth&lt;/em&gt; &amp;lt;depth&amp;gt;</source>
          <target state="translated">&lt;em&gt;オプションの深さ&lt;/em&gt; &amp;lt;深さ&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82d6797af0a212ad278e2948eaeaaf74a72f680a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option followtags&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションfollowtags&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9986eedd79cb9f9b7c70d2aedda0729823cac02a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option force&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションforce&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="111ea29454b6330909016c9e45b9b66754df6b19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option from-promisor&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションfrom-promisor&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="800dda6c88e8893c227fca8a8c94622ca67dc810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option no-dependents&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションno-dependents&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="7ea5bd740df1ec70168c7a478ecd00a132039f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option progress&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションの進行状況&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="5dc4a2e0bb9f6060bdad740b788ef15fe9ea07c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option pushcert&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションpushcert&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="59d5978dddebb71223de8e8f6a60d2e3e72c7a65" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option servpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;オプションservpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ca7ff603e79015944d1670c4c4f6181601659ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option update-shallow&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;オプションupdate-shallow&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;false&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="0786067c699d96aadca89509b296234c78e51c6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option verbosity&lt;/em&gt; &amp;lt;n&amp;gt;</source>
          <target state="translated">&lt;em&gt;オプションの冗長性&lt;/em&gt; &amp;lt;n&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04c59238310bfcf16cbbb35553d54bbfdca9360e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;option&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44f8139502701251329b628c8aa5e94fd7edfce3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;</source>
          <target state="translated">&lt;em&gt;オプション&lt;/em&gt; &amp;lt;名前&amp;gt; &amp;lt;値&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba27d70f1550f4f882b78e61655d5157efb6f50e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propget&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propget&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6756585c61f2a32bab572f78fd3126b296699695" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;proplist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;proplist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e4008412d95ecd817c12ca15c192c575f546de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498ec3238e0f1d50b74e6af30a09c8f3309ba7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;prune&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;prune&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd31fb337461755bb5e3e31aef446948ecaa910d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;push&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c969a81bfce4fd2324388518d5f5e17de0b527" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt; +&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;</source>
          <target state="translated">&lt;em&gt;プッシュ&lt;/em&gt; + &amp;lt;src&amp;gt;：&amp;lt;dst&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9117e882f570b9772bf4876578e36a25fc34732b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;qgit(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;qgit(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50ee056d4ddb76ef51f00483fe7dba34b51a449f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rebase&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rebase&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ea2b05c8f3c06fde58d0420744f0ca61045b90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd596b5091e1eb8368f579278c36824b713bc311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remaining&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remaining&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3ac08fba984c4fe2e39dbd6a9e3de5fb185a1f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b73121d3aa4f1dd8fa730929ede8f4b312f32337" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rename&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d13cdb6fdbae20acc2c43402406d81568a2499c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4c4fda591f60696add6ae66730f4d8ec836d261" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rm&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rm&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e477dd12e9e0460380eeba036cb09372c938695d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-branches&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-branches&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e65afe49a6eeb7cf02d2f6043f28b8a4ff342bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-head&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-head&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35f6993e8ee5f31dec406f06a31e049f29878752" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-tree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-tree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eda17e1c12e721d23988d4fc5e20726a9c47abd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8687e363ac98f906ebed1b843dd4f64a34e3c7f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6870a5d4b2985453a855890d8d72edfc3d70811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-externals&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-externals&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fe1dc07bdefa3cf58064ba55fde45829ca1f136" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd0e49781a98f7911b34f1aee38b44f2e869f16f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cc68266a42e8384ff3fa58baf8c34f3646c37ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;signed-tags&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;signed-tags&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86cead65159d3e086c70f8b7b59218a58d3147e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;stateless-connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4b47d3b1f6acb81c114d964233185b4c02ac419" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="translated">&lt;em&gt;ステートレス接続&lt;/em&gt; &amp;lt;サービス&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cbef19eb270f01c4c2c82d2d02a006f9e49ea17d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;status&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;status&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc5dcfd7fa2c24a533fa19007091483ece18fad4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tag&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96d7bc00171f5fd2b09f66cf504ac0023cca30dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tig(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tig(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="139a3f1d23eafefa18ee2425482ff51b6f467d67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;umask&lt;/em&gt; (or &lt;em&gt;false&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;umask&lt;/em&gt;（または&lt;em&gt;false&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="9c0e9959206cb6877a60069410fa385eb4f78805" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unchanged&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unchanged&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ecf8aa641ca5e9e706fa0d63103b28681ce2dc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1802e8d4ef28dec4be0233820e8c05c3d927de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unspecified&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unspecified&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b312ee3f358f78767b6a06231fbf44287808e9ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aed0d22d6992ee80ec4d657f0cd95ab429e2ec9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;verify&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;verify&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f49b6f6188963904d82e1623f3020436895b7e2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;write&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8172ae9dcfb804bff8895259fe3102a0316b0619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; The latter form is just a short-hand of &lt;code&gt;git checkout topic&lt;/code&gt; followed by &lt;code&gt;git rebase master&lt;/code&gt;. When rebase exits &lt;code&gt;topic&lt;/code&gt; will remain the checked-out branch.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;後者の形式は、 &lt;code&gt;git checkout topic&lt;/code&gt; 後に &lt;code&gt;git rebase master&lt;/code&gt; を続けたものです。リベースが終了すると、 &lt;code&gt;topic&lt;/code&gt; はチェックアウトされたブランチのままになります。</target>
        </trans-unit>
        <trans-unit id="b03388fb9a3fc2d66d455eba38ee0aa1f510dfbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; the changes introduced by the commits, and which are not reverted by subsequent commits, will still be in the rewritten branch. If you want to throw out &lt;code&gt;changes&lt;/code&gt; together with the commits, you should use the interactive mode of &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;以降のコミットによって元に戻されていないコミットによって導入された変更、および、まだ書き換えブランチになります。コミットと一緒に &lt;code&gt;changes&lt;/code&gt; を破棄したい場合は、 &lt;code&gt;git rebase&lt;/code&gt; のインタラクティブモードを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="34561b8d811663906f33af73652542d0fcde7357" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;$my_url&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt;, and &lt;code&gt;$base_url&lt;/code&gt; are overwritten with their default values before every request, so if you want to change them, be sure to set this variable to true or a code reference effecting the desired changes.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;$my_url&lt;/code&gt; 、 &lt;code&gt;$my_uri&lt;/code&gt; 、および &lt;code&gt;$base_url&lt;/code&gt; は、すべてのリクエストの前にデフォルト値で上書きされるため、これらを変更する場合は、この変数をtrueに設定するか、必要な変更を行うコード参照を設定してください。</target>
        </trans-unit>
        <trans-unit id="09aea3b60370a4f963c3a85b4699f5aaace7982e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read the note for &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;'s &lt;code&gt;--reference&lt;/code&gt;, &lt;code&gt;--shared&lt;/code&gt;, and &lt;code&gt;--dissociate&lt;/code&gt; options carefully.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：DOは&lt;strong&gt;ない&lt;/strong&gt;あなたがノートを読んでない限り、このオプションを使用する&lt;a href=&quot;git-clone&quot;&gt;gitのクローン[1]&lt;/a&gt;さん &lt;code&gt;--reference&lt;/code&gt; 、 &lt;code&gt;--shared&lt;/code&gt; 、および &lt;code&gt;--dissociate&lt;/code&gt; 慎重オプション。</target>
        </trans-unit>
        <trans-unit id="7c9dfe7ce0f5b8ee96b2cbc1652fb8a81531cced" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command honors &lt;code&gt;.git/info/grafts&lt;/code&gt; file and refs in the &lt;code&gt;refs/replace/&lt;/code&gt; namespace. If you have any grafts or replacement refs defined, running this command will make them permanent.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このコマンドは、 &lt;code&gt;.git/info/grafts&lt;/code&gt; ファイルと &lt;code&gt;refs/replace/&lt;/code&gt; 名前空間のrefを尊重します。グラフトまたは置換参照が定義されている場合、このコマンドを実行するとそれらが永続的になります。</target>
        </trans-unit>
        <trans-unit id="d30c68c37350410fb672027924f29f5f9ab1c98c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts repository.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：libcurlが7.16より古い場合、このコマンドは一時的に無効になります。組み合わせが機能しないことが報告されており、リポジトリが破損する場合があるためです。</target>
        </trans-unit>
        <trans-unit id="f74ae839c695329bca37194e38c0f34b77fadce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is intended for cleaning metadata, prefer the &lt;code&gt;--whitespace=fix&lt;/code&gt; mode of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for correcting whitespace of patches or files in the repository.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：これはメタデータの &lt;code&gt;--whitespace=fix&lt;/code&gt; 目的としています。リポジトリ内のパッチまたはファイルの空白を修正&lt;a href=&quot;git-apply&quot;&gt;するに&lt;/a&gt;は、git-apply [1]の--whitespace = fixモードをお勧めします。</target>
        </trans-unit>
        <trans-unit id="585c6ddedc01781dae2a49fca690af8a9afad0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: for a file to be highlighted, its syntax type must be detected and that syntax must be supported by &quot;highlight&quot;. The default syntax detection is minimal, and there are many supported syntax types with no detection by default. There are three options for adding syntax detection. The first and second priority are &lt;code&gt;%highlight_basename&lt;/code&gt; and &lt;code&gt;%highlight_ext&lt;/code&gt;, which detect based on basename (the full filename, for example &quot;Makefile&quot;) and extension (for example &quot;sh&quot;). The keys of these hashes are the basename and extension, respectively, and the value for a given key is the name of the syntax to be passed via &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; to &quot;highlight&quot;. The last priority is the &quot;highlight&quot; configuration of &lt;code&gt;Shebang&lt;/code&gt; regular expressions to detect the language based on the first line in the file, (for example, matching the line &quot;#!/bin/bash&quot;). See the highlight documentation and the default config at /etc/highlight/filetypes.conf for more details.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：ファイルを強調表示するには、その構文タイプを検出し、その構文が「強調表示」でサポートされている必要があります。デフォルトの構文検出は最小限であり、サポートされている多くの構文タイプがあり、デフォルトでは検出されません。構文検出を追加するには、3つのオプションがあります。 1番目と2番目の優先順位は &lt;code&gt;%highlight_basename&lt;/code&gt; と &lt;code&gt;%highlight_ext&lt;/code&gt; で、ベース名（完全なファイル名、たとえば「Makefile」）と拡張子（たとえば「sh」）に基づいて検出されます。これらのハッシュのキーはそれぞれベース名と拡張子であり、特定のキーの値は &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; を介して「highlight」に渡される構文の名前です。最後の優先事項は「ハイライト」です &lt;code&gt;Shebang&lt;/code&gt; ファイルの最初の行に基づいて言語を検出するための正規表現（たとえば、「＃！/ bin / bash」の行に一致）。詳細については、ハイライトドキュメントと/etc/highlight/filetypes.confのデフォルト設定を参照してください。</target>
        </trans-unit>
        <trans-unit id="9b9b27f31414016f32b35409236f195a9797bba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--reference&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：-- &lt;code&gt;--reference&lt;/code&gt; オプションの注を参照してください。</target>
        </trans-unit>
        <trans-unit id="5918a0077865239a25fcfe555ed0525b81a0cce2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--shared&lt;/code&gt; option, and also the &lt;code&gt;--dissociate&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：のための注意を参照してください &lt;code&gt;--shared&lt;/code&gt; オプション、およびまた &lt;code&gt;--dissociate&lt;/code&gt; オプション。</target>
        </trans-unit>
        <trans-unit id="cb7c79db74439daa322af5432c4cb38d74b773b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand the implications (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：これは危険な操作である可能性があります。ん&lt;strong&gt;ではない&lt;/strong&gt;あなたが意味を理解しない限り、それを使用する（参照&lt;a href=&quot;git-rebase&quot;&gt;のgit-リベース[1]&lt;/a&gt;詳細については、を）。</target>
        </trans-unit>
        <trans-unit id="fd8f10a91cc32941d397d3cbd72284f0494472a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git gc --auto&lt;/code&gt;. (See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：これは危険な操作である可能性があります。ん&lt;strong&gt;ではない&lt;/strong&gt;あなたはそれが何をするかを理解しない限り、それを使用しています。このオプションを使用してリポジトリを複製してから、ソースリポジトリのブランチを削除する（または既存のコミットを参照されないようにする他のGitコマンドを使用する）と、一部のオブジェクトが参照されなくなる（またはぶら下がる）場合があります。これらのオブジェクトは、自動的に &lt;code&gt;git gc --auto&lt;/code&gt; を呼び出す通常のGit操作（ &lt;code&gt;git commit&lt;/code&gt; など）によって削除される場合があります。 （&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]を&lt;/a&gt;参照してください。）これらのオブジェクトが削除され、複製されたリポジトリーによって参照された場合、複製されたリポジトリーは破損します。</target>
        </trans-unit>
        <trans-unit id="7c66780d5bfd012adc7033c6c0a4c5d63ded1f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; gitk (unlike &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) currently only understands this option if you specify it &quot;glued together&quot; with its argument. Do &lt;strong&gt;not&lt;/strong&gt; put a space after &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; gitkは（&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;とは異なり）、現在このオプションを理解するには、引数で &quot;glued一緒に&quot;を指定した場合のみです。 &lt;code&gt;-L&lt;/code&gt; の後にスペースを入れ&lt;strong&gt;ないで&lt;/strong&gt;ください。</target>
        </trans-unit>
        <trans-unit id="55897d0bbd0f3ca4e5eda8d2fd483ad8d798dcb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that no feature is overridable by default.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;デフォルトではオーバーライド可能な機能がないことに&lt;strong&gt;注意し&lt;/strong&gt;て&lt;strong&gt;ください&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="02ea3f041b0ba373c69cf48b5644925866c5ecea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that rename and especially copy detection can be quite CPU-intensive. Note also that non Git tools can have problems with patches generated with options mentioned above, especially when they involve file copies ('-C') or criss-cross renames ('-B').</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;名前の変更、特にコピーの検出は、CPUを集中的に使用する可能性があることに&lt;strong&gt;注意し&lt;/strong&gt;て&lt;strong&gt;ください&lt;/strong&gt;。また、Git以外のツールでは、上記のオプションで生成されたパッチで問題が発生する可能性があることにも注意してください。特に、ファイルコピー（ '-C'）または名前の変更（ '-B'）が含まれる場合に注意してください。</target>
        </trans-unit>
        <trans-unit id="902c07c8249a8df193537556ae95a34d36a6294b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this requires to be set for each request, so either &lt;code&gt;$per_request_config&lt;/code&gt; must be false, or the above must be put in code referenced by &lt;code&gt;$per_request_config&lt;/code&gt;;</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;これはリクエストごとに設定する必要があるため、 &lt;code&gt;$per_request_config&lt;/code&gt; がfalseであるか、または上記を &lt;code&gt;$per_request_config&lt;/code&gt; 参照するコードに含める必要があることに&lt;strong&gt;注意し&lt;/strong&gt;て&lt;strong&gt;ください&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e45e1902bb87b0712f0e2420e234000a3f2ef680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Also you can have a plain text file &lt;code&gt;.git&lt;/code&gt; at the root of your working tree, containing &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; to point at the real directory that has the repository. This mechanism is often used for a working tree of a submodule checkout, to allow you in the containing superproject to &lt;code&gt;git checkout&lt;/code&gt; a branch that does not have the submodule. The &lt;code&gt;checkout&lt;/code&gt; has to remove the entire submodule working tree, without losing the submodule repository.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：また、作業ツリーのルートに &lt;code&gt;.git&lt;/code&gt; を含むプレーンテキストファイル.gitを &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; ことができます。これには、リポジトリがある実際のディレクトリを指すgitdir：&amp;lt;path&amp;gt;が含まれています。このメカニズムは、サブモジュールのチェックアウトの作業ツリーでよく使用されます。これにより、包含スーパープロジェクトで、サブモジュールのないブランチを &lt;code&gt;git checkout&lt;/code&gt; できます。 &lt;code&gt;checkout&lt;/code&gt; サブモジュールのリポジトリを失うことなく、全体のサブモジュールの作業ツリーを削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="71fa00b64eae5b5c3890d9bb37bfa403b32cff82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: there is also a legacy &lt;code&gt;$stylesheet&lt;/code&gt; configuration variable, which was used by older gitweb. If &lt;code&gt;$stylesheet&lt;/code&gt; variable is defined, only CSS stylesheet given by this variable is used by gitweb.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：古いgitwebで使用されていた従来の &lt;code&gt;$stylesheet&lt;/code&gt; 構成変数もあります。場合は &lt;code&gt;$stylesheet&lt;/code&gt; 変数が定義されている、この変数によって与えられた唯一のCSSスタイルシートはgitwebで使用されます。</target>
        </trans-unit>
        <trans-unit id="22d7c2a95cf98eb3222f8ef736d4c5d7e8f5f3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; that in this case you don&amp;rsquo;t need special settings for &lt;code&gt;@stylesheets&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt; and &lt;code&gt;$home_link&lt;/code&gt;, but you lose &quot;dumb client&quot; access to your project .git dirs (described in &quot;Single URL for gitweb and for fetching&quot; section). A possible workaround for the latter is the following: in your project root dir (e.g. &lt;code&gt;/pub/git&lt;/code&gt;) have the projects named &lt;strong&gt;without&lt;/strong&gt; a .git extension (e.g. &lt;code&gt;/pub/git/project&lt;/code&gt; instead of &lt;code&gt;/pub/git/project.git&lt;/code&gt;) and configure Apache as follows:</source>
          <target state="translated">&lt;strong&gt;ご注意&lt;/strong&gt;このケースでは、あなたがのために特別な設定は必要ありません &lt;code&gt;@stylesheets&lt;/code&gt; 、 &lt;code&gt;$my_uri&lt;/code&gt; と &lt;code&gt;$home_link&lt;/code&gt; 、しかし、あなたのプロジェクトの.gitのdirsにに「ダムクライアント」のアクセスを失う（「gitweb用およびフェッチのための単一のURL」で説明をセクション） 。後者の可能な回避策は次のとおりです。プロジェクトのルートディレクトリ（例： &lt;code&gt;/pub/git&lt;/code&gt; ）に、.git拡張子&lt;strong&gt;なしで&lt;/strong&gt;名前が付けられたプロジェクト（例： &lt;code&gt;/pub/git/project.git&lt;/code&gt; の代わりに &lt;code&gt;/pub/git/project&lt;/code&gt; ）があります。次のようにApacheを構成します。</target>
        </trans-unit>
        <trans-unit id="07043eaeaff4821b6e3d2bf0596ce3d880d9918c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parent:&lt;/strong&gt; All files immediately inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;親：&lt;/strong&gt;ディレクトリ内のすべてのファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="32959a6518e6c4e84b5303e691c25180330dfdcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursive:&lt;/strong&gt; All paths inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;再帰的：&lt;/strong&gt;ディレクトリ内のすべてのパスが含まれます。</target>
        </trans-unit>
        <trans-unit id="e44ad2e7b5c600612a0a8797303bea45f315c6d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; for certain situations the import leads to incorrect results. Please see the section &lt;a href=&quot;#issues&quot;&gt;ISSUES&lt;/a&gt; for further reference.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;特定の状況では、インポートにより誤った結果が生じます。セクションを参照してください&lt;a href=&quot;#issues&quot;&gt;問題が&lt;/a&gt;さらに参考のために。</target>
        </trans-unit>
        <trans-unit id="a9194839c57ad7da4a8bab5e0d40ab32351d35b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt;&lt;code&gt;git cvsimport&lt;/code&gt; uses cvsps version 2, which is considered deprecated; it does not work with cvsps version 3 and later. If you are performing a one-shot import of a CVS repository consider using &lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt; or &lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; &lt;code&gt;git cvsimport&lt;/code&gt; はcvspsバージョン2を使用しますが、これは非推奨と見なされています。cvspsバージョン3以降では機能しません。CVSリポジトリのワンショットインポートを実行している場合は、&lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt;または&lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-exportの&lt;/a&gt;使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="56bcd3ed1b5437dcaa0e279477dd7d4ed74ad36f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;! The rewritten history will have different object names for all the objects and will not converge with the original branch. You will not be able to easily push and distribute the rewritten branch on top of the original branch. Please do not use this command if you do not know the full implications, and avoid using it anyway, if a simple single commit would suffice to fix your problem. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for further information about rewriting published history.)</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;！書き換えられた履歴は、すべてのオブジェクトに対して異なるオブジェクト名を持ち、元のブランチとは収束しません。書き換えたブランチを元のブランチの上に簡単にプッシュして配布することはできません。完全な影響が不明な場合はこのコマンドを使用しないでください。単純な単一のコミットで問題を解決できる場合は、このコマンドの使用を避けてください。（公開された履歴の書き換えの詳細については、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]の&lt;/a&gt;「UPSREAM REBASEからの復旧」セクションを参照してください。）</target>
        </trans-unit>
        <trans-unit id="1c57eef2952dcc7cbcb3f3594949c7f400ccd82e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Running &lt;code&gt;git merge&lt;/code&gt; with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：重要ではないコミットされていない変更を使用 &lt;code&gt;git merge&lt;/code&gt; てgitマージを実行することはお勧めしません。可能であれば、競合が発生した場合に元に戻せない状態になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="2e41f73876997d3719c74ffacd713f8bedda0ef1" translate="yes" xml:space="preserve">
          <source>@diff_opts</source>
          <target state="translated">@diff_opts</target>
        </trans-unit>
        <trans-unit id="ece9251682dfe6d86397776eeae7c5bceec968bb" translate="yes" xml:space="preserve">
          <source>@extra_breadcrumbs</source>
          <target state="translated">@extra_breadcrumbs</target>
        </trans-unit>
        <trans-unit id="d642d6b3afbdc1fe579a545767dd08c49fb22d26" translate="yes" xml:space="preserve">
          <source>@git_base_url_list</source>
          <target state="translated">@git_base_url_list</target>
        </trans-unit>
        <trans-unit id="d1cb9d322cf309d895cfe28288e26547a4f2023b" translate="yes" xml:space="preserve">
          <source>@stylesheets</source>
          <target state="translated">@stylesheets</target>
        </trans-unit>
        <trans-unit id="17f8f0c63a0ac553bacb3cc13b4bba7ffe3a1b0c" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; is just file data, which we can also examine with cat-file:</source>
          <target state="translated">blob」は単なるファイルデータであり、cat-fileでも調べることができます。</target>
        </trans-unit>
        <trans-unit id="48346c16ecaa075a67739766a897040a2f3413ba" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; object is nothing but a binary blob of data. It doesn&amp;rsquo;t refer to anything else or have attributes of any kind.</source>
          <target state="translated">「blob」オブジェクトは、データのバイナリblobにすぎません。それは他のものを参照したり、いかなる種類の属性も持っていません。</target>
        </trans-unit>
        <trans-unit id="78bff4978d5abc6efec633665a6a6e240b98928c" translate="yes" xml:space="preserve">
          <source>A &quot;branch&quot; is an active line of development. The most recent &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, which moves forward as additional development is done on the branch. A single Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can track an arbitrary number of branches, but your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is associated with just one of them (the &quot;current&quot; or &quot;checked out&quot; branch), and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; points to that branch.</source>
          <target state="translated">「ブランチ」は活発な開発ラインです。ブランチでの最新の&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;は、そのブランチの先端と呼ばれます。ブランチの先端はブランチ&lt;a href=&quot;#def_head&quot;&gt;ヘッド&lt;/a&gt;によって参照され、ブランチで追加の開発が行われると前方に移動します。1つのGit &lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;は任意の数のブランチを追跡できますが、&lt;a href=&quot;#def_working_tree&quot;&gt;作業ツリー&lt;/a&gt;はブランチの1つ（「現在の」または「チェックアウトされた」ブランチ）に関連付けられており、&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;はそのブランチを指します。</target>
        </trans-unit>
        <trans-unit id="a01578f0bd22457eb0af668d78f12e9483b4aa95" translate="yes" xml:space="preserve">
          <source>A &quot;combined diff&quot; format looks like this:</source>
          <target state="translated">結合された差分」の形式は次のようになります。</target>
        </trans-unit>
        <trans-unit id="3fd53e12d383c6d235aea40bfa1170ca1c16d64c" translate="yes" xml:space="preserve">
          <source>A &quot;light&quot; tag is technically nothing more than a branch, except we put it in the &lt;code&gt;.git/refs/tags/&lt;/code&gt; subdirectory instead of calling it a &lt;code&gt;head&lt;/code&gt;. So the simplest form of tag involves nothing more than</source>
          <target state="translated">「軽い」タグは技術的にはブランチにすぎませんが、 &lt;code&gt;head&lt;/code&gt; と呼ばずに &lt;code&gt;.git/refs/tags/&lt;/code&gt; サブディレクトリに配置する点が異なります。したがって、最も単純なタグの形式には、</target>
        </trans-unit>
        <trans-unit id="79a6a59906f3a3c6cb0aaa94c5e091d6ff4d2697" translate="yes" xml:space="preserve">
          <source>A &quot;patch ID&quot; is nothing but a sum of SHA-1 of the file diffs associated with a patch, with whitespace and line numbers ignored. As such, it&amp;rsquo;s &quot;reasonably stable&quot;, but at the same time also reasonably unique, i.e., two patches that have the same &quot;patch ID&quot; are almost guaranteed to be the same thing.</source>
          <target state="translated">「パッチID」は、パッチに関連付けられたファイルの差分のSHA-1の合計であり、空白と行番号は無視されます。そのため、「ある程度安定」していますが、同時にかなり合理的でもあります。つまり、「パッチID」が同じである2つのパッチは、ほぼ同じであることが保証されています。</target>
        </trans-unit>
        <trans-unit id="12c2193bcd0be75dda12f0549bb6c953d953abdc" translate="yes" xml:space="preserve">
          <source>A &quot;proxy command&quot; to execute (as &lt;code&gt;command host port&lt;/code&gt;) instead of establishing direct connection to the remote server when using the Git protocol for fetching. If the variable value is in the &quot;COMMAND for DOMAIN&quot; format, the command is applied only on hostnames ending with the specified domain string. This variable may be set multiple times and is matched in the given order; the first match wins.</source>
          <target state="translated">フェッチにGitプロトコルを使用する場合、リモートサーバーへの直接接続を確立する代わりに（ &lt;code&gt;command host port&lt;/code&gt; として）実行する「プロキシコマンド」。変数の値が「COMMAND for DOMAIN」形式の場合、コマンドは、指定されたドメイン文字列で終わるホスト名にのみ適用されます。この変数は複数回設定でき、指定された順序で照合されます。最初の試合が勝利します。</target>
        </trans-unit>
        <trans-unit id="b4f3117f71091d9312b93d71f6f1f95e92690216" translate="yes" xml:space="preserve">
          <source>A &quot;refspec&quot; is used by &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; and &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt; to describe the mapping between remote &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; and local ref.</source>
          <target state="translated">「refspec」は、リモート&lt;a href=&quot;#def_ref&quot;&gt;参照&lt;/a&gt;とローカル参照の間のマッピングを記述する&lt;a href=&quot;#def_push&quot;&gt;ため&lt;/a&gt;に&lt;a href=&quot;#def_fetch&quot;&gt;フェッチ&lt;/a&gt;とプッシュで使用されます。</target>
        </trans-unit>
        <trans-unit id="d877d63b6b5e9d7da0337dffb75c191c08f97905" translate="yes" xml:space="preserve">
          <source>A &quot;release&quot; tree into which tested patches are moved for final sanity checking, and as a vehicle to send them upstream to Linus (by sending him a &quot;please pull&quot; request.)</source>
          <target state="translated">テストされたパッチが最終的なサニティチェックのために移動される &quot;リリース &quot;ツリー、そしてそれらを上流のLinusに送るための手段として(彼に &quot;please pull &quot;リクエストを送ることによって)。</target>
        </trans-unit>
        <trans-unit id="5ff4d6ad0b357610ea5d99a54033d43fa5c5c86c" translate="yes" xml:space="preserve">
          <source>A &quot;test&quot; tree into which patches are initially placed so that they can get some exposure when integrated with other ongoing development. This tree is available to Andrew for pulling into -mm whenever he wants.</source>
          <target state="translated">テスト」ツリーは、パッチが他の進行中の開発と統合されたときにある程度の露出を得られるように、最初に配置されます。このツリーは、Andrew が望むときにいつでも -mm に引っ張ってくることができるようになっています。</target>
        </trans-unit>
        <trans-unit id="f3ec64c5418b4e1b2393cccdbc573a28510a5c03" translate="yes" xml:space="preserve">
          <source>A 1-based counter incremented by one for every path.</source>
          <target state="translated">1ベースのカウンタは、パスごとに1ずつインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="0615d3cb94994b8c99f6c3eb1d8a16fe3788d798" translate="yes" xml:space="preserve">
          <source>A 256-entry fan-out table just like v1.</source>
          <target state="translated">v1のような256エントリーのファンアウトテーブル。</target>
        </trans-unit>
        <trans-unit id="b5bb9a8b1ee368142624185fa1ae5c67aeb898ce" translate="yes" xml:space="preserve">
          <source>A 4-byte magic number &lt;code&gt;\377tOc&lt;/code&gt; which is an unreasonable fanout[0] value.</source>
          <target state="translated">4バイトのマジック番号 &lt;code&gt;\377tOc&lt;/code&gt; は、不当なファンアウト[0]値です。</target>
        </trans-unit>
        <trans-unit id="7a1ce6a5d795c5121faecb5f38bcdfbcd91b2ab7" translate="yes" xml:space="preserve">
          <source>A 4-byte version number (= 2)</source>
          <target state="translated">4バイトのバージョン番号(=2)</target>
        </trans-unit>
        <trans-unit id="8bede587e880e37efdb2a5ef16eda4ba90c67697" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_blob_object&quot;&gt;&quot;blob&quot; object&lt;/a&gt; is used to store file data.</source>
          <target state="translated">&lt;a href=&quot;#def_blob_object&quot;&gt;「ブロブ」オブジェクトが&lt;/a&gt;ストアファイルのデータに使用されています。</target>
        </trans-unit>
        <trans-unit id="d54288b35ef53475c72a23d4daf82b2c03c4a8f0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;&quot;commit&quot; object&lt;/a&gt; ties such directory hierarchies together into a &lt;a href=&quot;#def_DAG&quot;&gt;directed acyclic graph&lt;/a&gt; of revisions&amp;mdash;​each commit contains the object name of exactly one tree designating the directory hierarchy at the time of the commit. In addition, a commit refers to &quot;parent&quot; commit objects that describe the history of how we arrived at that directory hierarchy.</source>
          <target state="translated">&lt;a href=&quot;#def_commit_object&quot;&gt;オブジェクトの「コミット」&lt;/a&gt;に結びつけるようにディレクトリ階層を&lt;a href=&quot;#def_DAG&quot;&gt;有向非巡回グラフ&lt;/a&gt;コミットrevisions-それぞれのコミット時にディレクトリ階層を指定し、正確に一本の木のオブジェクト名が含まれています。さらに、コミットとは、ディレクトリ階層に到達した方法の履歴を表す「親」コミットオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="8530617aaaf740a14961ad3389fd991b174e36b0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents.</source>
          <target state="translated">&lt;a href=&quot;#def_commit_object&quot;&gt;オブジェクトがコミット&lt;/a&gt;すなわちその両親、開発のラインで論理前身の（空）のリスト（複数可）が含まれています。</target>
        </trans-unit>
        <trans-unit id="cb0f59568c969c04ae2919aa1276ec43b776c9bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a commit object, a tag object that points to a tag object that points to a commit object, etc.</source>
          <target state="translated">&lt;a href=&quot;#def_commit_object&quot;&gt;オブジェクトコミット&lt;/a&gt;または&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;を再帰的にコミット対象に間接参照することができます。以下はすべてコミットっぽいものです：コミットオブジェクト、コミットオブジェクトを指す&lt;a href=&quot;#def_tag_object&quot;&gt;タグオブジェクト&lt;/a&gt;、コミットオブジェクトを指すタグオブジェクトを指すタグオブジェクトなど。</target>
        </trans-unit>
        <trans-unit id="e6389313e21c94c3cd1f531678dbaff3d7f4b17f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;named reference&lt;/a&gt; to the &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; at the tip of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Heads are stored in a file in &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; directory, except when using packed refs. (See &lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs[1]&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;名前付き参照&lt;/a&gt;の&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;の先端に&lt;a href=&quot;#def_branch&quot;&gt;枝&lt;/a&gt;。パックされた参照を使用する場合を除き、 &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; は$ GIT_DIR / refs / heads /ディレクトリのファイルに保存されます。（&lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs [1]を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="0b389d584563a677fb26744bbc70caa1d1f76e96" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt;別からの変更に従うために使用される&lt;a href=&quot;#def_repository&quot;&gt;リポジトリを&lt;/a&gt;。通常は「refs / remotes / foo / bar」のようになり（「foo」という名前のリモートで「bar」という名前のブランチを追跡することを示します）、構成されたフェッチ&lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;の右側に一致します。リモート追跡ブランチには、直接の変更を含めたり、ローカルでコミットしたりしないでください。</target>
        </trans-unit>
        <trans-unit id="ace242fdc7f696a4feaa54f7241c321210896890" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; (indicating that it tracks a branch named &lt;code&gt;bar&lt;/code&gt; in a remote named &lt;code&gt;foo&lt;/code&gt;), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt;別からの変更に従うために使用される&lt;a href=&quot;#def_repository&quot;&gt;リポジトリを&lt;/a&gt;。それは、典型的には、のように見える &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; （これは名前のブランチを追跡ことを示す &lt;code&gt;bar&lt;/code&gt; リモートという名前で &lt;code&gt;foo&lt;/code&gt; ）し、設定されフェッチの右辺と一致する&lt;a href=&quot;#def_refspec&quot;&gt;refspecを&lt;/a&gt;。リモート追跡ブランチには、直接の変更を含めたり、ローカルでコミットしたりしないでください。</target>
        </trans-unit>
        <trans-unit id="bbf1d644e82a336ab047afaf23e6c38f6d2319f7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; under &lt;code&gt;refs/tags/&lt;/code&gt; namespace that points to an object of an arbitrary type (typically a tag points to either a &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; or a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). In contrast to a &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, a tag is not updated by the &lt;code&gt;commit&lt;/code&gt; command. A Git tag has nothing to do with a Lisp tag (which would be called an &lt;a href=&quot;#def_object_type&quot;&gt;object type&lt;/a&gt; in Git&amp;rsquo;s context). A tag is most typically used to mark a particular point in the commit ancestry &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt;下の &lt;code&gt;refs/tags/&lt;/code&gt; 名前空間は、任意のタイプのオブジェクトを指す（どちらかに、典型的には、タグ・ポイントこと&lt;a href=&quot;#def_tag_object&quot;&gt;タグ&lt;/a&gt;や&lt;a href=&quot;#def_commit_object&quot;&gt;オブジェクトをコミット&lt;/a&gt;）。&lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;とは対照的に、タグは &lt;code&gt;commit&lt;/code&gt; コマンドによって更新されません。Gitタグは、Lispタグ（Gitのコンテキストでは&lt;a href=&quot;#def_object_type&quot;&gt;オブジェクトタイプ&lt;/a&gt;と呼ばれます）とは関係ありません。タグは、最も一般的には、コミット先祖&lt;a href=&quot;#def_chain&quot;&gt;チェーンの&lt;/a&gt;特定のポイントをマークするために使用されます。</target>
        </trans-unit>
        <trans-unit id="fc46cfe77ce6b43ff04fe1e7aebea708602c159d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that holds the history of a separate project inside another repository (the latter of which is called &lt;a href=&quot;#def_superproject&quot;&gt;superproject&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;（と呼ばれる後者は別のリポジトリの内部に別のプロジェクトの履歴を保持している&lt;a href=&quot;#def_superproject&quot;&gt;親プロジェクト&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6438f4d0a1f63f0722cdeaf18b4e76a69d1faf0a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that references repositories of other projects in its working tree as &lt;a href=&quot;#def_submodule&quot;&gt;submodules&lt;/a&gt;. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules.</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;としての作業ツリー内の他のプロジェクトの参照リポジトリその&lt;a href=&quot;#def_submodule&quot;&gt;サブモジュール&lt;/a&gt;。スーパープロジェクトは、含まれているサブモジュールのコミットオブジェクトの名前を知っています（ただし、そのコピーは保持しません）。</target>
        </trans-unit>
        <trans-unit id="0c5fd39e912fa9dd55cd15e3992de80c831bb2a4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; which is used to track the same project but resides somewhere else. To communicate with remotes, see &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; or &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;同じプロジェクトを追跡するために使用されるが、他のどこかに存在しています。リモートと通信するには、&lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt;または&lt;a href=&quot;#def_push&quot;&gt;pushを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="328013b8812fa91caece6ff64eff68b5bce54efc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; is created by specifying the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch. The depth can later be changed with the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch, or full history restored with &lt;code&gt;--unshallow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅いクローンを&lt;/a&gt;指定することによって作成された&lt;a href=&quot;git-clone&quot;&gt;gitのクローン[1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; スイッチ。深さは後で&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; スイッチで変更するか、または--unshallowで完全な履歴を復元 &lt;code&gt;--unshallow&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4f6e57120855e95e9e182d5d994eedc42293e0e9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt;, with its truncated history, is useful when one is interested only in recent history of a project and getting full history from the upstream is expensive.</source>
          <target state="translated">履歴が切り捨てられた&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅いクローン&lt;/a&gt;は、プロジェクトの最近の履歴のみに関心があり、上流から完全な履歴を取得するのにコストがかかる場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5a5040a665f644abaf265d1f9e647b81d27b4cfd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tag_object&quot;&gt;&quot;tag&quot; object&lt;/a&gt; symbolically identifies and can be used to sign other objects. It contains the object name and type of another object, a symbolic name (of course!) and, optionally, a signature.</source>
          <target state="translated">&lt;a href=&quot;#def_tag_object&quot;&gt;「タグ」オブジェクト&lt;/a&gt;記号の識別とは、他のオブジェクトに署名するために使用することができます。オブジェクト名と別のオブジェクトのタイプ、記号名（もちろん！）、およびオプションで署名が含まれます。</target>
        </trans-unit>
        <trans-unit id="300bf6998ca24b2549892a071c929ed803f223bb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;&quot;tree&quot; object&lt;/a&gt; ties one or more &quot;blob&quot; objects into a directory structure. In addition, a tree object can refer to other tree objects, thus creating a directory hierarchy.</source>
          <target state="translated">&lt;a href=&quot;#def_tree_object&quot;&gt;「木」オブジェクトの&lt;/a&gt;ディレクトリ構造につながり、1つまたは複数の「ブロブ」オブジェクト。さらに、ツリーオブジェクトは他のツリーオブジェクトを参照できるため、ディレクトリ階層が作成されます。</target>
        </trans-unit>
        <trans-unit id="e7b0ce7b8c7522d74c7f9ad5ab8411731aaf299c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a tree object. Dereferencing a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; yields the tree object corresponding to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;'s top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;. The following are all tree-ishes: a &lt;a href=&quot;#def_commit-ish&quot;&gt;commit-ish&lt;/a&gt;, a tree object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a tree object, a tag object that points to a tag object that points to a tree object, etc.</source>
          <target state="translated">&lt;a href=&quot;#def_tree_object&quot;&gt;ツリーオブジェクト&lt;/a&gt;または&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;を再帰的にツリーオブジェクトに逆参照することができます。&lt;a href=&quot;#def_commit_object&quot;&gt;コミットオブジェクトを&lt;/a&gt;逆参照すると、&lt;a href=&quot;#def_revision&quot;&gt;リビジョン&lt;/a&gt;の最上位&lt;a href=&quot;#def_directory&quot;&gt;ディレクトリに&lt;/a&gt;対応するツリーオブジェクトが生成されます。以下はすべてツリーっぽいものです：&lt;a href=&quot;#def_commit-ish&quot;&gt;commit-ish&lt;/a&gt;、ツリーオブジェクト、ツリーオブジェクトを指す&lt;a href=&quot;#def_tag_object&quot;&gt;タグオブジェクト&lt;/a&gt;、ツリーオブジェクトを指すタグオブジェクトを指すタグオブジェクトなど。</target>
        </trans-unit>
        <trans-unit id="6766aaa194eae4342acb9b6eb8fe5dbb99ba5e2c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is clean, if it corresponds to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; referenced by the current &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;. Also see &quot;&lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt;&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;作業ツリーは、&lt;/a&gt;それが対応する場合、クリーンで&lt;a href=&quot;#def_revision&quot;&gt;改正&lt;/a&gt;現在で参照される&lt;a href=&quot;#def_head&quot;&gt;ヘッド&lt;/a&gt;。「&lt;a href=&quot;#def_dirty&quot;&gt;ダーティ&lt;/a&gt;」もご覧ください。</target>
        </trans-unit>
        <trans-unit id="910148d563c361f2f9ac9396584595cbecacd2d1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is said to be &quot;dirty&quot; if it contains modifications which have not been &lt;a href=&quot;#def_commit&quot;&gt;committed&lt;/a&gt; to the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;作業ツリーは、&lt;/a&gt;それがされていない変更が含まれている場合、「汚い」と言われて&lt;a href=&quot;#def_commit&quot;&gt;コミットし&lt;/a&gt;、現在に&lt;a href=&quot;#def_branch&quot;&gt;ブランチを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cef23a772a587d1dc5174a039d5d2a56a2421b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; string must use UNIX-style directory separators (forward slash &lt;code&gt;/&lt;/code&gt;), may contain any byte other than &lt;code&gt;LF&lt;/code&gt;, and must not start with double quote (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; の文字列は、（スラッシュUNIX形式のディレクトリ区切り文字を使用する必要があります &lt;code&gt;/&lt;/code&gt; 以外の任意のバイト含まれていてもよい、） &lt;code&gt;LF&lt;/code&gt; を、および二重引用符（で始めることはできません &lt;code&gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="25aaa39fff8a33da0ed231c681da2d1cc8f12d2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; specification can be either a single pattern, or a pair of such patterns separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">A &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 仕様単一パターン、またはそのようなパターンのペアのいずれかとすることができるコロンで区切られた「：」（これは、参考文献名はそれにコロンを持つことができないこと）。単一のパターン &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; の省略形にすぎません。</target>
        </trans-unit>
        <trans-unit id="5e4a35cc1f6ad4a24fbad41012f4dee139cf11ca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;-&lt;/code&gt; character in the column N means that the line appears in fileN but it does not appear in the result. A &lt;code&gt;+&lt;/code&gt; character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 列N手段の文字がその行がfileNに表示されますが、それは結果には表示されません。 &lt;code&gt;+&lt;/code&gt; の行が結果に表示され、fileNはそのラインを有していないこと列N手段の文字（換言すれば、行はその親の観点から、添加しました）。</target>
        </trans-unit>
        <trans-unit id="2f763d8aeb342898c485136e58023ca41a911c41" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fetch&lt;/code&gt; request can take the following arguments:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 要求は、次の引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="cdc49de55f827e970a03efc67dad77118b50f2b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filecopy&lt;/code&gt; command takes effect immediately. Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy.</source>
          <target state="translated">&lt;code&gt;filecopy&lt;/code&gt; コマンドはすぐに有効になります。ソースの場所が宛先にコピーされると、ソースの場所に適用される今後のコマンドは、コピーの宛先に影響を与えません。</target>
        </trans-unit>
        <trans-unit id="4b84f934e1b33bd4484622bc003d74b0f10abf36" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filerename&lt;/code&gt; command takes effect immediately. Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename.</source>
          <target state="translated">&lt;code&gt;filerename&lt;/code&gt; のコマンドはすぐに有効になります。ソースの場所の名前が宛先に変更されると、ソースの場所に今後適用されるコマンドはそこに新しいファイルを作成し、名前の変更の宛先に影響を与えません。</target>
        </trans-unit>
        <trans-unit id="e7ce3d61d685b39ad1b7df023b9aae5356d34434" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filter&lt;/code&gt; attribute can be set to a string value that names a filter driver specified in the configuration.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 設定で指定した名前フィルタドライバという属性は、文字列値に設定することができます。</target>
        </trans-unit>
        <trans-unit id="ca1b84b3e4f681759dcd049b031dfc1f3c0de5ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitattributes&lt;/code&gt; file is a simple text file that gives &lt;code&gt;attributes&lt;/code&gt; to pathnames.</source>
          <target state="translated">&lt;code&gt;gitattributes&lt;/code&gt; のファイルができます単純なテキストファイルである &lt;code&gt;attributes&lt;/code&gt; のパス名にします。</target>
        </trans-unit>
        <trans-unit id="d66ea4477ef0ba53ddd8e40294e2410ce0649ca9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitignore&lt;/code&gt; file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.</source>
          <target state="translated">&lt;code&gt;gitignore&lt;/code&gt; のファイルはGitは無視することを意図的に追跡されていないファイルを指定します。Gitによってすでに追跡されているファイルは影響を受けません。詳細については、以下の注を参照してください。</target>
        </trans-unit>
        <trans-unit id="6e637494c00a4030e3a229e0cf561d46671742b0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;map&lt;/code&gt; function is available that takes an &quot;original sha1 id&quot; argument and outputs a &quot;rewritten sha1 id&quot; if the commit has been already rewritten, and &quot;original sha1 id&quot; otherwise; the &lt;code&gt;map&lt;/code&gt; function can return several ids on separate lines if your commit filter emitted multiple commits.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 機能は、そうでなければ、「オリジナルSHA1 ID」を「オリジナルSHA1 IDが」引数を取り、既に書き換えられた場合にコミット「に書き換えSHA1 ID」を出力し、その利用可能です。コミットフィルターが複数のコミットを発行した場合、 &lt;code&gt;map&lt;/code&gt; 関数は複数のIDを別々の行に返すことができます。</target>
        </trans-unit>
        <trans-unit id="e0c17077eaabfda4b09416a4110316c7774b1c6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;mark&lt;/code&gt; command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format). It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit.</source>
          <target state="translated">&lt;code&gt;mark&lt;/code&gt; コマンドは、必要に応じて新たに作成された（形式については下記を参照）フロントエンドによって、将来の使用のためにコミットへの参照を保存するために高速インポートを要求し、表示されることがあります。フロントエンドが作成するすべてのコミットにマークを付けることは非常に一般的です。これにより、インポートされたコミットから将来のブランチの作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="9b43e35048f39cc98d8056bd70595785c095f7f4" translate="yes" xml:space="preserve">
          <source>A CVS server emulator for Git</source>
          <target state="translated">Git 用 CVS サーバーエミュレータ</target>
        </trans-unit>
        <trans-unit id="499e3b350610a0a7f42474bdeb7c1c19319ba58c" translate="yes" xml:space="preserve">
          <source>A Git project normally consists of a working directory with a &quot;.git&quot; subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an &quot;index&quot; file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads.</source>
          <target state="translated">Git プロジェクトは通常、作業ディレクトリとその最上位にある &quot;.git&quot; サブディレクトリで構成されます。.git ディレクトリには、プロジェクトの完全な履歴を表す圧縮オブジェクトデータベース、その履歴を現在の作業ツリーの内容にリンクする &quot;index&quot; ファイル、タグやブランチヘッドなどの履歴への名前付きポインタなどが含まれています。</target>
        </trans-unit>
        <trans-unit id="25a40623b731bcb70270f3faeba427fe44362569" translate="yes" xml:space="preserve">
          <source>A Git repository comes in two different flavours:</source>
          <target state="translated">Git リポジトリには二種類のフレーバーがあります。</target>
        </trans-unit>
        <trans-unit id="d81aa8115ce6f03214fb303ff61bdf68ead1b6d0" translate="yes" xml:space="preserve">
          <source>A GnuPG signed tag object will be created when &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u
&amp;lt;keyid&amp;gt;&lt;/code&gt; is used. When &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is not used, the committer identity for the current user is used to find the GnuPG key for signing. The configuration variable &lt;code&gt;gpg.program&lt;/code&gt; is used to specify custom GnuPG binary.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; または &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; を使用すると、GnuPG署名付きタグオブジェクトが作成されます。とき &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 使用されていない、現在のユーザーのためのコミッターのアイデンティティは、署名のためのGnuPGキーを見つけるために使用されます。設定変数 &lt;code&gt;gpg.program&lt;/code&gt; は、カスタムGnuPGバイナリを指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="79ace8057741243c07f0a9c439ea72cf149ebea7" translate="yes" xml:space="preserve">
          <source>A POSIX Extended Regular Expression used to determine what is a &quot;word&quot; when performing word-by-word difference calculations. Character sequences that match the regular expression are &quot;words&quot;, all other characters are &lt;strong&gt;ignorable&lt;/strong&gt; whitespace.</source>
          <target state="translated">単語ごとの差分計算を実行するときに「単語」を決定するために使用されるPOSIX拡張正規表現。正規表現に一致する文字シーケンスは「単語」であり、他のすべての文字は&lt;strong&gt;無視できる&lt;/strong&gt;空白です。</target>
        </trans-unit>
        <trans-unit id="d4b36e18a0d1a006f1ac7d7980a588087d5b430d" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive &lt;code&gt;git commit&lt;/code&gt; program.</source>
          <target state="translated">Tcl / Tkベースのグラフィカルインターフェイス。変更されたファイルを確認し、それらをインデックスにステージングし、コミットメッセージを入力して、新しいコミットを現在のブランチに記録します。このインターフェースは、対話性の低い &lt;code&gt;git commit&lt;/code&gt; プログラムの代替手段です。</target>
        </trans-unit>
        <trans-unit id="4b96204f8a09a4e60b67d30c184c76ab3aa13246" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical user interface to Git. &lt;code&gt;git gui&lt;/code&gt; focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories.</source>
          <target state="translated">GitへのTcl / Tkベースのグラフィカルユーザーインターフェイス。 &lt;code&gt;git gui&lt;/code&gt; は、新しいコミットの作成、既存のコミットの修正、ブランチの作成、ローカルマージの実行、リモートリポジトリへのフェッチ/プッシュを行うことで、ユーザーがリポジトリを変更できるようにすることに重点を置いています。</target>
        </trans-unit>
        <trans-unit id="24909c1b0660496a6bde046217501091c32d35a8" translate="yes" xml:space="preserve">
          <source>A URL identifying the server. Use an &lt;code&gt;imap://&lt;/code&gt; prefix for non-secure connections and an &lt;code&gt;imaps://&lt;/code&gt; prefix for secure connections. Ignored when imap.tunnel is set, but required otherwise.</source>
          <target state="translated">サーバーを識別するURL。非セキュア接続には &lt;code&gt;imap://&lt;/code&gt; プレフィックスを使用し、セキュア接続には &lt;code&gt;imaps://&lt;/code&gt; プレフィックスを使用します。imap.tunnelが設定されている場合は無視されますが、それ以外の場合は必須です。</target>
        </trans-unit>
        <trans-unit id="11e4f1c46822a29c15a31d1976020e3202745e04" translate="yes" xml:space="preserve">
          <source>A URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; explicitly instructs Git to invoke &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; as the second argument. If such a URL is encountered directly on the command line, the first argument is &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; 形式のURLは、2番目の引数として &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; を指定して &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; を呼び出すようにGitに明示的に指示します。そのようなURLがコマンドラインで直接検出される場合、最初の引数は &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; であり、構成されたリモートで検出される場合、最初の引数はそのリモートの名前です。</target>
        </trans-unit>
        <trans-unit id="bd88b7183354ef38e42a5694ea11c6ad40c90a63" translate="yes" xml:space="preserve">
          <source>A bare repository is normally an appropriately named &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; with a &lt;code&gt;.git&lt;/code&gt; suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden &lt;code&gt;.git&lt;/code&gt; sub-directory are directly present in the &lt;code&gt;repository.git&lt;/code&gt; directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available.</source>
          <target state="translated">ベアリポジトリは通常、適切に名前が付けられた&lt;a href=&quot;#def_directory&quot;&gt;ディレクトリ&lt;/a&gt;で、サフィックスが &lt;code&gt;.git&lt;/code&gt; で、リビジョン管理されているファイルのローカルにチェックアウトされたコピーはありません。つまり、通常は非表示の &lt;code&gt;.git&lt;/code&gt; サブディレクトリに存在するすべてのGit管理ファイルと制御ファイルは、代わりに &lt;code&gt;repository.git&lt;/code&gt; ディレクトリに直接存在し、他のファイルは存在せず、チェックアウトされません。通常、公開リポジトリの発行元は、ベアリポジトリを利用可能にします。</target>
        </trans-unit>
        <trans-unit id="fab59df7bed21e1355a3a3fdd6c1ee8b01aad2ba" translate="yes" xml:space="preserve">
          <source>A birds-eye view of Git&amp;rsquo;s source code</source>
          <target state="translated">Gitのソースコードの鳥瞰図</target>
        </trans-unit>
        <trans-unit id="23e4eeef8aa3fdcfbc58a9b30e01464d317f5146" translate="yes" xml:space="preserve">
          <source>A bit more elaborate report on tags, demonstrating that the format may be an entire script:</source>
          <target state="translated">タグに関するもう少し凝ったレポートで、フォーマットがスクリプト全体である可能性があることを示しています。</target>
        </trans-unit>
        <trans-unit id="146b6a7f060c34e94845d66a1242bb6c9a7f4e58" translate="yes" xml:space="preserve">
          <source>A blank line matches no files, so it can serve as a separator for readability.</source>
          <target state="translated">空行はファイルにマッチしないので、読みやすさのための区切り文字として機能します。</target>
        </trans-unit>
        <trans-unit id="556a519047d3c2b7e5ab74e824666155b316bdbf" translate="yes" xml:space="preserve">
          <source>A boolean or int to specify the level of verbose with &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git commit&lt;/code&gt; で詳細レベルを指定するブール値または整数。&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df9e4313a71ccb8b0351ad99469fa4eb3f3f9ac9" translate="yes" xml:space="preserve">
          <source>A boolean that controls whether to generate a cover-letter when format-patch is invoked, but in addition can be set to &quot;auto&quot;, to generate a cover-letter only when there&amp;rsquo;s more than one patch. Default is false.</source>
          <target state="translated">format-patchが呼び出されたときにカバーレターを生成するかどうかを制御するブール値。さらに、「auto」に設定して、複数のパッチがある場合にのみカバーレターを生成できます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="5594a28e2c0e4043dd1d1bbbff86fb17f935ca8e" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in hints (e.g. when a push failed, see &lt;code&gt;advice.*&lt;/code&gt; for a list). May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">ヒントの色を有効/無効にするブール（たとえば、プッシュが失敗した場合、リストについては &lt;code&gt;advice.*&lt;/code&gt; を参照してください）。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色がエラー出力が端末に行くときにのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2fbf675a2936dcecf3b1a2336c5df4b332604e58" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in push errors. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">プッシュエラーの色を有効/無効にするブール値。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色がエラー出力が端末に行くときにのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="423a3d788dfbe4bee04a423e0b36c0319dcd4d83" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;出力で色を有効/無効にするブール値。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色は、出力が端末にある場合にのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6f2e2c7e2ba4cb7674d5cd8117d8f0b42a85dae9" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;の出力で色を有効/無効にするブール値。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色は、出力が端末にある場合にのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd3e78cce49781de5f532bd4c5e0796c9098f940" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]の&lt;/a&gt;出力で色を有効/無効にするブール値。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色は、出力が端末にある場合にのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="297391e190582ac1cb26cf2a45a94d7b84f1e151" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color when pushes are rejected. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">プッシュが拒否されたときに色を有効/無効にするブール値。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）、その場合には、色がエラー出力が端末に行くときにのみ使用されます。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7bd8faf8bbae108bc3e3db709a35680c5dec839a" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable colored output when the pager is in use (default is true).</source>
          <target state="translated">ページャーが使用中のときに色付き出力を有効にするかどうかのブーリアン(デフォルトは true)。</target>
        </trans-unit>
        <trans-unit id="d29f1ced583e3f5a70811c52e97c2481cc279f73" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.</source>
          <target state="translated">エディタを使用してコミットメッセージを準備する際に、コミットメッセージテンプレートにステータス情報を含めることを有効/無効にするブール値です。デフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="c2d858807e8af6ae2203a74b627cef96e1757782" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable the use of html encoding when sending a patch. An html encoded patch will be bracketed with &amp;lt;pre&amp;gt; and have a content type of text/html. Ironically, enabling this option causes Thunderbird to send the patch as a plain/text, format=fixed email. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">パッチの送信時にHTMLエンコーディングの使用を有効または無効にするブール値。HTMLエンコードされたパッチは&amp;lt;pre&amp;gt;で囲まれ、コンテンツタイプはtext / htmlになります。皮肉なことに、このオプションを有効にすると、Thunderbirdはパッチをプレーン/テキスト、format = fixedメールとして送信します。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3f4c2eeab634e1e21aa0984b28bad1eef24f55b" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable verification of the server certificate used by the SSL/TLS connection. Default is &lt;code&gt;true&lt;/code&gt;. Ignored when imap.tunnel is set.</source>
          <target state="translated">SSL / TLS接続で使用されるサーバー証明書の検証を有効または無効にするブール値。デフォルトは &lt;code&gt;true&lt;/code&gt; です。imap.tunnelが設定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="2ba56edef0f759e6a6fb72f98e61ae0b81ab53f7" translate="yes" xml:space="preserve">
          <source>A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.</source>
          <target state="translated">空の出力行の前にスペースを印刷するという標準的な動作を禁止するブール値。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="aa4f8a419cff5bc7a9aa83bbb22ddc4383ad75de" translate="yes" xml:space="preserve">
          <source>A boolean to make git-clean do nothing unless given -f, -i or -n. Defaults to true.</source>
          <target state="translated">f、-i あるいは -n が与えられない限り git-clean を何もしないようにするブール値。デフォルトは true です。</target>
        </trans-unit>
        <trans-unit id="8ac4f1587b4bbb5651120aa9065e93380285e902" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.</source>
          <target state="translated">すべてのコミットを GPG 署名にするかどうかを指定するブール値。rebase のような操作を行う際にこのオプションを使用すると、多くのコミットが署名されることになります。GPG パスフレーズを何度も入力しないようにするためにエージェントを使うのは便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="285446918c9332ac6592ad772bc51e35d0bb94c4" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all tags should be GPG signed. Use of this option when running in an automated script can result in a large number of tags being signed. It is therefore convenient to use an agent to avoid typing your gpg passphrase several times. Note that this option doesn&amp;rsquo;t affect tag signing behavior enabled by &quot;-u &amp;lt;keyid&amp;gt;&quot; or &quot;--local-user=&amp;lt;keyid&amp;gt;&quot; options.</source>
          <target state="translated">すべてのタグにGPG署名を付けるかどうかを指定するブール値。自動スクリプトで実行するときにこのオプションを使用すると、多数のタグが署名される可能性があります。したがって、エージェントを使用すると、gpgパスフレーズを何度も入力する必要がなくなります。このオプションは、「-u &amp;lt;keyid&amp;gt;」または「--local-user = &amp;lt;keyid&amp;gt;」オプションによって有効にされるタグ署名動作に影響を与えないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8196128852a99f0296cb3a9178bf0edc9d5e344a" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether annotated tags created should be GPG signed. If &lt;code&gt;--annotate&lt;/code&gt; is specified on the command line, it takes precedence over this option.</source>
          <target state="translated">作成された注釈付きタグをGPG署名する必要があるかどうかを指定するブール値。コマンドラインで &lt;code&gt;--annotate&lt;/code&gt; が指定されている場合、このオプションよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="e95ae970d328003d484aaeb100825d3fb66dda25" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default.</source>
          <target state="translated">デフォルトでformat-patchの &lt;code&gt;--base=auto&lt;/code&gt; オプションを有効にするブール値。</target>
        </trans-unit>
        <trans-unit id="98939eb557a27a368986b34536ff6c8cd4c36abd" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;-s/--signoff&lt;/code&gt; option of format-patch by default. &lt;strong&gt;Note:&lt;/strong&gt; Adding the Signed-off-by: line to a patch should be a conscious act and means that you certify you have the rights to submit this work under the same open source license. Please see the &lt;code&gt;SubmittingPatches&lt;/code&gt; document for further discussion.</source>
          <target state="translated">デフォルトでformat-patch の &lt;code&gt;-s/--signoff&lt;/code&gt; オプションを有効にするブール値。&lt;strong&gt;注：&lt;/strong&gt; Signed-off-by：行をパッチに追加することは意識的な行為であり、同じオープンソースライセンスでこの作品を提出する権利があることを証明することを意味します。詳細については、 &lt;code&gt;SubmittingPatches&lt;/code&gt; ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="52843a970e21e2ecc8fa28c4ccdfeaf085918760" translate="yes" xml:space="preserve">
          <source>A boolean which can enable or disable sequence numbers in patch subjects. It defaults to &quot;auto&quot; which enables it only if there is more than one patch. It can be enabled or disabled for all messages by setting it to &quot;true&quot; or &quot;false&quot;. See --numbered option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">パッチサブジェクトのシーケンス番号を有効または無効にするブール値。デフォルトは「auto」で、複数のパッチがある場合にのみ有効になります。「true」または「false」に設定することにより、すべてのメッセージに対して有効または無効にできます。&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]の&lt;/a&gt; --numberedオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="4eaf2f30624eb10b8aee0a4842fe24fd9d5d1733" translate="yes" xml:space="preserve">
          <source>A boolean which disables using of EPSV ftp command by curl. This can helpful with some &quot;poor&quot; ftp servers which don&amp;rsquo;t support EPSV mode. Can be overridden by the &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; environment variable. Default is false (curl will use EPSV).</source>
          <target state="translated">curlによるEPSV ftpコマンドの使用を無効にするブール値。これは、EPSVモードをサポートしていない「貧弱な」ftpサーバーで役立ちます。 &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; 環境変数によってオーバーライドできます。デフォルトはfalseです（curlはEPSVを使用します）。</target>
        </trans-unit>
        <trans-unit id="a40656baca50661122d33e0890da13d751ed316a" translate="yes" xml:space="preserve">
          <source>A built-in pattern is provided for all languages listed in the previous section.</source>
          <target state="translated">前のセクションでリストアップされているすべての言語に対して、組み込みのパターンが提供されています。</target>
        </trans-unit>
        <trans-unit id="302353030177edeeb70686cd4f5139eb1acdd092" translate="yes" xml:space="preserve">
          <source>A bundle from a recipient repository&amp;rsquo;s point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:</source>
          <target state="translated">受信者リポジトリの観点から見たバンドルは、フェッチまたはプルする通常のリポジトリと同じです。たとえば、フェッチ時に参照をマップできます。</target>
        </trans-unit>
        <trans-unit id="1a5fcdefb11694692ac802e09961aef7e73e5df0" translate="yes" xml:space="preserve">
          <source>A caveat is that older reflog entries in your repository may be expired by &lt;code&gt;git gc&lt;/code&gt;. If B0 no longer appears in the reflog of the remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt;, the &lt;code&gt;--fork-point&lt;/code&gt; mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the &lt;code&gt;--fork-point&lt;/code&gt; option gives).</source>
          <target state="translated">注意点は、リポジトリ内の古いreflogエントリが &lt;code&gt;git gc&lt;/code&gt; によって期限切れになる可能性があることです。B0がリモート追跡ブランチ &lt;code&gt;origin/master&lt;/code&gt; のreflogに表示されなくなった場合、 &lt;code&gt;--fork-point&lt;/code&gt; モードは明らかにそれを見つけられず、失敗し、ランダムで役に立たない結果（B0の親など、 &lt;code&gt;--fork-point&lt;/code&gt; オプションを指定せずに同じコマンドを実行した場合）。</target>
        </trans-unit>
        <trans-unit id="e9b2d53c7c7f7197e6449bea92bdc1e149be79ae" translate="yes" xml:space="preserve">
          <source>A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true.</source>
          <target state="translated">除外されたファイルのみを含むチェンジリストは、このブールオプションがtrueに設定されている場合、空のコミットとしてインポートされます。</target>
        </trans-unit>
        <trans-unit id="1fded59f54db89df8b3f442b60da3137cb35cf1c" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;#def_ref&quot;&gt;refs&lt;/a&gt; together with an &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; containing all objects which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the refs, possibly accompanied by meta data from one or more &lt;a href=&quot;#def_porcelain&quot;&gt;porcelains&lt;/a&gt;. A repository can share an object database with other repositories via &lt;a href=&quot;#def_alternate_object_database&quot;&gt;alternates mechanism&lt;/a&gt;.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;#def_porcelain&quot;&gt;磁器&lt;/a&gt;からのメタデータを伴う可能性がある、参照から&lt;a href=&quot;#def_reachable&quot;&gt;到達可能な&lt;/a&gt;すべてのオブジェクトを含む&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベース&lt;/a&gt;と一緒の&lt;a href=&quot;#def_ref&quot;&gt;参照&lt;/a&gt;のコレクション。リポジトリは、&lt;a href=&quot;#def_alternate_object_database&quot;&gt;代替メカニズム&lt;/a&gt;を介して他のリポジトリとオブジェクトデータベースを共有できます。</target>
        </trans-unit>
        <trans-unit id="df01e27bf740894293c8642767b5b6f6ba2bfe1f" translate="yes" xml:space="preserve">
          <source>A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when &lt;a href=&quot;#def_merge&quot;&gt;merging&lt;/a&gt;.</source>
          <target state="translated">内容がオブジェクトとして保存されている、stat情報を持つファイルのコレクション。インデックスは、&lt;a href=&quot;#def_working_tree&quot;&gt;作業ツリーの&lt;/a&gt;保存されたバージョンです。正直なところ、&lt;a href=&quot;#def_merge&quot;&gt;マージ&lt;/a&gt;時に使用される作業ツリーの2番目、さらには3番目のバージョンを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="52a6e96629904ef8963fcbbd33f5c0e5160e4b14" translate="yes" xml:space="preserve">
          <source>A colon &lt;code&gt;:&lt;/code&gt; is used as in &lt;code&gt;srcref:dstref&lt;/code&gt; to mean &quot;use srcref&amp;rsquo;s value and store it in dstref&quot; in fetch and push operations. It may also be used to select a specific object such as with 'git cat-file': &quot;git cat-file blob v1.3.3:refs.c&quot;.</source>
          <target state="translated">コロン &lt;code&gt;:&lt;/code&gt; は、 &lt;code&gt;srcref:dstref&lt;/code&gt; と同様に、フェッチおよびプッシュ操作で「srcrefの値を使用してそれをdstrefに格納する」ことを意味するために使用されます。「git cat-file」などの特定のオブジェクトを選択するためにも使用できます：「git cat-file blob v1.3.3：refs.c」。</target>
        </trans-unit>
        <trans-unit id="0fa4235099cacbb93254de4106a73880e13a4bbc" translate="yes" xml:space="preserve">
          <source>A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. &lt;code&gt;:/^foo&lt;/code&gt;. The special sequence &lt;code&gt;:/!&lt;/code&gt; is reserved for modifiers to what is matched. &lt;code&gt;:/!-foo&lt;/code&gt; performs a negative match, while &lt;code&gt;:/!!foo&lt;/code&gt; matches a literal &lt;code&gt;!&lt;/code&gt; character, followed by &lt;code&gt;foo&lt;/code&gt;. Any other sequence beginning with &lt;code&gt;:/!&lt;/code&gt; is reserved for now. Depending on the given text, the shell&amp;rsquo;s word splitting rules might require additional quoting.</source>
          <target state="translated">コロン、スラッシュ、テキストの順で、指定した正規表現に一致するコミットメッセージを持つコミットを指定します。この名前は、HEADを含むすべての参照から到達可能な最も若い一致するコミットを返します。正規表現は、コミットメッセージの任意の部分に一致できます。文字列で始まるメッセージを照合するには、たとえば &lt;code&gt;:/^foo&lt;/code&gt; 使用できます。特別なシーケンス &lt;code&gt;:/!&lt;/code&gt; 一致するものに対する修飾子のために予約されています。 &lt;code&gt;:/!-foo&lt;/code&gt; は否定一致を実行しますが、 &lt;code&gt;:/!!foo&lt;/code&gt; はリテラル &lt;code&gt;!&lt;/code&gt; 文字の後に &lt;code&gt;foo&lt;/code&gt; が続きます。 &lt;code&gt;:/!&lt;/code&gt; で始まるその他のシーケンス現在予約されています。与えられたテキストによっては、シェルの単語分割ルールは追加の引用を必要とするかもしれません。</target>
        </trans-unit>
        <trans-unit id="13756e35429ac459169fe4f0ae98f0d2e3c822ed" translate="yes" xml:space="preserve">
          <source>A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch&amp;rsquo;s version (typically the current branch), and stage 3 is the version from the branch which is being merged.</source>
          <target state="translated">コロン、オプションでステージ番号（0〜3）が続き、コロンとパスが続き、指定されたパスにあるインデックスのblobオブジェクトを指定します。欠落しているステージ番号（およびそれに続くコロン）は、ステージ0エントリーを示します。マージ中、ステージ1は共通の祖先であり、ステージ2はターゲットブランチのバージョン（通常は現在のブランチ）であり、ステージ3はマージされるブランチのバージョンです。</target>
        </trans-unit>
        <trans-unit id="8caa5f563f7545c6d876e685c6213fbb94df9ad3" translate="yes" xml:space="preserve">
          <source>A comma and/or whitespace separated list of encodings that Git performs UTF-8 round trip checks on if they are used in an &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). The default value is &lt;code&gt;SHIFT-JIS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;working-tree-encoding&lt;/code&gt; 属性で使用されている場合にGitがUTF-8ラウンドトリップチェックを実行するエンコーディングのコンマまたは空白で区切られたリスト、あるいはその&lt;a href=&quot;gitattributes&quot;&gt;両方&lt;/a&gt;（gitattributes [5]を参照）。デフォルト値は &lt;code&gt;SHIFT-JIS&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9b2d1e893ce7e09a76d55d9b9450e681bcdfc845" translate="yes" xml:space="preserve">
          <source>A comma separated list of &lt;code&gt;--dirstat&lt;/code&gt; parameters specifying the default behavior of the &lt;code&gt;--dirstat&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and friends. The defaults can be overridden on the command line (using &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt;). The fallback defaults (when not changed by &lt;code&gt;diff.dirstat&lt;/code&gt;) are &lt;code&gt;changes,noncumulative,3&lt;/code&gt;. The following parameters are available:</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;およびその友達に対する &lt;code&gt;--dirstat&lt;/code&gt; オプションのデフォルトの動作を指定する &lt;code&gt;--dirstat&lt;/code&gt; パラメーターのコンマ区切りリスト。デフォルトはコマンドラインで上書きできます（ &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt; ）。フォールバックのデフォルト（ &lt;code&gt;diff.dirstat&lt;/code&gt; で変更されていない場合）は、 &lt;code&gt;changes,noncumulative,3&lt;/code&gt; です。次のパラメータを使用できます。</target>
        </trans-unit>
        <trans-unit id="90c61024b3e6d8b4fd7db663d99f9e656029c4cd" translate="yes" xml:space="preserve">
          <source>A comma separated list of common whitespace problems to notice. &lt;code&gt;git diff&lt;/code&gt; will use &lt;code&gt;color.diff.whitespace&lt;/code&gt; to highlight them, and &lt;code&gt;git apply --whitespace=error&lt;/code&gt; will consider them as errors. You can prefix &lt;code&gt;-&lt;/code&gt; to disable any of them (e.g. &lt;code&gt;-trailing-space&lt;/code&gt;):</source>
          <target state="translated">気づくべき一般的な空白問題のコンマ区切りリスト。 &lt;code&gt;git diff&lt;/code&gt; は &lt;code&gt;color.diff.whitespace&lt;/code&gt; を使用してそれらを強調表示し、 &lt;code&gt;git apply --whitespace=error&lt;/code&gt; はそれらをエラーと見なします。接頭辞 &lt;code&gt;-&lt;/code&gt; を付けて、それらを無効にすることができます（例： &lt;code&gt;-trailing-space&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="bb282cbfbc43caeda403e67d10ddbed3e0b9cd80" translate="yes" xml:space="preserve">
          <source>A comma-separated list of patterns of &quot;important&quot; config settings that should be recorded in the trace2 output. For example, &lt;code&gt;core.*,remote.*.url&lt;/code&gt; would cause the trace2 output to contain events listing each configured remote. May be overridden by the &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="translated">trace2出力に記録する必要がある「重要な」構成設定のパターンのコンマ区切りリスト。たとえば、 &lt;code&gt;core.*,remote.*.url&lt;/code&gt; は、trace2出力に、構成された各リモートをリストするイベントを含めます。 &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; 環境変数によってオーバーライドされる場合があります。デフォルトでは設定解除されています。</target>
        </trans-unit>
        <trans-unit id="5fab91cb4daf1c47222fcbb845cf8839d9381cfa" translate="yes" xml:space="preserve">
          <source>A commit comment is read from stdin. If a changelog entry is not provided via &quot;&amp;lt;&quot; redirection, &lt;code&gt;git commit-tree&lt;/code&gt; will just wait for one to be entered and terminated with ^D.</source>
          <target state="translated">コミットコメントは標準入力から読み込まれます。&quot;&amp;lt;&quot;リダイレクトを介して変更ログエントリが提供されない場合、 &lt;code&gt;git commit-tree&lt;/code&gt; は、エントリが入力され、^ Dで終了するのを待つだけです。</target>
        </trans-unit>
        <trans-unit id="3c1dc52f2c7f4f92de3fbbe4920a9bf34ad24479" translate="yes" xml:space="preserve">
          <source>A commit encapsulates:</source>
          <target state="translated">コミットがカプセル化されます。</target>
        </trans-unit>
        <trans-unit id="acc26f5acfd22e9eac8779b8f191ce6307d46b3a" translate="yes" xml:space="preserve">
          <source>A commit is usually created by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, which creates a commit whose parent is normally the current HEAD, and whose tree is taken from the content currently stored in the index.</source>
          <target state="translated">コミットは通常&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;によって作成され、通常は現在のHEADを親とするコミットを作成し、そのツリーは現在インデックスに格納されているコンテンツから取得されます。</target>
        </trans-unit>
        <trans-unit id="cdd78b04bea05d29acf58eb590016b304b9a695a" translate="yes" xml:space="preserve">
          <source>A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents.</source>
          <target state="translated">コミットオブジェクトはいくつでも親を持つことができます。正確には一つの親を持つと、それは通常のコミットとなります。複数の親を持つと、コミットは複数の履歴をマージしたものになります。最初の (ルートの)コミットには親はありません。</target>
        </trans-unit>
        <trans-unit id="f73e034726177d0d1de0cc7cb0b4640f70795d7d" translate="yes" xml:space="preserve">
          <source>A commit&amp;rsquo;s reachable set is the commit itself and the commits in its ancestry chain.</source>
          <target state="translated">コミットの到達可能なセットは、コミット自体とその祖先チェーン内のコミットです。</target>
        </trans-unit>
        <trans-unit id="9f0c7cb4b676d44b852130363daf17e0059e5d35" translate="yes" xml:space="preserve">
          <source>A common idiom to check &quot;fast-forward-ness&quot; between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts.</source>
          <target state="translated">2 つのコミット A と B の間の &quot;fast-forward-ness&quot; をチェックするための一般的なイディオムは、A と B の間のマージベースを計算して、それが A と同じかどうかをチェックすることです (この場合、A は B の祖先です)。</target>
        </trans-unit>
        <trans-unit id="efeda38b74e243af3941ca4cb1afcb6d50536c89" translate="yes" xml:space="preserve">
          <source>A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system.</source>
          <target state="translated">メンテナンスの一般的な認識は、単にバグを修正することである。しかし、長年にわたる研究や調査によると、メンテナンスの努力の大部分、80%以上が非是正措置のために使われていることが示されています(Pigosky 1997)。この認識は、実際にはシステムの機能強化である問題報告をユーザが提出することによって、永続しています。</target>
        </trans-unit>
        <trans-unit id="5edc728da69ffd96fd56c998aef47f3f04d15f9f" translate="yes" xml:space="preserve">
          <source>A common shorthand for &lt;code&gt;git diff-files -p&lt;/code&gt; is to just write &lt;code&gt;git
diff&lt;/code&gt;, which will do the same thing.</source>
          <target state="translated">&lt;code&gt;git diff-files -p&lt;/code&gt; の一般的な省略表現は、同じことを行う &lt;code&gt;git diff&lt;/code&gt; 記述することです。</target>
        </trans-unit>
        <trans-unit id="14a9ba1b1e1a8bc290e55e84eb3c20bc97ffb373" translate="yes" xml:space="preserve">
          <source>A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes. Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense. This command does &lt;code&gt;git p4 sync&lt;/code&gt; followed by &lt;code&gt;git rebase&lt;/code&gt; to move local commits on top of updated p4 changes.</source>
          <target state="translated">一般的な作業パターンは、p4デポから最新の変更をフェッチし、それらをローカルのコミットされていない変更とマージすることです。多くの場合、p4リポジトリはすべてのコードの最終的な場所であるため、リベースワークフローは理にかなっています。このコマンドは &lt;code&gt;git p4 sync&lt;/code&gt; に続いて &lt;code&gt;git rebase&lt;/code&gt; を実行して、更新されたp4の変更の上にローカルコミットを移動します。</target>
        </trans-unit>
        <trans-unit id="a4fa8348285318059dfacd14294d170b4fc808f0" translate="yes" xml:space="preserve">
          <source>A complete 40 byte or abbreviated commit SHA-1 in hex.</source>
          <target state="translated">完全な40バイトまたは省略形のコミットSHA-1を16進数で表したもの。</target>
        </trans-unit>
        <trans-unit id="02926b5c0160f21e1aa42320ded7f690bec583ac" translate="yes" xml:space="preserve">
          <source>A configuration identity. When given, causes values in the &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; subsection to take precedence over values in the &lt;code&gt;sendemail&lt;/code&gt; section. The default identity is the value of &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">構成ID。指定すると、 &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; サブセクションの値が &lt;code&gt;sendemail&lt;/code&gt; セクションの値よりも優先されます。デフォルトのIDは、 &lt;code&gt;sendemail.identity&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="35d1e222ae59833da8390e3205af99d5791ad8cb" translate="yes" xml:space="preserve">
          <source>A conflict occurs if both &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; have changes in a common segment of lines. If a conflict is found, &lt;code&gt;git merge-file&lt;/code&gt; normally outputs a warning and brackets the conflict with lines containing &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; and &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; markers. A typical conflict will look like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; の両方に、行の共通セグメントに変更があると、競合が発生します。競合が見つかった場合、通常、 &lt;code&gt;git merge-file&lt;/code&gt; は警告を出力し、&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;および&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;マーカーを含む行で競合を囲みます。典型的な競合は次のようになります。</target>
        </trans-unit>
        <trans-unit id="07bd76c9e5bd5a5c306cd10ddbfbe3c7ac2875c0" translate="yes" xml:space="preserve">
          <source>A convenience alias for &lt;code&gt;--only-trailers --only-input
--unfold&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--only-trailers --only-input --unfold&lt;/code&gt; の便利なエイリアス。</target>
        </trans-unit>
        <trans-unit id="97978af293e3af436b507f6dc4b9076f9f973577" translate="yes" xml:space="preserve">
          <source>A debug option to help with future &quot;partial clone&quot; development. This option specifies how missing objects are handled.</source>
          <target state="translated">将来の &quot;パーシャルクローン &quot;開発に役立つデバッグオプション。このオプションは、欠落したオブジェクトがどのように処理されるかを指定します。</target>
        </trans-unit>
        <trans-unit id="26d7d5495841c41cd87cf2e545d3c8aff9d18129" translate="yes" xml:space="preserve">
          <source>A default username, if one is not provided in the URL.</source>
          <target state="translated">URL で指定されていない場合のデフォルトのユーザ名。</target>
        </trans-unit>
        <trans-unit id="cba5596219f17f93a98404ea4497b915ef344a8c" translate="yes" xml:space="preserve">
          <source>A delimiter string is used to mark the end of the data. fast-import will compute the length by searching for the delimiter. This format is primarily useful for testing and is not recommended for real data.</source>
          <target state="translated">fast-importはデリミタを検索して長さを計算します。この形式は主にテストに便利で、実際のデータには推奨されません。</target>
        </trans-unit>
        <trans-unit id="21e88086f294c6f14da1c8f79767c0e47b61a6a2" translate="yes" xml:space="preserve">
          <source>A developer working as a participant in a group project needs to learn how to communicate with others, and uses these commands in addition to the ones needed by a standalone developer.</source>
          <target state="translated">グループプロジェクトの参加者として働く開発者は、他の人とのコミュニケーション方法を学ぶ必要があり、スタンドアロンの開発者が必要とするコマンドに加えて、これらのコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="aa00f0c6fcff7a20980dde937b6f2c6eff19948d" translate="yes" xml:space="preserve">
          <source>A directory to add to the whitelist of allowed directories. Unless --strict-paths is specified this will also include subdirectories of each named directory.</source>
          <target state="translated">許可されるディレクトリのホワイトリストに追加するディレクトリ。strict-paths が指定されていない限り、各ディレクトリのサブディレクトリも含まれます。</target>
        </trans-unit>
        <trans-unit id="a72583fc1f6c7369768db5e1d7fb0e226e0f4e70" translate="yes" xml:space="preserve">
          <source>A double-dot &lt;code&gt;..&lt;/code&gt; is often used as in &lt;code&gt;ref1..ref2&lt;/code&gt;, and in some contexts this notation means &lt;code&gt;^ref1 ref2&lt;/code&gt; (i.e. not in &lt;code&gt;ref1&lt;/code&gt; and in &lt;code&gt;ref2&lt;/code&gt;).</source>
          <target state="translated">二重ドット &lt;code&gt;..&lt;/code&gt; はしばしば &lt;code&gt;ref1..ref2&lt;/code&gt; のように使用され、一部のコンテキストでは、この表記は &lt;code&gt;^ref1 ref2&lt;/code&gt; 意味します（つまり、 &lt;code&gt;ref1&lt;/code&gt; および &lt;code&gt;ref2&lt;/code&gt; にはありません）。</target>
        </trans-unit>
        <trans-unit id="8cdb3523eaeda3961c032ea5c0f58f6c364cd9b3" translate="yes" xml:space="preserve">
          <source>A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files.</source>
          <target state="translated">オンザフライでパックを生成しないダムサーバは、クライアントがサーバが持っている参照やパックを発見するのを助けるために、 $GIT_DIR/info と $GIT_OBJECT_DIRECTORY/info ディレクトリにいくつかの補助情報ファイルを持っていなければなりません。このコマンドはそのような補助ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="3e6068affbbe0ff6a579ff1d24351f9cddf70755" translate="yes" xml:space="preserve">
          <source>A fairly central person acting as the integrator in a group project receives changes made by others, reviews and integrates them and publishes the result for others to use, using these commands in addition to the ones needed by participants.</source>
          <target state="translated">グループプロジェクトのインテグレータとして行動するかなり中心的な人が、他の人が行った変更を受け取り、レビューと統合を行い、その結果を他の人が使えるように公開します。</target>
        </trans-unit>
        <trans-unit id="62b9ceab10a1cb84bc6e55a7f4299b34b10f0e2f" translate="yes" xml:space="preserve">
          <source>A fast-forward is a special type of &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; where you have a &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; and you are &quot;merging&quot; another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;'s changes that happen to be a descendant of what you have. In such a case, you do not make a new &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; but instead just update to his revision. This will happen frequently on a &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branch&lt;/a&gt; of a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">早送りは特別なタイプの&lt;a href=&quot;#def_merge&quot;&gt;マージ&lt;/a&gt;で、&lt;a href=&quot;#def_revision&quot;&gt;リビジョンが&lt;/a&gt;あり、たまたま自分の子孫である別の&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;の変更を「マージ」します。このような場合は、新しい&lt;a href=&quot;#def_merge&quot;&gt;マージ&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;を行わず、代わりに彼のリビジョンに更新します。これは、リモート&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;のリモート&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;追跡ブランチ&lt;/a&gt;で頻繁に発生します。</target>
        </trans-unit>
        <trans-unit id="f1639e68ef8005bf8b9fd0a9765a95c3e36366d5" translate="yes" xml:space="preserve">
          <source>A fast-forward looks something like this:</source>
          <target state="translated">早送りはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="b2e7c39642f6628198b3a6330b5201dad9a7aff7" translate="yes" xml:space="preserve">
          <source>A fatal error was encountered.</source>
          <target state="translated">致命的なエラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="0b2eaf514674a6a55b836d451eca54479349bb70" translate="yes" xml:space="preserve">
          <source>A feature release is created from the &lt;code&gt;master&lt;/code&gt; branch, since &lt;code&gt;master&lt;/code&gt; tracks the commits that should go into the next feature release.</source>
          <target state="translated">機能リリースは以下から作成された &lt;code&gt;master&lt;/code&gt; から、支店 &lt;code&gt;master&lt;/code&gt; 次の機能リリースに行くべきコミットを追跡します。</target>
        </trans-unit>
        <trans-unit id="74ba6f95b54ef3076dd734e20033705f91d3f8bd" translate="yes" xml:space="preserve">
          <source>A few configuration variables (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) can make it easy to push both branches to your public tree. (See &lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;Setting up a public repository&lt;/a&gt;.)</source>
          <target state="translated">いくつかの構成変数（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）を使用すると、両方のブランチをパブリックツリーに簡単にプッシュできます。（&lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;パブリックリポジトリの設定を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="9b328fdc14f23c3b282a30f44ac30ff04e6b3868" translate="yes" xml:space="preserve">
          <source>A few more notes on matching via &lt;code&gt;gitdir&lt;/code&gt; and &lt;code&gt;gitdir/i&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;gitdir&lt;/code&gt; と &lt;code&gt;gitdir/i&lt;/code&gt; によるマッチングに関するいくつかの注意事項：</target>
        </trans-unit>
        <trans-unit id="74c1c3db8333ea0856e57a216b0202a880b8b0fd" translate="yes" xml:space="preserve">
          <source>A field name to sort on. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. When unspecified, &lt;code&gt;refname&lt;/code&gt; is used. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key.</source>
          <target state="translated">並べ替えるフィールド名。プレフィックス &lt;code&gt;-&lt;/code&gt; 値の降順でソートします。指定しない場合、 &lt;code&gt;refname&lt;/code&gt; が使用されます。--sort = &amp;lt;key&amp;gt;オプションを複数回使用できます。その場合、最後のキーが主キーになります。</target>
        </trans-unit>
        <trans-unit id="13fa2104992d30057f7ee2ca78ba1b9cc1b33c21" translate="yes" xml:space="preserve">
          <source>A filter driver consists of a &lt;code&gt;clean&lt;/code&gt; command and a &lt;code&gt;smudge&lt;/code&gt; command, either of which can be left unspecified. Upon checkout, when the &lt;code&gt;smudge&lt;/code&gt; command is specified, the command is fed the blob object from its standard input, and its standard output is used to update the worktree file. Similarly, the &lt;code&gt;clean&lt;/code&gt; command is used to convert the contents of worktree file upon checkin. By default these commands process only a single blob and terminate. If a long running &lt;code&gt;process&lt;/code&gt; filter is used in place of &lt;code&gt;clean&lt;/code&gt; and/or &lt;code&gt;smudge&lt;/code&gt; filters, then Git can process all blobs with a single filter command invocation for the entire life of a single Git command, for example &lt;code&gt;git add --all&lt;/code&gt;. If a long running &lt;code&gt;process&lt;/code&gt; filter is configured then it always takes precedence over a configured single blob filter. See section below for the description of the protocol used to communicate with a &lt;code&gt;process&lt;/code&gt; filter.</source>
          <target state="translated">フィルタードライバーは、 &lt;code&gt;clean&lt;/code&gt; コマンドと &lt;code&gt;smudge&lt;/code&gt; コマンドで構成され、どちらも指定しないでおくことができます。チェックアウト時に、 &lt;code&gt;smudge&lt;/code&gt; コマンドが指定されている場合、コマンドには標準入力からblobオブジェクトが供給され、その標準出力を使用してワークツリーファイルが更新されます。同様に、 &lt;code&gt;clean&lt;/code&gt; コマンドは、チェックイン時にワークツリーファイルの内容を変換するために使用されます。デフォルトでは、これらのコマンドは単一のblobのみを処理して終了します。 &lt;code&gt;clean&lt;/code&gt; や &lt;code&gt;smudge&lt;/code&gt; フィルターの代わりに長時間実行 &lt;code&gt;process&lt;/code&gt; フィルターを使用すると、Gitは、単一のGitコマンドの寿命全体にわたって、単一のフィルターコマンド呼び出しですべてのblobを処理できます。 &lt;code&gt;git add --all&lt;/code&gt; 。実行時間の長い &lt;code&gt;process&lt;/code&gt; フィルターが構成されている場合は、構成されている単一のBLOBフィルターよりも常に優先されます。 &lt;code&gt;process&lt;/code&gt; フィルターとの通信に使用されるプロトコルの説明については、以下のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a399e6db3987e04a0a954aa555198a880460b1b3" translate="yes" xml:space="preserve">
          <source>A format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, to be used for the todo list during an interactive rebase. The format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;で指定されているフォーマット文字列で、インタラクティブなリベース中にtodoリストに使用されます。この形式では、長いコミットハッシュが自動的に先頭に付加されます。</target>
        </trans-unit>
        <trans-unit id="3ef0d2618bd1f2707924d8265b8cbc81cb0f4df7" translate="yes" xml:space="preserve">
          <source>A formatted and hyperlinked copy of the latest Git documentation can be viewed at &lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt; or &lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs&lt;/a&gt;.</source>
          <target state="translated">最新のGitドキュメントのフォーマット済みでハイパーリンクされたコピーは、&lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https：//git.github.io/htmldocs/git.html&lt;/a&gt;または&lt;a href=&quot;index&quot;&gt;https://git-scm.com/docsで&lt;/a&gt;表示できます。</target>
        </trans-unit>
        <trans-unit id="1611e58cf3ba6bbcadd845b19a6529d9c8709a09" translate="yes" xml:space="preserve">
          <source>A freshly cloned repository contains a single branch head, by default named &quot;master&quot;, with the working directory initialized to the state of the project referred to by that branch head.</source>
          <target state="translated">クローンされたばかりのリポジトリには、デフォルトでは &quot;master&quot; という名前の単一のブランチヘッドが含まれ、作業ディレクトリはそのブランチヘッドが参照するプロジェクトの状態で初期化されています。</target>
        </trans-unit>
        <trans-unit id="9361f96571e895bc96ccb37b799d33736e1313bd" translate="yes" xml:space="preserve">
          <source>A frontend set up this way can use &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; commands to read information from the import in progress.</source>
          <target state="translated">この方法で設定されたフロントエンドは、 &lt;code&gt;progress&lt;/code&gt; 、 &lt;code&gt;get-mark&lt;/code&gt; 、 &lt;code&gt;ls&lt;/code&gt; 、および &lt;code&gt;cat-blob&lt;/code&gt; コマンドを使用して、進行中のインポートから情報を読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="5ec35e8b31b58ee10f23bf6c56b94488c655953e" translate="yes" xml:space="preserve">
          <source>A general note on safety: supplying this option without an expected value, i.e. as &lt;code&gt;--force-with-lease&lt;/code&gt; or &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; interacts very badly with anything that implicitly runs &lt;code&gt;git fetch&lt;/code&gt; on the remote to be pushed to in the background, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; on your repository in a cronjob.</source>
          <target state="translated">安全性に関する一般的な注意：予期される値なしでこのオプションを指定すると、つまり &lt;code&gt;--force-with-lease&lt;/code&gt; または &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; は、リモートで暗黙的に &lt;code&gt;git fetch&lt;/code&gt; を実行するものと非常に悪影響を及ぼします。バックグラウンドでプッシュされます（例：cronジョブのリポジトリの &lt;code&gt;git fetch origin&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ed755acace2a48ffeeff6fb565baf90507fd745" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &quot;git init&quot; or &quot;git clone&quot;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="translated">gitリポジトリは複数の作業ツリーをサポートできるため、一度に複数のブランチをチェックアウトできます。 &lt;code&gt;git worktree add&lt;/code&gt; 新しい作業ツリーをリポジトリに関連付けられています。この新しい作業ツリーは、「リンクされた作業ツリー」と呼ばれ、「git init」または「git clone」によって作成された「メイン作業ツリー」とは対照的です。リポジトリには、1つのメイン作業ツリー（ベアリポジトリでない場合）と0個以上のリンクされた作業ツリーがあります。リンクされた作業ツリーが完了したら、 &lt;code&gt;git worktree remove&lt;/code&gt; で削除します。</target>
        </trans-unit>
        <trans-unit id="bb35f01e2c3f5716f9ff7a011caefd2667f92277" translate="yes" xml:space="preserve">
          <source>A glob pattern that matches branch or tag names under refs/. For example, if you have many topic branches under refs/heads/topic, giving &lt;code&gt;topic/*&lt;/code&gt; would show all of them.</source>
          <target state="translated">refs /のブランチ名またはタグ名に一致するグロブパターン。たとえば、refs / heads / topicの下に多くのトピックブランチがある場合、 &lt;code&gt;topic/*&lt;/code&gt; を指定するとそれらすべてが表示されます。</target>
        </trans-unit>
        <trans-unit id="190546c0fc74bb90a9365e134f633644e2a48fc0" translate="yes" xml:space="preserve">
          <source>A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with &lt;code&gt;/*&lt;/code&gt;. The above specifies that all remote branches are tracked using remote-tracking branches in &lt;code&gt;refs/remotes/origin/&lt;/code&gt; hierarchy under the same name.</source>
          <target state="translated">グロビングrefspecには空でないRHS（つまり、リモート追跡ブランチでフェッチされたものを格納する）が必要であり、そのLHSおよびRHSは &lt;code&gt;/*&lt;/code&gt; で終わる必要があります。上記は、すべてのリモートブランチが、同じ名前の &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 階層のリモートトラッキングブランチを使用して追跡されることを指定しています。</target>
        </trans-unit>
        <trans-unit id="45b9d757fdd2ed971a566d8afcb44af578620a00" translate="yes" xml:space="preserve">
          <source>A good place to start is with the contents of the initial commit, with:</source>
          <target state="translated">最初のコミットの内容から始めるのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="9d5629e7ec2db5ea11dbadd12ca8d2c545f75144" translate="yes" xml:space="preserve">
          <source>A handy way to push the current branch to the same name on the remote.</source>
          <target state="translated">現在のブランチをリモート上の同名にプッシュする便利な方法。</target>
        </trans-unit>
        <trans-unit id="8420ab633ffe4ffea61082096882d33b9782db25" translate="yes" xml:space="preserve">
          <source>A header appears at the beginning and consists of the following:</source>
          <target state="translated">先頭にヘッダーが現れ、以下のような構成になっています。</target>
        </trans-unit>
        <trans-unit id="bd26c474482563b0a0cde7feb34691662847c30b" translate="yes" xml:space="preserve">
          <source>A helper advertising the capability &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; is saying that, when it is asked to &lt;code&gt;import refs/heads/topic&lt;/code&gt;, the stream it outputs will update the &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; ref.</source>
          <target state="translated">機能 &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; を宣伝するヘルパーは、 &lt;code&gt;import refs/heads/topic&lt;/code&gt; をインポートするように要求されたときに、出力するストリームが &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; を更新すると言っていますブランチ/トピック参照</target>
        </trans-unit>
        <trans-unit id="a8a80004c991a3f9b4309875108440f77b31093a" translate="yes" xml:space="preserve">
          <source>A html file (HTML fragment) which is included on the gitweb project &quot;summary&quot; page inside &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; block element. You can use it for longer description of a project, to provide links (for example to project&amp;rsquo;s homepage), etc. This is recognized only if XSS prevention is off (&lt;code&gt;$prevent_xss&lt;/code&gt; is false, see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;); a way to include a README safely when XSS prevention is on may be worked out in the future.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ブロック要素内のgitwebプロジェクトの「概要」ページに含まれるHTMLファイル（HTMLフラグメント）。これを使用して、プロジェクトの詳細な説明、リンク（プロジェクトのホームページなど）の提供などに使用できます。これは、XSS防止がオフになっている場合にのみ認識されます（ &lt;code&gt;$prevent_xss&lt;/code&gt; がfalse、&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]を&lt;/a&gt;参照）。 XSS防止がオンのときにREADMEを安全に含める方法は、将来的には解決される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5fd437060459f74aebbd18b9e1cd799a77abb2e3" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">人間が読める説明。取得に成功したrefの場合、説明は必要ありません。失敗した ref の場合は、失敗した理由を説明します。</target>
        </trans-unit>
        <trans-unit id="41f2620460bac465215c8ebb35f39e6332181467" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">人間が読める説明。プッシュに成功した審判の場合は、説明は必要ありません。失敗した ref の場合は、失敗した理由を説明します。</target>
        </trans-unit>
        <trans-unit id="7a9b8dd4dd7232e67cd2ac62d96fc72ced1418df" translate="yes" xml:space="preserve">
          <source>A leading &quot;&lt;code&gt;**&lt;/code&gt;&quot; followed by a slash means match in all directories. For example, &quot;&lt;code&gt;**/foo&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot; anywhere, the same as pattern &quot;&lt;code&gt;foo&lt;/code&gt;&quot;. &quot;&lt;code&gt;**/foo/bar&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;bar&lt;/code&gt;&quot; anywhere that is directly under directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot;.</source>
          <target state="translated">先頭に「 &lt;code&gt;**&lt;/code&gt; 」とそれに続くスラッシュは、すべてのディレクトリで一致することを意味します。たとえば、「 &lt;code&gt;**/foo&lt;/code&gt; 」は、パターン「 &lt;code&gt;foo&lt;/code&gt; 」と同じように、どこでもファイルまたはディレクトリ「 &lt;code&gt;foo&lt;/code&gt; 」と一致します。「 &lt;code&gt;**/foo/bar&lt;/code&gt; 」一致ファイルまたはディレクトリの「 &lt;code&gt;bar&lt;/code&gt; 」に直接ディレクトリの下にある任意の場所には「 &lt;code&gt;foo&lt;/code&gt; 」。</target>
        </trans-unit>
        <trans-unit id="97f6b7568cdd7cd0d826aa05b6dbc1219066bda8" translate="yes" xml:space="preserve">
          <source>A leading &amp;ldquo;&lt;strong&gt;&amp;rdquo; followed by a slash means match in all directories. For example, &amp;ldquo;&lt;/strong&gt;/foo&amp;rdquo; matches file or directory &amp;ldquo;foo&amp;rdquo; anywhere, the same as pattern &amp;ldquo;foo&amp;rdquo;. &amp;ldquo;**/foo/bar&amp;rdquo; matches file or directory &amp;ldquo;bar&amp;rdquo; anywhere that is directly under directory &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">先頭に&amp;ldquo; &lt;strong&gt;&amp;rdquo;とそれに続くスラッシュは、すべてのディレクトリで一致することを意味します。たとえば、「&lt;/strong&gt; / foo」は、パターン「foo」と同じように、どこでもファイルまたはディレクトリ「foo」と一致します。「** / foo / bar」は、ディレクトリ「foo」の直下にあるファイルまたはディレクトリ「bar」と一致します。</target>
        </trans-unit>
        <trans-unit id="2c8f962f2c5484e8e35937a88a5b10524899265d" translate="yes" xml:space="preserve">
          <source>A line starting with # serves as a comment. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first hash for patterns that begin with a hash.</source>
          <target state="translated">＃で始まる行はコメントとして機能します。ハッシュで始まるパターンの最初のハッシュの前にバックスラッシュ（ &quot; &lt;code&gt;\&lt;/code&gt; &quot;）を置きます。</target>
        </trans-unit>
        <trans-unit id="93ea1d2be8a3f17ecb8e1b8c1df7c56dd65b653c" translate="yes" xml:space="preserve">
          <source>A line that defines a value can be continued to the next line by ending it with a &lt;code&gt;\&lt;/code&gt;; the backquote and the end-of-line are stripped. Leading whitespaces after &lt;code&gt;name =&lt;/code&gt;, the remainder of the line after the first comment character &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt;, and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim.</source>
          <target state="translated">値を定義する行は、 &lt;code&gt;\&lt;/code&gt; で終了することにより、次の行に継続できます。バッククォートと行末は取り除かれます。 &lt;code&gt;name =&lt;/code&gt; の後の先頭の空白、最初のコメント文字 &lt;code&gt;#&lt;/code&gt; または &lt;code&gt;;&lt;/code&gt; の後の行の残り。、および行の末尾の空白は、二重引用符で囲まれていない限り破棄されます。値内の内部の空白はそのまま保持されます。</target>
        </trans-unit>
        <trans-unit id="e045379bf9ceca1c017025a4aa6255f96ea8439c" translate="yes" xml:space="preserve">
          <source>A list of SSL ciphers to use when negotiating an SSL connection. The available ciphers depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; option; see the libcurl documentation for more details on the format of this list.</source>
          <target state="translated">SSL接続のネゴシエーション時に使用するSSL暗号のリスト。使用可能な暗号は、libcurlがNSSまたはOpenSSLのどちらに対して構築されたか、および使用中の暗号ライブラリの特定の構成によって異なります。内部的には、これは &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; オプションを設定します。このリストの形式の詳細については、libcurlのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6c29c3e295aee253a56f78c75eca16ee4e34a579" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt; (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.</source>
          <target state="translated">特定のオブジェクトとトランスポートへの参照を指定する引数のリスト。gitrev &lt;code&gt;git rev-parse&lt;/code&gt; と &lt;code&gt;git rev-list&lt;/code&gt; に使用できます（名前付きの参照を含みます。以下の「仕様の参照」を参照）。たとえば、 &lt;code&gt;master~10..master&lt;/code&gt; と、現在のマスター参照が、10番目の祖先のコミット以降に追加されたすべてのオブジェクトとともにパッケージ化されます。パッケージ化できる参照とオブジェクトの数に明示的な制限はありません。</target>
        </trans-unit>
        <trans-unit id="420b50217489bdf5f6fb9acc6b31c779455eb7fa" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt;, that specifies the specific objects and references to export. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master~9 and master~10.</source>
          <target state="translated">エクスポートする特定のオブジェクトと参照を指定する引数のリスト &lt;code&gt;git rev-parse&lt;/code&gt; および &lt;code&gt;git rev-list&lt;/code&gt; で使用できます。たとえば、 &lt;code&gt;master~10..master&lt;/code&gt; は、10番目の祖先がコミットされてから追加されたすべてのオブジェクト、および（--reference-excluded-parentsオプションが指定されていない限り）master〜9およびマスター〜10。</target>
        </trans-unit>
        <trans-unit id="fb05e036e321c60d20fab2990848c796c4fdcdc0" translate="yes" xml:space="preserve">
          <source>A list of colors, separated by commas, that can be used to draw history lines in &lt;code&gt;git log --graph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git log --graph&lt;/code&gt; で履歴行を描画するために使用できる、コンマで区切られた色のリスト。</target>
        </trans-unit>
        <trans-unit id="bf5bc7dd64f11fdc046f9ab831535ad5346e3642" translate="yes" xml:space="preserve">
          <source>A list of metadata for the ith object ID including:</source>
          <target state="translated">ith オブジェクト ID のメタデータのリスト。</target>
        </trans-unit>
        <trans-unit id="71a1660072afab5f192d304c6526e11a86c64fed" translate="yes" xml:space="preserve">
          <source>A list of objects, where each &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the list contains a reference to its successor (for example, the successor of a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; could be one of its &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;のリスト。リスト内の各オブジェクトには、その後続オブジェクトへの参照が含まれています（たとえば、&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;の後続オブジェクトは、その&lt;a href=&quot;#def_parent&quot;&gt;親の&lt;/a&gt; 1つである場合があります）。</target>
        </trans-unit>
        <trans-unit id="b5ed6b3e420a3426ad69e7d40c511b1585c55951" translate="yes" xml:space="preserve">
          <source>A list of packfile names.</source>
          <target state="translated">パックファイル名のリスト。</target>
        </trans-unit>
        <trans-unit id="eacf8acfc6a510356f2536425e15b68215e037b6" translate="yes" xml:space="preserve">
          <source>A list of references used to limit the references reported as available. This is principally of use to &lt;code&gt;git fetch&lt;/code&gt;, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, &lt;code&gt;git bundle&lt;/code&gt; acts like &lt;code&gt;git fetch-pack&lt;/code&gt;).</source>
          <target state="translated">利用可能として報告される参照を制限するために使用される参照のリスト。これは主に &lt;code&gt;git fetch&lt;/code&gt; に使用されます。これは、要求された参照のみを受け取り、必ずしもパック内のすべてではないことを期待します（この場合、 &lt;code&gt;git bundle&lt;/code&gt; は &lt;code&gt;git fetch-pack&lt;/code&gt; のように動作します）。</target>
        </trans-unit>
        <trans-unit id="97e674656171c048f36512c6e555d0bf166acfba" translate="yes" xml:space="preserve">
          <source>A listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:</source>
          <target state="translated">リストは、一時的なファイル名と追跡されたパス名との関連付けを提供する標準出力に書き込まれます。リスト形式には2つのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="4f1fa860bd3075a2f2e7d9bfa6fd3e508ce503b8" translate="yes" xml:space="preserve">
          <source>A long running filter demo implementation can be found in &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; located in the Git core repository. If you develop your own long running filter process then the &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; environment variables can be very helpful for debugging (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;).</source>
          <target state="translated">長時間実行されるフィルターデモの実装は、Gitコアリポジトリにある &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; にあります。独自の長期実行フィルタープロセスを開発する場合、 &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; 環境変数がデバッグに非常に役立ちます（&lt;a href=&quot;git&quot;&gt;git [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0c85a74fa5c3962acf646f43bc3d679fdbcbb049" translate="yes" xml:space="preserve">
          <source>A mapping will override any user information from P4. Mappings for multiple P4 user can be defined.</source>
          <target state="translated">マッピングは、P4 からのユーザー情報をすべて上書きします。複数のP4ユーザーに対するマッピングを定義することができます。</target>
        </trans-unit>
        <trans-unit id="f830620e3507664edd811855851325f3aba696d1" translate="yes" xml:space="preserve">
          <source>A mark reference, &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; is the mark number.</source>
          <target state="translated">マーク参照 &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; 、ここで &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; はマーク番号です。</target>
        </trans-unit>
        <trans-unit id="baabb9591c6356cfbcbcedc1f1f1f517fd26280b" translate="yes" xml:space="preserve">
          <source>A merge is made by combining the changes made in &lt;code&gt;branchname&lt;/code&gt; and the changes made up to the latest commit in your current branch since their histories forked. The work tree is overwritten by the result of the merge when this combining is done cleanly, or overwritten by a half-merged results when this combining results in conflicts. Therefore, if you have uncommitted changes touching the same files as the ones impacted by the merge, Git will refuse to proceed. Most of the time, you will want to commit your changes before you can merge, and if you don&amp;rsquo;t, then &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; can take these changes away while you&amp;rsquo;re doing the merge, and reapply them afterwards.</source>
          <target state="translated">マージは、 &lt;code&gt;branchname&lt;/code&gt; で行われた変更と、履歴がフォークされてから現在のブランチで最新のコミットまで行われた変更を組み合わせることによって行われます。作業ツリーは、この結合が正常に行われた場合はマージの結果によって上書きされ、この結合が競合を引き起こす場合はハーフマージされた結果によって上書きされます。したがって、マージによって影響を受けたファイルと同じファイルを変更するコミットされていない変更がある場合、Gitは処理を拒否します。ほとんどの場合、マージする前に変更をコミットする必要があります。コミットしない場合、&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;はマージ中にこれらの変更を取り除き、後でそれらを再適用できます。</target>
        </trans-unit>
        <trans-unit id="e4d489b543f60fc98d2a6018d75091a747eea01a" translate="yes" xml:space="preserve">
          <source>A merged version reconciling the changes from all branches to be merged is committed, and your &lt;code&gt;HEAD&lt;/code&gt;, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.</source>
          <target state="translated">マージされるすべてのブランチからの変更を調整するマージされたバージョンがコミットされ、 &lt;code&gt;HEAD&lt;/code&gt; 、インデックス、および作業ツリーがそれに更新されます。作業ツリーが重複しない限り、変更を加えることができます。更新はそれらを保持します。</target>
        </trans-unit>
        <trans-unit id="556c7318c2e7e187ba3d844ceeba1d7c90165db2" translate="yes" xml:space="preserve">
          <source>A minimal repository browser and Git tool output highlighter written in C using Ncurses.</source>
          <target state="translated">Ncursesを使ってC言語で書かれたミニマムなリポジトリブラウザとGitツールの出力ハイライターです。</target>
        </trans-unit>
        <trans-unit id="0f82fb44f773fe4ef6363789a0bed7a920af8c57" translate="yes" xml:space="preserve">
          <source>A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers.</source>
          <target state="translated">マイナーな問題ですが、リポジトリ内のすべての名前とメールを更新することを目標としているユーザーは、 --env-filter に誘導されて、作者とコミッターのみを更新し、タガーを欠いてしまうかもしれません。</target>
        </trans-unit>
        <trans-unit id="ee7974b838cbb4f29c64d1d141d31a017781be24" translate="yes" xml:space="preserve">
          <source>A more detailed explanation follows.</source>
          <target state="translated">より詳細な説明は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1294d206b2b9b4a7e8a2c5b691b195e05326798f" translate="yes" xml:space="preserve">
          <source>A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added &quot;What is unexpected&quot; in the old commit, for example, is completely red, even if the intent of the old commit was to add something.</source>
          <target state="translated">ナイーブな色分けされた diff の diff は、行全体が赤や緑に着色されていて、実はちょっと読みづらい。例えば、古いコミットで「予期せぬこと」を追加した行は、たとえ古いコミットの意図が何かを追加することであったとしても、完全に赤になっています。</target>
        </trans-unit>
        <trans-unit id="f995936d742d7948d27ea58d580269673915afeb" translate="yes" xml:space="preserve">
          <source>A name referring to a list of repositories as the value of remotes.&amp;lt;group&amp;gt; in the configuration file. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">構成ファイルのremotes。&amp;lt;group&amp;gt;の値としてリポジトリのリストを参照する名前。（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="285bedb08cb2a07c72d29f3452de603f4eff78e2" translate="yes" xml:space="preserve">
          <source>A name that begins with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) that points to an &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; or another ref (the latter is called a &lt;a href=&quot;#def_symref&quot;&gt;symbolic ref&lt;/a&gt;). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details. Refs are stored in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object_name&quot;&gt;オブジェクト名&lt;/a&gt;または別のref（後者は&lt;a href=&quot;#def_symref&quot;&gt;シンボリックref&lt;/a&gt;と呼ばれます）を指す &lt;code&gt;refs/&lt;/code&gt; （例： &lt;code&gt;refs/heads/master&lt;/code&gt; ）で始まる名前。便宜上、refはGitコマンドの引数として使用される場合、省略されることがあります。詳細については、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;を参照してください。参照は&lt;a href=&quot;#def_repository&quot;&gt;リポジトリに&lt;/a&gt;格納されます。</target>
        </trans-unit>
        <trans-unit id="7703b2466f10a68f3b1c01b58b3d6c6dd1bbbf9e" translate="yes" xml:space="preserve">
          <source>A newly created object is stored in its own file. The objects are splayed over 256 subdirectories using the first two characters of the sha1 object name to keep the number of directory entries in &lt;code&gt;objects&lt;/code&gt; itself to a manageable number. Objects found here are often called &lt;code&gt;unpacked&lt;/code&gt; (or &lt;code&gt;loose&lt;/code&gt;) objects.</source>
          <target state="translated">新しく作成されたオブジェクトは、独自のファイルに保存されます。オブジェクトは、sha1オブジェクト名の最初の2文字を使用して256を超えるサブディレクトリに表示され、 &lt;code&gt;objects&lt;/code&gt; 自体のディレクトリエントリの数を管理可能な数に保ちます。ここで見つかったオブジェクトは、しばしば &lt;code&gt;unpacked&lt;/code&gt; （または &lt;code&gt;loose&lt;/code&gt; ）オブジェクトと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="4642a2b17c96a073cdb3a7085d71034eb452a227" translate="yes" xml:space="preserve">
          <source>A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.</source>
          <target state="translated">オブジェクト名の曖昧でない短縮名。オプション core.warnAmbiguousRefs を使用して、厳密な省略形モードを選択します。</target>
        </trans-unit>
        <trans-unit id="969533e24645fc570f9e6901a33806920e5cb706" translate="yes" xml:space="preserve">
          <source>A note on commit messages: Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">コミットメッセージに関する注意：必須ではありませんが、変更を要約した単一の短い（50文字未満）行でコミットメッセージを開始し、その後に空白行を入れてから、さらに詳細な説明を書くことをお勧めします。コミットメッセージの最初の空白行までのテキストはコミットタイトルとして扱われ、そのタイトルはGit全体で使用されます。たとえば、&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;はコミットをメールに変換し、件名のタイトルと本文の残りのコミットを使用します。</target>
        </trans-unit>
        <trans-unit id="4dfc512a94e79667c45c7af73a6fa69e373a158c" translate="yes" xml:space="preserve">
          <source>A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2.</source>
          <target state="translated">オプションの進捗状況インジケータを表示する前に何秒遅らせるかを指定します。デフォルトは 2 です。</target>
        </trans-unit>
        <trans-unit id="678367292507a434e0e80079657b6dfcb1357dad" translate="yes" xml:space="preserve">
          <source>A number controlling the amount of output shown by the recursive merge strategy. Overrides merge.verbosity. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;</source>
          <target state="translated">再帰的マージ戦略によって示される出力の量を制御する数値。merge.verbosityをオーバーライドします。&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="5b6753b358cd59601b720b7e321e301f821aeaac" translate="yes" xml:space="preserve">
          <source>A number of commands are useful for keeping track of what you&amp;rsquo;re about to commit:</source>
          <target state="translated">コミットしようとしている内容を追跡するには、いくつかのコマンドが役立ちます。</target>
        </trans-unit>
        <trans-unit id="9a527e05c01a1cd1e2fbbfb008d8a0a9991b3e36" translate="yes" xml:space="preserve">
          <source>A number of other receive.* config options are available to tweak its behavior, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">他の多くのreceive。*設定オプションを使用して、その動作を微調整できます&lt;a href=&quot;git-config&quot;&gt;。git-config[1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2735235afad8c3de74567bf475c2f66e22a1a38" translate="yes" xml:space="preserve">
          <source>A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. &quot;people who are primarily interested in the networking part of the kernel&quot;) who may have their own set of tags (e.g. &quot;this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release&quot;) to another circle of people (e.g. &quot;people who integrate various subsystem improvements&quot;). The latter are usually not interested in the detailed tags used internally in the former group (that is what &quot;internal&quot; means). That is why it is desirable not to follow tags automatically in this case.</source>
          <target state="translated">ワンショットプルは、あるコミット履歴が、あるサークルの人々 (例えば、「カーネルのネットワーク部分に主に興味を持っている人々」)から別のサークルの人々 (例えば、「これは 2.6.21 リリースで一般消費のために提案されるネットワーキンググループからの 3 番目のリリース候補です」)への境界を越えていることを示しています。後者は通常、前者のグループで内部的に使用されている詳細なタグには興味がありません(「内部的」というのはそういう意味です)。だからこそ、この場合はタグを自動的に追従させないことが望ましいのです。</target>
        </trans-unit>
        <trans-unit id="9cabaac84bf06e47bfc060c7436d54129d5c9635" translate="yes" xml:space="preserve">
          <source>A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES) enables Git to read from the pack archive.</source>
          <target state="translated">パックのインデックスファイル(.idx)が生成され、パック内のオブジェクトへの高速でランダムなアクセスが可能になります。インデックスファイル (.idx)とパックされたアーカイブ (.pack)の両方を $GIT_OBJECT_DIRECTORY の pack/サブディレクトリ (あるいは $GIT_ALTERNATE_OBJECT_DIRECTORIES のいずれかのディレクトリ)に置くことで、Git がパックアーカイブから読み込めるようになります。</target>
        </trans-unit>
        <trans-unit id="397ffaa6c68ed0147644cba4450a6f826844c8cb" translate="yes" xml:space="preserve">
          <source>A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file.</source>
          <target state="translated">パックとは、個々に圧縮されたオブジェクトの集合体で、デルタ圧縮が適用されており、関連するインデックスファイルとともに1つのファイルに格納されています。</target>
        </trans-unit>
        <trans-unit id="f35f65ed82291bd06ac4c67bd1644d87a71cb117" translate="yes" xml:space="preserve">
          <source>A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don&amp;rsquo;t understand the latter. By default, &lt;code&gt;git pack-objects&lt;/code&gt; only uses the former format for better compatibility. This option allows the command to use the latter format for compactness. Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent.</source>
          <target state="translated">パックされたアーカイブは、デルタのベースオブジェクトを20バイトのオブジェクト名またはストリーム内のオフセットとして表現できますが、Gitの古いバージョンでは後者を理解できません。デフォルトでは、 &lt;code&gt;git pack-objects&lt;/code&gt; は互換性を高めるために以前の形式のみを使用します。このオプションを使用すると、コマンドはコンパクトにするために後者の形式を使用できます。デルタチェーンの長さの平均に応じて、このオプションは通常、結果のパックファイルを3〜5％縮小します。</target>
        </trans-unit>
        <trans-unit id="60fd37e1abf8d7c37fbc7d9812df5fcd79af795e" translate="yes" xml:space="preserve">
          <source>A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format. In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta.</source>
          <target state="translated">パックアーカイブは、2つのリポジトリ間で一連のオブジェクトを転送する効率的な方法であり、アクセス効率の良いアーカイブ形式でもあります。パックアーカイブでは、オブジェクトは圧縮された全体として保存されるか、他のオブジェクトとの差分として保存されます。後者はしばしばデルタと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="bf032ee74744146d5a15b7c697cecedcaf0b0c4f" translate="yes" xml:space="preserve">
          <source>A paragraph in the commit log message. This can be given more than once and each &amp;lt;message&amp;gt; becomes its own paragraph.</source>
          <target state="translated">コミットログメッセージの段落。これは複数回指定でき、各&amp;lt;message&amp;gt;は独自の段落になります。</target>
        </trans-unit>
        <trans-unit id="8ae6bc184aa1a805bb37320ee63c3bc2d3ceedc5" translate="yes" xml:space="preserve">
          <source>A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files. Sometimes this indicates that the developer was being sloppy and did not refactor the code properly. You can first find the commit that introduced the file with:</source>
          <target state="translated">特に便利なのは、追加されたファイルに既存のファイルからコピーアンドペーストで作成された行があるかどうかを確認することです。これは開発者がずさんで、コードを適切にリファクタリングしていないことを示していることがあります。まず、そのファイルを導入したコミットを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="70409c2f17849d4a005f3c1893f70bfb2726cd34" translate="yes" xml:space="preserve">
          <source>A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains &lt;code&gt;LF&lt;/code&gt;. In C-style quoting, the complete name should be surrounded with double quotes, and any &lt;code&gt;LF&lt;/code&gt;, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt;).</source>
          <target state="translated">パスはCスタイルの文字列引用を使用できます。これはすべての場合に受け入れられ、ファイル名が二重引用符で始まるか、 &lt;code&gt;LF&lt;/code&gt; を含む場合は必須です。Cスタイルの引用では、完全な名前を二重引用符で囲み、 &lt;code&gt;LF&lt;/code&gt; 、バックスラッシュ、または二重引用符文字の前にバックスラッシュを付けてエスケープする必要があります（例： &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd2947c5ab63d63637e419f1d545864acc22513b" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is set is treated as text, even when they contain byte values that normally never appear in text files, such as NUL.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 属性が設定されているパスは、NULなどのテキストファイルには通常表示されないバイト値が含まれている場合でも、テキストとして扱われます。</target>
        </trans-unit>
        <trans-unit id="c497cf3cb539fc75cfa79107d99052fa1c172747" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unset will generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled).</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 属性が設定されていないパスでは、 &lt;code&gt;Binary files differ&lt;/code&gt; 生成されます（バイナリパッチが有効な場合はバイナリパッチ）。</target>
        </trans-unit>
        <trans-unit id="88c800d486d5ce3a0265a47a1feb9f3c335f6f77" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unspecified first gets its contents inspected, and if it looks like text and is smaller than core.bigFileThreshold, it is treated as text. Otherwise it would generate &lt;code&gt;Binary files differ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 属性が指定されていないパスは、最初にその内容が検査され、テキストのように見え、core.bigFileThresholdよりも小さい場合、テキストとして扱われます。それ以外の場合は、 &lt;code&gt;Binary files differ&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="1de5fce3d256d15d9371f68eb7be9e8c39bff70d" translate="yes" xml:space="preserve">
          <source>A pathspec that begins with a colon &lt;code&gt;:&lt;/code&gt; has special meaning. In the short form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by zero or more &quot;magic signature&quot; letters (which optionally is terminated by another colon &lt;code&gt;:&lt;/code&gt;), and the remainder is the pattern to match against the path. The &quot;magic signature&quot; consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the &quot;magic signature&quot; can be omitted if the pattern begins with a character that does not belong to &quot;magic signature&quot; symbol set and is not a colon.</source>
          <target state="translated">コロン &lt;code&gt;:&lt;/code&gt; で始まるpathspecには特別な意味があります。短い形式では、先頭のコロン &lt;code&gt;:&lt;/code&gt; の後に0個以上の「マジックシグネチャ」文字（オプションで別のコロン &lt;code&gt;:&lt;/code&gt; で終わる）が続き、残りはパスと照合するパターンです。「マジックシグネチャ」は、英数字、グロブ、正規表現の特殊文字でもコロンでもないASCII記号で構成されます。「マジックシグネチャ」を終了するオプションのコロンは、パターンが「マジックシグネチャ」シンボルセットに属さず、コロンではない文字で始まる場合は省略できます。</target>
        </trans-unit>
        <trans-unit id="5dbd2b8e2f5a79d8f4767d53dab7382344add01a" translate="yes" xml:space="preserve">
          <source>A pathspec with only a colon means &quot;there is no pathspec&quot;. This form should not be combined with other pathspec.</source>
          <target state="translated">コロンのみのパス仕様は、「パス仕様が存在しない」ことを意味します。この形式は他のパス仕様と組み合わせてはいけません。</target>
        </trans-unit>
        <trans-unit id="905a72351f89ce389bbe3fe0bc52dfbff0e65e1a" translate="yes" xml:space="preserve">
          <source>A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in.</source>
          <target state="translated">コマンドラインで --exclude で指定されたパターン、または --exclude-from で指定されたファイルから読み出されたパターンは、ディレクトリツリーの先頭からの相対的なものです。除外-per-directoryで指定されたファイルから読み出されたパターンは、そのパターンファイルが存在するディレクトリからの相対的なものです。</target>
        </trans-unit>
        <trans-unit id="543c0b6dffa14304d5bbca9c7badb06a27012480" translate="yes" xml:space="preserve">
          <source>A plain file &lt;code&gt;.git&lt;/code&gt; at the root of a working tree that points at the directory that is the real repository.</source>
          <target state="translated">実際のリポジトリであるディレクトリを指す作業ツリーのルートにあるプレーンファイル &lt;code&gt;.git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67f2fd432760e7725d26e3c634fda7223350a3d" translate="yes" xml:space="preserve">
          <source>A portable graphical interface to Git</source>
          <target state="translated">Git のポータブルなグラフィカルインターフェイス</target>
        </trans-unit>
        <trans-unit id="de9f6646a7f195313b665f81866ba2d97ea2d1a5" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do 'not' want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, 'not' tracking files with Git is just a matter of 'not' calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">プロジェクトでは、Gitで追跡したくないファイルを生成することがよくあります。これには通常、ビルドプロセスによって生成されたファイル、またはエディターによって作成された一時バックアップファイルが含まれます。もちろん、Gitでファイルを追跡しないことは、ファイルに &lt;code&gt;git add&lt;/code&gt; を呼び出さないことの問題です。しかし、これらの追跡されていないファイルがあるとすぐにうっとうしくなります。たとえば &lt;code&gt;git add .&lt;/code&gt; を作成します。実質的に役に立たず、それらは &lt;code&gt;git status&lt;/code&gt; の出力に表示され続けます。</target>
        </trans-unit>
        <trans-unit id="6db2ee1a1d750a2aa19ca518ec09fb893a88a85d" translate="yes" xml:space="preserve">
          <source>A range of commits could also be removed with rebase. If we have the following situation:</source>
          <target state="translated">コミットの範囲も rebase で削除できました。以下のような状況であれば</target>
        </trans-unit>
        <trans-unit id="a9d115fddbdf7f10bd3b9f771bde1590c6813bbd" translate="yes" xml:space="preserve">
          <source>A really simple TCP Git daemon that normally listens on port &quot;DEFAULT_GIT_PORT&quot; aka 9418. It waits for a connection asking for a service, and will serve that service if it is enabled.</source>
          <target state="translated">本当にシンプルな TCP Git デーモンで、通常はポート &quot;DEFAULT_GIT_PORT&quot;、通称 9418 をリッスンします。サービスを求める接続を待ち、それが有効になっていればそのサービスを提供します。</target>
        </trans-unit>
        <trans-unit id="3eaf62e43457d050db3acd458814891c29242983" translate="yes" xml:space="preserve">
          <source>A really simple server for Git repositories</source>
          <target state="translated">Git リポジトリのためのシンプルなサーバー</target>
        </trans-unit>
        <trans-unit id="d9323a3a61d783f2901a029c1a9555370896ed64" translate="yes" xml:space="preserve">
          <source>A recommended practice to deal with a repository with too many refs is to pack its refs with &lt;code&gt;--all&lt;/code&gt; once, and occasionally run &lt;code&gt;git pack-refs&lt;/code&gt;. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial &lt;code&gt;pack-refs --all&lt;/code&gt;, but only the currently active branch heads will become unpacked, and the next &lt;code&gt;pack-refs&lt;/code&gt; (without &lt;code&gt;--all&lt;/code&gt;) will leave them unpacked.</source>
          <target state="translated">参照が多すぎるリポジトリを処理するための推奨される方法は、その参照を &lt;code&gt;--all&lt;/code&gt; で一度に &lt;code&gt;git pack-refs&lt;/code&gt; 、時々git pack-refsを実行することです。タグは本質的に静止しており、変更されることはありません。ブランチヘッドは、最初にパックされます &lt;code&gt;pack-refs --all&lt;/code&gt; が、唯一現在アクティブなブランチヘッドはアンパックとなり、次の &lt;code&gt;pack-refs&lt;/code&gt; （なし &lt;code&gt;--all&lt;/code&gt; が）アンパックそれらを残すだろう。</target>
        </trans-unit>
        <trans-unit id="69fd7125bed2f55c76f0826ae0ec95817fbc826b" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for a &quot;subsystem maintainer&quot; who works on that project and has an own &quot;public repository&quot; goes like this:</source>
          <target state="translated">そのプロジェクトで作業し、独自の「公開リポジトリ」を持つ「サブシステムメンテナ」の推奨作業サイクルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="4fc51d6ef6719c059d48b71f7162885a19b6d5bb" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for an &quot;individual developer&quot; who does not have a &quot;public&quot; repository is somewhat different. It goes like this:</source>
          <target state="translated">公開」リポジトリを持っていない「個人開発者」に推奨される作業サイクルは、多少異なります。それは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d5352ae383650a2fe850c6303d60d8b60b542b21" translate="yes" xml:space="preserve">
          <source>A recommended workflow for a &quot;project lead&quot; goes like this:</source>
          <target state="translated">プロジェクトリード」の推奨ワークフローは次のようになります。</target>
        </trans-unit>
        <trans-unit id="265a7c950336ee05f26938c5f28759002d86d93b" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with a date specification enclosed in a brace pair (e.g. &lt;code&gt;{yesterday}&lt;/code&gt;, &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; or &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt;) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;). Note that this looks up the state of your &lt;strong&gt;local&lt;/strong&gt; ref at a given time; e.g., what was in your local &lt;code&gt;master&lt;/code&gt; branch last week. If you want to look at commits made during certain times, see &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt;.</source>
          <target state="translated">ブレースのペアで囲まれた日付指定を伴う接尾辞 &lt;code&gt;@&lt;/code&gt; が続くref （例： &lt;code&gt;{yesterday}&lt;/code&gt; 、 &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; または &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt; ）以前の時点での参照の値。このサフィックスは参照名の直後にのみ使用でき、参照には既存のログ（ &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; ）が必要です。これは、特定の時点での&lt;strong&gt;ローカル&lt;/strong&gt;参照の状態を検索することに注意してください。たとえば、先週のローカル &lt;code&gt;master&lt;/code&gt; ブランチの内容。あなたが特定の時間中に行われたコミットを見たい場合は、参照 &lt;code&gt;--since&lt;/code&gt; と &lt;code&gt;--until&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="51716c72ef284c873d21cfca784e510780211d59" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with an ordinal specification enclosed in a brace pair (e.g. &lt;code&gt;{1}&lt;/code&gt;, &lt;code&gt;{15}&lt;/code&gt;) specifies the n-th prior value of that ref. For example &lt;code&gt;master@{1}&lt;/code&gt; is the immediate prior value of &lt;code&gt;master&lt;/code&gt; while &lt;code&gt;master@{5}&lt;/code&gt; is the 5th prior value of &lt;code&gt;master&lt;/code&gt;. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">接尾辞 &lt;code&gt;@&lt;/code&gt; が後に続くrefと中括弧のペアで囲まれた序数指定（例： &lt;code&gt;{1}&lt;/code&gt; 、 &lt;code&gt;{15}&lt;/code&gt; ）は、そのrefの前のn番目の値を指定します。たとえば、 &lt;code&gt;master@{1}&lt;/code&gt; は &lt;code&gt;master&lt;/code&gt; の直前の値で、 &lt;code&gt;master@{5}&lt;/code&gt; は &lt;code&gt;master&lt;/code&gt; の 5番目の値です。このサフィックスは参照名の直後にのみ使用でき、参照には既存のログ（ &lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt; ）が必要です。</target>
        </trans-unit>
        <trans-unit id="c828d8d799658a52963b92e85f92230ddce05633" translate="yes" xml:space="preserve">
          <source>A reference is used in Git to specify branches and tags. A branch head is stored in the &lt;code&gt;refs/heads&lt;/code&gt; hierarchy, while a tag is stored in the &lt;code&gt;refs/tags&lt;/code&gt; hierarchy of the ref namespace (typically in &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; and &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; directories or, as entries in file &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; if refs are packed by &lt;code&gt;git gc&lt;/code&gt;).</source>
          <target state="translated">参照はGitでブランチとタグを指定するために使用されます。ブランチヘッドは &lt;code&gt;refs/heads&lt;/code&gt; 階層に格納され、タグはref名前空間の &lt;code&gt;refs/tags&lt;/code&gt; 階層に格納されます（通常、 &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; および &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; ディレクトリに、またはファイルのエントリとして） &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 参照が &lt;code&gt;git gc&lt;/code&gt; によってパックされている場合）。</target>
        </trans-unit>
        <trans-unit id="38b0c287bc0250d0d7c7ad1e770e07055b7fabea" translate="yes" xml:space="preserve">
          <source>A reflog shows the local &quot;history&quot; of a ref. In other words, it can tell you what the 3rd last revision in &lt;code&gt;this&lt;/code&gt; repository was, and what was the current state in &lt;code&gt;this&lt;/code&gt; repository, yesterday 9:14pm. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for details.</source>
          <target state="translated">reflogは、refのローカルな「履歴」を示します。つまり、 &lt;code&gt;this&lt;/code&gt; リポジトリの最後の3番目のリビジョンが何であったか、昨日の午後9時14分に &lt;code&gt;this&lt;/code&gt; リポジトリの現在の状態が何であったかを知ることができます。詳細については、&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5d85fab27e60023cfb23c382a480074950bc3b6" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;D..M&lt;/code&gt; computes the set of commits that are ancestors of &lt;code&gt;M&lt;/code&gt;, but excludes the ones that are ancestors of &lt;code&gt;D&lt;/code&gt;. This is useful to see what happened to the history leading to &lt;code&gt;M&lt;/code&gt; since &lt;code&gt;D&lt;/code&gt;, in the sense that &amp;ldquo;what does &lt;code&gt;M&lt;/code&gt; have that did not exist in &lt;code&gt;D&lt;/code&gt;&amp;rdquo;. The result in this example would be all the commits, except &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; (and &lt;code&gt;D&lt;/code&gt; itself, of course).</source>
          <target state="translated">通常の &lt;code&gt;D..M&lt;/code&gt; は、 &lt;code&gt;M&lt;/code&gt; の祖先であるコミットのセットを計算しますが、 &lt;code&gt;D&lt;/code&gt; の祖先であるコミットは除外します。これは、「 &lt;code&gt;M&lt;/code&gt; には &lt;code&gt;D&lt;/code&gt; には存在しなかったものがある」という意味で、 &lt;code&gt;D&lt;/code&gt; 以来 &lt;code&gt;M&lt;/code&gt; に至る歴史に何が起こったかを知るのに役立ちます。この例の結果は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; （もちろん &lt;code&gt;D&lt;/code&gt; 自体）を除くすべてのコミットになります。</target>
        </trans-unit>
        <trans-unit id="2ed028af5f97bfe4672822d1dbdbcfbdfebcb455" translate="yes" xml:space="preserve">
          <source>A regular Git &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes.</source>
          <target state="translated">開発の概念的な開発ラインを識別するために開発者が使用する通常のGit &lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;。ブランチは非常に簡単で安価なので、それぞれが非常に明確に定義された概念または小さなインクリメンタルだが関連する変更を含むいくつかの小さなブランチを持つことが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="2a66b0bccadf6b4b35ab899aad4e51fd773c916c" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="translated">アップストリームサブモジュールで更新を追跡するためのリモートブランチ名。このオプションが指定されていない場合、デフォルトで &lt;code&gt;master&lt;/code&gt; になります。特別な値 &lt;code&gt;.&lt;/code&gt; サブモジュールのブランチの名前が、現在のリポジトリの現在のブランチと同じ名前であることを示すために使用されます。詳細については、&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;の &lt;code&gt;--remote&lt;/code&gt; ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="8a9a8ecf4e3c29353c757ea95408f73fb557ebe2" translate="yes" xml:space="preserve">
          <source>A remote host to house the repository. When this part is specified, &lt;code&gt;git-receive-pack&lt;/code&gt; is invoked via ssh.</source>
          <target state="translated">リポジトリを収容するリモートホスト。この部分を指定すると、 &lt;code&gt;git-receive-pack&lt;/code&gt; がssh経由で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cd3cc062c2af6416292b0ef7c3779dab312dd5ae" translate="yes" xml:space="preserve">
          <source>A repeated field which contains a pathspec used to match against a submodule&amp;rsquo;s path to determine if the submodule is of interest to git commands. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">サブモジュールがgitコマンドの対象であるかどうかを判断するためにサブモジュールのパスと照合するために使用されるpathspecを含む繰り返しフィールド。詳細については、&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c4f31deb02430ad940d40632dc48c6584b615bca" translate="yes" xml:space="preserve">
          <source>A repository administrator uses the following tools to set up and maintain access to the repository by developers.</source>
          <target state="translated">リポジトリ管理者は、以下のツールを使用して、開発者のリポジトリへのアクセスを設定・維持します。</target>
        </trans-unit>
        <trans-unit id="291ca170f72d7ae46d3d06abf11420385d3bc632" translate="yes" xml:space="preserve">
          <source>A repository browser written in C++ using Qt.</source>
          <target state="translated">Qtを使ってC++で書かれたリポジトリブラウザ。</target>
        </trans-unit>
        <trans-unit id="4f0e13fa1004207d77a93fcbfe7ad39156045662" translate="yes" xml:space="preserve">
          <source>A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory.</source>
          <target state="translated">独立してクローンされ、後でサブモジュールとして追加されたリポジトリや古い設定では、superprojectsのgitディレクトリに埋め込まれるのではなく、サブモジュールの中にsubsmodulesのgitディレクトリがあります。</target>
        </trans-unit>
        <trans-unit id="e2e984261a0bc7837fbb8a0ec46d94f09fd20ad4" translate="yes" xml:space="preserve">
          <source>A repository, however, may be on a filesystem that handles the filemode correctly, and this variable is set to &lt;code&gt;true&lt;/code&gt; when created, but later may be made accessible from another environment that loses the filemode (e.g. exporting ext4 via CIFS mount, visiting a Cygwin created repository with Git for Windows or Eclipse). In such a case it may be necessary to set this variable to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">ただし、リポジトリはファイルモードを正しく処理するファイルシステム上にある可能性があり、この変数は作成時に &lt;code&gt;true&lt;/code&gt; に設定されますが、後でファイルモードを失う別の環境からアクセスできるようになります（例：CIFSマウントを介したext4のエクスポート、Cygwinへのアクセス） Git for WindowsまたはEclipseで作成されたリポジトリ）。そのような場合、この変数を &lt;code&gt;false&lt;/code&gt; に設定する必要があるかもしれません。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="78ddd4f9a8a430a958f1b8538f7d6f7067859a81" translate="yes" xml:space="preserve">
          <source>A response cannot have both &quot;ACK&quot; lines as well as a &quot;NAK&quot; line.</source>
          <target state="translated">応答は、&quot;ACK &quot;行と &quot;NAK &quot;行の両方を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="2e8097366b5d40667e4abf117fd6ca3ad0717782" translate="yes" xml:space="preserve">
          <source>A revision parameter &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; typically, but not necessarily, names a commit object. It uses what is called an &lt;code&gt;extended SHA-1&lt;/code&gt; syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.</source>
          <target state="translated">通常、リビジョンパラメータ &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; は、必ずしもではないが、コミットオブジェクトを指定します。いわゆる &lt;code&gt;extended SHA-1&lt;/code&gt; 構文を使用します。オブジェクト名を綴るさまざまな方法を次に示します。このリストの終わり近くにリストされているものは、コミットに含まれるツリーとブロブの名前です。</target>
        </trans-unit>
        <trans-unit id="62c6349b68cd7c10517a568cd609971cc38e5788" translate="yes" xml:space="preserve">
          <source>A sample script called &lt;code&gt;git merge-one-file&lt;/code&gt; is included in the distribution.</source>
          <target state="translated">&lt;code&gt;git merge-one-file&lt;/code&gt; というサンプルスクリプトがディストリビューションに含まれています。</target>
        </trans-unit>
        <trans-unit id="120e3b8f4ab8d187e55b285ecbd0489d8d26eb44" translate="yes" xml:space="preserve">
          <source>A separate reflog is kept for the HEAD, so</source>
          <target state="translated">HEAD用のリブログは別途保管されているので</target>
        </trans-unit>
        <trans-unit id="d91dd506db610265c4f5339a204fd581531aedbc" translate="yes" xml:space="preserve">
          <source>A server which decides to communicate (based on a request from a client) using protocol version 2, notifies the client by sending a version string in its initial response followed by an advertisement of its capabilities. Each capability is a key with an optional value. Clients must ignore all unknown keys. Semantics of unknown values are left to the definition of each key. Some capabilities will describe commands which can be requested to be executed by the client.</source>
          <target state="translated">(クライアントからのリクエストに基づいて)プロトコルバージョン2を使用して通信することを決定したサーバは、最初の応答でバージョン文字列を送信してクライアントに通知し、その後にケイパビリティのアドバタイズメントを行う。各ケイパビリティはオプションの値を持つキーである。クライアントはすべての未知のキーを無視しなければなりません。未知の値の意味は各キーの定義に委ねられる。いくつかのケイパビリティは、クライアントが実行を要求できるコマンドを記述します。</target>
        </trans-unit>
        <trans-unit id="1df310f47acb8f98df997eb87d57f9f09ca45534" translate="yes" xml:space="preserve">
          <source>A set of objects which have been compressed into one file (to save space or to transmit them efficiently).</source>
          <target state="translated">1つのファイルに圧縮されたオブジェクトのセット(スペースを節約したり、効率的に送信するために)。</target>
        </trans-unit>
        <trans-unit id="760738014c8d15080dd8ad99ff6f8946e9b78b3f" translate="yes" xml:space="preserve">
          <source>A shallow &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; has an incomplete history some of whose &lt;a href=&quot;#def_commit&quot;&gt;commits&lt;/a&gt; have &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, and its history can be later deepened with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">浅いの&lt;a href=&quot;#def_repository&quot;&gt;リポジトリには、&lt;/a&gt;不完全な歴史にそのいくつか持って&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;している&lt;a href=&quot;#def_parent&quot;&gt;親が&lt;/a&gt;離れて焼灼（つまり、Gitのは、これらのコミットは、彼らが内に記録されていても、親を持っていないことをふりをするように指示された&lt;a href=&quot;#def_commit_object&quot;&gt;コミットオブジェクトを&lt;/a&gt;）。これは、上流に記録された実際の履歴がはるかに大きいにもかかわらず、プロジェクトの最近の履歴のみに関心がある場合に役立つことがあります。 &lt;code&gt;--depth&lt;/code&gt; オプションを&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;に指定することで浅いリポジトリが作成され、その履歴は後で&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]で&lt;/a&gt;深めることができます。</target>
        </trans-unit>
        <trans-unit id="84d2217cabdf29712dcb12dec7c077c5557961f7" translate="yes" xml:space="preserve">
          <source>A similar notation &lt;code&gt;r1...r2&lt;/code&gt; is called symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; and is defined as &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt;. It is the set of commits that are reachable from either one of &lt;code&gt;r1&lt;/code&gt; (left side) or &lt;code&gt;r2&lt;/code&gt; (right side) but not from both.</source>
          <target state="translated">同様の表記 &lt;code&gt;r1...r2&lt;/code&gt; は、 &lt;code&gt;r1&lt;/code&gt; と &lt;code&gt;r2&lt;/code&gt; の対称差と呼ばれ、 &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt; として定義されます。これは、 &lt;code&gt;r1&lt;/code&gt; （左側）または &lt;code&gt;r2&lt;/code&gt; （右側）のいずれかから到達可能で、両方からは到達できないコミットのセットです。</target>
        </trans-unit>
        <trans-unit id="03b58226721c4cc7166ad8aeab7f1974a94bf09d" translate="yes" xml:space="preserve">
          <source>A similar situation may exist if you have many refs outside of &lt;code&gt;refs/heads/&lt;/code&gt; and &lt;code&gt;refs/tags/&lt;/code&gt; that point to related objects (e.g., &lt;code&gt;refs/pull&lt;/code&gt; or &lt;code&gt;refs/changes&lt;/code&gt; used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is.</source>
          <target state="translated">&lt;code&gt;refs/heads/&lt;/code&gt; および &lt;code&gt;refs/tags/&lt;/code&gt; 外に、関連オブジェクトを指す多くの参照がある場合（たとえば、一部のホスティングプロバイダーによって使用される &lt;code&gt;refs/pull&lt;/code&gt; または &lt;code&gt;refs/changes&lt;/code&gt; ）も、同様の状況が発生する可能性があります。デフォルトでは、クライアントはヘッドとタグのみをフェッチし、他のグループでのみ検出されたオブジェクトに対するデルタはそのまま送信できません。</target>
        </trans-unit>
        <trans-unit id="b8ed03d108643fd395f938fb72a9354bf316277b" translate="yes" xml:space="preserve">
          <source>A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols. The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol.</source>
          <target state="translated">Git リポジトリの内容を、http://および https://プロトコルでリポジトリにアクセスする Git クライアントに提供するシンプルな CGI プログラムです。このプログラムは、スマート HTTP プロトコルと下位互換のダム HTTP プロトコルの両方を使用して取得するクライアントと、 スマート HTTP プロトコルを使用してプッシュするクライアントの両方をサポートしています。</target>
        </trans-unit>
        <trans-unit id="b1195c95166bae01312d67abaddce937f83d9362" translate="yes" xml:space="preserve">
          <source>A simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:</source>
          <target state="translated">shell evalを出力する際に-shellを使用していることを示す簡単な例です。すべてのヘッドの接頭辞をリストアップします。</target>
        </trans-unit>
        <trans-unit id="c189ba8d16025c20dba9fcda55d122bc7aead222" translate="yes" xml:space="preserve">
          <source>A simple script to set up &lt;code&gt;gitweb&lt;/code&gt; and a web server for browsing the local repository.</source>
          <target state="translated">ローカルリポジトリを参照するための &lt;code&gt;gitweb&lt;/code&gt; とWebサーバーを設定する簡単なスクリプト。</target>
        </trans-unit>
        <trans-unit id="24dbbf1a98e941496d92210bf8c09236d984ac48" translate="yes" xml:space="preserve">
          <source>A single Git repository can maintain multiple branches of development. To create a new branch named &quot;experimental&quot;, use</source>
          <target state="translated">ひとつの Git リポジトリで複数の開発ブランチを管理することができます。experimental&quot; という名前の新しいブランチを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="25083b025a2b5a403b052b2229f06625158a6247" translate="yes" xml:space="preserve">
          <source>A single Git repository can track development on multiple branches. It does this by keeping a list of &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; which reference the latest commit on each branch; the &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; command shows you the list of branch heads:</source>
          <target state="translated">1つのGitリポジトリで、複数のブランチの開発を追跡できます。これは、各ブランチの最新のコミットを参照する&lt;a href=&quot;#def_head&quot;&gt;ヘッドの&lt;/a&gt;リストを保持することによって行われます。&lt;a href=&quot;git-branch&quot;&gt;gitのブランチ[1]&lt;/a&gt;コマンドを示しますブランチヘッドのリスト：</target>
        </trans-unit>
        <trans-unit id="7288da94d33c9eb52ba6940278539d1555cfdfd9" translate="yes" xml:space="preserve">
          <source>A single character indicating the status of the ref:</source>
          <target state="translated">ref の状態を示す 1 文字。</target>
        </trans-unit>
        <trans-unit id="31c723ae3e05980f7081e5473a8ac04766150ab6" translate="yes" xml:space="preserve">
          <source>A single commit, &amp;lt;since&amp;gt;, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the &amp;lt;since&amp;gt; to be output.</source>
          <target state="translated">単一のコミット&amp;lt;since&amp;gt;は、現在のブランチの先端につながるコミットであり、&amp;lt;since&amp;gt;の出力につながる履歴にないものを指定します。</target>
        </trans-unit>
        <trans-unit id="d66b9962c6b8969581e4f00aff7618bfe88dca4e" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &quot;&lt;code&gt;a/**/b&lt;/code&gt;&quot; matches &quot;&lt;code&gt;a/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/y/b&lt;/code&gt;&quot; and so on.</source>
          <target state="translated">スラッシュとそれに続く2つのアスタリスクは、0個以上のディレクトリと一致します。たとえば、「 &lt;code&gt;a/**/b&lt;/code&gt; 」は「 &lt;code&gt;a/b&lt;/code&gt; 」、「 &lt;code&gt;a/x/b&lt;/code&gt; 」、「 &lt;code&gt;a/x/y/b&lt;/code&gt; 」などと一致します。</target>
        </trans-unit>
        <trans-unit id="4e21b6b860da30d1826bc3bb029200d80cc11cad" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &amp;ldquo;a/**/b&amp;rdquo; matches &amp;ldquo;a/b&amp;rdquo;, &amp;ldquo;a/x/b&amp;rdquo;, &amp;ldquo;a/x/y/b&amp;rdquo; and so on.</source>
          <target state="translated">スラッシュとそれに続く2つのアスタリスクは、0個以上のディレクトリと一致します。たとえば、「a / ** / b」は「a / b」、「a / x / b」、「a / x / y / b」などと一致します。</target>
        </trans-unit>
        <trans-unit id="7c9431663a53487c588fbbedb283ae62fa2894ff" translate="yes" xml:space="preserve">
          <source>A slightly deprecated way to store shorthands to be used to specify a URL to &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt;. A file can be stored as &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; and then &lt;code&gt;name&lt;/code&gt; can be given to these commands in place of &lt;code&gt;repository&lt;/code&gt; argument. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/branches&quot; will be used instead.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 、 &lt;code&gt;git pull&lt;/code&gt; 、および &lt;code&gt;git push&lt;/code&gt; へのURLを指定するために使用される省略形を格納するための少し非推奨の方法。ファイルとして記憶することができ &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; 、その後、 &lt;code&gt;name&lt;/code&gt; の代わりに、これらのコマンドに与えることができる &lt;code&gt;repository&lt;/code&gt; 引数。詳細については、&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;のREMOTESセクションを参照してください。このメカニズムはレガシーであり、最近のリポジトリには見られないでしょう。 $ GIT_COMMON_DIRが設定されており、代わりに「$ GIT_COMMON_DIR / branches」が使用される場合、このディレクトリは無視されます。</target>
        </trans-unit>
        <trans-unit id="abbe30d91a78c1b581b029eea169d6574e2c5cb4" translate="yes" xml:space="preserve">
          <source>A sorted list of object IDs.</source>
          <target state="translated">オブジェクトIDのソートされたリスト。</target>
        </trans-unit>
        <trans-unit id="3047be03f0d3ecaf4a4a3e674d103af6ab32bc53" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^'&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="translated">特別な表記 &quot; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;は、 &quot;^ '&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;の省略形として使用できます。たとえば、次のいずれかを同じ意味で使用できます。</target>
        </trans-unit>
        <trans-unit id="2a3908ea4f3253577085936fe5b76bc16ca04e0c" translate="yes" xml:space="preserve">
          <source>A special work-flow to process regressions can give great results.</source>
          <target state="translated">回帰を処理するための特別なワークフローは、大きな結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="43ce84536299a4f1684c7f29def2c093aadc39c2" translate="yes" xml:space="preserve">
          <source>A standalone individual developer does not exchange patches with other people, and works alone in a single repository, using the following commands.</source>
          <target state="translated">スタンドアロンの個人開発者は、他の人とパッチを交換せず、以下のコマンドを使用して単一のリポジトリで単独で作業します。</target>
        </trans-unit>
        <trans-unit id="6d0b6db37ed70c0023a81918dabe38bb8d99cf58" translate="yes" xml:space="preserve">
          <source>A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at &lt;code&gt;HEAD&lt;/code&gt; when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the &lt;code&gt;HEAD&lt;/code&gt; commit. The ancestry graph looks like this:</source>
          <target state="translated">stashエントリーは、ツリーが作業ディレクトリーの状態を記録するコミットとして表され、その最初の親は、エントリーが作成されたときの &lt;code&gt;HEAD&lt;/code&gt; でのコミットです。2番目の親のツリーは、エントリが作成されたときのインデックスの状態を記録し、 &lt;code&gt;HEAD&lt;/code&gt; コミットの子になります。祖先グラフは次のようになります。</target>
        </trans-unit>
        <trans-unit id="36a517b64103a2430e203bb84a9e73d7f028600f" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a branch ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;.</source>
          <target state="translated">表示されているブランチ参照とそれが指すオブジェクトから &lt;code&gt;%(fieldname)&lt;/code&gt; を補間する文字列。フォーマットは&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="9edde80e52399b826b491130bef9d05b3925669d" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a ref being shown and the object it points at. If &lt;code&gt;fieldname&lt;/code&gt; is prefixed with an asterisk (&lt;code&gt;*&lt;/code&gt;) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object). When unspecified, &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt;. It also interpolates &lt;code&gt;%%&lt;/code&gt; to &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; are hex digits interpolates to character with hex code &lt;code&gt;xx&lt;/code&gt;; for example &lt;code&gt;%00&lt;/code&gt; interpolates to &lt;code&gt;\0&lt;/code&gt; (NUL), &lt;code&gt;%09&lt;/code&gt; to &lt;code&gt;\t&lt;/code&gt; (TAB) and &lt;code&gt;%0a&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; (LF).</source>
          <target state="translated">表示されている参照とその参照先のオブジェクトから &lt;code&gt;%(fieldname)&lt;/code&gt; を補間する文字列。場合 &lt;code&gt;fieldname&lt;/code&gt; アスタリスク（付いている &lt;code&gt;*&lt;/code&gt; ）とタグオブジェクトにREF点、タグオブジェクトは、（代わりにタグオブジェクト内のフィールド）を参照するオブジェクトのフィールドの値を使用します。指定しない場合、 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; はデフォルトで &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt; ます。また、 &lt;code&gt;%%&lt;/code&gt; を &lt;code&gt;%&lt;/code&gt; に補間し、 &lt;code&gt;%xx&lt;/code&gt; &lt;code&gt;xx&lt;/code&gt; は16進数で、xxは16進コード &lt;code&gt;xx&lt;/code&gt; の文字を補間します。たとえば、 &lt;code&gt;%00&lt;/code&gt; は &lt;code&gt;\0&lt;/code&gt; （NUL）に補間します。 &lt;code&gt;%09&lt;/code&gt; から &lt;code&gt;\t&lt;/code&gt; （タブ）および &lt;code&gt;%0a&lt;/code&gt; から &lt;code&gt;\n&lt;/code&gt; （LF）。</target>
        </trans-unit>
        <trans-unit id="9cb129a282a3da00e35f465609f9329380941366" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a tag ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. When unspecified, defaults to &lt;code&gt;%(refname:strip=2)&lt;/code&gt;.</source>
          <target state="translated">表示されているタグ参照とそれが指すオブジェクトから &lt;code&gt;%(fieldname)&lt;/code&gt; を補間する文字列。フォーマットは&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;と同じです。指定しない場合、デフォルトは &lt;code&gt;%(refname:strip=2)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0560022c11ba0c716585e6d8f8913228ee3e6c3e" translate="yes" xml:space="preserve">
          <source>A submodule can be deinitialized by running &lt;code&gt;git submodule deinit&lt;/code&gt;. Besides emptying the working directory, this command only modifies the superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file, so the superproject&amp;rsquo;s history is not affected. This can be undone using &lt;code&gt;git submodule init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git submodule deinit&lt;/code&gt; を実行すると、サブモジュールを初期化解除できます。作業ディレクトリを空にするほかに、このコマンドはスーパー &lt;code&gt;$GIT_DIR/config&lt;/code&gt; の$ GIT_DIR / configファイルのみを変更するため、スーパープロジェクトの履歴は影響を受けません。これは &lt;code&gt;git submodule init&lt;/code&gt; を使用して元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="7b89540955e10e5feb43789fbebb00e44fcb9843" translate="yes" xml:space="preserve">
          <source>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</source>
          <target state="translated">サブモジュールとは、別のリポジトリの中に埋め込まれたリポジトリのことです。サブモジュールにはそれ自身の歴史があり、サブモジュールが埋め込まれているリポジトリをスーパープロジェクトと呼びます。</target>
        </trans-unit>
        <trans-unit id="e88b5d8fa1cd6a4cae09ba91d60ef7a2df883ac3" translate="yes" xml:space="preserve">
          <source>A submodule is considered active,</source>
          <target state="translated">サブモジュールはアクティブとみなされます。</target>
        </trans-unit>
        <trans-unit id="a4216bd581f8b9370ea9e414788282e84b57f684" translate="yes" xml:space="preserve">
          <source>A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren&amp;rsquo;t ignored are present in the submodules work tree. Ignored files are deemed expendable and won&amp;rsquo;t stop a submodule&amp;rsquo;s work tree from being removed.</source>
          <target state="translated">HEADがインデックスに記録されているものと同じ場合、サブモジュールは最新と見なされ、追跡されたファイルは変更されず、無視されない未追跡のファイルはサブモジュールの作業ツリーに存在しません。無視されたファイルは使い捨てと見なされ、サブモジュールの作業ツリーが削除されるのを止めることはありません。</target>
        </trans-unit>
        <trans-unit id="df342118147abc0cd90ff22df7d540bbed94c62e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;:&lt;/code&gt; followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; is relative to the current working directory. The given path will be converted to be relative to the working tree&amp;rsquo;s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.</source>
          <target state="translated">接尾辞 &lt;code&gt;:&lt;/code&gt; 後に続くパスは、コロンの前の部分で指定されたツリーっぽいオブジェクトの特定のパスにあるblobまたはツリーを指定します。 &lt;code&gt;./&lt;/code&gt; または &lt;code&gt;../&lt;/code&gt; で始まるパスは、現在の作業ディレクトリに対する相対パスです。指定されたパスは、作業ツリーのルートディレクトリからの相対パスに変換されます。これは、作業ツリーと同じツリー構造を持つコミットまたはツリーからBLOBまたはツリーをアドレス指定するのに最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="7e785e37b028efe6293e2efb14cf20d30e4be808" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an at sign is the same as listing all parents of &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; (meaning, include anything reachable from its parents, but not the commit itself).</source>
          <target state="translated">接尾辞 &lt;code&gt;^&lt;/code&gt; の後にアットマークが続くことは、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; のすべての親をリストすることと同じです（つまり、その親から到達可能なすべてのものを含めますが、コミット自体は含めません）。</target>
        </trans-unit>
        <trans-unit id="234f424b36b663492de634fe2e068b47127b2353" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.</source>
          <target state="translated">接尾辞 &lt;code&gt;^&lt;/code&gt; の後に空のブレースペアが続く場合は、オブジェクトがタグである可能性があり、非タグオブジェクトが見つかるまで再帰的にタグを逆参照します。</target>
        </trans-unit>
        <trans-unit id="e176abe5e6fcc215a4e351cefa8ffc3e524bb3aa" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an exclamation mark is the same as giving commit &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; and then all its parents prefixed with &lt;code&gt;^&lt;/code&gt; to exclude them (and their ancestors).</source>
          <target state="translated">接尾辞 &lt;code&gt;^&lt;/code&gt; の後に感嘆符が続くことは、コミット &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; を与えた後に、それらの親（およびその祖先）を除外するために &lt;code&gt;^&lt;/code&gt; で始まるすべての親を与えることと同じです。</target>
        </trans-unit>
        <trans-unit id="079cde747b39722224d412153b37c2370e8debbb" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an object type name enclosed in brace pair means dereference the object at &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; recursively until an object of type &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is found or the object cannot be dereferenced anymore (in which case, barf). For example, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a commit-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; describes the corresponding commit object. Similarly, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a tree-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; describes the corresponding tree object. &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; is a short-hand for &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt;.</source>
          <target state="translated">接尾辞 &lt;code&gt;^&lt;/code&gt; の後にブレースペアで囲まれたオブジェクトタイプ名が続くと、タイプ &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; のオブジェクトが見つかるか、オブジェクトが逆参照できなくなるまで（その場合はbarf）、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; のオブジェクトが再帰的に逆参照されます。たとえば、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; がコミットっぽい場合、 &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; は対応するコミットオブジェクトを表します。同様に、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; がツリーっぽい場合、 &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; は対応するツリーオブジェクトを記述します。 &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; は &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; 省略形です。</target>
        </trans-unit>
        <trans-unit id="fffb9575171f3ccde74304b43fe061daf6edfa9e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter means the first parent of that commit object. &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; means the &amp;lt;n&amp;gt;th parent (i.e. &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt;). As a special rule, &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; means the commit itself and is used when &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is the object name of a tag object that refers to a commit object.</source>
          <target state="translated">リビジョンパラメータの接尾辞 &lt;code&gt;^&lt;/code&gt; は、そのコミットオブジェクトの最初の親を意味します。 &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; は&amp;lt;n&amp;gt;番目の親を意味します（つまり、 &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; は &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt; と同等です）。特別な規則として、 &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; はコミット自体を意味し、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; がコミットオブジェクトを参照するタグオブジェクトのオブジェクト名である場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="4abb972743010d92ad3a5190f17461682915e18a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the &lt;code&gt;:/fix nasty bug&lt;/code&gt; syntax below except that it returns the youngest matching commit which is reachable from the &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; before &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">リビジョンパラメータへの接尾辞 &lt;code&gt;^&lt;/code&gt; の後にスラッシュで始まるテキストを含む中括弧のペアは、 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; から到達可能な最も若い一致するコミットを返すことを除いて、以下の &lt;code&gt;:/fix nasty bug&lt;/code&gt; 構文と同じです。 &lt;code&gt;^&lt;/code&gt; の前。</target>
        </trans-unit>
        <trans-unit id="9efdcb3b13d0c9c0789d26cd7ee831f4aca0612a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;~&lt;/code&gt; to a revision parameter means the first parent of that commit object. A suffix &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; to a revision parameter means the commit object that is the &amp;lt;n&amp;gt;th generation ancestor of the named commit object, following only the first parents. I.e. &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; which is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt;. See below for an illustration of the usage of this form.</source>
          <target state="translated">リビジョンパラメータの接尾辞 &lt;code&gt;~&lt;/code&gt; は、そのコミットオブジェクトの最初の親を意味します。リビジョンパラメータのサフィックス &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; は、名前付きコミットオブジェクトの&amp;lt;n&amp;gt;世代の祖先であるコミットオブジェクトを意味します。すなわち &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; に相当します &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; に相当する &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt; 。このフォームの使用例については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="08cd172649a72cf4ad5161e6315024c0dfabce75" translate="yes" xml:space="preserve">
          <source>A symbolic ref is a regular file that stores a string that begins with &lt;code&gt;ref: refs/&lt;/code&gt;. For example, your &lt;code&gt;.git/HEAD&lt;/code&gt; is a regular file whose contents is &lt;code&gt;ref: refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">シンボリックrefは、 &lt;code&gt;ref: refs/&lt;/code&gt; で始まる文字列を格納する通常のファイルです。たとえば、 &lt;code&gt;.git/HEAD&lt;/code&gt; は通常のファイルで、その内容は &lt;code&gt;ref: refs/heads/master&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2f6a4a117c3c9029c31388fc9b0d710a83f42f4d" translate="yes" xml:space="preserve">
          <source>A symbolic ref name. E.g. &lt;code&gt;master&lt;/code&gt; typically means the commit object referenced by &lt;code&gt;refs/heads/master&lt;/code&gt;. If you happen to have both &lt;code&gt;heads/master&lt;/code&gt; and &lt;code&gt;tags/master&lt;/code&gt;, you can explicitly say &lt;code&gt;heads/master&lt;/code&gt; to tell Git which one you mean. When ambiguous, a &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; is disambiguated by taking the first match in the following rules:</source>
          <target state="translated">シンボリックな参照名。たとえば、 &lt;code&gt;master&lt;/code&gt; は通常、 &lt;code&gt;refs/heads/master&lt;/code&gt; によって参照されるコミットオブジェクトを意味します。あなたは両方持ってしまった場合 &lt;code&gt;heads/master&lt;/code&gt; と &lt;code&gt;tags/master&lt;/code&gt; 、明示的に言うことができる &lt;code&gt;heads/master&lt;/code&gt; あなたが意味どちらのGitを伝えるために。あいまいな場合、 &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; は、次のルールの最初の一致をとることによって明確化されます。</target>
        </trans-unit>
        <trans-unit id="2a9339c8e09a3c8f9775daba35ba89a601eb61af" translate="yes" xml:space="preserve">
          <source>A symref (see glossary) to the &lt;code&gt;refs/heads/&lt;/code&gt; namespace describing the currently active branch. It does not mean much if the repository is not associated with any working tree (i.e. a &lt;code&gt;bare&lt;/code&gt; repository), but a valid Git repository &lt;strong&gt;must&lt;/strong&gt; have the HEAD file; some porcelains may use it to guess the designated &quot;default&quot; branch of the repository (usually &lt;code&gt;master&lt;/code&gt;). It is legal if the named branch &lt;code&gt;name&lt;/code&gt; does not (yet) exist. In some legacy setups, it is a symbolic link instead of a symref that points at the current branch.</source>
          <target state="translated">現在アクティブなブランチを説明する &lt;code&gt;refs/heads/&lt;/code&gt; 名前空間へのsymref（用語集を参照）。リポジトリが作業ツリー（つまり、 &lt;code&gt;bare&lt;/code&gt; リポジトリ）に関連付けられていなくても意味はありませんが、有効なGitリポジトリにはHEADファイルが&lt;strong&gt;必要&lt;/strong&gt;です。一部の磁器は、リポジトリ（通常は &lt;code&gt;master&lt;/code&gt; ）の指定された「デフォルト」ブランチを推測するためにそれを使用する場合があります。指定されたブランチ &lt;code&gt;name&lt;/code&gt; が（まだ）存在しない場合は、合法です。一部のレガシーセットアップでは、現在のブランチを指すsymrefではなく、シンボリックリンクです。</target>
        </trans-unit>
        <trans-unit id="29c5b752bfbf12baa27c0d09bf45852511199efe" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;の同意語。</target>
        </trans-unit>
        <trans-unit id="6a76d6428fd9851f11221d0de44fe9ce84899c23" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt;; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt;, similar to &lt;code&gt;git cherry upstream mybranch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt; の同義語。出力を私たちのコミットに制限し、フォークされた履歴の反対側に適用されたものに &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt; で &lt;code&gt;git cherry upstream mybranch&lt;/code&gt; ます。これはgit cherryアップストリームmybranchと同様です。</target>
        </trans-unit>
        <trans-unit id="868704b8b35cf6bb729f23c31a6430d7399400cb" translate="yes" xml:space="preserve">
          <source>A table of 4-byte CRC32 values of the packed object data. This is new in v2 so compressed data can be copied directly from pack to pack during repacking without undetected data corruption.</source>
          <target state="translated">パックされたオブジェクトデータの4バイトCRC32値のテーブル。これはv2で新しく追加されたもので、圧縮されたデータを再梱包中にデータの破損を検出することなく、パックからパックへ直接コピーすることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="b9c572354f0344d27ffddcbe955d1d768c1138c7" translate="yes" xml:space="preserve">
          <source>A table of 4-byte offset values (in network byte order). These are usually 31-bit pack file offsets, but large offsets are encoded as an index into the next table with the msbit set.</source>
          <target state="translated">4 バイトのオフセット値のテーブル(ネットワークバイト順)。通常は 31 ビットのパックファイルのオフセットですが、大きなオフセットは msbit セットで次のテーブルへのインデックスとしてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="115de84d2ad1c82aefd29447ce36382b5a4e7147" translate="yes" xml:space="preserve">
          <source>A table of 8-byte offset entries (empty for pack files less than 2 GiB). Pack files are organized with heavily used objects toward the front, so most object references should not need to refer to this table.</source>
          <target state="translated">8 バイトのオフセットエントリのテーブル (2 GiB 未満のパックファイルでは空)。パックファイルは、使用頻度の高いオブジェクトを先頭にして整理されているので、ほとんどのオブジェクト参照はこのテーブルを参照する必要はありません。</target>
        </trans-unit>
        <trans-unit id="9b489f426a28ee960ee163d6ec7cd47d15e9a4e2" translate="yes" xml:space="preserve">
          <source>A table of sorted 20-byte SHA-1 object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="translated">ソートされた20バイトのSHA-1オブジェクト名のテーブル。これらは、特定のオブジェクト名のバイナリ検索のキャッシュフットプリントを減らすために、オフセット値なしでまとめられています。</target>
        </trans-unit>
        <trans-unit id="04b73c881d8049c32b44bc4f672cd5152d4e0c48" translate="yes" xml:space="preserve">
          <source>A tag is created with &lt;a href=&quot;git-mktag&quot;&gt;git-mktag[1]&lt;/a&gt;, and the signature can be verified by &lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag[1]&lt;/a&gt;, though it is normally simpler to use &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for both.</source>
          <target state="translated">タグは&lt;a href=&quot;git-mktag&quot;&gt;git-mktag [1]&lt;/a&gt;で作成され、署名は&lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag [1]&lt;/a&gt;で検証できますが、通常は両方に&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;を使用する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="27736fe1ba37175d3cc5e2ce129ab17b8daa1329" translate="yes" xml:space="preserve">
          <source>A tag object contains an object, object type, tag name, the name of the person (&quot;tagger&quot;) who created the tag, and a message, which may contain a signature, as can be seen using &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;:</source>
          <target state="translated">タグオブジェクトには、オブジェクト、オブジェクトタイプ、タグ名、タグを作成した人物の名前（「tagger」）、および&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1 ]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="460cd2951f141993dd60da4f89bc9632bc5240a6" translate="yes" xml:space="preserve">
          <source>A tag signature file, to be fed to this command&amp;rsquo;s standard input, has a very simple fixed format: four lines of</source>
          <target state="translated">このコマンドの標準入力に供給されるタグ署名ファイルは、非常に単純な固定形式です。</target>
        </trans-unit>
        <trans-unit id="c9577e2a94118633866403eba48d1b01fa7f34b6" translate="yes" xml:space="preserve">
          <source>A text file containing the absolute path back to the .git file that points to here. This is used to check if the linked repository has been manually removed and there is no need to keep this directory any more. The mtime of this file should be updated every time the linked repository is accessed.</source>
          <target state="translated">ここを指す .git ファイルへの絶対パスを含むテキストファイル。これは、リンク先のリポジトリが手動で削除されたかどうか、このディレクトリを保持する必要がなくなったかどうかを確認するために使用します。このファイルの mtime は、リンク先のリポジトリにアクセスするたびに更新しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e6620ed6a8dd7fc370324b4a637371aff9ccd2b8" translate="yes" xml:space="preserve">
          <source>A textconv, by comparison, is much more limiting. You provide a transformation of the data into a line-oriented text format, and Git uses its regular diff tools to generate the output. There are several advantages to choosing this method:</source>
          <target state="translated">それに比べて textconv は、より限定的なものです。データを行指向のテキスト形式に変換し、Git は通常の diff ツールを使って出力を生成します。この方法を選択すると、いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="20ee50ebcc035e786bc0063549e7c3be96310965" translate="yes" xml:space="preserve">
          <source>A tilde &lt;code&gt;~&lt;/code&gt; and caret &lt;code&gt;^&lt;/code&gt; are used to introduce the postfix &lt;code&gt;nth parent&lt;/code&gt; and &lt;code&gt;peel onion&lt;/code&gt; operation.</source>
          <target state="translated">チルダ &lt;code&gt;~&lt;/code&gt; とキャレット &lt;code&gt;^&lt;/code&gt; を使用して、 &lt;code&gt;nth parent&lt;/code&gt; の接尾辞と &lt;code&gt;peel onion&lt;/code&gt; 操作を導入します。</target>
        </trans-unit>
        <trans-unit id="8b05115bcd451b82846a70dc0f8122c29671169c" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;&lt;code&gt;abc&lt;/code&gt;&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">末尾の「 &lt;code&gt;/**&lt;/code&gt; 」は内部のすべてに一致します。たとえば、「 &lt;code&gt;abc/**&lt;/code&gt; 」は、 &lt;code&gt;.gitignore&lt;/code&gt; ファイルの場所を基準にして、ディレクトリ「 &lt;code&gt;abc&lt;/code&gt; 」内のすべてのファイルと、深さが無限に一致します。</target>
        </trans-unit>
        <trans-unit id="c57747a45d9976be1263b4b7a69a5ab667656384" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">末尾の「 &lt;code&gt;/**&lt;/code&gt; 」は内部のすべてに一致します。たとえば、 &quot; &lt;code&gt;abc/**&lt;/code&gt; &quot;は、 &lt;code&gt;.gitignore&lt;/code&gt; ファイルの場所を基準にして、ディレクトリ &quot;abc&quot;内のすべてのファイルと、深さが無限に一致します。</target>
        </trans-unit>
        <trans-unit id="ed5db9c2038caa3b11960feb667ae09ddbf5220c" translate="yes" xml:space="preserve">
          <source>A trailing &amp;ldquo;/&lt;strong&gt;&amp;rdquo; matches everything inside. For example, &amp;ldquo;abc/&lt;/strong&gt;&amp;rdquo; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">末尾の「/ &lt;strong&gt;」は、内部のすべてに一致します。たとえば、「abc /&lt;/strong&gt;」は、 &lt;code&gt;.gitignore&lt;/code&gt; ファイルの場所を基準にして、ディレクトリ「abc」内のすべてのファイルに一致します。深さは無限です。</target>
        </trans-unit>
        <trans-unit id="1ffbc3235b6f3805e76da872c4d7da43eac01de9" translate="yes" xml:space="preserve">
          <source>A tree can be created with &lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree[1]&lt;/a&gt; and its data can be accessed by &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;. Two trees can be compared with &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;.</source>
          <target state="translated">ツリーは&lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree [1]&lt;/a&gt;で作成でき、そのデータには&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;でアクセスできます。2つのツリーは&lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt;と比較できます。</target>
        </trans-unit>
        <trans-unit id="71ac2a6922ce84e247da3afac7c8eab10ddc8e0d" translate="yes" xml:space="preserve">
          <source>A tree can refer to one or more &quot;blob&quot; objects, each corresponding to a file. In addition, a tree can also refer to other tree objects, thus creating a directory hierarchy. You can examine the contents of any tree using ls-tree (remember that a long enough initial portion of the SHA-1 will also work):</source>
          <target state="translated">ツリーは、ファイルに対応する 1 つ以上の「ブロブ」オブジェクトを参照することができます。さらに、ツリーは他のツリー・オブジェクトを参照することもでき、ディレクトリ階層を作成することができます。ls-tree を使用して、任意のツリーの内容を調べることができます (十分に長い SHA-1 の初期部分でも動作することを覚えておいてください)。</target>
        </trans-unit>
        <trans-unit id="20d6593ce00c8f4a86630f0208b8c6cb9ed9de85" translate="yes" xml:space="preserve">
          <source>A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code. Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git. This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back).</source>
          <target state="translated">fast-importの典型的なフロントエンドは、Perl/Python/Rubyのコードが200行程度です。ほとんどの開発者は、fast-importに初めて触れ、時にはGitにも触れることがあるにもかかわらず、わずか数時間で動作するインポーターを作成することができました。ほとんどの変換ツールが使い捨てであることを考えると、これは理想的な状況です。</target>
        </trans-unit>
        <trans-unit id="e8135e3fa6705c7716d147bd5d8e6059fc5669c5" translate="yes" xml:space="preserve">
          <source>A typical integrator&amp;rsquo;s Git day.</source>
          <target state="translated">典型的なインテグレーターのGitの日。</target>
        </trans-unit>
        <trans-unit id="cf9ceecdb03729fb43526343794e6a94c95fe225" translate="yes" xml:space="preserve">
          <source>A typical output of &lt;code&gt;git range-diff&lt;/code&gt; would look like this:</source>
          <target state="translated">&lt;code&gt;git range-diff&lt;/code&gt; の一般的な出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e41e892a94b26f51f6da2faaf7e783142c2d2445" translate="yes" xml:space="preserve">
          <source>A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by &lt;code&gt;git log&lt;/code&gt; along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying &quot;Notes (&amp;lt;refname&amp;gt;):&quot; (or &quot;Notes:&quot; for &lt;code&gt;refs/notes/commits&lt;/code&gt;).</source>
          <target state="translated">メモの一般的な使用法は、コミット自体を変更せずにコミットメッセージを補足することです。メモは、元のコミットメッセージとともに &lt;code&gt;git log&lt;/code&gt; で表示できます。これらのメモをコミットオブジェクトに格納されているメッセージと区別するために、メモのように、「メモ（&amp;lt;refname&amp;gt;）：」（または &lt;code&gt;refs/notes/commits&lt;/code&gt; の場合は「メモ：」）のようにインデントされていない行の後にインデントされます。</target>
        </trans-unit>
        <trans-unit id="f6b5db3f89763f637b749fc5b0ec07665392a318" translate="yes" xml:space="preserve">
          <source>A v2 server would reply:</source>
          <target state="translated">v2サーバーが返信してくれます。</target>
        </trans-unit>
        <trans-unit id="814fa5229889141123953471b46691119165aa04" translate="yes" xml:space="preserve">
          <source>A value j referring to the jth packfile.</source>
          <target state="translated">j 番目のパックファイルを参照する値 j。</target>
        </trans-unit>
        <trans-unit id="0db561a50c25f0c87e4728686c752358969a2d04" translate="yes" xml:space="preserve">
          <source>A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">0を指定すると、ある程度妥当なデフォルト値になります。設定されていない場合、デフォルトは1になります。</target>
        </trans-unit>
        <trans-unit id="aa0ad35cb8bc2af5f4d79278f7255026ebe99d79" translate="yes" xml:space="preserve">
          <source>A variable that takes a pathname value can be given a string that begins with &quot;&lt;code&gt;~/&lt;/code&gt;&quot; or &quot;&lt;code&gt;~user/&lt;/code&gt;&quot;, and the usual tilde expansion happens to such a string: &lt;code&gt;~/&lt;/code&gt; is expanded to the value of &lt;code&gt;$HOME&lt;/code&gt;, and &lt;code&gt;~user/&lt;/code&gt; to the specified user&amp;rsquo;s home directory.</source>
          <target state="translated">パス名の値をとる変数は「で始まる文字列を与えることができます &lt;code&gt;~/&lt;/code&gt; 」または「 &lt;code&gt;~user/&lt;/code&gt; 」を、通常のチルダ拡張は、A列に起こります： &lt;code&gt;~/&lt;/code&gt; の値に展開される &lt;code&gt;$HOME&lt;/code&gt; 、と &lt;code&gt;~user/&lt;/code&gt; を指定されたユーザーのホームディレクトリに。</target>
        </trans-unit>
        <trans-unit id="e794a6fd78ae6c428e6284131fe5a2e63e70771b" translate="yes" xml:space="preserve">
          <source>A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">存在しない参照に対して警告が発行されますが、どの参照にもマッチしないグロブは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="fd32407bcc9b7692e9e0052b8179af70723a8a0f" translate="yes" xml:space="preserve">
          <source>A whole-repository format version bump should only be part of a change that cannot be independently versioned. For instance, if one were to change the reachability rules for objects, or the rules for locking refs, that would require a bump of the repository format version.</source>
          <target state="translated">リポジトリ全体のフォーマットのバージョンバンプは、独立してバージョンを変更できない変更の一部でなければなりません。例えば、オブジェクトの到達性のルールや ref のロックのルールを変更する場合、リポジトリフォーマットのバージョンのバンプが必要になります。</target>
        </trans-unit>
        <trans-unit id="5bfda56601f95323dd8aca6fc5f3876aceac9edc" translate="yes" xml:space="preserve">
          <source>A zero exit from the update hook allows the ref to be updated. Exiting with a non-zero status prevents &lt;code&gt;git receive-pack&lt;/code&gt; from updating that ref.</source>
          <target state="translated">更新フックからのゼロ出口により、参照を更新できます。ゼロ以外のステータスで終了すると、 &lt;code&gt;git receive-pack&lt;/code&gt; がその参照を更新できなくなります。</target>
        </trans-unit>
        <trans-unit id="daa85a6ac2fd33dacf832ee98a538368318a091a" translate="yes" xml:space="preserve">
          <source>A: addition of a file</source>
          <target state="translated">A:ファイルの追加</target>
        </trans-unit>
        <trans-unit id="8e39d81ad3ae332d60cc3e83e97303a91d0b4f70" translate="yes" xml:space="preserve">
          <source>ALERT ALERT ALERT! The Git &quot;merge object order&quot; is different from the RCS &lt;code&gt;merge&lt;/code&gt; program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program &lt;code&gt;merge&lt;/code&gt; is to have the original in the middle. Don&amp;rsquo;t ask me why.</source>
          <target state="translated">ALERT ALERT ALERT！Gitの「オブジェクトのマージ順序」は、RCS &lt;code&gt;merge&lt;/code&gt; プログラムのオブジェクトのマージ順序とは異なります。上記の順序では、オリジナルが最初です。ただし、3者間マージプログラムの &lt;code&gt;merge&lt;/code&gt; の引数の順序は、オリジナルを中間にすることです。理由を聞かないでください。</target>
        </trans-unit>
        <trans-unit id="4508200e35a10a4b1f04bf5f137007ce3e238313" translate="yes" xml:space="preserve">
          <source>Abbreviate the object name. When using &lt;code&gt;--hash&lt;/code&gt;, you do not have to say &lt;code&gt;--hash --abbrev&lt;/code&gt;; &lt;code&gt;--hash=n&lt;/code&gt; would do.</source>
          <target state="translated">オブジェクト名を省略します。使用している場合 &lt;code&gt;--hash&lt;/code&gt; 、あなたが言う必要はありません &lt;code&gt;--hash --abbrev&lt;/code&gt; を。 &lt;code&gt;--hash=n&lt;/code&gt; で十分です。</target>
        </trans-unit>
        <trans-unit id="73bf43580d9c77cf2c146fe7b7b0ac96cfdd25cc" translate="yes" xml:space="preserve">
          <source>Abbreviating long options</source>
          <target state="translated">長いオプションの省略</target>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state.</source>
          <target state="translated">現在の紛争解決プロセスを中止し、マージ前の状態を再構築しようとします。</target>
        </trans-unit>
        <trans-unit id="97a8cc5ece3d7d535580e6c4ba9d955b1cbee507" translate="yes" xml:space="preserve">
          <source>Abort the patching operation but keep HEAD and the index untouched.</source>
          <target state="translated">パッチング操作を中止しますが、HEADとインデックスはそのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="d8af665ebaab7b8a3f7a19d579a76f94def56137" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation and reset HEAD to the original branch. If &amp;lt;branch&amp;gt; was provided when the rebase operation was started, then HEAD will be reset to &amp;lt;branch&amp;gt;. Otherwise HEAD will be reset to where it was when the rebase operation was started.</source>
          <target state="translated">リベース操作を中止し、HEADを元のブランチにリセットします。リベース操作の開始時に&amp;lt;branch&amp;gt;が指定された場合、HEADは&amp;lt;branch&amp;gt;にリセットされます。そうでない場合、HEADはリベース操作が開始されたときの場所にリセットされます。</target>
        </trans-unit>
        <trans-unit id="e1a60cae95d240ebe223133619984451eb8da56d" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result.</source>
          <target state="translated">リベース操作を中止しますが、HEADは元のブランチにリセットされません。インデックスと作業ツリーも結果として変更されません。</target>
        </trans-unit>
        <trans-unit id="348ed40ffd74f6eb0fbdde58a662f091cfe18d08" translate="yes" xml:space="preserve">
          <source>Abort/reset an in-progress &lt;code&gt;git notes merge&lt;/code&gt;, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.</source>
          <target state="translated">進行中の &lt;code&gt;git notes merge&lt;/code&gt; を中止/リセットします。つまり、競合が発生しているメモのマージです。これは単にメモのマージに関連するすべてのファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="26d78acc57b2d47f1ebfb75a2f9bb6687faa0fcc" translate="yes" xml:space="preserve">
          <source>About ten years ago did i do my first &lt;code&gt;bisection&lt;/code&gt; of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug.</source>
          <target state="translated">10年ほど前にLinuxパッチキューの最初の &lt;code&gt;bisection&lt;/code&gt; を行いました。それはGitより前（さらにはBitKeeperより前）でした。私は文字通りパッチを整理し、本質的にはそのバグに関連していると私が推測したスタンドアロンのコミットを作成するのに費やしました。</target>
        </trans-unit>
        <trans-unit id="7a17b1a2762f733cbf8fe0ce3ae058c1fb64af21" translate="yes" xml:space="preserve">
          <source>Absolute filesystem path which will be prepended to project path; the path to repository is &lt;code&gt;$projectroot/$project&lt;/code&gt;. Set to &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; during installation. This variable has to be set correctly for gitweb to find repositories.</source>
          <target state="translated">プロジェクトパスの前に付加される絶対ファイルシステムパス。リポジトリへのパスは &lt;code&gt;$projectroot/$project&lt;/code&gt; です。インストール時に &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; に設定します。gitwebがリポジトリを見つけるには、この変数を正しく設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="17286b3ab79f469f1686313022a96ba044391703" translate="yes" xml:space="preserve">
          <source>Accelerated static Apache 2.x</source>
          <target state="translated">高速化された静的な Apache 2.x</target>
        </trans-unit>
        <trans-unit id="52790b3bcb573f6e8573cdbe7b68a8e690d099eb" translate="yes" xml:space="preserve">
          <source>Access control: By restricting user access to submodules, this can be used to implement read/write policies for different users.</source>
          <target state="translated">アクセス制御。サブモジュールへのユーザーアクセスを制限することで、異なるユーザーの読み書きポリシーを実装するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="478ae85b8fa23d44da84a56a398158571f09f29c" translate="yes" xml:space="preserve">
          <source>Act as though the corresponding command-line option with a leading &lt;code&gt;--&lt;/code&gt; was passed on the command line (see OPTIONS, above).</source>
          <target state="translated">先頭が &lt;code&gt;--&lt;/code&gt; の対応するコマンドラインオプションがコマンドラインで渡されたかのように動作します（上記のオプションを参照）。</target>
        </trans-unit>
        <trans-unit id="6478562162279a99d43ca11e0923b34140a68ad3" translate="yes" xml:space="preserve">
          <source>Actions, and urls</source>
          <target state="translated">アクション、および、URL</target>
        </trans-unit>
        <trans-unit id="3894e58bd38733ccd4747f0674e47d077bbb6100" translate="yes" xml:space="preserve">
          <source>Actions:</source>
          <target state="translated">Actions:</target>
        </trans-unit>
        <trans-unit id="8c5178bf114268e42ef635c5fbc78f8654415410" translate="yes" xml:space="preserve">
          <source>Activate recording of resolved conflicts, so that identical conflict hunks can be resolved automatically, should they be encountered again. By default, &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt; is enabled if there is an &lt;code&gt;rr-cache&lt;/code&gt; directory under the &lt;code&gt;$GIT_DIR&lt;/code&gt;, e.g. if &quot;rerere&quot; was previously used in the repository.</source>
          <target state="translated">解決された競合の記録をアクティブ化して、同じ競合hunkが再び発生した場合に自動的に解決できるようにします。 &lt;code&gt;$GIT_DIR&lt;/code&gt; 下に &lt;code&gt;rr-cache&lt;/code&gt; ディレクトリがある場合、たとえば「rerere」が以前にリポジトリで使用されていた場合、デフォルトで&lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]&lt;/a&gt;が有効になります。</target>
        </trans-unit>
        <trans-unit id="f02f312753d69f3d534d52a8b88d589eac9ef0bb" translate="yes" xml:space="preserve">
          <source>Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch. If subtree &lt;code&gt;include&lt;/code&gt; has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree &lt;code&gt;src&lt;/code&gt; has been modified by a commit since the branch became active, then its contents will be loaded in memory.</source>
          <target state="translated">アクティブなブランチには、非アクティブなブランチと同じオーバーヘッドがありますが、そのブランチで最近変更されたすべてのツリーのコピーも含まれています。ブランチがアクティブになってからサブツリー &lt;code&gt;include&lt;/code&gt; が変更されていない場合、そのコンテンツはメモリに読み込まれませんが、ブランチがアクティブになってからサブツリー &lt;code&gt;src&lt;/code&gt; がコミットによって変更されている場合、そのコンテンツはメモリに読み込まれます。</target>
        </trans-unit>
        <trans-unit id="19a0105409fd4103b8842eb13af0140d95a67fb2" translate="yes" xml:space="preserve">
          <source>Active submodules</source>
          <target state="translated">アクティブなサブモジュール</target>
        </trans-unit>
        <trans-unit id="8a0a4ffd02b3e3415f28bfa49ecef06eac3d36bf" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">ように作用する &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; が、で使用される&lt;a href=&quot;git-fetch-pack&quot;&gt;のgitフェッチパック[1]&lt;/a&gt;の代わり&lt;a href=&quot;git-fsck&quot;&gt;にgit-のfsck [1] &lt;/a&gt;。詳細については、 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="8a2b29e689f134a6c33caf76c2612bd809b36f86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">ように作用する &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; が、で使用される&lt;a href=&quot;git-receive-pack&quot;&gt;のgit -受信パック[1]&lt;/a&gt;の代わり&lt;a href=&quot;git-fsck&quot;&gt;にgit-のfsck [1] &lt;/a&gt;。詳細については、 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="53c1b47e4f88ea8cc86f31135daa96f65e495e4d" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; のように動作しますが、&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt;ではなく&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;によって使用されます。詳細については、 &lt;code&gt;fsck.skipList&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="31c02a316f685de03eb757b49fbbce21e75b00c4" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; のように動作しますが、&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt;ではなく&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;によって使用されます。詳細については、 &lt;code&gt;fsck.skipList&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="bb483d422626db8f460b089acb2b2a17f42ef653" translate="yes" xml:space="preserve">
          <source>Actually write the object into the object database.</source>
          <target state="translated">実際にオブジェクトをオブジェクトデータベースに書き込む</target>
        </trans-unit>
        <trans-unit id="9ae5ee2ecd5525bbb102db4f0d78bb539c98b2b0" translate="yes" xml:space="preserve">
          <source>Adapting your work-flow</source>
          <target state="translated">ワークフローの適応</target>
        </trans-unit>
        <trans-unit id="febbcaaccd6732ef0fbf603adeb6e4b1534f2caf" translate="yes" xml:space="preserve">
          <source>Add &quot;glob&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Disabling globbing on individual pathspecs can be done using pathspec magic &quot;:(literal)&quot;</source>
          <target state="translated">「glob」マジックをすべてのパススペックに追加します。これは、 &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; 環境変数を &lt;code&gt;1&lt;/code&gt; に設定することと同じです。個々のパススペックでのグロビングの無効化は、パススペックマジック &quot;：（literal）&quot;を使用して行うことができます</target>
        </trans-unit>
        <trans-unit id="7a1c5ad83cb656e31e0abe5871946adce7f2dbed" translate="yes" xml:space="preserve">
          <source>Add &quot;icase&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">「icase」マジックをすべてのパススペックに追加します。これは、 &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; 環境変数を &lt;code&gt;1&lt;/code&gt; に設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="38d537b0a7b0bc1a6255114f214ad3b7382addc5" translate="yes" xml:space="preserve">
          <source>Add &quot;literal&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Enabling globbing on individual pathspecs can be done using pathspec magic &quot;:(glob)&quot;</source>
          <target state="translated">「リテラル」マジックをすべてのパススペックに追加します。これは、 &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; 環境変数を &lt;code&gt;1&lt;/code&gt; に設定することと同じです。個々のパススペックでグロビングを有効にするには、パススペックマジック &quot;：（glob）&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="5a692c67e8b6f449d83f8b5219858b8b4cd34c65" translate="yes" xml:space="preserve">
          <source>Add (or prevent adding) the &quot;X-Mailer:&quot; header. By default, the header is added, but it can be turned off by setting the &lt;code&gt;sendemail.xmailer&lt;/code&gt; configuration variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">「X-Mailer：」ヘッダーを追加（または追加を禁止）します。デフォルトではヘッダーが追加されますが、 &lt;code&gt;sendemail.xmailer&lt;/code&gt; 構成変数を &lt;code&gt;false&lt;/code&gt; に設定することでオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="875e6f546a41d1d0704772304d2d43d72adc62d9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">自分のコミッターIDを使用して、 &lt;code&gt;Signed-off-by:&lt;/code&gt; 行をコミットメッセージに追加します。詳細については、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;のsignoffオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ed47084b5999b126507c3c0b45a1bb8e478c76b6" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line at the end of the commit message. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">コミットメッセージの最後にSigned-off-by行を追加します。詳細については、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;のsignoffオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="290e4752e9d079cc99d7e2f47d052706296ff714" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line by the committer at the end of the commit log message. The meaning of a signoff depends on the project, but it typically certifies that committer has the rights to submit this work under the same license and agrees to a Developer Certificate of Origin (see &lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt; for more information).</source>
          <target state="translated">コミットログメッセージの最後にコミッターがSigned-off-by行を追加します。サインオフの意味はプロジェクトによって異なりますが、通常はコミッターが同じライセンスに基づいてこの作業を提出する権利を有していることを証明し、開発元証明書に同意し&lt;a href=&quot;http://developercertificate.org/&quot;&gt;ます&lt;/a&gt;（詳細については、http：//developercertificate.org/を参照してください）。</target>
        </trans-unit>
        <trans-unit id="780762089271321ecfe958d672a214a85e1519d6" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Cc:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-cc&lt;/code&gt; discards all &lt;code&gt;Cc:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">&lt;code&gt;Cc:&lt;/code&gt; ヘッダーをメールのヘッダーに追加します。これは、構成されたヘッダーに追加されるもので、複数回使用できます。否定形式 &lt;code&gt;--no-cc&lt;/code&gt; は、これまでに（構成またはコマンドラインから）追加されたすべての &lt;code&gt;Cc:&lt;/code&gt; ヘッダーを破棄します。</target>
        </trans-unit>
        <trans-unit id="ee7701fb474747c5b74516af829e74a1b309150b" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">自分のコミッターIDを使用して、 &lt;code&gt;Signed-off-by:&lt;/code&gt; 行をコミットメッセージに追加します。詳細については、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;のsignoffオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1d5ee25b8be312a8351ef48a09ee57bfe0ac5407" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;To:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-to&lt;/code&gt; discards all &lt;code&gt;To:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">&lt;code&gt;To:&lt;/code&gt; ヘッダーをメールのヘッダーに追加します。これは、構成されたヘッダーに追加されるもので、複数回使用できます。否定形式 &lt;code&gt;--no-to&lt;/code&gt; は、これまでに追加されたすべての &lt;code&gt;To:&lt;/code&gt; ヘッダーを破棄します（構成またはコマンドラインから）。</target>
        </trans-unit>
        <trans-unit id="1d75fe65b404604e5ef539902b9de029d2905810" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;verify&lt;/code&gt; subcommand to the &lt;code&gt;git midx&lt;/code&gt; builtin to verify the contents of the multi-pack-index file match the offsets listed in the corresponding pack-indexes.</source>
          <target state="translated">組み込みの &lt;code&gt;git midx&lt;/code&gt; に &lt;code&gt;verify&lt;/code&gt; サブコマンドを追加して、multi-pack-indexファイルの内容が、対応するpack-indexesにリストされているオフセットと一致することを確認します。</target>
        </trans-unit>
        <trans-unit id="f049bd4f468982bc6e0cdfee8fd216a0b6cab6f3" translate="yes" xml:space="preserve">
          <source>Add a Signed-off-by: trailer to all the rebased commits. Note that if &lt;code&gt;--interactive&lt;/code&gt; is given then only commits marked to be picked, edited or reworded will have the trailer added.</source>
          <target state="translated">Signed-off-by：トレーラーをすべてのリベースされたコミットに追加します。 &lt;code&gt;--interactive&lt;/code&gt; が指定されている場合、選択、編集、または言い換えのマークが付けられたコミットのみがトレーラーを追加することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ced7c6e6677217cd2f3e27d5808cd7af3f82dcc9" translate="yes" xml:space="preserve">
          <source>Add a new remote, fetch, and check out a branch from it</source>
          <target state="translated">新しいリモートを追加し、フェッチし、そこからブランチをチェックアウトする</target>
        </trans-unit>
        <trans-unit id="d7b8618aa62adcdff8f32f43f7ea6da4fbbc410b" translate="yes" xml:space="preserve">
          <source>Add a section on working with other version control systems, including CVS, Subversion, and just imports of series of release tarballs.</source>
          <target state="translated">CVS、Subversion、およびリリースターボールのシリーズの単なるインポートを含む他のバージョン管理システムでの作業についてのセクションを追加します。</target>
        </trans-unit>
        <trans-unit id="a6c8ce810b46aeac59b7c7fbb4f0eb1c414e0fbc" translate="yes" xml:space="preserve">
          <source>Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.</source>
          <target state="translated">生成された各メッセージに署名を追加します。RFC 3676 にしたがって、署名は本文から '--' の行で区切られます。signature オプションを省略すると、署名のデフォルトは Git のバージョン番号となります。</target>
        </trans-unit>
        <trans-unit id="d67013d040b00288c354d7feb55fb2074c49fc78" translate="yes" xml:space="preserve">
          <source>Add a tag reference in &lt;code&gt;refs/tags/&lt;/code&gt;, unless &lt;code&gt;-d/-l/-v&lt;/code&gt; is given to delete, list or verify tags.</source>
          <target state="translated">タグを削除、一覧表示、または検証するために &lt;code&gt;-d/-l/-v&lt;/code&gt; が指定されていない限り、タグ参照を &lt;code&gt;refs/tags/&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="c3ba9550fdf49f0f7ec1ed9c2838f550f0841180" translate="yes" xml:space="preserve">
          <source>Add all existing files to the index.</source>
          <target state="translated">既存のすべてのファイルをインデックスに追加します。</target>
        </trans-unit>
        <trans-unit id="61e0fed7e8f28eb826825866ef9181c8986ab6b6" translate="yes" xml:space="preserve">
          <source>Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt;. The negated form &lt;code&gt;--no-add-header&lt;/code&gt; discards &lt;strong&gt;all&lt;/strong&gt; (&lt;code&gt;To:&lt;/code&gt;, &lt;code&gt;Cc:&lt;/code&gt;, and custom) headers added so far from config or command line.</source>
          <target state="translated">メールのヘッダーに任意のヘッダーを追加します。これは、構成されたヘッダーに追加されるもので、複数回使用できます。たとえば、-- &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt; です。否定形式 &lt;code&gt;--no-add-header&lt;/code&gt; は、構成またはコマンドラインからこれまでに追加された&lt;strong&gt;すべての&lt;/strong&gt;（ &lt;code&gt;To:&lt;/code&gt; 、 &lt;code&gt;Cc:&lt;/code&gt; 、およびカスタム）ヘッダーを破棄し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3eb694979cbe30dcf490050a0765be211e88b887" translate="yes" xml:space="preserve">
          <source>Add an extra directive to the output for commits and blobs, &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt;. While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id).</source>
          <target state="translated">コミットとBLOBの出力に追加のディレクティブ、 &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt; を追加します。このようなディレクティブはgit-fast-importなどのインポーターによって無視される可能性がありますが、中間フィルター（たとえば、古いコミットを参照するコミットメッセージの書き換えや、IDによるblobの除去）には役立ちます。</target>
        </trans-unit>
        <trans-unit id="d3d9056473fe07372c67f810c3055c3b46a20590" translate="yes" xml:space="preserve">
          <source>Add authorship information. Adds Author line, and Committer (if different from Author) to the message.</source>
          <target state="translated">著者情報を追加します。メッセージに Author 行、Committer (Author と異なる場合)を追加します。</target>
        </trans-unit>
        <trans-unit id="b495931d52e43ecbfb5286b0146fb64097586eff" translate="yes" xml:space="preserve">
          <source>Add file contents to the index</source>
          <target state="translated">ファイルの内容をインデックスに追加</target>
        </trans-unit>
        <trans-unit id="c35a311c3337f0cc2cbd68316a0fe51132f8719c" translate="yes" xml:space="preserve">
          <source>Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">作業ツリーの変更されたコンテンツをインタラクティブにインデックスに追加します。オプションのパス引数を指定して、操作を作業ツリーのサブセットに制限できます。詳細については、「インタラクティブモード」を参照してください。</target>
        </trans-unit>
        <trans-unit id="f89fde681339a37c16082b848c84b533f9b8eb78" translate="yes" xml:space="preserve">
          <source>Add more good examples. Entire sections of just cookbook examples might be a good idea; maybe make an &quot;advanced examples&quot; section a standard end-of-chapter section?</source>
          <target state="translated">もっと良い例を追加してください。ちょうど料理本の例のセクション全体が良いアイデアかもしれません;多分 &quot;高度な例&quot; セクションを標準的な章の終わりのセクションにしますか?</target>
        </trans-unit>
        <trans-unit id="e557ff36381109d45439d6a8300a1119a6fdeb9a" translate="yes" xml:space="preserve">
          <source>Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use &lt;code&gt;-f&lt;/code&gt; to overwrite existing notes). However, if you&amp;rsquo;re using &lt;code&gt;add&lt;/code&gt; interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the &lt;code&gt;edit&lt;/code&gt; subcommand).</source>
          <target state="translated">指定されたオブジェクトのメモを追加します（デフォルトはHEAD）。オブジェクトにすでにメモがある場合は中止します（ &lt;code&gt;-f&lt;/code&gt; を使用して既存のメモを上書きします）。ただし、 &lt;code&gt;add&lt;/code&gt; をインタラクティブに使用している場合（エディターを使用してノートのコンテンツを提供する場合）は、中止する代わりに、既存のノートがエディターで開かれ &lt;code&gt;edit&lt;/code&gt; （editサブコマンドのように）。</target>
        </trans-unit>
        <trans-unit id="cc2ade0db6bb50863f06b44fc9c06dfd60dcfff0" translate="yes" xml:space="preserve">
          <source>Add or inspect object notes</source>
          <target state="translated">オブジェクトノートの追加と検査</target>
        </trans-unit>
        <trans-unit id="384163813513712116bc610979aaf5a161ff795b" translate="yes" xml:space="preserve">
          <source>Add or parse structured information in commit messages</source>
          <target state="translated">コミットメッセージに構造化された情報を追加または解析</target>
        </trans-unit>
        <trans-unit id="4e875c484b14b19240ea9be7566dd014f5c8ec38" translate="yes" xml:space="preserve">
          <source>Add the given merge information during the dcommit (e.g. &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt;). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (&lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt;)</source>
          <target state="translated">dcommit中に特定のマージ情報を追加します（例 &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt; ）。すべてのsvnサーバーバージョンはこの情報を（プロパティとして）保存でき、バージョン1.5以降のsvnクライアントはそれを利用できます。複数のブランチからのマージ情報を指定するには、ブランチ間に単一のスペース文字を使用します（ &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3cd81f5530cb193ba26157e4348607aee6556490" translate="yes" xml:space="preserve">
          <source>Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the &quot;superproject&quot;.</source>
          <target state="translated">与えられたリポジトリを、現在のプロジェクトの隣にコミットされるチェンジセットの指定されたパスにサブモジュールとして追加します。</target>
        </trans-unit>
        <trans-unit id="5cddbbcd4cc96cbfc64c9c4d6d8f5bcef7bbee43" translate="yes" xml:space="preserve">
          <source>Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user&amp;rsquo;s global exclusion file.</source>
          <target state="translated">標準のGit除外を追加します。各ディレクトリに.git / info / exclude、.gitignore、およびユーザーのグローバル除外ファイルを追加します。</target>
        </trans-unit>
        <trans-unit id="9821869aa821996defeaba01e6c12538af610d55" translate="yes" xml:space="preserve">
          <source>Added content is represented by lines beginning with &quot;+&quot;. You can prevent staging any addition lines by deleting them.</source>
          <target state="translated">追加された内容は「+」で始まる行で表現されます。追加された行を削除することで、追加された行の演出を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="afb70b05688a7cd869d2606481b27296b19719c8" translate="yes" xml:space="preserve">
          <source>Additional commands may be supported, as may be determined from capabilities reported by the helper.</source>
          <target state="translated">ヘルパーが報告した能力から判断して、追加のコマンドをサポートしてもよい。</target>
        </trans-unit>
        <trans-unit id="73160eb439c17b83bb173df83040945299062f05" translate="yes" xml:space="preserve">
          <source>Additional email headers to include in a patch to be submitted by mail. See &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">メールで送信するパッチに含める追加の電子メールヘッダー。&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="54ded2bd3477ca52f24ae225994ba73ed8ad29b3" translate="yes" xml:space="preserve">
          <source>Additional features not supported in the base command will be advertised as the value of the command in the capability advertisement in the form of a space separated list of features: &quot;&amp;lt;command&amp;gt;=&amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</source>
          <target state="translated">baseコマンドでサポートされていない追加機能は、機能のスペース広告で区切られたリストの形式で機能アドバタイズメントのコマンドの値としてアドバタイズされます： &quot;&amp;lt;command&amp;gt; = &amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</target>
        </trans-unit>
        <trans-unit id="fa12c13f7c5fa3298b908c7e9540ddac59b47249" translate="yes" xml:space="preserve">
          <source>Additional information about the object store is recorded in this directory.</source>
          <target state="translated">このディレクトリには、オブジェクトストアに関する追加情報が記録されています。</target>
        </trans-unit>
        <trans-unit id="be06c5d8e7c3543b7023fd7faff294ed6ccc5563" translate="yes" xml:space="preserve">
          <source>Additional information about the repository is recorded in this directory. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/info&quot; will be used instead.</source>
          <target state="translated">このディレクトリには、リポジトリに関する追加情報が記録されます。GIT_COMMON_DIRが設定されている場合、このディレクトリは無視され、代わりに&quot;$GIT_COMMON_DIR/info &quot;が使用されます。</target>
        </trans-unit>
        <trans-unit id="e1d5079ec73555b8d437ff4e76ae398022d66054" translate="yes" xml:space="preserve">
          <source>Additional links to be added to the start of the breadcrumb trail before the home link, to pages that are logically &quot;above&quot; the gitweb projects list, such as the organization and department which host the gitweb server. Each element of the list is a reference to an array, in which element 0 is the link text (equivalent to &lt;code&gt;$home_link_str&lt;/code&gt;) and element 1 is the target URL (equivalent to &lt;code&gt;$home_link&lt;/code&gt;).</source>
          <target state="translated">ホームリンクの前のブレッドクラムトレイルの先頭に追加する追加リンク。gitwebサーバーをホストする組織や部門など、gitwebプロジェクトリストの論理的に「上位」にあるページ。リストの各要素は配列への参照であり、要素0はリンクテキスト（ &lt;code&gt;$home_link_str&lt;/code&gt; 相当）で、要素1はターゲットURL（ &lt;code&gt;$home_link&lt;/code&gt; 相当）です。</target>
        </trans-unit>
        <trans-unit id="d9432410873900e1c24cb64c2fa2f5825d3d685b" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; に追加オプションを追加すると、不要なマージを結果の履歴から削除できます。このマージに関与しているコミットが選択されていないためです。</target>
        </trans-unit>
        <trans-unit id="936252ffd07e8aa44edb6a58806e990e0e986320" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; に追加オプションを追加すると、不要なマージを結果の履歴から削除できます。このマージに関与しているコミットが選択されていないためです。（詳細な説明については、&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;「履歴の簡略化」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="639abe6e93382e14198d397d42d012876c506898" translate="yes" xml:space="preserve">
          <source>Additional options for cvsps. The options &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-A&lt;/code&gt; are implicit and should not be used here.</source>
          <target state="translated">cvspsの追加オプション。オプション &lt;code&gt;-u&lt;/code&gt; および &lt;code&gt;-A&lt;/code&gt; は暗黙的であり、ここでは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="126d4b07345ee8d93a4ae79da306723c896414b7" translate="yes" xml:space="preserve">
          <source>Additional recipients to include in a patch to be submitted by mail. See the --to and --cc options in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">メールで送信するパッチに含める追加の受信者。&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;の--toおよび--ccオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="37901b95369dc888aa41ab1e345bdcf6c9cbdd0a" translate="yes" xml:space="preserve">
          <source>Additionally, &quot;[PATCH]&quot; will be stripped from the commit description.</source>
          <target state="translated">さらに、コミットの記述から「[PATCH]」が取り除かれます。</target>
        </trans-unit>
        <trans-unit id="45f709ea6030431bf2cc526dc56f831bf13777f2" translate="yes" xml:space="preserve">
          <source>Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git &quot;patch&quot; programs won&amp;rsquo;t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.</source>
          <target state="translated">さらに、名前変更を検出して処理し、インテリジェントに書き直して名前変更パッチを生成します。名前を変更するパッチは、テキスト出力の量を減らし、一般的にレビューを容易にします。Git以外の「パッチ」プログラムは名前の変更パッチを認識しないため、受信者がGitを使用してパッチを適用していることがわかっている場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="7511556dc9bb42ef3e1b927086b0b7b0eb2fc510" translate="yes" xml:space="preserve">
          <source>Additionally, it will create a special branch named &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt;, where &amp;lt;SVN-Revision&amp;gt; is the SVN revision number the branch was copied from. This branch will point to the newly created parent commit of the branch. If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt; という名前の特別なブランチが作成されます。ここで、&amp;lt;SVN-Revision&amp;gt;は、ブランチのコピー元のSVNリビジョン番号です。このブランチは、ブランチの新しく作成された親コミットを指します。SVNでブランチが削除され、後で別のバージョンから再作成された場合、そのようなブランチは &lt;code&gt;@&lt;/code&gt; で複数存在します。</target>
        </trans-unit>
        <trans-unit id="c4aae954f8fe3ec994c11ca19a460c6f95d1b16b" translate="yes" xml:space="preserve">
          <source>Additionally, only one of these options can be used per svn-remote section because they affect the &lt;code&gt;git-svn-id:&lt;/code&gt; metadata line, except for rewriteRoot and rewriteUUID which can be used together.</source>
          <target state="translated">さらに、これらのオプションは &lt;code&gt;git-svn-id:&lt;/code&gt; メタデータ行に影響を与えるため、svn-remoteセクションごとに1つだけ使用できます。ただし、rewriteRootとrewriteUUIDは一緒に使用できます。</target>
        </trans-unit>
        <trans-unit id="629abb925697ea2611b60db0bc894374f52c4869" translate="yes" xml:space="preserve">
          <source>Additionally, the commit diff lines that are only present in the first commit range are shown &quot;dimmed&quot; (this can be overridden using the &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; config setting where &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt; and &lt;code&gt;newDimmed&lt;/code&gt;), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; being one of &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt; or &lt;code&gt;newBold&lt;/code&gt;).</source>
          <target state="translated">さらに、最初のコミット範囲にのみ存在するコミットdiff行は「淡色表示」で表示されます（これは &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; 設定を使用してオーバーライドできます。ここで、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は &lt;code&gt;contextDimmed&lt;/code&gt; 、 &lt;code&gt;oldDimmed&lt;/code&gt; 、 &lt;code&gt;newDimmed&lt;/code&gt; のいずれかです）。また、2番目のコミット範囲にのみ存在するコミットの差分行は太字で示されています（これは、設定の &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; を使用してオーバーライドでき、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は &lt;code&gt;contextBold&lt;/code&gt; 、 &lt;code&gt;oldBold&lt;/code&gt; 、または &lt;code&gt;newBold&lt;/code&gt; のいずれかです）。</target>
        </trans-unit>
        <trans-unit id="33cc6001363abb379cd9070769d41d2ac8c9a55b" translate="yes" xml:space="preserve">
          <source>Additionally, when a configured remote has &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; set to &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt;, Git explicitly invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; as the first argument. If set, the second argument is &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt;; otherwise, the second argument is omitted.</source>
          <target state="translated">さらに、構成されたリモートで &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; が &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; に設定されている場合、Git は最初の引数として &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; を指定して &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; を明示的に呼び出します。設定されている場合、2番目の引数は &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt; です。それ以外の場合、2番目の引数は省略されます。</target>
        </trans-unit>
        <trans-unit id="6af479ae4e97a30fad59cd7baeb4a449867877a2" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;replace&lt;/code&gt; reference in &lt;code&gt;refs/replace/&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;code&gt;refs/replace/&lt;/code&gt; 名前空間に &lt;code&gt;replace&lt;/code&gt; 参照を追加します。</target>
        </trans-unit>
        <trans-unit id="067f226622dab621132cf8ecc0c9775fffa56382" translate="yes" xml:space="preserve">
          <source>Adds a new line to the option without altering any existing values. This is the same as providing &lt;code&gt;^$&lt;/code&gt; as the value_regex in &lt;code&gt;--replace-all&lt;/code&gt;.</source>
          <target state="translated">既存の値を変更せずに、オプションに新しい行を追加します。これは、 &lt;code&gt;--replace-all&lt;/code&gt; でvalue_regexとして &lt;code&gt;^$&lt;/code&gt; を指定するのと同じです。</target>
        </trans-unit>
        <trans-unit id="25827132716a81d21acebe34dd646ff14930968e" translate="yes" xml:space="preserve">
          <source>Adds a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;url&amp;gt;のリポジトリに&amp;lt;name&amp;gt;という名前のリモートを追加します。コマンド &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; を使用して、リモート追跡ブランチ&amp;lt;name&amp;gt; / &amp;lt;branch&amp;gt;を作成および更新できます。</target>
        </trans-unit>
        <trans-unit id="ab8c59cb65189781a225d03eb525c1d3e35346e1" translate="yes" xml:space="preserve">
          <source>Adds content from all &lt;code&gt;*.txt&lt;/code&gt; files under &lt;code&gt;Documentation&lt;/code&gt; directory and its subdirectories:</source>
          <target state="translated">&lt;code&gt;Documentation&lt;/code&gt; ディレクトリとそのサブディレクトリの下にあるすべての &lt;code&gt;*.txt&lt;/code&gt; ファイルからコンテンツを追加します。</target>
        </trans-unit>
        <trans-unit id="d2a8bde384697b7b35dc55b38f84a5bc59a23070" translate="yes" xml:space="preserve">
          <source>Adds the file to the index again.</source>
          <target state="translated">ファイルを再びインデックスに追加します。</target>
        </trans-unit>
        <trans-unit id="9deafeaa2ae3e0af3bf37dc46c067f8db67dd63a" translate="yes" xml:space="preserve">
          <source>Adds, removes, or reads notes attached to objects, without touching the objects themselves.</source>
          <target state="translated">オブジェクト自体に触れることなく、オブジェクトに添付されたノートを追加、削除、または読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="b8f333e4ae95f720feba6eabc8b0ae852b99b985" translate="yes" xml:space="preserve">
          <source>Administering</source>
          <target state="translated">Administering</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="c98cde56602b5dbe18cd13dfc6b1296aba3da4ee" translate="yes" xml:space="preserve">
          <source>Advanced branch management</source>
          <target state="translated">高度な支店管理</target>
        </trans-unit>
        <trans-unit id="63c9e0bac98e698a29bdae673d4e9edfa151c025" translate="yes" xml:space="preserve">
          <source>Advanced options</source>
          <target state="translated">高度なオプション</target>
        </trans-unit>
        <trans-unit id="5126907c1aaa23aea7d546c880913def66c36620" translate="yes" xml:space="preserve">
          <source>Advanced shared repository management</source>
          <target state="translated">高度な共有リポジトリ管理</target>
        </trans-unit>
        <trans-unit id="1b3bdc1b24cf17ee4a466d753939342282e0d80f" translate="yes" xml:space="preserve">
          <source>Advanced web server setup</source>
          <target state="translated">高度なウェブサーバーの設定</target>
        </trans-unit>
        <trans-unit id="b6a2eaecb555069cd46a3c234e96420e295802e9" translate="yes" xml:space="preserve">
          <source>Advertise the URL of &lt;code&gt;proj.git&lt;/code&gt;. Anybody else should then be able to clone or pull from that URL, for example with a command line like:</source>
          <target state="translated">&lt;code&gt;proj.git&lt;/code&gt; のURLを宣伝します。他の誰もが、たとえば次のようなコマンドラインを使用して、そのURLから複製またはプルできるはずです。</target>
        </trans-unit>
        <trans-unit id="789a67096a4646c15f2aa6086486ffd34077e411" translate="yes" xml:space="preserve">
          <source>Advice on how to set your identity configuration when your information is guessed from the system username and domain name.</source>
          <target state="translated">システムのユーザー名とドメイン名から自分の情報が推測された場合のID設定の方法をアドバイスします。</target>
        </trans-unit>
        <trans-unit id="a821447d06e24bab231c15461aafe7618db95e5a" translate="yes" xml:space="preserve">
          <source>Advice on what to do when you&amp;rsquo;ve accidentally added one git repo inside of another.</source>
          <target state="translated">誤って1つのGitリポジトリを別のGitリポジトリ内に追加した場合の対処方法に関するアドバイス。</target>
        </trans-unit>
        <trans-unit id="3d483bea154d1589851e27e82350c90b66804ae7" translate="yes" xml:space="preserve">
          <source>Advice shown by various commands when conflicts prevent the operation from being performed.</source>
          <target state="translated">コンフリクトにより操作ができなくなった場合に、各種コマンドで表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="f6a85c6f280ebe2521ee45431f06743254445adc" translate="yes" xml:space="preserve">
          <source>Advice shown if a hook is ignored because the hook is not set as executable.</source>
          <target state="translated">フックが実行可能に設定されていないためにフックが無視された場合に表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="860ec9915ca898e80b509fbd6387408b77665509" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to recursively tag a tag object.</source>
          <target state="translated">ユーザーがタグオブジェクトに再帰的にタグを付けようとした場合に表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="4564a8cef9c264afd1da9386fe52f7316f5ca2ba" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; takes a long time to calculate forced updates after ref updates, or to warn that the check is disabled.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;がref更新後の強制更新の計算、またはチェックが無効であることを警告するのに長い時間がかかるときに表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="1d65ddbca3a799ed312f569d4aeb5502874161b1" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; refuses to merge to avoid overwriting local changes.</source>
          <target state="translated">ローカルの変更を上書きしないように&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;がマージを拒否したときに表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="b0d8f2ca61900be48cc5b75f8552ddc63690e847" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; fails due to a non-fast-forward update to the current branch.</source>
          <target state="translated">現在のブランチへの非早送り更新のために&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;が失敗したときに表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="4568fed53b701ea10d314b56862ee812cfea2bea" translate="yes" xml:space="preserve">
          <source>Advice shown when a sequencer command is already in progress.</source>
          <target state="translated">シーケンサコマンドが既に実行中の場合に表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="9ae8580cfe92126e912e3c0a9b1125abf0c3f017" translate="yes" xml:space="preserve">
          <source>Advice shown when a submodule.alternateErrorStrategy option configured to &quot;die&quot; causes a fatal error.</source>
          <target state="translated">submodule.alternateErrorStrategy オプションを &quot;die&quot; に設定した場合に致命的なエラーが発生した場合に表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="df663a838b7df94d5ce12ffdd49a91bc903ea158" translate="yes" xml:space="preserve">
          <source>Advice shown when the argument to &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; and &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; ambiguously resolves to a remote tracking branch on more than one remote in situations where an unambiguous argument would have otherwise caused a remote-tracking branch to be checked out. See the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable for how to set a given remote to used by default in some situations where this advice would be printed.</source>
          <target state="translated">&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;と&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;への引数が曖昧に複数のリモートのリモートトラッキングブランチに解決された場合に表示されるアドバイスは、明確な引数が原因でリモートトラッキングブランチがチェックアウトされる原因になります。 。このアドバイスが出力される状況で、特定のリモートをデフォルトで使用するように設定する方法については、 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 構成変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="287a70bfe9316e6c27233404e6ef7bfe75cf2ade" translate="yes" xml:space="preserve">
          <source>Advice shown when you ran &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and pushed &lt;code&gt;matching refs&lt;/code&gt; explicitly (i.e. you used &lt;code&gt;:&lt;/code&gt;, or specified a refspec that isn&amp;rsquo;t your current branch) and it resulted in a non-fast-forward error.</source>
          <target state="translated">アドバイスは、あなたが実行したときに示す&lt;a href=&quot;git-push&quot;&gt;のgit-プッシュ[1]&lt;/a&gt;と押し &lt;code&gt;matching refs&lt;/code&gt; （つまり、あなたが使用し、明示的に &lt;code&gt;:&lt;/code&gt; 、またはあなたの現在の分岐ではありませんrefspecを指定）、それが非早送りエラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="c04cbde1130eafb3edca74961656b00234c5044b" translate="yes" xml:space="preserve">
          <source>Advice shown when you used &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; or &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; to move to the detach HEAD state, to instruct how to create a local branch after the fact.</source>
          <target state="translated">&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;または&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;を使用してデタッチHEAD状態に移行し、事後にローカルブランチを作成する方法を指示したときに表示されるアドバイス。</target>
        </trans-unit>
        <trans-unit id="ef27fc3c51d0563e2cd508226536f4e82abdea97" translate="yes" xml:space="preserve">
          <source>Advice that shows the location of the patch file when &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; fails to apply it.</source>
          <target state="translated">&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;がパッチファイルの適用に失敗したときにパッチファイルの場所を示すアドバイス。</target>
        </trans-unit>
        <trans-unit id="28a199e10db511a76b4343fb1d5d8f81b83d30fa" translate="yes" xml:space="preserve">
          <source>Advice to consider using the &lt;code&gt;--quiet&lt;/code&gt; option to &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate unstaged changes after reset.</source>
          <target state="translated">コマンドがリセット後にステージングされていない変更を列挙するのに2秒以上かかる場合は、&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;に &lt;code&gt;--quiet&lt;/code&gt; オプションを使用することを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c591e1c0c160f4739a66ef35a070ea84c2e7f3a4" translate="yes" xml:space="preserve">
          <source>Advise to consider using the &lt;code&gt;-u&lt;/code&gt; option to &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate untracked files.</source>
          <target state="translated">コマンドが追跡されていないファイルを列挙するのに2秒以上かかる場合は、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;に &lt;code&gt;-u&lt;/code&gt; オプションを使用することを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5496dea1231cd43f3ddab3a40907ffb3e37af6ae" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;attr:&lt;/code&gt; comes a space separated list of &quot;attribute requirements&quot;, all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;attr:&lt;/code&gt; 後には、スペースで区切られた「属性要件」のリストが表示されます。パスが一致と見なされるためには、それらすべてを満たす必要があります。これは通常の非マジックパススペックパターンマッチングに追加されます。&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a429914950c338a68e237d8a7583b13b733a18d9" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;collapsing&lt;/code&gt; operation, paths that are different in three trees are left in non-zero stages. At this point, you can inspect the index file with this command:</source>
          <target state="translated">&lt;code&gt;collapsing&lt;/code&gt; 操作後、3つのツリーで異なるパスはゼロ以外のステージのままになります。この時点で、次のコマンドでインデックスファイルを検査できます。</target>
        </trans-unit>
        <trans-unit id="f8a35b13d3b2d2c3173fb0d4b6b82c758bbe9442" translate="yes" xml:space="preserve">
          <source>After Git received the pathnames, it will request the corresponding blobs again. These requests contain a pathname and an empty content section. The filter is expected to respond with the smudged content in the usual way as explained above.</source>
          <target state="translated">Git はパス名を受け取った後、対応する blob を再度リクエストします。これらのリクエストには、パス名と空のコンテンツセクションが含まれます。フィルタは上で説明したように、通常の方法で汚れたコンテンツを返してくると予想されます。</target>
        </trans-unit>
        <trans-unit id="66031e0774792924c3ad30f78f9d0c8073d135a9" translate="yes" xml:space="preserve">
          <source>After a &lt;code&gt;git merge&lt;/code&gt; stops due to conflicts you can conclude the merge by running &lt;code&gt;git merge --continue&lt;/code&gt; (see &quot;HOW TO RESOLVE CONFLICTS&quot; section below).</source>
          <target state="translated">競合により &lt;code&gt;git merge&lt;/code&gt; 停止した後、git merge &lt;code&gt;git merge --continue&lt;/code&gt; 実行してマージを終了できます（以下の「競合を解決する方法」セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="fe72261aa48e1b3f091f59d72477eebdd075b990" translate="yes" xml:space="preserve">
          <source>After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:</source>
          <target state="translated">バイセクションセッションの後、バイセクション状態をクリーンアップして元のHEADに戻すには、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="47c118266972ae017fd4f07d4eca9db22855faae" translate="yes" xml:space="preserve">
          <source>After a failed merge, show refs that touch files having a conflict and don&amp;rsquo;t exist on all heads to merge.</source>
          <target state="translated">マージに失敗した後、競合するファイルに触れ、マージするすべてのヘッドに存在しない参照を表示します。</target>
        </trans-unit>
        <trans-unit id="4ca7401582c91e911d7f14741ffa269af2ed6e2a" translate="yes" xml:space="preserve">
          <source>After a feature release, the integration branch &lt;code&gt;next&lt;/code&gt; may optionally be rewound and rebuilt from the tip of &lt;code&gt;master&lt;/code&gt; using the surviving topics on &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">機能のリリース後、統合ブランチ &lt;code&gt;next&lt;/code&gt; はオプションで巻き戻され、 &lt;code&gt;next&lt;/code&gt; で残っているトピックを使用して &lt;code&gt;master&lt;/code&gt; のチップから再構築されます。</target>
        </trans-unit>
        <trans-unit id="1ee4d8fb94bffa7e70baa538f9ff73a2b240bae8" translate="yes" xml:space="preserve">
          <source>After a feature release, you need to manage your maintenance branches.</source>
          <target state="translated">機能リリース後、メンテナンスブランチを管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="745f4d981edc1fae67ad7a65eae4ba7b48a51d0c" translate="yes" xml:space="preserve">
          <source>After a merge (initiated by &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;) stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with &lt;code&gt;git status&lt;/code&gt; and after fixing them manually in your working tree, you would stage the result as usual with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">競合のために（ &lt;code&gt;git merge&lt;/code&gt; または &lt;code&gt;git pull&lt;/code&gt; によって開始された）マージが停止した後、正常にマージされたパスは既にコミットされるようにステージングされており、競合したパスはマージされていない状態のままになります。まず、どのパスが &lt;code&gt;git status&lt;/code&gt; と競合しているかを確認する必要があります。作業ツリーで手動で修正した後、通常どおり &lt;code&gt;git add&lt;/code&gt; を使用して結果をステージングします。</target>
        </trans-unit>
        <trans-unit id="10502b7e8b48a8dee46e24b2019e9f5e468162f8" translate="yes" xml:space="preserve">
          <source>After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.</source>
          <target state="translated">パッチ失敗後(競合するパッチを適用しようとするなど)、ユーザーが手で適用した結果をインデックスファイルに格納。メールメッセージと現在のインデックスファイルから抽出したオーサリングとコミットログを使用してコミットを行い、続行します。</target>
        </trans-unit>
        <trans-unit id="5aad77091cab70cb7dbe8f7ee76657f4f26524af" translate="yes" xml:space="preserve">
          <source>After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: &lt;code&gt;!&lt;/code&gt; or its synonym &lt;code&gt;^&lt;/code&gt;). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec.</source>
          <target state="translated">パスが非除外パス仕様に一致すると、すべての除外パス仕様（マジックシグネチャ： &lt;code&gt;!&lt;/code&gt; またはその同義語 &lt;code&gt;^&lt;/code&gt; ）を通過します。一致する場合、パスは無視されます。非除外パス指定がない場合、除外は、パス指定なしで呼び出されたかのように結果セットに適用されます。</target>
        </trans-unit>
        <trans-unit id="e532f3552d5348fdc5f1bdf8915328d4f66e0e76" translate="yes" xml:space="preserve">
          <source>After a successful merge, update the files in the work tree with the result of the merge.</source>
          <target state="translated">マージが成功したら、マージの結果で作業ツリー内のファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="f915a9b6a0d7dfb5ab76e6778aa20c487e2e4897" translate="yes" xml:space="preserve">
          <source>After a while, you will have a number of branches, and despite the well chosen names you picked for each of them, you may forget what they are for, or what status they are in. To get a reminder of what changes are in a specific branch, use:</source>
          <target state="translated">しばらくすると、いくつかのブランチができ、それぞれに選んだ名前にもかかわらず、何のためのブランチなのか、どのような状態なのかを忘れてしまうかもしれません。特定のブランチに何が変更されたのかをリマインダーで確認するには</target>
        </trans-unit>
        <trans-unit id="a21e19052101e64abbac6635b64126db7893d400" translate="yes" xml:space="preserve">
          <source>After about 13 tests (in this case), it will output the commit id of the guilty commit. You can then examine the commit with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, find out who wrote it, and mail them your bug report with the commit id. Finally, run</source>
          <target state="translated">約13回のテスト（この場合）の後、有罪のコミットのコミットIDが出力されます。次に、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;を使用してコミットを調べ、誰が作成したかを確認し、コミットIDを付けてバグレポートをメールで送信します。最後に、実行します</target>
        </trans-unit>
        <trans-unit id="39d63924c0ad3d41ed7256461fb0f8cabfcd6c6b" translate="yes" xml:space="preserve">
          <source>After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated. This can be used to implement any repository wide cleanup tasks.</source>
          <target state="translated">他のすべての処理の後、少なくとも1つのrefが更新され、$git_dir/hooks/post-updateファイルが存在し、実行可能であれば、更新されたrefのリストと共にpost-updateが呼び出されます。これは、リポジトリ全体のクリーンアップタスクを実装するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="63a0e4603dcf967bd9664f6f3fe860af10658058" translate="yes" xml:space="preserve">
          <source>After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line for each successfully updated ref:</source>
          <target state="translated">すべての ref が更新された (あるいは更新を試みた)後、いずれかの ref の更新が成功し、 $GIT_DIR/hooks/post-receive ファイルが存在して実行可能であれば、パラメータなしで一度だけ呼び出されます。フックの標準入力は、更新に成功したrefごとに1行となります。</target>
        </trans-unit>
        <trans-unit id="df214f68fd91640cff1f194bcc254ff88f0793ee" translate="yes" xml:space="preserve">
          <source>After an attempt to merge stops with conflicts, show the commits on the history between two branches (i.e. the HEAD and the MERGE_HEAD) that modify the conflicted files and do not exist on all the heads being merged.</source>
          <target state="translated">マージが競合して停止した後、競合しているファイルを修正し、マージされるすべてのヘッドに存在しない 2 つのブランチ (すなわち HEAD と MERGE_HEAD)の間の履歴上のコミットを表示します。</target>
        </trans-unit>
        <trans-unit id="6855a297433d6efa583ee53f54f77288a36a4a3c" translate="yes" xml:space="preserve">
          <source>After committing, do not rebase or reset.</source>
          <target state="translated">コミット後はリベースやリセットをしないでください。</target>
        </trans-unit>
        <trans-unit id="a6cb6cc7533103000a5b985188fd777c705ca2f2" translate="yes" xml:space="preserve">
          <source>After configuring the remote, the following three commands will do the same thing:</source>
          <target state="translated">リモートを設定した後、以下の3つのコマンドで同じことができます。</target>
        </trans-unit>
        <trans-unit id="38c4cb5f4b09781b6323bee4b2e059f8adaf4c9f" translate="yes" xml:space="preserve">
          <source>After creating a packfile, print a line of data to &amp;lt;file&amp;gt; listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">packfileを作成したら、データ行を&amp;lt;file&amp;gt;に出力して、packfileのファイル名と、そのpackfileに書き込まれた各ブランチの最後のコミットをリストします。これらのコミットは &lt;code&gt;git pack-objects&lt;/code&gt; の呼び出し中にエッジポイントとして使用できるため、この情報は、オブジェクトセットの合計が4 GiBパックファイルの制限を超えるプロジェクトをインポートした後に役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="7eb0f12cc4760d99513845842d5818989334b063" translate="yes" xml:space="preserve">
          <source>After creating commits on a local branch, update the remote branch with your commits:</source>
          <target state="translated">ローカルブランチでコミットを作成した後、リモートブランチをコミットで更新します。</target>
        </trans-unit>
        <trans-unit id="d35d26dae79ab6ed7b967d8dc4249bb1ae7ac970" translate="yes" xml:space="preserve">
          <source>After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks.</source>
          <target state="translated">全てのハンクの運命を決定した後、選択されたハンクがあれば、その選択されたハンクでインデックスを更新します。</target>
        </trans-unit>
        <trans-unit id="1e8e9a912ee46d43880271748ff8431413ab88e6" translate="yes" xml:space="preserve">
          <source>After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.</source>
          <target state="translated">ファイルを記述する各行の後に、そのキャッシュエントリに関するデータを追加してください。これは、手動検査のために可能な限り多くの情報を表示することを意図しています;正確なフォーマットはいつでも変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8e22ef2eb3af8a0d0bd459bef01ed36acc704c46" translate="yes" xml:space="preserve">
          <source>After each step you can verify that</source>
          <target state="translated">各ステップの後、次のことを確認できます。</target>
        </trans-unit>
        <trans-unit id="715ed76b18490d22ccb88eb785651c8c2059a4a7" translate="yes" xml:space="preserve">
          <source>After editing the p4 change message, &lt;code&gt;git p4&lt;/code&gt; makes sure that the description really was changed by looking at the file modification time. This option disables that test.</source>
          <target state="translated">p4変更メッセージを編集した後、 &lt;code&gt;git p4&lt;/code&gt; はファイルの変更時間を確認して、説明が実際に変更されたことを確認します。このオプションはそのテストを無効にします。</target>
        </trans-unit>
        <trans-unit id="efcca15ec51efe3416c95ceb171efbcf6537ffe0" translate="yes" xml:space="preserve">
          <source>After examining those changes, Alice could merge the changes into her master branch:</source>
          <target state="translated">それらの変化を調べた後、アリスはその変化を自分のマスターブランチにマージすることができました。</target>
        </trans-unit>
        <trans-unit id="6432877f7b94f7bff8d7c5100d32a9aa8ff2a2de" translate="yes" xml:space="preserve">
          <source>After fast-import terminates the frontend will need to do &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; to remove the dummy branch.</source>
          <target state="translated">高速インポートが終了した後、フロントエンドは &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; を実行してダミーのブランチを削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="7ccac6fd0d710a221bb8914388317ad9efd2c0ef" translate="yes" xml:space="preserve">
          <source>After finding out a common ancestor commit, the second step is this:</source>
          <target state="translated">共通の先祖コミットを見つけたら、次はこれです。</target>
        </trans-unit>
        <trans-unit id="a0f8226e38e0606c48953eb6013c6b55022869a5" translate="yes" xml:space="preserve">
          <source>After having marked revisions as good or bad, issue the following command to show what has been done so far:</source>
          <target state="translated">リビジョンに良し悪しをつけた後、以下のコマンドを実行して、これまでに何が行われたかを表示します。</target>
        </trans-unit>
        <trans-unit id="e80bd551ece50cfc5fc850da2031735d0adb9a3e" translate="yes" xml:space="preserve">
          <source>After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will let you go back to where you were, but it will discard your local changes, which you do not want. &lt;code&gt;git reset --merge&lt;/code&gt; keeps your local changes.</source>
          <target state="translated">マージの結果を調べた後、他のブランチでの変更が不十分であることがわかる場合があります。 &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; を実行すると、以前の場所に戻ることができますが、ローカルの変更は破棄されますが、これは不要です。 &lt;code&gt;git reset --merge&lt;/code&gt; はローカルの変更を保持します。</target>
        </trans-unit>
        <trans-unit id="6ff21b83188a31a6207ce191dc61f50a691f861b" translate="yes" xml:space="preserve">
          <source>After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob&amp;rsquo;s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a &quot;pull&quot;, and then finally unstash her work-in-progress on top of the resulting history.</source>
          <target state="translated">ボブが何をしたかを調べた後、急を要することが何もない場合、アリスはボブから引っ張らずに仕事を続けることに決めるかもしれません。ボブの履歴にアリスがすぐに必要とするものがある場合、アリスは、進行中の作業を最初に隠し、「プル」し、最後に結果の履歴の上に進行中の作業を展開することを選択できます。</target>
        </trans-unit>
        <trans-unit id="03d5abbf7626dec9ccf7afab1dc07b8795265376" translate="yes" xml:space="preserve">
          <source>After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.</source>
          <target state="translated">選択した後、空行で答えて、インデックス内の選択されたパスの作業ツリーファイルの内容をステージングします。</target>
        </trans-unit>
        <trans-unit id="dcd3f26f69bbd1d1c0b392e2f4a4b9463da76a66" translate="yes" xml:space="preserve">
          <source>After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run &lt;code&gt;git prune-packed&lt;/code&gt; to remove redundant loose object files.</source>
          <target state="translated">梱包後に、新しく作成されたパックによって既存の一部のパックが冗長になる場合は、冗長パックを削除します。また、 &lt;code&gt;git prune-packed&lt;/code&gt; を実行して、冗長なルーズオブジェクトファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="6310edfcb7521ec31d9b130cb6ae6f20fea23aff" translate="yes" xml:space="preserve">
          <source>After performing a merge, the original file with conflict markers can be saved as a file with a &lt;code&gt;.orig&lt;/code&gt; extension. If this variable is set to &lt;code&gt;false&lt;/code&gt; then this file is not preserved. Defaults to &lt;code&gt;true&lt;/code&gt; (i.e. keep the backup files).</source>
          <target state="translated">マージを実行した後、競合マーカーのある元のファイルを &lt;code&gt;.orig&lt;/code&gt; 拡張子の付いたファイルとして保存できます。この変数が &lt;code&gt;false&lt;/code&gt; に設定されている場合、このファイルは保持されません。デフォルトは &lt;code&gt;true&lt;/code&gt; です（つまり、バックアップファイルを保持します）。</target>
        </trans-unit>
        <trans-unit id="df243e176ddfa0cca8db617f9402400e5f7c60ba" translate="yes" xml:space="preserve">
          <source>After pushing your work to &lt;code&gt;mytree&lt;/code&gt;, you can use &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to prepare a &quot;please pull&quot; request message to send to Linus:</source>
          <target state="translated">作業を &lt;code&gt;mytree&lt;/code&gt; にプッシュした後、&lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt;を使用して、「プルしてください」リクエストメッセージを準備してLinusに送信できます。</target>
        </trans-unit>
        <trans-unit id="8b7b502730a3874da935b609ad110273aca4a8d0" translate="yes" xml:space="preserve">
          <source>After receiving the capability advertisement, a client can then issue a request to select the command it wants with any particular capabilities or arguments. There is then an optional section where the client can provide any command specific parameters or queries. Only a single command can be requested at a time.</source>
          <target state="translated">ケイパビリティアドバタイズメントを受け取った後、クライアントはリクエストを発行して、特定のケイパビリティや引数を持つコマンドを選択することができます。オプションのセクションでは、クライアントがコマンド固有のパラメータやクエリを提供することができます。一度にリクエストできるコマンドは1つだけです。</target>
        </trans-unit>
        <trans-unit id="d906effb7cd99af8f81c132d80d9dfe4320f7472" translate="yes" xml:space="preserve">
          <source>After receiving the pack from the client, &lt;code&gt;receive-pack&lt;/code&gt; may produce no output (if &lt;code&gt;--quiet&lt;/code&gt; was specified) while processing the pack, causing some networks to drop the TCP connection. With this option set, if &lt;code&gt;receive-pack&lt;/code&gt; does not transmit any data in this phase for &lt;code&gt;receive.keepAlive&lt;/code&gt; seconds, it will send a short keepalive packet. The default is 5 seconds; set to 0 to disable keepalives entirely.</source>
          <target state="translated">クライアントからパックを受信した後、packの処理中に &lt;code&gt;receive-pack&lt;/code&gt; が出力を生成せず（ &lt;code&gt;--quiet&lt;/code&gt; が指定されている場合）、一部のネットワークでTCP接続が切断されることがあります。このオプションを設定すると、 &lt;code&gt;receive-pack&lt;/code&gt; がこのフェーズで &lt;code&gt;receive.keepAlive&lt;/code&gt; 秒間データを送信しない場合、短いキープアライブパケットが送信されます。デフォルトは5秒です。キープアライブを完全に無効にするには、0に設定します。</target>
        </trans-unit>
        <trans-unit id="0db356d4df77c5c16acb15ad22a97c7ea6f2c6df" translate="yes" xml:space="preserve">
          <source>After resolving conflicts and staging the result, &lt;code&gt;git ls-files -u&lt;/code&gt; would stop mentioning the conflicted path. When you are done, run &lt;code&gt;git commit&lt;/code&gt; to finally record the merge:</source>
          <target state="translated">競合を解決して結果をステージングした後、 &lt;code&gt;git ls-files -u&lt;/code&gt; は競合するパスの言及を停止します。完了したら、 &lt;code&gt;git commit&lt;/code&gt; を実行して、最終的にマージを記録します。</target>
        </trans-unit>
        <trans-unit id="8c30281e1be411a0e33e0f09c24d7eee56dd1d4d" translate="yes" xml:space="preserve">
          <source>After resolving the conflict in the obvious way (but before updating the index), the diff will look like:</source>
          <target state="translated">明らかな方法で競合を解決した後(ただしインデックスを更新する前)、diffは次のようになります。</target>
        </trans-unit>
        <trans-unit id="60011229c2b6e9f4d0205ce31a17f85a92fcdccf" translate="yes" xml:space="preserve">
          <source>After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with</source>
          <target state="translated">競合を手動で解決し、希望する解決方法でインデックスを更新した後で</target>
        </trans-unit>
        <trans-unit id="4f17f667d528a937d15361797e46f1a4fea1bdf2" translate="yes" xml:space="preserve">
          <source>After rewinding, the commit structure should look like this:</source>
          <target state="translated">巻き戻した後のコミット構造は以下のようになるはずです。</target>
        </trans-unit>
        <trans-unit id="b66a5176477ad671c21413d345a1019b22e18ec7" translate="yes" xml:space="preserve">
          <source>After running &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; to update the index entry, you can use &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; to check the contents out of the index to the working tree. Alternatively, using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; and specifying a commit with &lt;code&gt;--source&lt;/code&gt;, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</source>
          <target state="translated">&lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; を実行してインデックスエントリを更新した後、&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;を使用して、インデックスからコンテンツを作業ツリーにチェックアウトできます。または、&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;を使用して &lt;code&gt;--source&lt;/code&gt; でコミットを指定すると、パスの内容をコミットからインデックスと作業ツリーに一度にコピーできます。</target>
        </trans-unit>
        <trans-unit id="18afdf4deff269ec9f25d6d6aebe21c179f08972" translate="yes" xml:space="preserve">
          <source>After running this &lt;code&gt;git push&lt;/code&gt; on the &lt;code&gt;satellite&lt;/code&gt; machine, you would ssh into the &lt;code&gt;mothership&lt;/code&gt; and run &lt;code&gt;git merge&lt;/code&gt; there to complete the emulation of &lt;code&gt;git pull&lt;/code&gt; that were run on &lt;code&gt;mothership&lt;/code&gt; to pull changes made on &lt;code&gt;satellite&lt;/code&gt;.</source>
          <target state="translated">この実行した後 &lt;code&gt;git push&lt;/code&gt; の &lt;code&gt;satellite&lt;/code&gt; マシンを、あなたはにsshを考え &lt;code&gt;mothership&lt;/code&gt; と実行 &lt;code&gt;git merge&lt;/code&gt; エミュレーションが完了するまでに &lt;code&gt;git pull&lt;/code&gt; 上で実行された &lt;code&gt;mothership&lt;/code&gt; で行った変更プルに &lt;code&gt;satellite&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de248d3c434336170b313b4a606fae76271119ac" translate="yes" xml:space="preserve">
          <source>After seeing a conflict, you can do two things:</source>
          <target state="translated">葛藤を見た後にできることは2つ。</target>
        </trans-unit>
        <trans-unit id="f8a8b60b2d146b020baf249114d8bfb4056df2e3" translate="yes" xml:space="preserve">
          <source>After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location.</source>
          <target state="translated">relative-marks を指定すると、--import-marks=や --export-marks=で指定したパスは、現在のリポジトリの内部ディレクトリからの相対パスとなります。git-fast-import では、これは .git/info/fast-import ディレクトリからの相対パスということになります。しかし、他のインポートツールでは別の場所を使うかもしれません。</target>
        </trans-unit>
        <trans-unit id="55c65fc108282e758fad76a3e65ea8f48110fd1a" translate="yes" xml:space="preserve">
          <source>After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to &lt;code&gt;git commit&lt;/code&gt;. When pathnames are given, the command makes a commit that only records the changes made to the named paths:</source>
          <target state="translated">多くのファイルへの変更をステージングした後、パス名を &lt;code&gt;git commit&lt;/code&gt; に与えることにより、変更が記録される順序を変更できます。パス名が指定されると、コマンドは名前付きパスに加えられた変更のみを記録するコミットを行います。</target>
        </trans-unit>
        <trans-unit id="e72be6c76fa86af29190b1a1f88fe08f999420ad" translate="yes" xml:space="preserve">
          <source>After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when &quot;git bisect skip&quot; was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009).</source>
          <target state="translated">スキップアルゴリズムでは)ステップ7)の後に、2回目のコミットがスキップされたかどうかをチェックして、スキップされていなければそれを返すことができました。そして実際には、これがGitバージョン1.5.4(2008年2月1日リリース)で「git bisect skip」が開発されたときから、Gitバージョン1.6.4(2009年7月29日リリース)までの間、私たちが使っていたアルゴリズムです。</target>
        </trans-unit>
        <trans-unit id="8ebae7c6dbdbd052d8e1deddf2741dfd39e2c5b6" translate="yes" xml:space="preserve">
          <source>After submitting, sync this named branch instead of the default p4/master. See the &quot;Sync options&quot; section above for more information.</source>
          <target state="translated">送信後、デフォルトのp4/masterではなく、この名前のブランチを同期します。詳細は上記の「同期オプション」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="56b0b049063f0a3e5fb48dd65396ec13b42da44e" translate="yes" xml:space="preserve">
          <source>After that is done, you should be able to compose email as you otherwise would (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), and the patches will not be mangled.</source>
          <target state="translated">それが終わったら、他の方法（カット+ペースト、 &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; など）と同じようにメールを作成でき、パッチが破損することはありません。</target>
        </trans-unit>
        <trans-unit id="bfac36870999dd7fd482f2000fa5fc0ffd3ce594" translate="yes" xml:space="preserve">
          <source>After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit.</source>
          <target state="translated">その後、新しいブランチでいつものようにバイセクティングを始めれば、最終的には最初の悪いコミットを見つけることができるはずです。</target>
        </trans-unit>
        <trans-unit id="35f073b8aaf7a7d573c425aa250957facb3adf5b" translate="yes" xml:space="preserve">
          <source>After that, the easiest way to record all removals, additions, and modifications in the working tree is:</source>
          <target state="translated">その後、作業ツリーにすべての削除、追加、変更を記録する最も簡単な方法は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="37ec20c881539f18de6028bfbfa7896bacec3155" translate="yes" xml:space="preserve">
          <source>After that, you can go back to what you were working on with &lt;code&gt;git stash pop&lt;/code&gt;:</source>
          <target state="translated">その後、 &lt;code&gt;git stash pop&lt;/code&gt; で行っていた作業に戻ることができます。</target>
        </trans-unit>
        <trans-unit id="a18484e36aeec06b4dafe8bfc4dc2214df9ad775" translate="yes" xml:space="preserve">
          <source>After the basics are established, additional command information can be sent to Trace2 as it is discovered.</source>
          <target state="translated">基本が確立された後、追加のコマンド情報を発見次第、Trace2に送信することができます。</target>
        </trans-unit>
        <trans-unit id="9e00cd4b44746238e1913ce6a929735926105a52" translate="yes" xml:space="preserve">
          <source>After the clone is created, initialize and clone submodules within based on the provided pathspec. If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has &lt;code&gt;submodule.active&lt;/code&gt; set to the provided pathspec, or &quot;.&quot; (meaning all submodules) if no pathspec is provided.</source>
          <target state="translated">クローンが作成されたら、提供されたパス仕様に基づいてサブモジュールを初期化およびクローンします。pathspecを指定しない場合、すべてのサブモジュールが初期化され、複製されます。このオプションは、複数のエントリで構成されるパス仕様に対して複数回指定できます。結果のクローンには、 &lt;code&gt;submodule.active&lt;/code&gt; が、指定されたパス仕様または「。」に設定されています。（すべてのサブモジュールを意味します）pathspecが提供されていない場合。</target>
        </trans-unit>
        <trans-unit id="512c768beb6f564041f676bad06ef4ee2a1c558f" translate="yes" xml:space="preserve">
          <source>After the clone, a plain &lt;code&gt;git fetch&lt;/code&gt; without arguments will update all the remote-tracking branches, and a &lt;code&gt;git pull&lt;/code&gt; without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when &quot;--single-branch&quot; is given; see below).</source>
          <target state="translated">クローンの後、引数なしの単純な &lt;code&gt;git fetch&lt;/code&gt; はすべてのリモート追跡ブランチを更新し、引数なしの &lt;code&gt;git pull&lt;/code&gt; はさらに、リモートマスターブランチを現在のマスターブランチにマージします（存在する場合）（これは「--single -branch」が指定されています。以下を参照してください）。</target>
        </trans-unit>
        <trans-unit id="5cd7d7a65c5ebccd7e68c5c66967ea09b43d6139" translate="yes" xml:space="preserve">
          <source>After the last section, you should know how to manage topics. In general, you will not be the only person working on the project, so you will have to share your work.</source>
          <target state="translated">最後の項目が終わったら、トピックの管理方法を知っておきましょう。一般的には、自分だけが作業をしているわけではないので、自分の作業を共有する必要があります。</target>
        </trans-unit>
        <trans-unit id="d4845263a9667982d51c2722039eed2001af73b3" translate="yes" xml:space="preserve">
          <source>After this test merge, there are two ways to continue your work on the topic. The easiest is to build on top of the test merge commit &lt;code&gt;+&lt;/code&gt;, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the upstream might have been advanced since the test merge &lt;code&gt;+&lt;/code&gt;, in which case the final commit graph would look like this:</source>
          <target state="translated">このテストマージ後、トピックに関する作業を続行するには2つの方法があります。最も簡単なのは、テストマージコミット &lt;code&gt;+&lt;/code&gt; の上に構築することです。トピックブランチでの作業が最終的に準備ができたら、トピックブランチをマスターにプルするか、アップストリームにプルするよう依頼します。ただし、その時点までに、テストマージ &lt;code&gt;+&lt;/code&gt; 以降、マスターまたはアップストリームが進んでいる可能性があります。その場合、最終的なコミットグラフは次のようになります。</target>
        </trans-unit>
        <trans-unit id="764e78b04901ecf447ad9f08fb14a4d7a3784873" translate="yes" xml:space="preserve">
          <source>After this three-way merge, the local modifications are &lt;code&gt;not&lt;/code&gt; registered in your index file, so &lt;code&gt;git diff&lt;/code&gt; would show you what changes you made since the tip of the new branch.</source>
          <target state="translated">この3者間マージの後、ローカルの変更はインデックスファイルに登録され &lt;code&gt;not&lt;/code&gt; ため、 &lt;code&gt;git diff&lt;/code&gt; は新しいブランチの先端以降に行った変更を表示します。</target>
        </trans-unit>
        <trans-unit id="9aab9481201d40d0fe77311ee6889968b015c0cc" translate="yes" xml:space="preserve">
          <source>After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length.</source>
          <target state="translated">パックを検証した後、パックに含まれるオブジェクトのリストとデルタチェーンの長さのヒストグラムを表示します。</target>
        </trans-unit>
        <trans-unit id="9b8cdc248305abd7fd3ad025c5cea93360a62f47" translate="yes" xml:space="preserve">
          <source>After working in the wrong branch, switching to the correct branch would be done using:</source>
          <target state="translated">間違ったブランチで作業した後、正しいブランチに切り替えるには、次のような方法があります。</target>
        </trans-unit>
        <trans-unit id="eb228e2496a61023caca1aea4a6e82c2396eddae" translate="yes" xml:space="preserve">
          <source>After working on the &lt;code&gt;topic&lt;/code&gt; branch created with &lt;code&gt;git switch -c
topic origin/master&lt;/code&gt;, the history of remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt; may have been rewound and rebuilt, leading to a history of this shape:</source>
          <target state="translated">&lt;code&gt;git switch -c topic origin/master&lt;/code&gt; で作成された &lt;code&gt;topic&lt;/code&gt; ブランチで作業した後、リモートトラッキングブランチ &lt;code&gt;origin/master&lt;/code&gt; の履歴が巻き戻され、再構築された可能性があります。</target>
        </trans-unit>
        <trans-unit id="1c12d864e4ce5bf45abb0028f5de0df25bacff49" translate="yes" xml:space="preserve">
          <source>After working some more in the original repository, you can create an incremental bundle to update the other repository:</source>
          <target state="translated">元のリポジトリでもう少し作業した後、インクリメンタルバンドルを作成して他のリポジトリを更新することができます。</target>
        </trans-unit>
        <trans-unit id="7c5cdbcbfaa82437e4a65c5f716c041276984b11" translate="yes" xml:space="preserve">
          <source>After writing a crash report fast-import will close the current packfile and export the marks table. This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed. The modified branches and tags are not updated during a crash, as the import did not complete successfully. Branch and tag information can be found in the crash report and must be applied manually if the update is needed.</source>
          <target state="translated">クラッシュレポートを書いた後、fast-import は現在の packfile を閉じ、マークテーブルをエクスポートします。これにより、フロントエンド開発者はリポジトリの状態を検査し、クラッシュしたポイントからインポートを再開することができます。インポートが正常に完了しなかったため、クラッシュ時に変更されたブランチとタグは更新されません。ブランチとタグの情報はクラッシュレポートで確認でき、更新が必要な場合は手動で適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5c0e0972bba351246b0cebcda509c3b6e9fe7def" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates and merge them into your own work.</source>
          <target state="translated">リポジトリをクローンして、自分の変更をいくつかコミットした後、元のリポジトリの更新をチェックして、自分の作品にマージしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="11b2964f5fca0a040b3f9e0cd2999fe0e6cf0437" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates.</source>
          <target state="translated">リポジトリをクローンして、自分の変更点をいくつかコミットした後、元のリポジトリが更新されていないかチェックしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="5c1b426ddf419243558839a9a55a74c0218324ad" translate="yes" xml:space="preserve">
          <source>After you mastered the basic concepts, you can come back to this page to learn what commands Git offers. You can learn more about individual Git commands with &quot;git help command&quot;. &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt; manual page gives you an overview of the command-line command syntax.</source>
          <target state="translated">基本的な概念をマスターしたら、このページに戻って、Gitが提供するコマンドを学ぶことができます。個々のGitコマンドについて詳しくは、「git help command」をご覧ください。&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]の&lt;/a&gt;マニュアルページでは、コマンドラインコマンド構文の概要を説明しています。</target>
        </trans-unit>
        <trans-unit id="b3cf4e045979c169751c6df0015d31c55a03d7ee" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;re done, start up &lt;code&gt;gitk --all&lt;/code&gt; to see graphically what the history looks like. Notice that &lt;code&gt;mybranch&lt;/code&gt; still exists, and you can switch to it, and continue to work with it if you want to. The &lt;code&gt;mybranch&lt;/code&gt; branch will not contain the merge, but next time you merge it from the &lt;code&gt;master&lt;/code&gt; branch, Git will know how you merged it, so you&amp;rsquo;ll not have to do &lt;code&gt;that&lt;/code&gt; merge again.</source>
          <target state="translated">完了したら、 &lt;code&gt;gitk --all&lt;/code&gt; を起動して、履歴がどのように見えるかをグラフィカルに表示します。 &lt;code&gt;mybranch&lt;/code&gt; がまだ存在していることに注意してください。mybranchに切り替えて、必要に応じて引き続き操作できます。 &lt;code&gt;mybranch&lt;/code&gt; ブランチがマージが含まれませんが、次回からそれをマージ &lt;code&gt;master&lt;/code&gt; あなたがしなければならないだろうので、ブランチ、Gitは、あなたがそれをマージ方法を知っている &lt;code&gt;that&lt;/code&gt; を再度マージを。</target>
        </trans-unit>
        <trans-unit id="c0a021ce8c26fc96dbae55d24cd95f42b33ecba6" translate="yes" xml:space="preserve">
          <source>Afterwards Git sends a list of &quot;key=value&quot; pairs terminated with a flush packet. The list will contain at least the filter command (based on the supported capabilities) and the pathname of the file to filter relative to the repository root. Right after the flush packet Git sends the content split in zero or more pkt-line packets and a flush packet to terminate content. Please note, that the filter must not send any response before it received the content and the final flush packet. Also note that the &quot;value&quot; of a &quot;key=value&quot; pair can contain the &quot;=&quot; character whereas the key would never contain that character.</source>
          <target state="translated">その後、Git は &quot;key=value&quot; ペアのリストをフラッシュパケットで終わらせて送信します。このリストには、少なくとも(サポートされている機能に基づいて)フィルタリングコマンドと、リポジトリのルートからの相対的なフィルタリング対象のファイルのパス名が含まれます。フラッシュパケットの直後に、Git はコンテンツを 0 個以上の pkt-line パケットに分割し、フラッシュパケットでコンテンツを終了させます。注意してほしいのは、フィルタはコンテンツと最終的なフラッシュパケットを受信する前にレスポンスを送ってはいけないということです。また、&quot;key=value&quot; のペアの &quot;value&quot; には &quot;=&quot; 文字を含めることができますが、&quot;key&quot; にはそのような文字は含まれません。</target>
        </trans-unit>
        <trans-unit id="08fb4f0b833d93afae381ddbd32b2e731f88bbea" translate="yes" xml:space="preserve">
          <source>Again, because this is a common operation, you can also just shorthand it with</source>
          <target state="translated">繰り返しになりますが、これは一般的な操作なので</target>
        </trans-unit>
        <trans-unit id="2a17673033ec7dbc230aa6a7992e711b3fbc3d4a" translate="yes" xml:space="preserve">
          <source>Again, normally you&amp;rsquo;d never actually do this by hand. There is a helpful script called &lt;code&gt;git commit&lt;/code&gt; that will do all of this for you. So you could have just written &lt;code&gt;git commit&lt;/code&gt; instead, and it would have done the above magic scripting for you.</source>
          <target state="translated">繰り返しますが、通常、これを実際に手動で行うことはありません。これをすべて &lt;code&gt;git commit&lt;/code&gt; という便利なスクリプトがあります。したがって、代わりに &lt;code&gt;git commit&lt;/code&gt; を記述すれば、上記の魔法のスクリプトが実行されます。</target>
        </trans-unit>
        <trans-unit id="afde498ff4cd811d74693c0df59474ecda94165e" translate="yes" xml:space="preserve">
          <source>Again, this can all be simplified with</source>
          <target state="translated">繰り返しになりますが、これはすべて</target>
        </trans-unit>
        <trans-unit id="b9b1fee6e50d3dc98fed5593a8e8c0ed94635339" translate="yes" xml:space="preserve">
          <source>Again, updating A with this commit will fast-forward and your push will be accepted.</source>
          <target state="translated">繰り返しになりますが、このコミットでAを更新すると早送りされ、あなたのプッシュが受け入れられるようになります。</target>
        </trans-unit>
        <trans-unit id="b1bfbc3378c5615b3a3120f32e2b4f7a040c60bb" translate="yes" xml:space="preserve">
          <source>Again, you should never do this to a commit that may already have been merged into another branch; use &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; instead in that case.</source>
          <target state="translated">繰り返しますが、すでに別のブランチにマージされている可能性のあるコミットに対してこれを行うべきではありません。使用&lt;a href=&quot;git-revert&quot;&gt;のgit-復帰[1]の&lt;/a&gt;代わりに、その場合には。</target>
        </trans-unit>
        <trans-unit id="4ad4cd921bb660f6346bf34bcf03d35af1d89b1f" translate="yes" xml:space="preserve">
          <source>Aggregating short options</source>
          <target state="translated">ショートオプションの集計</target>
        </trans-unit>
        <trans-unit id="b46eb2e49d59fe40f45432cfc2d93b9f3ec1b6f6" translate="yes" xml:space="preserve">
          <source>Aggressive</source>
          <target state="translated">Aggressive</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="f18c0f421eb67bfb50f4d3af9083503fd4868a13" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt;. RFC means &quot;Request For Comments&quot;; use this when sending an experimental patch for discussion rather than application.</source>
          <target state="translated">&lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt; のエイリアス。RFCは「Request For Comments」を意味します。アプリケーションではなく実験的なパッチをディスカッションに送信する場合に使用します。</target>
        </trans-unit>
        <trans-unit id="33cafd3b08f6afce156de29f77fc37a32f1f3369" translate="yes" xml:space="preserve">
          <source>Alias for a --pretty= format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. Any aliases defined here can be used just as the built-in pretty formats could. For example, running &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; would cause the invocation &lt;code&gt;git log --pretty=changelog&lt;/code&gt; to be equivalent to running &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt;. Note that an alias with the same name as a built-in format will be silently ignored.</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;git-log [1]で&lt;/a&gt;指定されている--pretty =フォーマット文字列のエイリアス。ここで定義されたエイリアスは、組み込みのプリティ形式と同じように使用できます。たとえば、 &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; すると、呼び出し &lt;code&gt;git log --pretty=changelog&lt;/code&gt; が &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt; を実行するのと同じになります。組み込みフォーマットと同じ名前のエイリアスは警告なしで無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d1b325e842f25a822c4b269ff141ef39919c475" translate="yes" xml:space="preserve">
          <source>Alice can peek at what Bob did without merging first, using the &quot;fetch&quot; command; this allows Alice to inspect what Bob did, using a special symbol &quot;FETCH_HEAD&quot;, in order to determine if he has anything worth pulling, like this:</source>
          <target state="translated">アリスは &quot;fetch&quot; コマンドを使って、最初にマージせずにボブが何をしたかを覗くことができます。</target>
        </trans-unit>
        <trans-unit id="8e66fd3894cd9fabc7340a32ad3678d949571b95" translate="yes" xml:space="preserve">
          <source>Alice may want to view what both of them did since they forked. She can use three-dot form instead of the two-dot form:</source>
          <target state="translated">アリスは二人がフォークしてから何をしたのかを見たいのかもしれません。彼女は2ドットの代わりに3ドットのフォームを使うことができます。</target>
        </trans-unit>
        <trans-unit id="f40eaaa16860011566dbddc8353ce4cd5b34fb54" translate="yes" xml:space="preserve">
          <source>All 4-byte numbers are in network order.</source>
          <target state="translated">4バイトの数字はすべてネットワーク順になっています。</target>
        </trans-unit>
        <trans-unit id="099269695c58af639142bdae5a91d1e49c0c2c94" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CGI&lt;/code&gt; environment variables are available to each of the hooks invoked by the &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="translated">すべての &lt;code&gt;CGI&lt;/code&gt; 環境変数は、 &lt;code&gt;git-receive-pack&lt;/code&gt; によって呼び出される各フックで使用できます。</target>
        </trans-unit>
        <trans-unit id="f866a82b5ea8dc3929c4ad04564d5c3ed0ee42d8" translate="yes" xml:space="preserve">
          <source>All Trace2 API functions send a message to all of the active Trace2 Targets. This section describes the set of available messages.</source>
          <target state="translated">すべての Trace2 API 関数は、すべてのアクティブな Trace2 Targets にメッセージを送信します。ここでは、利用可能なメッセージのセットについて説明します。</target>
        </trans-unit>
        <trans-unit id="8567b1f7f97dea5e233c49b40ba1a9668558e4c8" translate="yes" xml:space="preserve">
          <source>All URLs are normalized before attempting any matching (the password part, if embedded in the URL, is always ignored for matching purposes) so that equivalent URLs that are simply spelled differently will match properly. Environment variable settings always override any matches. The URLs that are matched against are those given directly to Git commands. This means any URLs visited as a result of a redirection do not participate in matching.</source>
          <target state="translated">すべての URL は、マッチングを試みる前に正規化されます (URL にパスワードの部分が埋め込まれている場合は、マッチングのために常に無視されます)。環境変数の設定は常にマッチを上書きします。マッチの対象となる URL は、Git コマンドに直接渡されたものです。つまり、リダイレクトの結果として訪問された URL はマッチングに参加しないということです。</target>
        </trans-unit>
        <trans-unit id="05f6595fa2f42cca20a6fe38ba56a9a1d90610fc" translate="yes" xml:space="preserve">
          <source>All actions except for those that list all available projects, in whatever form, require this parameter.</source>
          <target state="translated">利用可能なすべてのプロジェクトをリストアップするアクション以外のすべてのアクションは、どのような形式であっても、このパラメータが必要です。</target>
        </trans-unit>
        <trans-unit id="1aaff790885e322791dd026d468d21215c97d5ed" translate="yes" xml:space="preserve">
          <source>All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">分割インデックスのすべての変更は、分割インデックスのエントリ数がsplitIndex.maxPercentChange構成変数（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）で指定されたレベルに達すると、共有インデックスファイルにプッシュバックされます。</target>
        </trans-unit>
        <trans-unit id="2ee4593d03a3fe3f61740d3dea48d16adb304aaa" translate="yes" xml:space="preserve">
          <source>All changes made by commits in the current branch but that are not in &amp;lt;upstream&amp;gt; are saved to a temporary area. This is the same set of commits that would be shown by &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt;; or by &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt;, if &lt;code&gt;--fork-point&lt;/code&gt; is active (see the description on &lt;code&gt;--fork-point&lt;/code&gt; below); or by &lt;code&gt;git log HEAD&lt;/code&gt;, if the &lt;code&gt;--root&lt;/code&gt; option is specified.</source>
          <target state="translated">現在のブランチのコミットによって行われたが、&amp;lt;upstream&amp;gt;にないすべての変更は、一時領域に保存されます。これは、 &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt; で表示されるのと同じ一連のコミットです。またはによって &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt; 、場合 &lt;code&gt;--fork-point&lt;/code&gt; （上の説明を参照アクティブである &lt;code&gt;--fork-point&lt;/code&gt; 以下）。 &lt;code&gt;--root&lt;/code&gt; オプションが指定されている場合は、 &lt;code&gt;git log HEAD&lt;/code&gt; によって。</target>
        </trans-unit>
        <trans-unit id="4bdf69f9f9acea0027f5883fae412fef01ef415d" translate="yes" xml:space="preserve">
          <source>All changes to the submodule&amp;rsquo;s work tree will be ignored, only committed differences between the HEAD of the submodule and its recorded state in the superproject are taken into account.</source>
          <target state="translated">サブモジュールの作業ツリーに対するすべての変更は無視され、サブモジュールのHEADとスーパープロジェクトでのその記録された状態との間のコミットされた差異のみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="0078bf2eb8fdaed52c7a49142c07f612f6194ca3" translate="yes" xml:space="preserve">
          <source>All commands except clone accept these options.</source>
          <target state="translated">clone以外のすべてのコマンドは、これらのオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="747ced70d2f3d8a9f580e20c513a115bf4ca8d06" translate="yes" xml:space="preserve">
          <source>All commits in the simplified history are shown.</source>
          <target state="translated">簡易履歴にあるすべてのコミットを表示しています。</target>
        </trans-unit>
        <trans-unit id="b7857a43f974cc0cc16fc43991167acda1bdb92d" translate="yes" xml:space="preserve">
          <source>All commits that are walked are included.</source>
          <target state="translated">歩いているコミットはすべて含まれています。</target>
        </trans-unit>
        <trans-unit id="d8c8c004ab3e327bb23a0e1cb06bdc4ffe16dbfd" translate="yes" xml:space="preserve">
          <source>All communication is done using packet-line framing, just as in v1. See &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; and &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; for more information.</source>
          <target state="translated">すべての通信は、v1と同様に、パケットラインフレーミングを使用して行われます。詳細については、 &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; および &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7c3a301219274de5dd57371abee3ab5a5312cbb7" translate="yes" xml:space="preserve">
          <source>All configuration variables can also be overridden for a specific method of access. Valid method names are &quot;ext&quot; (for SSH access) and &quot;pserver&quot;. The following example configuration would disable pserver access while still allowing access over SSH.</source>
          <target state="translated">すべての設定変数は、特定のアクセス方法のためにオーバーライドすることもできます。有効なメソッド名は &quot;ext&quot; (SSH アクセス用)と &quot;pserver&quot; です。以下の設定例では、pserver へのアクセスを無効にしながらも SSH 経由でのアクセスを許可しています。</target>
        </trans-unit>
        <trans-unit id="59ca4fe2d0fe1a800f4976e6f9f37c5b67ee4941" translate="yes" xml:space="preserve">
          <source>All files from the branching point are added to a branch even if never added in CVS.</source>
          <target state="translated">CVSでは一度も追加されていなくても、分岐点からのすべてのファイルがブランチに追加されます。</target>
        </trans-unit>
        <trans-unit id="f2751ce2c6eef82a246aaca1478ee0944abee964" translate="yes" xml:space="preserve">
          <source>All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">リスト内のファイル拡張子に一致するすべてのファイルは、ラージファイルシステムによって処理されます。拡張子の前にを付けないでください &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9eed6a91320d25f6961ad95b2f4c0551182ac97" translate="yes" xml:space="preserve">
          <source>All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">しきい値を超える圧縮サイズを持つすべてのファイルは、大きなファイルシステムによって処理されます。このオプションを使用すると、クローン/同期処理が遅くなる可能性があります。デフォルトでは、しきい値はバイト単位で定義されています。単位を変更するには、サフィックス k、m、または g を追加します。</target>
        </trans-unit>
        <trans-unit id="cba8238b26241037a2d523c9dbfd57c6ef21fd9c" translate="yes" xml:space="preserve">
          <source>All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">しきい値を超える非圧縮サイズのファイルはすべて、ラージファイルシステムによって処理されます。デフォルトでは、しきい値はバイト単位で定義されています。単位を変更するには、接尾辞 k,m,g を追加します。</target>
        </trans-unit>
        <trans-unit id="5faba2ec0a1d011ac70519fe6631987cdc41a2b9" translate="yes" xml:space="preserve">
          <source>All gitcvs variables except for &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; can also be specified as &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; (where &lt;code&gt;access_method&lt;/code&gt; is one of &quot;ext&quot; and &quot;pserver&quot;) to make them apply only for the given access method.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; と &lt;code&gt;gitcvs.allBinary&lt;/code&gt; を除くすべてのgitcvs変数を &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; として指定することもできます（ &lt;code&gt;access_method&lt;/code&gt; は「ext」と「pserver」のいずれかです）。これらは、指定されたアクセスメソッドにのみ適用されます。 。</target>
        </trans-unit>
        <trans-unit id="e0e3bbc643fcf0e6f476c9a1c5f8183263c2a18a" translate="yes" xml:space="preserve">
          <source>All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.</source>
          <target state="translated">リストされたすべての参照は、リモートリポジトリから削除されます。これは、すべての参照の前にコロンを付けるのと同じです。</target>
        </trans-unit>
        <trans-unit id="0a04df7dc83d3748d4d9902845dfe236dbda3335" translate="yes" xml:space="preserve">
          <source>All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose.</source>
          <target state="translated">すべてのオブジェクトは、その内容の SHA-1 ハッシュによって名前が付けられ、通常は 40 桁の 16 進数の文字列として記述されます。このような名前はグローバルに一意です。コミットに至るまでの全履歴は、そのコミットに署名することで証明することができます。この目的のために、4つ目のオブジェクトタイプであるタグが提供されています。</target>
        </trans-unit>
        <trans-unit id="5c22669562d39ab93b88e8b91c6653478eb31b9b" translate="yes" xml:space="preserve">
          <source>All objects have a statically determined &quot;type&quot; which identifies the format of the object (i.e. how it is used, and how it can refer to other objects). There are currently four different object types: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">すべてのオブジェクトには、静的に決定された &quot;型 &quot;があり、これはオブジェクトの形式を識別します(すなわち、どのように使用されるか、他のオブジェクトを参照することができるか)。現在、4つの異なるオブジェクトタイプがあります。&quot;blob&quot;、&quot;tree&quot;、&quot;commit&quot;、&quot;tag &quot;です。</target>
        </trans-unit>
        <trans-unit id="53b47e1baf96b9c8287456e674d706c2d2cb68d3" translate="yes" xml:space="preserve">
          <source>All of the ancestors of a given &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; are said to be &quot;reachable&quot; from that commit. More generally, one &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is reachable from another if we can reach the one from the other by a &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; that follows &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt; to whatever they tag, &lt;a href=&quot;#def_commit_object&quot;&gt;commits&lt;/a&gt; to their parents or trees, and &lt;a href=&quot;#def_tree_object&quot;&gt;trees&lt;/a&gt; to the trees or &lt;a href=&quot;#def_blob_object&quot;&gt;blobs&lt;/a&gt; that they contain.</source>
          <target state="translated">特定の&lt;a href=&quot;#def_commit&quot;&gt;コミットの&lt;/a&gt;祖先はすべて、そのコミットから「到達可能」であると言われます。より一般的には、1つ&lt;a href=&quot;#def_object&quot;&gt;のオブジェクトは、&lt;/a&gt;私たちがすることによって、他の1に達することができるならば、別のから到達可能である&lt;a href=&quot;#def_chain&quot;&gt;チェーン&lt;/a&gt;は以下の&lt;a href=&quot;#def_tag&quot;&gt;タグを&lt;/a&gt;、何でも彼らタグに&lt;a href=&quot;#def_commit_object&quot;&gt;コミット&lt;/a&gt;両親や樹木、およびに&lt;a href=&quot;#def_tree_object&quot;&gt;木&lt;/a&gt;木やへ&lt;a href=&quot;#def_blob_object&quot;&gt;の塊&lt;/a&gt;、彼らが含まれていることを。</target>
        </trans-unit>
        <trans-unit id="c914353521a7fcdc1482a5e3cfa2c2db891768c9" translate="yes" xml:space="preserve">
          <source>All of the changes that Git was able to merge automatically are already added to the index file, so &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; shows only the conflicts. It uses an unusual syntax:</source>
          <target state="translated">Gitが自動的にマージできたすべての変更はすでにインデックスファイルに追加されているため、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;は競合のみを表示します。それは珍しい構文を使用します：</target>
        </trans-unit>
        <trans-unit id="0851367bef62c00e23b203fa9f1e02fbe0c27531" translate="yes" xml:space="preserve">
          <source>All of the following examples map &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; to &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt;.</source>
          <target state="translated">次のすべての例では、 &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; を &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt; にマッピングしています。</target>
        </trans-unit>
        <trans-unit id="1a148afed6f28c8ecd0df018991ec0db90af85d7" translate="yes" xml:space="preserve">
          <source>All of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">更新として許可されないものについて上記で説明したすべてのルールは、オプションの先行 &lt;code&gt;+&lt;/code&gt; をrefspecに追加する（または &lt;code&gt;--force&lt;/code&gt; コマンドラインオプションを使用する）ことで上書きできます。これの唯一の例外は、どの程度の強制でも &lt;code&gt;refs/heads/*&lt;/code&gt; 名前空間に非コミットオブジェクトを受け入れさせないことです。フックまたオーバーライドしたり、これらのルールを修正することができる構成は、例えば、参照 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; をに&lt;a href=&quot;git-config&quot;&gt;[1]のgit -設定&lt;/a&gt;と &lt;code&gt;pre-receive&lt;/code&gt; 及び &lt;code&gt;update&lt;/code&gt; に&lt;a href=&quot;githooks&quot;&gt;githooks [5] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82a27511d4b01630cccb325b4298d897b1527c61" translate="yes" xml:space="preserve">
          <source>All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.</source>
          <target state="translated">これらはすべて、コマンドラインから refspec を省略することもできます。</target>
        </trans-unit>
        <trans-unit id="c91f646c685a7dfcf5e56237f918748518206037" translate="yes" xml:space="preserve">
          <source>All of these objects are stored under their SHA-1 names inside the Git directory:</source>
          <target state="translated">これらのオブジェクトはすべて、Git ディレクトリ内の SHA-1 名で保存されています。</target>
        </trans-unit>
        <trans-unit id="dcd6cc66ca5ed15a438644763fc31848cb788922" translate="yes" xml:space="preserve">
          <source>All of those examples use request rewriting, and need &lt;code&gt;mod_rewrite&lt;/code&gt; (or equivalent; examples below are written for Apache).</source>
          <target state="translated">これらの例はすべて、要求の書き換えを使用しており、 &lt;code&gt;mod_rewrite&lt;/code&gt; （または同等のもの;以下の例はApache用に書かれています）が必要です。</target>
        </trans-unit>
        <trans-unit id="555f29027228e8eb9986b68d870b32cd598f6835" translate="yes" xml:space="preserve">
          <source>All offset and size bytes are optional. This is to reduce the instruction size when encoding small offsets or sizes. The first seven bits in the first octet determines which of the next seven octets is present. If bit zero is set, offset1 is present. If bit one is set offset2 is present and so on.</source>
          <target state="translated">オフセットとサイズのバイトはすべてオプションです。これは、小さなオフセットやサイズをエンコードするときに命令サイズを小さくするためです。最初のオクテットの最初の7ビットによって、次の7オクテットのどれが存在するかが決まります。ビット0がセットされている場合、offset1が存在します。ビットが1に設定されている場合は、offset2が存在します。</target>
        </trans-unit>
        <trans-unit id="64104629c1b1b50c9f411fd4ec6fd95dec11f7bd" translate="yes" xml:space="preserve">
          <source>All packs except the largest pack and those marked with a &lt;code&gt;.keep&lt;/code&gt; files are consolidated into a single pack. When this option is used, &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is ignored.</source>
          <target state="translated">最大のパックと &lt;code&gt;.keep&lt;/code&gt; ファイルでマークされたパックを除くすべてのパックは、1つのパックに統合されます。このオプションを使用すると、 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="e92b55fa77d7332620f31b40a70c7222a88db6aa" translate="yes" xml:space="preserve">
          <source>All public Trace2 functions and macros are defined in &lt;code&gt;trace2.h&lt;/code&gt; and &lt;code&gt;trace2.c&lt;/code&gt;. All public symbols are prefixed with &lt;code&gt;trace2_&lt;/code&gt;.</source>
          <target state="translated">すべてのパブリックTrace2関数およびマクロは、 &lt;code&gt;trace2.h&lt;/code&gt; および &lt;code&gt;trace2.c&lt;/code&gt; で定義されています。すべてのパブリックシンボルの先頭には &lt;code&gt;trace2_&lt;/code&gt; が付いています。</target>
        </trans-unit>
        <trans-unit id="872d9d2cb78e2e8d2f37173a02b50fa38f291d05" translate="yes" xml:space="preserve">
          <source>All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report. This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution.</source>
          <target state="translated">最近のすべてのコマンド(ストリームコメント、ファイル変更、プログレスコマンドを含む)は、クラッシュレポート内のコマンド履歴に表示されますが、生のファイルデータとコミットメッセージはクラッシュレポートから除外されます。この除外により、レポートファイル内のスペースを節約し、実行中に fast-import が実行しなければならないバッファリングの量を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="0d43876445b213dd01218535a02d26c66dcd613b" translate="yes" xml:space="preserve">
          <source>All refs under &lt;code&gt;refs/tags&lt;/code&gt; are pushed, in addition to refspecs explicitly listed on the command line.</source>
          <target state="translated">コマンドラインで明示的にリストされたrefspecに加えて、 &lt;code&gt;refs/tags&lt;/code&gt; の下のすべての参照がプッシュされます。</target>
        </trans-unit>
        <trans-unit id="c5bff800f470ce2148eed81904a64139c855aaa1" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will be shallow with a depth of 1.</source>
          <target state="translated">クローン化されたサブモジュールはすべて深さ1の浅いものになります。</target>
        </trans-unit>
        <trans-unit id="f0007b01191229097f0830c36da052c040ebd97d" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will use the status of the submodule&amp;rsquo;s remote-tracking branch to update the submodule, rather than the superproject&amp;rsquo;s recorded SHA-1. Equivalent to passing &lt;code&gt;--remote&lt;/code&gt; to &lt;code&gt;git submodule update&lt;/code&gt;.</source>
          <target state="translated">複製されたすべてのサブモジュールは、スーパープロジェクトの記録されたSHA-1ではなく、サブモジュールのリモート追跡ブランチのステータスを使用してサブモジュールを更新します。 &lt;code&gt;--remote&lt;/code&gt; を &lt;code&gt;git submodule update&lt;/code&gt; に渡すのと同じです。</target>
        </trans-unit>
        <trans-unit id="a786f92eda8c2712ba677e1c4004bf3ff8163928" translate="yes" xml:space="preserve">
          <source>All such extra objects are removed.</source>
          <target state="translated">そのような余分なものはすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="308cf0e6d77f72bd2adee2732440a8d78d5aacdb" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;file1&lt;/code&gt; files in the output refer to files before the commit, and all the &lt;code&gt;file2&lt;/code&gt; files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:</source>
          <target state="translated">出力内のすべての &lt;code&gt;file1&lt;/code&gt; ファイルはコミット前のファイルを参照し、すべての &lt;code&gt;file2&lt;/code&gt; ファイルはコミット後のファイルを参照します。各変更を各ファイルに順次適用することは正しくありません。たとえば、このパッチはaとbを入れ替えます。</target>
        </trans-unit>
        <trans-unit id="239d57c9bf513683c75ec610784ccebafe4aed25" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;git commit&lt;/code&gt; hooks are invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">すべての &lt;code&gt;git commit&lt;/code&gt; フックは、環境変数 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 呼び出されます。コマンドがコミットメッセージを変更するためのエディターを起動しない場合。</target>
        </trans-unit>
        <trans-unit id="05af0c4256a038463a91f307f30a32fa481ee96d" translate="yes" xml:space="preserve">
          <source>All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit.</source>
          <target state="translated">checkout、diff、status、update、log、add、remove、commitなど、通常の利用に必要な操作をすべてサポートしています。</target>
        </trans-unit>
        <trans-unit id="b2fe8473c593abf01d9d1e8a032df7ab79ebe59a" translate="yes" xml:space="preserve">
          <source>All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form &lt;code&gt;name = value&lt;/code&gt; (or just &lt;code&gt;name&lt;/code&gt;, which is a short-hand to say that the variable is the boolean &quot;true&quot;). The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character.</source>
          <target state="translated">他のすべての行（およびセクションヘッダーの後の残りの行）は、 &lt;code&gt;name = value&lt;/code&gt; （または単に &lt;code&gt;name&lt;/code&gt; の形式）で変数を設定するものとして認識されます。 ）。変数名は大文字と小文字を区別せず、英数字と &lt;code&gt;-&lt;/code&gt; のみを使用でき、アルファベット文字で始まる必要があります。</target>
        </trans-unit>
        <trans-unit id="37ddc9bc522de0a239773cc3df5a07e1939ed991" translate="yes" xml:space="preserve">
          <source>All these options obviously only make sense if enforced by the server side. They have been implemented to resemble the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; options as closely as possible.</source>
          <target state="translated">これらのオプションはすべて、サーバー側で強制された場合にのみ意味を持ちます。これらは、&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;オプションにできる限り類似するように実装されています。</target>
        </trans-unit>
        <trans-unit id="5a78bca2d245f7f4e49ed3949e2005fd2e3b0774" translate="yes" xml:space="preserve">
          <source>All variables can also be set per access method, see &lt;a href=&quot;#configaccessmethod&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">すべての変数は、アクセス方法ごとに設定することもできます。&lt;a href=&quot;#configaccessmethod&quot;&gt;上記を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0e67d43426c8567d2129159d2cb0396634aa4c2f" translate="yes" xml:space="preserve">
          <source>All writing options will per default write to the repository specific configuration file. Note that this also affects options like &lt;code&gt;--replace-all&lt;/code&gt; and &lt;code&gt;--unset&lt;/code&gt;. &lt;strong&gt;&lt;em&gt;git config&lt;/em&gt; will only ever change one file at a time&lt;/strong&gt;.</source>
          <target state="translated">すべての書き込みオプションは、デフォルトでリポジトリ固有の構成ファイルに書き込みます。これは &lt;code&gt;--replace-all&lt;/code&gt; や &lt;code&gt;--unset&lt;/code&gt; などのオプションにも影響することに注意してください。&lt;strong&gt;&lt;em&gt;git config&lt;/em&gt;は一度に1つのファイルのみを変更します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="95ccd528c2d028453ad3cf7d0223681cc63467f8" translate="yes" xml:space="preserve">
          <source>All you need to do is edit the files to resolve the conflicts, and then</source>
          <target state="translated">必要なのは、コンフリクトを解決するためにファイルを編集して</target>
        </trans-unit>
        <trans-unit id="dd540fb2325b9250764db7424886c097360ae897" translate="yes" xml:space="preserve">
          <source>All you need to do is place the newly created bare Git repository in a directory that is exported by the web server, and make some adjustments to give web clients some extra information they need:</source>
          <target state="translated">新しく作成したベアGitリポジトリをウェブサーバーからエクスポートされたディレクトリに置き、ウェブクライアントが必要とする情報を追加できるように調整するだけです。</target>
        </trans-unit>
        <trans-unit id="48af47b0afbfe999262fa68f40e97838cf256b84" translate="yes" xml:space="preserve">
          <source>Allow (or disallow) external text conversion filters to be run when comparing binary files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, but not for &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or diff plumbing commands.</source>
          <target state="translated">バイナリファイルを比較するときに、外部テキスト変換フィルターの実行を許可（または禁止）します。詳細については、&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を参照してください。textconvフィルターは通常一方向の変換であるため、結果の差分は人間の消費に適していますが、適用できません。このため、textconvフィルターはデフォルトで&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;と&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;に対してのみ有効であり、&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;またはdiff plumbingコマンドに対しては有効ではありません。</target>
        </trans-unit>
        <trans-unit id="c181c3ddfb97039bcd6c32002cf12732d3862d70" translate="yes" xml:space="preserve">
          <source>Allow -s or -t to query broken/corrupt objects of unknown type.</source>
          <target state="translated">s または -t を使用して、型が不明な壊れた/破損したオブジェクトを問い合わせることができます。</target>
        </trans-unit>
        <trans-unit id="faf02b1d62cc9d5575e2c1ae9bbaffbbe1cee9af" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;--stdin&lt;/code&gt; to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; が、標準のオブジェクト解析またはgit-fsckチェックにパスしない可能性のあるルーズオブジェクトにゴミをハッシュできるようにします。Git自体のストレステストや、野生で遭遇した破損したオブジェクトや偽のオブジェクトの特性を再現するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="b8cf489219ee9e67f31bd43c44a93293049edf6e" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object that is reachable from any ref tip. However, note that calculating object reachability is computationally expensive. Defaults to &lt;code&gt;false&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">&lt;code&gt;upload-pack&lt;/code&gt; が、参照チップから到達可能なオブジェクトを要求するフェッチ要求を受け入れることを許可します。ただし、オブジェクトの到達可能性の計算には計算コストがかかることに注意してください。デフォルトは &lt;code&gt;false&lt;/code&gt; です。これが偽の場合でも、クライアントは&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]の&lt;/a&gt; manページの「セキュリティ」セクションで説明されている手法を使用してオブジェクトを盗むことができる場合があります。プライベートデータは別のリポジトリに保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5c123f83ef289d2d1e91047a317113ed5e999032" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for any object at all. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;upload-pack&lt;/code&gt; がオブジェクトを要求するフェッチ要求を受け入れることを許可します。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7dac60bc93b481fbd44fafe13c497842d9a7d982" translate="yes" xml:space="preserve">
          <source>Allow adding otherwise ignored files.</source>
          <target state="translated">無視されているファイルの追加を許可します。</target>
        </trans-unit>
        <trans-unit id="e0a681012f0189df01bc378cc160293747f7b006" translate="yes" xml:space="preserve">
          <source>Allow an empty note object to be stored. The default behavior is to automatically remove empty notes.</source>
          <target state="translated">空のノートオブジェクトの保存を許可します。デフォルトの動作は、空のノートを自動的に削除することです。</target>
        </trans-unit>
        <trans-unit id="87f26de68d4ee0de2215d71b6377c359ff10beb5" translate="yes" xml:space="preserve">
          <source>Allow an external diff helper to be executed. If you set an external diff driver with &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;, you need to use this option with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and friends.</source>
          <target state="translated">外部のdiffヘルパーの実行を許可します。&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を使用して外部diffドライバーを設定する場合は、このオプションを&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;およびその友達で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="73e430db92a123869cc3ef536d85d87d370ba895" translate="yes" xml:space="preserve">
          <source>Allow building of more than one tree object before exiting. Each tree is separated by as single blank line. The final new-line is optional. Note - if the &lt;code&gt;-z&lt;/code&gt; option is used, lines are terminated with NUL.</source>
          <target state="translated">終了する前に、複数のツリーオブジェクトの構築を許可します。各ツリーは、1つの空白行で区切られます。最後の改行はオプションです。注 &lt;code&gt;-z&lt;/code&gt; オプションを使用すると、行はNULで終了します。</target>
        </trans-unit>
        <trans-unit id="8e57d5c7661ffc2e9da98170f1d30b0c418901a9" translate="yes" xml:space="preserve">
          <source>Allow missing objects. The default behaviour (without this option) is to verify that each tree entry&amp;rsquo;s sha1 identifies an existing object. This option has no effect on the treatment of gitlink entries (aka &quot;submodules&quot;) which are always allowed to be missing.</source>
          <target state="translated">見つからないオブジェクトを許可します。デフォルトの動作（このオプションなし）は、各ツリーエントリのsha1が既存のオブジェクトを識別することを確認することです。このオプションは、常に欠落することが許可されているgitlinkエントリ（別名「サブモジュール」）の処理には影響しません。</target>
        </trans-unit>
        <trans-unit id="7a9030542d2938f9caeac64676db40e7417c42b9" translate="yes" xml:space="preserve">
          <source>Allow pulling from all directories that look like Git repositories (have the &lt;code&gt;objects&lt;/code&gt; and &lt;code&gt;refs&lt;/code&gt; subdirectories), even if they do not have the &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;git-daemon-export-ok&lt;/code&gt; ファイルがない場合でも、Gitリポジトリのように見えるすべてのディレクトリ（ &lt;code&gt;objects&lt;/code&gt; と &lt;code&gt;refs&lt;/code&gt; サブディレクトリがある）からのプルを許可します。</target>
        </trans-unit>
        <trans-unit id="98350181a43fb733be348f0d041de3f567196c13" translate="yes" xml:space="preserve">
          <source>Allow recursive removal when a leading directory name is given.</source>
          <target state="translated">先頭のディレクトリ名が指定された場合に再帰的に削除できるようにしました。</target>
        </trans-unit>
        <trans-unit id="c333cb7fb684ac83dfac5b9ca4103644dc06e4b3" translate="yes" xml:space="preserve">
          <source>Allow several &amp;lt;repository&amp;gt; and &amp;lt;group&amp;gt; arguments to be specified. No &amp;lt;refspec&amp;gt;s may be specified.</source>
          <target state="translated">複数の&amp;lt;repository&amp;gt;および&amp;lt;group&amp;gt;引数を指定できるようにします。&amp;lt;refspec&amp;gt;は指定できません。</target>
        </trans-unit>
        <trans-unit id="5913a64254a27922cb756768e473a3a0fc91c718" translate="yes" xml:space="preserve">
          <source>Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible.</source>
          <target state="translated">可能であれば、自動矛盾解決の結果を用いてインデックスを更新するためのリレレ機構を許可する。</target>
        </trans-unit>
        <trans-unit id="e67909264741a3c975c7c69263b8cae851ce5588" translate="yes" xml:space="preserve">
          <source>Allow to extend .git/shallow if the new refs require it.</source>
          <target state="translated">新しいリファレンスが必要ならば .git/shallow を拡張できるようにします。</target>
        </trans-unit>
        <trans-unit id="021daf7178c1ed944c38d8aa70956d32b2ff6625" translate="yes" xml:space="preserve">
          <source>Allow ~user notation to be used in requests. When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access &lt;code&gt;foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;. If &lt;code&gt;--user-path=path&lt;/code&gt; is specified, the same request is taken as a request to access &lt;code&gt;path/foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;.</source>
          <target state="translated">リクエストで〜user表記を使用できるようにします。パラメータなしで指定した場合、git：// host /〜alice / fooへのリクエストは、ユーザー &lt;code&gt;alice&lt;/code&gt; のホームディレクトリにある &lt;code&gt;foo&lt;/code&gt; リポジトリへのアクセスリクエストと見なされます。場合 &lt;code&gt;--user-path=path&lt;/code&gt; 指定され、同じ要求は、アクセスの要求としている &lt;code&gt;path/foo&lt;/code&gt; ユーザーのホームディレクトリにリポジトリ &lt;code&gt;alice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f93db45d6bdb40051ed50b8cdab39b85ae36aa7" translate="yes" xml:space="preserve">
          <source>Allow/forbid overriding the site-wide default with per repository configuration. By default, all the services may be overridden.</source>
          <target state="translated">リポジトリごとの設定でサイト全体のデフォルトをオーバーライドすることを許可/禁止します。デフォルトでは、すべてのサービスがオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="970c6f976b1a1113e48252fb665bb9621a059065" translate="yes" xml:space="preserve">
          <source>Allowing web browsing of a repository</source>
          <target state="translated">リポジトリのウェブ閲覧を許可する</target>
        </trans-unit>
        <trans-unit id="a8f99759b1b09bc7158e191889a1567fae09d468" translate="yes" xml:space="preserve">
          <source>Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">pre-rebaseフックの実行を許可します。これがデフォルトです。このオプションを使用して、-no-verifyをオーバーライドできます。&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="0c6ea72ee13badd8d83db58afdf5e962ad300ef1" translate="yes" xml:space="preserve">
          <source>Allows to specify the commit message.</source>
          <target state="translated">コミットメッセージを指定します。</target>
        </trans-unit>
        <trans-unit id="a2ec32ba2a953960fca003bf1ffa505bb688ba89" translate="yes" xml:space="preserve">
          <source>Also note that only one asterisk is allowed per word. For example:</source>
          <target state="translated">また、1つの単語につき、アスタリスクは1つしか使用できないことに注意してください。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="771cf844aea157583eecdff70f695735bc6a87ec" translate="yes" xml:space="preserve">
          <source>Also note that the above configuration can be performed by directly editing the file &lt;code&gt;.git/config&lt;/code&gt; instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">また、上記の設定は、&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;を使用する代わりに、ファイル &lt;code&gt;.git/config&lt;/code&gt; を直接編集することで実行できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="4107490214e5f413a9517623a2b64cb4835e7c24" translate="yes" xml:space="preserve">
          <source>Also note that we don&amp;rsquo;t require the commits that are kept to be descendants of a &quot;good&quot; commit. So in the following example, commits W and Z will be kept:</source>
          <target state="translated">また、「良い」コミットの子孫であるように保持されているコミットは必要ないことにも注意してください。したがって、次の例では、コミットWおよびZが保持されます。</target>
        </trans-unit>
        <trans-unit id="f69166c2831d93f6b548f4895823501206c0d3ba" translate="yes" xml:space="preserve">
          <source>Also output details about the matching pattern (if any) for each given pathname. For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">また、指定された各パス名の一致パターン（存在する場合）の詳細も出力します。除外ソース内および除外ソース間の優先ルールについては、&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="dd9960d9f0773be5357485566c306db4c0f3e065" translate="yes" xml:space="preserve">
          <source>Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line).</source>
          <target state="translated">また、標準入力からメモを削除するためのオブジェクト名も読んでください(コマンドラインからオブジェクト名と組み合わせられない理由はありません)。</target>
        </trans-unit>
        <trans-unit id="c7fa0726e69077445ae425465cf33ea62e9aedfc" translate="yes" xml:space="preserve">
          <source>Also search in ignored files by not honoring the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful with &lt;code&gt;--untracked&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;.gitignore&lt;/code&gt; メカニズムを尊重せずに、無視されたファイルを検索します。 &lt;code&gt;--untracked&lt;/code&gt; でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="05797f7578d1a6ba6a5217b9a350a9edbcb69fe4" translate="yes" xml:space="preserve">
          <source>Also you can use a regular expression to specify the line range:</source>
          <target state="translated">また、正規表現を使って行間を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="4774804d03b6c07565acb208c60c6e7cbe3431b2" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will list those files as &quot;unmerged&quot;, and the files with conflicts will have conflict markers added, like this:</source>
          <target state="translated">また、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;はこれらのファイルを「マージされていない」ものとしてリストし、競合のあるファイルには次のように競合マーカーが追加されます。</target>
        </trans-unit>
        <trans-unit id="4527cea99021b273b3aba7b9a7e7a9bfd20d98e9" translate="yes" xml:space="preserve">
          <source>Also, note that a bare &lt;code&gt;git diff&lt;/code&gt; shows the changes to file.txt, but not the addition of closing.txt, because the version of closing.txt in the index file is identical to the one in the working directory.</source>
          <target state="translated">また、裸の &lt;code&gt;git diff&lt;/code&gt; にはfile.txtへの変更が表示されますが、closed.txtの追加は表示されないことに注意してください。これは、インデックスファイル内のclosing.txtのバージョンが作業ディレクトリ内のバージョンと同じであるためです。</target>
        </trans-unit>
        <trans-unit id="1948de62c9472dadd9b232c96fea0db542b4a7f1" translate="yes" xml:space="preserve">
          <source>Also, the poor performance of git-filter-branch often leads to safety issues:</source>
          <target state="translated">また、git-filter-branchのパフォーマンスが悪いと、安全性の問題につながることが多いです。</target>
        </trans-unit>
        <trans-unit id="3d45b434e26b625e54920695d02b2fe8da737175" translate="yes" xml:space="preserve">
          <source>Also, the remote-tracking branch you use the &lt;code&gt;--fork-point&lt;/code&gt; mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; correctly finds, but the &lt;code&gt;--fork-point&lt;/code&gt; mode will not, because it is not one of the commits that used to be at the tip of origin/master).</source>
          <target state="translated">また、 &lt;code&gt;--fork-point&lt;/code&gt; モードで使用するリモート追跡ブランチは、トピックの先端から分岐したものでなければなりません。ヒントより古いコミットからフォークした場合、このモードではフォークポイントが見つかりません（上記のサンプル履歴でB0が存在せず、B1で開始されたオリジン/マスターがB2に移動してからBに移動し、トピックをフォークしたとします） origin / master ^ at origin / masterがB1の場合;履歴の形状は上記と同じですが、B0はあり &lt;code&gt;--fork-point&lt;/code&gt; の親は &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 正しく検出するものですが、-fork -pointモードは、以前はorigin / masterの先端にあったコミットの1つではないため、そうなりません。</target>
        </trans-unit>
        <trans-unit id="ac8d6fa69b9f440f0c0a5d003f6fd5f2f023c7f6" translate="yes" xml:space="preserve">
          <source>Also, these upper-case letters can be downcased to exclude. E.g. &lt;code&gt;--diff-filter=ad&lt;/code&gt; excludes added and deleted paths.</source>
          <target state="translated">また、これらの大文字を小文字にして除外することもできます。例 &lt;code&gt;--diff-filter=ad&lt;/code&gt; は、追加および削除されたパスを除外します。</target>
        </trans-unit>
        <trans-unit id="2530a264943c28587e7428206ae85af163c3c029" translate="yes" xml:space="preserve">
          <source>Also, we do not call it &quot;cache&quot; any more, but rather &quot;index&quot;; however, the file is still called &lt;code&gt;cache.h&lt;/code&gt;. Remark: Not much reason to change it now, especially since there is no good single name for it anyway, because it is basically &lt;code&gt;the&lt;/code&gt; header file which is included by &lt;code&gt;all&lt;/code&gt; of Git&amp;rsquo;s C sources.</source>
          <target state="translated">また、これを「キャッシュ」と呼ぶのではなく、「インデックス」と呼びます。ただし、ファイルはまだ &lt;code&gt;cache.h&lt;/code&gt; と呼ばれます。備考：それは基本的にあるので、それには良い単一の名前が、とにかく存在しない、特に以来、今それを変更しない多くの理由で含まれているヘッダファイル &lt;code&gt;all&lt;/code&gt; のGitのCソースの。 &lt;code&gt;the&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e6472f190ba1582b845a0ece02ff445cff78f4d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;--raw&lt;/code&gt; or &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">また、 &lt;code&gt;--raw&lt;/code&gt; または &lt;code&gt;--numstat&lt;/code&gt; が指定されている場合は、パス名を変更せず、出力フィールドのターミネーターとしてNULを使用してください。</target>
        </trans-unit>
        <trans-unit id="a1a167e4e28bf08db5b93ca5300935fe27c039fa" translate="yes" xml:space="preserve">
          <source>Alter the sha1&amp;rsquo;s minimum display length in the output listing. The default value is 7 and can be overridden by the &lt;code&gt;core.abbrev&lt;/code&gt; config option.</source>
          <target state="translated">出力リストのsha1の最小表示長を変更します。デフォルト値は7で、 &lt;code&gt;core.abbrev&lt;/code&gt; 設定オプションで上書きできます。</target>
        </trans-unit>
        <trans-unit id="aadcacaf495c2512ca4329e0d847da152c0541e3" translate="yes" xml:space="preserve">
          <source>Alternate terms</source>
          <target state="translated">別の用語</target>
        </trans-unit>
        <trans-unit id="0712141dd1ece4a4773c0da1c80f1954ca0f9da5" translate="yes" xml:space="preserve">
          <source>Alternates, clone -reference, etc.</source>
          <target state="translated">代替品、クローン-参照など。</target>
        </trans-unit>
        <trans-unit id="2ca863985e6b3522ed032957d62190302ca13b98" translate="yes" xml:space="preserve">
          <source>Alternative Git implementations (e.g. JGit or libgit2) and older Git versions (as of March 2018) do not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If you decide to use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute in your repository, then it is strongly recommended to ensure that all clients working with the repository support it.</source>
          <target state="translated">代替のGit実装（例：JGitまたはlibgit2）および古いGitバージョン（2018年3月現在）は、 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性をサポートしていません。リポジトリで &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性を使用する場合は、リポジトリを操作するすべてのクライアントがそれをサポートしていることを確認することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="9dbb61a2fa8dc0f3013308a0745fea72ba7b1a16" translate="yes" xml:space="preserve">
          <source>Alternative development models</source>
          <target state="translated">代替開発モデル</target>
        </trans-unit>
        <trans-unit id="a7aefac2117f3e88573f4205384ee4d7a98e203b" translate="yes" xml:space="preserve">
          <source>Alternatively you can produce the password with perl&amp;rsquo;s crypt() operator:</source>
          <target state="translated">あるいは、perlのcrypt（）演算子を使用してパスワードを生成できます。</target>
        </trans-unit>
        <trans-unit id="4ca416a8fe96dacfa9959132947eceee9f58da64" translate="yes" xml:space="preserve">
          <source>Alternatively, Git has a native protocol, or can use http; see &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; for details.</source>
          <target state="translated">あるいは、Gitはネイティブプロトコルを持っているか、httpを使用できます。詳細は&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7cf31ef819e05669294bc16a9923a23bdb2b7a01" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the &lt;code&gt;gitcvs.allBinary&lt;/code&gt; config for the default setting. If &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set, then file not otherwise specified will default to &lt;code&gt;-kb&lt;/code&gt; mode. Otherwise the &lt;code&gt;-k&lt;/code&gt; mode is left blank. But if &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set to &quot;guess&quot;, then the correct &lt;code&gt;-k&lt;/code&gt; mode will be guessed based on the contents of the file.</source>
          <target state="translated">または、 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 構成が有効になっていないか、属性でファイル名の自動検出が許可されていない場合、サーバーは &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 構成をデフォルト設定に使用します。 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; が設定されている場合、特に指定されていないファイルはデフォルトで &lt;code&gt;-kb&lt;/code&gt; モードになります。それ以外の場合、 &lt;code&gt;-k&lt;/code&gt; モードは空白のままになります。ただし、 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; が「推測」に設定されている場合、正しい &lt;code&gt;-k&lt;/code&gt; モードはファイルの内容に基づいて推測されます。</target>
        </trans-unit>
        <trans-unit id="b1ff522462be60cebf023852e684a91e2d5544f7" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it.</source>
          <target state="translated">あるいは、変数が絶対パス（ &lt;code&gt;/&lt;/code&gt; 文字で始まる）に設定されている場合、Gitはこれをファイルパスとして解釈し、それにトレースメッセージを追加しようとします。</target>
        </trans-unit>
        <trans-unit id="4d07f3824238dc7367ab6d5b5e874d23e305b47d" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it. If the path already exists and is a directory, the trace messages will be written to files (one per process) in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions).</source>
          <target state="translated">あるいは、変数が絶対パス（ &lt;code&gt;/&lt;/code&gt; 文字で始まる）に設定されている場合、Gitはこれをファイルパスとして解釈し、それにトレースメッセージを追加しようとします。パスが既に存在し、ディレクトリである場合、トレースメッセージはそのディレクトリのファイル（プロセスごとに1つ）に書き込まれ、SIDの最後のコンポーネントとオプションのカウンター（ファイル名の競合を回避するため）に従って名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="c00302c08639585f72779e30a86782e24fd08ff9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of running &lt;code&gt;git add&lt;/code&gt; beforehand, you can use</source>
          <target state="translated">または、事前に &lt;code&gt;git add&lt;/code&gt; を実行する代わりに、</target>
        </trans-unit>
        <trans-unit id="530bb07d1f66513818e1b0385a8e30a51f6194af" translate="yes" xml:space="preserve">
          <source>Alternatively, note that</source>
          <target state="translated">あるいは、次のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f80a5d22f5c293edd914795b473129c37d7276c3" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;code&gt;-z&lt;/code&gt; to specify in NUL-terminated format, without quoting:</source>
          <target state="translated">または、 &lt;code&gt;-z&lt;/code&gt; を使用して、引用符なしでNUL終了形式で指定します。</target>
        </trans-unit>
        <trans-unit id="e5759528a9df2b3bafde33c91b20bb607bfb37f6" translate="yes" xml:space="preserve">
          <source>Alternatively, you can edit the working directory and update the index to fix your mistake, just as if you were going to &lt;a href=&quot;#how-to-make-a-commit&quot;&gt;create a new commit&lt;/a&gt;, then run</source>
          <target state="translated">あなたはするつもりだったかのように別の方法として、あなたは、自分の間違いを修正する作業ディレクトリを編集し、インデックスを更新することができ&lt;a href=&quot;#how-to-make-a-commit&quot;&gt;、新しいコミットを作成&lt;/a&gt;し、実行します</target>
        </trans-unit>
        <trans-unit id="b15cfe3da911f6cecf33791979f852dbff3cfb5b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with &lt;code&gt;git-cvsserver&lt;/code&gt; or manipulate your &lt;code&gt;.bashrc&lt;/code&gt; so that calling &lt;code&gt;cvs&lt;/code&gt; effectively calls &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">または、Eclipseが提供する非標準のextsshプロトコルを使用することもできます。その場合、CVS_SERVERは無視され、サーバーのcvsユーティリティを &lt;code&gt;git-cvsserver&lt;/code&gt; に置き換えるか、 &lt;code&gt;.bashrc&lt;/code&gt; を操作して、 &lt;code&gt;cvs&lt;/code&gt; を呼び出すと &lt;code&gt;git-cvsserver&lt;/code&gt; が効果的に呼び出されるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="05fd4a6419394e16cfc11919ace1a8f856d1ec42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can rebase your change between X and B on top of A, with &quot;git pull --rebase&quot;, and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</source>
          <target state="translated">あるいは、X と B の間の変更を A の上にリベースするには &quot;git pull --rebase&quot; を実行し、その結果をプッシュします。このリベースにより、A の上に X と B の間の変更をビルドする新しいコミット D が作成されます。</target>
        </trans-unit>
        <trans-unit id="a49fa07d5474cf3dca63ac2a175c46a10b07f5f3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can undo the &lt;code&gt;git rebase&lt;/code&gt; with</source>
          <target state="translated">または、 &lt;code&gt;git rebase&lt;/code&gt; を元に戻すこともできます</target>
        </trans-unit>
        <trans-unit id="029034bf1886e77ae0c4d532b4059fd9c7d41a52" translate="yes" xml:space="preserve">
          <source>Alternatively, you may often see this sort of thing done with the lower-level command &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, which just lists the SHA-1&amp;rsquo;s of all the given commits:</source>
          <target state="translated">または、この種のことを、下位レベルのコマンド&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;で実行することがよくあります。これは、指定されたすべてのコミットのSHA-1を一覧表示するだけです。</target>
        </trans-unit>
        <trans-unit id="bf28b03e83304f7cdad7262da1da6a80b8eb9f3d" translate="yes" xml:space="preserve">
          <source>Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains. Developers of such porcelains might start by reading about &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">Gitには独自の磁器層が含まれていますが、低レベルのコマンドで代替磁器の開発をサポートできます。そのような磁器の開発者は&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;と&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;について読むことから始めるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6c4b8611028dc848ad4ee5788ef19d7585dae7a1" translate="yes" xml:space="preserve">
          <source>Although Git is a truly distributed system, it is often convenient to organize your project with an informal hierarchy of developers. Linux kernel development is run this way. There is a nice illustration (page 17, &quot;Merges to Mainline&quot;) in &lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap&amp;rsquo;s presentation&lt;/a&gt;.</source>
          <target state="translated">Gitは真に分散したシステムですが、非公式な開発者の階層でプロジェクトを編成すると便利な場合があります。Linuxカーネル開発はこの方法で実行されます。&lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;ランディダンラップのプレゼンテーションに&lt;/a&gt;は、すばらしいイラスト（17ページの「メインラインへのマージ」）があります。</target>
        </trans-unit>
        <trans-unit id="6f37ac3daafe831f82aec5b2cea866288f7330ab" translate="yes" xml:space="preserve">
          <source>Although both this option and --fork-point find the merge base between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt;, this option uses the merge base as the &lt;code&gt;starting point&lt;/code&gt; on which new commits will be created, whereas --fork-point uses the merge base to determine the &lt;code&gt;set of commits&lt;/code&gt; which will be rebased.</source>
          <target state="translated">このオプションと--fork-pointはどちらも&amp;lt;upstream&amp;gt;と&amp;lt;branch&amp;gt;の間のマージベースを検出しますが、このオプションはマージベースを新しいコミットが作成される &lt;code&gt;starting point&lt;/code&gt; として使用しますが、-fork-pointはマージを使用しますベースにして、リベース &lt;code&gt;set of commits&lt;/code&gt; のセットを決定します。</target>
        </trans-unit>
        <trans-unit id="bc30d48b03921e7f964de7f07369eb4188785847" translate="yes" xml:space="preserve">
          <source>Although the object files are gone, any commands that refer to those objects will work exactly as they did before.</source>
          <target state="translated">オブジェクトファイルはなくなりましたが、それらのオブジェクトを参照するコマンドは以前と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="47f1282955f73f61669189722bd77f19d0aada5a" translate="yes" xml:space="preserve">
          <source>Although this bit looks similar to assume-unchanged bit, its goal is different from assume-unchanged bit&amp;rsquo;s. Skip-worktree also takes precedence over assume-unchanged bit when both are set.</source>
          <target state="translated">このビットは想定されていないビットに似ていますが、その目的は想定されていないビットとは異なります。Skip-worktreeは、両方が設定されている場合、仮定されていないビットよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="d6138749eeae08edd7696427a93048315afbc7d0" translate="yes" xml:space="preserve">
          <source>Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.</source>
          <target state="translated">コミットログのメッセージを UTF-8 でエンコードすることを推奨していますが、コアと Git Porcelain の両方とも、プロジェクトに UTF-8 を強制しないように設計されています。特定のプロジェクトの参加者全員がレガシーエンコーディングを使った方が便利だと思う場合でも、Git はそれを禁止していません。しかし、いくつか注意すべき点があります。</target>
        </trans-unit>
        <trans-unit id="2138c97353c611a94eb25c7e6e46e48baedec73c" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;acknowledgments&quot;</source>
          <target state="translated">常にセクションヘッダー「謝辞」で始まる</target>
        </trans-unit>
        <trans-unit id="e2fd2ed397536c82477394e8a15b0eb70ea28108" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile&quot;</source>
          <target state="translated">常にセクションヘッダ &quot;packfile&quot; で始まる</target>
        </trans-unit>
        <trans-unit id="2a74cc6750711124d9f54ba56e439b92b2eb550a" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;shallow-info&quot;</source>
          <target state="translated">常にセクションヘッダー &quot;shallow-info &quot;で始まる</target>
        </trans-unit>
        <trans-unit id="fa34aca91ee0baeaea0934aa3e08a4599c439042" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;wanted-refs&quot;.</source>
          <target state="translated">常にセクションヘッダー &quot;wanted-refs &quot;から始まります。</target>
        </trans-unit>
        <trans-unit id="7e06c04cd8e1ea9ac30d6ef765d5374aeb2852d8" translate="yes" xml:space="preserve">
          <source>Always commit your fixes to the oldest supported branch that requires them. Then (periodically) merge the integration branches upwards into each other.</source>
          <target state="translated">修正を必要とする最も古いサポートされているブランチに常にコミットしてください。そして (定期的に)統合ブランチを上向きにマージします。</target>
        </trans-unit>
        <trans-unit id="740206082e01fd2ec3dbefb8f6cae1ac54979d66" translate="yes" xml:space="preserve">
          <source>Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in &quot;describe&quot; output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee&amp;hellip;​.).</source>
          <target state="translated">タグに一致する場合でも、常に長い形式（タグ、コミット数、および短縮されたコミット名）を出力します。これは、問題のコミットがタグ付きバージョンである場合でも、「説明」出力でコミットオブジェクト名の一部を確認する場合に便利です。タグ名を出力するだけでなく、そのようなコミットをv1.2-0-gdeadbeeとして記述します（オブジェクトのdeadbeeを指すタグv1.2以降の0番目のコミット&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="10fe0db5ec22452b1b5e484a236c7996a8b1d4d4" translate="yes" xml:space="preserve">
          <source>Always publish the submodule change before publishing the change to the superproject that references it. If you forget to publish the submodule change, others won&amp;rsquo;t be able to clone the repository:</source>
          <target state="translated">サブモジュールの変更をそれを参照するスーパープロジェクトに公開する前に、常にサブモジュールの変更を公開してください。サブモジュールの変更を公開するのを忘れると、他の人はリポジトリを複製できなくなります。</target>
        </trans-unit>
        <trans-unit id="30bc18fd1cd8bd10b1f49729296161d64c50a6de" translate="yes" xml:space="preserve">
          <source>Always use the current time and time zone. The literal &lt;code&gt;now&lt;/code&gt; must always be supplied for &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">常に現在の時刻とタイムゾーンを使用します。リテラルは &lt;code&gt;now&lt;/code&gt; 、常にのために供給しなければならない &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3edc64a04543ee397addec8da3ac8a7a4a6fa3" translate="yes" xml:space="preserve">
          <source>Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace &lt;code&gt;refs/original/&lt;/code&gt;.</source>
          <target state="translated">書き換えられたバージョンが正しいことを常に確認してください。元の参照は、書き換えられたものと異なる場合、名前空間 &lt;code&gt;refs/original/&lt;/code&gt; 格納されます。</target>
        </trans-unit>
        <trans-unit id="8c005cc3257b6a0770843066bf6334d49c090a4e" translate="yes" xml:space="preserve">
          <source>Among the &amp;lt;reference&amp;gt;s given, display only the ones that cannot be reached from any other &amp;lt;reference&amp;gt;.</source>
          <target state="translated">指定された&amp;lt;reference&amp;gt;のうち、他の&amp;lt;reference&amp;gt;から到達できないもののみを表示します。</target>
        </trans-unit>
        <trans-unit id="ac6d5f7660135e74c3b73d13034cd4552f455751" translate="yes" xml:space="preserve">
          <source>An &quot;annotated tag&quot; is actually a real Git object, and contains not only a pointer to the state you want to tag, but also a small tag name and message, along with optionally a PGP signature that says that yes, you really did that tag. You create these annotated tags with either the &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-s&lt;/code&gt; flag to &lt;code&gt;git tag&lt;/code&gt;:</source>
          <target state="translated">「注釈付きタグ」は、実際には実際のGitオブジェクトであり、タグ付けする状態へのポインターだけでなく、小さなタグ名とメッセージも含まれ、オプションでPGP署名が含まれています。鬼ごっこ。これらの注釈付きタグは、 &lt;code&gt;-a&lt;/code&gt; または &lt;code&gt;-s&lt;/code&gt; フラグを使用して &lt;code&gt;git tag&lt;/code&gt; に作成します。</target>
        </trans-unit>
        <trans-unit id="1268d4db5a16c4059e58835dc106857c027b0f95" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; which contains unmerged &lt;a href=&quot;#def_index_entry&quot;&gt;index entries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;マージされていない含まれている&lt;a href=&quot;#def_index_entry&quot;&gt;インデックスのエントリを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d934873e3d430ebe475eea94d0b0f9a9f43c9fd6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; pointing to another object, which can contain a message just like a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;. It can also contain a (PGP) signature, in which case it is called a &quot;signed tag object&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;含む&lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt;だけのようなメッセージが含まれていることができ、別のオブジェクトにポインティングを&lt;a href=&quot;#def_commit_object&quot;&gt;コミットオブジェクトを&lt;/a&gt;。また、（PGP）署名を含めることもできます。その場合、「署名済みタグオブジェクト」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="39ba7d0e69e6d58b366781bce9a8868629216c1c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a list of file names and modes along with refs to the associated blob and/or tree objects. A &lt;a href=&quot;#def_tree&quot;&gt;tree&lt;/a&gt; is equivalent to a &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;の関連するブロブおよび/またはツリーオブジェクトへのREFと一緒にファイル名とモードの一覧を含みます。&lt;a href=&quot;#def_tree&quot;&gt;ツリーは&lt;/a&gt;同等です&lt;a href=&quot;#def_directory&quot;&gt;ディレクトリ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c15d413f65deef5a874cba86dbad4625cd4cbd2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; used to temporarily store the contents of a &lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt; working directory and the index for future reuse.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクトは、&lt;/a&gt;一時的の内容を格納するために使用&lt;a href=&quot;#def_dirty&quot;&gt;汚い&lt;/a&gt;作業ディレクトリおよび将来の再利用のためのインデックスを。</target>
        </trans-unit>
        <trans-unit id="0c263addb55b65fe527b2a21bf509fb6d214e692" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which contains the information about a particular &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;, such as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;, committer, author, date and the &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; which corresponds to the top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; of the stored revision.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;特定に関する情報が含ま&lt;a href=&quot;#def_revision&quot;&gt;リビジョン&lt;/a&gt;など、&lt;a href=&quot;#def_parent&quot;&gt;両親&lt;/a&gt;、コミッター、著者、日付、&lt;a href=&quot;#def_tree_object&quot;&gt;木オブジェクト&lt;/a&gt;トップに対応する&lt;a href=&quot;#def_directory&quot;&gt;ディレクトリ&lt;/a&gt;記憶された改訂の。</target>
        </trans-unit>
        <trans-unit id="fa8c0584fca9913191dbab3d7a46ffea1d0255bd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, &lt;a href=&quot;#def_tag&quot;&gt;tag&lt;/a&gt;, or any other reference.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;ない&lt;a href=&quot;#def_reachable&quot;&gt;到達&lt;/a&gt;から&lt;a href=&quot;#def_branch&quot;&gt;分岐&lt;/a&gt;、&lt;a href=&quot;#def_tag&quot;&gt;タグ&lt;/a&gt;、または任意の他の参照。</target>
        </trans-unit>
        <trans-unit id="0fa11321cf1316d583795e0fa9253aae31456769" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_unreachable_object&quot;&gt;unreachable object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; even from other unreachable objects; a dangling object has no references to it from any reference or &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_unreachable_object&quot;&gt;到達不能なオブジェクト&lt;/a&gt;ではない&lt;a href=&quot;#def_reachable&quot;&gt;到達可能&lt;/a&gt;であっても、他の到達不能オブジェクトから。ダングリングオブジェクトには、&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ内の&lt;/a&gt;参照または&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;からの参照はありません。</target>
        </trans-unit>
        <trans-unit id="1f18e6fb49a003c4f6ae24bcf2f216e9b2db33c0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;author&lt;/code&gt; command may optionally appear, if the author information might differ from the committer information. If &lt;code&gt;author&lt;/code&gt; is omitted then fast-import will automatically use the committer&amp;rsquo;s information for the author portion of the commit. See below for a description of the fields in &lt;code&gt;author&lt;/code&gt;, as they are identical to &lt;code&gt;committer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; 著者情報はコミッターの情報と異なる可能性がある場合、コマンドは、必要に応じて、表示されることがあります。 &lt;code&gt;author&lt;/code&gt; が省略されている場合、高速インポートでは、コミットの著者部分にコミッターの情報が自動的に使用されます。 &lt;code&gt;author&lt;/code&gt; のフィールドは &lt;code&gt;committer&lt;/code&gt; と同じであるため、以下の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="2ca13f668178d4001fb40c21d014f07bacdba23a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;upload-archive&lt;/code&gt; also exists to serve &lt;code&gt;git archive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;upload-archive&lt;/code&gt; また、提供するために存在している &lt;code&gt;git archive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2777cee48df007e662d7335b2a99199ee01a9bf5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; is identified by its 160-bit SHA-1 hash, aka &lt;em&gt;object name&lt;/em&gt;, and a reference to an object is always the 40-byte hex representation of that SHA-1 name. The files in the &lt;code&gt;refs&lt;/code&gt; subdirectory are expected to contain these hex references (usually with a final &lt;code&gt;\n&lt;/code&gt; at the end), and you should thus expect to see a number of 41-byte files containing these references in these &lt;code&gt;refs&lt;/code&gt; subdirectories when you actually start populating your tree.</source>
          <target state="translated">&lt;em&gt;オブジェクトは、&lt;/em&gt;別名、その160ビットSHA-1ハッシュによって識別された&lt;em&gt;オブジェクト名&lt;/em&gt;、及びオブジェクトへの参照は、常にそのSHA-1名の40バイトの16進表現です。 &lt;code&gt;refs&lt;/code&gt; サブディレクトリ内のファイルには、これらの16進参照が含まれていることが予想されます（通常、最後に &lt;code&gt;\n&lt;/code&gt; 付いています）。したがって、実際に起動すると、これらの &lt;code&gt;refs&lt;/code&gt; サブディレクトリにこれらの参照を含む41バイトのファイルが多数表示されるはずです。あなたのツリーを埋める。</target>
        </trans-unit>
        <trans-unit id="a56c50d5220ee34a87c6403dce1dee00fe1f60bc" translate="yes" xml:space="preserve">
          <source>An advanced user may want to take a look at &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; after finishing this tutorial.</source>
          <target state="translated">上級ユーザーは、このチュートリアルを終了した後で&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;を確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2ba7e65ac14d1c1843ebc23a20f7a824d2e90d69" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;--discard-changes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--discard-changes&lt;/code&gt; のエイリアス。</target>
        </trans-unit>
        <trans-unit id="1c482877d68de7df403d2a569fe4e9b8337d6d28" translate="yes" xml:space="preserve">
          <source>An alternate participant submission mechanism is using the &lt;code&gt;git request-pull&lt;/code&gt; or pull-request mechanisms (e.g as used on GitHub (www.github.com) to notify your upstream of your contribution.</source>
          <target state="translated">代替の参加者 &lt;code&gt;git request-pull&lt;/code&gt; メカニズムは、gitリクエスト-プルまたはプルリクエストメカニズム（GitHub（www.github.com）で使用されるメカニズムなど）を使用して、コントリビューションをアップストリームに通知します。</target>
        </trans-unit>
        <trans-unit id="4308fb9f973f309f701eb31f44b62bb9dad115a0" translate="yes" xml:space="preserve">
          <source>An alternative scp-like syntax may also be used with the ssh protocol:</source>
          <target state="translated">代替の scp ライクな構文を ssh プロトコルで使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3e45d63c9493efc9c482c8956b2b502b296e599f" translate="yes" xml:space="preserve">
          <source>An alternative style can be used by setting the &quot;merge.conflictStyle&quot; configuration variable to &quot;diff3&quot;. In &quot;diff3&quot; style, the above conflict may look like this:</source>
          <target state="translated">merge.conflictStyle&quot; 設定変数に &quot;diff3&quot; を設定することで、別のスタイルを使用することができます。diff3」スタイルでは、上記のコンフリクトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b9a3606b6f09bb975ca3b2fd930ed7cfdb47c5de" translate="yes" xml:space="preserve">
          <source>An application using git-credential will typically use &lt;code&gt;git
credential&lt;/code&gt; following these steps:</source>
          <target state="translated">git-credentialを使用するアプリケーションは、通常、次の手順に従って &lt;code&gt;git credential&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="ae3f33e4c0349221e2575da0576bccf42d579897" translate="yes" xml:space="preserve">
          <source>An asterisk &quot;&lt;code&gt;*&lt;/code&gt;&quot; matches anything except a slash. The character &quot;&lt;code&gt;?&lt;/code&gt;&quot; matches any one character except &quot;&lt;code&gt;/&lt;/code&gt;&quot;. The range notation, e.g. &lt;code&gt;[a-zA-Z]&lt;/code&gt;, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.</source>
          <target state="translated">アスタリスク「 &lt;code&gt;*&lt;/code&gt; 」は、スラッシュ以外のすべてと一致します。文字「 &lt;code&gt;?&lt;/code&gt; 」は、「 &lt;code&gt;/&lt;/code&gt; 」以外の任意の1文字と一致します。 &lt;code&gt;[a-zA-Z]&lt;/code&gt; などの範囲表記を使用して、範囲内の文字の1つに一致させることができます。詳細については、fnmatch（3）およびFNM_PATHNAMEフラグを参照してください。</target>
        </trans-unit>
        <trans-unit id="f92a93236adb7a911f096656f0a19e52c91fc87c" translate="yes" xml:space="preserve">
          <source>An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart&amp;rsquo;s content, and you can remove them. The list looks more or less like this:</source>
          <target state="translated">エディターは、現在のブランチ（マージコミットを無視）内のすべてのコミットで起動します。これらのコミットは、指定されたコミットの後に来ます。このリストのコミットを思い通りに並べ替えたり、削除したりできます。リストは多かれ少なかれこのように見えます：</target>
        </trans-unit>
        <trans-unit id="3034dd5f2cb814d90a3721e980abfe2559bdf7b3" translate="yes" xml:space="preserve">
          <source>An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely.</source>
          <target state="translated">空の色文字列は、色の効果を全く発生させません。これは、色を完全に無効にせずに特定の要素に色を付けないようにするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="2425d5d7f13cfb1e5013987fec335bdb279cc21f" translate="yes" xml:space="preserve">
          <source>An evil merge is a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; that introduces changes that do not appear in any &lt;a href=&quot;#def_parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="translated">悪意のあるマージは、どの&lt;a href=&quot;#def_parent&quot;&gt;親&lt;/a&gt;にも表示されない変更を導入する&lt;a href=&quot;#def_merge&quot;&gt;マージ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="983a5c1c22b13082f53d4ffac58905fc5683444c" translate="yes" xml:space="preserve">
          <source>An example crash:</source>
          <target state="translated">墜落の例。</target>
        </trans-unit>
        <trans-unit id="b7fefb821701ed8916b003bdc64ab026062f47d5" translate="yes" xml:space="preserve">
          <source>An example directly producing formatted text. Show the most recent 3 tagged commits:</source>
          <target state="translated">フォーマットされたテキストを直接生成する例。最近のタグ付けされた3つのコミットを表示します。</target>
        </trans-unit>
        <trans-unit id="07b3f3938c0999bf8d07073e13ae4fad78c37982" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). This prefixes the current branch with a star.</source>
          <target state="translated">％（if）&amp;hellip;％（then）&amp;hellip;％（else）&amp;hellip;％（end）の使用法を示す例。これは、現在のブランチの前にスターを付けます。</target>
        </trans-unit>
        <trans-unit id="130d3057e79f4ea0755954d533ec854202e8c665" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(end). This prints the authorname, if present.</source>
          <target state="translated">％（if）&amp;hellip;％（then）&amp;hellip;％（end）の使用法を示す例。これは、もしあれば著者名を表示します。</target>
        </trans-unit>
        <trans-unit id="0dd4a6b345a98548ae1d0552b0faaa4bc7a8afb7" translate="yes" xml:space="preserve">
          <source>An example to use customized color from the configuration in your script:</source>
          <target state="translated">スクリプトの設定からカスタマイズされた色を使用する例。</target>
        </trans-unit>
        <trans-unit id="5e3fe250825ac46db801c9bc9679b73fba035132" translate="yes" xml:space="preserve">
          <source>An example value is &amp;ldquo;Tue Feb 6 11:22:18 2007 -0500&amp;rdquo;. The Git parser is accurate, but a little on the lenient side. It is the same parser used by &lt;code&gt;git am&lt;/code&gt; when applying patches received from email.</source>
          <target state="translated">値の例は、「Tue Feb 6 11:22:18 2007 -0500」です。Gitパーサーは正確ですが、少し緩やかです。これは、メールから受け取ったパッチを適用するときに &lt;code&gt;git am&lt;/code&gt; が使用するのと同じパーサーです。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="67bf2af305e53a13545716b037aa5bc68e4afad9" translate="yes" xml:space="preserve">
          <source>An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub is branched by copying it to branches/. &lt;code&gt;git svn clone -s&lt;/code&gt; will then create a branch &lt;code&gt;sub&lt;/code&gt;. It will also create new Git commits for r.100 through r.199 and use these as the history of branch &lt;code&gt;sub&lt;/code&gt;. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch &lt;code&gt;sub@200&lt;/code&gt; pointing to the new parent commit of branch &lt;code&gt;sub&lt;/code&gt; (i.e. the commit for r.200 and trunk/sub/).</source>
          <target state="translated">例：標準のトランク/タグ/ブランチレイアウトのSVNリポジトリでは、r.100にディレクトリtrunk / subが作成されます。 r.200では、trunk / subは、branches /にコピーすることによって分岐されます。 &lt;code&gt;git svn clone -s&lt;/code&gt; は、ブランチ &lt;code&gt;sub&lt;/code&gt; を作成します。また、r.100からr.199までの新しいGitコミットを作成し、これらをブランチ &lt;code&gt;sub&lt;/code&gt; の履歴として使用します。したがって、r.100からr.199までのリビジョンごとに2つのGitコミットがあります（1つはtrunk /を含み、1つはtrunk / sub /を含みます）。最後に、それはブランチが作成されます &lt;code&gt;sub@200&lt;/code&gt; 新しい親がブランチのコミットにポインティング &lt;code&gt;sub&lt;/code&gt; （すなわちr.200とトランク/サブ/のコミット）。</target>
        </trans-unit>
        <trans-unit id="7e6df9fde9d9b1a6c24b6fde6ccfb6d951abd515" translate="yes" xml:space="preserve">
          <source>An existing tree object.</source>
          <target state="translated">既存のツリーオブジェクト。</target>
        </trans-unit>
        <trans-unit id="9c0f47829cd53aff363faaa441d2662f7d2a2298" translate="yes" xml:space="preserve">
          <source>An extended regular expression configuring a set of delta islands. See &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details.</source>
          <target state="translated">デルタアイランドのセットを構成する拡張正規表現。詳細については、&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]の&lt;/a&gt;「DELTA ISLANDS」を参照してください。</target>
        </trans-unit>
        <trans-unit id="e8771c0542061da31756f7f028cf42efc80a6790" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating a default compression level. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If set, this provides a default to other compression variables, such as &lt;code&gt;core.looseCompression&lt;/code&gt; and &lt;code&gt;pack.compression&lt;/code&gt;.</source>
          <target state="translated">デフォルトの圧縮レベルを示す整数-1..9。-1はzlibのデフォルトです。0は圧縮なしを意味し、1..9はさまざまな速度/サイズのトレードオフであり、9が最も遅くなります。設定されている場合、これは、 &lt;code&gt;core.looseCompression&lt;/code&gt; や &lt;code&gt;pack.compression&lt;/code&gt; などの他の圧縮変数にデフォルトを提供します。</target>
        </trans-unit>
        <trans-unit id="433b558671525ba8e4d4299bcca156947818bc47" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to -1, the zlib default, which is &quot;a default compromise between speed and compression (currently equivalent to level 6).&quot;</source>
          <target state="translated">1 ~ 9 の整数で、パックファイル内のオブジェクトの圧縮レベルを指定します。-1 は zlib のデフォルト値です。0 は圧縮なしを意味し、1~9 は様々な速度/サイズのトレードオフを表し、9 が最も遅いことを意味します。設定されていない場合は、デフォルトは core.compression です。これが設定されていなければ、デフォルトは core.compression になります。これは zlib のデフォルトで、&quot;速度と圧縮の間のデフォルトの妥協点 (現在のところレベル 6 と同等)&quot; です。</target>
        </trans-unit>
        <trans-unit id="e06d94c2c1c7fdd4fbd64a16fb4219ebbe8c1e07" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects that are not in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to 1 (best speed).</source>
          <target state="translated">1 ~ 9 の整数で、パックファイルに含まれないオブジェクトの圧縮レベルを指定します。-1 は zlib のデフォルト値です。0 は圧縮なしを意味し、1~9 は様々な速度/サイズのトレードオフを表し、9 は最も遅いことを意味します。設定されていない場合は、デフォルトは core.compression です。設定されていない場合は、デフォルトは 1 (最高速度)です。</target>
        </trans-unit>
        <trans-unit id="7a8d9172fe4750854d99468288f15a393b3d2a0b" translate="yes" xml:space="preserve">
          <source>An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.</source>
          <target state="translated">整数のパラメータにはカットオフパーセントを指定します (デフォルトでは 3%)。この割合よりも少ない割合で変更に貢献したディレクトリは、出力には表示されません。</target>
        </trans-unit>
        <trans-unit id="71479e10da1fa6d725307efac957175acd0b7dab" translate="yes" xml:space="preserve">
          <source>An integer port number to connect to on the server. Defaults to 143 for imap:// hosts and 993 for imaps:// hosts. Ignored when imap.tunnel is set.</source>
          <target state="translated">サーバー上で接続するポート番号を整数で指定します。デフォルトは imap://hosts では 143、imaps://hosts では 993 です。imap.tunnel が設定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="a13bd69f2aba7e28daf03425a855478a0ac87c0e" translate="yes" xml:space="preserve">
          <source>An object to treat as the head of an unreachability trace.</source>
          <target state="translated">到達不能トレースの先頭として扱うオブジェクト。</target>
        </trans-unit>
        <trans-unit id="649450686ab487a5807b370d54f0bd2d0e6521d8" translate="yes" xml:space="preserve">
          <source>An offset within the jth packfile for the object.</source>
          <target state="translated">オブジェクトの jth パックファイル内のオフセット。</target>
        </trans-unit>
        <trans-unit id="13fd616698d842e6abe0ccbaaa14a722ac806da4" translate="yes" xml:space="preserve">
          <source>An optimized way to tell git &quot;all files have changed&quot; is to return the filename &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">gitに「すべてのファイルが変更された」ことを通知する最適化された方法は、ファイル名 &lt;code&gt;/&lt;/code&gt; を返すことです。</target>
        </trans-unit>
        <trans-unit id="2683b05f238ac5f24ee58eef90d2e93c4d292853" translate="yes" xml:space="preserve">
          <source>An optional prefix &quot;&lt;code&gt;!&lt;/code&gt;&quot; which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn&amp;rsquo;t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first &quot;&lt;code&gt;!&lt;/code&gt;&quot; for patterns that begin with a literal &quot;&lt;code&gt;!&lt;/code&gt;&quot;, for example, &quot;&lt;code&gt;\!important!.txt&lt;/code&gt;&quot;.</source>
          <target state="translated">パターンを否定するオプションの接頭辞「 &lt;code&gt;!&lt;/code&gt; 」。以前のパターンによって除外された一致するファイルは、再び含まれます。そのファイルの親ディレクトリが除外されている場合、ファイルを再インクルードすることはできません。 Gitはパフォーマンス上の理由で除外されたディレクトリをリストしません。そのため、含まれているファイルのパターンは、それらが定義されている場所に関係なく、効果がありません。リテラル「 &lt;code&gt;!&lt;/code&gt; 」で始まるパターン（たとえば、「 &lt;code&gt;\!important!.txt&lt;/code&gt; 」）の最初の「 &lt;code&gt;!&lt;/code&gt; 」の前にバックスラッシュ（「 &lt;code&gt;\&lt;/code&gt; 」）を置きます。</target>
        </trans-unit>
        <trans-unit id="72eb40b71a3ee1287d4bc59941eb7d52450fb0cd" translate="yes" xml:space="preserve">
          <source>An output line is formatted this way:</source>
          <target state="translated">出力行はこのようにフォーマットされています。</target>
        </trans-unit>
        <trans-unit id="39328bc4d54c0b1f8244ab4fbfc2b0861f3ec8b7" translate="yes" xml:space="preserve">
          <source>An update will fail (without changing &amp;lt;ref&amp;gt;) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available.</source>
          <target state="translated">現在のユーザーが新しいログファイルを作成できない、既存のログファイルに追加できない、または使用可能なコミッター情報がない場合、更新は（&amp;lt;ref&amp;gt;を変更せずに）失敗します。</target>
        </trans-unit>
        <trans-unit id="dc6309284d4ffb9f9db9b99bb2400d242ab3d042" translate="yes" xml:space="preserve">
          <source>Ancillary Commands</source>
          <target state="translated">補助コマンド</target>
        </trans-unit>
        <trans-unit id="690298b04d34764749d8b6b774f1017ccff2bdf1" translate="yes" xml:space="preserve">
          <source>And &quot;p4 branch -o branch1&quot; shows a View line that looks like:</source>
          <target state="translated">そして「p4 branch -o branch1」を見ると、以下のようなView行が表示されています。</target>
        </trans-unit>
        <trans-unit id="06312e404b0eeaa83f6e7b08d3417e9f32eb7193" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; would print the same thing, as would &lt;code&gt;HEAD:dir/link&lt;/code&gt;, as they both point at &lt;code&gt;HEAD:f&lt;/code&gt;.</source>
          <target state="translated">そして &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; は、 &lt;code&gt;HEAD:dir/link&lt;/code&gt; と同じものを出力します。どちらも &lt;code&gt;HEAD:f&lt;/code&gt; を指すためです。</target>
        </trans-unit>
        <trans-unit id="e8ef2a07032d9e5ab4fbc79e4cc5adecbcbea354" translate="yes" xml:space="preserve">
          <source>And after a few more steps like that, &quot;git bisect&quot; will eventually find a first bad commit:</source>
          <target state="translated">そして、そのようにいくつかのステップを踏んだ後、「git bisect」は最終的には最初の悪いコミットを見つけることになります。</target>
        </trans-unit>
        <trans-unit id="5e2acfea5a7223f44ca9fe3e573c07079e7f8361" translate="yes" xml:space="preserve">
          <source>And even if a bisection fails today it tells us something valuable about the bug: that it&amp;rsquo;s non-deterministic - timing or kernel image layout dependent.</source>
          <target state="translated">そして、二分法が今日失敗しても、それはバグについて何か価値のあることを教えてくれます。それは非決定的であるということです-タイミングまたはカーネルイメージのレイアウトに依存します。</target>
        </trans-unit>
        <trans-unit id="85f0203157ace1141f1dde2ae30a3fa8a3636c88" translate="yes" xml:space="preserve">
          <source>And finally create the final commit.</source>
          <target state="translated">そして最後に最終的なコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="860e42dc488be31ffa7a020df965384765242565" translate="yes" xml:space="preserve">
          <source>And here is what Andreas said about this work-flow &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;:</source>
          <target state="translated">アンドレアスがこのワークフローについて言ったことは次のとおりです&lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01892e1eb858acb775eb9592a4003c7fc4445cdb" translate="yes" xml:space="preserve">
          <source>And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the &quot;bad&quot; commit you have which may be very wasteful.</source>
          <target state="translated">そして、いくつかのバグがテストスイートをすり抜けた場合は、テストスイートにテストを追加することができます。しかし、新しい改良されたテストスイートを使ってどこにバグがすり抜けたのかを見つけたい場合は、二分法をエミュレートしなければならないか、あるいは「悪い」コミットから後ろ向きに各コミットをテストすることになるでしょう。</target>
        </trans-unit>
        <trans-unit id="15b39a143fb8659118caee67f4b21c31bc36bf3c" translate="yes" xml:space="preserve">
          <source>And it is possible to replay it using:</source>
          <target state="translated">そして、それを使って再生することが可能です。</target>
        </trans-unit>
        <trans-unit id="75822a1512d331a3d4633273030648c95f9328f4" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s take a commit X in the graph.</source>
          <target state="translated">グラフのコミットXを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f4b0d8092d1f5d252ea539a91373ab642092fc55" translate="yes" xml:space="preserve">
          <source>And move the first patch to the end of the list.</source>
          <target state="translated">そして、最初のパッチをリストの最後に移動させます。</target>
        </trans-unit>
        <trans-unit id="43f0cc168dfe6f57e4c3a310a06a6b6b3c95713b" translate="yes" xml:space="preserve">
          <source>And of course you can combine all of these; the following finds commits since v2.5 which touch the &lt;code&gt;Makefile&lt;/code&gt; or any file under &lt;code&gt;fs&lt;/code&gt;:</source>
          <target state="translated">そしてもちろん、これらすべてを組み合わせることができます。以下は、 &lt;code&gt;Makefile&lt;/code&gt; または &lt;code&gt;fs&lt;/code&gt; の下のファイルを操作するv2.5以降のコミットを検索します。</target>
        </trans-unit>
        <trans-unit id="4c90b40159743f0c37c98cf280277c74b4f36f16" translate="yes" xml:space="preserve">
          <source>And testing can be done more often in special integration branches like linux-next for the linux kernel.</source>
          <target state="translated">また、linux-nextのような特別な統合ブランチでは、linuxカーネルのテストをより頻繁に行うことができます。</target>
        </trans-unit>
        <trans-unit id="de647a064a0da49ca37de783bfbd65b321bef2ec" translate="yes" xml:space="preserve">
          <source>And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:</source>
          <target state="translated">そして、これはIngo Molnar (Linuxカーネルの開発者としてよく知られている)がgit bisectを使っていることについて言っていることです。</target>
        </trans-unit>
        <trans-unit id="66491a56d29baec4b0beb6e367fe2e638c6cc60b" translate="yes" xml:space="preserve">
          <source>And then we can ask to see all the commits reachable from master but not from these other heads:</source>
          <target state="translated">そして、マスターからは到達可能だが、他のヘッドからは到達できないコミットを見るように要求することができます。</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">そして、その後。</target>
        </trans-unit>
        <trans-unit id="dc5ba14bf614a8d9b59a130fcae6a5153ba0970b" translate="yes" xml:space="preserve">
          <source>And this is nice because at step 2) we compute number_of_ancestors(X) and so at step 3) we compute f(X).</source>
          <target state="translated">そして、ステップ2)で number_of_ancestors(X)を計算し、ステップ3)で f(X)を計算するので、これは素晴らしいことです。</target>
        </trans-unit>
        <trans-unit id="8cc4b2a34ee7e169dafe705c6dd15bf4f2ab80f2" translate="yes" xml:space="preserve">
          <source>And this is true because at step 1) b) we remove the ancestors of the &quot;good&quot; commits.</source>
          <target state="translated">そして、ステップ1)b)で「良い」コミットの先祖を取り除くので、これは真実です。</target>
        </trans-unit>
        <trans-unit id="42d3703f66b9dc1860841e2625f510f6dad5a4b2" translate="yes" xml:space="preserve">
          <source>And this is where we create the &lt;code&gt;.git/refs/heads/master&lt;/code&gt; file which is pointed at by &lt;code&gt;HEAD&lt;/code&gt;. This file is supposed to contain the reference to the top-of-tree of the master branch, and since that&amp;rsquo;s exactly what &lt;code&gt;git commit-tree&lt;/code&gt; spits out, we can do this all with a sequence of simple shell commands:</source>
          <target state="translated">そして、ここで &lt;code&gt;HEAD&lt;/code&gt; が指す &lt;code&gt;.git/refs/heads/master&lt;/code&gt; ファイルを作成します。このファイルには、マスターブランチのツリーのトップへの参照が含まれることになっています。これは、 &lt;code&gt;git commit-tree&lt;/code&gt; が正確に出力するものであるため、一連の単純なシェルコマンドでこれをすべて実行できます。</target>
        </trans-unit>
        <trans-unit id="e7a1c872c4878ac6e52bac1154940404cb212eeb" translate="yes" xml:space="preserve">
          <source>And when we are finished we can use &quot;git bisect reset&quot; to go back to the branch we were in before we started bisecting:</source>
          <target state="translated">そして、それが終わったら &quot;git bisect reset&quot; を使って、bisect を始める前のブランチに戻ることができます。</target>
        </trans-unit>
        <trans-unit id="36ca616a13091cd678c7050cbd59b751c0ca0cb5" translate="yes" xml:space="preserve">
          <source>And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released.</source>
          <target state="translated">そして、あるブランチで作業している人が、別のブランチで作業している人がバグを修正したことに気づかないということは、実際に起こり得ることです。また、F が複数のバグを修正していたり、リリースする準備ができていなかった大きな開発努力の反動であったりすることもあります。</target>
        </trans-unit>
        <trans-unit id="dc2b5b20cbff6f0447bfb79a46815513c19063a1" translate="yes" xml:space="preserve">
          <source>And, as you can see with cat-file, this new entry refers to the current contents of the file:</source>
          <target state="translated">そして、cat-fileを見ればわかるように、この新しいエントリは現在のファイルの内容を参照しています。</target>
        </trans-unit>
        <trans-unit id="a03f7e1dc1779f7a6b6058b743b6c59117c067d5" translate="yes" xml:space="preserve">
          <source>Annotate file lines with commit information</source>
          <target state="translated">コミット情報でファイル行に注釈を付ける</target>
        </trans-unit>
        <trans-unit id="fe64bd304ff43d1f92c6b0e9e2636f5e1954515e" translate="yes" xml:space="preserve">
          <source>Annotate only the given line range. May be specified multiple times. Overlapping ranges are allowed.</source>
          <target state="translated">指定された行範囲のみをアノテーションします。複数回指定できます。重複した範囲を指定することができます。</target>
        </trans-unit>
        <trans-unit id="a4227402e63911eeddf3891b83571a9d301c5199" translate="yes" xml:space="preserve">
          <source>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like &lt;code&gt;git describe&lt;/code&gt;) will ignore lightweight tags by default.</source>
          <target state="translated">注釈付きタグはリリース用であり、軽量タグはプライベートまたは一時的なオブジェクトラベル用です。このため、オブジェクトに名前を付けるための一部のgitコマンド（ &lt;code&gt;git describe&lt;/code&gt; など）は、デフォルトでは軽量タグを無視します。</target>
        </trans-unit>
        <trans-unit id="fb074164892a20bb11edd02087ea8ad1467c6bc3" translate="yes" xml:space="preserve">
          <source>Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:</source>
          <target state="translated">注釈付きタグが誤って軽量タグに変換されてしまうことがありますが、これは2つの問題のどちらかが原因です。</target>
        </trans-unit>
        <trans-unit id="78661c20ec385a35ca13b1d1faa523521f8f6f6e" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision.</source>
          <target state="translated">与えられたファイルの各行に、その行を導入したコミットからの情報をアノテーションします。オプションで、指定されたリビジョンからアノテーションを行います。</target>
        </trans-unit>
        <trans-unit id="372eac78f459ab911a94fedbdc320e48ccdbf71b" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision.</source>
          <target state="translated">与えられたファイルの各行に、その行を最後に変更したリビジョンの情報をアノテーションします。オプションで、指定されたリビジョンからアノテーションを開始します。</target>
        </trans-unit>
        <trans-unit id="b09d247a13d19963c95ef0e9b47f19d8e2953d8d" translate="yes" xml:space="preserve">
          <source>Anonymize the contents of the repository while still retaining the shape of the history and stored tree. See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="translated">履歴と保存されたツリーの形状を保持したまま、リポジトリのコンテンツを匿名化します。以下の &lt;code&gt;ANONYMIZING&lt;/code&gt; に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a01e013ecca5b260c6867926bf1ecfcf398d9ba1" translate="yes" xml:space="preserve">
          <source>Anonymizing</source>
          <target state="translated">Anonymizing</target>
        </trans-unit>
        <trans-unit id="40a85528d14ebc97736a92adba47c86eb9ff2aeb" translate="yes" xml:space="preserve">
          <source>Another example of --onto option is to rebase part of a branch. If we have the following situation:</source>
          <target state="translated">他にも --onto オプションの例として、ブランチの一部をリベースするというものがあります。以下のような状況になったとします。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">別の例です。</target>
        </trans-unit>
        <trans-unit id="11987472d58c6aa8430ac38a3fd3bf9cba4916dd" translate="yes" xml:space="preserve">
          <source>Another example: Find out what to do in order to make some script a builtin:</source>
          <target state="translated">別の例です。いくつかのスクリプトをビルトイン化するために何をすべきかを調べてください。</target>
        </trans-unit>
        <trans-unit id="065628e1fb0324bb656fd86df1e08ab2f4715fb3" translate="yes" xml:space="preserve">
          <source>Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made.</source>
          <target state="translated">もう一つの良いアイデアは、良いコミットメッセージを持つことです。これらのメッセージは、なぜ変更が加えられたのかを理解するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="32dd386169e45600451de31b5f03542af4e30d00" translate="yes" xml:space="preserve">
          <source>Another nice thing you can do is:</source>
          <target state="translated">もう一ついいことがあります。</target>
        </trans-unit>
        <trans-unit id="9242e709d07837df4600256193a227ac34a2269c" translate="yes" xml:space="preserve">
          <source>Another option is &quot;updateInstead&quot; which will update the working tree if pushing into the current branch. This option is intended for synchronizing working directories when one side is not easily accessible via interactive ssh (e.g. a live web site, hence the requirement that the working directory be clean). This mode also comes in handy when developing inside a VM to test and fix code on different Operating Systems.</source>
          <target state="translated">もう一つのオプションは &quot;updateInstead&quot; で、現在のブランチにプッシュした場合に作業ツリーを更新します。このオプションは、一方の側がインタラクティブな ssh 経由で容易にアクセスできない場合 (ライブの Web サイトなどでは、作業ディレクトリがクリーンである必要があります)に、作業ディレクトリを同期させることを目的としています。このモードは、異なるオペレーティングシステム上でコードをテストしたり修正したりするために VM 内で開発する場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="41abbfafae0720017768935474ce8290c706a151" translate="yes" xml:space="preserve">
          <source>Another possible improvement to &quot;git bisect&quot; would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs.</source>
          <target state="translated">git bisect&quot; のもうひとつの改良点は、散発的に発生するバグを追跡する際の信頼性を高めるために、テストの冗長性をオプションで追加することです。</target>
        </trans-unit>
        <trans-unit id="0a6527778973bccd7f71c735f492db2e31da9fa5" translate="yes" xml:space="preserve">
          <source>Another special notation is &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&amp;hellip;​&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:</source>
          <target state="translated">別の特別な表記がある「 &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; 」マージのために有用です。結果のコミットのセットは、2つのオペランドの対称的な違いです。次の2つのコマンドは同等です。</target>
        </trans-unit>
        <trans-unit id="26135d7c8f5f59da8beefa37e9b70a51b7cf91c1" translate="yes" xml:space="preserve">
          <source>Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable &quot;sparse checkout&quot; because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file content as follows:</source>
          <target state="translated">もう1つのトリッキーなことは、スパースチェックアウトが不要になったときに、作業ディレクトリを完全に再設定することです。「スパースチェックアウト」を無効にすることはできません。スキップワークツリービットがまだインデックスにあり、作業ディレクトリがまだまばらに入力されているためです。次のように、 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; ファイルの内容を作業ディレクトリに再入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="ecb7d4f32d7593e5037a022410f521fabccc479c" translate="yes" xml:space="preserve">
          <source>Another use of the content filtering is to store the content that cannot be directly used in the repository (e.g. a UUID that refers to the true content stored outside Git, or an encrypted content) and turn it into a usable form upon checkout (e.g. download the external content, or decrypt the encrypted content).</source>
          <target state="translated">コンテンツフィルタリングのもう一つの使い方は、リポジトリ内で直接使えないコンテンツ(例:Gitの外部に保存されている真のコンテンツを指すUUIDや暗号化されたコンテンツ)を保存しておき、チェックアウト時に使える形にする(例:外部コンテンツをダウンロードする、暗号化されたコンテンツを復号化する)というものです。</target>
        </trans-unit>
        <trans-unit id="1d8a0103b0697a268e7a45a45f3916e77fac0c3e" translate="yes" xml:space="preserve">
          <source>Another useful tool, especially if you do not always work in X-Window environment, is &lt;code&gt;git show-branch&lt;/code&gt;.</source>
          <target state="translated">特にX-Window環境で常に作業するとは限らない場合に便利なもう1つのツールは、 &lt;code&gt;git show-branch&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d7b5fb1eb9536e4fd859b841771a0add7272b354" translate="yes" xml:space="preserve">
          <source>Another way to collaborate is by using a model similar to that commonly used in CVS, where several developers with special rights all push to and pull from a single shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for instructions on how to set this up.</source>
          <target state="translated">コラボレーションのもう1つの方法は、CVSで一般的に使用されているものと同様のモデルを使用することです。このモデルでは、特別な権限を持つ複数の開発者がすべて1つの共有リポジトリに対してプッシュおよびプルを行います。これを設定する方法については、&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27bf2b0b2701454d4c7012f3aa28342f714d532f" translate="yes" xml:space="preserve">
          <source>Another way to submit changes to a project is to tell the maintainer of that project to pull the changes from your repository using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;. In the section &quot;&lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt;Getting updates with &lt;code&gt;git pull&lt;/code&gt;&lt;/a&gt;&quot; we described this as a way to get updates from the &quot;main&quot; repository, but it works just as well in the other direction.</source>
          <target state="translated">プロジェクトに変更を送信する別の方法は、そのプロジェクトのメンテナーに&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;を使用してリポジトリから変更をプルするように伝えることです。「&lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt; &lt;code&gt;git pull&lt;/code&gt; を使用した&lt;/a&gt;更新の取得」セクションでは、これを「メイン」リポジトリから更新を取得する方法として説明しましたが、それは逆方向でも同様に機能します。</target>
        </trans-unit>
        <trans-unit id="85d232111ed1b21837987efa570715d6d841ade7" translate="yes" xml:space="preserve">
          <source>Any Git command accepting any &amp;lt;object&amp;gt; can also use the following symbolic notation:</source>
          <target state="translated">&amp;lt;object&amp;gt;を受け入れるGitコマンドでは、次の記号表記も使用できます。</target>
        </trans-unit>
        <trans-unit id="2637aa3ab721e22e9e92fa0dc5c3b142c43c70b8" translate="yes" xml:space="preserve">
          <source>Any Git command that needs to know a commit can take any of these names. For example:</source>
          <target state="translated">コミットを知る必要がある Git コマンドは、これらの名前のいずれかを取ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="17e0ecc60216ae45d014af4558855c0627e28395" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will be rewritten to start, instead, with &amp;lt;base&amp;gt;. In cases where some site serves a large number of repositories, and serves them with multiple access methods, and some users need to use different access methods, this feature allows people to specify any of the equivalent URLs and have Git automatically rewrite the URL to the best alternative for the particular user, even for a never-before-seen repository on the site. When more than one insteadOf strings match a given URL, the longest match is used.</source>
          <target state="translated">この値で始まるURLは、&amp;lt;base&amp;gt;で始まるように書き換えられます。一部のサイトが多数のリポジトリを提供し、複数のアクセス方法でそれらを提供し、一部のユーザーが異なるアクセス方法を使用する必要がある場合、この機能により、ユーザーは同等のURLを指定し、GitにURLを自動的に書き換えさせることができます。サイト上のこれまでに見たことのないリポジトリであっても、特定のユーザーにとって最良の代替手段です。指定されたURLに複数のsteadyOf文字列が一致する場合、最長一致が使用されます。</target>
        </trans-unit>
        <trans-unit id="589cf27f168023444a88c2fd0201931be3237bfb" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will not be pushed to; instead, it will be rewritten to start with &amp;lt;base&amp;gt;, and the resulting URL will be pushed to. In cases where some site serves a large number of repositories, and serves them with multiple access methods, some of which do not allow push, this feature allows people to specify a pull-only URL and have Git automatically use an appropriate URL to push, even for a never-before-seen repository on the site. When more than one pushInsteadOf strings match a given URL, the longest match is used. If a remote has an explicit pushurl, Git will ignore this setting for that remote.</source>
          <target state="translated">この値で始まるURLはプッシュされません。代わりに、&amp;lt;base&amp;gt;で始まるように書き換えられ、結果のURLがプッシュされます。一部のサイトが多数のリポジトリを提供し、それらに複数のアクセス方法を提供する場合（プッシュを許可しないものもある）、この機能により、ユーザーはプル専用URLを指定し、Gitに適切なURLを使用してプッシュさせることができます。サイト上のこれまでに見たことのないリポジトリであっても。複数のpushInsteadOf文字列が特定のURLに一致する場合、最長一致が使用されます。リモートに明示的なpushurlがある場合、Gitはそのリモートのこの設定を無視します。</target>
        </trans-unit>
        <trans-unit id="82a7e54a4e4438b5714cd3ea8d9c648126a4d9c8" translate="yes" xml:space="preserve">
          <source>Any arguments that control the behaviour of the action.</source>
          <target state="translated">アクションの動作を制御する任意の引数。</target>
        </trans-unit>
        <trans-unit id="90454bd170fd9408c974e42887247b5e22880026" translate="yes" xml:space="preserve">
          <source>Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding. (This happens whether or not --msg-filter is used.)</source>
          <target state="translated">git-filter-branch はエンコーディングを無視して元のバイトを取り、適切なエンコーディングを伝えずにそれを commit-tree に送ります (--msg-filter が使われているかどうかは関係ありません)。(--msg-filter が使われていても使われていなくても、これは起こります)。</target>
        </trans-unit>
        <trans-unit id="5b932d4d430aaf425c61def387b1d5f7272350dc" translate="yes" xml:space="preserve">
          <source>Any commits (or tags) that have already been marked will not be exported again. If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs.</source>
          <target state="translated">既にマークされているコミット(またはタグ)は再度エクスポートされません。バックエンドが同様の --import-marks ファイルを使用している場合、これを使用することで、実行中に同じマークを維持することで、リポジトリのインクリメンタルな双方向エクスポートが可能になります。</target>
        </trans-unit>
        <trans-unit id="f3f9b66d28d85d6e19fdb5a2a58f610b82508a43" translate="yes" xml:space="preserve">
          <source>Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an &lt;code&gt;rsync&lt;/code&gt; with some other site in the hopes that somebody else has the object you have corrupted).</source>
          <target state="translated">バックアップまたは他のアーカイブで見つけなければならない破損したオブジェクト（つまり、それらを削除して、他の誰かがあなたが破損したオブジェクトを持っていることを期待して、他のサイトと &lt;code&gt;rsync&lt;/code&gt; を実行できます）。</target>
        </trans-unit>
        <trans-unit id="881f628d30dc8f906e6314a57d637b480027cf97" translate="yes" xml:space="preserve">
          <source>Any diff-generating command can take the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt; option to produce a &lt;code&gt;combined diff&lt;/code&gt; when showing a merge. This is the default format when showing merges with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; or &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;. Note also that you can give the &lt;code&gt;-m&lt;/code&gt; option to any of these commands to force generation of diffs with individual parents of a merge.</source>
          <target state="translated">すべてのdiff-generatingコマンドは、マージを表示するときに &lt;code&gt;-c&lt;/code&gt; または &lt;code&gt;--cc&lt;/code&gt; オプションを使用して、 &lt;code&gt;combined diff&lt;/code&gt; を生成できます。これは&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;または&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;でマージを表示するときのデフォルトのフォーマットです。これらのコマンドのいずれかに &lt;code&gt;-m&lt;/code&gt; オプションを指定して、マージの個々の親との差分を強制的に生成できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="693fa01c32bbb0a692d5b48b48158d26bcd64f81" translate="yes" xml:space="preserve">
          <source>Any line that is added in one location and was removed in another location will be colored with &lt;code&gt;color.diff.newMoved&lt;/code&gt;. Similarly &lt;code&gt;color.diff.oldMoved&lt;/code&gt; will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.</source>
          <target state="translated">ある場所に追加され、別の場所で削除された行は、 &lt;code&gt;color.diff.newMoved&lt;/code&gt; で色付けされます。同様に、 &lt;code&gt;color.diff.oldMoved&lt;/code&gt; は、差分の別の場所に追加された削除された行に使用されます。このモードは、移動された行をピックアップしますが、コードブロックが順列なしで移動されたかどうかを確認するレビューではあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="7e51f4c4f56de2a2384662213d8799137a1187ad" translate="yes" xml:space="preserve">
          <source>Any nontrivial feature will require several patches to implement, and may get extra bugfixes or improvements during its lifetime.</source>
          <target state="translated">非自明な機能は、実装するために数回のパッチを必要とし、その間にバグフィックスや改善が追加されることがあります。</target>
        </trans-unit>
        <trans-unit id="d98b5885c45b32a708919758a9a90750e9cf4885" translate="yes" xml:space="preserve">
          <source>Any object with modification time newer than the &lt;code&gt;--prune&lt;/code&gt; date is kept, along with everything reachable from it.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 日付よりも変更時刻が新しいオブジェクトは、そこから到達可能なすべてのものとともに保持されます。</target>
        </trans-unit>
        <trans-unit id="57cde5a06f278fc117497921cb6730239da3eb9d" translate="yes" xml:space="preserve">
          <source>Any objects created by the &lt;code&gt;pre-receive&lt;/code&gt; hook will be created in the quarantine directory (and migrated only if it succeeds).</source>
          <target state="translated">&lt;code&gt;pre-receive&lt;/code&gt; フックによって作成されたオブジェクトはすべて隔離ディレクトリに作成されます（成功した場合にのみ移行されます）。</target>
        </trans-unit>
        <trans-unit id="5f15852fd98f4e7d5fcff8be14576b9b3b53c8dc" translate="yes" xml:space="preserve">
          <source>Any of the credential.* options above can be applied selectively to some credentials. For example &quot;credential.https://example.com.username&quot; would set the default username only for https connections to example.com. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details on how URLs are matched.</source>
          <target state="translated">上記のcredential。*オプションは、一部の資格情報に選択的に適用できます。たとえば、「credential.https：//example.com.username」は、example.comへのhttps接続にのみデフォルトのユーザー名を設定します。参照してください&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;のURLが一致している方法の詳細について。</target>
        </trans-unit>
        <trans-unit id="bac0fc50e3c83a77179d2fb9959cd57efc236587" translate="yes" xml:space="preserve">
          <source>Any of the http.* options above can be applied selectively to some URLs. For a config key to match a URL, each element of the config key is compared to that of the URL, in the following order:</source>
          <target state="translated">上記の http.*オプションは、いくつかの URL に選択的に適用することができます。設定キーが URL にマッチするためには、設定キーの各要素が URL のそれと比較されます。</target>
        </trans-unit>
        <trans-unit id="3dafc51d2498886776211f48626918bab9502059" translate="yes" xml:space="preserve">
          <source>Any other arguments are passed directly to &lt;code&gt;git log&lt;/code&gt;</source>
          <target state="translated">その他の引数は直接 &lt;code&gt;git log&lt;/code&gt; に渡されます</target>
        </trans-unit>
        <trans-unit id="41dff852ecf280a28625475c8607b0ee485f1ab1" translate="yes" xml:space="preserve">
          <source>Any other exit code will abort the bisect process. It should be noted that a program that terminates via &lt;code&gt;exit(-1)&lt;/code&gt; leaves $? = 255, (see the exit(3) manual page), as the value is chopped with &lt;code&gt;&amp;amp; 0377&lt;/code&gt;.</source>
          <target state="translated">他の終了コードはbisectプロセスを中止します。 &lt;code&gt;exit(-1)&lt;/code&gt; で終了するプログラムは$？を残すことに注意してください。= 255、値がでチョップされているように、（出口（3）マニュアルページを参照） &lt;code&gt;&amp;amp; 0377&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="642004f414daf9dcdfd792ec1198534a94bdecbe" translate="yes" xml:space="preserve">
          <source>Any other value causes Git to act as if &lt;code&gt;text&lt;/code&gt; has been left unspecified.</source>
          <target state="translated">他の値を指定すると、Git は &lt;code&gt;text&lt;/code&gt; が指定されていないままになっているように動作します。</target>
        </trans-unit>
        <trans-unit id="c934a0e2885189af1607d7090f7bdedd35f47c56" translate="yes" xml:space="preserve">
          <source>Any submodule changes are reported as modified &lt;code&gt;M&lt;/code&gt; instead of &lt;code&gt;m&lt;/code&gt; or single &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">サブモジュールの変更は、 &lt;code&gt;m&lt;/code&gt; またはsingle ではなく変更された &lt;code&gt;M&lt;/code&gt; として報告され &lt;code&gt;?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c7f540cc43682f246f3211715ad8ff43ff2cc9b" translate="yes" xml:space="preserve">
          <source>Any valid Git SHA-1 expression that resolves to a commit. See &amp;ldquo;SPECIFYING REVISIONS&amp;rdquo; in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">コミットに解決される任意の有効なGit SHA-1式。詳細については、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]の&lt;/a&gt;「リビジョンの指定」を参照してください。</target>
        </trans-unit>
        <trans-unit id="f7d956d491ba987cc8588aff431085dc6fef94e0" translate="yes" xml:space="preserve">
          <source>Anyway &quot;git rebase&quot; can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch.</source>
          <target state="translated">とにかく &quot;git rebase&quot; は履歴を線形化するために使うことができます。これは、そもそもマージを避けるために使うこともできますし、非線形の履歴を二等分するために使うこともできます。あるいは、非線形の履歴ではなく線形の履歴を二分するために使うこともできます。</target>
        </trans-unit>
        <trans-unit id="0e59b76f5bd0befb4dbe4de65fbbfc975d414db1" translate="yes" xml:space="preserve">
          <source>Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same &quot;tree&quot; in git parlance). That&amp;rsquo;s because Z' result from applying the same changes as Z just in a slightly different order.</source>
          <target state="translated">とにかく、上記の特別なブランチの例では、Z 'とZのコミットが同じソースコードの状態（git用語では同じ「ツリー」）を指す必要があることに気付くでしょう。これは、Z 'がZと同じ変更をわずかに異なる順序で適用した結果であるためです。</target>
        </trans-unit>
        <trans-unit id="b6009c11bd52cccb479f468a5d30bb80204ccc20" translate="yes" xml:space="preserve">
          <source>Anyway, as we mentioned previously, you normally never actually take a look at the objects themselves, and typing long 40-character hex names is not something you&amp;rsquo;d normally want to do. The above digression was just to show that &lt;code&gt;git update-index&lt;/code&gt; did something magical, and actually saved away the contents of your files into the Git object database.</source>
          <target state="translated">とにかく、前述したように、通常は実際にオブジェクト自体を確認することは決してなく、長い40文字の16進数名を入力することは、通常、実行したくないことではありません。上記の余談は、 &lt;code&gt;git update-index&lt;/code&gt; が不思議なことを行い、実際にファイルの内容をGitオブジェクトデータベースに保存したことを示すためのものです。</target>
        </trans-unit>
        <trans-unit id="868e50b230265adc5a12e0fabfef64c97f0dfb44" translate="yes" xml:space="preserve">
          <source>Anyway, let&amp;rsquo;s exit &lt;code&gt;gitk&lt;/code&gt; (&lt;code&gt;^Q&lt;/code&gt; or the File menu), and decide that we want to merge the work we did on the &lt;code&gt;mybranch&lt;/code&gt; branch into the &lt;code&gt;master&lt;/code&gt; branch (which is currently our &lt;code&gt;HEAD&lt;/code&gt; too). To do that, there&amp;rsquo;s a nice script called &lt;code&gt;git merge&lt;/code&gt;, which wants to know which branches you want to resolve and what the merge is all about:</source>
          <target state="translated">とにかく、 &lt;code&gt;gitk&lt;/code&gt; （ &lt;code&gt;^Q&lt;/code&gt; または[ファイル]メニュー）を終了して、 &lt;code&gt;mybranch&lt;/code&gt; ブランチで行った作業を &lt;code&gt;master&lt;/code&gt; ブランチ（現在も &lt;code&gt;HEAD&lt;/code&gt; です）にマージすることを決定します。それを行うには、解決したいブランチとマージの内容を知りたい &lt;code&gt;git merge&lt;/code&gt; という素晴らしいスクリプトがあります。</target>
        </trans-unit>
        <trans-unit id="4dd4f1d29aada84809b848ed1f3cfeec94f509cd" translate="yes" xml:space="preserve">
          <source>Anyway, once you are sure that you&amp;rsquo;re not interested in any dangling state, you can just prune all unreachable objects:</source>
          <target state="translated">とにかく、ぶら下がっている状態に興味がないことが確実になったら、到達できないすべてのオブジェクトを削除できます。</target>
        </trans-unit>
        <trans-unit id="0af8b356773c7cf5ba56c2406453ade92d5ac3c1" translate="yes" xml:space="preserve">
          <source>Apache 2.x</source>
          <target state="translated">アパッチ2.x</target>
        </trans-unit>
        <trans-unit id="62093635aebe85cb9943f4c0313c4cb13ae431e5" translate="yes" xml:space="preserve">
          <source>Apache as CGI</source>
          <target state="translated">アパッチ</target>
        </trans-unit>
        <trans-unit id="fcf355a3b504d322d867b3a7779ff63edb5eff93" translate="yes" xml:space="preserve">
          <source>Apache must be configured to support CGI scripts in the directory in which gitweb is installed. Let&amp;rsquo;s assume that it is &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; directory.</source>
          <target state="translated">Apacheは、gitwebがインストールされているディレクトリでCGIスクリプトをサポートするように設定する必要があります。それが &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; ディレクトリであると仮定しましょう。</target>
        </trans-unit>
        <trans-unit id="adce44ce9fd05dba8366c6738436e24094334a46" translate="yes" xml:space="preserve">
          <source>Apache with FastCGI</source>
          <target state="translated">Apache と FastCGI</target>
        </trans-unit>
        <trans-unit id="154d9ee4c57b9c60297467031aab475139a92de6" translate="yes" xml:space="preserve">
          <source>Apache with mod_perl, via ModPerl::Registry</source>
          <target state="translated">modPerl::Registry を介した mod_perl での Apache</target>
        </trans-unit>
        <trans-unit id="0e7319c6d9f1793811603c0e586a372fe36cd4e3" translate="yes" xml:space="preserve">
          <source>Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for &lt;code&gt;blame_usage&lt;/code&gt;:</source>
          <target state="translated">Gitは、ファイルアノテーションのサポートとは別に、コードスニペットが変更時に発生した場合の開発履歴の検索もサポートしています。これにより、コードスニペットがファイルに追加され、ファイル間で移動またはコピーされ、最終的に削除または置換された時期を追跡できます。差分でテキスト文字列を検索することで機能します。つるはしインタフェースの小さな例を検索している &lt;code&gt;blame_usage&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d7464dc71494394ceb8bfdacf997c37cf7b2fe0" translate="yes" xml:space="preserve">
          <source>Append &quot;exec &amp;lt;cmd&amp;gt;&quot; after each line creating a commit in the final history. &amp;lt;cmd&amp;gt; will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.</source>
          <target state="translated">最終履歴でコミットを作成する各行の後に「exec &amp;lt;cmd&amp;gt;」を追加します。&amp;lt;cmd&amp;gt;は、1つ以上のシェルコマンドとして解釈されます。失敗したコマンドは、終了コード1でリベースを中断します。</target>
        </trans-unit>
        <trans-unit id="ef04cef4b0401f57059733c71c586ba695e16618" translate="yes" xml:space="preserve">
          <source>Append ref names and object names of fetched refs to the existing contents of &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. Without this option old data in &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; will be overwritten.</source>
          <target state="translated">フェッチされた参照の参照名とオブジェクト名を &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; の既存の内容に追加します。このオプションがないと、 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 内の古いデータが上書きされます。</target>
        </trans-unit>
        <trans-unit id="94dedcc5d01b91b42b1e3ae2801d2b001bfa9291" translate="yes" xml:space="preserve">
          <source>Append the notes (see &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;) for the commit after the three-dash line.</source>
          <target state="translated">3ダッシュ線の後にコミットの注釈（&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]を&lt;/a&gt;参照）を追加します。</target>
        </trans-unit>
        <trans-unit id="60b0cf67b9a78690ab42bf05c5a970037b617230" translate="yes" xml:space="preserve">
          <source>Append this string to each commit message. Set to empty string to disable this feature. Defaults to &quot;via git-CVS emulator&quot;.</source>
          <target state="translated">この文字列を各コミットメッセージに追加します。空の文字列を指定すると、この機能を無効にします。デフォルトは &quot;via git-CVS emulator&quot; です。</target>
        </trans-unit>
        <trans-unit id="2373a40d8b684d9b213d526a29e87b69fa3f0b45" translate="yes" xml:space="preserve">
          <source>Append to the notes of an existing object (defaults to HEAD). Creates a new notes object if needed.</source>
          <target state="translated">既存のオブジェクトのノートに追加します(デフォルトは HEAD)。必要に応じて、新しいノートオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="64fff387ef07a8a383c37886a7516866c065d733" translate="yes" xml:space="preserve">
          <source>Appendix a: git quick reference</source>
          <target state="translated">付録 a:git クイックリファレンス</target>
        </trans-unit>
        <trans-unit id="505428ce9360d60afb175c3a83b181da98dfd5f0" translate="yes" xml:space="preserve">
          <source>Appendix b: notes and todo list for this manual</source>
          <target state="translated">付録B:本書の注意点とToDoリスト</target>
        </trans-unit>
        <trans-unit id="0cd05b54bd7b3a6c1bc46851a5cc57ae9e4714f4" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset.</source>
          <target state="translated">キルトパッチセットを現在の Git ブランチに適用し、キルトパッチセットに含まれるパッチの境界、パッチの順番、パッチの説明を保持します。</target>
        </trans-unit>
        <trans-unit id="a7cac5d66c52938bbdbd6bb2ccc1b2a1e469d6e9" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current branch</source>
          <target state="translated">キルトのパッチセットを現在のブランチに適用します。</target>
        </trans-unit>
        <trans-unit id="0ace5fe552ca52b3206a5bd3ee6c81166a6d4e30" translate="yes" xml:space="preserve">
          <source>Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation. Do not issue the final &quot;p4 submit&quot;, but instead print a message about how to submit manually or revert. This option always stops after the first (oldest) commit. Git tags are not exported to p4.</source>
          <target state="translated">p4 ワークスペースにコミットを適用し、通常の投稿操作と同様に p4 でファイルを開いたり、追加したり、削除したりします。最終的な &quot;p4 submit &quot;は発行せず、手動での提出方法や元に戻す方法についてのメッセージを表示します。このオプションは常に最初の (最も古い)コミットの後で停止します。Git タグは p4 にはエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="48f2321ef5db21359607b635bc37d95c3c3f6949" translate="yes" xml:space="preserve">
          <source>Apply a patch to files and/or to the index</source>
          <target state="translated">ファイルやインデックスにパッチを適用する</target>
        </trans-unit>
        <trans-unit id="bd267fa176f80df21611314430fb619c6c0ca823" translate="yes" xml:space="preserve">
          <source>Apply a patch without touching the working tree. Instead take the cached data, apply the patch, and store the result in the index without using the working tree. This implies &lt;code&gt;--index&lt;/code&gt;.</source>
          <target state="translated">作業ツリーに触れずにパッチを適用します。代わりに、キャッシュされたデータを取得してパッチを適用し、作業ツリーを使用せずに結果をインデックスに格納します。これは &lt;code&gt;--index&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="9e6f2e44329517aef587c18d6b7620bb801018d0" translate="yes" xml:space="preserve">
          <source>Apply a series of patches from a mailbox</source>
          <target state="translated">メールボックスから一連のパッチを適用する</target>
        </trans-unit>
        <trans-unit id="7e0339ba7940213ee941e0cfb4df5c765eb525b6" translate="yes" xml:space="preserve">
          <source>Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories.</source>
          <target state="translated">指定されたパスパターンにマッチするファイルに変更を適用します。これは、パッチセットをインポートする際に、特定のファイルやディレクトリをインポートしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="62ad9c2cc3b0c429c18e394c154429c6601a33bc" translate="yes" xml:space="preserve">
          <source>Apply it:</source>
          <target state="translated">それを適用します。</target>
        </trans-unit>
        <trans-unit id="9537fc12221a208866b0d5f4bdeb3c72a1e2302e" translate="yes" xml:space="preserve">
          <source>Apply the &quot;clean&quot; process freshly to all tracked files to forcibly add them again to the index. This is useful after changing &lt;code&gt;core.autocrlf&lt;/code&gt; configuration or the &lt;code&gt;text&lt;/code&gt; attribute in order to correct files added with wrong CRLF/LF line endings. This option implies &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="translated">追跡されたすべてのファイルに新たに「クリーン」プロセスを適用して、強制的に再度インデックスに追加します。これは、間違ったCRLF / LF行末で追加されたファイルを修正するために、 &lt;code&gt;core.autocrlf&lt;/code&gt; 構成または &lt;code&gt;text&lt;/code&gt; 属性を変更した後に役立ちます。このオプションは &lt;code&gt;-u&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="3387547d9c3f57336c6769472fbdaa2f41d8d54e" translate="yes" xml:space="preserve">
          <source>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.</source>
          <target state="translated">マスターブランチの先端にあるコミットで導入された変更を適用し、この変更で新しいコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="dcad7381c75ab9bcebba4ec36c60788e21cc232d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.</source>
          <target state="translated">READMEに触れたmasterブランチ上のすべてのコミットで導入された変更を作業ツリーとインデックスに適用し、結果を検査し、適切であれば単一の新しいコミットにすることができるようにします。</target>
        </trans-unit>
        <trans-unit id="0cd6111442f7f7c96f0cf43ef692ab3fd0aeaf35" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean &lt;code&gt;maint&lt;/code&gt; and everything between &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;; specifically, &lt;code&gt;maint&lt;/code&gt; will not be used if it is included in &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">maintまたはnextの祖先であり、masterまたはその祖先のいずれでもないすべてのコミットによって導入された変更を適用します。後者は &lt;code&gt;maint&lt;/code&gt; と &lt;code&gt;master&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; すべてを意味するわけではないことに注意してください。具体的には、 &lt;code&gt;maint&lt;/code&gt; が &lt;code&gt;master&lt;/code&gt; に含まれている場合、maintは使用されません。</target>
        </trans-unit>
        <trans-unit id="93bf7e7b652d09afeef199594d1b407f0e89fdfa" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.</source>
          <target state="translated">master の先祖であって HEAD の先祖ではないすべてのコミットで導入された変更を適用し、新しいコミットを生成します。</target>
        </trans-unit>
        <trans-unit id="267d59350d3cc9c55b8eac43fb7124a86e3e2e8d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by some existing commits</source>
          <target state="translated">既存のコミットで導入された変更を適用する</target>
        </trans-unit>
        <trans-unit id="4483cddab281b7008c2024c5cf39c925a712d6f4" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.</source>
          <target state="translated">master が指摘した 5 番目と 3 番目の最後のコミットで導入した変更を適用し、その変更を反映した 2 つの新しいコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="32e6df839ae5866b7658a0152bc89b8703c2e9dc" translate="yes" xml:space="preserve">
          <source>Apply the patch in reverse.</source>
          <target state="translated">逆にパッチを当てます。</target>
        </trans-unit>
        <trans-unit id="88f8070d0672eae136d921241ac9866b7f235114" translate="yes" xml:space="preserve">
          <source>Apply the specified refspec to each ref exported. Multiple of them can be specified.</source>
          <target state="translated">エクスポートした各refに指定したrefspecを適用します。複数指定可能です。</target>
        </trans-unit>
        <trans-unit id="7fd7e8ac68a94d08f0fdbfcbab3475962ee42209" translate="yes" xml:space="preserve">
          <source>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.</source>
          <target state="translated">master が指す 2 番目の最後のコミットと next が指す最後のコミットによって導入された変更を作業ツリーとインデックスに適用しますが、これらの変更を含むコミットは作成しないでください。</target>
        </trans-unit>
        <trans-unit id="0cd32c5cf17ab15de02490afcc460874d487a4cd" translate="yes" xml:space="preserve">
          <source>Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call &lt;code&gt;git stash drop&lt;/code&gt; manually afterwards.</source>
          <target state="translated">状態の適用は競合で失敗する可能性があります。この場合、スタッシュリストからは削除されません。競合を手動で解決し、後で手動で &lt;code&gt;git stash drop&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="956519c248d491798436fec0428abbdf91cbc909" translate="yes" xml:space="preserve">
          <source>Approach #1 (add-on)</source>
          <target state="translated">アプローチ#1(アドオン</target>
        </trans-unit>
        <trans-unit id="57f019c85346bddb5f41fba94e7c74787f47bd0d" translate="yes" xml:space="preserve">
          <source>Approach #2 (configuration)</source>
          <target state="translated">アプローチ#2(構成</target>
        </trans-unit>
        <trans-unit id="bb297e0ad30a52de0d35c2e51c324455cc5006ef" translate="yes" xml:space="preserve">
          <source>Approach #3 (external editor)</source>
          <target state="translated">アプローチその3(外部編集者</target>
        </trans-unit>
        <trans-unit id="6a4c02b7a9497dd0187742b95b941fbc3f472c18" translate="yes" xml:space="preserve">
          <source>Arbitrary extended SHA-1 expression (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) that typically names a branch head or a tag.</source>
          <target state="translated">通常はブランチヘッドまたはタグに名前を付ける任意の拡張SHA-1式（&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="99d8ff22bcfacdaff98940313c6f7a07ddd4cf65" translate="yes" xml:space="preserve">
          <source>Archive/branch identifier in a format that &lt;code&gt;tla log&lt;/code&gt; understands.</source>
          <target state="translated">&lt;code&gt;tla log&lt;/code&gt; が理解できる形式のアーカイブ/ブランチ識別子。</target>
        </trans-unit>
        <trans-unit id="872da414bff0647443183643c537cf06ff00de53" translate="yes" xml:space="preserve">
          <source>Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="translated">引数 --depth は、各リモートブランチ履歴の先端からではなく、現在の浅い境界からのコミット数を指定します。</target>
        </trans-unit>
        <trans-unit id="5f7cc8b7282309c04b6094d3e942d3596636318c" translate="yes" xml:space="preserve">
          <source>Argument disambiguation</source>
          <target state="translated">引数の曖昧性の解消</target>
        </trans-unit>
        <trans-unit id="fd50e821541e889c251a37edf6c132e6475912dc" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;git rev-list&lt;/code&gt;. All positive refs included by these options are rewritten. You may also specify options such as &lt;code&gt;--all&lt;/code&gt;, but you must use &lt;code&gt;--&lt;/code&gt; to separate them from the &lt;code&gt;git filter-branch&lt;/code&gt; options. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; の引数。これらのオプションに含まれるすべての正の参照は書き換えられます。 &lt;code&gt;--all&lt;/code&gt; などのオプションを指定することもできますが、これらを &lt;code&gt;git filter-branch&lt;/code&gt; オプションから分離するには、 &lt;code&gt;--&lt;/code&gt; を使用する必要があります。&lt;a href=&quot;#Remap_to_ancestor&quot;&gt;先祖への&lt;/a&gt;リマップを意味します。</target>
        </trans-unit>
        <trans-unit id="345e43f16973168887e556514ee57c8062a62d30" translate="yes" xml:space="preserve">
          <source>Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1. Here the current object is the object creation command the &lt;code&gt;mark&lt;/code&gt; command appears within. This can be &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, and &lt;code&gt;blob&lt;/code&gt;, but &lt;code&gt;commit&lt;/code&gt; is the most common usage.</source>
          <target state="translated">高速インポートが現在のオブジェクトへの参照を保存するように調整し、フロントエンドがSHA-1を知らなくても、将来のある時点でこのオブジェクトを呼び出すことができるようにします。ここで、現在のオブジェクトは、 &lt;code&gt;mark&lt;/code&gt; コマンドが表示されるオブジェクト作成コマンドです。これは、することができ &lt;code&gt;commit&lt;/code&gt; 、 &lt;code&gt;tag&lt;/code&gt; 、および &lt;code&gt;blob&lt;/code&gt; が、 &lt;code&gt;commit&lt;/code&gt; 最も一般的な使用方法です。</target>
        </trans-unit>
        <trans-unit id="63f07e2039af4b87f8fad3f523ac66820be39017" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; は、 GitのもしrefnameまたはSHA-1の発現は有効ではありませんが、ノー引用またはエスケープ構文が内に支持される &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41e120dada68dd444b90dd5ea02098a2591a6678" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;checkpoint&lt;/code&gt; can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single &lt;code&gt;checkpoint&lt;/code&gt; command to complete.</source>
          <target state="translated">&lt;code&gt;checkpoint&lt;/code&gt; CPU時間とディスクIO、かなりの量を必要とすることができ、容易に単一のために数分かかることがあります（対応するインデックスファイルを生成し、全体的なパックSHA-1チェックサムを計算し、参照文献を更新するために） &lt;code&gt;checkpoint&lt;/code&gt; を完全にコマンド。</target>
        </trans-unit>
        <trans-unit id="cdb295aae55f7fada69cf590bc90ed14f2b247f0" translate="yes" xml:space="preserve">
          <source>As a consequence, the &lt;code&gt;merge base&lt;/code&gt; is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; when used with the &lt;code&gt;--merge-base&lt;/code&gt; option.</source>
          <target state="translated">結果として、3 つ以上のコミットが指定されている場合、 &lt;code&gt;merge base&lt;/code&gt; は必ずしも各コミット引数に含まれているとは限りません。これは、 &lt;code&gt;--merge-base&lt;/code&gt; オプションとともに使用した場合の&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;とは異なります。</target>
        </trans-unit>
        <trans-unit id="dbf2a4b63177a116bbc3cf47e4c27a09d7f0ef0f" translate="yes" xml:space="preserve">
          <source>As a convenience measure, &lt;code&gt;git merge&lt;/code&gt; automatically invokes &lt;code&gt;git rerere&lt;/code&gt; upon exiting with a failed automerge and &lt;code&gt;git rerere&lt;/code&gt; records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not. &lt;code&gt;git commit&lt;/code&gt; also invokes &lt;code&gt;git rerere&lt;/code&gt; when committing a merge result. What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable).</source>
          <target state="translated">コンビニエンス対策として、 &lt;code&gt;git merge&lt;/code&gt; 自動的に起動します &lt;code&gt;git rerere&lt;/code&gt; 失敗した自動マージを出る際と &lt;code&gt;git rerere&lt;/code&gt; 、それが新たな紛争である、またはそれがないときに、以前の手の決意を再利用するときの手の決意を記録します。 &lt;code&gt;git commit&lt;/code&gt; は、マージ結果をコミットするときに &lt;code&gt;git rerere&lt;/code&gt; も呼び出します。つまり、rerere.enabled構成変数を有効にする以外に、自分で特別なことを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="152aaf1da15e40e4974ab4fba1bc2c82b319de92" translate="yes" xml:space="preserve">
          <source>As a general rule, you should try to split your changes into small logical steps, and commit each of them. They should be consistent, working independently of any later commits, pass the test suite, etc. This makes the review process much easier, and the history much more useful for later inspection and analysis, for example with &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; and &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt;.</source>
          <target state="translated">原則として、変更を小さな論理的なステップに分割し、それぞれをコミットする必要があります。それらは一貫性があり、その後のコミットとは独立して動作し、テストスイートに合格するなどする必要があります。これにより、レビュープロセスがはるかに簡単になり、履歴は、たとえば&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;や&lt;a href=&quot;git-bisect&quot;&gt;gitを&lt;/a&gt;使用した後の検査や分析に非常に役立ちます。-bisect [1]。</target>
        </trans-unit>
        <trans-unit id="813a368009448480dbec96398e42a0584e7bd447" translate="yes" xml:space="preserve">
          <source>As a given feature goes from experimental to stable, it also &quot;graduates&quot; between the corresponding branches of the software. &lt;code&gt;git.git&lt;/code&gt; uses the following &lt;code&gt;integration branches&lt;/code&gt;:</source>
          <target state="translated">特定の機能が実験的から安定したものになると、ソフトウェアの対応するブランチ間で「卒業」します。 &lt;code&gt;git.git&lt;/code&gt; は次の &lt;code&gt;integration branches&lt;/code&gt; 使用します：</target>
        </trans-unit>
        <trans-unit id="b64fd0a9b4f65c1520607403d9b5b0753895060e" translate="yes" xml:space="preserve">
          <source>As a last resort, you can search for the corrupted objects and attempt to replace them by hand. Back up your repository before attempting this in case you corrupt things even more in the process.</source>
          <target state="translated">最後の手段として、破損したオブジェクトを検索して、手で置き換えることができます。これを試みる前にリポジトリをバックアップしておきましょう。</target>
        </trans-unit>
        <trans-unit id="55349f46b4e35ef9e012280dbd1cc43373573ca9" translate="yes" xml:space="preserve">
          <source>As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word &quot;commit&quot; is often used by Git in the same places other revision control systems use the words &quot;revision&quot; or &quot;version&quot;. Also used as a short hand for &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;.</source>
          <target state="translated">名詞として：Gitの歴史における単一のポイント。プロジェクトの全履歴は、相互に関連する一連のコミットとして表されます。「コミット」という単語は、他のリビジョン管理システムが「リビジョン」または「バージョン」という単語を使用するのと同じ場所でGitによってよく使用されます。&lt;a href=&quot;#def_commit_object&quot;&gt;コミットオブジェクトの&lt;/a&gt;短縮形としても使用されます。</target>
        </trans-unit>
        <trans-unit id="ff1fc843fbc05442df0cf0a8f29973ba8fa37083" translate="yes" xml:space="preserve">
          <source>As a noun: unless it is a &lt;a href=&quot;#def_fast_forward&quot;&gt;fast-forward&lt;/a&gt;, a successful merge results in the creation of a new &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; representing the result of the merge, and having as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; the tips of the merged &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;. This commit is referred to as a &quot;merge commit&quot;, or sometimes just a &quot;merge&quot;.</source>
          <target state="translated">名詞として：&lt;a href=&quot;#def_fast_forward&quot;&gt;早送りで&lt;/a&gt;ない限り、マージが成功すると、マージの結果&lt;a href=&quot;#def_commit&quot;&gt;を&lt;/a&gt;表す新しいコミットが作成され、マージされた&lt;a href=&quot;#def_branch&quot;&gt;ブランチの&lt;/a&gt;ヒントが&lt;a href=&quot;#def_parent&quot;&gt;親に&lt;/a&gt;なります。このコミットは「マージコミット」または「マージ」と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="c1c9a37d68f66f1f75bfd831a2c5dd7a1272c9cd" translate="yes" xml:space="preserve">
          <source>As a real example, this is how I update my public Git repository. Kernel.org mirror network takes care of the propagation to other publicly visible machines:</source>
          <target state="translated">実際の例として、これは私が公開している Git リポジトリを更新する方法です。Kernel.org のミラーネットワークが、他の公開されているマシンへの伝搬の世話をしてくれます。</target>
        </trans-unit>
        <trans-unit id="d1e2c8156579db2980e4a3d9117d5ad5706a2358" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt;
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">その結果、オブジェクトの一般的な一貫性は、オブジェクトのコンテンツやタイプに関係なく常にテストできます。すべてのオブジェクトは、（a）ハッシュがファイルのコンテンツと一致していること、および（b）オブジェクトを検証することで検証できます。 &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt; &amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt; シーケンスを形成するバイトストリームに正常に拡張します。</target>
        </trans-unit>
        <trans-unit id="1a86b8dd400c7fa63fb2fa4b8a7674ea4f9c20d3" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert a range-diff (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3
feature/v2&lt;/code&gt;), or a revision range if the two versions of the series are disjoint (for example &lt;code&gt;git format-patch --cover-letter
--range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">レビュー担当者の補助として、範囲差（&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]を&lt;/a&gt;参照）をカバーレターに挿入するか、1パッチシリーズの唯一のパッチのコメントとして、以前のバージョンのパッチの違いを示します。シリーズおよび現在フォーマットされているシリーズ。 &lt;code&gt;previous&lt;/code&gt; は、フォーマットされるシリーズと共通のベースを共有する場合、前のシリーズの先端に名前を付ける単一のリビジョンにすることができます（たとえば、 &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2&lt;/code&gt; ）、またはシリーズの2つのバージョンがばらばらである場合のリビジョン範囲（たとえば、 &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7fd619ea41aade7bb01c884d2572b761cf9ff25b" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example &lt;code&gt;git format-patch
--cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">レビュー担当者の補助として、カバーレターに相互差分を挿入するか、1パッチシリーズの単独パッチの解説として、以前のバージョンのパッチシリーズと現在フォーマットされているシリーズの違いを示します。 &lt;code&gt;previous&lt;/code&gt; は、フォーマットされているシリーズと共通のベースを共有する前のシリーズの先端に名前を付ける単一のリビジョンです（たとえば、 &lt;code&gt;git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a396a38596332774142e3633350d3c5ee12f3978" translate="yes" xml:space="preserve">
          <source>As a special case for the date-type fields, you may specify a format for the date by adding &lt;code&gt;:&lt;/code&gt; followed by date format name (see the values the &lt;code&gt;--date&lt;/code&gt; option to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; takes).</source>
          <target state="translated">日付タイプのフィールドの特殊なケースとして、 &lt;code&gt;:&lt;/code&gt; の後に日付フォーマット名を追加して、日付のフォーマットを指定できます（&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;の &lt;code&gt;--date&lt;/code&gt; オプションの値を参照）。</target>
        </trans-unit>
        <trans-unit id="45ade4e7bdf6353bad954746718b0b4bd913e21c" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will 'not' update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="translated">特別な場合として、 &lt;code&gt;git update-index --refresh&lt;/code&gt; を実行することもできます。これにより、各インデックスの「統計」情報が更新され、現在の統計情報と一致します。オブジェクトのステータス自体は更新されず、オブジェクトが古いバッキングストアオブジェクトとまだ一致しているかどうかをすばやくテストするために使用されるフィールドのみが更新されます。</target>
        </trans-unit>
        <trans-unit id="4f896fc12182c6581528d02b73cafa58c18c0571" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &quot;A...B&quot; as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.</source>
          <target state="translated">特殊なケースとして、A と B のマージベースが正確に一つの場合、&quot;A...B&quot; を A と B のマージベースのショートカットとして使用することができます。A と B のどちらか一方だけを省略することもできますが、その場合は HEAD がデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="f60f56407a2b12c7ab7900d72be353ae897d29d5" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、マージベースが1つしかない場合は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; のマージベースのショートカットとして &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; を使用できます。 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の最大1つを &lt;code&gt;HEAD&lt;/code&gt; ます。その場合、デフォルトでHEADになります。</target>
        </trans-unit>
        <trans-unit id="10cc0995f68a1af6b96ca8bc169efe97ff360947" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;A...B&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; のマージベースが1つしかない場合は、AとBのマージベースのショートカットとして &lt;code&gt;A...B&lt;/code&gt; を使用できます。 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の最大1つを &lt;code&gt;HEAD&lt;/code&gt; ます。その場合、デフォルトでHEADになります。</target>
        </trans-unit>
        <trans-unit id="c98a50738baa944b04be5906cf4230cda7da50f7" translate="yes" xml:space="preserve">
          <source>As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents.</source>
          <target state="translated">特別な拡張として、コミットフィルタは複数のコミット ID を出力することができます。</target>
        </trans-unit>
        <trans-unit id="014231faf08aed1fd006d6569258568e8c26510e" translate="yes" xml:space="preserve">
          <source>As a special shortcut,</source>
          <target state="translated">特殊なショートカットとして</target>
        </trans-unit>
        <trans-unit id="4df53d3c6d9483bf31546176476f770bb64d7028" translate="yes" xml:space="preserve">
          <source>As a verb: The action of storing a new snapshot of the project&amp;rsquo;s state in the Git history, by creating a new commit representing the current state of the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and advancing &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; to point at the new commit.</source>
          <target state="translated">動詞として：プロジェクトの状態の新しいスナップショットをGit履歴に保存するアクション。&lt;a href=&quot;#def_index&quot;&gt;インデックスの&lt;/a&gt;現在の状態を表す新しいコミットを作成し、新しいコミットを指すように&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;を進めます。</target>
        </trans-unit>
        <trans-unit id="e121b03809309d600afd50d432f7cbb397b47657" translate="yes" xml:space="preserve">
          <source>As a verb: To bring the contents of another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; (possibly from an external &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first &lt;a href=&quot;#def_fetch&quot;&gt;fetching&lt;/a&gt; the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a &lt;a href=&quot;#def_pull&quot;&gt;pull&lt;/a&gt;. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge.</source>
          <target state="translated">動詞として：（おそらく外部&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;から）別の&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;のコンテンツを現在のブランチに取り込むこと。マージされたブランチが別のリポジトリからのものである場合、これは最初にリモートブランチを&lt;a href=&quot;#def_fetch&quot;&gt;フェッチ&lt;/a&gt;してから、結果を現在のブランチにマージすることによって行われます。このフェッチ操作とマージ操作の組み合わせは、&lt;a href=&quot;#def_pull&quot;&gt;プル&lt;/a&gt;と呼ばれます。マージは、ブランチの分岐以降に行われた変更を識別し、それらの変更をすべて一緒に適用する自動プロセスによって実行されます。変更が競合する場合、マージを完了するために手動の介入が必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="30669ffae471bf3f6383626501505c5e90309074" translate="yes" xml:space="preserve">
          <source>As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below).</source>
          <target state="translated">アクティブなブランチは、そのブランチに含まれるファイルのメタデータを保存するので、そのメモリ内ストレージのサイズはかなりの大きさになる可能性があります (以下を参照)。</target>
        </trans-unit>
        <trans-unit id="5905e313567b9a612b1c4b05bb63adbe4c8ba180" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:</source>
          <target state="translated">別の方法として、トピックブランチにテストマージを含まないようにするには、テストマージを吹き飛ばして、テストマージの前にチップの上にビルドを続けるという方法もあります。</target>
        </trans-unit>
        <trans-unit id="cabda80231ec81bd47e1b2a8cca346f3b12eb94b" translate="yes" xml:space="preserve">
          <source>As an example use case, consider the following commit history:</source>
          <target state="translated">使用例として、以下のようなコミット履歴を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d1cfcd564d3c903d2d8f64e4c4116cc502a9ccb3" translate="yes" xml:space="preserve">
          <source>As an example, a typical orderfile for the core Git probably would look like this:</source>
          <target state="translated">例えば、コアGitの典型的なオーダーファイルは、おそらく次のようになるでしょう。</target>
        </trans-unit>
        <trans-unit id="393e086dc57d2576b08e508b4c5a81ba83fe2ed2" translate="yes" xml:space="preserve">
          <source>As an example, suppose you are trying to find the commit that broke a feature that was known to work in version &lt;code&gt;v2.6.13-rc2&lt;/code&gt; of your project. You start a bisect session as follows:</source>
          <target state="translated">例として、プロジェクトのバージョン &lt;code&gt;v2.6.13-rc2&lt;/code&gt; で動作することがわかっている機能に違反したコミットを見つけようとしているとします。次のようにbisectセッションを開始します。</target>
        </trans-unit>
        <trans-unit id="f51fd8c0acda05665f38c4533584f1e7599db6e4" translate="yes" xml:space="preserve">
          <source>As an example, the command below will show the path and currently checked out commit for each submodule:</source>
          <target state="translated">例として、以下のコマンドは各サブモジュールのパスと現在チェックアウトされているコミットを表示します。</target>
        </trans-unit>
        <trans-unit id="3760e902be67f22552bbeb65e39e836e5efd1bcb" translate="yes" xml:space="preserve">
          <source>As an example, use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 encoded with byte order mark (BOM) and you want Git to perform automatic line ending conversion based on your platform.</source>
          <target state="translated">例として、 &lt;code&gt;*.ps1&lt;/code&gt; ファイルがバイトオーダーマーク（BOM）でUTF-16エンコードされていて、Gitでプラットフォームに基づいて自動行末変換を実行する場合は、次の属性を使用します。</target>
        </trans-unit>
        <trans-unit id="51bf467f4f316d3645d71a2a1258673146c504e9" translate="yes" xml:space="preserve">
          <source>As another useful shortcut, the &quot;HEAD&quot; of a repository can be referred to just using the name of that repository. So, for example, &quot;origin&quot; is usually a shortcut for the HEAD branch in the repository &quot;origin&quot;.</source>
          <target state="translated">もう一つの便利なショートカットとして、リポジトリの「head」は、そのリポジトリの名前を使うだけで参照することができます。ですから、例えば、&quot;origin &quot;は通常、リポジトリ &quot;origin &quot;のHEADブランチを参照するショートカットです。</target>
        </trans-unit>
        <trans-unit id="8026d1f9c2456b3e1c9c2d009b9420179e138763" translate="yes" xml:space="preserve">
          <source>As before, if we do &lt;code&gt;git diff-files -p&lt;/code&gt; in our git-tutorial project, we&amp;rsquo;ll still see the same difference we saw last time: the index file hasn&amp;rsquo;t changed by the act of committing anything. However, now that we have committed something, we can also learn to use a new command: &lt;code&gt;git diff-index&lt;/code&gt;.</source>
          <target state="translated">以前と同様に、git-tutorialプロジェクトで &lt;code&gt;git diff-files -p&lt;/code&gt; を実行しても、前回と同じ違いが見られます。インデックスファイルは、何かをコミットすることによって変更されていません。ただし、何かをコミットしたので、新しいコマンド &lt;code&gt;git diff-index&lt;/code&gt; の使い方を学ぶこともできます。</target>
        </trans-unit>
        <trans-unit id="bf611fa72ccf0565756cc79d030368187f807460" translate="yes" xml:space="preserve">
          <source>As described in &quot;Projects list file format&quot; section, you can control which projects are &lt;strong&gt;visible&lt;/strong&gt; by selectively including repositories in projects list file, and setting &lt;code&gt;$projects_list&lt;/code&gt; gitweb configuration variable to point to it. With &lt;code&gt;$strict_export&lt;/code&gt; set, projects list file can be used to control which repositories are &lt;strong&gt;available&lt;/strong&gt; as well.</source>
          <target state="translated">「プロジェクトリストファイルの形式」セクションで説明されている&lt;strong&gt;ように&lt;/strong&gt;、プロジェクトリストファイルにリポジトリを選択的に含め、それを指すように &lt;code&gt;$projects_list&lt;/code&gt; gitweb構成変数を設定することで、表示するプロジェクトを制御できます。では &lt;code&gt;$strict_export&lt;/code&gt; セット、プロジェクトリストファイルはリポジトリがある制御に使用することができ&lt;strong&gt;利用できる&lt;/strong&gt;だけでなく。</target>
        </trans-unit>
        <trans-unit id="a7cd736f89da40ebc01b21f3f068771d165721a3" translate="yes" xml:space="preserve">
          <source>As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too.</source>
          <target state="translated">二等分アルゴリズムのステップ1)b)で説明したように、良いコミットの祖先も良いとされているので、全て削除します。</target>
        </trans-unit>
        <trans-unit id="4986ad28ead3398292128508370a98b8f0d98d3c" translate="yes" xml:space="preserve">
          <source>As development continues in the p4 repository, those changes can be included in the Git repository using:</source>
          <target state="translated">p4 リポジトリで開発が続けば、それらの変更を Git リポジトリに含めることができます。</target>
        </trans-unit>
        <trans-unit id="b95c634f5d2da95f8f228babb7d2d483e4c0fbd6" translate="yes" xml:space="preserve">
          <source>As explained in the comments, you can reorder commits, squash them together, edit commit messages, etc. by editing the list. Once you are satisfied, save the list and close your editor, and the rebase will begin.</source>
          <target state="translated">コメントで説明されているように、リストを編集することでコミットの並び替え、まとめてつぶす、コミットメッセージの編集などができます。満足したらリストを保存してエディタを閉じるとリベースが始まります。</target>
        </trans-unit>
        <trans-unit id="7111298f6d4fcf0e45bb2162c1a76bdcc1c9c21b" translate="yes" xml:space="preserve">
          <source>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</source>
          <target state="translated">1と同様に、攻撃者は盗むべきオブジェクトID Xを選択する。被害者は攻撃者が既に持っているオブジェクトYを送るが、攻撃者はYではなくXを持っていると偽っているので、被害者はXに対するデルタとしてYを送る。</target>
        </trans-unit>
        <trans-unit id="5b094bea742cc2d9c8adaa2beb6a0f04f6aac290" translate="yes" xml:space="preserve">
          <source>As long as a &quot;smudge&amp;rarr;clean&quot; results in the same output as a &quot;clean&quot; even on files that are already smudged, this strategy will automatically resolve all filter-related conflicts. Filters that do not act in this way may cause additional merge conflicts that must be resolved manually.</source>
          <target state="translated">「smudge&amp;rarr;clean」の結果がすでに汚されているファイルでも「clean」と同じ出力になる限り、この戦略はすべてのフィルター関連の競合を自動的に解決します。このように機能しないフィルターは、手動で解決する必要がある追加のマージ競合を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="1864f8816e6742ed19679415e2b4f0693aaf2aa7" translate="yes" xml:space="preserve">
          <source>As no direct connection between the repositories exists, the user must specify a basis for the bundle that is held by the destination repository: the bundle assumes that all objects in the basis are already in the destination repository.</source>
          <target state="translated">リポジトリ間には直接の接続が存在しないため、ユーザーは接続先のリポジトリが保持するバンドルの基底を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5a5d1f8e11ad4218ba16acff45cd1e219fd7d0" translate="yes" xml:space="preserve">
          <source>As objects are unpacked they&amp;rsquo;re written to the object store, so there can be cases where malicious objects get introduced even though the &quot;fetch&quot; failed, only to have a subsequent &quot;fetch&quot; succeed because only new incoming objects are checked, not those that have already been written to the object store. That difference in behavior should not be relied upon. In the future, such objects may be quarantined for &quot;fetch&quot; as well.</source>
          <target state="translated">オブジェクトはアンパックされるとオブジェクトストアに書き込まれるため、「フェッチ」が失敗しても悪意のあるオブジェクトが導入され、新しい受信オブジェクトのみがチェックされるため、後続の「フェッチ」のみが成功する場合があります。オブジェクトストアに既に書き込まれています。その動作の違いに依存すべきではありません。将来的には、そのようなオブジェクトも「フェッチ」のために隔離される可能性があります。</target>
        </trans-unit>
        <trans-unit id="09eeb717613e6d721cd260fee5aeb319ede3cef4" translate="yes" xml:space="preserve">
          <source>As of cURL v7.60.0, the Secure Channel backend can use the certificate bundle provided via &lt;code&gt;http.sslCAInfo&lt;/code&gt;, but that would override the Windows Certificate Store. Since this is not desirable by default, Git will tell cURL not to use that bundle by default when the &lt;code&gt;schannel&lt;/code&gt; backend was configured via &lt;code&gt;http.sslBackend&lt;/code&gt;, unless &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; overrides this behavior.</source>
          <target state="translated">cURL v7.60.0以降、セキュアチャネルバックエンドは &lt;code&gt;http.sslCAInfo&lt;/code&gt; を介して提供される証明書バンドルを使用できますが、これによりWindows証明書ストアが上書きされます。これはデフォルトでは望ましくないので、 &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; がこの動作をオーバーライドしない限り、 &lt;code&gt;schannel&lt;/code&gt; バックエンドが &lt;code&gt;http.sslBackend&lt;/code&gt; を介して設定されている場合、GitはcURLにデフォルトでそのバンドルを使用しないように指示します。</target>
        </trans-unit>
        <trans-unit id="965229350b7d9b7b4d3000cae9b4d2865a3ca80c" translate="yes" xml:space="preserve">
          <source>As one can see it lacks the 'sub' element.</source>
          <target state="translated">見ての通り、「サブ」の要素を欠いています。</target>
        </trans-unit>
        <trans-unit id="581927934e29a8f082f8e666e70165083e8e5a90" translate="yes" xml:space="preserve">
          <source>As soon as fast-import completes the Git repository is completely valid and ready for use. Typically this takes only a very short time, even for considerably large projects (100,000+ commits).</source>
          <target state="translated">fast-import が完了すると、Git リポジトリは完全に有効になり、すぐに使用できる状態になります。通常、かなり大きなプロジェクト (10万件以上のコミット)であっても、この作業は短時間で完了します。</target>
        </trans-unit>
        <trans-unit id="7ef5bfd643e7695a1fe3a9fa38e890221a2a3138" translate="yes" xml:space="preserve">
          <source>As stated earlier, the repo-id is currently always 1, so there will only be one def_repo event. Later, if in-proc submodules are supported, a def_repo event should be emitted for each submodule visited.</source>
          <target state="translated">前述したように、現在のところ repo-id は常に 1 なので、def_repo イベントは一つしかありません。後になって in-proc サブモジュールがサポートされるようになれば、訪問したサブモジュールごとに def_repo イベントが発行されるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="d80ca2ccc438317d745ae5338aae99312b25f26c" translate="yes" xml:space="preserve">
          <source>As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a &quot;truly stupid&quot; algorithm, later improved by Junio Hamano, that works quite well.</source>
          <target state="translated">Git のコミットは有向非周期グラフ (DAG)を形成しているので、各ステップでテストすべき最適な二等分コミットを見つけるのはそれほど単純ではありません。いずれにしても、Linus は「本当に愚かな」アルゴリズムを見つけて実装しました。</target>
        </trans-unit>
        <trans-unit id="58257bfeca486a2bf1fd8b1803660be56d2b010d" translate="yes" xml:space="preserve">
          <source>As the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits.</source>
          <target state="translated">最も一般的な特殊なケースとして、コマンドラインで 2 つのコミットのみを指定すると、与えられた 2 つのコミット間のマージベースを計算することになります。</target>
        </trans-unit>
        <trans-unit id="2031564d4e49bc946d835c341012879d4274c799" translate="yes" xml:space="preserve">
          <source>As the result, the attributes assignment to &lt;code&gt;t/abc&lt;/code&gt; becomes:</source>
          <target state="translated">その結果、 &lt;code&gt;t/abc&lt;/code&gt; への属性割り当ては次のようになります。</target>
        </trans-unit>
        <trans-unit id="192578c95c2280ba3c2f61313d8bf0f6a57ae4fb" translate="yes" xml:space="preserve">
          <source>As this option had confusing syntax, it is no longer supported. Please use &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt; instead.</source>
          <target state="translated">このオプションの構文は紛らわしいため、サポートされなくなりました。代わりに &lt;code&gt;--track&lt;/code&gt; または &lt;code&gt;--set-upstream-to&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="843f190460819446fe8a020e4f922195a92ea733" translate="yes" xml:space="preserve">
          <source>As we know N from the beginning, we know that min(X, N - X) can&amp;rsquo;t be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit.</source>
          <target state="translated">最初からNを知っているので、min（X、N-X）をN / 2より大きくすることはできません。したがって、ステップ2）および3）の間に、N / 2をコミットに関連付ける場合、これが最良の二分ポイントであることがわかります。したがって、この場合、他のコミットの処理を停止して、現在のコミットを返すことができます。</target>
        </trans-unit>
        <trans-unit id="85eb1d605d24cad051a866066f0da97dcc80577c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; will complain if this does not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;; see the following section for details on handling this case.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; と同様に、これが&lt;a href=&quot;#fast-forwards&quot;&gt;早送りに&lt;/a&gt;ならないと、 &lt;code&gt;git push&lt;/code&gt; は文句を言うでしょう。このケースの処理の詳細については、次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="8efa157c58c7162f458fc6766132a5f146c4534e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, you may also set up configuration options to save typing; so, for example:</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; と同様に、設定オプションを設定して入力を節約することもできます。したがって、たとえば：</target>
        </trans-unit>
        <trans-unit id="e2e201452993c8ff29862a314b348165ba75fd76" translate="yes" xml:space="preserve">
          <source>As with other commands of this type, &lt;em&gt;git diff-index&lt;/em&gt; does not actually look at the contents of the file at all. So maybe &lt;code&gt;kernel/sched.c&lt;/code&gt; hasn&amp;rsquo;t actually changed, and it&amp;rsquo;s just that you touched it. In either case, it&amp;rsquo;s a note that you need to &lt;em&gt;git update-index&lt;/em&gt; it to make the index be in sync.</source>
          <target state="translated">このタイプの他のコマンドと同様に、&lt;em&gt;git diff-index&lt;/em&gt;は実際にはファイルの内容をまったく調べません。そのため、おそらく &lt;code&gt;kernel/sched.c&lt;/code&gt; は実際には変更されておらず、触れただけです。どちらの場合も、インデックスを同期させるには&lt;em&gt;git update-index&lt;/em&gt;を実行する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a219cc037572dc449858e58401a98b9487e41ef" translate="yes" xml:space="preserve">
          <source>As with pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, all of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object.</source>
          <target state="translated">押すと同様に&lt;a href=&quot;git-push&quot;&gt;Gitのプッシュ[1] &lt;/a&gt;、ルールのすべての更新は、オプション主要添加することによって上書きすることができるように許可されていないものについて上述 &lt;code&gt;+&lt;/code&gt; を refspecに（または使用 &lt;code&gt;--force&lt;/code&gt; コマンドラインオプション）。これの唯一の例外は、どの程度の強制でも &lt;code&gt;refs/heads/*&lt;/code&gt; 名前空間に非コミットオブジェクトを受け入れさせないことです。</target>
        </trans-unit>
        <trans-unit id="3ed71506050bfa72b1ea4f1ce93514b64d8904d8" translate="yes" xml:space="preserve">
          <source>As with the bug described above the solution is to one-off do a &quot;git status&quot; run with &lt;code&gt;core.untrackedCache=false&lt;/code&gt; to flush out the leftover bad data.</source>
          <target state="translated">上記のバグと同様に、解決策は、 &lt;code&gt;core.untrackedCache=false&lt;/code&gt; を指定して「git status」を1回実行し、残りの不良データをフラッシュすることです。</target>
        </trans-unit>
        <trans-unit id="7f65f9810b42bc29820c9b18c26064984a955e8e" translate="yes" xml:space="preserve">
          <source>As with the case to record your own changes, you can use &lt;code&gt;-a&lt;/code&gt; option to save typing. One difference is that during a merge resolution, you cannot use &lt;code&gt;git commit&lt;/code&gt; with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see &lt;code&gt;-i&lt;/code&gt; option).</source>
          <target state="translated">独自の変更を記録する場合と同様に、 &lt;code&gt;-a&lt;/code&gt; オプションを使用して入力を保存できます。1つの違いは、マージの解決時に、マージが単一のコミットとして記録されるため、変更がコミットされる順序を変更するためにパス名を指定した &lt;code&gt;git commit&lt;/code&gt; を使用できないことです。実際、パス名が指定されている場合、コマンドは実行を拒否します（ただし、 &lt;code&gt;-i&lt;/code&gt; オプションを参照）。</target>
        </trans-unit>
        <trans-unit id="b22aaf02415c185eaf98c36bda4bb6f6375b4276" translate="yes" xml:space="preserve">
          <source>As yet another alternative, the &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; command lists the commits reachable from its arguments with a display on the left-hand side that indicates which arguments that commit is reachable from. So, if you run something like</source>
          <target state="translated">さらに別の方法として、&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;コマンドは、その引数から到達可能なコミットを一覧表示し、左側のディスプレイには、コミットが到達可能な引数を示します。したがって、次のようなものを実行した場合</target>
        </trans-unit>
        <trans-unit id="ab55ac3413eea0cf585d324d891a90eb1c44a9c7" translate="yes" xml:space="preserve">
          <source>As you can see, a commit is defined by:</source>
          <target state="translated">ご覧のように、コミットは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="6777c5e47b1bbdf59716ff3b0a0a681c16313dcb" translate="yes" xml:space="preserve">
          <source>As you can see, a commit shows who made the latest change, what they did, and why.</source>
          <target state="translated">ご覧のように、コミットは誰が最新の変更を行ったのか、何をしたのか、なぜ行ったのかを示しています。</target>
        </trans-unit>
        <trans-unit id="a0f1d03e1580f855020045fffe8e5647f3b9c420" translate="yes" xml:space="preserve">
          <source>As you can see, a tree object contains a list of entries, each with a mode, object type, SHA-1 name, and name, sorted by name. It represents the contents of a single directory tree.</source>
          <target state="translated">ご覧のように、ツリーオブジェクトには、モード、オブジェクトタイプ、SHA-1名、および名前でソートされた各エントリのリストが含まれています。これは、1 つのディレクトリツリーの内容を表しています。</target>
        </trans-unit>
        <trans-unit id="ec8afd8db14f6b2c4703101087783a19cada8ee5" translate="yes" xml:space="preserve">
          <source>As you can see, this tells us which branch we&amp;rsquo;re currently on, and it tells us this by naming a file under the .git directory, which itself contains a SHA-1 name referring to a commit object, which we can examine with cat-file:</source>
          <target state="translated">ご覧のとおり、これにより現在ブランチがわかります。また、.gitディレクトリの下のファイルに名前を付けることでこれを知らせます。これには、コミットオブジェクトを参照するSHA-1名が含まれています。猫ファイル：</target>
        </trans-unit>
        <trans-unit id="7345319011443769ac795138deb4faa77176b52c" translate="yes" xml:space="preserve">
          <source>Ask git-credential to give us a username and password for this description. This is done by running &lt;code&gt;git credential fill&lt;/code&gt;, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:</source>
          <target state="translated">この説明に使用するユーザー名とパスワードをgit-credentialに要求してください。これは、 &lt;code&gt;git credential fill&lt;/code&gt; を実行して、ステップ（1）の説明を標準入力に入力することによって行われます。完全な資格情報の説明（資格情報自体、つまりログインとパスワードを含む）は、次のような標準出力に生成されます。</target>
        </trans-unit>
        <trans-unit id="353866df360a6151213ae26714b0b27ee93959c9" translate="yes" xml:space="preserve">
          <source>Ask the user to confirm that a patch set should actually be sent to SVN. For each patch, one may answer &quot;yes&quot; (accept this patch), &quot;no&quot; (discard this patch), &quot;all&quot; (accept all patches), or &quot;quit&quot;.</source>
          <target state="translated">ユーザーに、パッチセットが実際に SVN に送られるべきかどうかの確認を求めます。それぞれのパッチについて、&quot;yes&quot; (このパッチを受け入れる)、&quot;no&quot; (このパッチを破棄する)、&quot;all&quot; (すべてのパッチを受け入れる)、&quot;quit&quot; と答えることができます。</target>
        </trans-unit>
        <trans-unit id="74885a8f797e3dd4d74ed362a01fa5f6e719e159" translate="yes" xml:space="preserve">
          <source>Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created. Still, this is useful to convert Arch repositories that had been rotated periodically.</source>
          <target state="translated">複数の Arch ブランチを 1 つの Git ブランチに関連付けることは可能で、2 番目のブランチを作成した後に 1 番目のブランチにコミットしなかった場合にのみ、結果は最も意味のあるものになります。それでも、これは定期的にローテーションされていた Arch リポジトリを変換するのに便利です。</target>
        </trans-unit>
        <trans-unit id="3fae130157899ed03a40dd2250aa34f89aff67c5" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;&lt;code&gt;master&lt;/code&gt;&quot;:</source>
          <target state="translated">次の履歴が存在し、現在のブランチが「 &lt;code&gt;master&lt;/code&gt; 」であると仮定します。</target>
        </trans-unit>
        <trans-unit id="faa8cbaa5281b0af933b5133552cbab39bea906e" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;topic&quot;:</source>
          <target state="translated">以下のような履歴が存在し、現在のブランチが &quot;topic &quot;であるとします。</target>
        </trans-unit>
        <trans-unit id="3cd2aff8a20d9db05868ff5d3b79174e0521391d" translate="yes" xml:space="preserve">
          <source>Assume the output looks like this:</source>
          <target state="translated">出力が以下のようになっているとします。</target>
        </trans-unit>
        <trans-unit id="97613cb38d31b0bbed31ce68ca2dcace37e030ff" translate="yes" xml:space="preserve">
          <source>Assume you have a tarball project.tar.gz with your initial work. You can place it under Git revision control as follows.</source>
          <target state="translated">初期の作業をしたtarball project.tar.gzがあるとします。それを以下のようにGitリビジョン管理下に置くことができます。</target>
        </trans-unit>
        <trans-unit id="679231bf1096aa234d1b1628f62bacea198b2922" translate="yes" xml:space="preserve">
          <source>Assume you have local changes in &quot;master&quot;, but you need to refetch &quot;r2&quot;.</source>
          <target state="translated">master &quot;にローカルで変更があったとしますが、&quot;r2 &quot;をリフェッチする必要があるとします。</target>
        </trans-unit>
        <trans-unit id="be7f011565f1c258dd11dc44833bb09a98dcf45f" translate="yes" xml:space="preserve">
          <source>Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.</source>
          <target state="translated">マシンAのリポジトリR1からマシンBの別のリポジトリR2に履歴を転送したいと仮定します。R1のブランチマスターで作った開発をR2にアップデートしたい。</target>
        </trans-unit>
        <trans-unit id="2183deafca588db3e5f3e1c7cf0d56a53d10c987" translate="yes" xml:space="preserve">
          <source>Assume your existing repo is at /home/alice/myproject. Create a new &quot;bare&quot; repository (a repository without a working tree) and fetch your project into it:</source>
          <target state="translated">既存のリポジトリが /home/alice/myproject にあると仮定します。新しい &quot;bare&quot; リポジトリ (作業ツリーのないリポジトリ)を作成し、プロジェクトをそこにフェッチします。</target>
        </trans-unit>
        <trans-unit id="28e522eb4dcb1a9410bd8273e0683d16ad9d1887" translate="yes" xml:space="preserve">
          <source>Assume your personal repository is in the directory &lt;code&gt;~/proj&lt;/code&gt;. We first create a new clone of the repository and tell &lt;code&gt;git daemon&lt;/code&gt; that it is meant to be public:</source>
          <target state="translated">個人リポジトリがディレクトリ &lt;code&gt;~/proj&lt;/code&gt; と仮定します。最初にリポジトリの新しいクローンを作成し、 &lt;code&gt;git daemon&lt;/code&gt; にパブリックであることを伝えます。</target>
        </trans-unit>
        <trans-unit id="2f08c00864cc26377518c6e9b880162905e8d349" translate="yes" xml:space="preserve">
          <source>Assuming that gitweb is installed to &lt;code&gt;/var/www/perl&lt;/code&gt;, the following Apache configuration (for mod_perl 2.x) is suitable.</source>
          <target state="translated">gitwebが &lt;code&gt;/var/www/perl&lt;/code&gt; にインストールされていると仮定すると、次のApache構成（mod_perl 2.x用）が適しています。</target>
        </trans-unit>
        <trans-unit id="f21b72294adb0bdfa94f142e28bd7e66d94e6e2e" translate="yes" xml:space="preserve">
          <source>Assuming the submodule has a Git directory at &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; and a working directory at &lt;code&gt;path/to/bar/&lt;/code&gt;, the superproject tracks the submodule via a &lt;code&gt;gitlink&lt;/code&gt; entry in the tree at &lt;code&gt;path/to/bar&lt;/code&gt; and an entry in its &lt;code&gt;.gitmodules&lt;/code&gt; file (see &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;) of the form &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt;.</source>
          <target state="translated">サブモジュールに &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; Gitディレクトリがあり、作業ディレクトリが &lt;code&gt;path/to/bar/&lt;/code&gt; とすると、スーパー &lt;code&gt;gitlink&lt;/code&gt; は、 &lt;code&gt;path/to/bar&lt;/code&gt; にあるツリーのgitlinkエントリとそのエントリにサブモジュールを追跡します。 &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt; 形式の &lt;code&gt;.gitmodules&lt;/code&gt; ファイル（&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="60da90e959e19c4160d1646a608d2bc5b787c602" translate="yes" xml:space="preserve">
          <source>Assuming you are using the merge approach discussed above, when you are releasing your project you will need to do some additional branch management work.</source>
          <target state="translated">上で説明したマージアプローチを使用していると仮定して、プロジェクトをリリースする際には、いくつかの追加のブランチ管理作業を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="1388e5cd4892a287239160f51404821c63ca478d" translate="yes" xml:space="preserve">
          <source>At any point you can view the history of your changes using</source>
          <target state="translated">どの時点でも、変更の履歴を表示するには</target>
        </trans-unit>
        <trans-unit id="e40d41f48140a6f9c8ed7743f53a14cc49f4d4d6" translate="yes" xml:space="preserve">
          <source>At any point you may use the &lt;code&gt;--abort&lt;/code&gt; option to abort this process and return mywork to the state it had before you started the rebase:</source>
          <target state="translated">いつでも &lt;code&gt;--abort&lt;/code&gt; オプションを使用してこのプロセスを中止し、リベースを開始する前の状態にmyworkを戻すことができます。</target>
        </trans-unit>
        <trans-unit id="21e6c111ed6dea301f6219c21f04088d951095f1" translate="yes" xml:space="preserve">
          <source>At any time, we can create a new commit using &lt;code&gt;git commit&lt;/code&gt; (without the &quot;-a&quot; option), and verify that the state committed only includes the changes stored in the index file, not the additional change that is still only in our working tree:</source>
          <target state="translated">いつでも（ &quot;-a&quot;オプションなしで） &lt;code&gt;git commit&lt;/code&gt; を使用して新しいコミットを作成し、コミットされた状態にインデックスファイルに保存されている変更のみが含まれていることを確認できます。木：</target>
        </trans-unit>
        <trans-unit id="c62227c162304e2658e4b654489602aed406e046" translate="yes" xml:space="preserve">
          <source>At the beginning, the content of the index will be identical to that of the HEAD. The command &lt;code&gt;git diff --cached&lt;/code&gt;, which shows the difference between the HEAD and the index, should therefore produce no output at that point.</source>
          <target state="translated">最初は、インデックスの内容はHEADの内容と同じです。したがって、HEADとインデックスの違いを示すコマンド &lt;code&gt;git diff --cached&lt;/code&gt; は、その時点で出力を生成しません。</target>
        </trans-unit>
        <trans-unit id="8edc58a934b3ed21297a24f7c0434615621064c8" translate="yes" xml:space="preserve">
          <source>At this point the index file still has all the WIP changes you committed as &lt;code&gt;snapshot WIP&lt;/code&gt;. This updates the index to show your WIP files as uncommitted.</source>
          <target state="translated">この時点で、インデックスファイルには、 &lt;code&gt;snapshot WIP&lt;/code&gt; としてコミットしたすべてのWIP変更が残っています。これにより、インデックスが更新され、コミットされていないWIPファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="6fb30ce8f93c559deaf24b4ad05d6dda3c1a1ac8" translate="yes" xml:space="preserve">
          <source>At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command.</source>
          <target state="translated">この時点では、基本的に2つの方法で検索を行うことができます。ユーザーが手動で操作する方法と、スクリプトやコマンドで自動的に操作する方法があります。</target>
        </trans-unit>
        <trans-unit id="73d7e84e91592f3766bf21a35fce90d676b02b60" translate="yes" xml:space="preserve">
          <source>At this point we can see what the commit does, check it out (if it&amp;rsquo;s not already checked out) or tinker with it, for example:</source>
          <target state="translated">この時点で、コミットの動作を確認したり、チェックアウト（まだチェックアウトされていない場合）したり、次のようにいじったりできます。</target>
        </trans-unit>
        <trans-unit id="9821aa659e4d6623e87210d9f79f8fb8048ff5ce" translate="yes" xml:space="preserve">
          <source>At this point you could delete the experimental branch with</source>
          <target state="translated">この時点で、実験ブランチを削除するには</target>
        </trans-unit>
        <trans-unit id="9f18a8a14c3813ef07a4e4179ae90618a19f07d0" translate="yes" xml:space="preserve">
          <source>At this point you should know everything necessary to read the man pages for any of the git commands; one good place to start would be with the commands mentioned in &lt;a href=&quot;giteveryday&quot;&gt;giteveryday[7]&lt;/a&gt;. You should be able to find any unknown jargon in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">この時点で、gitコマンドのmanページを読むために必要なすべてを知っているはずです。開始するには、&lt;a href=&quot;giteveryday&quot;&gt;giteveryday [7]に&lt;/a&gt;記載されているコマンドを使用することをお勧めします。&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt;で不明な専門用語を見つけることができるはずです。</target>
        </trans-unit>
        <trans-unit id="870751f448af1f37fa82b626c9d940e8d540a997" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;git diff&lt;/code&gt; shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with &lt;code&gt;git add&lt;/code&gt; as usual:</source>
          <target state="translated">この時点で、 &lt;code&gt;git diff&lt;/code&gt; は前の例のように完全にマージされた変更と競合するファイルの変更を表示します。競合を編集して解決し、通常どおり &lt;code&gt;git add&lt;/code&gt; で解決済みとしてマークします。</target>
        </trans-unit>
        <trans-unit id="1c8e0f856e1b344e50a8f9f6370e6aeaf4be3455" translate="yes" xml:space="preserve">
          <source>At this point, you could use &lt;code&gt;pull&lt;/code&gt; to merge your changes back in; the result would create a new merge commit, like this:</source>
          <target state="translated">この時点で、 &lt;code&gt;pull&lt;/code&gt; を使用して変更をマージして戻すことができます。その結果、次のように新しいマージコミットが作成されます。</target>
        </trans-unit>
        <trans-unit id="0cd76265a60d161772d69d7db5cee25c535ce122" translate="yes" xml:space="preserve">
          <source>At this time, the &lt;code&gt;merge&lt;/code&gt; command will &lt;strong&gt;always&lt;/strong&gt; use the &lt;code&gt;recursive&lt;/code&gt; merge strategy for regular merges, and &lt;code&gt;octopus&lt;/code&gt; for octopus merges, with no way to choose a different one. To work around this, an &lt;code&gt;exec&lt;/code&gt; command can be used to call &lt;code&gt;git merge&lt;/code&gt; explicitly, using the fact that the labels are worktree-local refs (the ref &lt;code&gt;refs/rewritten/onto&lt;/code&gt; would correspond to the label &lt;code&gt;onto&lt;/code&gt;, for example).</source>
          <target state="translated">このとき、 &lt;code&gt;merge&lt;/code&gt; コマンドがします&lt;strong&gt;常に&lt;/strong&gt;使用 &lt;code&gt;recursive&lt;/code&gt; マージ定期的なマージのための戦略、そして &lt;code&gt;octopus&lt;/code&gt; 異なるものを選択する方法はありませんで、タコのマージのために。この問題を回避するには、 &lt;code&gt;exec&lt;/code&gt; コマンドを呼び出すために使用することができます &lt;code&gt;git merge&lt;/code&gt; ラベルがworktreeローカルレフリーがあるという事実を使用して、明示的に（参考文献を &lt;code&gt;refs/rewritten/onto&lt;/code&gt; ラベルに対応する &lt;code&gt;onto&lt;/code&gt; 、例えば）。</target>
        </trans-unit>
        <trans-unit id="c05aeaaa9fcd28f51dfdd6a6420e663787cde8e1" translate="yes" xml:space="preserve">
          <source>Attempt authentication without seeking a username or password. This can be used to attempt GSS-Negotiate authentication without specifying a username in the URL, as libcurl normally requires a username for authentication.</source>
          <target state="translated">ユーザ名やパスワードを求めずに認証を試みます。libcurl は通常認証にユーザ名を必要とするので、これは URL にユーザ名を指定せずに GSS-Negotiate 認証を試みるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="b7ef94beb2ddaab144a55b166c213b4001e85f5a" translate="yes" xml:space="preserve">
          <source>Attempt to auto-register archives at &lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; This is particularly useful with the -D option.</source>
          <target state="translated">&lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; でアーカイブを自動登録しようとします。これは、-Dオプションで特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="7d9e2779fbfa7bc1835b11ad0c4ebabfce18ac06" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message with a custom regex. It can be used with &lt;code&gt;-m&lt;/code&gt; to enable the default regexes as well. You must escape forward slashes.</source>
          <target state="translated">カスタム正規表現を使用して、コミットメッセージに基づいてマージを検出しようとします。 &lt;code&gt;-m&lt;/code&gt; とともに使用して、デフォルトの正規表現を有効にすることもできます。スラッシュはエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="b8801ab881aa4eb66128b4665e3908eb4d237716" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message.</source>
          <target state="translated">コミットメッセージに基づいてマージの検出を試みます。このオプションは、コミットメッセージからソースブランチ名を取得しようとするデフォルトの正規表現を有効にします。</target>
        </trans-unit>
        <trans-unit id="8811bcf98c754b208d76412300be8b3f7a7a0962" translate="yes" xml:space="preserve">
          <source>Attempt to use AUTH SSL/TLS and encrypted data transfers when connecting via regular FTP protocol. This might be needed if the FTP server requires it for security reasons or you wish to connect securely whenever remote FTP server supports it. Default is false since it might trigger certificate verification errors on misconfigured servers.</source>
          <target state="translated">通常のFTPプロトコルで接続する場合は、AUTH SSL/TLSと暗号化されたデータ転送を使用してみてください。これは、FTP サーバがセキュリティ上の理由で必要とする場合や、リモート FTP サーバがサポートしている場合はいつでも安全に接続したい場合に必要になるかもしれません。誤った設定のサーバで証明書検証エラーが発生する可能性があるため、デフォルトは false になっています。</target>
        </trans-unit>
        <trans-unit id="653466560b06acd7928eb1dabc7b9fa724a015d3" translate="yes" xml:space="preserve">
          <source>Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files. Empty directories are automatically recreated when using &quot;git svn clone&quot; and &quot;git svn rebase&quot;, so &quot;mkdirs&quot; is intended for use after commands like &quot;git checkout&quot; or &quot;git reset&quot;. (See the svn-remote.&amp;lt;name&amp;gt;.automkdirs config file option for more information.)</source>
          <target state="translated">コアGitが$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.logファイルの情報に基づいて追跡できない空のディレクトリを再作成しようとします。「git svn clone」および「git svn rebase」を使用すると、空のディレクトリが自動的に再作成されるため、「mkdirs」は「git checkout」や「git reset」などのコマンドの後に使用することを目的としています。（詳細については、svn-remote。&amp;lt;name&amp;gt; .automkdirs config fileオプションを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="6945a05135c86ba329a2113c1a6c328943460d7a" translate="yes" xml:space="preserve">
          <source>Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable).</source>
          <target state="translated">照会されたすべての設定オプションの出力を、原点タイプ(ファイル、標準入力、blob、コマンドライン)と実際の原点(設定ファイルのパス、ref、または該当する場合はblob id)で拡張します。</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="3a3b18a78fb302a466d9706ed638e25ca72e2b20" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken build between v1.2 and HEAD:</source>
          <target state="translated">v1.2とHEADの間で壊れたビルドを自動的に二分するようにしました。</target>
        </trans-unit>
        <trans-unit id="b961e5ffc1b4a2335ddafbf9005a05ec9394a9ac" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken test case:</source>
          <target state="translated">壊れたテストケースを自動的に二等分します。</target>
        </trans-unit>
        <trans-unit id="efbd5b3ba20268a44c57d801ed284c730cc6da62" translate="yes" xml:space="preserve">
          <source>Automatically bisect a test failure between origin and HEAD:</source>
          <target state="translated">オリジンとHEADの間でテストの失敗を自動的に二等分します。</target>
        </trans-unit>
        <trans-unit id="305f7f7499890d95ab081f6ff6a94a43fd8f7472" translate="yes" xml:space="preserve">
          <source>Automatically bisect with temporary modifications (hot-fix):</source>
          <target state="translated">一時的な修正(ホットフィックス)で自動的に二等分します。</target>
        </trans-unit>
        <trans-unit id="f3ce497b64c12f23e2601126336fc2efac214445" translate="yes" xml:space="preserve">
          <source>Automatically correct and execute mistyped commands after waiting for the given number of deciseconds (0.1 sec). If more than one command can be deduced from the entered text, nothing will be executed. If the value of this option is negative, the corrected command will be executed immediately. If the value is 0 - the command will be just shown but not executed. This is the default.</source>
          <target state="translated">与えられた決定秒数(0.1秒)を待ってから、誤入力したコマンドを自動的に修正して実行します。入力されたテキストから複数のコマンドが推測できる場合は、何も実行されません。このオプションの値が負の場合、修正されたコマンドは直ちに実行されます。値が 0 の場合、コマンドは表示されるだけで実行されません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="c95bbf7a5ca8016973d83b1a1be57b0354ee0b3c" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.</source>
          <target state="translated">操作開始前に一時的なスタッシュエントリを自動的に作成し、操作終了後に適用します。これにより、ダーティなワークツリーでもリベースを実行できるようになります。ただし、リベースが成功した後の最終的なスタッシュの適用では、本質的でない競合が発生する可能性がありますので、注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="172ed809f35e71e5eeb8f45359fa6e87d4adb464" translate="yes" xml:space="preserve">
          <source>Automatically enter the &lt;code&gt;Amend Last Commit&lt;/code&gt; mode of the interface.</source>
          <target state="translated">インターフェースの &lt;code&gt;Amend Last Commit&lt;/code&gt; モードに自動的に入ります。</target>
        </trans-unit>
        <trans-unit id="ea4a15096a50442dde0b46a87fa45d92f2d785b9" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided).</source>
          <target state="translated">失敗した &lt;code&gt;exec&lt;/code&gt; コマンドを自動的に再スケジュールします。これは、対話モード（または &lt;code&gt;--exec&lt;/code&gt; オプションが指定されている場合）でのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="49d8a969b318bfe4bd71c313d20f34515eed00b4" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided). This is the same as specifying the &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; option.</source>
          <target state="translated">失敗した &lt;code&gt;exec&lt;/code&gt; コマンドを自動的に再スケジュールします。これは、対話モード（または &lt;code&gt;--exec&lt;/code&gt; オプションが指定されている場合）でのみ意味があります。これは、 &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; オプションを指定するのと同じです。</target>
        </trans-unit>
        <trans-unit id="d8ac3fef9b72ebf093fec8697b2ecc321af38b99" translate="yes" xml:space="preserve">
          <source>Automating</source>
          <target state="translated">Automating</target>
        </trans-unit>
        <trans-unit id="91b5703f47ead0e97d542b1a3caaad3f90e51a85" translate="yes" xml:space="preserve">
          <source>Avatar support. When this feature is enabled, views such as &quot;shortlog&quot; or &quot;commit&quot; will display an avatar associated with the email of each committer and author.</source>
          <target state="translated">アバターのサポート。この機能を有効にすると、&quot;shortlog&quot; や &quot;commit&quot; などのビューに、各コミッターや作者のメールに関連付けられたアバターが表示されます。</target>
        </trans-unit>
        <trans-unit id="c6d2705a42ecaf3f83b93f2bb10c67222bc9051b" translate="yes" xml:space="preserve">
          <source>Avoid using these constructs, or do so with extreme caution.</source>
          <target state="translated">これらの構成要素の使用を避けるか、細心の注意を払ってください。</target>
        </trans-unit>
        <trans-unit id="58d07623af97c330a561d59f75b429cfa3bf0d0e" translate="yes" xml:space="preserve">
          <source>Avoiding bug prone merges</source>
          <target state="translated">バグが発生しやすいマージを避ける</target>
        </trans-unit>
        <trans-unit id="e75c3f820aba1b207ca074d2c527699299d0d6c8" translate="yes" xml:space="preserve">
          <source>Avoiding repetition</source>
          <target state="translated">繰り返しを避ける</target>
        </trans-unit>
        <trans-unit id="8c9b7d07bde7114458252fe7c7c79eff561fa5a3" translate="yes" xml:space="preserve">
          <source>Avoiding testing a commit</source>
          <target state="translated">コミットテストの回避</target>
        </trans-unit>
        <trans-unit id="b6679b7397715a4a559a3f90cd5da98012c5192b" translate="yes" xml:space="preserve">
          <source>Avoiding untestable commits</source>
          <target state="translated">テスト不可能なコミットを避ける</target>
        </trans-unit>
        <trans-unit id="c06045f474b6de45fbcfae00e6444b3eed002fd3" translate="yes" xml:space="preserve">
          <source>BBChop is like &lt;code&gt;git bisect&lt;/code&gt; (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial).</source>
          <target state="translated">BBChopは &lt;code&gt;git bisect&lt;/code&gt; （または同等のもの）に似ていますが、バグが断続的である場合に機能します。つまり、偽陰性の存在下で機能します（バグが含まれているにもかかわらずバージョンが今回機能する場合）。誤検知がないことを前提としています（原則として、同じアプローチが機能しますが、追加するのは簡単ではありません）。</target>
        </trans-unit>
        <trans-unit id="58da1ac28249462c67af1a7a678bbb84e64c5732" translate="yes" xml:space="preserve">
          <source>Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.</source>
          <target state="translated">作曲ウィンドウに戻ります。メッセージに好きなテキストを追加し、アドレスと件名を入力し、送信を押します。</target>
        </trans-unit>
        <trans-unit id="0e4c8fb0c7c0f01878ae288a3240d6945abd9968" translate="yes" xml:space="preserve">
          <source>Back when this document was originally written, many porcelain commands were shell scripts. For simplicity, it still uses them as examples to illustrate how plumbing is fit together to form the porcelain commands. The source tree includes some of these scripts in contrib/examples/ for reference. Although these are not implemented as shell scripts anymore, the description of what the plumbing layer commands do is still valid.</source>
          <target state="translated">このドキュメントが書かれた当時、多くの磁器コマンドはシェルスクリプトでした。簡単にするために、この文書では、配管がどのように組み合わされて磁器コマンドを形成しているかを説明するための例として、それらを今でも使用しています。ソースツリーには、参照のためにcontrib/examples/にこれらのスクリプトのいくつかが含まれています。これらはシェルスクリプトとしては実装されなくなりましたが、配管レイヤコマンドが何をするかについての記述はまだ有効です。</target>
        </trans-unit>
        <trans-unit id="3cd5a2617e84a99ed87281238ca40ff62c45eb00" translate="yes" xml:space="preserve">
          <source>Backend extra options</source>
          <target state="translated">バックエンドの追加オプション</target>
        </trans-unit>
        <trans-unit id="68cec68bccaee9cd80346d9802ee1e4fe905591f" translate="yes" xml:space="preserve">
          <source>Backend for fast Git data importers</source>
          <target state="translated">高速な Git データインポーターのためのバックエンド</target>
        </trans-unit>
        <trans-unit id="332ccbbf6a93a641f5828315e15dfb5ba3534887" translate="yes" xml:space="preserve">
          <source>Background refresh</source>
          <target state="translated">背景リフレッシュ</target>
        </trans-unit>
        <trans-unit id="3768e81347249432d7250e290eff2b7dcfb031aa" translate="yes" xml:space="preserve">
          <source>Backwards compatibility with &lt;code&gt;crlf&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crlf&lt;/code&gt; 属性との下位互換性</target>
        </trans-unit>
        <trans-unit id="0f4f796a2c073cee4b5657a9746bebeb8b591e9a" translate="yes" xml:space="preserve">
          <source>Base URL for relative URLs in pages generated by gitweb, (e.g. &lt;code&gt;$logo&lt;/code&gt;, &lt;code&gt;$favicon&lt;/code&gt;, &lt;code&gt;@stylesheets&lt;/code&gt; if they are relative URLs), needed and used &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; only for URLs with nonempty PATH_INFO. Usually gitweb sets its value correctly, and there is no need to set this variable, e.g. to $my_uri or &quot;/&quot;. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to override it anyway.</source>
          <target state="translated">gitwebによって生成されたページ内の相対URLのベースURL（例： &lt;code&gt;$logo&lt;/code&gt; 、 &lt;code&gt;$favicon&lt;/code&gt; 、 &lt;code&gt;@stylesheets&lt;/code&gt; が相対URLの場合）は、空でないPATH_INFOを持つURLに対してのみ必要であり、 &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; 使用します。通常、gitwebはその値を正しく設定し、この変数を$ my_uriや &quot;/&quot;などに設定する必要はありません。とにかくオーバーライドする必要がある場合は、 &lt;code&gt;$per_request_config&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="097ac79311bf794decc7505841440135a2fcc1ec" translate="yes" xml:space="preserve">
          <source>Base tree information</source>
          <target state="translated">ベースツリー情報</target>
        </trans-unit>
        <trans-unit id="41acf5ab02f1a6facad6c843b7f1be13be76b889" translate="yes" xml:space="preserve">
          <source>Basic Command Messages</source>
          <target state="translated">基本的なコマンドメッセージ</target>
        </trans-unit>
        <trans-unit id="32df76cf3cbd146d03819bb90c4b2e01188b5795" translate="yes" xml:space="preserve">
          <source>Basic Snapshotting</source>
          <target state="translated">基本的なスナップショット</target>
        </trans-unit>
        <trans-unit id="8f3df0ee4c430ab18f213f1998c456e450457574" translate="yes" xml:space="preserve">
          <source>Basic bisect commands: start, bad, good</source>
          <target state="translated">基本的な二等分コマンド:スタート、バッド、グッド</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">基本的な例</target>
        </trans-unit>
        <trans-unit id="8edc4390b3f014a72c7bad2082d4af28321b0a0d" translate="yes" xml:space="preserve">
          <source>Basically, the initial version of &lt;code&gt;git log&lt;/code&gt; was a shell script:</source>
          <target state="translated">基本的に、 &lt;code&gt;git log&lt;/code&gt; の初期バージョンはシェルスクリプトでした。</target>
        </trans-unit>
        <trans-unit id="434712fddf7623f4187c1faf83b1bb6fa207c805" translate="yes" xml:space="preserve">
          <source>Batch output</source>
          <target state="translated">バッチ出力</target>
        </trans-unit>
        <trans-unit id="09375d82ef48456f50bfb9b6b51c1eb3256d2719" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and &lt;code&gt;subcommand&lt;/code&gt;.</source>
          <target state="translated">もう少し冗長にして、名前の後にリモートURLを表示します。注：これは、 &lt;code&gt;remote&lt;/code&gt; と &lt;code&gt;subcommand&lt;/code&gt; 間に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c658e70993b255c8802b7997e9b78d1f1aa3285" translate="yes" xml:space="preserve">
          <source>Be aware that commits that the old version of example/master pointed at may be lost, as we saw in the previous section.</source>
          <target state="translated">前項で見たように、古いバージョンの example/master が指し示すコミットが失われる可能性があるので注意しましょう。</target>
        </trans-unit>
        <trans-unit id="f1a69fc5e5785e6c85861e4893e3a9a94deb0c9c" translate="yes" xml:space="preserve">
          <source>Be careful with that last command: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don&amp;rsquo;t use &lt;code&gt;git reset&lt;/code&gt; on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use &lt;code&gt;git revert&lt;/code&gt; instead.</source>
          <target state="translated">最後のコマンドには注意してください。作業ディレクトリ内の変更が失われるだけでなく、このブランチから以降のコミットもすべて削除されます。このブランチがそれらのコミットを含む唯一のブランチである場合、それらは失われます。また、他の開発者がプルしたパブリックに見えるブランチで &lt;code&gt;git reset&lt;/code&gt; を使用しないでください。他の開発者が不要なマージを行うと、履歴がクリーンアップされます。プッシュした変更を元に戻す必要がある場合は、代わりに &lt;code&gt;git revert&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="a106ab03cbfb468582a31c86875853bbaafe530d" translate="yes" xml:space="preserve">
          <source>Be chatty.</source>
          <target state="translated">おしゃべりになる。</target>
        </trans-unit>
        <trans-unit id="0226bfbddcb9791bd20d59aa488cf4bfb67ab797" translate="yes" xml:space="preserve">
          <source>Be more quiet when creating or deleting a branch, suppressing non-error messages.</source>
          <target state="translated">ブランチの作成や削除の際には、より静かにして、エラー以外のメッセージを抑制します。</target>
        </trans-unit>
        <trans-unit id="925261c1087472fc24273a6f0433e6dab581a46e" translate="yes" xml:space="preserve">
          <source>Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0</source>
          <target state="translated">パッチを適用するときは、衒学的(偏執的)であること。fuzz=0 でパッチを起動します。</target>
        </trans-unit>
        <trans-unit id="5a76ff079f12b1a74eb9b1c43645e96dd86361c1" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors, but not the files that are successfully removed.</source>
          <target state="translated">静かにして、エラーだけを報告して、正常に削除されたファイルは報告しないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="3b0a3e777f7a9dd999ab064af69bac80ddbc5083" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors. The default behavior is set by the &lt;code&gt;reset.quiet&lt;/code&gt; config option. &lt;code&gt;--quiet&lt;/code&gt; and &lt;code&gt;--no-quiet&lt;/code&gt; will override the default behavior.</source>
          <target state="translated">静かにし、エラーのみを報告します。デフォルトの動作は、 &lt;code&gt;reset.quiet&lt;/code&gt; 構成オプションによって設定されます。 &lt;code&gt;--quiet&lt;/code&gt; と &lt;code&gt;--no-quiet&lt;/code&gt; はデフォルトの動作を上書きします。</target>
        </trans-unit>
        <trans-unit id="4f313b181847f334463e2b9b9cfece6969bdba71" translate="yes" xml:space="preserve">
          <source>Be quiet.</source>
          <target state="translated">じっとしてろ</target>
        </trans-unit>
        <trans-unit id="57fac52c9e565c186d12f20b18e356a6357e3a35" translate="yes" xml:space="preserve">
          <source>Be quiet. Implies --no-stat.</source>
          <target state="translated">静かにして no-statを暗示している。</target>
        </trans-unit>
        <trans-unit id="35516ed1ed9df26f7366465685509e0334c0b48a" translate="yes" xml:space="preserve">
          <source>Be quiet. Only print error messages.</source>
          <target state="translated">静かにしてください。エラーメッセージだけを印刷してください。</target>
        </trans-unit>
        <trans-unit id="89978c5e1540e90f998db2cd0eadcb073170d060" translate="yes" xml:space="preserve">
          <source>Be verbose about what is going on, including progress status.</source>
          <target state="translated">進捗状況も含めて、何が起こっているのかを丁寧に説明しましょう。</target>
        </trans-unit>
        <trans-unit id="4e80f48c004a90076351b14f311e5f6e4c744c6f" translate="yes" xml:space="preserve">
          <source>Be verbose.</source>
          <target state="translated">饒舌になる。</target>
        </trans-unit>
        <trans-unit id="e38a34eb197b14381b23c4e10c689eabe1fdd749" translate="yes" xml:space="preserve">
          <source>Be verbose. Implies --stat.</source>
          <target state="translated">饒舌になれ 含意は--stat.</target>
        </trans-unit>
        <trans-unit id="d448b8a2b9d0f1627827f1dfcde2eef631321fa0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;--&lt;/code&gt; disambiguates revisions and paths in some commands, it cannot be used for those commands to separate options and revisions. You can use &lt;code&gt;--end-of-options&lt;/code&gt; for this (it also works for commands that do not distinguish between revisions in paths, in which case it is simply an alias for &lt;code&gt;--&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; は一部のコマンドのリビジョンとパスを明確にするため、オプションとリビジョンを区切るコマンドには使用できません。これには &lt;code&gt;--end-of-options&lt;/code&gt; を使用できます（これは、パス内のリビジョンを区別しないコマンドでも機能します。この場合、それは &lt;code&gt;--&lt;/code&gt; 単なるエイリアスです）。</target>
        </trans-unit>
        <trans-unit id="ed27c3aa81ab7c3b7b68607b6265fd75466941ef" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;git rebase&lt;/code&gt; replays each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch using the given strategy, using the &lt;code&gt;ours&lt;/code&gt; strategy simply empties all patches from the &amp;lt;branch&amp;gt;, which makes little sense.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; は、指定された戦略を使用して&amp;lt;upstream&amp;gt;ブランチの上にある作業ブランチから各コミットをリプレイするため、 &lt;code&gt;ours&lt;/code&gt; 戦略を使用すると、&amp;lt;branch&amp;gt;からすべてのパッチを空にするだけで、ほとんど意味がありません。</target>
        </trans-unit>
        <trans-unit id="611de3be2abb35df567ae0fa30747c7d8e2e7993" translate="yes" xml:space="preserve">
          <source>Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes. If branches exist under &lt;code&gt;refs/remote/origin/p4&lt;/code&gt;, those will be fetched and used when syncing from p4. This variable can be set to &lt;code&gt;false&lt;/code&gt; to disable this behavior.</source>
          <target state="translated">他のGitリポジトリからのコミットのインポートは、p4からのインポートよりもはるかに高速であるため、Gitリモートで最初にp4の変更を見つけるメカニズムが存在します。 &lt;code&gt;refs/remote/origin/p4&lt;/code&gt; の下にブランチが存在する場合、それらはフェッチされ、p4から同期するときに使用されます。この変数を &lt;code&gt;false&lt;/code&gt; に設定して、この動作を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="8b27b448c938b73dbdadc78ef0ba4dafccd89967" translate="yes" xml:space="preserve">
          <source>Because of this rule, version bumps should be kept to an absolute minimum. Instead, we generally prefer these strategies:</source>
          <target state="translated">このルールのため、バージョンバンプは最小限に抑えるべきです。その代わりに、私たちは一般的に以下のような戦略を推奨しています。</target>
        </trans-unit>
        <trans-unit id="9d9f1c640b4582c4a49afdb8c70b2833e5da2875" translate="yes" xml:space="preserve">
          <source>Because text conversion can be slow, especially when doing a large number of them with &lt;code&gt;git log -p&lt;/code&gt;, Git provides a mechanism to cache the output and use it in future diffs. To enable caching, set the &quot;cachetextconv&quot; variable in your diff driver&amp;rsquo;s config. For example:</source>
          <target state="translated">特に &lt;code&gt;git log -p&lt;/code&gt; で大量のテキスト変換を行う場合、テキスト変換が遅くなる可能性があるため、Gitは出力をキャッシュして将来の差分で使用するメカニズムを提供します。キャッシングを有効にするには、diffドライバーの設定で「cachetextconv」変数を設定します。例えば：</target>
        </trans-unit>
        <trans-unit id="0cc6b3eb8dba093f368da6924e1615ce67ee83a2" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">この例では、シェルでアスタリスクを拡張できるため（つまり、ファイルを明示的にリストしているため）、 &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; は考慮されません。</target>
        </trans-unit>
        <trans-unit id="6959f8959917da0048164f701d2c1653881d1c94" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">この例では、シェルでアスタリスクを拡張できるため（つまり、ファイルを明示的にリストしているため）、 &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; は削除されません。</target>
        </trans-unit>
        <trans-unit id="19c5affce108c66b3b01079a5ffc874aa2199c4e" translate="yes" xml:space="preserve">
          <source>Because you&amp;rsquo;re asking for raw output, you&amp;rsquo;ll now get something like</source>
          <target state="translated">あなたは生の出力を求めているので、今のようなものを得るでしょう</target>
        </trans-unit>
        <trans-unit id="6c83aee082a9b203ae0a8b1d789ef54ecb5119e2" translate="yes" xml:space="preserve">
          <source>Because your branch did not contain anything more than what had already been merged into the &lt;code&gt;master&lt;/code&gt; branch, the merge operation did not actually do a merge. Instead, it just updated the top of the tree of your branch to that of the &lt;code&gt;master&lt;/code&gt; branch. This is often called &lt;code&gt;fast-forward&lt;/code&gt; merge.</source>
          <target state="translated">ブランチには既に &lt;code&gt;master&lt;/code&gt; ブランチにマージされたもの以外のものが含まれていないため、マージ操作は実際にはマージを行いませんでした。代わりに、ブランチのツリーのトップを &lt;code&gt;master&lt;/code&gt; ブランチのトップに更新しました。これは、しばしば &lt;code&gt;fast-forward&lt;/code&gt; マージと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="870bf9816d9b0c5ffd88b816d5bee6377c654145" translate="yes" xml:space="preserve">
          <source>Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the &quot;status: add a failing test showing a core.untrackedCache bug&quot; commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):</source>
          <target state="translated">2.17 より前のバージョンでは、untracked キャッシュには、ディレクトリを別のディレクトリへのシンボリックリンクで置き換えると、git で追跡したファイルが正しく表示されないというバグがありました。git.git へのコミット &quot;status:add a failing test showing a core.untrackedCache bug&quot; を参照ください。これに対する回避策は次のとおりです (将来的には他の未発見のバグにも対応できるようになるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="201415c3562a156d29edac8b78dcea637cbede90" translate="yes" xml:space="preserve">
          <source>Before Git invokes a hook, it changes its working directory to either $GIT_DIR in a bare repository or the root of the working tree in a non-bare repository. An exception are hooks triggered during a push (&lt;code&gt;pre-receive&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;post-receive&lt;/code&gt;, &lt;code&gt;post-update&lt;/code&gt;, &lt;code&gt;push-to-checkout&lt;/code&gt;) which are always executed in $GIT_DIR.</source>
          <target state="translated">Gitがフックを呼び出す前に、Gitは作業ディレクトリをベアリポジトリの$ GIT_DIRまたは非ベアリポジトリのワーキングツリーのルートに変更します。例外は、常に$ GIT_DIRで実行されるプッシュ（ &lt;code&gt;pre-receive&lt;/code&gt; 、 &lt;code&gt;update&lt;/code&gt; 、 &lt;code&gt;post-receive&lt;/code&gt; 、 &lt;code&gt;post-update&lt;/code&gt; 、 &lt;code&gt;push-to-checkout&lt;/code&gt; ）中にトリガーされるフックです。</target>
        </trans-unit>
        <trans-unit id="5cb683352fd365c05d1a2f3a901dc43ac75f481f" translate="yes" xml:space="preserve">
          <source>Before Git v2.0, the default prefix was &quot;&quot; (no prefix). This meant that SVN-tracking refs were put at &quot;refs/remotes/*&quot;, which is incompatible with how Git&amp;rsquo;s own remote-tracking refs are organized. If you still want the old default, you can get it by passing &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; on the command line (&lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; may not work if your Perl&amp;rsquo;s Getopt::Long is &amp;lt; v2.37).</source>
          <target state="translated">Git v2.0より前は、デフォルトのプレフィックスは &quot;&quot;（プレフィックスなし）でした。これは、SVN追跡参照が「refs / remotes / *」に配置されたことを意味します。これは、Git独自のリモート追跡参照の構成と互換性がありません。それでも古いデフォルトが必要な場合は、コマンドラインで &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; を渡して取得できます（PerlのGetopt :: Longが&amp;lt;v2.37の場合、--prefix &lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; は機能しない可能性があります）。</target>
        </trans-unit>
        <trans-unit id="c9087c912c36612c549b23a216e2ca49dd6b41fb" translate="yes" xml:space="preserve">
          <source>Before any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running &lt;code&gt;git am&lt;/code&gt; on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the &quot;From:&quot; lines).</source>
          <target state="translated">パッチが適用される前に、ORIG_HEADが現在のブランチの先端に設定されます。これは、間違ったブランチで &lt;code&gt;git am&lt;/code&gt; を実行したり、メールボックスを変更することでより簡単に修正できるコミットのエラー（「From：」行のエラーなど）のような複数のコミットに問題がある場合に役立ちます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
