<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="ansible">
    <body>
      <group id="ansible">
        <trans-unit id="cd4c4c97f36b2b62de11c34b4a27a2c761742b55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvs server&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49a24547f58bd02d543075f89ceed8c90d6d7d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dcommit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dcommit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29a1329a0153d69adbf79d22da2d86026099cd1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dadae45c2e0ed49ab92c21e51924b9c5c51ce2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;disable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;disable&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b451ef329785424729c63e2a3017984d3e643c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b45d112a98b2ca1521e95769372073007c885a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;export&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069adc38be838320ed1d0aece7752fcbc214a54a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fetch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d558b04f07f16944ece2169a0e3c3823b9025f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt; &amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89dcac1ec2e46569b3edf183125a808da46f4c6f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;find-rev&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;find-rev&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1073814f068a39c89b0eede6d041e1faf4e59ac8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;forget&lt;/em&gt; &amp;lt;pathspec&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8f3fbb6ffe3b51991811f0c6531319170fdb21" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;gc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;gc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4af622a2a4f28a61d7a9f24cb930fffc6ba76491" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;get-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;get-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a9d6d2f21ff1ec0d69ee63760f22a3c5cbb084b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; (-p|--patch) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228e3a4db67759d57c887f137171bceae52a6f8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;branch&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ead8dfc114c4f20b9d6ce6d106f2bc2ef44cf5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; -b|-B &amp;lt;new_branch&amp;gt; [&amp;lt;start point&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b2375b489fba132766f1463af8f72171dbc00f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;branch&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1ee40d06e7050bf76fabde96c6e18bcdee66c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;commit&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617a45295c12feb378bd11060f09979d655ab681" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d51fb50a15426c11b22d89a456ad62c37302f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3a4a5dff582db446092ec31dff7ac07f6c56f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644cb16bb367018811de44ec6a0f22813d106722" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server for virtual hosts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56394bb621be1c3ea64a9da0cc7c453f78c851ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as regular daemon for virtual hosts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb95273e719d9bbb038ef063d4fe7199f2a7aaf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0820ca6bb0780c196ed7a86287e4ecc94f9478" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bddd1875bfd788184caf49193c3ba66e07b6e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d3be1f649e59b3792c69f12f6776a563b79a47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5568faf67d40bb88542b7b67ef397df7105ffc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e447147bf3a29d6c97f55baf3c69e97f18f8eee8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [&amp;lt;commit&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d1c1e990e80e06e13a4eafe5a8bc5038d40599" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --no-index [--] &amp;lt;path&amp;gt; &amp;lt;path&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d86328721afc22cd489583dfba8df6685359245" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3453c9e134e20e25559107f3911fd6230cd8bc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git push&lt;/em&gt; uses a pair of commands, &lt;em&gt;git send-pack&lt;/em&gt; on your local machine, and &lt;em&gt;git-receive-pack&lt;/em&gt; on the remote machine. The communication between the two over the network internally uses an SSH connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf93dc31f705fddbb9194212d483f563999e11e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git receive-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc127848493f760fe053476520e3d12a67e1a15a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0143ed9ababaeb97962f5daf71b285ee855acf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8b6cc4b08d5db74f9966c865d7bdbc3e8057ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db1e64e46be79d2a9c84117847b63d5ab92c79c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6a869ee4e5a3eb64f1df2a1d1670adf970a316" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-archive &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2be43a079baf397e7d9b3bb2f1f647a64854d22" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b0677a6a48058174b9c4662c9d2ba987db8c81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;group&lt;/em&gt; (or &lt;em&gt;true&lt;/em&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55040b4473f65b2a2bbdfd28a71977476093b889" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41133af30f1b5a3e614609c0efa62b0bd14788f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7615a0bee74b428678cd3952d9a38bbd50138b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt; &amp;lt;name&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026584f5175b5bbc2ceb1f268e18940c0011aaec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;info&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;info&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0a5f718f14de716a46db8b2404578b5920000d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;init&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;init&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="286e2b7b70dbf3ef029c4799f2f0e629b0a5aef4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list for-push&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49361f1b70e440beb1d6cf2176c292c8e2abc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;list&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a100b4c5979c283ac452823f58dbcc9e5048c7b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971c241f477dec4b57be5fc29faa14ab335706fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;mkdirs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;mkdirs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35b67dffbe62b7476ce92342433b831e27d5bcee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;no-private-update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;no-private-update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b76f729b2c8dd001b33a3965716abefb37454800" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option atomic&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33bb338d193ab16d7a0168b421e3b698bb0bcbe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option check-connectivity&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c99d5f55da3961c68109a0e1d9a50e706a2120b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option cloning&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bd7fa50536660a2d31774812bb98fb7a2abdff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option deepen-relative {'true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98d1a36ae5cdad2003ea22f14ad851505cf3847" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option depth&lt;/em&gt; &amp;lt;depth&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d6797af0a212ad278e2948eaeaaf74a72f680a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option followtags&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9986eedd79cb9f9b7c70d2aedda0729823cac02a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option force&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111ea29454b6330909016c9e45b9b66754df6b19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option from-promisor&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800dda6c88e8893c227fca8a8c94622ca67dc810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option no-dependents&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea5bd740df1ec70168c7a478ecd00a132039f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option progress&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc4a2e0bb9f6060bdad740b788ef15fe9ea07c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option pushcert&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5978dddebb71223de8e8f6a60d2e3e72c7a65" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option servpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca7ff603e79015944d1670c4c4f6181601659ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option update-shallow&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0786067c699d96aadca89509b296234c78e51c6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option verbosity&lt;/em&gt; &amp;lt;n&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c59238310bfcf16cbbb35553d54bbfdca9360e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;option&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44f8139502701251329b628c8aa5e94fd7edfce3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba27d70f1550f4f882b78e61655d5157efb6f50e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propget&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propget&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6756585c61f2a32bab572f78fd3126b296699695" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;proplist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;proplist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e4008412d95ecd817c12ca15c192c575f546de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498ec3238e0f1d50b74e6af30a09c8f3309ba7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;prune&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;prune&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd31fb337461755bb5e3e31aef446948ecaa910d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;push&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c969a81bfce4fd2324388518d5f5e17de0b527" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt; +&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9117e882f570b9772bf4876578e36a25fc34732b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;qgit(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;qgit(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50ee056d4ddb76ef51f00483fe7dba34b51a449f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rebase&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rebase&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ea2b05c8f3c06fde58d0420744f0ca61045b90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd596b5091e1eb8368f579278c36824b713bc311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remaining&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remaining&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3ac08fba984c4fe2e39dbd6a9e3de5fb185a1f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b73121d3aa4f1dd8fa730929ede8f4b312f32337" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rename&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d13cdb6fdbae20acc2c43402406d81568a2499c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4c4fda591f60696add6ae66730f4d8ec836d261" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rm&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rm&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e477dd12e9e0460380eeba036cb09372c938695d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-branches&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-branches&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e65afe49a6eeb7cf02d2f6043f28b8a4ff342bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-head&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-head&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35f6993e8ee5f31dec406f06a31e049f29878752" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-tree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-tree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eda17e1c12e721d23988d4fc5e20726a9c47abd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8687e363ac98f906ebed1b843dd4f64a34e3c7f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6870a5d4b2985453a855890d8d72edfc3d70811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-externals&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-externals&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fe1dc07bdefa3cf58064ba55fde45829ca1f136" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd0e49781a98f7911b34f1aee38b44f2e869f16f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cc68266a42e8384ff3fa58baf8c34f3646c37ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;signed-tags&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;signed-tags&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86cead65159d3e086c70f8b7b59218a58d3147e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;stateless-connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4b47d3b1f6acb81c114d964233185b4c02ac419" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbef19eb270f01c4c2c82d2d02a006f9e49ea17d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;status&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;status&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc5dcfd7fa2c24a533fa19007091483ece18fad4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tag&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96d7bc00171f5fd2b09f66cf504ac0023cca30dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tig(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tig(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="139a3f1d23eafefa18ee2425482ff51b6f467d67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;umask&lt;/em&gt; (or &lt;em&gt;false&lt;/em&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0e9959206cb6877a60069410fa385eb4f78805" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unchanged&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unchanged&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ecf8aa641ca5e9e706fa0d63103b28681ce2dc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1802e8d4ef28dec4be0233820e8c05c3d927de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unspecified&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unspecified&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b312ee3f358f78767b6a06231fbf44287808e9ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aed0d22d6992ee80ec4d657f0cd95ab429e2ec9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;verify&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;verify&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f49b6f6188963904d82e1623f3020436895b7e2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;write&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8172ae9dcfb804bff8895259fe3102a0316b0619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; The latter form is just a short-hand of &lt;code&gt;git checkout topic&lt;/code&gt; followed by &lt;code&gt;git rebase master&lt;/code&gt;. When rebase exits &lt;code&gt;topic&lt;/code&gt; will remain the checked-out branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03388fb9a3fc2d66d455eba38ee0aa1f510dfbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; the changes introduced by the commits, and which are not reverted by subsequent commits, will still be in the rewritten branch. If you want to throw out &lt;code&gt;changes&lt;/code&gt; together with the commits, you should use the interactive mode of &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34561b8d811663906f33af73652542d0fcde7357" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;$my_url&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt;, and &lt;code&gt;$base_url&lt;/code&gt; are overwritten with their default values before every request, so if you want to change them, be sure to set this variable to true or a code reference effecting the desired changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09aea3b60370a4f963c3a85b4699f5aaace7982e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read the note for &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;'s &lt;code&gt;--reference&lt;/code&gt;, &lt;code&gt;--shared&lt;/code&gt;, and &lt;code&gt;--dissociate&lt;/code&gt; options carefully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9dfe7ce0f5b8ee96b2cbc1652fb8a81531cced" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command honors &lt;code&gt;.git/info/grafts&lt;/code&gt; file and refs in the &lt;code&gt;refs/replace/&lt;/code&gt; namespace. If you have any grafts or replacement refs defined, running this command will make them permanent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30c68c37350410fb672027924f29f5f9ab1c98c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74ae839c695329bca37194e38c0f34b77fadce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is intended for cleaning metadata, prefer the &lt;code&gt;--whitespace=fix&lt;/code&gt; mode of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for correcting whitespace of patches or files in the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585c6ddedc01781dae2a49fca690af8a9afad0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: for a file to be highlighted, its syntax type must be detected and that syntax must be supported by &quot;highlight&quot;. The default syntax detection is minimal, and there are many supported syntax types with no detection by default. There are three options for adding syntax detection. The first and second priority are &lt;code&gt;%highlight_basename&lt;/code&gt; and &lt;code&gt;%highlight_ext&lt;/code&gt;, which detect based on basename (the full filename, for example &quot;Makefile&quot;) and extension (for example &quot;sh&quot;). The keys of these hashes are the basename and extension, respectively, and the value for a given key is the name of the syntax to be passed via &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; to &quot;highlight&quot;. The last priority is the &quot;highlight&quot; configuration of &lt;code&gt;Shebang&lt;/code&gt; regular expressions to detect the language based on the first line in the file, (for example, matching the line &quot;#!/bin/bash&quot;). See the highlight documentation and the default config at /etc/highlight/filetypes.conf for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9b27f31414016f32b35409236f195a9797bba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--reference&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5918a0077865239a25fcfe555ed0525b81a0cce2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--shared&lt;/code&gt; option, and also the &lt;code&gt;--dissociate&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7c79db74439daa322af5432c4cb38d74b773b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand the implications (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8f10a91cc32941d397d3cbd72284f0494472a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git gc --auto&lt;/code&gt;. (See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c66780d5bfd012adc7033c6c0a4c5d63ded1f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; gitk (unlike &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) currently only understands this option if you specify it &quot;glued together&quot; with its argument. Do &lt;strong&gt;not&lt;/strong&gt; put a space after &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55897d0bbd0f3ca4e5eda8d2fd483ad8d798dcb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that no feature is overridable by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ea3f041b0ba373c69cf48b5644925866c5ecea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that rename and especially copy detection can be quite CPU-intensive. Note also that non Git tools can have problems with patches generated with options mentioned above, especially when they involve file copies ('-C') or criss-cross renames ('-B').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902c07c8249a8df193537556ae95a34d36a6294b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this requires to be set for each request, so either &lt;code&gt;$per_request_config&lt;/code&gt; must be false, or the above must be put in code referenced by &lt;code&gt;$per_request_config&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45e1902bb87b0712f0e2420e234000a3f2ef680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Also you can have a plain text file &lt;code&gt;.git&lt;/code&gt; at the root of your working tree, containing &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; to point at the real directory that has the repository. This mechanism is often used for a working tree of a submodule checkout, to allow you in the containing superproject to &lt;code&gt;git checkout&lt;/code&gt; a branch that does not have the submodule. The &lt;code&gt;checkout&lt;/code&gt; has to remove the entire submodule working tree, without losing the submodule repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fa00b64eae5b5c3890d9bb37bfa403b32cff82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: there is also a legacy &lt;code&gt;$stylesheet&lt;/code&gt; configuration variable, which was used by older gitweb. If &lt;code&gt;$stylesheet&lt;/code&gt; variable is defined, only CSS stylesheet given by this variable is used by gitweb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d7c2a95cf98eb3222f8ef736d4c5d7e8f5f3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; that in this case you don&amp;rsquo;t need special settings for &lt;code&gt;@stylesheets&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt; and &lt;code&gt;$home_link&lt;/code&gt;, but you lose &quot;dumb client&quot; access to your project .git dirs (described in &quot;Single URL for gitweb and for fetching&quot; section). A possible workaround for the latter is the following: in your project root dir (e.g. &lt;code&gt;/pub/git&lt;/code&gt;) have the projects named &lt;strong&gt;without&lt;/strong&gt; a .git extension (e.g. &lt;code&gt;/pub/git/project&lt;/code&gt; instead of &lt;code&gt;/pub/git/project.git&lt;/code&gt;) and configure Apache as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07043eaeaff4821b6e3d2bf0596ce3d880d9918c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parent:&lt;/strong&gt; All files immediately inside a directory are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32959a6518e6c4e84b5303e691c25180330dfdcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursive:&lt;/strong&gt; All paths inside a directory are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44ad2e7b5c600612a0a8797303bea45f315c6d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; for certain situations the import leads to incorrect results. Please see the section &lt;a href=&quot;#issues&quot;&gt;ISSUES&lt;/a&gt; for further reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9194839c57ad7da4a8bab5e0d40ab32351d35b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt;&lt;code&gt;git cvsimport&lt;/code&gt; uses cvsps version 2, which is considered deprecated; it does not work with cvsps version 3 and later. If you are performing a one-shot import of a CVS repository consider using &lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt; or &lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bcd3ed1b5437dcaa0e279477dd7d4ed74ad36f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;! The rewritten history will have different object names for all the objects and will not converge with the original branch. You will not be able to easily push and distribute the rewritten branch on top of the original branch. Please do not use this command if you do not know the full implications, and avoid using it anyway, if a simple single commit would suffice to fix your problem. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for further information about rewriting published history.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c57eef2952dcc7cbcb3f3594949c7f400ccd82e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Running &lt;code&gt;git merge&lt;/code&gt; with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="2e41f73876997d3719c74ffacd713f8bedda0ef1" translate="yes" xml:space="preserve">
          <source>@diff_opts</source>
          <target state="translated">@diff_opts</target>
        </trans-unit>
        <trans-unit id="ece9251682dfe6d86397776eeae7c5bceec968bb" translate="yes" xml:space="preserve">
          <source>@extra_breadcrumbs</source>
          <target state="translated">@extra_breadcrumbs</target>
        </trans-unit>
        <trans-unit id="d642d6b3afbdc1fe579a545767dd08c49fb22d26" translate="yes" xml:space="preserve">
          <source>@git_base_url_list</source>
          <target state="translated">@git_base_url_list</target>
        </trans-unit>
        <trans-unit id="d1cb9d322cf309d895cfe28288e26547a4f2023b" translate="yes" xml:space="preserve">
          <source>@stylesheets</source>
          <target state="translated">@stylesheets</target>
        </trans-unit>
        <trans-unit id="17f8f0c63a0ac553bacb3cc13b4bba7ffe3a1b0c" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; is just file data, which we can also examine with cat-file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48346c16ecaa075a67739766a897040a2f3413ba" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; object is nothing but a binary blob of data. It doesn&amp;rsquo;t refer to anything else or have attributes of any kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bff4978d5abc6efec633665a6a6e240b98928c" translate="yes" xml:space="preserve">
          <source>A &quot;branch&quot; is an active line of development. The most recent &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, which moves forward as additional development is done on the branch. A single Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can track an arbitrary number of branches, but your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is associated with just one of them (the &quot;current&quot; or &quot;checked out&quot; branch), and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; points to that branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01578f0bd22457eb0af668d78f12e9483b4aa95" translate="yes" xml:space="preserve">
          <source>A &quot;combined diff&quot; format looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd53e12d383c6d235aea40bfa1170ca1c16d64c" translate="yes" xml:space="preserve">
          <source>A &quot;light&quot; tag is technically nothing more than a branch, except we put it in the &lt;code&gt;.git/refs/tags/&lt;/code&gt; subdirectory instead of calling it a &lt;code&gt;head&lt;/code&gt;. So the simplest form of tag involves nothing more than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a6a59906f3a3c6cb0aaa94c5e091d6ff4d2697" translate="yes" xml:space="preserve">
          <source>A &quot;patch ID&quot; is nothing but a sum of SHA-1 of the file diffs associated with a patch, with whitespace and line numbers ignored. As such, it&amp;rsquo;s &quot;reasonably stable&quot;, but at the same time also reasonably unique, i.e., two patches that have the same &quot;patch ID&quot; are almost guaranteed to be the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c2193bcd0be75dda12f0549bb6c953d953abdc" translate="yes" xml:space="preserve">
          <source>A &quot;proxy command&quot; to execute (as &lt;code&gt;command host port&lt;/code&gt;) instead of establishing direct connection to the remote server when using the Git protocol for fetching. If the variable value is in the &quot;COMMAND for DOMAIN&quot; format, the command is applied only on hostnames ending with the specified domain string. This variable may be set multiple times and is matched in the given order; the first match wins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f3117f71091d9312b93d71f6f1f95e92690216" translate="yes" xml:space="preserve">
          <source>A &quot;refspec&quot; is used by &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; and &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt; to describe the mapping between remote &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; and local ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d877d63b6b5e9d7da0337dffb75c191c08f97905" translate="yes" xml:space="preserve">
          <source>A &quot;release&quot; tree into which tested patches are moved for final sanity checking, and as a vehicle to send them upstream to Linus (by sending him a &quot;please pull&quot; request.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff4d6ad0b357610ea5d99a54033d43fa5c5c86c" translate="yes" xml:space="preserve">
          <source>A &quot;test&quot; tree into which patches are initially placed so that they can get some exposure when integrated with other ongoing development. This tree is available to Andrew for pulling into -mm whenever he wants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ec64c5418b4e1b2393cccdbc573a28510a5c03" translate="yes" xml:space="preserve">
          <source>A 1-based counter incremented by one for every path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0615d3cb94994b8c99f6c3eb1d8a16fe3788d798" translate="yes" xml:space="preserve">
          <source>A 256-entry fan-out table just like v1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bb9a8b1ee368142624185fa1ae5c67aeb898ce" translate="yes" xml:space="preserve">
          <source>A 4-byte magic number &lt;code&gt;\377tOc&lt;/code&gt; which is an unreasonable fanout[0] value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1ce6a5d795c5121faecb5f38bcdfbcd91b2ab7" translate="yes" xml:space="preserve">
          <source>A 4-byte version number (= 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bede587e880e37efdb2a5ef16eda4ba90c67697" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_blob_object&quot;&gt;&quot;blob&quot; object&lt;/a&gt; is used to store file data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54288b35ef53475c72a23d4daf82b2c03c4a8f0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;&quot;commit&quot; object&lt;/a&gt; ties such directory hierarchies together into a &lt;a href=&quot;#def_DAG&quot;&gt;directed acyclic graph&lt;/a&gt; of revisions&amp;mdash;​each commit contains the object name of exactly one tree designating the directory hierarchy at the time of the commit. In addition, a commit refers to &quot;parent&quot; commit objects that describe the history of how we arrived at that directory hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8530617aaaf740a14961ad3389fd991b174e36b0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0f59568c969c04ae2919aa1276ec43b776c9bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a commit object, a tag object that points to a tag object that points to a commit object, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6389313e21c94c3cd1f531678dbaff3d7f4b17f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;named reference&lt;/a&gt; to the &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; at the tip of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Heads are stored in a file in &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; directory, except when using packed refs. (See &lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs[1]&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b389d584563a677fb26744bbc70caa1d1f76e96" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace242fdc7f696a4feaa54f7241c321210896890" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; (indicating that it tracks a branch named &lt;code&gt;bar&lt;/code&gt; in a remote named &lt;code&gt;foo&lt;/code&gt;), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf1d644e82a336ab047afaf23e6c38f6d2319f7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; under &lt;code&gt;refs/tags/&lt;/code&gt; namespace that points to an object of an arbitrary type (typically a tag points to either a &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; or a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). In contrast to a &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, a tag is not updated by the &lt;code&gt;commit&lt;/code&gt; command. A Git tag has nothing to do with a Lisp tag (which would be called an &lt;a href=&quot;#def_object_type&quot;&gt;object type&lt;/a&gt; in Git&amp;rsquo;s context). A tag is most typically used to mark a particular point in the commit ancestry &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc46cfe77ce6b43ff04fe1e7aebea708602c159d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that holds the history of a separate project inside another repository (the latter of which is called &lt;a href=&quot;#def_superproject&quot;&gt;superproject&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438f4d0a1f63f0722cdeaf18b4e76a69d1faf0a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that references repositories of other projects in its working tree as &lt;a href=&quot;#def_submodule&quot;&gt;submodules&lt;/a&gt;. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5fd39e912fa9dd55cd15e3992de80c831bb2a4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; which is used to track the same project but resides somewhere else. To communicate with remotes, see &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; or &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328013b8812fa91caece6ff64eff68b5bce54efc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; is created by specifying the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch. The depth can later be changed with the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch, or full history restored with &lt;code&gt;--unshallow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6e57120855e95e9e182d5d994eedc42293e0e9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt;, with its truncated history, is useful when one is interested only in recent history of a project and getting full history from the upstream is expensive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5040a665f644abaf265d1f9e647b81d27b4cfd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tag_object&quot;&gt;&quot;tag&quot; object&lt;/a&gt; symbolically identifies and can be used to sign other objects. It contains the object name and type of another object, a symbolic name (of course!) and, optionally, a signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300bf6998ca24b2549892a071c929ed803f223bb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;&quot;tree&quot; object&lt;/a&gt; ties one or more &quot;blob&quot; objects into a directory structure. In addition, a tree object can refer to other tree objects, thus creating a directory hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b0ce7b8c7522d74c7f9ad5ab8411731aaf299c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a tree object. Dereferencing a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; yields the tree object corresponding to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;'s top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;. The following are all tree-ishes: a &lt;a href=&quot;#def_commit-ish&quot;&gt;commit-ish&lt;/a&gt;, a tree object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a tree object, a tag object that points to a tag object that points to a tree object, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6766aaa194eae4342acb9b6eb8fe5dbb99ba5e2c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is clean, if it corresponds to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; referenced by the current &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;. Also see &quot;&lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910148d563c361f2f9ac9396584595cbecacd2d1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is said to be &quot;dirty&quot; if it contains modifications which have not been &lt;a href=&quot;#def_commit&quot;&gt;committed&lt;/a&gt; to the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cef23a772a587d1dc5174a039d5d2a56a2421b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; string must use UNIX-style directory separators (forward slash &lt;code&gt;/&lt;/code&gt;), may contain any byte other than &lt;code&gt;LF&lt;/code&gt;, and must not start with double quote (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25aaa39fff8a33da0ed231c681da2d1cc8f12d2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; specification can be either a single pattern, or a pair of such patterns separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4a35cc1f6ad4a24fbad41012f4dee139cf11ca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;-&lt;/code&gt; character in the column N means that the line appears in fileN but it does not appear in the result. A &lt;code&gt;+&lt;/code&gt; character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f763d8aeb342898c485136e58023ca41a911c41" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fetch&lt;/code&gt; request can take the following arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc49de55f827e970a03efc67dad77118b50f2b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filecopy&lt;/code&gt; command takes effect immediately. Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b84f934e1b33bd4484622bc003d74b0f10abf36" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filerename&lt;/code&gt; command takes effect immediately. Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ce3d61d685b39ad1b7df023b9aae5356d34434" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filter&lt;/code&gt; attribute can be set to a string value that names a filter driver specified in the configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1b84b3e4f681759dcd049b031dfc1f3c0de5ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitattributes&lt;/code&gt; file is a simple text file that gives &lt;code&gt;attributes&lt;/code&gt; to pathnames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66ea4477ef0ba53ddd8e40294e2410ce0649ca9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitignore&lt;/code&gt; file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e637494c00a4030e3a229e0cf561d46671742b0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;map&lt;/code&gt; function is available that takes an &quot;original sha1 id&quot; argument and outputs a &quot;rewritten sha1 id&quot; if the commit has been already rewritten, and &quot;original sha1 id&quot; otherwise; the &lt;code&gt;map&lt;/code&gt; function can return several ids on separate lines if your commit filter emitted multiple commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c17077eaabfda4b09416a4110316c7774b1c6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;mark&lt;/code&gt; command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format). It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b43e35048f39cc98d8056bd70595785c095f7f4" translate="yes" xml:space="preserve">
          <source>A CVS server emulator for Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499e3b350610a0a7f42474bdeb7c1c19319ba58c" translate="yes" xml:space="preserve">
          <source>A Git project normally consists of a working directory with a &quot;.git&quot; subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an &quot;index&quot; file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a40623b731bcb70270f3faeba427fe44362569" translate="yes" xml:space="preserve">
          <source>A Git repository comes in two different flavours:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81aa8115ce6f03214fb303ff61bdf68ead1b6d0" translate="yes" xml:space="preserve">
          <source>A GnuPG signed tag object will be created when &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u
&amp;lt;keyid&amp;gt;&lt;/code&gt; is used. When &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is not used, the committer identity for the current user is used to find the GnuPG key for signing. The configuration variable &lt;code&gt;gpg.program&lt;/code&gt; is used to specify custom GnuPG binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ace8057741243c07f0a9c439ea72cf149ebea7" translate="yes" xml:space="preserve">
          <source>A POSIX Extended Regular Expression used to determine what is a &quot;word&quot; when performing word-by-word difference calculations. Character sequences that match the regular expression are &quot;words&quot;, all other characters are &lt;strong&gt;ignorable&lt;/strong&gt; whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b36e18a0d1a006f1ac7d7980a588087d5b430d" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive &lt;code&gt;git commit&lt;/code&gt; program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b96204f8a09a4e60b67d30c184c76ab3aa13246" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical user interface to Git. &lt;code&gt;git gui&lt;/code&gt; focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24909c1b0660496a6bde046217501091c32d35a8" translate="yes" xml:space="preserve">
          <source>A URL identifying the server. Use an &lt;code&gt;imap://&lt;/code&gt; prefix for non-secure connections and an &lt;code&gt;imaps://&lt;/code&gt; prefix for secure connections. Ignored when imap.tunnel is set, but required otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e4f1c46822a29c15a31d1976020e3202745e04" translate="yes" xml:space="preserve">
          <source>A URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; explicitly instructs Git to invoke &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; as the second argument. If such a URL is encountered directly on the command line, the first argument is &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd88b7183354ef38e42a5694ea11c6ad40c90a63" translate="yes" xml:space="preserve">
          <source>A bare repository is normally an appropriately named &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; with a &lt;code&gt;.git&lt;/code&gt; suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden &lt;code&gt;.git&lt;/code&gt; sub-directory are directly present in the &lt;code&gt;repository.git&lt;/code&gt; directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab59df7bed21e1355a3a3fdd6c1ee8b01aad2ba" translate="yes" xml:space="preserve">
          <source>A birds-eye view of Git&amp;rsquo;s source code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e4eeef8aa3fdcfbc58a9b30e01464d317f5146" translate="yes" xml:space="preserve">
          <source>A bit more elaborate report on tags, demonstrating that the format may be an entire script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146b6a7f060c34e94845d66a1242bb6c9a7f4e58" translate="yes" xml:space="preserve">
          <source>A blank line matches no files, so it can serve as a separator for readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556a519047d3c2b7e5ab74e824666155b316bdbf" translate="yes" xml:space="preserve">
          <source>A boolean or int to specify the level of verbose with &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9e4313a71ccb8b0351ad99469fa4eb3f3f9ac9" translate="yes" xml:space="preserve">
          <source>A boolean that controls whether to generate a cover-letter when format-patch is invoked, but in addition can be set to &quot;auto&quot;, to generate a cover-letter only when there&amp;rsquo;s more than one patch. Default is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5594a28e2c0e4043dd1d1bbbff86fb17f935ca8e" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in hints (e.g. when a push failed, see &lt;code&gt;advice.*&lt;/code&gt; for a list). May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbf675a2936dcecf3b1a2336c5df4b332604e58" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in push errors. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423a3d788dfbe4bee04a423e0b36c0319dcd4d83" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2e2c7e2ba4cb7674d5cd8117d8f0b42a85dae9" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3e78cce49781de5f532bd4c5e0796c9098f940" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297391e190582ac1cb26cf2a45a94d7b84f1e151" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color when pushes are rejected. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd8faf8bbae108bc3e3db709a35680c5dec839a" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable colored output when the pager is in use (default is true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29f1ced583e3f5a70811c52e97c2481cc279f73" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d858807e8af6ae2203a74b627cef96e1757782" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable the use of html encoding when sending a patch. An html encoded patch will be bracketed with &amp;lt;pre&amp;gt; and have a content type of text/html. Ironically, enabling this option causes Thunderbird to send the patch as a plain/text, format=fixed email. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f4c2eeab634e1e21aa0984b28bad1eef24f55b" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable verification of the server certificate used by the SSL/TLS connection. Default is &lt;code&gt;true&lt;/code&gt;. Ignored when imap.tunnel is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba56edef0f759e6a6fb72f98e61ae0b81ab53f7" translate="yes" xml:space="preserve">
          <source>A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4f8a419cff5bc7a9aa83bbb22ddc4383ad75de" translate="yes" xml:space="preserve">
          <source>A boolean to make git-clean do nothing unless given -f, -i or -n. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac4f1587b4bbb5651120aa9065e93380285e902" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285446918c9332ac6592ad772bc51e35d0bb94c4" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all tags should be GPG signed. Use of this option when running in an automated script can result in a large number of tags being signed. It is therefore convenient to use an agent to avoid typing your gpg passphrase several times. Note that this option doesn&amp;rsquo;t affect tag signing behavior enabled by &quot;-u &amp;lt;keyid&amp;gt;&quot; or &quot;--local-user=&amp;lt;keyid&amp;gt;&quot; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8196128852a99f0296cb3a9178bf0edc9d5e344a" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether annotated tags created should be GPG signed. If &lt;code&gt;--annotate&lt;/code&gt; is specified on the command line, it takes precedence over this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95ae970d328003d484aaeb100825d3fb66dda25" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98939eb557a27a368986b34536ff6c8cd4c36abd" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;-s/--signoff&lt;/code&gt; option of format-patch by default. &lt;strong&gt;Note:&lt;/strong&gt; Adding the Signed-off-by: line to a patch should be a conscious act and means that you certify you have the rights to submit this work under the same open source license. Please see the &lt;code&gt;SubmittingPatches&lt;/code&gt; document for further discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52843a970e21e2ecc8fa28c4ccdfeaf085918760" translate="yes" xml:space="preserve">
          <source>A boolean which can enable or disable sequence numbers in patch subjects. It defaults to &quot;auto&quot; which enables it only if there is more than one patch. It can be enabled or disabled for all messages by setting it to &quot;true&quot; or &quot;false&quot;. See --numbered option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaf2f30624eb10b8aee0a4842fe24fd9d5d1733" translate="yes" xml:space="preserve">
          <source>A boolean which disables using of EPSV ftp command by curl. This can helpful with some &quot;poor&quot; ftp servers which don&amp;rsquo;t support EPSV mode. Can be overridden by the &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; environment variable. Default is false (curl will use EPSV).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40656baca50661122d33e0890da13d751ed316a" translate="yes" xml:space="preserve">
          <source>A built-in pattern is provided for all languages listed in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302353030177edeeb70686cd4f5139eb1acdd092" translate="yes" xml:space="preserve">
          <source>A bundle from a recipient repository&amp;rsquo;s point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5fcdefb11694692ac802e09961aef7e73e5df0" translate="yes" xml:space="preserve">
          <source>A caveat is that older reflog entries in your repository may be expired by &lt;code&gt;git gc&lt;/code&gt;. If B0 no longer appears in the reflog of the remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt;, the &lt;code&gt;--fork-point&lt;/code&gt; mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the &lt;code&gt;--fork-point&lt;/code&gt; option gives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b2d53c7c7f7197e6449bea92bdc1e149be79ae" translate="yes" xml:space="preserve">
          <source>A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fded59f54db89df8b3f442b60da3137cb35cf1c" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;#def_ref&quot;&gt;refs&lt;/a&gt; together with an &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; containing all objects which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the refs, possibly accompanied by meta data from one or more &lt;a href=&quot;#def_porcelain&quot;&gt;porcelains&lt;/a&gt;. A repository can share an object database with other repositories via &lt;a href=&quot;#def_alternate_object_database&quot;&gt;alternates mechanism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df01e27bf740894293c8642767b5b6f6ba2bfe1f" translate="yes" xml:space="preserve">
          <source>A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when &lt;a href=&quot;#def_merge&quot;&gt;merging&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a6e96629904ef8963fcbbd33f5c0e5160e4b14" translate="yes" xml:space="preserve">
          <source>A colon &lt;code&gt;:&lt;/code&gt; is used as in &lt;code&gt;srcref:dstref&lt;/code&gt; to mean &quot;use srcref&amp;rsquo;s value and store it in dstref&quot; in fetch and push operations. It may also be used to select a specific object such as with 'git cat-file': &quot;git cat-file blob v1.3.3:refs.c&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa4235099cacbb93254de4106a73880e13a4bbc" translate="yes" xml:space="preserve">
          <source>A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. &lt;code&gt;:/^foo&lt;/code&gt;. The special sequence &lt;code&gt;:/!&lt;/code&gt; is reserved for modifiers to what is matched. &lt;code&gt;:/!-foo&lt;/code&gt; performs a negative match, while &lt;code&gt;:/!!foo&lt;/code&gt; matches a literal &lt;code&gt;!&lt;/code&gt; character, followed by &lt;code&gt;foo&lt;/code&gt;. Any other sequence beginning with &lt;code&gt;:/!&lt;/code&gt; is reserved for now. Depending on the given text, the shell&amp;rsquo;s word splitting rules might require additional quoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13756e35429ac459169fe4f0ae98f0d2e3c822ed" translate="yes" xml:space="preserve">
          <source>A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch&amp;rsquo;s version (typically the current branch), and stage 3 is the version from the branch which is being merged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caa5f563f7545c6d876e685c6213fbb94df9ad3" translate="yes" xml:space="preserve">
          <source>A comma and/or whitespace separated list of encodings that Git performs UTF-8 round trip checks on if they are used in an &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). The default value is &lt;code&gt;SHIFT-JIS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2d1e893ce7e09a76d55d9b9450e681bcdfc845" translate="yes" xml:space="preserve">
          <source>A comma separated list of &lt;code&gt;--dirstat&lt;/code&gt; parameters specifying the default behavior of the &lt;code&gt;--dirstat&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and friends. The defaults can be overridden on the command line (using &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt;). The fallback defaults (when not changed by &lt;code&gt;diff.dirstat&lt;/code&gt;) are &lt;code&gt;changes,noncumulative,3&lt;/code&gt;. The following parameters are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c61024b3e6d8b4fd7db663d99f9e656029c4cd" translate="yes" xml:space="preserve">
          <source>A comma separated list of common whitespace problems to notice. &lt;code&gt;git diff&lt;/code&gt; will use &lt;code&gt;color.diff.whitespace&lt;/code&gt; to highlight them, and &lt;code&gt;git apply --whitespace=error&lt;/code&gt; will consider them as errors. You can prefix &lt;code&gt;-&lt;/code&gt; to disable any of them (e.g. &lt;code&gt;-trailing-space&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb282cbfbc43caeda403e67d10ddbed3e0b9cd80" translate="yes" xml:space="preserve">
          <source>A comma-separated list of patterns of &quot;important&quot; config settings that should be recorded in the trace2 output. For example, &lt;code&gt;core.*,remote.*.url&lt;/code&gt; would cause the trace2 output to contain events listing each configured remote. May be overridden by the &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fab91cb4daf1c47222fcbb845cf8839d9381cfa" translate="yes" xml:space="preserve">
          <source>A commit comment is read from stdin. If a changelog entry is not provided via &quot;&amp;lt;&quot; redirection, &lt;code&gt;git commit-tree&lt;/code&gt; will just wait for one to be entered and terminated with ^D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1dc52f2c7f4f92de3fbbe4920a9bf34ad24479" translate="yes" xml:space="preserve">
          <source>A commit encapsulates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc26f5acfd22e9eac8779b8f191ce6307d46b3a" translate="yes" xml:space="preserve">
          <source>A commit is usually created by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, which creates a commit whose parent is normally the current HEAD, and whose tree is taken from the content currently stored in the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd78b04bea05d29acf58eb590016b304b9a695a" translate="yes" xml:space="preserve">
          <source>A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73e034726177d0d1de0cc7cb0b4640f70795d7d" translate="yes" xml:space="preserve">
          <source>A commit&amp;rsquo;s reachable set is the commit itself and the commits in its ancestry chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0c7cb4b676d44b852130363daf17e0059e5d35" translate="yes" xml:space="preserve">
          <source>A common idiom to check &quot;fast-forward-ness&quot; between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efeda38b74e243af3941ca4cb1afcb6d50536c89" translate="yes" xml:space="preserve">
          <source>A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edc728da69ffd96fd56c998aef47f3f04d15f9f" translate="yes" xml:space="preserve">
          <source>A common shorthand for &lt;code&gt;git diff-files -p&lt;/code&gt; is to just write &lt;code&gt;git
diff&lt;/code&gt;, which will do the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a9ba1b1e1a8bc290e55e84eb3c20bc97ffb373" translate="yes" xml:space="preserve">
          <source>A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes. Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense. This command does &lt;code&gt;git p4 sync&lt;/code&gt; followed by &lt;code&gt;git rebase&lt;/code&gt; to move local commits on top of updated p4 changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fa8348285318059dfacd14294d170b4fc808f0" translate="yes" xml:space="preserve">
          <source>A complete 40 byte or abbreviated commit SHA-1 in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02926b5c0160f21e1aa42320ded7f690bec583ac" translate="yes" xml:space="preserve">
          <source>A configuration identity. When given, causes values in the &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; subsection to take precedence over values in the &lt;code&gt;sendemail&lt;/code&gt; section. The default identity is the value of &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d1e222ae59833da8390e3205af99d5791ad8cb" translate="yes" xml:space="preserve">
          <source>A conflict occurs if both &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; have changes in a common segment of lines. If a conflict is found, &lt;code&gt;git merge-file&lt;/code&gt; normally outputs a warning and brackets the conflict with lines containing &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; and &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; markers. A typical conflict will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bd76c9e5bd5a5c306cd10ddbfbe3c7ac2875c0" translate="yes" xml:space="preserve">
          <source>A convenience alias for &lt;code&gt;--only-trailers --only-input
--unfold&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97978af293e3af436b507f6dc4b9076f9f973577" translate="yes" xml:space="preserve">
          <source>A debug option to help with future &quot;partial clone&quot; development. This option specifies how missing objects are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d7d5495841c41cd87cf2e545d3c8aff9d18129" translate="yes" xml:space="preserve">
          <source>A default username, if one is not provided in the URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba5596219f17f93a98404ea4497b915ef344a8c" translate="yes" xml:space="preserve">
          <source>A delimiter string is used to mark the end of the data. fast-import will compute the length by searching for the delimiter. This format is primarily useful for testing and is not recommended for real data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e88086f294c6f14da1c8f79767c0e47b61a6a2" translate="yes" xml:space="preserve">
          <source>A developer working as a participant in a group project needs to learn how to communicate with others, and uses these commands in addition to the ones needed by a standalone developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa00f0c6fcff7a20980dde937b6f2c6eff19948d" translate="yes" xml:space="preserve">
          <source>A directory to add to the whitelist of allowed directories. Unless --strict-paths is specified this will also include subdirectories of each named directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72583fc1f6c7369768db5e1d7fb0e226e0f4e70" translate="yes" xml:space="preserve">
          <source>A double-dot &lt;code&gt;..&lt;/code&gt; is often used as in &lt;code&gt;ref1..ref2&lt;/code&gt;, and in some contexts this notation means &lt;code&gt;^ref1 ref2&lt;/code&gt; (i.e. not in &lt;code&gt;ref1&lt;/code&gt; and in &lt;code&gt;ref2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdb3523eaeda3961c032ea5c0f58f6c364cd9b3" translate="yes" xml:space="preserve">
          <source>A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6068affbbe0ff6a579ff1d24351f9cddf70755" translate="yes" xml:space="preserve">
          <source>A fairly central person acting as the integrator in a group project receives changes made by others, reviews and integrates them and publishes the result for others to use, using these commands in addition to the ones needed by participants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b9ceab10a1cb84bc6e55a7f4299b34b10f0e2f" translate="yes" xml:space="preserve">
          <source>A fast-forward is a special type of &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; where you have a &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; and you are &quot;merging&quot; another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;'s changes that happen to be a descendant of what you have. In such a case, you do not make a new &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; but instead just update to his revision. This will happen frequently on a &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branch&lt;/a&gt; of a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1639e68ef8005bf8b9fd0a9765a95c3e36366d5" translate="yes" xml:space="preserve">
          <source>A fast-forward looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e7c39642f6628198b3a6330b5201dad9a7aff7" translate="yes" xml:space="preserve">
          <source>A fatal error was encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2eaf514674a6a55b836d451eca54479349bb70" translate="yes" xml:space="preserve">
          <source>A feature release is created from the &lt;code&gt;master&lt;/code&gt; branch, since &lt;code&gt;master&lt;/code&gt; tracks the commits that should go into the next feature release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ba6f95b54ef3076dd734e20033705f91d3f8bd" translate="yes" xml:space="preserve">
          <source>A few configuration variables (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) can make it easy to push both branches to your public tree. (See &lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;Setting up a public repository&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b328fdc14f23c3b282a30f44ac30ff04e6b3868" translate="yes" xml:space="preserve">
          <source>A few more notes on matching via &lt;code&gt;gitdir&lt;/code&gt; and &lt;code&gt;gitdir/i&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c1c3db8333ea0856e57a216b0202a880b8b0fd" translate="yes" xml:space="preserve">
          <source>A field name to sort on. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. When unspecified, &lt;code&gt;refname&lt;/code&gt; is used. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fa2104992d30057f7ee2ca78ba1b9cc1b33c21" translate="yes" xml:space="preserve">
          <source>A filter driver consists of a &lt;code&gt;clean&lt;/code&gt; command and a &lt;code&gt;smudge&lt;/code&gt; command, either of which can be left unspecified. Upon checkout, when the &lt;code&gt;smudge&lt;/code&gt; command is specified, the command is fed the blob object from its standard input, and its standard output is used to update the worktree file. Similarly, the &lt;code&gt;clean&lt;/code&gt; command is used to convert the contents of worktree file upon checkin. By default these commands process only a single blob and terminate. If a long running &lt;code&gt;process&lt;/code&gt; filter is used in place of &lt;code&gt;clean&lt;/code&gt; and/or &lt;code&gt;smudge&lt;/code&gt; filters, then Git can process all blobs with a single filter command invocation for the entire life of a single Git command, for example &lt;code&gt;git add --all&lt;/code&gt;. If a long running &lt;code&gt;process&lt;/code&gt; filter is configured then it always takes precedence over a configured single blob filter. See section below for the description of the protocol used to communicate with a &lt;code&gt;process&lt;/code&gt; filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a399e6db3987e04a0a954aa555198a880460b1b3" translate="yes" xml:space="preserve">
          <source>A format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, to be used for the todo list during an interactive rebase. The format will automatically have the long commit hash prepended to the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef0d2618bd1f2707924d8265b8cbc81cb0f4df7" translate="yes" xml:space="preserve">
          <source>A formatted and hyperlinked copy of the latest Git documentation can be viewed at &lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt; or &lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1611e58cf3ba6bbcadd845b19a6529d9c8709a09" translate="yes" xml:space="preserve">
          <source>A freshly cloned repository contains a single branch head, by default named &quot;master&quot;, with the working directory initialized to the state of the project referred to by that branch head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9361f96571e895bc96ccb37b799d33736e1313bd" translate="yes" xml:space="preserve">
          <source>A frontend set up this way can use &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; commands to read information from the import in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec35e8b31b58ee10f23bf6c56b94488c655953e" translate="yes" xml:space="preserve">
          <source>A general note on safety: supplying this option without an expected value, i.e. as &lt;code&gt;--force-with-lease&lt;/code&gt; or &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; interacts very badly with anything that implicitly runs &lt;code&gt;git fetch&lt;/code&gt; on the remote to be pushed to in the background, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; on your repository in a cronjob.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed755acace2a48ffeeff6fb565baf90507fd745" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &quot;git init&quot; or &quot;git clone&quot;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb35f01e2c3f5716f9ff7a011caefd2667f92277" translate="yes" xml:space="preserve">
          <source>A glob pattern that matches branch or tag names under refs/. For example, if you have many topic branches under refs/heads/topic, giving &lt;code&gt;topic/*&lt;/code&gt; would show all of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190546c0fc74bb90a9365e134f633644e2a48fc0" translate="yes" xml:space="preserve">
          <source>A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with &lt;code&gt;/*&lt;/code&gt;. The above specifies that all remote branches are tracked using remote-tracking branches in &lt;code&gt;refs/remotes/origin/&lt;/code&gt; hierarchy under the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b9d757fdd2ed971a566d8afcb44af578620a00" translate="yes" xml:space="preserve">
          <source>A good place to start is with the contents of the initial commit, with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5629e7ec2db5ea11dbadd12ca8d2c545f75144" translate="yes" xml:space="preserve">
          <source>A handy way to push the current branch to the same name on the remote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8420ab633ffe4ffea61082096882d33b9782db25" translate="yes" xml:space="preserve">
          <source>A header appears at the beginning and consists of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd26c474482563b0a0cde7feb34691662847c30b" translate="yes" xml:space="preserve">
          <source>A helper advertising the capability &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; is saying that, when it is asked to &lt;code&gt;import refs/heads/topic&lt;/code&gt;, the stream it outputs will update the &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a80004c991a3f9b4309875108440f77b31093a" translate="yes" xml:space="preserve">
          <source>A html file (HTML fragment) which is included on the gitweb project &quot;summary&quot; page inside &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; block element. You can use it for longer description of a project, to provide links (for example to project&amp;rsquo;s homepage), etc. This is recognized only if XSS prevention is off (&lt;code&gt;$prevent_xss&lt;/code&gt; is false, see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;); a way to include a README safely when XSS prevention is on may be worked out in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd437060459f74aebbd18b9e1cd799a77abb2e3" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f2620460bac465215c8ebb35f39e6332181467" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9b8dd4dd7232e67cd2ac62d96fc72ced1418df" translate="yes" xml:space="preserve">
          <source>A leading &quot;&lt;code&gt;**&lt;/code&gt;&quot; followed by a slash means match in all directories. For example, &quot;&lt;code&gt;**/foo&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot; anywhere, the same as pattern &quot;&lt;code&gt;foo&lt;/code&gt;&quot;. &quot;&lt;code&gt;**/foo/bar&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;bar&lt;/code&gt;&quot; anywhere that is directly under directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f6b7568cdd7cd0d826aa05b6dbc1219066bda8" translate="yes" xml:space="preserve">
          <source>A leading &amp;ldquo;&lt;strong&gt;&amp;rdquo; followed by a slash means match in all directories. For example, &amp;ldquo;&lt;/strong&gt;/foo&amp;rdquo; matches file or directory &amp;ldquo;foo&amp;rdquo; anywhere, the same as pattern &amp;ldquo;foo&amp;rdquo;. &amp;ldquo;**/foo/bar&amp;rdquo; matches file or directory &amp;ldquo;bar&amp;rdquo; anywhere that is directly under directory &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8f962f2c5484e8e35937a88a5b10524899265d" translate="yes" xml:space="preserve">
          <source>A line starting with # serves as a comment. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first hash for patterns that begin with a hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ea1d2be8a3f17ecb8e1b8c1df7c56dd65b653c" translate="yes" xml:space="preserve">
          <source>A line that defines a value can be continued to the next line by ending it with a &lt;code&gt;\&lt;/code&gt;; the backquote and the end-of-line are stripped. Leading whitespaces after &lt;code&gt;name =&lt;/code&gt;, the remainder of the line after the first comment character &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt;, and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e045379bf9ceca1c017025a4aa6255f96ea8439c" translate="yes" xml:space="preserve">
          <source>A list of SSL ciphers to use when negotiating an SSL connection. The available ciphers depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; option; see the libcurl documentation for more details on the format of this list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c29c3e295aee253a56f78c75eca16ee4e34a579" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt; (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420b50217489bdf5f6fb9acc6b31c779455eb7fa" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt;, that specifies the specific objects and references to export. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master~9 and master~10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb05e036e321c60d20fab2990848c796c4fdcdc0" translate="yes" xml:space="preserve">
          <source>A list of colors, separated by commas, that can be used to draw history lines in &lt;code&gt;git log --graph&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5bc7dd64f11fdc046f9ab831535ad5346e3642" translate="yes" xml:space="preserve">
          <source>A list of metadata for the ith object ID including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a1660072afab5f192d304c6526e11a86c64fed" translate="yes" xml:space="preserve">
          <source>A list of objects, where each &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the list contains a reference to its successor (for example, the successor of a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; could be one of its &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ed6b3e420a3426ad69e7d40c511b1585c55951" translate="yes" xml:space="preserve">
          <source>A list of packfile names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf8acfc6a510356f2536425e15b68215e037b6" translate="yes" xml:space="preserve">
          <source>A list of references used to limit the references reported as available. This is principally of use to &lt;code&gt;git fetch&lt;/code&gt;, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, &lt;code&gt;git bundle&lt;/code&gt; acts like &lt;code&gt;git fetch-pack&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e674656171c048f36512c6e555d0bf166acfba" translate="yes" xml:space="preserve">
          <source>A listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1fa860bd3075a2f2e7d9bfa6fd3e508ce503b8" translate="yes" xml:space="preserve">
          <source>A long running filter demo implementation can be found in &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; located in the Git core repository. If you develop your own long running filter process then the &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; environment variables can be very helpful for debugging (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c85a74fa5c3962acf646f43bc3d679fdbcbb049" translate="yes" xml:space="preserve">
          <source>A mapping will override any user information from P4. Mappings for multiple P4 user can be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830620e3507664edd811855851325f3aba696d1" translate="yes" xml:space="preserve">
          <source>A mark reference, &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; is the mark number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baabb9591c6356cfbcbcedc1f1f1f517fd26280b" translate="yes" xml:space="preserve">
          <source>A merge is made by combining the changes made in &lt;code&gt;branchname&lt;/code&gt; and the changes made up to the latest commit in your current branch since their histories forked. The work tree is overwritten by the result of the merge when this combining is done cleanly, or overwritten by a half-merged results when this combining results in conflicts. Therefore, if you have uncommitted changes touching the same files as the ones impacted by the merge, Git will refuse to proceed. Most of the time, you will want to commit your changes before you can merge, and if you don&amp;rsquo;t, then &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; can take these changes away while you&amp;rsquo;re doing the merge, and reapply them afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d489b543f60fc98d2a6018d75091a747eea01a" translate="yes" xml:space="preserve">
          <source>A merged version reconciling the changes from all branches to be merged is committed, and your &lt;code&gt;HEAD&lt;/code&gt;, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556c7318c2e7e187ba3d844ceeba1d7c90165db2" translate="yes" xml:space="preserve">
          <source>A minimal repository browser and Git tool output highlighter written in C using Ncurses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f82fb44f773fe4ef6363789a0bed7a920af8c57" translate="yes" xml:space="preserve">
          <source>A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7974b838cbb4f29c64d1d141d31a017781be24" translate="yes" xml:space="preserve">
          <source>A more detailed explanation follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1294d206b2b9b4a7e8a2c5b691b195e05326798f" translate="yes" xml:space="preserve">
          <source>A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added &quot;What is unexpected&quot; in the old commit, for example, is completely red, even if the intent of the old commit was to add something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f995936d742d7948d27ea58d580269673915afeb" translate="yes" xml:space="preserve">
          <source>A name referring to a list of repositories as the value of remotes.&amp;lt;group&amp;gt; in the configuration file. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285bedb08cb2a07c72d29f3452de603f4eff78e2" translate="yes" xml:space="preserve">
          <source>A name that begins with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) that points to an &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; or another ref (the latter is called a &lt;a href=&quot;#def_symref&quot;&gt;symbolic ref&lt;/a&gt;). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details. Refs are stored in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7703b2466f10a68f3b1c01b58b3d6c6dd1bbbf9e" translate="yes" xml:space="preserve">
          <source>A newly created object is stored in its own file. The objects are splayed over 256 subdirectories using the first two characters of the sha1 object name to keep the number of directory entries in &lt;code&gt;objects&lt;/code&gt; itself to a manageable number. Objects found here are often called &lt;code&gt;unpacked&lt;/code&gt; (or &lt;code&gt;loose&lt;/code&gt;) objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4642a2b17c96a073cdb3a7085d71034eb452a227" translate="yes" xml:space="preserve">
          <source>A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969533e24645fc570f9e6901a33806920e5cb706" translate="yes" xml:space="preserve">
          <source>A note on commit messages: Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfc512a94e79667c45c7af73a6fa69e373a158c" translate="yes" xml:space="preserve">
          <source>A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678367292507a434e0e80079657b6dfcb1357dad" translate="yes" xml:space="preserve">
          <source>A number controlling the amount of output shown by the recursive merge strategy. Overrides merge.verbosity. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6753b358cd59601b720b7e321e301f821aeaac" translate="yes" xml:space="preserve">
          <source>A number of commands are useful for keeping track of what you&amp;rsquo;re about to commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a527e05c01a1cd1e2fbbfb008d8a0a9991b3e36" translate="yes" xml:space="preserve">
          <source>A number of other receive.* config options are available to tweak its behavior, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2735235afad8c3de74567bf475c2f66e22a1a38" translate="yes" xml:space="preserve">
          <source>A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. &quot;people who are primarily interested in the networking part of the kernel&quot;) who may have their own set of tags (e.g. &quot;this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release&quot;) to another circle of people (e.g. &quot;people who integrate various subsystem improvements&quot;). The latter are usually not interested in the detailed tags used internally in the former group (that is what &quot;internal&quot; means). That is why it is desirable not to follow tags automatically in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cabaac84bf06e47bfc060c7436d54129d5c9635" translate="yes" xml:space="preserve">
          <source>A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES) enables Git to read from the pack archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397ffaa6c68ed0147644cba4450a6f826844c8cb" translate="yes" xml:space="preserve">
          <source>A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35f65ed82291bd06ac4c67bd1644d87a71cb117" translate="yes" xml:space="preserve">
          <source>A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don&amp;rsquo;t understand the latter. By default, &lt;code&gt;git pack-objects&lt;/code&gt; only uses the former format for better compatibility. This option allows the command to use the latter format for compactness. Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fd37e1abf8d7c37fbc7d9812df5fcd79af795e" translate="yes" xml:space="preserve">
          <source>A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format. In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf032ee74744146d5a15b7c697cecedcaf0b0c4f" translate="yes" xml:space="preserve">
          <source>A paragraph in the commit log message. This can be given more than once and each &amp;lt;message&amp;gt; becomes its own paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae6bc184aa1a805bb37320ee63c3bc2d3ceedc5" translate="yes" xml:space="preserve">
          <source>A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files. Sometimes this indicates that the developer was being sloppy and did not refactor the code properly. You can first find the commit that introduced the file with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70409c2f17849d4a005f3c1893f70bfb2726cd34" translate="yes" xml:space="preserve">
          <source>A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains &lt;code&gt;LF&lt;/code&gt;. In C-style quoting, the complete name should be surrounded with double quotes, and any &lt;code&gt;LF&lt;/code&gt;, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2947c5ab63d63637e419f1d545864acc22513b" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is set is treated as text, even when they contain byte values that normally never appear in text files, such as NUL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c497cf3cb539fc75cfa79107d99052fa1c172747" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unset will generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c800d486d5ce3a0265a47a1feb9f3c335f6f77" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unspecified first gets its contents inspected, and if it looks like text and is smaller than core.bigFileThreshold, it is treated as text. Otherwise it would generate &lt;code&gt;Binary files differ&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de5fce3d256d15d9371f68eb7be9e8c39bff70d" translate="yes" xml:space="preserve">
          <source>A pathspec that begins with a colon &lt;code&gt;:&lt;/code&gt; has special meaning. In the short form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by zero or more &quot;magic signature&quot; letters (which optionally is terminated by another colon &lt;code&gt;:&lt;/code&gt;), and the remainder is the pattern to match against the path. The &quot;magic signature&quot; consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the &quot;magic signature&quot; can be omitted if the pattern begins with a character that does not belong to &quot;magic signature&quot; symbol set and is not a colon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbd2b8e2f5a79d8f4767d53dab7382344add01a" translate="yes" xml:space="preserve">
          <source>A pathspec with only a colon means &quot;there is no pathspec&quot;. This form should not be combined with other pathspec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905a72351f89ce389bbe3fe0bc52dfbff0e65e1a" translate="yes" xml:space="preserve">
          <source>A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543c0b6dffa14304d5bbca9c7badb06a27012480" translate="yes" xml:space="preserve">
          <source>A plain file &lt;code&gt;.git&lt;/code&gt; at the root of a working tree that points at the directory that is the real repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67f2fd432760e7725d26e3c634fda7223350a3d" translate="yes" xml:space="preserve">
          <source>A portable graphical interface to Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9f6646a7f195313b665f81866ba2d97ea2d1a5" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do 'not' want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, 'not' tracking files with Git is just a matter of 'not' calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db2ee1a1d750a2aa19ca518ec09fb893a88a85d" translate="yes" xml:space="preserve">
          <source>A range of commits could also be removed with rebase. If we have the following situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d115fddbdf7f10bd3b9f771bde1590c6813bbd" translate="yes" xml:space="preserve">
          <source>A really simple TCP Git daemon that normally listens on port &quot;DEFAULT_GIT_PORT&quot; aka 9418. It waits for a connection asking for a service, and will serve that service if it is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eaf62e43457d050db3acd458814891c29242983" translate="yes" xml:space="preserve">
          <source>A really simple server for Git repositories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9323a3a61d783f2901a029c1a9555370896ed64" translate="yes" xml:space="preserve">
          <source>A recommended practice to deal with a repository with too many refs is to pack its refs with &lt;code&gt;--all&lt;/code&gt; once, and occasionally run &lt;code&gt;git pack-refs&lt;/code&gt;. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial &lt;code&gt;pack-refs --all&lt;/code&gt;, but only the currently active branch heads will become unpacked, and the next &lt;code&gt;pack-refs&lt;/code&gt; (without &lt;code&gt;--all&lt;/code&gt;) will leave them unpacked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fd7125bed2f55c76f0826ae0ec95817fbc826b" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for a &quot;subsystem maintainer&quot; who works on that project and has an own &quot;public repository&quot; goes like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc51d6ef6719c059d48b71f7162885a19b6d5bb" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for an &quot;individual developer&quot; who does not have a &quot;public&quot; repository is somewhat different. It goes like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5352ae383650a2fe850c6303d60d8b60b542b21" translate="yes" xml:space="preserve">
          <source>A recommended workflow for a &quot;project lead&quot; goes like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265a7c950336ee05f26938c5f28759002d86d93b" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with a date specification enclosed in a brace pair (e.g. &lt;code&gt;{yesterday}&lt;/code&gt;, &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; or &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt;) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;). Note that this looks up the state of your &lt;strong&gt;local&lt;/strong&gt; ref at a given time; e.g., what was in your local &lt;code&gt;master&lt;/code&gt; branch last week. If you want to look at commits made during certain times, see &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51716c72ef284c873d21cfca784e510780211d59" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with an ordinal specification enclosed in a brace pair (e.g. &lt;code&gt;{1}&lt;/code&gt;, &lt;code&gt;{15}&lt;/code&gt;) specifies the n-th prior value of that ref. For example &lt;code&gt;master@{1}&lt;/code&gt; is the immediate prior value of &lt;code&gt;master&lt;/code&gt; while &lt;code&gt;master@{5}&lt;/code&gt; is the 5th prior value of &lt;code&gt;master&lt;/code&gt;. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c828d8d799658a52963b92e85f92230ddce05633" translate="yes" xml:space="preserve">
          <source>A reference is used in Git to specify branches and tags. A branch head is stored in the &lt;code&gt;refs/heads&lt;/code&gt; hierarchy, while a tag is stored in the &lt;code&gt;refs/tags&lt;/code&gt; hierarchy of the ref namespace (typically in &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; and &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; directories or, as entries in file &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; if refs are packed by &lt;code&gt;git gc&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b0c287bc0250d0d7c7ad1e770e07055b7fabea" translate="yes" xml:space="preserve">
          <source>A reflog shows the local &quot;history&quot; of a ref. In other words, it can tell you what the 3rd last revision in &lt;code&gt;this&lt;/code&gt; repository was, and what was the current state in &lt;code&gt;this&lt;/code&gt; repository, yesterday 9:14pm. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d85fab27e60023cfb23c382a480074950bc3b6" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;D..M&lt;/code&gt; computes the set of commits that are ancestors of &lt;code&gt;M&lt;/code&gt;, but excludes the ones that are ancestors of &lt;code&gt;D&lt;/code&gt;. This is useful to see what happened to the history leading to &lt;code&gt;M&lt;/code&gt; since &lt;code&gt;D&lt;/code&gt;, in the sense that &amp;ldquo;what does &lt;code&gt;M&lt;/code&gt; have that did not exist in &lt;code&gt;D&lt;/code&gt;&amp;rdquo;. The result in this example would be all the commits, except &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; (and &lt;code&gt;D&lt;/code&gt; itself, of course).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed028af5f97bfe4672822d1dbdbcfbdfebcb455" translate="yes" xml:space="preserve">
          <source>A regular Git &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a66b0bccadf6b4b35ab899aad4e51fd773c916c" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9a8ecf4e3c29353c757ea95408f73fb557ebe2" translate="yes" xml:space="preserve">
          <source>A remote host to house the repository. When this part is specified, &lt;code&gt;git-receive-pack&lt;/code&gt; is invoked via ssh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3cc062c2af6416292b0ef7c3779dab312dd5ae" translate="yes" xml:space="preserve">
          <source>A repeated field which contains a pathspec used to match against a submodule&amp;rsquo;s path to determine if the submodule is of interest to git commands. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f31deb02430ad940d40632dc48c6584b615bca" translate="yes" xml:space="preserve">
          <source>A repository administrator uses the following tools to set up and maintain access to the repository by developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291ca170f72d7ae46d3d06abf11420385d3bc632" translate="yes" xml:space="preserve">
          <source>A repository browser written in C++ using Qt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0e13fa1004207d77a93fcbfe7ad39156045662" translate="yes" xml:space="preserve">
          <source>A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e984261a0bc7837fbb8a0ec46d94f09fd20ad4" translate="yes" xml:space="preserve">
          <source>A repository, however, may be on a filesystem that handles the filemode correctly, and this variable is set to &lt;code&gt;true&lt;/code&gt; when created, but later may be made accessible from another environment that loses the filemode (e.g. exporting ext4 via CIFS mount, visiting a Cygwin created repository with Git for Windows or Eclipse). In such a case it may be necessary to set this variable to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ddd4f9a8a430a958f1b8538f7d6f7067859a81" translate="yes" xml:space="preserve">
          <source>A response cannot have both &quot;ACK&quot; lines as well as a &quot;NAK&quot; line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8097366b5d40667e4abf117fd6ca3ad0717782" translate="yes" xml:space="preserve">
          <source>A revision parameter &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; typically, but not necessarily, names a commit object. It uses what is called an &lt;code&gt;extended SHA-1&lt;/code&gt; syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c6349b68cd7c10517a568cd609971cc38e5788" translate="yes" xml:space="preserve">
          <source>A sample script called &lt;code&gt;git merge-one-file&lt;/code&gt; is included in the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120e3b8f4ab8d187e55b285ecbd0489d8d26eb44" translate="yes" xml:space="preserve">
          <source>A separate reflog is kept for the HEAD, so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91dd506db610265c4f5339a204fd581531aedbc" translate="yes" xml:space="preserve">
          <source>A server which decides to communicate (based on a request from a client) using protocol version 2, notifies the client by sending a version string in its initial response followed by an advertisement of its capabilities. Each capability is a key with an optional value. Clients must ignore all unknown keys. Semantics of unknown values are left to the definition of each key. Some capabilities will describe commands which can be requested to be executed by the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df310f47acb8f98df997eb87d57f9f09ca45534" translate="yes" xml:space="preserve">
          <source>A set of objects which have been compressed into one file (to save space or to transmit them efficiently).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760738014c8d15080dd8ad99ff6f8946e9b78b3f" translate="yes" xml:space="preserve">
          <source>A shallow &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; has an incomplete history some of whose &lt;a href=&quot;#def_commit&quot;&gt;commits&lt;/a&gt; have &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, and its history can be later deepened with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d2217cabdf29712dcb12dec7c077c5557961f7" translate="yes" xml:space="preserve">
          <source>A similar notation &lt;code&gt;r1...r2&lt;/code&gt; is called symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; and is defined as &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt;. It is the set of commits that are reachable from either one of &lt;code&gt;r1&lt;/code&gt; (left side) or &lt;code&gt;r2&lt;/code&gt; (right side) but not from both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b58226721c4cc7166ad8aeab7f1974a94bf09d" translate="yes" xml:space="preserve">
          <source>A similar situation may exist if you have many refs outside of &lt;code&gt;refs/heads/&lt;/code&gt; and &lt;code&gt;refs/tags/&lt;/code&gt; that point to related objects (e.g., &lt;code&gt;refs/pull&lt;/code&gt; or &lt;code&gt;refs/changes&lt;/code&gt; used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ed03d108643fd395f938fb72a9354bf316277b" translate="yes" xml:space="preserve">
          <source>A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols. The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1195c95166bae01312d67abaddce937f83d9362" translate="yes" xml:space="preserve">
          <source>A simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c189ba8d16025c20dba9fcda55d122bc7aead222" translate="yes" xml:space="preserve">
          <source>A simple script to set up &lt;code&gt;gitweb&lt;/code&gt; and a web server for browsing the local repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dbbf1a98e941496d92210bf8c09236d984ac48" translate="yes" xml:space="preserve">
          <source>A single Git repository can maintain multiple branches of development. To create a new branch named &quot;experimental&quot;, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25083b025a2b5a403b052b2229f06625158a6247" translate="yes" xml:space="preserve">
          <source>A single Git repository can track development on multiple branches. It does this by keeping a list of &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; which reference the latest commit on each branch; the &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; command shows you the list of branch heads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7288da94d33c9eb52ba6940278539d1555cfdfd9" translate="yes" xml:space="preserve">
          <source>A single character indicating the status of the ref:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c723ae3e05980f7081e5473a8ac04766150ab6" translate="yes" xml:space="preserve">
          <source>A single commit, &amp;lt;since&amp;gt;, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the &amp;lt;since&amp;gt; to be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66b9962c6b8969581e4f00aff7618bfe88dca4e" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &quot;&lt;code&gt;a/**/b&lt;/code&gt;&quot; matches &quot;&lt;code&gt;a/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/y/b&lt;/code&gt;&quot; and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e21b6b860da30d1826bc3bb029200d80cc11cad" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &amp;ldquo;a/**/b&amp;rdquo; matches &amp;ldquo;a/b&amp;rdquo;, &amp;ldquo;a/x/b&amp;rdquo;, &amp;ldquo;a/x/y/b&amp;rdquo; and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9431663a53487c588fbbedb283ae62fa2894ff" translate="yes" xml:space="preserve">
          <source>A slightly deprecated way to store shorthands to be used to specify a URL to &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt;. A file can be stored as &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; and then &lt;code&gt;name&lt;/code&gt; can be given to these commands in place of &lt;code&gt;repository&lt;/code&gt; argument. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/branches&quot; will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe30d91a78c1b581b029eea169d6574e2c5cb4" translate="yes" xml:space="preserve">
          <source>A sorted list of object IDs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3047be03f0d3ecaf4a4a3e674d103af6ab32bc53" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^'&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3908ea4f3253577085936fe5b76bc16ca04e0c" translate="yes" xml:space="preserve">
          <source>A special work-flow to process regressions can give great results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ce84536299a4f1684c7f29def2c093aadc39c2" translate="yes" xml:space="preserve">
          <source>A standalone individual developer does not exchange patches with other people, and works alone in a single repository, using the following commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0b6db37ed70c0023a81918dabe38bb8d99cf58" translate="yes" xml:space="preserve">
          <source>A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at &lt;code&gt;HEAD&lt;/code&gt; when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the &lt;code&gt;HEAD&lt;/code&gt; commit. The ancestry graph looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a517b64103a2430e203bb84a9e73d7f028600f" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a branch ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edde80e52399b826b491130bef9d05b3925669d" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a ref being shown and the object it points at. If &lt;code&gt;fieldname&lt;/code&gt; is prefixed with an asterisk (&lt;code&gt;*&lt;/code&gt;) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object). When unspecified, &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt;. It also interpolates &lt;code&gt;%%&lt;/code&gt; to &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; are hex digits interpolates to character with hex code &lt;code&gt;xx&lt;/code&gt;; for example &lt;code&gt;%00&lt;/code&gt; interpolates to &lt;code&gt;\0&lt;/code&gt; (NUL), &lt;code&gt;%09&lt;/code&gt; to &lt;code&gt;\t&lt;/code&gt; (TAB) and &lt;code&gt;%0a&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; (LF).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb129a282a3da00e35f465609f9329380941366" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a tag ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. When unspecified, defaults to &lt;code&gt;%(refname:strip=2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0560022c11ba0c716585e6d8f8913228ee3e6c3e" translate="yes" xml:space="preserve">
          <source>A submodule can be deinitialized by running &lt;code&gt;git submodule deinit&lt;/code&gt;. Besides emptying the working directory, this command only modifies the superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file, so the superproject&amp;rsquo;s history is not affected. This can be undone using &lt;code&gt;git submodule init&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b89540955e10e5feb43789fbebb00e44fcb9843" translate="yes" xml:space="preserve">
          <source>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88b5d8fa1cd6a4cae09ba91d60ef7a2df883ac3" translate="yes" xml:space="preserve">
          <source>A submodule is considered active,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4216bd581f8b9370ea9e414788282e84b57f684" translate="yes" xml:space="preserve">
          <source>A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren&amp;rsquo;t ignored are present in the submodules work tree. Ignored files are deemed expendable and won&amp;rsquo;t stop a submodule&amp;rsquo;s work tree from being removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df342118147abc0cd90ff22df7d540bbed94c62e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;:&lt;/code&gt; followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; is relative to the current working directory. The given path will be converted to be relative to the working tree&amp;rsquo;s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e785e37b028efe6293e2efb14cf20d30e4be808" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an at sign is the same as listing all parents of &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; (meaning, include anything reachable from its parents, but not the commit itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234f424b36b663492de634fe2e068b47127b2353" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e176abe5e6fcc215a4e351cefa8ffc3e524bb3aa" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an exclamation mark is the same as giving commit &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; and then all its parents prefixed with &lt;code&gt;^&lt;/code&gt; to exclude them (and their ancestors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079cde747b39722224d412153b37c2370e8debbb" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an object type name enclosed in brace pair means dereference the object at &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; recursively until an object of type &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is found or the object cannot be dereferenced anymore (in which case, barf). For example, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a commit-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; describes the corresponding commit object. Similarly, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a tree-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; describes the corresponding tree object. &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; is a short-hand for &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb9575171f3ccde74304b43fe061daf6edfa9e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter means the first parent of that commit object. &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; means the &amp;lt;n&amp;gt;th parent (i.e. &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt;). As a special rule, &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; means the commit itself and is used when &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is the object name of a tag object that refers to a commit object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abb972743010d92ad3a5190f17461682915e18a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the &lt;code&gt;:/fix nasty bug&lt;/code&gt; syntax below except that it returns the youngest matching commit which is reachable from the &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; before &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efdcb3b13d0c9c0789d26cd7ee831f4aca0612a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;~&lt;/code&gt; to a revision parameter means the first parent of that commit object. A suffix &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; to a revision parameter means the commit object that is the &amp;lt;n&amp;gt;th generation ancestor of the named commit object, following only the first parents. I.e. &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; which is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt;. See below for an illustration of the usage of this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cd172649a72cf4ad5161e6315024c0dfabce75" translate="yes" xml:space="preserve">
          <source>A symbolic ref is a regular file that stores a string that begins with &lt;code&gt;ref: refs/&lt;/code&gt;. For example, your &lt;code&gt;.git/HEAD&lt;/code&gt; is a regular file whose contents is &lt;code&gt;ref: refs/heads/master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6a4a117c3c9029c31388fc9b0d710a83f42f4d" translate="yes" xml:space="preserve">
          <source>A symbolic ref name. E.g. &lt;code&gt;master&lt;/code&gt; typically means the commit object referenced by &lt;code&gt;refs/heads/master&lt;/code&gt;. If you happen to have both &lt;code&gt;heads/master&lt;/code&gt; and &lt;code&gt;tags/master&lt;/code&gt;, you can explicitly say &lt;code&gt;heads/master&lt;/code&gt; to tell Git which one you mean. When ambiguous, a &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; is disambiguated by taking the first match in the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9339c8e09a3c8f9775daba35ba89a601eb61af" translate="yes" xml:space="preserve">
          <source>A symref (see glossary) to the &lt;code&gt;refs/heads/&lt;/code&gt; namespace describing the currently active branch. It does not mean much if the repository is not associated with any working tree (i.e. a &lt;code&gt;bare&lt;/code&gt; repository), but a valid Git repository &lt;strong&gt;must&lt;/strong&gt; have the HEAD file; some porcelains may use it to guess the designated &quot;default&quot; branch of the repository (usually &lt;code&gt;master&lt;/code&gt;). It is legal if the named branch &lt;code&gt;name&lt;/code&gt; does not (yet) exist. In some legacy setups, it is a symbolic link instead of a symref that points at the current branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5b752bfbf12baa27c0d09bf45852511199efe" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a76d6428fd9851f11221d0de44fe9ce84899c23" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt;; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt;, similar to &lt;code&gt;git cherry upstream mybranch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868704b8b35cf6bb729f23c31a6430d7399400cb" translate="yes" xml:space="preserve">
          <source>A table of 4-byte CRC32 values of the packed object data. This is new in v2 so compressed data can be copied directly from pack to pack during repacking without undetected data corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c572354f0344d27ffddcbe955d1d768c1138c7" translate="yes" xml:space="preserve">
          <source>A table of 4-byte offset values (in network byte order). These are usually 31-bit pack file offsets, but large offsets are encoded as an index into the next table with the msbit set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115de84d2ad1c82aefd29447ce36382b5a4e7147" translate="yes" xml:space="preserve">
          <source>A table of 8-byte offset entries (empty for pack files less than 2 GiB). Pack files are organized with heavily used objects toward the front, so most object references should not need to refer to this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b489f426a28ee960ee163d6ec7cd47d15e9a4e2" translate="yes" xml:space="preserve">
          <source>A table of sorted 20-byte SHA-1 object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b73c881d8049c32b44bc4f672cd5152d4e0c48" translate="yes" xml:space="preserve">
          <source>A tag is created with &lt;a href=&quot;git-mktag&quot;&gt;git-mktag[1]&lt;/a&gt;, and the signature can be verified by &lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag[1]&lt;/a&gt;, though it is normally simpler to use &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27736fe1ba37175d3cc5e2ce129ab17b8daa1329" translate="yes" xml:space="preserve">
          <source>A tag object contains an object, object type, tag name, the name of the person (&quot;tagger&quot;) who created the tag, and a message, which may contain a signature, as can be seen using &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460cd2951f141993dd60da4f89bc9632bc5240a6" translate="yes" xml:space="preserve">
          <source>A tag signature file, to be fed to this command&amp;rsquo;s standard input, has a very simple fixed format: four lines of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9577e2a94118633866403eba48d1b01fa7f34b6" translate="yes" xml:space="preserve">
          <source>A text file containing the absolute path back to the .git file that points to here. This is used to check if the linked repository has been manually removed and there is no need to keep this directory any more. The mtime of this file should be updated every time the linked repository is accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6620ed6a8dd7fc370324b4a637371aff9ccd2b8" translate="yes" xml:space="preserve">
          <source>A textconv, by comparison, is much more limiting. You provide a transformation of the data into a line-oriented text format, and Git uses its regular diff tools to generate the output. There are several advantages to choosing this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ee50ebcc035e786bc0063549e7c3be96310965" translate="yes" xml:space="preserve">
          <source>A tilde &lt;code&gt;~&lt;/code&gt; and caret &lt;code&gt;^&lt;/code&gt; are used to introduce the postfix &lt;code&gt;nth parent&lt;/code&gt; and &lt;code&gt;peel onion&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b05115bcd451b82846a70dc0f8122c29671169c" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;&lt;code&gt;abc&lt;/code&gt;&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57747a45d9976be1263b4b7a69a5ab667656384" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5db9c2038caa3b11960feb667ae09ddbf5220c" translate="yes" xml:space="preserve">
          <source>A trailing &amp;ldquo;/&lt;strong&gt;&amp;rdquo; matches everything inside. For example, &amp;ldquo;abc/&lt;/strong&gt;&amp;rdquo; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffbc3235b6f3805e76da872c4d7da43eac01de9" translate="yes" xml:space="preserve">
          <source>A tree can be created with &lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree[1]&lt;/a&gt; and its data can be accessed by &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;. Two trees can be compared with &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ac2a6922ce84e247da3afac7c8eab10ddc8e0d" translate="yes" xml:space="preserve">
          <source>A tree can refer to one or more &quot;blob&quot; objects, each corresponding to a file. In addition, a tree can also refer to other tree objects, thus creating a directory hierarchy. You can examine the contents of any tree using ls-tree (remember that a long enough initial portion of the SHA-1 will also work):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d6593ce00c8f4a86630f0208b8c6cb9ed9de85" translate="yes" xml:space="preserve">
          <source>A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code. Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git. This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8135e3fa6705c7716d147bd5d8e6059fc5669c5" translate="yes" xml:space="preserve">
          <source>A typical integrator&amp;rsquo;s Git day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9ceecdb03729fb43526343794e6a94c95fe225" translate="yes" xml:space="preserve">
          <source>A typical output of &lt;code&gt;git range-diff&lt;/code&gt; would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41e892a94b26f51f6da2faaf7e783142c2d2445" translate="yes" xml:space="preserve">
          <source>A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by &lt;code&gt;git log&lt;/code&gt; along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying &quot;Notes (&amp;lt;refname&amp;gt;):&quot; (or &quot;Notes:&quot; for &lt;code&gt;refs/notes/commits&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b5db3f89763f637b749fc5b0ec07665392a318" translate="yes" xml:space="preserve">
          <source>A v2 server would reply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814fa5229889141123953471b46691119165aa04" translate="yes" xml:space="preserve">
          <source>A value j referring to the jth packfile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db561a50c25f0c87e4728686c752358969a2d04" translate="yes" xml:space="preserve">
          <source>A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0ad35cb8bc2af5f4d79278f7255026ebe99d79" translate="yes" xml:space="preserve">
          <source>A variable that takes a pathname value can be given a string that begins with &quot;&lt;code&gt;~/&lt;/code&gt;&quot; or &quot;&lt;code&gt;~user/&lt;/code&gt;&quot;, and the usual tilde expansion happens to such a string: &lt;code&gt;~/&lt;/code&gt; is expanded to the value of &lt;code&gt;$HOME&lt;/code&gt;, and &lt;code&gt;~user/&lt;/code&gt; to the specified user&amp;rsquo;s home directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e794a6fd78ae6c428e6284131fe5a2e63e70771b" translate="yes" xml:space="preserve">
          <source>A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd32407bcc9b7692e9e0052b8179af70723a8a0f" translate="yes" xml:space="preserve">
          <source>A whole-repository format version bump should only be part of a change that cannot be independently versioned. For instance, if one were to change the reachability rules for objects, or the rules for locking refs, that would require a bump of the repository format version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bfda56601f95323dd8aca6fc5f3876aceac9edc" translate="yes" xml:space="preserve">
          <source>A zero exit from the update hook allows the ref to be updated. Exiting with a non-zero status prevents &lt;code&gt;git receive-pack&lt;/code&gt; from updating that ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa85a6ac2fd33dacf832ee98a538368318a091a" translate="yes" xml:space="preserve">
          <source>A: addition of a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e39d81ad3ae332d60cc3e83e97303a91d0b4f70" translate="yes" xml:space="preserve">
          <source>ALERT ALERT ALERT! The Git &quot;merge object order&quot; is different from the RCS &lt;code&gt;merge&lt;/code&gt; program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program &lt;code&gt;merge&lt;/code&gt; is to have the original in the middle. Don&amp;rsquo;t ask me why.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4508200e35a10a4b1f04bf5f137007ce3e238313" translate="yes" xml:space="preserve">
          <source>Abbreviate the object name. When using &lt;code&gt;--hash&lt;/code&gt;, you do not have to say &lt;code&gt;--hash --abbrev&lt;/code&gt;; &lt;code&gt;--hash=n&lt;/code&gt; would do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bf43580d9c77cf2c146fe7b7b0ac96cfdd25cc" translate="yes" xml:space="preserve">
          <source>Abbreviating long options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a8cc5ece3d7d535580e6c4ba9d955b1cbee507" translate="yes" xml:space="preserve">
          <source>Abort the patching operation but keep HEAD and the index untouched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8af665ebaab7b8a3f7a19d579a76f94def56137" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation and reset HEAD to the original branch. If &amp;lt;branch&amp;gt; was provided when the rebase operation was started, then HEAD will be reset to &amp;lt;branch&amp;gt;. Otherwise HEAD will be reset to where it was when the rebase operation was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a60cae95d240ebe223133619984451eb8da56d" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348ed40ffd74f6eb0fbdde58a662f091cfe18d08" translate="yes" xml:space="preserve">
          <source>Abort/reset an in-progress &lt;code&gt;git notes merge&lt;/code&gt;, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d78acc57b2d47f1ebfb75a2f9bb6687faa0fcc" translate="yes" xml:space="preserve">
          <source>About ten years ago did i do my first &lt;code&gt;bisection&lt;/code&gt; of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a17b1a2762f733cbf8fe0ce3ae058c1fb64af21" translate="yes" xml:space="preserve">
          <source>Absolute filesystem path which will be prepended to project path; the path to repository is &lt;code&gt;$projectroot/$project&lt;/code&gt;. Set to &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; during installation. This variable has to be set correctly for gitweb to find repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="17286b3ab79f469f1686313022a96ba044391703" translate="yes" xml:space="preserve">
          <source>Accelerated static Apache 2.x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52790b3bcb573f6e8573cdbe7b68a8e690d099eb" translate="yes" xml:space="preserve">
          <source>Access control: By restricting user access to submodules, this can be used to implement read/write policies for different users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="478ae85b8fa23d44da84a56a398158571f09f29c" translate="yes" xml:space="preserve">
          <source>Act as though the corresponding command-line option with a leading &lt;code&gt;--&lt;/code&gt; was passed on the command line (see OPTIONS, above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6478562162279a99d43ca11e0923b34140a68ad3" translate="yes" xml:space="preserve">
          <source>Actions, and urls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3894e58bd38733ccd4747f0674e47d077bbb6100" translate="yes" xml:space="preserve">
          <source>Actions:</source>
          <target state="translated">Actions:</target>
        </trans-unit>
        <trans-unit id="8c5178bf114268e42ef635c5fbc78f8654415410" translate="yes" xml:space="preserve">
          <source>Activate recording of resolved conflicts, so that identical conflict hunks can be resolved automatically, should they be encountered again. By default, &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt; is enabled if there is an &lt;code&gt;rr-cache&lt;/code&gt; directory under the &lt;code&gt;$GIT_DIR&lt;/code&gt;, e.g. if &quot;rerere&quot; was previously used in the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02f312753d69f3d534d52a8b88d589eac9ef0bb" translate="yes" xml:space="preserve">
          <source>Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch. If subtree &lt;code&gt;include&lt;/code&gt; has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree &lt;code&gt;src&lt;/code&gt; has been modified by a commit since the branch became active, then its contents will be loaded in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a0105409fd4103b8842eb13af0140d95a67fb2" translate="yes" xml:space="preserve">
          <source>Active submodules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0a4ffd02b3e3415f28bfa49ecef06eac3d36bf" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2b29e689f134a6c33caf76c2612bd809b36f86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c1b47e4f88ea8cc86f31135daa96f65e495e4d" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c02a316f685de03eb757b49fbbce21e75b00c4" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb483d422626db8f460b089acb2b2a17f42ef653" translate="yes" xml:space="preserve">
          <source>Actually write the object into the object database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae5ee2ecd5525bbb102db4f0d78bb539c98b2b0" translate="yes" xml:space="preserve">
          <source>Adapting your work-flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febbcaaccd6732ef0fbf603adeb6e4b1534f2caf" translate="yes" xml:space="preserve">
          <source>Add &quot;glob&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Disabling globbing on individual pathspecs can be done using pathspec magic &quot;:(literal)&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1c5ad83cb656e31e0abe5871946adce7f2dbed" translate="yes" xml:space="preserve">
          <source>Add &quot;icase&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d537b0a7b0bc1a6255114f214ad3b7382addc5" translate="yes" xml:space="preserve">
          <source>Add &quot;literal&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Enabling globbing on individual pathspecs can be done using pathspec magic &quot;:(glob)&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a692c67e8b6f449d83f8b5219858b8b4cd34c65" translate="yes" xml:space="preserve">
          <source>Add (or prevent adding) the &quot;X-Mailer:&quot; header. By default, the header is added, but it can be turned off by setting the &lt;code&gt;sendemail.xmailer&lt;/code&gt; configuration variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875e6f546a41d1d0704772304d2d43d72adc62d9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed47084b5999b126507c3c0b45a1bb8e478c76b6" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line at the end of the commit message. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290e4752e9d079cc99d7e2f47d052706296ff714" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line by the committer at the end of the commit log message. The meaning of a signoff depends on the project, but it typically certifies that committer has the rights to submit this work under the same license and agrees to a Developer Certificate of Origin (see &lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780762089271321ecfe958d672a214a85e1519d6" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Cc:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-cc&lt;/code&gt; discards all &lt;code&gt;Cc:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7701fb474747c5b74516af829e74a1b309150b" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5ee25b8be312a8351ef48a09ee57bfe0ac5407" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;To:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-to&lt;/code&gt; discards all &lt;code&gt;To:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d75fe65b404604e5ef539902b9de029d2905810" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;verify&lt;/code&gt; subcommand to the &lt;code&gt;git midx&lt;/code&gt; builtin to verify the contents of the multi-pack-index file match the offsets listed in the corresponding pack-indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f049bd4f468982bc6e0cdfee8fd216a0b6cab6f3" translate="yes" xml:space="preserve">
          <source>Add a Signed-off-by: trailer to all the rebased commits. Note that if &lt;code&gt;--interactive&lt;/code&gt; is given then only commits marked to be picked, edited or reworded will have the trailer added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced7c6e6677217cd2f3e27d5808cd7af3f82dcc9" translate="yes" xml:space="preserve">
          <source>Add a new remote, fetch, and check out a branch from it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b8618aa62adcdff8f32f43f7ea6da4fbbc410b" translate="yes" xml:space="preserve">
          <source>Add a section on working with other version control systems, including CVS, Subversion, and just imports of series of release tarballs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c8ce810b46aeac59b7c7fbb4f0eb1c414e0fbc" translate="yes" xml:space="preserve">
          <source>Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67013d040b00288c354d7feb55fb2074c49fc78" translate="yes" xml:space="preserve">
          <source>Add a tag reference in &lt;code&gt;refs/tags/&lt;/code&gt;, unless &lt;code&gt;-d/-l/-v&lt;/code&gt; is given to delete, list or verify tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ba9550fdf49f0f7ec1ed9c2838f550f0841180" translate="yes" xml:space="preserve">
          <source>Add all existing files to the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e0fed7e8f28eb826825866ef9181c8986ab6b6" translate="yes" xml:space="preserve">
          <source>Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt;. The negated form &lt;code&gt;--no-add-header&lt;/code&gt; discards &lt;strong&gt;all&lt;/strong&gt; (&lt;code&gt;To:&lt;/code&gt;, &lt;code&gt;Cc:&lt;/code&gt;, and custom) headers added so far from config or command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb694979cbe30dcf490050a0765be211e88b887" translate="yes" xml:space="preserve">
          <source>Add an extra directive to the output for commits and blobs, &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt;. While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d9056473fe07372c67f810c3055c3b46a20590" translate="yes" xml:space="preserve">
          <source>Add authorship information. Adds Author line, and Committer (if different from Author) to the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b495931d52e43ecbfb5286b0146fb64097586eff" translate="yes" xml:space="preserve">
          <source>Add file contents to the index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35a311c3337f0cc2cbd68316a0fe51132f8719c" translate="yes" xml:space="preserve">
          <source>Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89fde681339a37c16082b848c84b533f9b8eb78" translate="yes" xml:space="preserve">
          <source>Add more good examples. Entire sections of just cookbook examples might be a good idea; maybe make an &quot;advanced examples&quot; section a standard end-of-chapter section?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e557ff36381109d45439d6a8300a1119a6fdeb9a" translate="yes" xml:space="preserve">
          <source>Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use &lt;code&gt;-f&lt;/code&gt; to overwrite existing notes). However, if you&amp;rsquo;re using &lt;code&gt;add&lt;/code&gt; interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the &lt;code&gt;edit&lt;/code&gt; subcommand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2ade0db6bb50863f06b44fc9c06dfd60dcfff0" translate="yes" xml:space="preserve">
          <source>Add or inspect object notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384163813513712116bc610979aaf5a161ff795b" translate="yes" xml:space="preserve">
          <source>Add or parse structured information in commit messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e875c484b14b19240ea9be7566dd014f5c8ec38" translate="yes" xml:space="preserve">
          <source>Add the given merge information during the dcommit (e.g. &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt;). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (&lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd81f5530cb193ba26157e4348607aee6556490" translate="yes" xml:space="preserve">
          <source>Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the &quot;superproject&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cddbbcd4cc96cbfc64c9c4d6d8f5bcef7bbee43" translate="yes" xml:space="preserve">
          <source>Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user&amp;rsquo;s global exclusion file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9821869aa821996defeaba01e6c12538af610d55" translate="yes" xml:space="preserve">
          <source>Added content is represented by lines beginning with &quot;+&quot;. You can prevent staging any addition lines by deleting them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb70b05688a7cd869d2606481b27296b19719c8" translate="yes" xml:space="preserve">
          <source>Additional commands may be supported, as may be determined from capabilities reported by the helper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73160eb439c17b83bb173df83040945299062f05" translate="yes" xml:space="preserve">
          <source>Additional email headers to include in a patch to be submitted by mail. See &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ded2bd3477ca52f24ae225994ba73ed8ad29b3" translate="yes" xml:space="preserve">
          <source>Additional features not supported in the base command will be advertised as the value of the command in the capability advertisement in the form of a space separated list of features: &quot;&amp;lt;command&amp;gt;=&amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa12c13f7c5fa3298b908c7e9540ddac59b47249" translate="yes" xml:space="preserve">
          <source>Additional information about the object store is recorded in this directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be06c5d8e7c3543b7023fd7faff294ed6ccc5563" translate="yes" xml:space="preserve">
          <source>Additional information about the repository is recorded in this directory. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/info&quot; will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d5079ec73555b8d437ff4e76ae398022d66054" translate="yes" xml:space="preserve">
          <source>Additional links to be added to the start of the breadcrumb trail before the home link, to pages that are logically &quot;above&quot; the gitweb projects list, such as the organization and department which host the gitweb server. Each element of the list is a reference to an array, in which element 0 is the link text (equivalent to &lt;code&gt;$home_link_str&lt;/code&gt;) and element 1 is the target URL (equivalent to &lt;code&gt;$home_link&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9432410873900e1c24cb64c2fa2f5825d3d685b" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936252ffd07e8aa44edb6a58806e990e0e986320" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639abe6e93382e14198d397d42d012876c506898" translate="yes" xml:space="preserve">
          <source>Additional options for cvsps. The options &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-A&lt;/code&gt; are implicit and should not be used here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126d4b07345ee8d93a4ae79da306723c896414b7" translate="yes" xml:space="preserve">
          <source>Additional recipients to include in a patch to be submitted by mail. See the --to and --cc options in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37901b95369dc888aa41ab1e345bdcf6c9cbdd0a" translate="yes" xml:space="preserve">
          <source>Additionally, &quot;[PATCH]&quot; will be stripped from the commit description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f709ea6030431bf2cc526dc56f831bf13777f2" translate="yes" xml:space="preserve">
          <source>Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git &quot;patch&quot; programs won&amp;rsquo;t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7511556dc9bb42ef3e1b927086b0b7b0eb2fc510" translate="yes" xml:space="preserve">
          <source>Additionally, it will create a special branch named &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt;, where &amp;lt;SVN-Revision&amp;gt; is the SVN revision number the branch was copied from. This branch will point to the newly created parent commit of the branch. If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4aae954f8fe3ec994c11ca19a460c6f95d1b16b" translate="yes" xml:space="preserve">
          <source>Additionally, only one of these options can be used per svn-remote section because they affect the &lt;code&gt;git-svn-id:&lt;/code&gt; metadata line, except for rewriteRoot and rewriteUUID which can be used together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629abb925697ea2611b60db0bc894374f52c4869" translate="yes" xml:space="preserve">
          <source>Additionally, the commit diff lines that are only present in the first commit range are shown &quot;dimmed&quot; (this can be overridden using the &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; config setting where &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt; and &lt;code&gt;newDimmed&lt;/code&gt;), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; being one of &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt; or &lt;code&gt;newBold&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cc6001363abb379cd9070769d41d2ac8c9a55b" translate="yes" xml:space="preserve">
          <source>Additionally, when a configured remote has &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; set to &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt;, Git explicitly invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; as the first argument. If set, the second argument is &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt;; otherwise, the second argument is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af479ae4e97a30fad59cd7baeb4a449867877a2" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;replace&lt;/code&gt; reference in &lt;code&gt;refs/replace/&lt;/code&gt; namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067f226622dab621132cf8ecc0c9775fffa56382" translate="yes" xml:space="preserve">
          <source>Adds a new line to the option without altering any existing values. This is the same as providing &lt;code&gt;^$&lt;/code&gt; as the value_regex in &lt;code&gt;--replace-all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25827132716a81d21acebe34dd646ff14930968e" translate="yes" xml:space="preserve">
          <source>Adds a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8c59cb65189781a225d03eb525c1d3e35346e1" translate="yes" xml:space="preserve">
          <source>Adds content from all &lt;code&gt;*.txt&lt;/code&gt; files under &lt;code&gt;Documentation&lt;/code&gt; directory and its subdirectories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a8bde384697b7b35dc55b38f84a5bc59a23070" translate="yes" xml:space="preserve">
          <source>Adds the file to the index again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9deafeaa2ae3e0af3bf37dc46c067f8db67dd63a" translate="yes" xml:space="preserve">
          <source>Adds, removes, or reads notes attached to objects, without touching the objects themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f333e4ae95f720feba6eabc8b0ae852b99b985" translate="yes" xml:space="preserve">
          <source>Administering</source>
          <target state="translated">Administering</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="c98cde56602b5dbe18cd13dfc6b1296aba3da4ee" translate="yes" xml:space="preserve">
          <source>Advanced branch management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c9e0bac98e698a29bdae673d4e9edfa151c025" translate="yes" xml:space="preserve">
          <source>Advanced options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5126907c1aaa23aea7d546c880913def66c36620" translate="yes" xml:space="preserve">
          <source>Advanced shared repository management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3bdc1b24cf17ee4a466d753939342282e0d80f" translate="yes" xml:space="preserve">
          <source>Advanced web server setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a2eaecb555069cd46a3c234e96420e295802e9" translate="yes" xml:space="preserve">
          <source>Advertise the URL of &lt;code&gt;proj.git&lt;/code&gt;. Anybody else should then be able to clone or pull from that URL, for example with a command line like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789a67096a4646c15f2aa6086486ffd34077e411" translate="yes" xml:space="preserve">
          <source>Advice on how to set your identity configuration when your information is guessed from the system username and domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a821447d06e24bab231c15461aafe7618db95e5a" translate="yes" xml:space="preserve">
          <source>Advice on what to do when you&amp;rsquo;ve accidentally added one git repo inside of another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d483bea154d1589851e27e82350c90b66804ae7" translate="yes" xml:space="preserve">
          <source>Advice shown by various commands when conflicts prevent the operation from being performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a85c6f280ebe2521ee45431f06743254445adc" translate="yes" xml:space="preserve">
          <source>Advice shown if a hook is ignored because the hook is not set as executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860ec9915ca898e80b509fbd6387408b77665509" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to recursively tag a tag object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4564a8cef9c264afd1da9386fe52f7316f5ca2ba" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; takes a long time to calculate forced updates after ref updates, or to warn that the check is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d65ddbca3a799ed312f569d4aeb5502874161b1" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; refuses to merge to avoid overwriting local changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d8f2ca61900be48cc5b75f8552ddc63690e847" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; fails due to a non-fast-forward update to the current branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4568fed53b701ea10d314b56862ee812cfea2bea" translate="yes" xml:space="preserve">
          <source>Advice shown when a sequencer command is already in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae8580cfe92126e912e3c0a9b1125abf0c3f017" translate="yes" xml:space="preserve">
          <source>Advice shown when a submodule.alternateErrorStrategy option configured to &quot;die&quot; causes a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df663a838b7df94d5ce12ffdd49a91bc903ea158" translate="yes" xml:space="preserve">
          <source>Advice shown when the argument to &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; and &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; ambiguously resolves to a remote tracking branch on more than one remote in situations where an unambiguous argument would have otherwise caused a remote-tracking branch to be checked out. See the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable for how to set a given remote to used by default in some situations where this advice would be printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287a70bfe9316e6c27233404e6ef7bfe75cf2ade" translate="yes" xml:space="preserve">
          <source>Advice shown when you ran &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and pushed &lt;code&gt;matching refs&lt;/code&gt; explicitly (i.e. you used &lt;code&gt;:&lt;/code&gt;, or specified a refspec that isn&amp;rsquo;t your current branch) and it resulted in a non-fast-forward error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04cbde1130eafb3edca74961656b00234c5044b" translate="yes" xml:space="preserve">
          <source>Advice shown when you used &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; or &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; to move to the detach HEAD state, to instruct how to create a local branch after the fact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef27fc3c51d0563e2cd508226536f4e82abdea97" translate="yes" xml:space="preserve">
          <source>Advice that shows the location of the patch file when &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; fails to apply it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a199e10db511a76b4343fb1d5d8f81b83d30fa" translate="yes" xml:space="preserve">
          <source>Advice to consider using the &lt;code&gt;--quiet&lt;/code&gt; option to &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate unstaged changes after reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c591e1c0c160f4739a66ef35a070ea84c2e7f3a4" translate="yes" xml:space="preserve">
          <source>Advise to consider using the &lt;code&gt;-u&lt;/code&gt; option to &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate untracked files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5496dea1231cd43f3ddab3a40907ffb3e37af6ae" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;attr:&lt;/code&gt; comes a space separated list of &quot;attribute requirements&quot;, all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a429914950c338a68e237d8a7583b13b733a18d9" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;collapsing&lt;/code&gt; operation, paths that are different in three trees are left in non-zero stages. At this point, you can inspect the index file with this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a35b13d3b2d2c3173fb0d4b6b82c758bbe9442" translate="yes" xml:space="preserve">
          <source>After Git received the pathnames, it will request the corresponding blobs again. These requests contain a pathname and an empty content section. The filter is expected to respond with the smudged content in the usual way as explained above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66031e0774792924c3ad30f78f9d0c8073d135a9" translate="yes" xml:space="preserve">
          <source>After a &lt;code&gt;git merge&lt;/code&gt; stops due to conflicts you can conclude the merge by running &lt;code&gt;git merge --continue&lt;/code&gt; (see &quot;HOW TO RESOLVE CONFLICTS&quot; section below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe72261aa48e1b3f091f59d72477eebdd075b990" translate="yes" xml:space="preserve">
          <source>After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c118266972ae017fd4f07d4eca9db22855faae" translate="yes" xml:space="preserve">
          <source>After a failed merge, show refs that touch files having a conflict and don&amp;rsquo;t exist on all heads to merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca7401582c91e911d7f14741ffa269af2ed6e2a" translate="yes" xml:space="preserve">
          <source>After a feature release, the integration branch &lt;code&gt;next&lt;/code&gt; may optionally be rewound and rebuilt from the tip of &lt;code&gt;master&lt;/code&gt; using the surviving topics on &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee4d8fb94bffa7e70baa538f9ff73a2b240bae8" translate="yes" xml:space="preserve">
          <source>After a feature release, you need to manage your maintenance branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745f4d981edc1fae67ad7a65eae4ba7b48a51d0c" translate="yes" xml:space="preserve">
          <source>After a merge (initiated by &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;) stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with &lt;code&gt;git status&lt;/code&gt; and after fixing them manually in your working tree, you would stage the result as usual with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10502b7e8b48a8dee46e24b2019e9f5e468162f8" translate="yes" xml:space="preserve">
          <source>After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aad77091cab70cb7dbe8f7ee76657f4f26524af" translate="yes" xml:space="preserve">
          <source>After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: &lt;code&gt;!&lt;/code&gt; or its synonym &lt;code&gt;^&lt;/code&gt;). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e532f3552d5348fdc5f1bdf8915328d4f66e0e76" translate="yes" xml:space="preserve">
          <source>After a successful merge, update the files in the work tree with the result of the merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f915a9b6a0d7dfb5ab76e6778aa20c487e2e4897" translate="yes" xml:space="preserve">
          <source>After a while, you will have a number of branches, and despite the well chosen names you picked for each of them, you may forget what they are for, or what status they are in. To get a reminder of what changes are in a specific branch, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21e19052101e64abbac6635b64126db7893d400" translate="yes" xml:space="preserve">
          <source>After about 13 tests (in this case), it will output the commit id of the guilty commit. You can then examine the commit with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, find out who wrote it, and mail them your bug report with the commit id. Finally, run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d63924c0ad3d41ed7256461fb0f8cabfcd6c6b" translate="yes" xml:space="preserve">
          <source>After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated. This can be used to implement any repository wide cleanup tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a0e4603dcf967bd9664f6f3fe860af10658058" translate="yes" xml:space="preserve">
          <source>After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line for each successfully updated ref:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df214f68fd91640cff1f194bcc254ff88f0793ee" translate="yes" xml:space="preserve">
          <source>After an attempt to merge stops with conflicts, show the commits on the history between two branches (i.e. the HEAD and the MERGE_HEAD) that modify the conflicted files and do not exist on all the heads being merged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6855a297433d6efa583ee53f54f77288a36a4a3c" translate="yes" xml:space="preserve">
          <source>After committing, do not rebase or reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cb6cc7533103000a5b985188fd777c705ca2f2" translate="yes" xml:space="preserve">
          <source>After configuring the remote, the following three commands will do the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c4cb5f4b09781b6323bee4b2e059f8adaf4c9f" translate="yes" xml:space="preserve">
          <source>After creating a packfile, print a line of data to &amp;lt;file&amp;gt; listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb0f12cc4760d99513845842d5818989334b063" translate="yes" xml:space="preserve">
          <source>After creating commits on a local branch, update the remote branch with your commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35d26dae79ab6ed7b967d8dc4249bb1ae7ac970" translate="yes" xml:space="preserve">
          <source>After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8e9a912ee46d43880271748ff8431413ab88e6" translate="yes" xml:space="preserve">
          <source>After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e22ef2eb3af8a0d0bd459bef01ed36acc704c46" translate="yes" xml:space="preserve">
          <source>After each step you can verify that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715ed76b18490d22ccb88eb785651c8c2059a4a7" translate="yes" xml:space="preserve">
          <source>After editing the p4 change message, &lt;code&gt;git p4&lt;/code&gt; makes sure that the description really was changed by looking at the file modification time. This option disables that test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcca15ec51efe3416c95ceb171efbcf6537ffe0" translate="yes" xml:space="preserve">
          <source>After examining those changes, Alice could merge the changes into her master branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6432877f7b94f7bff8d7c5100d32a9aa8ff2a2de" translate="yes" xml:space="preserve">
          <source>After fast-import terminates the frontend will need to do &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; to remove the dummy branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccac6fd0d710a221bb8914388317ad9efd2c0ef" translate="yes" xml:space="preserve">
          <source>After finding out a common ancestor commit, the second step is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f8226e38e0606c48953eb6013c6b55022869a5" translate="yes" xml:space="preserve">
          <source>After having marked revisions as good or bad, issue the following command to show what has been done so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80bd551ece50cfc5fc850da2031735d0adb9a3e" translate="yes" xml:space="preserve">
          <source>After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will let you go back to where you were, but it will discard your local changes, which you do not want. &lt;code&gt;git reset --merge&lt;/code&gt; keeps your local changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff21b83188a31a6207ce191dc61f50a691f861b" translate="yes" xml:space="preserve">
          <source>After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob&amp;rsquo;s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a &quot;pull&quot;, and then finally unstash her work-in-progress on top of the resulting history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d5abbf7626dec9ccf7afab1dc07b8795265376" translate="yes" xml:space="preserve">
          <source>After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3f26f69bbd1d1c0b392e2f4a4b9463da76a66" translate="yes" xml:space="preserve">
          <source>After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run &lt;code&gt;git prune-packed&lt;/code&gt; to remove redundant loose object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6310edfcb7521ec31d9b130cb6ae6f20fea23aff" translate="yes" xml:space="preserve">
          <source>After performing a merge, the original file with conflict markers can be saved as a file with a &lt;code&gt;.orig&lt;/code&gt; extension. If this variable is set to &lt;code&gt;false&lt;/code&gt; then this file is not preserved. Defaults to &lt;code&gt;true&lt;/code&gt; (i.e. keep the backup files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df243e176ddfa0cca8db617f9402400e5f7c60ba" translate="yes" xml:space="preserve">
          <source>After pushing your work to &lt;code&gt;mytree&lt;/code&gt;, you can use &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to prepare a &quot;please pull&quot; request message to send to Linus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7b502730a3874da935b609ad110273aca4a8d0" translate="yes" xml:space="preserve">
          <source>After receiving the capability advertisement, a client can then issue a request to select the command it wants with any particular capabilities or arguments. There is then an optional section where the client can provide any command specific parameters or queries. Only a single command can be requested at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d906effb7cd99af8f81c132d80d9dfe4320f7472" translate="yes" xml:space="preserve">
          <source>After receiving the pack from the client, &lt;code&gt;receive-pack&lt;/code&gt; may produce no output (if &lt;code&gt;--quiet&lt;/code&gt; was specified) while processing the pack, causing some networks to drop the TCP connection. With this option set, if &lt;code&gt;receive-pack&lt;/code&gt; does not transmit any data in this phase for &lt;code&gt;receive.keepAlive&lt;/code&gt; seconds, it will send a short keepalive packet. The default is 5 seconds; set to 0 to disable keepalives entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db356d4df77c5c16acb15ad22a97c7ea6f2c6df" translate="yes" xml:space="preserve">
          <source>After resolving conflicts and staging the result, &lt;code&gt;git ls-files -u&lt;/code&gt; would stop mentioning the conflicted path. When you are done, run &lt;code&gt;git commit&lt;/code&gt; to finally record the merge:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c30281e1be411a0e33e0f09c24d7eee56dd1d4d" translate="yes" xml:space="preserve">
          <source>After resolving the conflict in the obvious way (but before updating the index), the diff will look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60011229c2b6e9f4d0205ce31a17f85a92fcdccf" translate="yes" xml:space="preserve">
          <source>After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f17f667d528a937d15361797e46f1a4fea1bdf2" translate="yes" xml:space="preserve">
          <source>After rewinding, the commit structure should look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66a5176477ad671c21413d345a1019b22e18ec7" translate="yes" xml:space="preserve">
          <source>After running &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; to update the index entry, you can use &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; to check the contents out of the index to the working tree. Alternatively, using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; and specifying a commit with &lt;code&gt;--source&lt;/code&gt;, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18afdf4deff269ec9f25d6d6aebe21c179f08972" translate="yes" xml:space="preserve">
          <source>After running this &lt;code&gt;git push&lt;/code&gt; on the &lt;code&gt;satellite&lt;/code&gt; machine, you would ssh into the &lt;code&gt;mothership&lt;/code&gt; and run &lt;code&gt;git merge&lt;/code&gt; there to complete the emulation of &lt;code&gt;git pull&lt;/code&gt; that were run on &lt;code&gt;mothership&lt;/code&gt; to pull changes made on &lt;code&gt;satellite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de248d3c434336170b313b4a606fae76271119ac" translate="yes" xml:space="preserve">
          <source>After seeing a conflict, you can do two things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a8b60b2d146b020baf249114d8bfb4056df2e3" translate="yes" xml:space="preserve">
          <source>After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c65fc108282e758fad76a3e65ea8f48110fd1a" translate="yes" xml:space="preserve">
          <source>After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to &lt;code&gt;git commit&lt;/code&gt;. When pathnames are given, the command makes a commit that only records the changes made to the named paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72be6c76fa86af29190b1a1f88fe08f999420ad" translate="yes" xml:space="preserve">
          <source>After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when &quot;git bisect skip&quot; was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebae7c6dbdbd052d8e1deddf2741dfd39e2c5b6" translate="yes" xml:space="preserve">
          <source>After submitting, sync this named branch instead of the default p4/master. See the &quot;Sync options&quot; section above for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b0b049063f0a3e5fb48dd65396ec13b42da44e" translate="yes" xml:space="preserve">
          <source>After that is done, you should be able to compose email as you otherwise would (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), and the patches will not be mangled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfac36870999dd7fd482f2000fa5fc0ffd3ce594" translate="yes" xml:space="preserve">
          <source>After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f073b8aaf7a7d573c425aa250957facb3adf5b" translate="yes" xml:space="preserve">
          <source>After that, the easiest way to record all removals, additions, and modifications in the working tree is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ec20c881539f18de6028bfbfa7896bacec3155" translate="yes" xml:space="preserve">
          <source>After that, you can go back to what you were working on with &lt;code&gt;git stash pop&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18484e36aeec06b4dafe8bfc4dc2214df9ad775" translate="yes" xml:space="preserve">
          <source>After the basics are established, additional command information can be sent to Trace2 as it is discovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e00cd4b44746238e1913ce6a929735926105a52" translate="yes" xml:space="preserve">
          <source>After the clone is created, initialize and clone submodules within based on the provided pathspec. If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has &lt;code&gt;submodule.active&lt;/code&gt; set to the provided pathspec, or &quot;.&quot; (meaning all submodules) if no pathspec is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512c768beb6f564041f676bad06ef4ee2a1c558f" translate="yes" xml:space="preserve">
          <source>After the clone, a plain &lt;code&gt;git fetch&lt;/code&gt; without arguments will update all the remote-tracking branches, and a &lt;code&gt;git pull&lt;/code&gt; without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when &quot;--single-branch&quot; is given; see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd7d7a65c5ebccd7e68c5c66967ea09b43d6139" translate="yes" xml:space="preserve">
          <source>After the last section, you should know how to manage topics. In general, you will not be the only person working on the project, so you will have to share your work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4845263a9667982d51c2722039eed2001af73b3" translate="yes" xml:space="preserve">
          <source>After this test merge, there are two ways to continue your work on the topic. The easiest is to build on top of the test merge commit &lt;code&gt;+&lt;/code&gt;, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the upstream might have been advanced since the test merge &lt;code&gt;+&lt;/code&gt;, in which case the final commit graph would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e78b04901ecf447ad9f08fb14a4d7a3784873" translate="yes" xml:space="preserve">
          <source>After this three-way merge, the local modifications are &lt;code&gt;not&lt;/code&gt; registered in your index file, so &lt;code&gt;git diff&lt;/code&gt; would show you what changes you made since the tip of the new branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aab9481201d40d0fe77311ee6889968b015c0cc" translate="yes" xml:space="preserve">
          <source>After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8cdc248305abd7fd3ad025c5cea93360a62f47" translate="yes" xml:space="preserve">
          <source>After working in the wrong branch, switching to the correct branch would be done using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb228e2496a61023caca1aea4a6e82c2396eddae" translate="yes" xml:space="preserve">
          <source>After working on the &lt;code&gt;topic&lt;/code&gt; branch created with &lt;code&gt;git switch -c
topic origin/master&lt;/code&gt;, the history of remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt; may have been rewound and rebuilt, leading to a history of this shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c12d864e4ce5bf45abb0028f5de0df25bacff49" translate="yes" xml:space="preserve">
          <source>After working some more in the original repository, you can create an incremental bundle to update the other repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5cdbcbfaa82437e4a65c5f716c041276984b11" translate="yes" xml:space="preserve">
          <source>After writing a crash report fast-import will close the current packfile and export the marks table. This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed. The modified branches and tags are not updated during a crash, as the import did not complete successfully. Branch and tag information can be found in the crash report and must be applied manually if the update is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0e0972bba351246b0cebcda509c3b6e9fe7def" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates and merge them into your own work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b2964f5fca0a040b3f9e0cd2999fe0e6cf0437" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1b426ddf419243558839a9a55a74c0218324ad" translate="yes" xml:space="preserve">
          <source>After you mastered the basic concepts, you can come back to this page to learn what commands Git offers. You can learn more about individual Git commands with &quot;git help command&quot;. &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt; manual page gives you an overview of the command-line command syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf4e045979c169751c6df0015d31c55a03d7ee" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;re done, start up &lt;code&gt;gitk --all&lt;/code&gt; to see graphically what the history looks like. Notice that &lt;code&gt;mybranch&lt;/code&gt; still exists, and you can switch to it, and continue to work with it if you want to. The &lt;code&gt;mybranch&lt;/code&gt; branch will not contain the merge, but next time you merge it from the &lt;code&gt;master&lt;/code&gt; branch, Git will know how you merged it, so you&amp;rsquo;ll not have to do &lt;code&gt;that&lt;/code&gt; merge again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a021ce8c26fc96dbae55d24cd95f42b33ecba6" translate="yes" xml:space="preserve">
          <source>Afterwards Git sends a list of &quot;key=value&quot; pairs terminated with a flush packet. The list will contain at least the filter command (based on the supported capabilities) and the pathname of the file to filter relative to the repository root. Right after the flush packet Git sends the content split in zero or more pkt-line packets and a flush packet to terminate content. Please note, that the filter must not send any response before it received the content and the final flush packet. Also note that the &quot;value&quot; of a &quot;key=value&quot; pair can contain the &quot;=&quot; character whereas the key would never contain that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fb4f0b833d93afae381ddbd32b2e731f88bbea" translate="yes" xml:space="preserve">
          <source>Again, because this is a common operation, you can also just shorthand it with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a17673033ec7dbc230aa6a7992e711b3fbc3d4a" translate="yes" xml:space="preserve">
          <source>Again, normally you&amp;rsquo;d never actually do this by hand. There is a helpful script called &lt;code&gt;git commit&lt;/code&gt; that will do all of this for you. So you could have just written &lt;code&gt;git commit&lt;/code&gt; instead, and it would have done the above magic scripting for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afde498ff4cd811d74693c0df59474ecda94165e" translate="yes" xml:space="preserve">
          <source>Again, this can all be simplified with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b1fee6e50d3dc98fed5593a8e8c0ed94635339" translate="yes" xml:space="preserve">
          <source>Again, updating A with this commit will fast-forward and your push will be accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bfbc3378c5615b3a3120f32e2b4f7a040c60bb" translate="yes" xml:space="preserve">
          <source>Again, you should never do this to a commit that may already have been merged into another branch; use &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; instead in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad4cd921bb660f6346bf34bcf03d35af1d89b1f" translate="yes" xml:space="preserve">
          <source>Aggregating short options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46eb2e49d59fe40f45432cfc2d93b9f3ec1b6f6" translate="yes" xml:space="preserve">
          <source>Aggressive</source>
          <target state="translated">Aggressive</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="f18c0f421eb67bfb50f4d3af9083503fd4868a13" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt;. RFC means &quot;Request For Comments&quot;; use this when sending an experimental patch for discussion rather than application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cafd3b08f6afce156de29f77fc37a32f1f3369" translate="yes" xml:space="preserve">
          <source>Alias for a --pretty= format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. Any aliases defined here can be used just as the built-in pretty formats could. For example, running &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; would cause the invocation &lt;code&gt;git log --pretty=changelog&lt;/code&gt; to be equivalent to running &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt;. Note that an alias with the same name as a built-in format will be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1b325e842f25a822c4b269ff141ef39919c475" translate="yes" xml:space="preserve">
          <source>Alice can peek at what Bob did without merging first, using the &quot;fetch&quot; command; this allows Alice to inspect what Bob did, using a special symbol &quot;FETCH_HEAD&quot;, in order to determine if he has anything worth pulling, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e66fd3894cd9fabc7340a32ad3678d949571b95" translate="yes" xml:space="preserve">
          <source>Alice may want to view what both of them did since they forked. She can use three-dot form instead of the two-dot form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40eaaa16860011566dbddc8353ce4cd5b34fb54" translate="yes" xml:space="preserve">
          <source>All 4-byte numbers are in network order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099269695c58af639142bdae5a91d1e49c0c2c94" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CGI&lt;/code&gt; environment variables are available to each of the hooks invoked by the &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f866a82b5ea8dc3929c4ad04564d5c3ed0ee42d8" translate="yes" xml:space="preserve">
          <source>All Trace2 API functions send a message to all of the active Trace2 Targets. This section describes the set of available messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8567b1f7f97dea5e233c49b40ba1a9668558e4c8" translate="yes" xml:space="preserve">
          <source>All URLs are normalized before attempting any matching (the password part, if embedded in the URL, is always ignored for matching purposes) so that equivalent URLs that are simply spelled differently will match properly. Environment variable settings always override any matches. The URLs that are matched against are those given directly to Git commands. This means any URLs visited as a result of a redirection do not participate in matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f6595fa2f42cca20a6fe38ba56a9a1d90610fc" translate="yes" xml:space="preserve">
          <source>All actions except for those that list all available projects, in whatever form, require this parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaff790885e322791dd026d468d21215c97d5ed" translate="yes" xml:space="preserve">
          <source>All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee4593d03a3fe3f61740d3dea48d16adb304aaa" translate="yes" xml:space="preserve">
          <source>All changes made by commits in the current branch but that are not in &amp;lt;upstream&amp;gt; are saved to a temporary area. This is the same set of commits that would be shown by &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt;; or by &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt;, if &lt;code&gt;--fork-point&lt;/code&gt; is active (see the description on &lt;code&gt;--fork-point&lt;/code&gt; below); or by &lt;code&gt;git log HEAD&lt;/code&gt;, if the &lt;code&gt;--root&lt;/code&gt; option is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdf69f9f9acea0027f5883fae412fef01ef415d" translate="yes" xml:space="preserve">
          <source>All changes to the submodule&amp;rsquo;s work tree will be ignored, only committed differences between the HEAD of the submodule and its recorded state in the superproject are taken into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0078bf2eb8fdaed52c7a49142c07f612f6194ca3" translate="yes" xml:space="preserve">
          <source>All commands except clone accept these options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747ced70d2f3d8a9f580e20c513a115bf4ca8d06" translate="yes" xml:space="preserve">
          <source>All commits in the simplified history are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7857a43f974cc0cc16fc43991167acda1bdb92d" translate="yes" xml:space="preserve">
          <source>All commits that are walked are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c8c004ab3e327bb23a0e1cb06bdc4ffe16dbfd" translate="yes" xml:space="preserve">
          <source>All communication is done using packet-line framing, just as in v1. See &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; and &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3a301219274de5dd57371abee3ab5a5312cbb7" translate="yes" xml:space="preserve">
          <source>All configuration variables can also be overridden for a specific method of access. Valid method names are &quot;ext&quot; (for SSH access) and &quot;pserver&quot;. The following example configuration would disable pserver access while still allowing access over SSH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ca4fe2d0fe1a800f4976e6f9f37c5b67ee4941" translate="yes" xml:space="preserve">
          <source>All files from the branching point are added to a branch even if never added in CVS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2751ce2c6eef82a246aaca1478ee0944abee964" translate="yes" xml:space="preserve">
          <source>All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9eed6a91320d25f6961ad95b2f4c0551182ac97" translate="yes" xml:space="preserve">
          <source>All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba8238b26241037a2d523c9dbfd57c6ef21fd9c" translate="yes" xml:space="preserve">
          <source>All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5faba2ec0a1d011ac70519fe6631987cdc41a2b9" translate="yes" xml:space="preserve">
          <source>All gitcvs variables except for &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; can also be specified as &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; (where &lt;code&gt;access_method&lt;/code&gt; is one of &quot;ext&quot; and &quot;pserver&quot;) to make them apply only for the given access method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e3bbc643fcf0e6f476c9a1c5f8183263c2a18a" translate="yes" xml:space="preserve">
          <source>All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a04df7dc83d3748d4d9902845dfe236dbda3335" translate="yes" xml:space="preserve">
          <source>All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c22669562d39ab93b88e8b91c6653478eb31b9b" translate="yes" xml:space="preserve">
          <source>All objects have a statically determined &quot;type&quot; which identifies the format of the object (i.e. how it is used, and how it can refer to other objects). There are currently four different object types: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b47e1baf96b9c8287456e674d706c2d2cb68d3" translate="yes" xml:space="preserve">
          <source>All of the ancestors of a given &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; are said to be &quot;reachable&quot; from that commit. More generally, one &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is reachable from another if we can reach the one from the other by a &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; that follows &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt; to whatever they tag, &lt;a href=&quot;#def_commit_object&quot;&gt;commits&lt;/a&gt; to their parents or trees, and &lt;a href=&quot;#def_tree_object&quot;&gt;trees&lt;/a&gt; to the trees or &lt;a href=&quot;#def_blob_object&quot;&gt;blobs&lt;/a&gt; that they contain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c914353521a7fcdc1482a5e3cfa2c2db891768c9" translate="yes" xml:space="preserve">
          <source>All of the changes that Git was able to merge automatically are already added to the index file, so &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; shows only the conflicts. It uses an unusual syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0851367bef62c00e23b203fa9f1e02fbe0c27531" translate="yes" xml:space="preserve">
          <source>All of the following examples map &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; to &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a148afed6f28c8ecd0df018991ec0db90af85d7" translate="yes" xml:space="preserve">
          <source>All of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a27511d4b01630cccb325b4298d897b1527c61" translate="yes" xml:space="preserve">
          <source>All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91f646c685a7dfcf5e56237f918748518206037" translate="yes" xml:space="preserve">
          <source>All of these objects are stored under their SHA-1 names inside the Git directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd6cc66ca5ed15a438644763fc31848cb788922" translate="yes" xml:space="preserve">
          <source>All of those examples use request rewriting, and need &lt;code&gt;mod_rewrite&lt;/code&gt; (or equivalent; examples below are written for Apache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555f29027228e8eb9986b68d870b32cd598f6835" translate="yes" xml:space="preserve">
          <source>All offset and size bytes are optional. This is to reduce the instruction size when encoding small offsets or sizes. The first seven bits in the first octet determines which of the next seven octets is present. If bit zero is set, offset1 is present. If bit one is set offset2 is present and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64104629c1b1b50c9f411fd4ec6fd95dec11f7bd" translate="yes" xml:space="preserve">
          <source>All packs except the largest pack and those marked with a &lt;code&gt;.keep&lt;/code&gt; files are consolidated into a single pack. When this option is used, &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92b55fa77d7332620f31b40a70c7222a88db6aa" translate="yes" xml:space="preserve">
          <source>All public Trace2 functions and macros are defined in &lt;code&gt;trace2.h&lt;/code&gt; and &lt;code&gt;trace2.c&lt;/code&gt;. All public symbols are prefixed with &lt;code&gt;trace2_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872d9d2cb78e2e8d2f37173a02b50fa38f291d05" translate="yes" xml:space="preserve">
          <source>All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report. This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d43876445b213dd01218535a02d26c66dcd613b" translate="yes" xml:space="preserve">
          <source>All refs under &lt;code&gt;refs/tags&lt;/code&gt; are pushed, in addition to refspecs explicitly listed on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bff800f470ce2148eed81904a64139c855aaa1" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will be shallow with a depth of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0007b01191229097f0830c36da052c040ebd97d" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will use the status of the submodule&amp;rsquo;s remote-tracking branch to update the submodule, rather than the superproject&amp;rsquo;s recorded SHA-1. Equivalent to passing &lt;code&gt;--remote&lt;/code&gt; to &lt;code&gt;git submodule update&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a786f92eda8c2712ba677e1c4004bf3ff8163928" translate="yes" xml:space="preserve">
          <source>All such extra objects are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308cf0e6d77f72bd2adee2732440a8d78d5aacdb" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;file1&lt;/code&gt; files in the output refer to files before the commit, and all the &lt;code&gt;file2&lt;/code&gt; files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239d57c9bf513683c75ec610784ccebafe4aed25" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;git commit&lt;/code&gt; hooks are invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af0c4256a038463a91f307f30a32fa481ee96d" translate="yes" xml:space="preserve">
          <source>All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fe8473c593abf01d9d1e8a032df7ab79ebe59a" translate="yes" xml:space="preserve">
          <source>All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form &lt;code&gt;name = value&lt;/code&gt; (or just &lt;code&gt;name&lt;/code&gt;, which is a short-hand to say that the variable is the boolean &quot;true&quot;). The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ddc9bc522de0a239773cc3df5a07e1939ed991" translate="yes" xml:space="preserve">
          <source>All these options obviously only make sense if enforced by the server side. They have been implemented to resemble the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; options as closely as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a78bca2d245f7f4e49ed3949e2005fd2e3b0774" translate="yes" xml:space="preserve">
          <source>All variables can also be set per access method, see &lt;a href=&quot;#configaccessmethod&quot;&gt;above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e67d43426c8567d2129159d2cb0396634aa4c2f" translate="yes" xml:space="preserve">
          <source>All writing options will per default write to the repository specific configuration file. Note that this also affects options like &lt;code&gt;--replace-all&lt;/code&gt; and &lt;code&gt;--unset&lt;/code&gt;. &lt;strong&gt;&lt;em&gt;git config&lt;/em&gt; will only ever change one file at a time&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ccd528c2d028453ad3cf7d0223681cc63467f8" translate="yes" xml:space="preserve">
          <source>All you need to do is edit the files to resolve the conflicts, and then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd540fb2325b9250764db7424886c097360ae897" translate="yes" xml:space="preserve">
          <source>All you need to do is place the newly created bare Git repository in a directory that is exported by the web server, and make some adjustments to give web clients some extra information they need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48af47b0afbfe999262fa68f40e97838cf256b84" translate="yes" xml:space="preserve">
          <source>Allow (or disallow) external text conversion filters to be run when comparing binary files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, but not for &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or diff plumbing commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c181c3ddfb97039bcd6c32002cf12732d3862d70" translate="yes" xml:space="preserve">
          <source>Allow -s or -t to query broken/corrupt objects of unknown type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf02b1d62cc9d5575e2c1ae9bbaffbbe1cee9af" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;--stdin&lt;/code&gt; to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cf489219ee9e67f31bd43c44a93293049edf6e" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object that is reachable from any ref tip. However, note that calculating object reachability is computationally expensive. Defaults to &lt;code&gt;false&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c123f83ef289d2d1e91047a317113ed5e999032" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for any object at all. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dac60bc93b481fbd44fafe13c497842d9a7d982" translate="yes" xml:space="preserve">
          <source>Allow adding otherwise ignored files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a681012f0189df01bc378cc160293747f7b006" translate="yes" xml:space="preserve">
          <source>Allow an empty note object to be stored. The default behavior is to automatically remove empty notes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f26de68d4ee0de2215d71b6377c359ff10beb5" translate="yes" xml:space="preserve">
          <source>Allow an external diff helper to be executed. If you set an external diff driver with &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;, you need to use this option with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e430db92a123869cc3ef536d85d87d370ba895" translate="yes" xml:space="preserve">
          <source>Allow building of more than one tree object before exiting. Each tree is separated by as single blank line. The final new-line is optional. Note - if the &lt;code&gt;-z&lt;/code&gt; option is used, lines are terminated with NUL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e57d5c7661ffc2e9da98170f1d30b0c418901a9" translate="yes" xml:space="preserve">
          <source>Allow missing objects. The default behaviour (without this option) is to verify that each tree entry&amp;rsquo;s sha1 identifies an existing object. This option has no effect on the treatment of gitlink entries (aka &quot;submodules&quot;) which are always allowed to be missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9030542d2938f9caeac64676db40e7417c42b9" translate="yes" xml:space="preserve">
          <source>Allow pulling from all directories that look like Git repositories (have the &lt;code&gt;objects&lt;/code&gt; and &lt;code&gt;refs&lt;/code&gt; subdirectories), even if they do not have the &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98350181a43fb733be348f0d041de3f567196c13" translate="yes" xml:space="preserve">
          <source>Allow recursive removal when a leading directory name is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c333cb7fb684ac83dfac5b9ca4103644dc06e4b3" translate="yes" xml:space="preserve">
          <source>Allow several &amp;lt;repository&amp;gt; and &amp;lt;group&amp;gt; arguments to be specified. No &amp;lt;refspec&amp;gt;s may be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5913a64254a27922cb756768e473a3a0fc91c718" translate="yes" xml:space="preserve">
          <source>Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67909264741a3c975c7c69263b8cae851ce5588" translate="yes" xml:space="preserve">
          <source>Allow to extend .git/shallow if the new refs require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021daf7178c1ed944c38d8aa70956d32b2ff6625" translate="yes" xml:space="preserve">
          <source>Allow ~user notation to be used in requests. When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access &lt;code&gt;foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;. If &lt;code&gt;--user-path=path&lt;/code&gt; is specified, the same request is taken as a request to access &lt;code&gt;path/foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f93db45d6bdb40051ed50b8cdab39b85ae36aa7" translate="yes" xml:space="preserve">
          <source>Allow/forbid overriding the site-wide default with per repository configuration. By default, all the services may be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970c6f976b1a1113e48252fb665bb9621a059065" translate="yes" xml:space="preserve">
          <source>Allowing web browsing of a repository</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f99759b1b09bc7158e191889a1567fae09d468" translate="yes" xml:space="preserve">
          <source>Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6ea72ee13badd8d83db58afdf5e962ad300ef1" translate="yes" xml:space="preserve">
          <source>Allows to specify the commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ec32ba2a953960fca003bf1ffa505bb688ba89" translate="yes" xml:space="preserve">
          <source>Also note that only one asterisk is allowed per word. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771cf844aea157583eecdff70f695735bc6a87ec" translate="yes" xml:space="preserve">
          <source>Also note that the above configuration can be performed by directly editing the file &lt;code&gt;.git/config&lt;/code&gt; instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4107490214e5f413a9517623a2b64cb4835e7c24" translate="yes" xml:space="preserve">
          <source>Also note that we don&amp;rsquo;t require the commits that are kept to be descendants of a &quot;good&quot; commit. So in the following example, commits W and Z will be kept:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69166c2831d93f6b548f4895823501206c0d3ba" translate="yes" xml:space="preserve">
          <source>Also output details about the matching pattern (if any) for each given pathname. For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9960d9f0773be5357485566c306db4c0f3e065" translate="yes" xml:space="preserve">
          <source>Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fa0726e69077445ae425465cf33ea62e9aedfc" translate="yes" xml:space="preserve">
          <source>Also search in ignored files by not honoring the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful with &lt;code&gt;--untracked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05797f7578d1a6ba6a5217b9a350a9edbcb69fe4" translate="yes" xml:space="preserve">
          <source>Also you can use a regular expression to specify the line range:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4774804d03b6c07565acb208c60c6e7cbe3431b2" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will list those files as &quot;unmerged&quot;, and the files with conflicts will have conflict markers added, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4527cea99021b273b3aba7b9a7e7a9bfd20d98e9" translate="yes" xml:space="preserve">
          <source>Also, note that a bare &lt;code&gt;git diff&lt;/code&gt; shows the changes to file.txt, but not the addition of closing.txt, because the version of closing.txt in the index file is identical to the one in the working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1948de62c9472dadd9b232c96fea0db542b4a7f1" translate="yes" xml:space="preserve">
          <source>Also, the poor performance of git-filter-branch often leads to safety issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d45b434e26b625e54920695d02b2fe8da737175" translate="yes" xml:space="preserve">
          <source>Also, the remote-tracking branch you use the &lt;code&gt;--fork-point&lt;/code&gt; mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; correctly finds, but the &lt;code&gt;--fork-point&lt;/code&gt; mode will not, because it is not one of the commits that used to be at the tip of origin/master).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8d6fa69b9f440f0c0a5d003f6fd5f2f023c7f6" translate="yes" xml:space="preserve">
          <source>Also, these upper-case letters can be downcased to exclude. E.g. &lt;code&gt;--diff-filter=ad&lt;/code&gt; excludes added and deleted paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2530a264943c28587e7428206ae85af163c3c029" translate="yes" xml:space="preserve">
          <source>Also, we do not call it &quot;cache&quot; any more, but rather &quot;index&quot;; however, the file is still called &lt;code&gt;cache.h&lt;/code&gt;. Remark: Not much reason to change it now, especially since there is no good single name for it anyway, because it is basically &lt;code&gt;the&lt;/code&gt; header file which is included by &lt;code&gt;all&lt;/code&gt; of Git&amp;rsquo;s C sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6472f190ba1582b845a0ece02ff445cff78f4d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;--raw&lt;/code&gt; or &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a167e4e28bf08db5b93ca5300935fe27c039fa" translate="yes" xml:space="preserve">
          <source>Alter the sha1&amp;rsquo;s minimum display length in the output listing. The default value is 7 and can be overridden by the &lt;code&gt;core.abbrev&lt;/code&gt; config option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadcacaf495c2512ca4329e0d847da152c0541e3" translate="yes" xml:space="preserve">
          <source>Alternate terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0712141dd1ece4a4773c0da1c80f1954ca0f9da5" translate="yes" xml:space="preserve">
          <source>Alternates, clone -reference, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca863985e6b3522ed032957d62190302ca13b98" translate="yes" xml:space="preserve">
          <source>Alternative Git implementations (e.g. JGit or libgit2) and older Git versions (as of March 2018) do not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If you decide to use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute in your repository, then it is strongly recommended to ensure that all clients working with the repository support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbb61a2fa8dc0f3013308a0745fea72ba7b1a16" translate="yes" xml:space="preserve">
          <source>Alternative development models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aefac2117f3e88573f4205384ee4d7a98e203b" translate="yes" xml:space="preserve">
          <source>Alternatively you can produce the password with perl&amp;rsquo;s crypt() operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca416a8fe96dacfa9959132947eceee9f58da64" translate="yes" xml:space="preserve">
          <source>Alternatively, Git has a native protocol, or can use http; see &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf31ef819e05669294bc16a9923a23bdb2b7a01" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the &lt;code&gt;gitcvs.allBinary&lt;/code&gt; config for the default setting. If &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set, then file not otherwise specified will default to &lt;code&gt;-kb&lt;/code&gt; mode. Otherwise the &lt;code&gt;-k&lt;/code&gt; mode is left blank. But if &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set to &quot;guess&quot;, then the correct &lt;code&gt;-k&lt;/code&gt; mode will be guessed based on the contents of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ff522462be60cebf023852e684a91e2d5544f7" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d07f3824238dc7367ab6d5b5e874d23e305b47d" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it. If the path already exists and is a directory, the trace messages will be written to files (one per process) in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00302c08639585f72779e30a86782e24fd08ff9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of running &lt;code&gt;git add&lt;/code&gt; beforehand, you can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530bb07d1f66513818e1b0385a8e30a51f6194af" translate="yes" xml:space="preserve">
          <source>Alternatively, note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80a5d22f5c293edd914795b473129c37d7276c3" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;code&gt;-z&lt;/code&gt; to specify in NUL-terminated format, without quoting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5759528a9df2b3bafde33c91b20bb607bfb37f6" translate="yes" xml:space="preserve">
          <source>Alternatively, you can edit the working directory and update the index to fix your mistake, just as if you were going to &lt;a href=&quot;#how-to-make-a-commit&quot;&gt;create a new commit&lt;/a&gt;, then run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15cfe3da911f6cecf33791979f852dbff3cfb5b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with &lt;code&gt;git-cvsserver&lt;/code&gt; or manipulate your &lt;code&gt;.bashrc&lt;/code&gt; so that calling &lt;code&gt;cvs&lt;/code&gt; effectively calls &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fd4a6419394e16cfc11919ace1a8f856d1ec42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can rebase your change between X and B on top of A, with &quot;git pull --rebase&quot;, and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49fa07d5474cf3dca63ac2a175c46a10b07f5f3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can undo the &lt;code&gt;git rebase&lt;/code&gt; with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029034bf1886e77ae0c4d532b4059fd9c7d41a52" translate="yes" xml:space="preserve">
          <source>Alternatively, you may often see this sort of thing done with the lower-level command &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, which just lists the SHA-1&amp;rsquo;s of all the given commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf28b03e83304f7cdad7262da1da6a80b8eb9f3d" translate="yes" xml:space="preserve">
          <source>Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains. Developers of such porcelains might start by reading about &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4b8611028dc848ad4ee5788ef19d7585dae7a1" translate="yes" xml:space="preserve">
          <source>Although Git is a truly distributed system, it is often convenient to organize your project with an informal hierarchy of developers. Linux kernel development is run this way. There is a nice illustration (page 17, &quot;Merges to Mainline&quot;) in &lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap&amp;rsquo;s presentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f37ac3daafe831f82aec5b2cea866288f7330ab" translate="yes" xml:space="preserve">
          <source>Although both this option and --fork-point find the merge base between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt;, this option uses the merge base as the &lt;code&gt;starting point&lt;/code&gt; on which new commits will be created, whereas --fork-point uses the merge base to determine the &lt;code&gt;set of commits&lt;/code&gt; which will be rebased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc30d48b03921e7f964de7f07369eb4188785847" translate="yes" xml:space="preserve">
          <source>Although the object files are gone, any commands that refer to those objects will work exactly as they did before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f1282955f73f61669189722bd77f19d0aada5a" translate="yes" xml:space="preserve">
          <source>Although this bit looks similar to assume-unchanged bit, its goal is different from assume-unchanged bit&amp;rsquo;s. Skip-worktree also takes precedence over assume-unchanged bit when both are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6138749eeae08edd7696427a93048315afbc7d0" translate="yes" xml:space="preserve">
          <source>Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2138c97353c611a94eb25c7e6e46e48baedec73c" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;acknowledgments&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd2ed397536c82477394e8a15b0eb70ea28108" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a74cc6750711124d9f54ba56e439b92b2eb550a" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;shallow-info&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa34aca91ee0baeaea0934aa3e08a4599c439042" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;wanted-refs&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e06c04cd8e1ea9ac30d6ef765d5374aeb2852d8" translate="yes" xml:space="preserve">
          <source>Always commit your fixes to the oldest supported branch that requires them. Then (periodically) merge the integration branches upwards into each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740206082e01fd2ec3dbefb8f6cae1ac54979d66" translate="yes" xml:space="preserve">
          <source>Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in &quot;describe&quot; output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee&amp;hellip;​.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fe0db5ec22452b1b5e484a236c7996a8b1d4d4" translate="yes" xml:space="preserve">
          <source>Always publish the submodule change before publishing the change to the superproject that references it. If you forget to publish the submodule change, others won&amp;rsquo;t be able to clone the repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bc18fd1cd8bd10b1f49729296161d64c50a6de" translate="yes" xml:space="preserve">
          <source>Always use the current time and time zone. The literal &lt;code&gt;now&lt;/code&gt; must always be supplied for &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3edc64a04543ee397addec8da3ac8a7a4a6fa3" translate="yes" xml:space="preserve">
          <source>Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace &lt;code&gt;refs/original/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c005cc3257b6a0770843066bf6334d49c090a4e" translate="yes" xml:space="preserve">
          <source>Among the &amp;lt;reference&amp;gt;s given, display only the ones that cannot be reached from any other &amp;lt;reference&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6d5f7660135e74c3b73d13034cd4552f455751" translate="yes" xml:space="preserve">
          <source>An &quot;annotated tag&quot; is actually a real Git object, and contains not only a pointer to the state you want to tag, but also a small tag name and message, along with optionally a PGP signature that says that yes, you really did that tag. You create these annotated tags with either the &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-s&lt;/code&gt; flag to &lt;code&gt;git tag&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1268d4db5a16c4059e58835dc106857c027b0f95" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; which contains unmerged &lt;a href=&quot;#def_index_entry&quot;&gt;index entries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d934873e3d430ebe475eea94d0b0f9a9f43c9fd6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; pointing to another object, which can contain a message just like a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;. It can also contain a (PGP) signature, in which case it is called a &quot;signed tag object&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ba7d0e69e6d58b366781bce9a8868629216c1c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a list of file names and modes along with refs to the associated blob and/or tree objects. A &lt;a href=&quot;#def_tree&quot;&gt;tree&lt;/a&gt; is equivalent to a &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c15d413f65deef5a874cba86dbad4625cd4cbd2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; used to temporarily store the contents of a &lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt; working directory and the index for future reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c263addb55b65fe527b2a21bf509fb6d214e692" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which contains the information about a particular &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;, such as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;, committer, author, date and the &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; which corresponds to the top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; of the stored revision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8c0584fca9913191dbab3d7a46ffea1d0255bd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, &lt;a href=&quot;#def_tag&quot;&gt;tag&lt;/a&gt;, or any other reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa11321cf1316d583795e0fa9253aae31456769" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_unreachable_object&quot;&gt;unreachable object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; even from other unreachable objects; a dangling object has no references to it from any reference or &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f18e6fb49a003c4f6ae24bcf2f216e9b2db33c0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;author&lt;/code&gt; command may optionally appear, if the author information might differ from the committer information. If &lt;code&gt;author&lt;/code&gt; is omitted then fast-import will automatically use the committer&amp;rsquo;s information for the author portion of the commit. See below for a description of the fields in &lt;code&gt;author&lt;/code&gt;, as they are identical to &lt;code&gt;committer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca13f668178d4001fb40c21d014f07bacdba23a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;upload-archive&lt;/code&gt; also exists to serve &lt;code&gt;git archive&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2777cee48df007e662d7335b2a99199ee01a9bf5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; is identified by its 160-bit SHA-1 hash, aka &lt;em&gt;object name&lt;/em&gt;, and a reference to an object is always the 40-byte hex representation of that SHA-1 name. The files in the &lt;code&gt;refs&lt;/code&gt; subdirectory are expected to contain these hex references (usually with a final &lt;code&gt;\n&lt;/code&gt; at the end), and you should thus expect to see a number of 41-byte files containing these references in these &lt;code&gt;refs&lt;/code&gt; subdirectories when you actually start populating your tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56c50d5220ee34a87c6403dce1dee00fe1f60bc" translate="yes" xml:space="preserve">
          <source>An advanced user may want to take a look at &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; after finishing this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba7e65ac14d1c1843ebc23a20f7a824d2e90d69" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;--discard-changes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c482877d68de7df403d2a569fe4e9b8337d6d28" translate="yes" xml:space="preserve">
          <source>An alternate participant submission mechanism is using the &lt;code&gt;git request-pull&lt;/code&gt; or pull-request mechanisms (e.g as used on GitHub (www.github.com) to notify your upstream of your contribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4308fb9f973f309f701eb31f44b62bb9dad115a0" translate="yes" xml:space="preserve">
          <source>An alternative scp-like syntax may also be used with the ssh protocol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e45d63c9493efc9c482c8956b2b502b296e599f" translate="yes" xml:space="preserve">
          <source>An alternative style can be used by setting the &quot;merge.conflictStyle&quot; configuration variable to &quot;diff3&quot;. In &quot;diff3&quot; style, the above conflict may look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a3606b6f09bb975ca3b2fd930ed7cfdb47c5de" translate="yes" xml:space="preserve">
          <source>An application using git-credential will typically use &lt;code&gt;git
credential&lt;/code&gt; following these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3f33e4c0349221e2575da0576bccf42d579897" translate="yes" xml:space="preserve">
          <source>An asterisk &quot;&lt;code&gt;*&lt;/code&gt;&quot; matches anything except a slash. The character &quot;&lt;code&gt;?&lt;/code&gt;&quot; matches any one character except &quot;&lt;code&gt;/&lt;/code&gt;&quot;. The range notation, e.g. &lt;code&gt;[a-zA-Z]&lt;/code&gt;, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92a93236adb7a911f096656f0a19e52c91fc87c" translate="yes" xml:space="preserve">
          <source>An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart&amp;rsquo;s content, and you can remove them. The list looks more or less like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3034dd5f2cb814d90a3721e980abfe2559bdf7b3" translate="yes" xml:space="preserve">
          <source>An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2425d5d7f13cfb1e5013987fec335bdb279cc21f" translate="yes" xml:space="preserve">
          <source>An evil merge is a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; that introduces changes that do not appear in any &lt;a href=&quot;#def_parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="983a5c1c22b13082f53d4ffac58905fc5683444c" translate="yes" xml:space="preserve">
          <source>An example crash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fefb821701ed8916b003bdc64ab026062f47d5" translate="yes" xml:space="preserve">
          <source>An example directly producing formatted text. Show the most recent 3 tagged commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b3f3938c0999bf8d07073e13ae4fad78c37982" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). This prefixes the current branch with a star.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130d3057e79f4ea0755954d533ec854202e8c665" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(end). This prints the authorname, if present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd4a6b345a98548ae1d0552b0faaa4bc7a8afb7" translate="yes" xml:space="preserve">
          <source>An example to use customized color from the configuration in your script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3fe250825ac46db801c9bc9679b73fba035132" translate="yes" xml:space="preserve">
          <source>An example value is &amp;ldquo;Tue Feb 6 11:22:18 2007 -0500&amp;rdquo;. The Git parser is accurate, but a little on the lenient side. It is the same parser used by &lt;code&gt;git am&lt;/code&gt; when applying patches received from email.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bf2af305e53a13545716b037aa5bc68e4afad9" translate="yes" xml:space="preserve">
          <source>An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub is branched by copying it to branches/. &lt;code&gt;git svn clone -s&lt;/code&gt; will then create a branch &lt;code&gt;sub&lt;/code&gt;. It will also create new Git commits for r.100 through r.199 and use these as the history of branch &lt;code&gt;sub&lt;/code&gt;. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch &lt;code&gt;sub@200&lt;/code&gt; pointing to the new parent commit of branch &lt;code&gt;sub&lt;/code&gt; (i.e. the commit for r.200 and trunk/sub/).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6df9fde9d9b1a6c24b6fde6ccfb6d951abd515" translate="yes" xml:space="preserve">
          <source>An existing tree object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0f47829cd53aff363faaa441d2662f7d2a2298" translate="yes" xml:space="preserve">
          <source>An extended regular expression configuring a set of delta islands. See &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8771c0542061da31756f7f028cf42efc80a6790" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating a default compression level. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If set, this provides a default to other compression variables, such as &lt;code&gt;core.looseCompression&lt;/code&gt; and &lt;code&gt;pack.compression&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433b558671525ba8e4d4299bcca156947818bc47" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to -1, the zlib default, which is &quot;a default compromise between speed and compression (currently equivalent to level 6).&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06d94c2c1c7fdd4fbd64a16fb4219ebbe8c1e07" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects that are not in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to 1 (best speed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8d9172fe4750854d99468288f15a393b3d2a0b" translate="yes" xml:space="preserve">
          <source>An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71479e10da1fa6d725307efac957175acd0b7dab" translate="yes" xml:space="preserve">
          <source>An integer port number to connect to on the server. Defaults to 143 for imap:// hosts and 993 for imaps:// hosts. Ignored when imap.tunnel is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13bd69f2aba7e28daf03425a855478a0ac87c0e" translate="yes" xml:space="preserve">
          <source>An object to treat as the head of an unreachability trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649450686ab487a5807b370d54f0bd2d0e6521d8" translate="yes" xml:space="preserve">
          <source>An offset within the jth packfile for the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fd616698d842e6abe0ccbaaa14a722ac806da4" translate="yes" xml:space="preserve">
          <source>An optimized way to tell git &quot;all files have changed&quot; is to return the filename &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2683b05f238ac5f24ee58eef90d2e93c4d292853" translate="yes" xml:space="preserve">
          <source>An optional prefix &quot;&lt;code&gt;!&lt;/code&gt;&quot; which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn&amp;rsquo;t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first &quot;&lt;code&gt;!&lt;/code&gt;&quot; for patterns that begin with a literal &quot;&lt;code&gt;!&lt;/code&gt;&quot;, for example, &quot;&lt;code&gt;\!important!.txt&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72eb40b71a3ee1287d4bc59941eb7d52450fb0cd" translate="yes" xml:space="preserve">
          <source>An output line is formatted this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39328bc4d54c0b1f8244ab4fbfc2b0861f3ec8b7" translate="yes" xml:space="preserve">
          <source>An update will fail (without changing &amp;lt;ref&amp;gt;) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6309284d4ffb9f9db9b99bb2400d242ab3d042" translate="yes" xml:space="preserve">
          <source>Ancillary Commands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690298b04d34764749d8b6b774f1017ccff2bdf1" translate="yes" xml:space="preserve">
          <source>And &quot;p4 branch -o branch1&quot; shows a View line that looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06312e404b0eeaa83f6e7b08d3417e9f32eb7193" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; would print the same thing, as would &lt;code&gt;HEAD:dir/link&lt;/code&gt;, as they both point at &lt;code&gt;HEAD:f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ef2a07032d9e5ab4fbc79e4cc5adecbcbea354" translate="yes" xml:space="preserve">
          <source>And after a few more steps like that, &quot;git bisect&quot; will eventually find a first bad commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2acfea5a7223f44ca9fe3e573c07079e7f8361" translate="yes" xml:space="preserve">
          <source>And even if a bisection fails today it tells us something valuable about the bug: that it&amp;rsquo;s non-deterministic - timing or kernel image layout dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f0203157ace1141f1dde2ae30a3fa8a3636c88" translate="yes" xml:space="preserve">
          <source>And finally create the final commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860e42dc488be31ffa7a020df965384765242565" translate="yes" xml:space="preserve">
          <source>And here is what Andreas said about this work-flow &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01892e1eb858acb775eb9592a4003c7fc4445cdb" translate="yes" xml:space="preserve">
          <source>And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the &quot;bad&quot; commit you have which may be very wasteful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b39a143fb8659118caee67f4b21c31bc36bf3c" translate="yes" xml:space="preserve">
          <source>And it is possible to replay it using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75822a1512d331a3d4633273030648c95f9328f4" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s take a commit X in the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b0d8092d1f5d252ea539a91373ab642092fc55" translate="yes" xml:space="preserve">
          <source>And move the first patch to the end of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f0cc168dfe6f57e4c3a310a06a6b6b3c95713b" translate="yes" xml:space="preserve">
          <source>And of course you can combine all of these; the following finds commits since v2.5 which touch the &lt;code&gt;Makefile&lt;/code&gt; or any file under &lt;code&gt;fs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c90b40159743f0c37c98cf280277c74b4f36f16" translate="yes" xml:space="preserve">
          <source>And testing can be done more often in special integration branches like linux-next for the linux kernel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de647a064a0da49ca37de783bfbd65b321bef2ec" translate="yes" xml:space="preserve">
          <source>And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66491a56d29baec4b0beb6e367fe2e638c6cc60b" translate="yes" xml:space="preserve">
          <source>And then we can ask to see all the commits reachable from master but not from these other heads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5ba14bf614a8d9b59a130fcae6a5153ba0970b" translate="yes" xml:space="preserve">
          <source>And this is nice because at step 2) we compute number_of_ancestors(X) and so at step 3) we compute f(X).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc4b2a34ee7e169dafe705c6dd15bf4f2ab80f2" translate="yes" xml:space="preserve">
          <source>And this is true because at step 1) b) we remove the ancestors of the &quot;good&quot; commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d3703f66b9dc1860841e2625f510f6dad5a4b2" translate="yes" xml:space="preserve">
          <source>And this is where we create the &lt;code&gt;.git/refs/heads/master&lt;/code&gt; file which is pointed at by &lt;code&gt;HEAD&lt;/code&gt;. This file is supposed to contain the reference to the top-of-tree of the master branch, and since that&amp;rsquo;s exactly what &lt;code&gt;git commit-tree&lt;/code&gt; spits out, we can do this all with a sequence of simple shell commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a1c872c4878ac6e52bac1154940404cb212eeb" translate="yes" xml:space="preserve">
          <source>And when we are finished we can use &quot;git bisect reset&quot; to go back to the branch we were in before we started bisecting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ca616a13091cd678c7050cbd59b751c0ca0cb5" translate="yes" xml:space="preserve">
          <source>And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2b5b20cbff6f0447bfb79a46815513c19063a1" translate="yes" xml:space="preserve">
          <source>And, as you can see with cat-file, this new entry refers to the current contents of the file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03f7e1dc1779f7a6b6058b743b6c59117c067d5" translate="yes" xml:space="preserve">
          <source>Annotate file lines with commit information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe64bd304ff43d1f92c6b0e9e2636f5e1954515e" translate="yes" xml:space="preserve">
          <source>Annotate only the given line range. May be specified multiple times. Overlapping ranges are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4227402e63911eeddf3891b83571a9d301c5199" translate="yes" xml:space="preserve">
          <source>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like &lt;code&gt;git describe&lt;/code&gt;) will ignore lightweight tags by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb074164892a20bb11edd02087ea8ad1467c6bc3" translate="yes" xml:space="preserve">
          <source>Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78661c20ec385a35ca13b1d1faa523521f8f6f6e" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372eac78f459ab911a94fedbdc320e48ccdbf71b" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09d247a13d19963c95ef0e9b47f19d8e2953d8d" translate="yes" xml:space="preserve">
          <source>Anonymize the contents of the repository while still retaining the shape of the history and stored tree. See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01e013ecca5b260c6867926bf1ecfcf398d9ba1" translate="yes" xml:space="preserve">
          <source>Anonymizing</source>
          <target state="translated">Anonymizing</target>
        </trans-unit>
        <trans-unit id="40a85528d14ebc97736a92adba47c86eb9ff2aeb" translate="yes" xml:space="preserve">
          <source>Another example of --onto option is to rebase part of a branch. If we have the following situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11987472d58c6aa8430ac38a3fd3bf9cba4916dd" translate="yes" xml:space="preserve">
          <source>Another example: Find out what to do in order to make some script a builtin:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065628e1fb0324bb656fd86df1e08ab2f4715fb3" translate="yes" xml:space="preserve">
          <source>Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd386169e45600451de31b5f03542af4e30d00" translate="yes" xml:space="preserve">
          <source>Another nice thing you can do is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9242e709d07837df4600256193a227ac34a2269c" translate="yes" xml:space="preserve">
          <source>Another option is &quot;updateInstead&quot; which will update the working tree if pushing into the current branch. This option is intended for synchronizing working directories when one side is not easily accessible via interactive ssh (e.g. a live web site, hence the requirement that the working directory be clean). This mode also comes in handy when developing inside a VM to test and fix code on different Operating Systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41abbfafae0720017768935474ce8290c706a151" translate="yes" xml:space="preserve">
          <source>Another possible improvement to &quot;git bisect&quot; would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6527778973bccd7f71c735f492db2e31da9fa5" translate="yes" xml:space="preserve">
          <source>Another special notation is &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&amp;hellip;​&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26135d7c8f5f59da8beefa37e9b70a51b7cf91c1" translate="yes" xml:space="preserve">
          <source>Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable &quot;sparse checkout&quot; because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file content as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb7d4f32d7593e5037a022410f521fabccc479c" translate="yes" xml:space="preserve">
          <source>Another use of the content filtering is to store the content that cannot be directly used in the repository (e.g. a UUID that refers to the true content stored outside Git, or an encrypted content) and turn it into a usable form upon checkout (e.g. download the external content, or decrypt the encrypted content).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8a0103b0697a268e7a45a45f3916e77fac0c3e" translate="yes" xml:space="preserve">
          <source>Another useful tool, especially if you do not always work in X-Window environment, is &lt;code&gt;git show-branch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b5fb1eb9536e4fd859b841771a0add7272b354" translate="yes" xml:space="preserve">
          <source>Another way to collaborate is by using a model similar to that commonly used in CVS, where several developers with special rights all push to and pull from a single shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for instructions on how to set this up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bf2b0b2701454d4c7012f3aa28342f714d532f" translate="yes" xml:space="preserve">
          <source>Another way to submit changes to a project is to tell the maintainer of that project to pull the changes from your repository using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;. In the section &quot;&lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt;Getting updates with &lt;code&gt;git pull&lt;/code&gt;&lt;/a&gt;&quot; we described this as a way to get updates from the &quot;main&quot; repository, but it works just as well in the other direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d232111ed1b21837987efa570715d6d841ade7" translate="yes" xml:space="preserve">
          <source>Any Git command accepting any &amp;lt;object&amp;gt; can also use the following symbolic notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2637aa3ab721e22e9e92fa0dc5c3b142c43c70b8" translate="yes" xml:space="preserve">
          <source>Any Git command that needs to know a commit can take any of these names. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e0ecc60216ae45d014af4558855c0627e28395" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will be rewritten to start, instead, with &amp;lt;base&amp;gt;. In cases where some site serves a large number of repositories, and serves them with multiple access methods, and some users need to use different access methods, this feature allows people to specify any of the equivalent URLs and have Git automatically rewrite the URL to the best alternative for the particular user, even for a never-before-seen repository on the site. When more than one insteadOf strings match a given URL, the longest match is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589cf27f168023444a88c2fd0201931be3237bfb" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will not be pushed to; instead, it will be rewritten to start with &amp;lt;base&amp;gt;, and the resulting URL will be pushed to. In cases where some site serves a large number of repositories, and serves them with multiple access methods, some of which do not allow push, this feature allows people to specify a pull-only URL and have Git automatically use an appropriate URL to push, even for a never-before-seen repository on the site. When more than one pushInsteadOf strings match a given URL, the longest match is used. If a remote has an explicit pushurl, Git will ignore this setting for that remote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a7e54a4e4438b5714cd3ea8d9c648126a4d9c8" translate="yes" xml:space="preserve">
          <source>Any arguments that control the behaviour of the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90454bd170fd9408c974e42887247b5e22880026" translate="yes" xml:space="preserve">
          <source>Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding. (This happens whether or not --msg-filter is used.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b932d4d430aaf425c61def387b1d5f7272350dc" translate="yes" xml:space="preserve">
          <source>Any commits (or tags) that have already been marked will not be exported again. If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f9b66d28d85d6e19fdb5a2a58f610b82508a43" translate="yes" xml:space="preserve">
          <source>Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an &lt;code&gt;rsync&lt;/code&gt; with some other site in the hopes that somebody else has the object you have corrupted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881f628d30dc8f906e6314a57d637b480027cf97" translate="yes" xml:space="preserve">
          <source>Any diff-generating command can take the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt; option to produce a &lt;code&gt;combined diff&lt;/code&gt; when showing a merge. This is the default format when showing merges with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; or &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;. Note also that you can give the &lt;code&gt;-m&lt;/code&gt; option to any of these commands to force generation of diffs with individual parents of a merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693fa01c32bbb0a692d5b48b48158d26bcd64f81" translate="yes" xml:space="preserve">
          <source>Any line that is added in one location and was removed in another location will be colored with &lt;code&gt;color.diff.newMoved&lt;/code&gt;. Similarly &lt;code&gt;color.diff.oldMoved&lt;/code&gt; will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e51f4c4f56de2a2384662213d8799137a1187ad" translate="yes" xml:space="preserve">
          <source>Any nontrivial feature will require several patches to implement, and may get extra bugfixes or improvements during its lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98b5885c45b32a708919758a9a90750e9cf4885" translate="yes" xml:space="preserve">
          <source>Any object with modification time newer than the &lt;code&gt;--prune&lt;/code&gt; date is kept, along with everything reachable from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cde5a06f278fc117497921cb6730239da3eb9d" translate="yes" xml:space="preserve">
          <source>Any objects created by the &lt;code&gt;pre-receive&lt;/code&gt; hook will be created in the quarantine directory (and migrated only if it succeeds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f15852fd98f4e7d5fcff8be14576b9b3b53c8dc" translate="yes" xml:space="preserve">
          <source>Any of the credential.* options above can be applied selectively to some credentials. For example &quot;credential.https://example.com.username&quot; would set the default username only for https connections to example.com. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details on how URLs are matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac0fc50e3c83a77179d2fb9959cd57efc236587" translate="yes" xml:space="preserve">
          <source>Any of the http.* options above can be applied selectively to some URLs. For a config key to match a URL, each element of the config key is compared to that of the URL, in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dafc51d2498886776211f48626918bab9502059" translate="yes" xml:space="preserve">
          <source>Any other arguments are passed directly to &lt;code&gt;git log&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dff852ecf280a28625475c8607b0ee485f1ab1" translate="yes" xml:space="preserve">
          <source>Any other exit code will abort the bisect process. It should be noted that a program that terminates via &lt;code&gt;exit(-1)&lt;/code&gt; leaves $? = 255, (see the exit(3) manual page), as the value is chopped with &lt;code&gt;&amp;amp; 0377&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642004f414daf9dcdfd792ec1198534a94bdecbe" translate="yes" xml:space="preserve">
          <source>Any other value causes Git to act as if &lt;code&gt;text&lt;/code&gt; has been left unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c934a0e2885189af1607d7090f7bdedd35f47c56" translate="yes" xml:space="preserve">
          <source>Any submodule changes are reported as modified &lt;code&gt;M&lt;/code&gt; instead of &lt;code&gt;m&lt;/code&gt; or single &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7f540cc43682f246f3211715ad8ff43ff2cc9b" translate="yes" xml:space="preserve">
          <source>Any valid Git SHA-1 expression that resolves to a commit. See &amp;ldquo;SPECIFYING REVISIONS&amp;rdquo; in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d956d491ba987cc8588aff431085dc6fef94e0" translate="yes" xml:space="preserve">
          <source>Anyway &quot;git rebase&quot; can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e59b76f5bd0befb4dbe4de65fbbfc975d414db1" translate="yes" xml:space="preserve">
          <source>Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same &quot;tree&quot; in git parlance). That&amp;rsquo;s because Z' result from applying the same changes as Z just in a slightly different order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6009c11bd52cccb479f468a5d30bb80204ccc20" translate="yes" xml:space="preserve">
          <source>Anyway, as we mentioned previously, you normally never actually take a look at the objects themselves, and typing long 40-character hex names is not something you&amp;rsquo;d normally want to do. The above digression was just to show that &lt;code&gt;git update-index&lt;/code&gt; did something magical, and actually saved away the contents of your files into the Git object database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868e50b230265adc5a12e0fabfef64c97f0dfb44" translate="yes" xml:space="preserve">
          <source>Anyway, let&amp;rsquo;s exit &lt;code&gt;gitk&lt;/code&gt; (&lt;code&gt;^Q&lt;/code&gt; or the File menu), and decide that we want to merge the work we did on the &lt;code&gt;mybranch&lt;/code&gt; branch into the &lt;code&gt;master&lt;/code&gt; branch (which is currently our &lt;code&gt;HEAD&lt;/code&gt; too). To do that, there&amp;rsquo;s a nice script called &lt;code&gt;git merge&lt;/code&gt;, which wants to know which branches you want to resolve and what the merge is all about:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd4f1d29aada84809b848ed1f3cfeec94f509cd" translate="yes" xml:space="preserve">
          <source>Anyway, once you are sure that you&amp;rsquo;re not interested in any dangling state, you can just prune all unreachable objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af8b356773c7cf5ba56c2406453ade92d5ac3c1" translate="yes" xml:space="preserve">
          <source>Apache 2.x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62093635aebe85cb9943f4c0313c4cb13ae431e5" translate="yes" xml:space="preserve">
          <source>Apache as CGI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf355a3b504d322d867b3a7779ff63edb5eff93" translate="yes" xml:space="preserve">
          <source>Apache must be configured to support CGI scripts in the directory in which gitweb is installed. Let&amp;rsquo;s assume that it is &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adce44ce9fd05dba8366c6738436e24094334a46" translate="yes" xml:space="preserve">
          <source>Apache with FastCGI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154d9ee4c57b9c60297467031aab475139a92de6" translate="yes" xml:space="preserve">
          <source>Apache with mod_perl, via ModPerl::Registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7319c6d9f1793811603c0e586a372fe36cd4e3" translate="yes" xml:space="preserve">
          <source>Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for &lt;code&gt;blame_usage&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7464dc71494394ceb8bfdacf997c37cf7b2fe0" translate="yes" xml:space="preserve">
          <source>Append &quot;exec &amp;lt;cmd&amp;gt;&quot; after each line creating a commit in the final history. &amp;lt;cmd&amp;gt; will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef04cef4b0401f57059733c71c586ba695e16618" translate="yes" xml:space="preserve">
          <source>Append ref names and object names of fetched refs to the existing contents of &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. Without this option old data in &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dedcc5d01b91b42b1e3ae2801d2b001bfa9291" translate="yes" xml:space="preserve">
          <source>Append the notes (see &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;) for the commit after the three-dash line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b0cf67b9a78690ab42bf05c5a970037b617230" translate="yes" xml:space="preserve">
          <source>Append this string to each commit message. Set to empty string to disable this feature. Defaults to &quot;via git-CVS emulator&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2373a40d8b684d9b213d526a29e87b69fa3f0b45" translate="yes" xml:space="preserve">
          <source>Append to the notes of an existing object (defaults to HEAD). Creates a new notes object if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fff387ef07a8a383c37886a7516866c065d733" translate="yes" xml:space="preserve">
          <source>Appendix a: git quick reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505428ce9360d60afb175c3a83b181da98dfd5f0" translate="yes" xml:space="preserve">
          <source>Appendix b: notes and todo list for this manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd05b54bd7b3a6c1bc46851a5cc57ae9e4714f4" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cac5d66c52938bbdbd6bb2ccc1b2a1e469d6e9" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ace5fe552ca52b3206a5bd3ee6c81166a6d4e30" translate="yes" xml:space="preserve">
          <source>Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation. Do not issue the final &quot;p4 submit&quot;, but instead print a message about how to submit manually or revert. This option always stops after the first (oldest) commit. Git tags are not exported to p4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f2321ef5db21359607b635bc37d95c3c3f6949" translate="yes" xml:space="preserve">
          <source>Apply a patch to files and/or to the index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd267fa176f80df21611314430fb619c6c0ca823" translate="yes" xml:space="preserve">
          <source>Apply a patch without touching the working tree. Instead take the cached data, apply the patch, and store the result in the index without using the working tree. This implies &lt;code&gt;--index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6f2e44329517aef587c18d6b7620bb801018d0" translate="yes" xml:space="preserve">
          <source>Apply a series of patches from a mailbox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0339ba7940213ee941e0cfb4df5c765eb525b6" translate="yes" xml:space="preserve">
          <source>Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ad9c2cc3b0c429c18e394c154429c6601a33bc" translate="yes" xml:space="preserve">
          <source>Apply it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9537fc12221a208866b0d5f4bdeb3c72a1e2302e" translate="yes" xml:space="preserve">
          <source>Apply the &quot;clean&quot; process freshly to all tracked files to forcibly add them again to the index. This is useful after changing &lt;code&gt;core.autocrlf&lt;/code&gt; configuration or the &lt;code&gt;text&lt;/code&gt; attribute in order to correct files added with wrong CRLF/LF line endings. This option implies &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3387547d9c3f57336c6769472fbdaa2f41d8d54e" translate="yes" xml:space="preserve">
          <source>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcad7381c75ab9bcebba4ec36c60788e21cc232d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd6111442f7f7c96f0cf43ef692ab3fd0aeaf35" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean &lt;code&gt;maint&lt;/code&gt; and everything between &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;; specifically, &lt;code&gt;maint&lt;/code&gt; will not be used if it is included in &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bf7e7b652d09afeef199594d1b407f0e89fdfa" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267d59350d3cc9c55b8eac43fb7124a86e3e2e8d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by some existing commits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4483cddab281b7008c2024c5cf39c925a712d6f4" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e6df839ae5866b7658a0152bc89b8703c2e9dc" translate="yes" xml:space="preserve">
          <source>Apply the patch in reverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f8070d0672eae136d921241ac9866b7f235114" translate="yes" xml:space="preserve">
          <source>Apply the specified refspec to each ref exported. Multiple of them can be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd7e8ac68a94d08f0fdbfcbab3475962ee42209" translate="yes" xml:space="preserve">
          <source>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd32c5cf17ab15de02490afcc460874d487a4cd" translate="yes" xml:space="preserve">
          <source>Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call &lt;code&gt;git stash drop&lt;/code&gt; manually afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956519c248d491798436fec0428abbdf91cbc909" translate="yes" xml:space="preserve">
          <source>Approach #1 (add-on)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f019c85346bddb5f41fba94e7c74787f47bd0d" translate="yes" xml:space="preserve">
          <source>Approach #2 (configuration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb297e0ad30a52de0d35c2e51c324455cc5006ef" translate="yes" xml:space="preserve">
          <source>Approach #3 (external editor)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4c02b7a9497dd0187742b95b941fbc3f472c18" translate="yes" xml:space="preserve">
          <source>Arbitrary extended SHA-1 expression (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) that typically names a branch head or a tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d8ff22bcfacdaff98940313c6f7a07ddd4cf65" translate="yes" xml:space="preserve">
          <source>Archive/branch identifier in a format that &lt;code&gt;tla log&lt;/code&gt; understands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872da414bff0647443183643c537cf06ff00de53" translate="yes" xml:space="preserve">
          <source>Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f7cc8b7282309c04b6094d3e942d3596636318c" translate="yes" xml:space="preserve">
          <source>Argument disambiguation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd50e821541e889c251a37edf6c132e6475912dc" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;git rev-list&lt;/code&gt;. All positive refs included by these options are rewritten. You may also specify options such as &lt;code&gt;--all&lt;/code&gt;, but you must use &lt;code&gt;--&lt;/code&gt; to separate them from the &lt;code&gt;git filter-branch&lt;/code&gt; options. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345e43f16973168887e556514ee57c8062a62d30" translate="yes" xml:space="preserve">
          <source>Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1. Here the current object is the object creation command the &lt;code&gt;mark&lt;/code&gt; command appears within. This can be &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, and &lt;code&gt;blob&lt;/code&gt;, but &lt;code&gt;commit&lt;/code&gt; is the most common usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f07e2039af4b87f8fad3f523ac66820be39017" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e120dada68dd444b90dd5ea02098a2591a6678" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;checkpoint&lt;/code&gt; can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single &lt;code&gt;checkpoint&lt;/code&gt; command to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb295aae55f7fada69cf590bc90ed14f2b247f0" translate="yes" xml:space="preserve">
          <source>As a consequence, the &lt;code&gt;merge base&lt;/code&gt; is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; when used with the &lt;code&gt;--merge-base&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf2a4b63177a116bbc3cf47e4c27a09d7f0ef0f" translate="yes" xml:space="preserve">
          <source>As a convenience measure, &lt;code&gt;git merge&lt;/code&gt; automatically invokes &lt;code&gt;git rerere&lt;/code&gt; upon exiting with a failed automerge and &lt;code&gt;git rerere&lt;/code&gt; records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not. &lt;code&gt;git commit&lt;/code&gt; also invokes &lt;code&gt;git rerere&lt;/code&gt; when committing a merge result. What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152aaf1da15e40e4974ab4fba1bc2c82b319de92" translate="yes" xml:space="preserve">
          <source>As a general rule, you should try to split your changes into small logical steps, and commit each of them. They should be consistent, working independently of any later commits, pass the test suite, etc. This makes the review process much easier, and the history much more useful for later inspection and analysis, for example with &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; and &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813a368009448480dbec96398e42a0584e7bd447" translate="yes" xml:space="preserve">
          <source>As a given feature goes from experimental to stable, it also &quot;graduates&quot; between the corresponding branches of the software. &lt;code&gt;git.git&lt;/code&gt; uses the following &lt;code&gt;integration branches&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64fd0a9b4f65c1520607403d9b5b0753895060e" translate="yes" xml:space="preserve">
          <source>As a last resort, you can search for the corrupted objects and attempt to replace them by hand. Back up your repository before attempting this in case you corrupt things even more in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55349f46b4e35ef9e012280dbd1cc43373573ca9" translate="yes" xml:space="preserve">
          <source>As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word &quot;commit&quot; is often used by Git in the same places other revision control systems use the words &quot;revision&quot; or &quot;version&quot;. Also used as a short hand for &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1fc843fbc05442df0cf0a8f29973ba8fa37083" translate="yes" xml:space="preserve">
          <source>As a noun: unless it is a &lt;a href=&quot;#def_fast_forward&quot;&gt;fast-forward&lt;/a&gt;, a successful merge results in the creation of a new &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; representing the result of the merge, and having as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; the tips of the merged &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;. This commit is referred to as a &quot;merge commit&quot;, or sometimes just a &quot;merge&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c9a37d68f66f1f75bfd831a2c5dd7a1272c9cd" translate="yes" xml:space="preserve">
          <source>As a real example, this is how I update my public Git repository. Kernel.org mirror network takes care of the propagation to other publicly visible machines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e2c8156579db2980e4a3d9117d5ad5706a2358" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt;
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a86b8dd400c7fa63fb2fa4b8a7674ea4f9c20d3" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert a range-diff (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3
feature/v2&lt;/code&gt;), or a revision range if the two versions of the series are disjoint (for example &lt;code&gt;git format-patch --cover-letter
--range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd619ea41aade7bb01c884d2572b761cf9ff25b" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example &lt;code&gt;git format-patch
--cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a396a38596332774142e3633350d3c5ee12f3978" translate="yes" xml:space="preserve">
          <source>As a special case for the date-type fields, you may specify a format for the date by adding &lt;code&gt;:&lt;/code&gt; followed by date format name (see the values the &lt;code&gt;--date&lt;/code&gt; option to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; takes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ade4e7bdf6353bad954746718b0b4bd913e21c" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will 'not' update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f896fc12182c6581528d02b73cafa58c18c0571" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &quot;A...B&quot; as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60f56407a2b12c7ab7900d72be353ae897d29d5" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cc0995f68a1af6b96ca8bc169efe97ff360947" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;A...B&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98a50738baa944b04be5906cf4230cda7da50f7" translate="yes" xml:space="preserve">
          <source>As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014231faf08aed1fd006d6569258568e8c26510e" translate="yes" xml:space="preserve">
          <source>As a special shortcut,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df53d3c6d9483bf31546176476f770bb64d7028" translate="yes" xml:space="preserve">
          <source>As a verb: The action of storing a new snapshot of the project&amp;rsquo;s state in the Git history, by creating a new commit representing the current state of the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and advancing &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; to point at the new commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e121b03809309d600afd50d432f7cbb397b47657" translate="yes" xml:space="preserve">
          <source>As a verb: To bring the contents of another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; (possibly from an external &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first &lt;a href=&quot;#def_fetch&quot;&gt;fetching&lt;/a&gt; the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a &lt;a href=&quot;#def_pull&quot;&gt;pull&lt;/a&gt;. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30669ffae471bf3f6383626501505c5e90309074" translate="yes" xml:space="preserve">
          <source>As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5905e313567b9a612b1c4b05bb63adbe4c8ba180" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabda80231ec81bd47e1b2a8cca346f3b12eb94b" translate="yes" xml:space="preserve">
          <source>As an example use case, consider the following commit history:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cfcd564d3c903d2d8f64e4c4116cc502a9ccb3" translate="yes" xml:space="preserve">
          <source>As an example, a typical orderfile for the core Git probably would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393e086dc57d2576b08e508b4c5a81ba83fe2ed2" translate="yes" xml:space="preserve">
          <source>As an example, suppose you are trying to find the commit that broke a feature that was known to work in version &lt;code&gt;v2.6.13-rc2&lt;/code&gt; of your project. You start a bisect session as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51fd8c0acda05665f38c4533584f1e7599db6e4" translate="yes" xml:space="preserve">
          <source>As an example, the command below will show the path and currently checked out commit for each submodule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3760e902be67f22552bbeb65e39e836e5efd1bcb" translate="yes" xml:space="preserve">
          <source>As an example, use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 encoded with byte order mark (BOM) and you want Git to perform automatic line ending conversion based on your platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51bf467f4f316d3645d71a2a1258673146c504e9" translate="yes" xml:space="preserve">
          <source>As another useful shortcut, the &quot;HEAD&quot; of a repository can be referred to just using the name of that repository. So, for example, &quot;origin&quot; is usually a shortcut for the HEAD branch in the repository &quot;origin&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8026d1f9c2456b3e1c9c2d009b9420179e138763" translate="yes" xml:space="preserve">
          <source>As before, if we do &lt;code&gt;git diff-files -p&lt;/code&gt; in our git-tutorial project, we&amp;rsquo;ll still see the same difference we saw last time: the index file hasn&amp;rsquo;t changed by the act of committing anything. However, now that we have committed something, we can also learn to use a new command: &lt;code&gt;git diff-index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf611fa72ccf0565756cc79d030368187f807460" translate="yes" xml:space="preserve">
          <source>As described in &quot;Projects list file format&quot; section, you can control which projects are &lt;strong&gt;visible&lt;/strong&gt; by selectively including repositories in projects list file, and setting &lt;code&gt;$projects_list&lt;/code&gt; gitweb configuration variable to point to it. With &lt;code&gt;$strict_export&lt;/code&gt; set, projects list file can be used to control which repositories are &lt;strong&gt;available&lt;/strong&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cd736f89da40ebc01b21f3f068771d165721a3" translate="yes" xml:space="preserve">
          <source>As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4986ad28ead3398292128508370a98b8f0d98d3c" translate="yes" xml:space="preserve">
          <source>As development continues in the p4 repository, those changes can be included in the Git repository using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95c634f5d2da95f8f228babb7d2d483e4c0fbd6" translate="yes" xml:space="preserve">
          <source>As explained in the comments, you can reorder commits, squash them together, edit commit messages, etc. by editing the list. Once you are satisfied, save the list and close your editor, and the rebase will begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7111298f6d4fcf0e45bb2162c1a76bdcc1c9c21b" translate="yes" xml:space="preserve">
          <source>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b094bea742cc2d9c8adaa2beb6a0f04f6aac290" translate="yes" xml:space="preserve">
          <source>As long as a &quot;smudge&amp;rarr;clean&quot; results in the same output as a &quot;clean&quot; even on files that are already smudged, this strategy will automatically resolve all filter-related conflicts. Filters that do not act in this way may cause additional merge conflicts that must be resolved manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1864f8816e6742ed19679415e2b4f0693aaf2aa7" translate="yes" xml:space="preserve">
          <source>As no direct connection between the repositories exists, the user must specify a basis for the bundle that is held by the destination repository: the bundle assumes that all objects in the basis are already in the destination repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5a5d1f8e11ad4218ba16acff45cd1e219fd7d0" translate="yes" xml:space="preserve">
          <source>As objects are unpacked they&amp;rsquo;re written to the object store, so there can be cases where malicious objects get introduced even though the &quot;fetch&quot; failed, only to have a subsequent &quot;fetch&quot; succeed because only new incoming objects are checked, not those that have already been written to the object store. That difference in behavior should not be relied upon. In the future, such objects may be quarantined for &quot;fetch&quot; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09eeb717613e6d721cd260fee5aeb319ede3cef4" translate="yes" xml:space="preserve">
          <source>As of cURL v7.60.0, the Secure Channel backend can use the certificate bundle provided via &lt;code&gt;http.sslCAInfo&lt;/code&gt;, but that would override the Windows Certificate Store. Since this is not desirable by default, Git will tell cURL not to use that bundle by default when the &lt;code&gt;schannel&lt;/code&gt; backend was configured via &lt;code&gt;http.sslBackend&lt;/code&gt;, unless &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; overrides this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965229350b7d9b7b4d3000cae9b4d2865a3ca80c" translate="yes" xml:space="preserve">
          <source>As one can see it lacks the 'sub' element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581927934e29a8f082f8e666e70165083e8e5a90" translate="yes" xml:space="preserve">
          <source>As soon as fast-import completes the Git repository is completely valid and ready for use. Typically this takes only a very short time, even for considerably large projects (100,000+ commits).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef5bfd643e7695a1fe3a9fa38e890221a2a3138" translate="yes" xml:space="preserve">
          <source>As stated earlier, the repo-id is currently always 1, so there will only be one def_repo event. Later, if in-proc submodules are supported, a def_repo event should be emitted for each submodule visited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80ca2ccc438317d745ae5338aae99312b25f26c" translate="yes" xml:space="preserve">
          <source>As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a &quot;truly stupid&quot; algorithm, later improved by Junio Hamano, that works quite well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58257bfeca486a2bf1fd8b1803660be56d2b010d" translate="yes" xml:space="preserve">
          <source>As the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2031564d4e49bc946d835c341012879d4274c799" translate="yes" xml:space="preserve">
          <source>As the result, the attributes assignment to &lt;code&gt;t/abc&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192578c95c2280ba3c2f61313d8bf0f6a57ae4fb" translate="yes" xml:space="preserve">
          <source>As this option had confusing syntax, it is no longer supported. Please use &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843f190460819446fe8a020e4f922195a92ea733" translate="yes" xml:space="preserve">
          <source>As we know N from the beginning, we know that min(X, N - X) can&amp;rsquo;t be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85eb1d605d24cad051a866066f0da97dcc80577c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; will complain if this does not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;; see the following section for details on handling this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efa157c58c7162f458fc6766132a5f146c4534e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, you may also set up configuration options to save typing; so, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e201452993c8ff29862a314b348165ba75fd76" translate="yes" xml:space="preserve">
          <source>As with other commands of this type, &lt;em&gt;git diff-index&lt;/em&gt; does not actually look at the contents of the file at all. So maybe &lt;code&gt;kernel/sched.c&lt;/code&gt; hasn&amp;rsquo;t actually changed, and it&amp;rsquo;s just that you touched it. In either case, it&amp;rsquo;s a note that you need to &lt;em&gt;git update-index&lt;/em&gt; it to make the index be in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a219cc037572dc449858e58401a98b9487e41ef" translate="yes" xml:space="preserve">
          <source>As with pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, all of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed71506050bfa72b1ea4f1ce93514b64d8904d8" translate="yes" xml:space="preserve">
          <source>As with the bug described above the solution is to one-off do a &quot;git status&quot; run with &lt;code&gt;core.untrackedCache=false&lt;/code&gt; to flush out the leftover bad data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f65f9810b42bc29820c9b18c26064984a955e8e" translate="yes" xml:space="preserve">
          <source>As with the case to record your own changes, you can use &lt;code&gt;-a&lt;/code&gt; option to save typing. One difference is that during a merge resolution, you cannot use &lt;code&gt;git commit&lt;/code&gt; with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see &lt;code&gt;-i&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22aaf02415c185eaf98c36bda4bb6f6375b4276" translate="yes" xml:space="preserve">
          <source>As yet another alternative, the &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; command lists the commits reachable from its arguments with a display on the left-hand side that indicates which arguments that commit is reachable from. So, if you run something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab55ac3413eea0cf585d324d891a90eb1c44a9c7" translate="yes" xml:space="preserve">
          <source>As you can see, a commit is defined by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6777c5e47b1bbdf59716ff3b0a0a681c16313dcb" translate="yes" xml:space="preserve">
          <source>As you can see, a commit shows who made the latest change, what they did, and why.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f1d03e1580f855020045fffe8e5647f3b9c420" translate="yes" xml:space="preserve">
          <source>As you can see, a tree object contains a list of entries, each with a mode, object type, SHA-1 name, and name, sorted by name. It represents the contents of a single directory tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8afd8db14f6b2c4703101087783a19cada8ee5" translate="yes" xml:space="preserve">
          <source>As you can see, this tells us which branch we&amp;rsquo;re currently on, and it tells us this by naming a file under the .git directory, which itself contains a SHA-1 name referring to a commit object, which we can examine with cat-file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7345319011443769ac795138deb4faa77176b52c" translate="yes" xml:space="preserve">
          <source>Ask git-credential to give us a username and password for this description. This is done by running &lt;code&gt;git credential fill&lt;/code&gt;, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353866df360a6151213ae26714b0b27ee93959c9" translate="yes" xml:space="preserve">
          <source>Ask the user to confirm that a patch set should actually be sent to SVN. For each patch, one may answer &quot;yes&quot; (accept this patch), &quot;no&quot; (discard this patch), &quot;all&quot; (accept all patches), or &quot;quit&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74885a8f797e3dd4d74ed362a01fa5f6e719e159" translate="yes" xml:space="preserve">
          <source>Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created. Still, this is useful to convert Arch repositories that had been rotated periodically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae130157899ed03a40dd2250aa34f89aff67c5" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;&lt;code&gt;master&lt;/code&gt;&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa8cbaa5281b0af933b5133552cbab39bea906e" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;topic&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd2aff8a20d9db05868ff5d3b79174e0521391d" translate="yes" xml:space="preserve">
          <source>Assume the output looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97613cb38d31b0bbed31ce68ca2dcace37e030ff" translate="yes" xml:space="preserve">
          <source>Assume you have a tarball project.tar.gz with your initial work. You can place it under Git revision control as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679231bf1096aa234d1b1628f62bacea198b2922" translate="yes" xml:space="preserve">
          <source>Assume you have local changes in &quot;master&quot;, but you need to refetch &quot;r2&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7f011565f1c258dd11dc44833bb09a98dcf45f" translate="yes" xml:space="preserve">
          <source>Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2183deafca588db3e5f3e1c7cf0d56a53d10c987" translate="yes" xml:space="preserve">
          <source>Assume your existing repo is at /home/alice/myproject. Create a new &quot;bare&quot; repository (a repository without a working tree) and fetch your project into it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e522eb4dcb1a9410bd8273e0683d16ad9d1887" translate="yes" xml:space="preserve">
          <source>Assume your personal repository is in the directory &lt;code&gt;~/proj&lt;/code&gt;. We first create a new clone of the repository and tell &lt;code&gt;git daemon&lt;/code&gt; that it is meant to be public:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f08c00864cc26377518c6e9b880162905e8d349" translate="yes" xml:space="preserve">
          <source>Assuming that gitweb is installed to &lt;code&gt;/var/www/perl&lt;/code&gt;, the following Apache configuration (for mod_perl 2.x) is suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21b72294adb0bdfa94f142e28bd7e66d94e6e2e" translate="yes" xml:space="preserve">
          <source>Assuming the submodule has a Git directory at &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; and a working directory at &lt;code&gt;path/to/bar/&lt;/code&gt;, the superproject tracks the submodule via a &lt;code&gt;gitlink&lt;/code&gt; entry in the tree at &lt;code&gt;path/to/bar&lt;/code&gt; and an entry in its &lt;code&gt;.gitmodules&lt;/code&gt; file (see &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;) of the form &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60da90e959e19c4160d1646a608d2bc5b787c602" translate="yes" xml:space="preserve">
          <source>Assuming you are using the merge approach discussed above, when you are releasing your project you will need to do some additional branch management work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1388e5cd4892a287239160f51404821c63ca478d" translate="yes" xml:space="preserve">
          <source>At any point you can view the history of your changes using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40d41f48140a6f9c8ed7743f53a14cc49f4d4d6" translate="yes" xml:space="preserve">
          <source>At any point you may use the &lt;code&gt;--abort&lt;/code&gt; option to abort this process and return mywork to the state it had before you started the rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e6c111ed6dea301f6219c21f04088d951095f1" translate="yes" xml:space="preserve">
          <source>At any time, we can create a new commit using &lt;code&gt;git commit&lt;/code&gt; (without the &quot;-a&quot; option), and verify that the state committed only includes the changes stored in the index file, not the additional change that is still only in our working tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62227c162304e2658e4b654489602aed406e046" translate="yes" xml:space="preserve">
          <source>At the beginning, the content of the index will be identical to that of the HEAD. The command &lt;code&gt;git diff --cached&lt;/code&gt;, which shows the difference between the HEAD and the index, should therefore produce no output at that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8edc58a934b3ed21297a24f7c0434615621064c8" translate="yes" xml:space="preserve">
          <source>At this point the index file still has all the WIP changes you committed as &lt;code&gt;snapshot WIP&lt;/code&gt;. This updates the index to show your WIP files as uncommitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb30ce8f93c559deaf24b4ad05d6dda3c1a1ac8" translate="yes" xml:space="preserve">
          <source>At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d7e84e91592f3766bf21a35fce90d676b02b60" translate="yes" xml:space="preserve">
          <source>At this point we can see what the commit does, check it out (if it&amp;rsquo;s not already checked out) or tinker with it, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9821aa659e4d6623e87210d9f79f8fb8048ff5ce" translate="yes" xml:space="preserve">
          <source>At this point you could delete the experimental branch with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f18a8a14c3813ef07a4e4179ae90618a19f07d0" translate="yes" xml:space="preserve">
          <source>At this point you should know everything necessary to read the man pages for any of the git commands; one good place to start would be with the commands mentioned in &lt;a href=&quot;giteveryday&quot;&gt;giteveryday[7]&lt;/a&gt;. You should be able to find any unknown jargon in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870751f448af1f37fa82b626c9d940e8d540a997" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;git diff&lt;/code&gt; shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with &lt;code&gt;git add&lt;/code&gt; as usual:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e0f856e1b344e50a8f9f6370e6aeaf4be3455" translate="yes" xml:space="preserve">
          <source>At this point, you could use &lt;code&gt;pull&lt;/code&gt; to merge your changes back in; the result would create a new merge commit, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd76265a60d161772d69d7db5cee25c535ce122" translate="yes" xml:space="preserve">
          <source>At this time, the &lt;code&gt;merge&lt;/code&gt; command will &lt;strong&gt;always&lt;/strong&gt; use the &lt;code&gt;recursive&lt;/code&gt; merge strategy for regular merges, and &lt;code&gt;octopus&lt;/code&gt; for octopus merges, with no way to choose a different one. To work around this, an &lt;code&gt;exec&lt;/code&gt; command can be used to call &lt;code&gt;git merge&lt;/code&gt; explicitly, using the fact that the labels are worktree-local refs (the ref &lt;code&gt;refs/rewritten/onto&lt;/code&gt; would correspond to the label &lt;code&gt;onto&lt;/code&gt;, for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05aeaaa9fcd28f51dfdd6a6420e663787cde8e1" translate="yes" xml:space="preserve">
          <source>Attempt authentication without seeking a username or password. This can be used to attempt GSS-Negotiate authentication without specifying a username in the URL, as libcurl normally requires a username for authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ef94beb2ddaab144a55b166c213b4001e85f5a" translate="yes" xml:space="preserve">
          <source>Attempt to auto-register archives at &lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; This is particularly useful with the -D option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9e2779fbfa7bc1835b11ad0c4ebabfce18ac06" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message with a custom regex. It can be used with &lt;code&gt;-m&lt;/code&gt; to enable the default regexes as well. You must escape forward slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8801ab881aa4eb66128b4665e3908eb4d237716" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8811bcf98c754b208d76412300be8b3f7a7a0962" translate="yes" xml:space="preserve">
          <source>Attempt to use AUTH SSL/TLS and encrypted data transfers when connecting via regular FTP protocol. This might be needed if the FTP server requires it for security reasons or you wish to connect securely whenever remote FTP server supports it. Default is false since it might trigger certificate verification errors on misconfigured servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653466560b06acd7928eb1dabc7b9fa724a015d3" translate="yes" xml:space="preserve">
          <source>Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files. Empty directories are automatically recreated when using &quot;git svn clone&quot; and &quot;git svn rebase&quot;, so &quot;mkdirs&quot; is intended for use after commands like &quot;git checkout&quot; or &quot;git reset&quot;. (See the svn-remote.&amp;lt;name&amp;gt;.automkdirs config file option for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="6945a05135c86ba329a2113c1a6c328943460d7a" translate="yes" xml:space="preserve">
          <source>Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="3a3b18a78fb302a466d9706ed638e25ca72e2b20" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken build between v1.2 and HEAD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b961e5ffc1b4a2335ddafbf9005a05ec9394a9ac" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken test case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbd5b3ba20268a44c57d801ed284c730cc6da62" translate="yes" xml:space="preserve">
          <source>Automatically bisect a test failure between origin and HEAD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305f7f7499890d95ab081f6ff6a94a43fd8f7472" translate="yes" xml:space="preserve">
          <source>Automatically bisect with temporary modifications (hot-fix):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ce497b64c12f23e2601126336fc2efac214445" translate="yes" xml:space="preserve">
          <source>Automatically correct and execute mistyped commands after waiting for the given number of deciseconds (0.1 sec). If more than one command can be deduced from the entered text, nothing will be executed. If the value of this option is negative, the corrected command will be executed immediately. If the value is 0 - the command will be just shown but not executed. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95bbf7a5ca8016973d83b1a1be57b0354ee0b3c" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172ed809f35e71e5eeb8f45359fa6e87d4adb464" translate="yes" xml:space="preserve">
          <source>Automatically enter the &lt;code&gt;Amend Last Commit&lt;/code&gt; mode of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4a15096a50442dde0b46a87fa45d92f2d785b9" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d8a969b318bfe4bd71c313d20f34515eed00b4" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided). This is the same as specifying the &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ac3fef9b72ebf093fec8697b2ecc321af38b99" translate="yes" xml:space="preserve">
          <source>Automating</source>
          <target state="translated">Automating</target>
        </trans-unit>
        <trans-unit id="91b5703f47ead0e97d542b1a3caaad3f90e51a85" translate="yes" xml:space="preserve">
          <source>Avatar support. When this feature is enabled, views such as &quot;shortlog&quot; or &quot;commit&quot; will display an avatar associated with the email of each committer and author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d2705a42ecaf3f83b93f2bb10c67222bc9051b" translate="yes" xml:space="preserve">
          <source>Avoid using these constructs, or do so with extreme caution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d07623af97c330a561d59f75b429cfa3bf0d0e" translate="yes" xml:space="preserve">
          <source>Avoiding bug prone merges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75c3f820aba1b207ca074d2c527699299d0d6c8" translate="yes" xml:space="preserve">
          <source>Avoiding repetition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9b7d07bde7114458252fe7c7c79eff561fa5a3" translate="yes" xml:space="preserve">
          <source>Avoiding testing a commit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6679b7397715a4a559a3f90cd5da98012c5192b" translate="yes" xml:space="preserve">
          <source>Avoiding untestable commits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06045f474b6de45fbcfae00e6444b3eed002fd3" translate="yes" xml:space="preserve">
          <source>BBChop is like &lt;code&gt;git bisect&lt;/code&gt; (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58da1ac28249462c67af1a7a678bbb84e64c5732" translate="yes" xml:space="preserve">
          <source>Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4c8fb0c7c0f01878ae288a3240d6945abd9968" translate="yes" xml:space="preserve">
          <source>Back when this document was originally written, many porcelain commands were shell scripts. For simplicity, it still uses them as examples to illustrate how plumbing is fit together to form the porcelain commands. The source tree includes some of these scripts in contrib/examples/ for reference. Although these are not implemented as shell scripts anymore, the description of what the plumbing layer commands do is still valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd5a2617e84a99ed87281238ca40ff62c45eb00" translate="yes" xml:space="preserve">
          <source>Backend extra options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68cec68bccaee9cd80346d9802ee1e4fe905591f" translate="yes" xml:space="preserve">
          <source>Backend for fast Git data importers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332ccbbf6a93a641f5828315e15dfb5ba3534887" translate="yes" xml:space="preserve">
          <source>Background refresh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3768e81347249432d7250e290eff2b7dcfb031aa" translate="yes" xml:space="preserve">
          <source>Backwards compatibility with &lt;code&gt;crlf&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4f796a2c073cee4b5657a9746bebeb8b591e9a" translate="yes" xml:space="preserve">
          <source>Base URL for relative URLs in pages generated by gitweb, (e.g. &lt;code&gt;$logo&lt;/code&gt;, &lt;code&gt;$favicon&lt;/code&gt;, &lt;code&gt;@stylesheets&lt;/code&gt; if they are relative URLs), needed and used &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; only for URLs with nonempty PATH_INFO. Usually gitweb sets its value correctly, and there is no need to set this variable, e.g. to $my_uri or &quot;/&quot;. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to override it anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097ac79311bf794decc7505841440135a2fcc1ec" translate="yes" xml:space="preserve">
          <source>Base tree information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41acf5ab02f1a6facad6c843b7f1be13be76b889" translate="yes" xml:space="preserve">
          <source>Basic Command Messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32df76cf3cbd146d03819bb90c4b2e01188b5795" translate="yes" xml:space="preserve">
          <source>Basic Snapshotting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3df0ee4c430ab18f213f1998c456e450457574" translate="yes" xml:space="preserve">
          <source>Basic bisect commands: start, bad, good</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8edc4390b3f014a72c7bad2082d4af28321b0a0d" translate="yes" xml:space="preserve">
          <source>Basically, the initial version of &lt;code&gt;git log&lt;/code&gt; was a shell script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434712fddf7623f4187c1faf83b1bb6fa207c805" translate="yes" xml:space="preserve">
          <source>Batch output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09375d82ef48456f50bfb9b6b51c1eb3256d2719" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and &lt;code&gt;subcommand&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c658e70993b255c8802b7997e9b78d1f1aa3285" translate="yes" xml:space="preserve">
          <source>Be aware that commits that the old version of example/master pointed at may be lost, as we saw in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a69fc5e5785e6c85861e4893e3a9a94deb0c9c" translate="yes" xml:space="preserve">
          <source>Be careful with that last command: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don&amp;rsquo;t use &lt;code&gt;git reset&lt;/code&gt; on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use &lt;code&gt;git revert&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a106ab03cbfb468582a31c86875853bbaafe530d" translate="yes" xml:space="preserve">
          <source>Be chatty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0226bfbddcb9791bd20d59aa488cf4bfb67ab797" translate="yes" xml:space="preserve">
          <source>Be more quiet when creating or deleting a branch, suppressing non-error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925261c1087472fc24273a6f0433e6dab581a46e" translate="yes" xml:space="preserve">
          <source>Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a76ff079f12b1a74eb9b1c43645e96dd86361c1" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors, but not the files that are successfully removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0a3e777f7a9dd999ab064af69bac80ddbc5083" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors. The default behavior is set by the &lt;code&gt;reset.quiet&lt;/code&gt; config option. &lt;code&gt;--quiet&lt;/code&gt; and &lt;code&gt;--no-quiet&lt;/code&gt; will override the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f313b181847f334463e2b9b9cfece6969bdba71" translate="yes" xml:space="preserve">
          <source>Be quiet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fac52c9e565c186d12f20b18e356a6357e3a35" translate="yes" xml:space="preserve">
          <source>Be quiet. Implies --no-stat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35516ed1ed9df26f7366465685509e0334c0b48a" translate="yes" xml:space="preserve">
          <source>Be quiet. Only print error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89978c5e1540e90f998db2cd0eadcb073170d060" translate="yes" xml:space="preserve">
          <source>Be verbose about what is going on, including progress status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e80f48c004a90076351b14f311e5f6e4c744c6f" translate="yes" xml:space="preserve">
          <source>Be verbose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38a34eb197b14381b23c4e10c689eabe1fdd749" translate="yes" xml:space="preserve">
          <source>Be verbose. Implies --stat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d448b8a2b9d0f1627827f1dfcde2eef631321fa0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;--&lt;/code&gt; disambiguates revisions and paths in some commands, it cannot be used for those commands to separate options and revisions. You can use &lt;code&gt;--end-of-options&lt;/code&gt; for this (it also works for commands that do not distinguish between revisions in paths, in which case it is simply an alias for &lt;code&gt;--&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed27c3aa81ab7c3b7b68607b6265fd75466941ef" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;git rebase&lt;/code&gt; replays each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch using the given strategy, using the &lt;code&gt;ours&lt;/code&gt; strategy simply empties all patches from the &amp;lt;branch&amp;gt;, which makes little sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611de3be2abb35df567ae0fa30747c7d8e2e7993" translate="yes" xml:space="preserve">
          <source>Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes. If branches exist under &lt;code&gt;refs/remote/origin/p4&lt;/code&gt;, those will be fetched and used when syncing from p4. This variable can be set to &lt;code&gt;false&lt;/code&gt; to disable this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b27b448c938b73dbdadc78ef0ba4dafccd89967" translate="yes" xml:space="preserve">
          <source>Because of this rule, version bumps should be kept to an absolute minimum. Instead, we generally prefer these strategies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9f1c640b4582c4a49afdb8c70b2833e5da2875" translate="yes" xml:space="preserve">
          <source>Because text conversion can be slow, especially when doing a large number of them with &lt;code&gt;git log -p&lt;/code&gt;, Git provides a mechanism to cache the output and use it in future diffs. To enable caching, set the &quot;cachetextconv&quot; variable in your diff driver&amp;rsquo;s config. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc6b3eb8dba093f368da6924e1615ce67ee83a2" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6959f8959917da0048164f701d2c1653881d1c94" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c5affce108c66b3b01079a5ffc874aa2199c4e" translate="yes" xml:space="preserve">
          <source>Because you&amp;rsquo;re asking for raw output, you&amp;rsquo;ll now get something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c83aee082a9b203ae0a8b1d789ef54ecb5119e2" translate="yes" xml:space="preserve">
          <source>Because your branch did not contain anything more than what had already been merged into the &lt;code&gt;master&lt;/code&gt; branch, the merge operation did not actually do a merge. Instead, it just updated the top of the tree of your branch to that of the &lt;code&gt;master&lt;/code&gt; branch. This is often called &lt;code&gt;fast-forward&lt;/code&gt; merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870bf9816d9b0c5ffd88b816d5bee6377c654145" translate="yes" xml:space="preserve">
          <source>Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the &quot;status: add a failing test showing a core.untrackedCache bug&quot; commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201415c3562a156d29edac8b78dcea637cbede90" translate="yes" xml:space="preserve">
          <source>Before Git invokes a hook, it changes its working directory to either $GIT_DIR in a bare repository or the root of the working tree in a non-bare repository. An exception are hooks triggered during a push (&lt;code&gt;pre-receive&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;post-receive&lt;/code&gt;, &lt;code&gt;post-update&lt;/code&gt;, &lt;code&gt;push-to-checkout&lt;/code&gt;) which are always executed in $GIT_DIR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb683352fd365c05d1a2f3a901dc43ac75f481f" translate="yes" xml:space="preserve">
          <source>Before Git v2.0, the default prefix was &quot;&quot; (no prefix). This meant that SVN-tracking refs were put at &quot;refs/remotes/*&quot;, which is incompatible with how Git&amp;rsquo;s own remote-tracking refs are organized. If you still want the old default, you can get it by passing &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; on the command line (&lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; may not work if your Perl&amp;rsquo;s Getopt::Long is &amp;lt; v2.37).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9087c912c36612c549b23a216e2ca49dd6b41fb" translate="yes" xml:space="preserve">
          <source>Before any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running &lt;code&gt;git am&lt;/code&gt; on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the &quot;From:&quot; lines).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
