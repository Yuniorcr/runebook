<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">サーバーと通信する際に、指定したHTTPプロトコルのバージョンを使用します。デフォルトを強制的に使用したい場合。利用可能なバージョンとデフォルトのバージョンは libcurl に依存します。実際には、このオプションの可能な値は</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">指定されたURLを使用して、宛先のSubversionリポジトリに接続します。これは、ソースSVNリポジトリが読み取り専用である場合に役立ちます。このオプションは、設定プロパティ &lt;code&gt;commiturl&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 構成変数の値を使用して、エラーとして何を通知するかを決定します。</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">PGP署名を作成または検証するときに、 &lt;code&gt;$PATH&lt;/code&gt; にある「 &lt;code&gt;gpg&lt;/code&gt; 」の代わりにこのカスタムプログラムを使用します。プログラムは、GPGと同じコマンドラインインターフェイスをサポートする必要があります。つまり、切り離された署名を検証するには、「 &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; 」が実行され、プログラムはコードで終了することにより、適切な署名を通知します。 0、およびASCII装甲の分離署名を生成するには、「 &lt;code&gt;gpg -bsau $key&lt;/code&gt; 」の標準入力に署名する内容を入力し、プログラムは結果を標準出力に送信することが期待されます。</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">これは、以前のバージョンの &lt;code&gt;git archimport&lt;/code&gt; で使用されていた古いスタイルのブランチ名との互換性のために使用します。古いスタイルのブランチ名はカテゴリ{litdd}ブランチでしたが、新しいスタイルのブランチ名はアーカイブ、カテゴリ{litdd}ブランチ{litdd}バージョンです。どちらの場合も、コマンドラインで指定された名前は、自動生成された名前をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">このオプションを使用して、アップストリームサブプロジェクトからの変更をサブモジュールの現在のHEADと統合します。また、あなたが実行することができます &lt;code&gt;git pull&lt;/code&gt; リモートブランチ名を除いて同等であるサブモジュールから： &lt;code&gt;update --remote&lt;/code&gt; デフォルトの上流リポジトリと使用しています &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 、一方で &lt;code&gt;git pull&lt;/code&gt; サブモジュールの使用しています &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 。優先 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; あなたが親プロジェクトとして、デフォルト上流分岐を配布する場合 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; サブモジュール自体での作業中に、あなたがより多くのネイティブな感触をしたい場合。</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">このオプションを使用して、元のコミットが保存されるネームスペースを設定します。デフォルト値は &lt;code&gt;refs/original&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">このオプションを使用して、書き換えに使用する一時ディレクトリへのパスを設定します。ツリーフィルターを適用する場合、コマンドは一時的にツリーをいくつかのディレクトリにチェックアウトする必要があります。これは、大規模なプロジェクトの場合にかなりのスペースを消費する可能性があります。デフォルトでは &lt;code&gt;.git-rewrite/&lt;/code&gt; ディレクトリでこれを行いますが、このパラメーターでその選択を上書きできます。</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">このオプションを使用すると、ステージを解除してインデックスからパスのみを削除することができます。作業ツリーファイルは、変更されているかどうかに関わらず、そのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">これを使用して、選択した署名形式に使用されるプログラムをカスタマイズします。 （参照 &lt;code&gt;gpg.program&lt;/code&gt; と &lt;code&gt;gpg.format&lt;/code&gt; を） &lt;code&gt;gpg.program&lt;/code&gt; は依然としてため、従来の同義語として使用することができる &lt;code&gt;gpg.openpgp.program&lt;/code&gt; 。 &lt;code&gt;gpg.x509.program&lt;/code&gt; のデフォルト値は「gpgsm」です。</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">$ PATHに見つからない場合、これを使用してリモート側の &lt;code&gt;git-upload-pack&lt;/code&gt; へのパスを指定します。 sshdのインストールでは、ログインシェル用のユーザーの環境設定スクリプト（.bash_profileなど）が無視され、プライベートにインストールされたgitがシステムのデフォルトの$ PATHにない場合があります。推奨される別の回避策は、「。bashrc」に$ PATHを設定することですが、このフラグは、無駄のない.bashrcファイルを使用して非インタラクティブシェルのオーバーヘッドを支払うことを望まない人向けです（ほとんどの設定は.bash_profile内）。</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">使用したDBIドライバー。ここで使用可能なドライバーを指定できますが、機能しない可能性があります。 cvsserverは &lt;code&gt;DBD::SQLite&lt;/code&gt; でテストされ、DBD :: &lt;code&gt;DBD::Pg&lt;/code&gt; で動作することが報告されており、 &lt;code&gt;DBD::mysql&lt;/code&gt; 動作し&lt;strong&gt;ない&lt;/strong&gt;ことが報告されて&lt;strong&gt;い&lt;/strong&gt;ます。これは実験的な機能と見なしてください。コロンを含めることはできません（ &lt;code&gt;:&lt;/code&gt; ）。デフォルト： &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Perl DBIドライバーを使用。ここで使用可能なドライバーを指定できますが、機能しない可能性があります。 git-cvsserverは &lt;code&gt;DBD::SQLite&lt;/code&gt; でテストされ、DBD &lt;code&gt;DBD::Pg&lt;/code&gt; で動作することが報告されており、 &lt;code&gt;DBD::mysql&lt;/code&gt; 動作し&lt;strong&gt;ない&lt;/strong&gt;ことが報告されて&lt;strong&gt;い&lt;/strong&gt;ます。実験的機能。ダブルコロンを含めることはできません（ &lt;code&gt;:&lt;/code&gt; ）。デフォルト： &lt;code&gt;SQLite&lt;/code&gt; 。&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">％（if）&amp;hellip;％（then）&amp;hellip;％（end）または％（if）&amp;hellip;％（then）&amp;hellip;％（else）&amp;hellip;％（end）として使用されます。 ％（if）の後に値または文字列リテラルを持つアトムがある場合、％（then）の後のすべてが出力されます。そうでなければ、％（else）アトムが使用される場合、％（else）の後のすべてが出力されます。 ％（then）の前の文字列を評価するときにスペースを無視します。これは、「*」または「」を出力する％（HEAD）アトムを使用し、 &lt;code&gt;HEAD&lt;/code&gt; 参照にのみ &lt;code&gt;if&lt;/code&gt; 条件を適用する場合に役立ちます。 「：equals = &amp;lt;string&amp;gt;」または「：notequals = &amp;lt;string&amp;gt;」を追加して、％（if：&amp;hellip;）および％（then）アトム間の値を指定された文字列と比較します。</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">バンドルファイルが有効であり、現在のリポジトリにクリーンに適用されることを確認するために使用されます。これには、バンドル形式自体のチェック、および前提条件のコミットが存在し、現在のリポジトリに完全にリンクされていることのチェックが含まれます。 &lt;code&gt;git bundle&lt;/code&gt; は、欠落しているコミットがあればそのリストを出力し、ゼロ以外のステータスで終了します。</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; という名前のバンドルを作成するために使用されます。これには、バンドルの内容を定義する &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 引数が必要です。 &lt;code&gt;options&lt;/code&gt; には、 &lt;code&gt;git bundle create&lt;/code&gt; サブコマンドに固有のオプションが含まれています。</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">http.sslBackendが「schannel」に設定されている場合、cURLで証明書失効チェックを強制または無効にするために使用されます。設定されてい &lt;code&gt;true&lt;/code&gt; 場合、デフォルトはtrueです。 Gitが一貫してエラーになり、メッセージが証明書の失効ステータスを確認することに関する場合にのみ、これを無効にする必要があります。実行時に関連するSSLオプションを設定するためのサポートがcURLにない場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">gitwebクエリに応答する最大負荷を設定するために使用されます。サーバーの負荷がこの値を超えると、gitwebは「503 Service Unavailable」エラーを返します。gitwebが値を決定できない場合、サーバーの負荷は0になります。現在は &lt;code&gt;/proc/loadavg&lt;/code&gt; を使用するLinuxでのみ機能します。負荷は、システム上でアクティブなタスクの数（実際に実行されているプロセス）の数で、直前の1分間の平均です。</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">--remoteと共に使用して、リモート側の &lt;code&gt;git-upload-archive&lt;/code&gt; へのパスを指定します。</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;--range-diff&lt;/code&gt; と一緒に使用し、作成/削除のコストファッジファクターを調整することにより、以前のパッチと現在のパッチの間のコミットを一致させるヒューリスティックを調整します。詳細については、&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; コマンドで使用されます。</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">ユーザーマニュアル</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">ユーザーの設定や設定は、次の場所に保存されます。</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">ユーザー名（例えば、 &lt;code&gt;user&lt;/code&gt; で &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ）。構成キーにユーザー名がある場合は、URLのユーザー名と正確に一致する必要があります。構成キーにユーザー名がない場合、その構成キーは、任意のユーザー名（なしを含む）とURLを照合しますが、ユーザー名のある構成キーよりも優先順位が低くなります。</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; を使用して、すべてのp4コマンドのオプションとして指定されたユーザー。代わりに、環境変数 &lt;code&gt;P4USER&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">ユーザー固有の設定ファイル。グローバル」設定ファイルとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">ユーザー固有の資格情報ファイル。</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTHのユーザー名。デフォルトは &lt;code&gt;sendemail.smtpUser&lt;/code&gt; の値です。ユーザー名が指定されていない場合（ &lt;code&gt;--smtp-user&lt;/code&gt; または &lt;code&gt;sendemail.smtpUser&lt;/code&gt; を使用）、認証は試行されません。</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">ユーザーは、-s/--strategy オプションを使用するか、または notes.mergeStrategy を設定することで、以下の中から自動化されたマージ戦略を選択することができます。</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">CVSから移行するユーザーは、&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;を読むこともできます。</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">「変更しない」ビットの使用</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">「git add -A」を使用する</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">「git commit -a」を使用する</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">キャッシュ情報または --info-only を使用する</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">インデックス情報を使う</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">recurse-submodules を使うと、すでにチェックアウトされているサブモジュールの新しいコミットを今すぐに取得することができます。例えば、スーパープロジェクトのコミットを取得したところで上流側が新しいサブモジュールを追加した場合、そのサブモジュール自体を取得することはできません。これは将来の Git バージョンで修正される予定です。</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">recurse-submodulesを使うと、read-treeを再帰的に呼び出すことで、スーパープロジェクトに記録されたコミットに応じて、すべての初期化されたサブモジュールの内容が更新され、そのコミット時にサブモジュールのHEADが切り離されるように設定されます。</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">リフレッシュを使用する</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">temp または --stage=all を使う</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; で &lt;code&gt;--index-filter&lt;/code&gt; を使用すると、非常に高速なバージョンが生成されます。 &lt;code&gt;rm filename&lt;/code&gt; を使用する場合と同様に、ファイルがコミットのツリーに存在しない場合、 &lt;code&gt;git rm --cached filename&lt;/code&gt; は失敗します。ファイルを「完全に忘れる」場合は、いつ履歴に入ったかは問題ではないため、 &lt;code&gt;--ignore-unmatch&lt;/code&gt; も追加します。</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、初期化されたすべてのサブモジュールの内容が更新されます。サブモジュールのローカル変更が上書きされる場合、 &lt;code&gt;-f&lt;/code&gt; を使用しないとチェックアウトは失敗します。何も使用しない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、初期化されたすべてのサブモジュールの内容が更新されます。何も使用しない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; を使用すると、&amp;lt;remote&amp;gt;が、同じ&amp;lt;remote&amp;gt;パターンが前に付いているローカルブランチと混同されます。</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">&lt;em&gt;git checkout-index&lt;/em&gt;を使用して「ツリー全体をエクスポートする」</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">制限を使用する</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">独立した履歴を維持しながら別のプロジェクトを使う サブモジュールを使うことで、両方のプロジェクトの履歴を別々に保ちながら、別のプロジェクトの作業ツリーを自分の作業ツリーの中に入れることができます。また、サブモジュールは任意のバージョンに固定されるため、スーパープロジェクトに影響を与えずに他のプロジェクトを独立して開発することができ、スーパープロジェクトのプロジェクトは必要なときだけ新しいバージョンに固定することができます。</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">複雑なスクリプトの使用</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">SSLでダイレクトモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">ダイレクトモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">git を使った共同作業</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">インタラクティブなリベースの使用</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">マクロ属性の使用</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">より多くのオプションを一般的にさらなる制限を使用して出力（例えば &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; より新しいコミットに制限 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; ととそれを用いた &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; ログメッセージコミットに対するさらなる制限が一致していることラインを有します &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ）（特に明記されていない限り）。</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">refspecsを明示的に使用する。</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">テストスイートとgitを二分して使う</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]で&lt;/a&gt; &lt;code&gt;--submodule=log&lt;/code&gt; オプションを使用すると、その情報も提供されます。</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">これらのオプションを使用すると、&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;は、コミットログツールのより専門的なファミリである&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;、および&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]と同様に機能します。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">このヘルパーを使用すると、パスワードが暗号化されずにディスクに保存され、ファイルシステムのアクセス許可によってのみ保護されます。これが許容できるセキュリティのトレードオフではない場合は、&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]を&lt;/a&gt;試すか、オペレーティングシステムが提供する安全なストレージと統合するヘルパーを見つけてください。</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">このフックを使えば、リポジトリへの更新を記述するメールを簡単に生成できます。このスクリプトの例では、リポジトリにプッシュされたコミットをリストアップしたメールメッセージを ref ごとに送信し、署名されたプッシュのプッシュ証明書をロガーサービスに記録しています。</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">このオプションを他の目的で使用しないでください（質問しないでください）。</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">トンネルモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">テキストファイルの通常の3方向ファイルレベルマージ。競合の領域が衝突マーカでマークされている &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;=======&lt;/code&gt; そして &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。ブランチのバージョンは &lt;code&gt;=======&lt;/code&gt; マーカーの前に表示され、マージされたブランチのバージョンは &lt;code&gt;=======&lt;/code&gt; マーカーの後に表示されます。</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">通常、 &lt;code&gt;git gc&lt;/code&gt; は非常に高速に実行されますが、ディスク領域の使用率とパフォーマンスは良好です。このオプションを使用すると、 &lt;code&gt;git gc&lt;/code&gt; はリポジトリをより積極的に最適化しますが、はるかに時間がかかります。この最適化の効果は、ほとんどが持続します。詳細については、以下の「積極的」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">通常、マージでは、ローカルでの変更を失わないようにするために、作業ツリー内のファイルだけでなくインデックスファイルも現在のヘッドコミットと最新の状態にしておく必要があります。このフラグは、作業ツリーのチェックを無効にし、現在の作業ツリーの状態に直接関係のないツリーを一時的なインデックスファイルにマージする際に使用します。</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">通常、 &lt;code&gt;git read-tree&lt;/code&gt; による3者間マージでは、非常に些細なケースのマージが解決され、他のケースはインデックスに未解決のまま残るため、磁器が異なるマージポリシーを実装できます。このフラグにより​​、コマンドは内部でさらにいくつかのケースを解決します。</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">通常、「&amp;lt;feature&amp;gt;」を指定すると、リポジトリごとのGit構成ファイルの &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; 構成変数を介して構成できます。</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">通常、個人の &lt;code&gt;.ssh/config&lt;/code&gt; ファイルを使用して、必要なオプションを構成する方が簡単です。詳細については、sshのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">通常、唯一の親コミットと全く同じツリーを持つコミットを記録することは間違いであり、このコマンドはそのようなコミットを行わないようにします。このオプションは安全性をバイパスし、主に外国の SCM インタフェーススクリプトで使用します。</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">通常、コマンドは自動的に一連のコミットを作成します。このフラグは、コミットを行わずに、作業ツリーとインデックスにそれぞれの名前のついたコミットをチェリーピックするために必要な変更を適用します。さらに、このオプションが使用された場合、インデックスは HEAD コミットと一致する必要はありません。チェリーピックはインデックスの先頭の状態に対して行われます。</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">通常、このコマンドは、どのコミットが元に戻されたかを示すコミットログメッセージとともに、いくつかのコミットを自動的に作成します。このフラグは、指定されたコミットを作業ツリーとインデックスに戻すために必要な変更を適用しますが、コミットは行いません。さらに、このオプションを使用した場合、インデックスは HEAD コミットと一致する必要はありません。復帰はインデックスの先頭の状態に対して行われます。</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">通常、コマンドは、すべてのブランチの共通の祖先であるコミットを表示すると出力を停止します。このフラグは、コマンドに&amp;lt;n&amp;gt;より多くの一般的なコミットを実行するように指示します。&amp;lt;n&amp;gt;が負の場合、コミットの祖先ツリーを表示せずに、指定された&amp;lt;reference&amp;gt;のみを表示します。</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">通常、オブジェクト名はSHA-1形式（可能な &lt;code&gt;^&lt;/code&gt; プレフィックス付き）で出力されます。このオプションは、可能な限り元の入力に近い形式で出力します。</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">通常、出力はフラグとパラメータごとに1行になります。このオプションは、シェルによる消費のために適切に引用された出力を1行にします。パラメータに空白や改行が含まれることが予想される場合に便利です（たとえば、 &lt;code&gt;git diff-*&lt;/code&gt; で pickaxe &lt;code&gt;-S&lt;/code&gt; を使用する場合）。 &lt;code&gt;--sq-quote&lt;/code&gt; オプションとは異なり、コマンド入力は通常どおり解釈されます。</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">通常、プログラムはSubject：ヘッダー行から電子メールの残骸を削除して、コミットログメッセージのタイトル行を抽出します。このオプションはこの変更を防ぎ、 &lt;code&gt;git format-patch -k&lt;/code&gt; の出力を読み取るために使用する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">マージのどちらをメインラインとみなすべきかがわからないので、通常はチェリーピックはできません。このオプションは、メインラインの親番号 (1 から始まる)を指定し、チェリーピックで指定した親からの相対的な変更を再生することができます。</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">通常、マージのどちら側をメインラインと見なすべきかがわからないため、マージを元に戻すことはできません。このオプションは、メインラインの親番号 (1 から始まる)を指定し、指定した親からの相対的な変更を元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">通常は、以下に説明する設定変数を変更 (調整)する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">通常は、代わりに、このコマンドの上位レベルのラッパーである &lt;code&gt;git fetch&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">通常は、代わりにこのコマンドの上位レベルのラッパーである &lt;code&gt;git push&lt;/code&gt; を使用します。&lt;a href=&quot;git-push&quot;&gt;git-push [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">通常、&quot;git push&quot; は、上書きに使用したローカル ref の祖先ではないリモート ref の更新を拒否します。</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">通常、ぶら下がっているブロブとツリーはあまり面白くありません。ほとんどの場合、それらは中途半端なマージベースである（手動で修正した競合するマージがあった場合、BLOBには多くの場合、マージからの競合マーカーも含まれます）、または単に中断した結果です。^ Cなどを使用した &lt;code&gt;git fetch&lt;/code&gt; 。オブジェクトデータベースに新しいオブジェクトの &lt;code&gt;some&lt;/code&gt; を残しますが、ぶら下がり、役に立たなくなります。</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">通常、コマンドは、それを上書きするために使用されたローカル参照の祖先ではないリモート参照の更新を拒否します。また、 &lt;code&gt;--force-with-lease&lt;/code&gt; オプションを使用すると、コマンドは、現在の値が予期されるものと一致しないリモート参照の更新を拒否します。</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">通常、コマンドは、上書きに使用されたローカル ref の祖先ではないリモート ref の更新を拒否します。このフラグはチェックを無効にします。これが意味するのは、リモートリポジトリがコミットを失う可能性があるということです;注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">有効な &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; には以下が含まれます：</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">有効なオブジェクトタイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">パックされた Git アーカイブファイルの検証</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git commit -S&lt;/code&gt; によって作成されたGPG署名を検証します。</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git tag&lt;/code&gt; 作成されたgpg署名を検証します。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">対応する &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 構成エントリがある場合は、他のツールの値を使用できます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">後の設定ファイルで取得した値は、上記のシーケンスで以前に取得した値を上書きします。</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">多くの変数の値は単純な文字列として扱われますが、特定の型の値を取る変数があり、それをどのように綴るかというルールがあります。</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">変数の置換</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">さまざまな Git コマンドでは、以下の環境変数を使用します。</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">gitwebの動作のさまざまな側面は​​、構成ファイル &lt;code&gt;gitweb_config.perl&lt;/code&gt; または &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; で制御できます。詳細については、&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">さまざまなコマンドが構成ファイルから読み取られ、それに応じて操作が調整されます。参照&lt;a href=&quot;git-config&quot;&gt;のgit-config設定[1]&lt;/a&gt;リストおよび設定メカニズムの詳細については。</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">参照オブジェクト内の構造化されたフィールドからの様々な値を、結果の出力への補間や、ソートキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">作業木のチェック方法いろいろ</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">曖昧な出力。</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">採用されている検索戦略に関する情報を標準誤差になるように簡潔に表示します。タグ名は標準出力されます。</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">冗長性： &lt;code&gt;cvsimport&lt;/code&gt; に実行内容を報告させます。</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">データベース内のオブジェクトの接続性と有効性を検証します。</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">データベース内のオブジェクトの接続性と有効性を検証します。</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;に対して&amp;lt;ref&amp;gt;を確認しますが、変更しないでください。&amp;lt;oldvalue&amp;gt;がゼロまたは欠落している場合、参照は存在してはなりません。</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">ターゲットから到達可能なすべてのものがフェッチされていることを確認します。以前のフェッチが中断された後に使用されます。</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">正確に1つのパラメータが提供され、それがオブジェクト・データベースにアクセスするために使用できる生の20バイトSHA-1に変換できることを確認してください。そうであれば、それを標準出力に出力し、そうでなければエラーアウトします。</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">マージするサイドブランチの tip commit が有効な鍵で署名されているかどうかを確認します。サイドブランチの tip コミットが有効な鍵で署名されていない場合は、マージは中止されます。</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">与えられたタグ名のGPG署名を検証します。</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">現在の .git フォルダにある packfiles の MIDX ファイルを確認します。</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">MIDXファイルの内容を確認します。</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">バージョン1の磁器フォーマットは短いフォーマットに似ていますが、Gitのバージョン間やユーザーの設定に基づいて後方互換性のない方法で変更されないことが保証されています。そのため、スクリプトによるパースに最適です。上記の short フォーマットの説明では、いくつかの例外を除いて porcelain フォーマットについても説明しています。</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">バージョン2のフォーマットでは、ワークツリーの状態や変更された項目に関するより詳細な情報が追加されています。バージョン2では、解析しやすいオプションのヘッダの拡張可能なセットも定義されています。</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">バージョン 2 の pack-*.idx ファイルは 4 gib 以上のパックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">バージョン4では、単純なパス名圧縮を実行して、大規模なリポジトリでインデックスサイズを30%~50%削減し、ロード時間を短縮します。バージョン 4 は比較的新しいものです (最初にリリースされたのは 2012 年 10 月の 1.8.0 です)。JGit や libgit2 のような他の Git 実装はまだサポートしていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">1.7.7より古いバージョンのGitは &lt;code&gt;tar.gz&lt;/code&gt; 形式を認識していません。明示的にgzipを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">代替メカニズムを介して、&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;は「代替」と呼ばれる別のオブジェクトデータベースから&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベースの&lt;/a&gt;一部を継承できます。</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">リビジョンで変更されたものをすべて表示し、リポジトリの履歴を見ながら、リビジョンを1つずつステップアップしていきます。</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">GUIツールでのファイルの閲覧</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">複数の Git リポジトリを共通のルートで表示します。</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">古いファイルのバージョンを表示する</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">プロジェクトの履歴を見る</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">任意のファイルの注釈/注釈の詳細を表示します(有効な場合)。</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">リポジトリ内のファイルの内容を任意のリビジョンで表示します。</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">ブランチのリビジョンログ、ファイルやディレクトリの履歴を表示して、いつ、誰が、何を変更したかを確認します。</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">SMTPサーバーに再接続する前に$ &amp;lt;int&amp;gt;秒待機しています。--batch-sizeオプションと一緒に使用します。デフォルトは &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 構成変数です。</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">履歴を後方ではなく前方に移動します。行が表示されたリビジョンを表示する代わりに、行が存在した最後のリビジョンを表示します。これには、START..ENDのような一連のリビジョンが必要です。 &lt;code&gt;git blame --reverse START&lt;/code&gt; は、便宜上 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">シリーズのパッチをウォークスルーして、パッチをコミットするために必要な情報がすべて見つからない場合に警告します。この記事を書いている時点では、欠落している作者情報のみが警告されています。</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">変更により競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 &lt;code&gt;core.whitespace&lt;/code&gt; 構成によって制御されます。デフォルトでは、末尾の空白（空白のみで構成される行を含む）および行の最初のインデント内の直後にタブ文字が続く空白文字は、空白エラーと見なされます。問題が見つかった場合、ゼロ以外のステータスで終了します。--exit-codeとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">適切な転送エンコーディング（ &lt;code&gt;auto&lt;/code&gt; 、 &lt;code&gt;base64&lt;/code&gt; 、または &lt;code&gt;quoted-printable&lt;/code&gt; ）が使用されていない限り、998文字より長い行を含むパッチの警告。これは、&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txtで&lt;/a&gt;説明されているSMTPの制限によるものです。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">明示的にサポートされていない構文や、パーサに認識されないその他の行については、標準エラー出力に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">&lt;a href=&quot;#understanding-commits&quot;&gt;「ヒストリーの理解：コミット」では&lt;/a&gt;、すべてのコミットが40桁の「オブジェクト名」で保存されることをすでに確認しました。実際、プロジェクトの履歴を表すために必要なすべての情報は、そのような名前のオブジェクトに格納されています。いずれの場合も、名前はオブジェクトのコンテンツのSHA-1ハッシュを取ることによって計算されます。SHA-1ハッシュは、暗号化ハッシュ関数です。つまり、同じ名前の2つの異なるオブジェクトを見つけることは不可能です。これには多くの利点があります。特に：</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">我々は新しい系列の「最良の」説明を古い系列の観点から探している.説明」をグラフの辺として表現することができる.</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">GITWEB_CONFIGにはデフォルトのMakefile値、つまり &lt;code&gt;gitweb_config.perl&lt;/code&gt; があると想定しています。以下を &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; ファイルに入れます：</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">etc/servicesでは以下のように仮定しています。</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">プロジェクトのGitリポジトリがすでに作成されていると想定します。ゼロから作成するか、tarballから作成するか（&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]を&lt;/a&gt;参照）、既存のCVSリポジトリからインポートする（次のセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">特定のコミットを参照するためのタグを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">&lt;code&gt;cat-file&lt;/code&gt; コマンドを使用して、この特定のオブジェクトについてGitに問い合わせることができます。この例の40桁の16進数はコピーせず、独自のバージョンのものを使用してください。40桁の16進数をすべて入力する手間を省くために、数文字だけに短縮できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">追跡されていないファイルのスキャンに費やした時間をさらに調査することができます。</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">標準ユーティリティのcutとgrep を使用して、ブランチヘッド名だけを取得し、 &lt;code&gt;master&lt;/code&gt; を削除できます。</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">以下のコマンドで取得できます。</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">この名前を &lt;code&gt;git show&lt;/code&gt; に付けて、このコミットの詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">このリポジトリのすべてのヘッドを&lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]で&lt;/a&gt;一覧表示できます。</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Gitを高レベル(「磁器」)のコマンドと低レベル(「配管」)のコマンドに分けています。</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">では、その方法を説明します。</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">簡単に参照できるように一連の &lt;code&gt;rules&lt;/code&gt; を作成しますが、散文はそれぞれのルールを動機づけようとします。常に文字どおりに受け取らないでください。このようなマンページよりもアクションの正当な理由を高く評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">私たちは、グラフ上のほとんどのコミットがテスト時にかなり多くの情報を提供することを発見しました。そして、平均して多くの情報を提供しないコミットは、良いコミットと悪いコミットの近くにあるコミットです。</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">我々はすでに見てきた&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;これまでのリモート追跡の枝を維持するためにどのよう&lt;/a&gt;に&lt;a href=&quot;git-fetch&quot;&gt;gitのフェッチ[1] &lt;/a&gt;、およびどのように二つのブランチをマージします。したがって、元のリポジトリのマスターブランチからの変更を次のようにマージできます。</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">2つのブランチを使用する &quot;fun and work&quot;の例を使用して、ブランチが以前にどのように機能するかについてはすでに見てきました。ブランチが3つ以上ある場合も同じです。「マスター」の頭から始めて、「マスター」ブランチにいくつかの新しいコードがあり、「コミットコミット」および「差分フィックス」ブランチに2つの独立した修正があるとします。</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">コミットの命名方法はすでにいくつか見てきました。</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">リグレッションが重要な問題であること、そして &quot;git bisect&quot; には、リグレッションと戦うために一般的に使われているプラクティスや他のツール、特にテストスイートを非常によく補完する機能があることを見てきました。しかし、それを最大限に活用するためには、ワークフローや (悪い)習慣を変える必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">テストスイートとgit bisectは併用すると非常に強力であることがわかりました。他のシステムと組み合わせることができれば、さらに強力になります。</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">svn：executableを除くすべてのSVNプロパティを無視します。未処理のプロパティはすべて$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.logに記録されます</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">このチュートリアルでは、水を流していない磁器に対処するために配管が何をするかを説明しましたが、これまでのところ、マージが実際にどのように機能するかについては触れていません。このチュートリアルを初めて実行する場合は、「作品の公開」セクションにスキップして、後でここに戻ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">上記で見たように、 &lt;code&gt;origin&lt;/code&gt; は元のクローン元のリポジトリを参照するためのショートカットにすぎません。この情報はGit構成変数に格納され、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">先ほど、&quot;git bisect skip&quot; が PRNG を使ってコミットグラフの中でテスト不可能な領域を避けようとしていることを見ました。問題は、最初の悪いコミットがテスト不可能な領域にあることがあるということです。</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">私たちは、で見た&lt;a href=&quot;#conflict-resolution&quot;&gt;マージ中に競合解決ヘルプの&lt;/a&gt;マージ中にインデックスが（「ステージ」と呼ばれる）単一のファイルの複数のバージョンを保存することが可能となります。上記の&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]の&lt;/a&gt;出力の3番目の列はステージ番号であり、マージの競合があるファイルに対して0以外の値をとります。</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">を使用して最新のコミットを置き換えることができるという&lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;履歴&lt;/a&gt;を書き換えることによる間違いの修正で見た</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">チュートリアルの一部で、コミットに次のような名前が付いているのを見ました。 Git履歴のすべてのオブジェクトは、40桁の16進数の名前で保存されていることがわかります。その名前は、オブジェクトのコンテンツのSHA-1ハッシュです。特に、これにより、Gitが同じデータを2回保存することはなく（同じデータには同じSHA-1名が付けられるため）、Gitオブジェクトの内容は決して変更されません（オブジェクトの名前も変更されるため） ）。ここでの7文字の16進文字列は、このような40文字の長い文字列の省略形です。省略形は、40文字の文字列が使用できる場所であればどこでも使用できますが、あいまいでない場合に限ります。</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">磁器のコマンドをメインコマンドと補助的なユーザーユーティリティに分けています。</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">統合ブランチを「習慣的に」（通常は本当の理由ではありませんが）トピックにマージすること、そしてさらに言えば、定期的に上流にあるものを下流にあるものにマージすることは不快であることを指摘する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">まずは、プロジェクトにバグを導入したコミットを見つけるのに便利な専用ツールから始めます。</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">最も重要な&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベース&lt;/a&gt;と&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;から始めます。</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">これまでの例では、「良い」コミットは「悪い」コミットの先祖であると考えていました。しかし、これは &quot;git bisect&quot; の要件ではありません。</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">ブランチ &lt;code&gt;master&lt;/code&gt; から分岐した &lt;code&gt;topic&lt;/code&gt; を作成します。たとえば、 &lt;code&gt;topic&lt;/code&gt; 依存する機能がより安定した &lt;code&gt;master&lt;/code&gt; ブランチにマージされたためです。ツリーを次のようにしたいとします。</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">その際に役立つツールをいくつか紹介し、その使い方を説明した上で、歴史を書き換えているからこそ起こりうる問題点を解説していきます。</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">Git の履歴を、以下のような図を使って表現することがあります。コミットを「o」で表し、その間のリンクを「/」と「\」で線で表しています。時間は左から右に進みます。</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">問題は、単一の欠落または破損したBLOBであると想定します。これは、解決可能な問題になる場合があります。（欠落しているツリー、特にコミットの回復は&lt;strong&gt;はるかに&lt;/strong&gt;困難です）。</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">私たちはこれをシンプルで愚かなままにしておくので、まずはそれを感じるためにいくつかの簡単なファイルを作成することから始めます。</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">ウェブサーバの設定</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">複数のプロジェクトのルートを持つWebサーバの設定</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">各フォーマットのエイリアスファイルがどのように見えるかは、同名のメールプログラムのドキュメントを参照してください。標準フォーマットとの違いや制限事項を以下に説明します。</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git がコミットに反応した 7 桁の 16 進数は?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">これは何を意味するのか?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">また、興味深いのは、バグを報告しているエンドユーザー(またはバグを再現したQAの人たち)は、バグが発生した環境にアクセスできるということです。そのため、彼らはより簡単にリグレッションを再現することができます。また、二分することができれば、バグが発生している環境からより多くの情報が抽出され、バグを理解して修正することが容易になります。</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">次は何をするの?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">人々が得ていないのは、これが「エンドノードの原則」が適用される状況であるということです。リソースが限られている場合（ここでは開発者）、負担の大部分をプッシュすることはありません。代わりに、多くのリソースであるエンドノード（ここではユーザー）に物事をプッシュして、状況を実際に拡大できるようにします。</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">間違ったコミットをタグ付けしてしまい、再タグ付けしたい場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">p オプションが生成するものは、従来の diff 形式とは少し異なります。</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">プッシュが失敗したときの対処法</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">選択した内容は、次のように &lt;code&gt;*&lt;/code&gt; で強調表示されます。</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">&amp;lt;rev&amp;gt;が指定されていない場合、コマンドは作業ツリーのコピーから逆方向に始まる変更に注釈を付けます。このフラグは、作業ツリーのコピーに指定されたファイルの内容があるかのようにコマンドを偽装させます（ &lt;code&gt;-&lt;/code&gt; を指定すると、コマンドは標準入力から読み取られます）。</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">--fork-pointがアクティブな場合、リベースするコミットのセットを計算するために、&amp;lt;upstream&amp;gt;の代わりに &lt;code&gt;fork_point&lt;/code&gt; が使用されます &lt;code&gt;fork_point&lt;/code&gt; は &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; コマンドの結果です（&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]を&lt;/a&gt;参照してください）。もし &lt;code&gt;fork_point&lt;/code&gt; 空になってしまう、&amp;lt;上流&amp;gt;フォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">--graphを使用しない場合、すべての履歴ブランチがフラット化されるため、2つの連続したコミットが線形ブランチに属していないことがわかりにくくなる可能性があります。その場合、このオプションはそれらの間に障壁を置きます。 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; が指定されている場合、デフォルトの代わりに表示される文字列です。</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">stdout が指定された場合、オブジェクトカウントと圧縮フェーズでは進捗状況のレポートが表示されますが、書き込みフェーズでは表示されません。これは、出力ストリームが別のコマンドに直接リンクされている場合があり、そのコマンドが入力されたパックデータを処理している間は、そのコマンド自身の進捗状況を表示したい場合があるためです。このフラグは--progressと同様で、--stdoutが使用されている場合でも、書出しフェーズでも進行状況の報告を強制することを除いては--progressと同じです。</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">-kが有効でない場合、 &lt;code&gt;[&lt;/code&gt; と &lt;code&gt;]&lt;/code&gt; のペアで囲まれたすべての先行文字列が削除されます。このオプションは、括弧で囲まれた文字列に「PATCH」という単語が含まれるペアのみにストリッピングを制限します。</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">ときに &lt;code&gt;&quot;$@&quot;&lt;/code&gt; で &lt;code&gt;-h&lt;/code&gt; または &lt;code&gt;--help&lt;/code&gt; 上記の例では、以下の使用テキストが表示されます：</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">とき &lt;code&gt;--batch-all-objects&lt;/code&gt; 使用されている、訪問はハッシュ順序よりもオブジェクトの内容にアクセスするためのより効率的かもしれために、オブジェクト。順序の正確な詳細は指定されていませんが、特定の順序を必要としない場合は、特に &lt;code&gt;--batch&lt;/code&gt; を使用すると、一般的に出力が速くなります。 &lt;code&gt;cat-file&lt;/code&gt; は、リポジトリに複数回保存されている場合でも、各オブジェクトを1回だけ表示することに注意してください。</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">とき &lt;code&gt;--check&lt;/code&gt; が有効になっている、または（オプションのいずれも無効、それが有効でないことをするときのデフォルトです）パッチを適用する際に、必ずパッチはどのような現在のインデックスファイル・レコードに適用されます。作業ツリーでパッチを適用するファイルが最新でない場合、エラーとしてフラグが立てられます。このフラグにより​​、インデックスファイルも更新されます。</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">とき &lt;code&gt;--compose&lt;/code&gt; が使用され、gitのセンドメールから、件名、およびIn-返信先のメッセージで指定されたヘッダーを使用します。メッセージの本文（ヘッダーと空白行の後に入力したもの）に空白（またはGit：接頭辞付き）の行のみが含まれている場合、要約は送信されませんが、From、Subject、およびIn-Reply-Toヘッダーは送信されます削除しない限り、使用してください。</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">場合 &lt;code&gt;--exclude&lt;/code&gt; と &lt;code&gt;--include&lt;/code&gt; パターンが使用され、それらは、コマンドライン上に表示され、各パスのパッチが使用される場合、最初の一致が判断するために検査されます。include / excludeパターンに一致しないパスへのパッチは、コマンドラインにincludeパターンがない場合はデフォルトで使用され、includeパターンがある場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">&lt;code&gt;--notes&lt;/code&gt; が有効な場合、ノートからのメッセージは、ログメッセージの一部であるかのように照合されます。</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">&lt;code&gt;--numstat&lt;/code&gt; が指定されている場合、パス名を変更せず、NULで終了する機械可読形式を使用します。</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">とき &lt;code&gt;--raw&lt;/code&gt; 、 &lt;code&gt;--numstat&lt;/code&gt; 、 &lt;code&gt;--name-only&lt;/code&gt; または &lt;code&gt;--name-status&lt;/code&gt; 与えられている、出力フィールドターミネータとしてのmungeないパス名と使用NULsを行います。</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">とき &lt;code&gt;--root&lt;/code&gt; が指定された初期には、コミットビッグ作成イベントとして表示されます。これは、NULLツリーに対する差分と同等です。</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">とき &lt;code&gt;--stdin&lt;/code&gt; を指定され、コマンドは、コマンドラインから&amp;lt;木っぽい&amp;gt;引数を取りません。代わりに、2つの&amp;lt;tree&amp;gt;、1つの&amp;lt;commit&amp;gt;、または&amp;lt;commit&amp;gt;のリストを含む行を標準入力から読み取ります。（区切り文字として単一のスペースを使用します。）</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">&lt;code&gt;--temp&lt;/code&gt; が使用されている場合（または &lt;code&gt;--stage=all&lt;/code&gt; で暗黙指定されている場合）、 &lt;code&gt;git checkout-index&lt;/code&gt; は、チェックアウトされる各インデックスエントリに対して一時ファイルを作成します。インデックスは統計情報で更新されません。これらのオプションは、マージされていないファイルを外部のマージツールで処理できるように、呼び出し元がすべてのマージされていないエントリのすべてのステージを必要とする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">とき &lt;code&gt;-S&lt;/code&gt; または &lt;code&gt;-G&lt;/code&gt; をせずに使用されている &lt;code&gt;--pickaxe-all&lt;/code&gt; 、それぞれの基準に一致のみfilepairsは出力に保存されています。とき &lt;code&gt;--pickaxe-all&lt;/code&gt; 使用されていても1 filepairがチェンジで、それぞれの基準に一致した場合、全体のチェンジが保たれています。この動作は、変更セット全体のコンテキストで変更を簡単に確認できるように設計されています。</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">とき &lt;code&gt;-S&lt;/code&gt; または &lt;code&gt;-G&lt;/code&gt; が変更を見つけ、そのチェンジ内のすべての変更、&amp;lt;文字列&amp;gt;の変化が含まれていないファイルだけを表示します。</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">ときに &lt;code&gt;-u&lt;/code&gt; オプションが使用されていない、人跡未踏のファイルとディレクトリが（指定するのと同じつまり、表示され &lt;code&gt;normal&lt;/code&gt; 、あなたが新たに作成されたファイルを追加し忘れ避けるために、）。ファイルシステムで追跡されていないファイルを見つけるには余分な作業が必要なため、このモードでは、大きな作業ツリーでは時間がかかる場合があります。サポートされている場合人跡未踏のキャッシュとスプリット指標を有効にすることを検討（見ない &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; と &lt;code&gt;git update-index --split-index&lt;/code&gt; それ以外の場合は、使用することができ、） &lt;code&gt;no&lt;/code&gt; 持っている &lt;code&gt;git status&lt;/code&gt; 人跡未踏のファイルを表示せずに、より迅速にリターンを。</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">とき &lt;code&gt;-z&lt;/code&gt; 出力オプションが有効である、出力はこのようにフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">とき &lt;code&gt;FETCH_HEAD&lt;/code&gt; （および他のコミットしない）が指定され、中に記録された枝 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; の以前の呼び出しによって、ファイル &lt;code&gt;git fetch&lt;/code&gt; 現在のブランチにマージされているマージします。</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">場合 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 又は &lt;code&gt;receive.fsckObjects&lt;/code&gt; が設定されていない、この変数の値が代わりに使用されます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">場合 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 又は &lt;code&gt;receive.unpackLimit&lt;/code&gt; が設定されていない、この変数の値が代わりに使用されます。デフォルト値は100です。</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">とき &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 設定され、エラーがその逆の設定によって警告とバイスに切り替えることができ &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 設定する場合 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; のfsckメッセージIDであり、値の一つである &lt;code&gt;error&lt;/code&gt; 、 &lt;code&gt;warn&lt;/code&gt; または &lt;code&gt;ignore&lt;/code&gt; ます。便宜上、fsckはエラー/警告の前にメッセージIDを付けます。たとえば、「missingEmail：無効な作成者/コミッターの行-メールの欠落」は、 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; を設定するとその問題が非表示になることを意味します。</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">ときに &lt;code&gt;git apply&lt;/code&gt; 、「より良いGNUパッチ」として使用され、ユーザーが渡すことができ &lt;code&gt;--unsafe-paths&lt;/code&gt; この安全チェックを無効にするオプションを選択します。 &lt;code&gt;--index&lt;/code&gt; または &lt;code&gt;--cached&lt;/code&gt; が使用されている場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;git difftool&lt;/code&gt; 、このツール（のいずれかを通じてで呼び出され &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;--tool&lt;/code&gt; オプションまたは &lt;code&gt;diff.tool&lt;/code&gt; の設定変数）設定され、コマンドラインは、使用可能な以下の変数を使用して呼び出されます： &lt;code&gt;$LOCAL&lt;/code&gt; 、一時の名前に設定されています差分プリイメージのコンテンツを含むファイルと &lt;code&gt;$REMOTE&lt;/code&gt; は、差分ポストイメージのコンテンツを含む一時ファイルの名前に設定されます。 &lt;code&gt;$MERGED&lt;/code&gt; は、比較されているファイルの名前です。 &lt;code&gt;$BASE&lt;/code&gt; はカスタムマージツールコマンドとの互換性のために提供されており、 &lt;code&gt;$MERGED&lt;/code&gt; と同じ値を持っています。</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">コマンドラインでフェッチする明示的なブランチやタグを使用して &lt;code&gt;git fetch&lt;/code&gt; を実行する場合（例： &lt;code&gt;git fetch origin master&lt;/code&gt; ）、コマンドラインで指定された&amp;lt;refspec&amp;gt;は何をフェッチするかを決定します（例では &lt;code&gt;master&lt;/code&gt; ）。 &lt;code&gt;master:&lt;/code&gt; の省略形です。つまり、「 &lt;code&gt;master&lt;/code&gt; ブランチをフェッチしますが、コマンドラインから更新するリモートトラッキングブランチを明示的に指定することはありません」）。例のコマンドは、 &lt;code&gt;master&lt;/code&gt; ブランチ &lt;code&gt;only&lt;/code&gt; をフェッチします。 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 、更新された場合の値は、どのリモート追跡ブランチを決定します。このように使用すると、 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 値は、 &lt;code&gt;what&lt;/code&gt; をフェッチするかの決定に影響を与えません（つまり、コマンドラインがrefspecをリストするとき、値はrefspecとして使用されません）。これらは、マッピングとして機能することにより、フェッチされた参照が格納される &lt;code&gt;where&lt;/code&gt; を決定するためにのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">ときに &lt;code&gt;git fetch&lt;/code&gt; 例えば、支店および/またはタグは、コマンドラインでフェッチするかを指定せずに実行された &lt;code&gt;git fetch origin&lt;/code&gt; または &lt;code&gt;git fetch&lt;/code&gt; 、 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 値はrefspecs-として使用されている彼らは、レフリーがフェッチするかを指定し、更新するローカル参照。上記の例は、 &lt;code&gt;origin&lt;/code&gt; 存在するすべてのブランチ（つまり、値の左側に一致するすべてのref、 &lt;code&gt;refs/heads/*&lt;/code&gt; ）をフェッチし、 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; の対応するリモート追跡ブランチを更新します階層。</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">ときに &lt;code&gt;git fetch&lt;/code&gt; で使用される &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspecそれはで説明したようにローカルブランチを更新するために拒否することができる &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 下記の一部。このオプションはそのチェックを上書きします。</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">場合 &lt;code&gt;git fetch&lt;/code&gt; で使用され &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspecそれはで説明したようにローカルブランチを更新することを拒否することができる &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; の一部&lt;a href=&quot;git-fetch&quot;&gt;のgitフェッチ[1]&lt;/a&gt;ドキュメント。このオプションはそのチェックを上書きします。</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">とき &lt;code&gt;git gc&lt;/code&gt; 実行され、それが呼び出されます &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 。この構成変数を使用して、別の猶予期間を設定できます。値「now」を使用して猶予期間を無効にし、 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; すぐにプルーニングするか、「never」を使用してプルーニングを抑制できます。</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">とき &lt;code&gt;git gc&lt;/code&gt; 実行され、それが呼び出されます &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; 。この構成変数で猶予期間をオーバーライドします。値「now」を使用して、この猶予期間を無効にし、常に到達不能なオブジェクトをすぐにプルーニングするか、「never」を使用してプルーニングを抑制できます。この機能は、 &lt;code&gt;git gc&lt;/code&gt; がリポジトリに書き込む別のプロセスと同時に実行される場合の破損を防ぐのに役立ちます。&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;の「NOTES」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">とき &lt;code&gt;git mergetool&lt;/code&gt; 、このツールで（いずれかを介して起動される &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;--tool&lt;/code&gt; オプションまたは &lt;code&gt;merge.tool&lt;/code&gt; の設定変数）に構成コマンドラインがで呼び出されます &lt;code&gt;$BASE&lt;/code&gt; ための共通基盤を含む一時ファイルの名前に設定可能な場合はマージ。 &lt;code&gt;$LOCAL&lt;/code&gt; は、現在のブランチ上のファイルの内容を含む一時ファイルの名前に設定されます。 &lt;code&gt;$REMOTE&lt;/code&gt; は、マージされるファイルの内容を含む一時ファイルの名前に設定され、 &lt;code&gt;$MERGED&lt;/code&gt; は、マージツールがマージ解決の結果を書き込むファイルの名前に設定されます。</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">とき &lt;code&gt;git-difftool&lt;/code&gt; で呼び出される &lt;code&gt;-g&lt;/code&gt; または &lt;code&gt;--gui&lt;/code&gt; オプションデフォルトの差分ツールは、設定から読み込まれます &lt;code&gt;diff.guitool&lt;/code&gt; の変数の代わりに、 &lt;code&gt;diff.tool&lt;/code&gt; 。 &lt;code&gt;--no-gui&lt;/code&gt; のオプションは、この設定を上書きするために使用することができます。場合 &lt;code&gt;diff.guitool&lt;/code&gt; が設定されていない場合、我々は、の順にフォールバックします &lt;code&gt;merge.guitool&lt;/code&gt; 、 &lt;code&gt;diff.tool&lt;/code&gt; 、 &lt;code&gt;merge.tool&lt;/code&gt; ツールが見つかるまで。</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;git-mergetool&lt;/code&gt; で呼び出される &lt;code&gt;-g&lt;/code&gt; または &lt;code&gt;--gui&lt;/code&gt; オプションデフォルトマージツールは、設定から読み込まれます &lt;code&gt;merge.guitool&lt;/code&gt; の代わりに変数 &lt;code&gt;merge.tool&lt;/code&gt; 。場合 &lt;code&gt;merge.guitool&lt;/code&gt; が設定されていない場合、我々は下に構成ツールにフォールバックします &lt;code&gt;merge.tool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）すると、リポジトリはグループ内の複数のユーザー間で共有可能になります（すべてのファイルとオブジェクトがグループ書き込み可能であることを確認してください）。場合は &lt;code&gt;all&lt;/code&gt; （または &lt;code&gt;world&lt;/code&gt; または &lt;code&gt;everybody&lt;/code&gt; ）、リポジトリはさらに、グループ共有可能であることに、すべてのユーザーが読み取り可能になります。とき &lt;code&gt;umask&lt;/code&gt; （または &lt;code&gt;false&lt;/code&gt; ）、Gitはアクセス許可を使用しますのumask（2）により報告されました。とき &lt;code&gt;0xxx&lt;/code&gt; 、どこ &lt;code&gt;0xxx&lt;/code&gt; 進数である、リポジトリ内のファイルは、このモード値を持つことになります。 &lt;code&gt;0xxx&lt;/code&gt; はユーザーのumask値をオーバーライドします（他のオプションはユーザーのumask値の要求された部分のみをオーバーライドします）。例： &lt;code&gt;0660&lt;/code&gt; 所有者とグループのリポジトリを読み取り/書き込み可能にしますが、他のユーザーはアクセスできません（umaskが &lt;code&gt;0022&lt;/code&gt; でない限り、 &lt;code&gt;group&lt;/code&gt; と同じです）。 &lt;code&gt;0640&lt;/code&gt; は、グループは読み取り可能ですが、グループが書き込み可能ではないリポジトリーです。&lt;a href=&quot;git-init&quot;&gt;git-init [1]を&lt;/a&gt;参照してください。デフォルトではfalse。</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">&lt;code&gt;interactive&lt;/code&gt; 場合、リベースのインタラクティブモードを有効にします。</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; が &lt;code&gt;man.viewer&lt;/code&gt; 構成変数で指定されている場合、kfmclientを起動して、 &lt;code&gt;kfmclient&lt;/code&gt; 、すでに開いているkonquerorのmanページを新しいタブで開こうとします。</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">とき &lt;code&gt;matching&lt;/code&gt; モードが指定され、明示的に無視されたパターンと一致する経路が示されています。ディレクトリが無視パターンに一致する場合、それは表示されますが、無視されたディレクトリに含まれるパスは表示されません。ディレクトリが無視パターンに一致しないが、すべてのコンテンツが無視される場合、ディレクトリは表示されませんが、すべてのコンテンツが表示されます。</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;merges&lt;/code&gt; するときは、 &lt;code&gt;--rebase-merges&lt;/code&gt; オプションを &lt;code&gt;git rebase&lt;/code&gt; に渡して、ローカルマージコミットがリベースに含まれるようにします（詳細は&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; する場合（ &lt;code&gt;merges&lt;/code&gt; ために非推奨）、ローカルでコミットされたマージコミットが &lt;code&gt;git pull&lt;/code&gt; を実行してもフラット化されないように、 &lt;code&gt;git rebase&lt;/code&gt; に &lt;code&gt;--preserve-merges&lt;/code&gt; も渡します。</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">とき &lt;code&gt;preserveUser&lt;/code&gt; が真である、 &lt;code&gt;git p4&lt;/code&gt; 、それはP4のユーザマップで著者を見つけることができない場合は正常に死にます。この設定は関係なく変更を送信します。</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">ときに &lt;code&gt;receive-pack&lt;/code&gt; オブジェクトに取り、彼らは内の一時的な「隔離」ディレクトリに配置されている &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; ディレクトリをし、後にのみ、メインオブジェクトストアに移行 &lt;code&gt;pre-receive&lt;/code&gt; フックが完了しました。それ以前にプッシュが失敗した場合、一時ディレクトリは完全に削除されます。</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; が「auto」に設定されている場合、パスは自動行末変換用にマークされます。コンテンツがテキストであるとGitが判断した場合、その行末はチェックイン時にLFに変換されます。ファイルがCRLFでコミットされている場合、変換は行われません。</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">場合は &lt;code&gt;text=auto&lt;/code&gt; 変換が中央リポジトリにのCRLFを含むテキストファイルをプッシュプルを使用したクロスプラットフォームのプロジェクトで有効になっている正規化されなければなりません。</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">&lt;code&gt;upload-pack&lt;/code&gt; が &lt;code&gt;pack-objects&lt;/code&gt; を開始したとき、 &lt;code&gt;pack-objects&lt;/code&gt; がパックを準備している間、静かな期間がある場合があります。通常、これは進行状況情報を出力しますが、フェッチに &lt;code&gt;--quiet&lt;/code&gt; が使用された場合、 &lt;code&gt;pack-objects&lt;/code&gt; はパックデータが始まるまで何も出力しません。一部のクライアントとネットワークは、サーバーがハングしてあきらめたと見なす場合があります。このオプションを指示する設定 &lt;code&gt;upload-pack&lt;/code&gt; 空のキープアライブパケットごとに送信するための &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 秒。このオプションを0に設定すると、キープアライブパケットが完全に無効になります。デフォルトは5秒です。</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">&lt;code&gt;uploadpack.hideRefs&lt;/code&gt; が有効な場合、非表示の参照の先端にあるオブジェクトを要求するフェッチ要求を受け入れるように、 &lt;code&gt;upload-pack&lt;/code&gt; に許可します（デフォルトでは、そのような要求は拒否されます）。 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; も参照してください。これが偽の場合でも、クライアントは&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]の&lt;/a&gt; manページの「セキュリティ」セクションで説明されている手法を使用してオブジェクトを盗むことができる場合があります。プライベートデータは別のリポジトリに保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Gitが特定のトランスポートプロトコルを処理する方法を知らない場合、リモート- &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; リモートヘルパー（存在する場合）を使用しようとします。リモートヘルパーを明示的に要求するには、次の構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">Gitが &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; という形式のURLを検出すると、 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; はネイティブで処理できないプロトコルであり、2番目の引数として完全なURLを指定して &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; を自動的に呼び出します。そのようなURLがコマンドラインで直接検出される場合、最初の引数は2番目の引数と同じです。構成されたリモートで検出される場合、最初の引数はそのリモートの名前です。</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Gitは、クリーン化やスマッジが必要な最初のファイルに遭遇すると、フィルターを起動してハンドシェイクを実行します。ハンドシェイクでは、Gitから送られてくるウェルカムメッセージは「git-filter-client」、サポートされているのはバージョン2のみ、サポートされている機能は「clean」「smudge」「delay」です。</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Gitが特定のURLコンテキストの認証を必要とする場合、credential-storeは、そのコンテキストを、信任状ファイルの各エントリーと照合するパターンと見なします。プロトコル、ホスト名、ユーザー名（既にある場合）が一致すると、パスワードがGitに返されます。詳細については、&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]の&lt;/a&gt;構成の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Gitは、 &lt;code&gt;diff&lt;/code&gt; 属性が &lt;code&gt;jcdiff&lt;/code&gt; に設定されたパスの差分を表示する必要がある場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; プログラムが呼び出されるのと同じように、上記の構成で指定したコマンド、つまり &lt;code&gt;j-c-diff&lt;/code&gt; を7つのパラメーターで呼び出します。詳細は&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git push --signed&lt;/code&gt; が、この数秒以内に同じリポジトリを提供する受信パックによって発行された「nonce」を含むプッシュ証明書を送信したとき、証明書にある「nonce」をフックに（代わりに） &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; にエクスポートします受信パックが送信側に含めるように要求したもの）。これは、中に小切手を書くことを可能にする &lt;code&gt;pre-receive&lt;/code&gt; と &lt;code&gt;post-receive&lt;/code&gt; 少し簡単。ナンスが古くなっている秒数を記録する &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 環境変数をチェックする代わりに、証明書を受け入れるかどうかを決定する代わりに、 &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; が &lt;code&gt;OK&lt;/code&gt; かどうかのみをチェックできます。</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">コマンドが終了し、クライアントがサーバーからの応答全体を受け取ったとき、クライアントは別のコマンドの実行を 要求するか、接続を終了するかのいずれかを行うことができる。クライアントはオプションで、これ以上のリクエストが行われないことを示すために flush-pkt だけで構成される空のリクエストを送ることができます。</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">この状態でコミットが作成されると、新しいコミットを参照するようにブランチが更新されます。具体的には、 &lt;code&gt;git commit&lt;/code&gt; 新しいを作成し、コミット &lt;code&gt;d&lt;/code&gt; その親コミットされ、 &lt;code&gt;c&lt;/code&gt; 、そしてブランチ更新 &lt;code&gt;master&lt;/code&gt; 新しいコミットを参照するために &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;HEAD&lt;/code&gt; はまだブランチ &lt;code&gt;master&lt;/code&gt; を指しているため、間接的にcommit &lt;code&gt;d&lt;/code&gt; を指します。</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">curlトレースが有効な場合（上記の &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; を参照）、データをダンプしないでください（つまり、情報行とヘッダーのみをダンプします）。</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">フェッチミラーが &lt;code&gt;--mirror=fetch&lt;/code&gt; で作成されると、 &lt;code&gt;refs/remotes/&lt;/code&gt; はrefs / remotes /名前空間に保存されませんが、リモートの &lt;code&gt;refs/&lt;/code&gt; 内のすべてがローカルリポジトリの &lt;code&gt;refs/&lt;/code&gt; に直接ミラーリングされます。フェッチはローカルコミットを上書きするため、このオプションはベアリポジトリでのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">git プロセスが他の git プロセスの (直接的または間接的な)子プロセスである場合、Trace2 のコンテキスト情報を継承します。これにより、子プロセスはコマンド階層を表示することができます。この例では、gc を fetch の child[3]としています。gc プロセスが自分の名前を &quot;gc&quot; と報告すると、階層も &quot;fetch/gc&quot; と報告します。(この例では、わかりやすくするために、子プロセスからのtrace2メッセージをインデントしています)。</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">ローカルブランチがリモートトラッキングブランチから開始されると、Gitはブランチ（特に、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; および &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 構成エントリ）をセットアップして、 &lt;code&gt;git pull&lt;/code&gt; がリモートブランチから適切にマージされるようにします追跡ブランチ。この動作は、グローバル &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 構成フラグを介して変更できます。その設定は、使用して無効にすることができ &lt;code&gt;--track&lt;/code&gt; と &lt;code&gt;--no-track&lt;/code&gt; のオプションを、そして使用して後で変更 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; オプションを使用してブランチを切り替えるときにマージの競合が発生すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">マージの競合が発生すると、競合するパスのインデックスエントリはマージされないままになるため、競合を解決し、解決されたパスを &lt;code&gt;git add&lt;/code&gt; （またはマージによってパスが削除される場合は &lt;code&gt;git rm&lt;/code&gt; )でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">マージが自動的に解決されない場合、Gitはインデックスと作業ツリーを特別な状態のままにして、マージの解決に必要なすべての情報を提供します。</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">別のブランチを追跡する &lt;code&gt;git branch&lt;/code&gt; 、 &lt;code&gt;git switch&lt;/code&gt; または &lt;code&gt;git checkout&lt;/code&gt; を使用して新しいブランチが作成されると、この変数は、マージではなくリベースするプルを設定するようにGitに指示します（「branch。&amp;lt;name&amp;gt; .rebase」を参照）。 &lt;code&gt;never&lt;/code&gt; の場合、リベースが自動的にtrueに設定されることはありません。 &lt;code&gt;local&lt;/code&gt; の場合、他のローカルブランチの追跡されたブランチに対してrebaseがtrueに設定されます。 &lt;code&gt;remote&lt;/code&gt; の場合、リモート追跡ブランチの追跡ブランチに対してrebaseがtrueに設定されます。ときは &lt;code&gt;always&lt;/code&gt; 、リベースは、すべての追跡ブランチをtrueに設定されます。別のブランチを追跡するようにブランチを設定する方法の詳細については、「branch.autoSetupMerge」を参照してください。このオプションのデフォルトは決してありません。</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">パッチ障害が発生すると、終了する前に&amp;lt;msg&amp;gt;が画面に出力されます。これにより、 &lt;code&gt;--continue&lt;/code&gt; または &lt;code&gt;--skip&lt;/code&gt; を使用して失敗を処理するように通知する標準メッセージが上書きされます。これは &lt;code&gt;git rebase&lt;/code&gt; と &lt;code&gt;git am&lt;/code&gt; の間の内部使用のみを目的としています。</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">パッチが進行中のディスカッションの一部である場合、 &lt;code&gt;git format-patch&lt;/code&gt; によって生成されたパッチを調整して、 &lt;code&gt;git am --scissors&lt;/code&gt; 機能を利用できます。ディスカッションに対する応答の後に、「 &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; 」（はさみとミシン目）のみで構成される行が続き、不要なヘッダーフィールドが削除されたパッチが続きます。</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">パスが「マージされていない」状態にある場合、そのパスに対して &lt;code&gt;git update-index&lt;/code&gt; を実行すると、Gitはパスを解決済みとしてマークするように指示されます。</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">純粋なモード変更(インデックス情報を持たない)に遭遇した場合、代わりに現在のインデックスから情報が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">&lt;code&gt;--mirror=push&lt;/code&gt; を使用してプッシュミラーを作成すると、 &lt;code&gt;git push&lt;/code&gt; は常に &lt;code&gt;--mirror&lt;/code&gt; が渡されたかのように動作します。</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">リベースでマージの競合を解決する必要があった場合、リベースで導入された変更を直接比較するには、次のように使用します。</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">refが更新されると、reflogエントリが作成され、refの古い値と新しい値に加えて、refが更新された理由（通常は、refを更新した高レベルコマンドの名前）を追跡します。 。スクリプト化されたPorcelainコマンドは、 &lt;code&gt;git-sh-setup&lt;/code&gt; の set_reflog_actionヘルパー関数を使用して、エンドユーザーがトップレベルコマンドとして呼び出されたときにその名前をこの変数に設定し、reflogの本文に記録できます。</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">リポジトリが &lt;code&gt;git push&lt;/code&gt; および &lt;code&gt;git pull&lt;/code&gt; を介して同期されると、ソースリポジトリにパックされたオブジェクトは通常、解凍されて宛先に格納されます。これにより、両端で異なるパッキング戦略を使用できますが、両方のリポジトリをたまに再パックする必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">スクリプト言語固有のクォートが有効な場合、トップレベルのオープニング・アトムとそれにマッチする %(end)の間のすべてがオープニング・アトムのセマンティクスに従って評価され、トップレベルからの結果のみがクォートされます。</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">変数がブール値を取ると言われるとき、多くの同義語は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; で受け入れられます。これらはすべて大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">ベンダーブランチの新しいコードドロップを受け入れる際には、既存のパスの変更だけでなく、パスの削除と新しいパスの追加の両方を記録したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">署名付きプッシュを受け入れるとき（&lt;a href=&quot;git-push&quot;&gt;git-push [1]を&lt;/a&gt;参照）、署名付きプッシュ証明書はblobに保存され、オブジェクト名について環境変数 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; を調べることができます。例については、 &lt;code&gt;post-receive&lt;/code&gt; フックの説明を参照してください。さらに、証明書はGPGを使用して検証され、結果は次の環境変数とともにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">資格情報を取得するときは、httpまたはhttpsのURLの「パス」コンポーネントが重要であると考えてください。デフォルトはfalseです。詳細については、&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">すでにノートがあるオブジェクトにノートを追加する場合は、既存のノートを上書きします(アボートするのではなく)。</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">利用可能な履歴のヒントを代替からアドバタイズする場合は、&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]の&lt;/a&gt;代わりにシェルを使用して、指定されたコマンドを実行します。最初の引数は、代替の絶対パスです。出力には、1行に1つの16進オブジェクトIDが含まれている必要があります（つまり、 &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; によって生成されるものと同じです）。</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">引数がリビジョンまたはパスのどちらかと誤解される可能性がある場合は、それらの間に &lt;code&gt;--&lt;/code&gt; を配置することにより、曖昧さをなくすことができます。例： &lt;code&gt;git diff -- HEAD&lt;/code&gt; は、「ワークツリーにHEADというファイルがあります。インデックスでステージングしたバージョンとそのファイルのワークツリーにあるものの違いを表示してください」ではなく、「 HEADコミットとワークツリー全体」 &lt;code&gt;git diff HEAD --&lt;/code&gt; 後者を要求するように言うことができます。</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">引数が参照またはファイル名として理解される可能性がある場合は、それをフォーマットパッチ引数（ &lt;code&gt;--format-patch&lt;/code&gt; ）またはファイル名（ &lt;code&gt;--no-format-patch&lt;/code&gt; ）として理解することを選択します。デフォルトでは、このような競合が発生すると、git send-emailは失敗します。</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">対話型コマンド（ &lt;code&gt;git add --patch&lt;/code&gt; など）がカラー化された差分を表示する場合、gitはこの構成変数で定義されたシェルコマンドを介して差分をパイプします。コマンドは、元の差分の行との1対1の対応を保持している場合に限り、人間が使用できるように差分をさらにマークアップできます。デフォルトは無効（フィルタリングなし）です。</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">オプションの Git ブランチ名 (あるいは Git コミットオブジェクト名)を引数に指定すると、このサブコマンドは現在のブランチではなく指定したブランチで動作します。</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">コミット A を指していたブランチ (あるいは一般的には ref)を別のコミット B を指すように更新する場合、B が A の子孫である場合に限り、早送り更新と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">パッチを適用するときに、空白エラーのある新しい行または変更された行を検出します。空白エラーと見なされるものは、 &lt;code&gt;core.whitespace&lt;/code&gt; 構成によって制御されます。デフォルトでは、末尾の空白（空白のみで構成される行を含む）および行の最初のインデント内の直後にタブ文字が続く空白文字は、空白エラーと見なされます。</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">パッチを適用するときは、パッチによる追加を無視してください。これを使用して、最初に2つのファイルに対して &lt;code&gt;diff&lt;/code&gt; を実行し、このオプションで結果を適用することにより、2つのファイル間の共通部分を抽出できます。これにより、削除部分は適用されますが、追加部分は適用されません。</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">パッチを適用するときは、必要に応じてコンテキスト行の空白の変更を無視してください。コンテキスト行は空白を保持し、 &lt;code&gt;--whitespace&lt;/code&gt; オプションの値に関係なく空白の修正は行われません。ただし、新しい行は修正されます。</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">作業ツリーのみにパッチを適用する場合は、後でインデックスに追加する新しいファイルをマークします（&lt;a href=&quot;git-add&quot;&gt;git-add [1]の&lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; オプションを参照）。このオプションは、Gitリポジトリで実行され、 &lt;code&gt;--index&lt;/code&gt; が指定されていない場合は無視されます。 &lt;code&gt;--index&lt;/code&gt; は &lt;code&gt;--cached&lt;/code&gt; や &lt;code&gt;--3way&lt;/code&gt; などの他のオプションによって暗示される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; するように要求すると（これはデフォルトです）、このプログラムは署名付きタグに遭遇すると終了します。では &lt;code&gt;strip&lt;/code&gt; 、とタグが静かに、未署名の行われる &lt;code&gt;warn-strip&lt;/code&gt; で、彼らは符号なし行われますが、警告が表示されます &lt;code&gt;verbatim&lt;/code&gt; 、彼らは静かに輸出されるとして &lt;code&gt;warn&lt;/code&gt; 、それらがエクスポートされますが、あなたは警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; するように要求すると（これがデフォルトです）、このようなタグに遭遇すると、このプログラムは終了します。 &lt;code&gt;drop&lt;/code&gt; それは出力から、このようなタグを省略します。 &lt;code&gt;rewrite&lt;/code&gt; タグ付きオブジェクトがコミットである場合、それは（;参照親書き換えを介してコミット祖先をタグ付けするタグを書き換えるであろう&lt;a href=&quot;git-rev-list&quot;&gt;[1]のgit-REV-リスト&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; オプションを指定して呼び出すと、コマンドはビルド時に結果を出力します。出力は一般に、最近のコミットが最初に触れた行について話します（つまり、行は順不同で注釈が付けられます）。対話型のビューアが使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">インデックスからパスをチェックアウトするときは、マージされていないパスのステージ＃2（ &lt;code&gt;ours&lt;/code&gt; ）または＃3（ &lt;code&gt;theirs&lt;/code&gt; ）をチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">インデックスからのパスをチェックアウトする際には、マージされていないエントリで失敗しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">インデックスからパスをチェックアウトする際に、このオプションを使用すると、指定したパス内の競合するマージを再作成することができます。</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">SVNリポジトリのクローンを作成するときに、リポジトリレイアウトを記述するオプション（--trunk、-tags、-branches、-stdlayout）が使用されていない場合、 &lt;code&gt;git svn clone&lt;/code&gt; は完全に線形の履歴を持つGitリポジトリを作成します。ブランチとタグは、作業コピーの個別のディレクトリとして表示されます。これは完全なリポジトリのコピーを取得する最も簡単な方法ですが、多くのブランチを持つプロジェクトの場合、トランクよりも何倍も大きい作業コピーになります。したがって、標準のディレクトリ構造（trunk / branches / tags）を使用するプロジェクトでは、オプション &lt;code&gt;--stdlayout&lt;/code&gt; を使用してクローンを作成することをお勧めします。プロジェクトが非標準の構造を使用している場合や、ブランチやタグが不要な場合は、リポジトリレイアウトオプションを指定せずに、1つのディレクトリ（通常はトランク）のみを複製するのが最も簡単です。ブランチとタグの完全な履歴が必要な場合、オプション &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">サブモジュールを含むリポジトリを複製またはプルするとき、サブモジュールはデフォルトではチェックアウトされません。 &lt;code&gt;clone&lt;/code&gt; にサブモジュールに再帰するように指示できます。 &lt;code&gt;git submodule&lt;/code&gt; の &lt;code&gt;init&lt;/code&gt; および &lt;code&gt;update&lt;/code&gt; サブコマンドは、チェックアウトされたサブモジュールと作業ツリーの適切なリビジョンを維持します。または、 &lt;code&gt;submodule.recurse&lt;/code&gt; を設定して、 &lt;code&gt;checkout&lt;/code&gt; をサブモジュールに再帰させることもできます。</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">フィックスアップをコミットするときは、 &lt;code&gt;merge&lt;/code&gt; を使用して、ファイルリビジョンを提供しているコミットをフィックスアップブランチに接続することを検討してください。そうすることで、 &lt;code&gt;git blame&lt;/code&gt; などのツールが実際のコミット履歴を追跡し、ソースファイルに適切に注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">（ &lt;code&gt;set-tree&lt;/code&gt; または &lt;code&gt;dcommit&lt;/code&gt; 操作の一部として）Gitからsvnにコミットするときに、既存のログメッセージに &lt;code&gt;From:&lt;/code&gt; または &lt;code&gt;Signed-off-by:&lt;/code&gt; 行がまだない場合は、Gitコミットに基づいて &lt;code&gt;From:&lt;/code&gt; 行を追加します著者の文字列。これを使用すると、 &lt;code&gt;--use-log-author&lt;/code&gt; はすべてのコミットに対して有効な作成者文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">オブジェクトを作成する一般的な磁器操作が実行されると、最後のメンテナンス以降、リポジトリが大幅に増加しているかどうかが確認され、そうであれば &lt;code&gt;git gc&lt;/code&gt; が自動的に実行されます。この動作を無効にする方法については、以下の &lt;code&gt;gc.auto&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">2つのツリーを比較する場合、両方のツリーのID(スペースで区切られ、改行で終わる)が差分の前に表示されます。コミットを比較する場合、最初の (または唯一の)コミットの ID が表示され、その後に改行が続きます。</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">&lt;code&gt;--type=bool&lt;/code&gt; タイプ指定子を使用して値を正規の形式に変換する場合、 &lt;code&gt;git config&lt;/code&gt; は出力が「true」または「false」（小文字のスペル）であることを確認します。</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">リモートリポジトリをコピーするときは、少なくともこの操作を行うときにインデックスキャッシュを更新する必要があります。特に他の人のリポジトリでは、インデックスキャッシュが既知の状態であることを確認したい場合があります（知って&lt;strong&gt;どのような&lt;/strong&gt;ので、通常、あなたが先行するだろう、彼らは）行われ、まだチェックインいませんでした &lt;code&gt;git update-index&lt;/code&gt; Aと</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">書き換え中にメモをコピーする場合（「notes.rewrite。&amp;lt;command&amp;gt;」オプションを参照）、ターゲットのコミットに既にメモがある場合の処理​​を決定します。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。デフォルトでは &lt;code&gt;concatenate&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">書き換え中にノートをコピーする場合、ノートをコピーする(完全修飾された)ref を指定します。グロブであってもよいが、その場合、一致するすべての ref のノートがコピーされる。この設定は複数回指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">書き換え中にノートをコピーする場合、ノートをコピーする(完全修飾された)ref を指定します。ref はグロブである可能性があり、その場合、一致するすべての ref のノートがコピーされます。この設定は複数回指定することもできます。</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">書き換え中にメモをコピーするときに、ターゲットコミットに既にメモがある場合の対処方法。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。デフォルトでは &lt;code&gt;concatenate&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">書き換え中にメモをコピーするときに、ターゲットコミットに既にメモがある場合の対処方法。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。これは、 &lt;code&gt;core.rewriteMode&lt;/code&gt; 設定をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときに、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がブランチである場合は、新しいブランチの「上流」としてマークします。 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がリモート追跡ブランチの場合、これがデフォルトです。詳細については、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;「--track」を参照してください。</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときは、「アップストリーム」構成をセットアップします。 &lt;code&gt;-c&lt;/code&gt; が暗示されます。詳細 &lt;code&gt;--track&lt;/code&gt; は、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;--trackを参照してください。</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときは、「アップストリーム」構成をセットアップします。詳細については、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;「--track」を参照してください。</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">新しいブランチを作成するときは、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; および &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 構成エントリを設定して、開始点ブランチを新しいブランチの「上流」としてマークします。この構成は、 &lt;code&gt;git status&lt;/code&gt; 2つのブランチと &lt;code&gt;git branch -v&lt;/code&gt; の関係を示すようにgitに指示します。さらに、新しいブランチがチェックアウトされるときに、引数なしで &lt;code&gt;git pull&lt;/code&gt; に上流からプルするように指示します。</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">既存のパックがあるリポジトリでパックされたアーカイブを作成する場合、コマンドは既存のデルタを再利用します。これにより、わずかに最適ではないパックになってしまうことがあります。このフラグは、既存のデルタを再利用せず、ゼロから計算するようにコマンドに指示します。</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">ファイルを作成するときは、&amp;lt;string&amp;gt;（通常、末尾に/を含むディレクトリ）を付加します。</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; 出力を処理する場合、パッチの先頭にコミットのオブジェクト名が付けられるという事実を利用して、2つの40バイトの16進数文字列を出力します。最初の文字列はパッチIDで、2番目の文字列はコミットIDです。これは、パッチIDからコミットIDへのマッピングに使用できます。</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">パスに割り当てる属性を決定するとき、Gitは &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ファイル（優先順位が最も高い）、問題のパスと同じディレクトリにある &lt;code&gt;.gitattributes&lt;/code&gt; ファイル、およびその最上位レベルまでの親ディレクトリを調べます作業ツリー（ &lt;code&gt;.gitattributes&lt;/code&gt; を含むディレクトリが問題のパスから遠いほど、優先順位が低くなります）。最後に、グローバルファイルとシステム全体のファイルが考慮されます（優先順位が最も低くなります）。</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">初期化解除または削除（以下を参照）すると、サブモジュールのGitディレクトリはスーパー &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; に自動的に移動されます。</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">到達可能なオブジェクトの名前を表示する場合、SHA-1に加えて、到達可能性を説明する名前も表示され&lt;strong&gt;ます&lt;/strong&gt;。たとえば、 &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; &lt;strong&gt;よう&lt;/strong&gt;に、&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;と互換性があります。</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行う場合は、磁器に対応した形式で出力してください。詳細については、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;を参照してください。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行う場合は、出力を長形式で提供します。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行う場合は、短い形式で出力してください。詳細については、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;を参照してください。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">リポジトリ変換を行うときは、コミットごとに一意のマーク（ &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ）を使用し、コマンドラインで--export-marksオプションを指定します。 fast-importは、すべてのマークとそれに対応するGitオブジェクトSHA-1をリストしたファイルをダンプします。フロントエンドがマークをソースリポジトリに結び付けることができる場合、各Gitコミットを対応するソースリビジョンと比較することで、インポートの正確さと完全性を簡単に検証できます。</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">コミットメッセージを編集するときは、指定されたファイルの内容でエディターを起動します。 &lt;code&gt;commit.template&lt;/code&gt; 設定変数は、多くの場合、コマンドに暗黙のうちに、このオプションを与えるために使用されます。このメカニズムは、メッセージに何を書き込むかについてのヒントを参加者に案内したいプロジェクトで使用できます。ユーザーがメッセージを編集せずにエディターを終了すると、コミットは中止されます。これは、メッセージが &lt;code&gt;-m&lt;/code&gt; または &lt;code&gt;-F&lt;/code&gt; オプションなどの他の方法で与えられた場合には効果がありません。</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">編集時には、きれいに印刷されたものではなく、生のオブジェクトの内容を提供するようにしました。現在のところ、これはツリーにのみ影響し、バイナリ形式で表示されます。これは作業が難しくなりますが、きれいに印刷できないほど破損したツリーを修復するときに役立ちます。バイナリデータをきれいに読み書きできるようにエディタを設定する必要があるかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">有効にすると、デフォルト &lt;code&gt;post-update&lt;/code&gt; フックが &lt;code&gt;git update-server-info&lt;/code&gt; を実行して、ダムトランスポート（HTTPなど）によって使用される情報を最新の状態に保ちます。HTTP経由でアクセス可能なGitリポジトリを公開する場合は、おそらくこのフックを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">エンコードが宣言されていない非ASCIIメッセージまたは件名を検出した場合は、ヘッダー/引用符を追加して、&amp;lt;encoding&amp;gt;でエンコードされていることを示します。デフォルトは &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; の値です。これが指定されていない場合は、ASCII以外のファイルが検出された場合にプロンプ​​トが表示されます。</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">クレデンシャルを消去する場合、一致するクレデンシャルはすべてのファイルから消去されます。</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">extensions.worktreeConfigが有効な場合、構成ファイル &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; は &lt;code&gt;.git/config&lt;/code&gt; の後に読み取られます。</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">false の場合、現在のブランチを上流ブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">コマンドラインにリストされた参照を &lt;code&gt;remote.*.fetch&lt;/code&gt; する場合、リモートリポジトリのremote。*。fetch構成変数の値の代わりに、指定されたrefspec（複数回指定できる）を使用して、参照をリモート追跡ブランチにマップします。詳細については、「設定されたリモート追跡ブランチ」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Gitの外部でファイルが変更された場合、ユーザーは変更されたファイルを明示的にステージングする必要があります（例：&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]の&lt;/a&gt;「 &lt;code&gt;Examples&lt;/code&gt; セクションを参照）。Gitは通常、これらのファイルへの変更を検出しません。</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">歴史をフィルタリングすると &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; 、いくつかの歴史を整理しません。（詳細な説明については、&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;「履歴の簡略化」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">最初に作成されたときには、オブジェクトは個々のファイルに格納されますが、効率化のために後でまとめて「パックファイル」に圧縮されることがあります。</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">（例えば、ディスプレイへのコミットの範囲が与えられたとき &lt;code&gt;commit1..commit2&lt;/code&gt; 又は &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）のみの間の祖先鎖上に直接存在するコミット表示 &lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; の子孫の両方である、すなわちコミット &lt;code&gt;commit1&lt;/code&gt; 、との祖先 &lt;code&gt;commit2&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">（例えば、ディスプレイへのコミットの範囲が与えられたとき &lt;code&gt;commit1..commit2&lt;/code&gt; 又は &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）のみの間の祖先鎖上に直接存在するコミット表示 &lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; の子孫の両方である、すなわちコミット &lt;code&gt;commit1&lt;/code&gt; 、との祖先 &lt;code&gt;commit2&lt;/code&gt; を。 （詳細な説明については、&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;「履歴の簡略化」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">2部構成の名前section.keyを指定すると、&amp;lt;url&amp;gt;部分が指定のURLに最も一致するsection。&amp;lt;url&amp;gt; .keyの値が返されます（そのようなキーが存在しない場合、section.keyの値が使用されますフォールバックとして）。名前としてセクションのみを指定する場合は、セクション内のすべてのキーに対してそのようにし、それらをリストします。値が見つからない場合は、エラーコード1を返します。</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">形式 &lt;code&gt;rN&lt;/code&gt; の SVNリビジョン番号を指定すると、対応するGitコミットハッシュを返します（オプションで、ツリーのように続けて検索するブランチを指定できます）。ツリー風に指定すると、対応するSVNリビジョン番号を返します。</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">これが与えられ、クローンを作成するリポジトリが ssh 経由でアクセスされている場合、もう一方の端で実行されるコマンドのデフォルト以外のパスを指定します。</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">指定すると、フェッチ元のリポジトリが &lt;code&gt;git fetch-pack&lt;/code&gt; によって処理され、 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; がコマンドに渡され、相手側で実行されるコマンドのデフォルト以外のパスが指定されます。</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">&lt;code&gt;--or&lt;/code&gt; と組み合わせて複数のパターン式を指定する場合、このフラグを指定して、すべてに一致する行があるファイルに一致を制限します。</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">準備ができたら、アリスに/ home / bob / myrepoのリポジトリから変更をプルするように指示します。彼女はこれをします：</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">リネームされたファイルやディレクトリをインポートする際には、古い名前を削除し、対応するコミットの際に新しい名前を変更するだけです。Git は、コミット中に明示的にリネームを検出するのではなく、その場でリネームを検出します。</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">リストモードの場合、上流のブランチ（存在する場合）との関係とともに、sha1を表示し、各ヘッドの件名をコミットします。2回指定すると、リンクされたワークツリー（存在する場合）のパスと上流のブランチの名前も出力します（ &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; も参照）。現在のワークツリーのHEADにはパスが印刷されないことに注意してください（常に現在のディレクトリになります）。</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">informative errors をオンにすると、git-daemon は &quot;no such repository&quot; のような状態を &quot;repository not exported&quot; と区別して、より冗長なエラーをクライアントに報告します。この方がクライアントにとっては便利ですが、エクスポートされていないリポジトリの存在についての情報が漏れてしまうかもしれません。情報提供型エラーが有効になっていない場合、すべてのエラーがクライアントに「アクセス拒否」を報告します。デフォルトは --no-informative-errors です。</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">サブモジュールを初期化するとき、含まれているリポジトリの最上位ディレクトリにある &lt;code&gt;.gitmodules&lt;/code&gt; ファイルを使用して、各サブモジュールのURLを検索します。このファイルは、 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; と同じ方法でフォーマットする必要があります。各サブモジュールのURLのキーは「submodule。$ name.url」です。詳細については、&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">最初に &lt;code&gt;git am&lt;/code&gt; を呼び出すときに、処理するメールボックスの名前をそれに与えます。適用されない最初のパッチが表示されると、途中で中止されます。この状態から回復するには、次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">カスタムマージツールを呼び出すとき、Gitは一時ファイルのセットを使用してツールに渡します。ツールがエラーを返し、この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、これらの一時ファイルは保持されます。それ以外の場合は、ツールの終了後に削除されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">そのコミットの編集については、 &lt;code&gt;git reset HEAD^&lt;/code&gt; 実行します。その効果は、HEADが1つ巻き戻され、インデックスがそれに追随することです。ただし、作業ツリーは同じままです。</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">変化をどのように適用したらよいかわからない場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">どうやって調整したらいいのかわからないときは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">代替からの参照をリストする場合、指定された接頭辞で始まる参照のみをリストします。プレフィックスは、&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;への引数として与えられたかのように一致します。複数の接頭辞をリストするには、空白で区切ります。場合 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; が設定され、設定 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; しても効果はありません。</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">リストするときは、指定された&amp;lt;format&amp;gt;を使用します。これは、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;medium&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; のいずれかです。省略した場合、フォーマットはデフォルトで &lt;code&gt;short&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">到達できないオブジェクトを緩めるときは、 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; より古いオブジェクトを緩めないでください。これは、フォローアップ &lt;code&gt;git prune&lt;/code&gt; によってすぐに除去されるオブジェクトの書き込みを最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">注釈付き（および場合によっては署名済み）のタグをマージするとき、Gitは早送りマージが可能であっても常にマージコミットを作成し、コミットメッセージテンプレートはタグメッセージで準備されます。さらに、タグが署名されている場合、署名チェックはメッセージテンプレートのコメントとして報告されます。&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">ノートを結合するときは、より冗長にします。ノートを剪定するときは、ノートが削除されたオブジェクト名をすべて報告します。</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">ノートを結合するときは、静かに操作してください。</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">ノートをマージするときは、与えられた戦略を使用してノートの競合を解決します。以下のストラテジーが認識されます。&quot;マニュアル」(デフォルト)、「私たちの」、「彼らの」、「ユニオン」、および「cat_sort_uniq」です。このオプションは &quot;notes.mergeStrategy&quot; 構成設定を上書きします。各ノートのマージ戦略の詳細については、以下の「NOTES MERGE STRATEGIES」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">存在しないか &lt;code&gt;default&lt;/code&gt; に設定されている場合、Gitがファイルを参照してからファイルが変更されたかどうかを検出するために、stat構造体の多くのフィールドがチェックされます。この構成変数に設定されたときに &lt;code&gt;minimal&lt;/code&gt; （Gitのは、それを使用するためにコンパイルされた場合、デバイス番号）のmtimeとCTIMEのサブ第二の部分、uidとファイルの所有者のGID、inode番号から除外されていますこれらのフィールド間のチェック &lt;code&gt;core.trustCtime&lt;/code&gt; （およびcore.trustCtimeが設定されている場合はctime）の秒全体とチェックするファイルサイズのみを残します。</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">複数のパターンがパスにマッチする場合、後の行が前の行を上書きします。この上書きは属性ごとに行われます。</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">移動ラインは、例えば使用して着色されている場合は &lt;code&gt;diff.colorMoved&lt;/code&gt; の設定は、このオプションを制御し &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; にスペースが有効なモードの詳細についてはどのように扱われるかは、見 &lt;code&gt;--color-moved-ws&lt;/code&gt; で&lt;a href=&quot;git-diff&quot;&gt;のgit-diffの[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">複数のパッチが出力される場合、件名のプレフィックスは「[PATCH n / m]」になります。1つのパッチに1/1を強制的に追加するには、 &lt;code&gt;-n&lt;/code&gt; を使用します。件名からパッチ番号を省略するには、 &lt;code&gt;-N&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">複数の作業ツリーが使用されている場合、$ GIT_DIR内のほとんどのファイルは、いくつかの既知の例外を除いて、作業ツリーごとです。ただし、 &lt;code&gt;common&lt;/code&gt; すべてのファイルは、すべての作業ツリー間で共有されます。</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">コマンドラインも設定もプッシュするものを指定しない場合、デフォルトの動作が使用されます。これは &lt;code&gt;push.default&lt;/code&gt; の &lt;code&gt;simple&lt;/code&gt; 値に対応します。現在のブランチは対応する上流のブランチにプッシュされますが、安全対策として、プッシュ上流のブランチの名前がローカルのブランチと同じでない場合は、中止されます。</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; が指定されていない場合、 &lt;code&gt;stash@{0}&lt;/code&gt; が想定されます。それ以外の場合、 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; は &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式の参照である必要があります。</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">いかなる場合 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 引数は、コマンドラインから与えられていない &lt;code&gt;git push&lt;/code&gt; この変数の各&amp;lt;値&amp;gt;として与えられるかのように動作 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">コマンドラインから &lt;code&gt;--whitespace&lt;/code&gt; フラグが指定されていない場合、この構成アイテムがデフォルトとして使用されます。</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">コマンドラインでrefspecが指定されていない場合、 &lt;code&gt;git pull&lt;/code&gt; は構成または &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; からのrefspec を使用します。このような場合、次の規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">（-rを介して）リモートが指定されていない場合、 &lt;code&gt;HEAD&lt;/code&gt; はすでにGitに特別な意味を持っているため、CVSからの &lt;code&gt;HEAD&lt;/code&gt; ブランチはGitリポジトリ内の &lt;code&gt;origin&lt;/code&gt; ブランチにインポートされます。リモートが指定されている場合、 &lt;code&gt;HEAD&lt;/code&gt; ブランチはremotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour という名前になります。別のブランチにインポートする場合は、このオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">リモートが指定されていない場合、現在のブランチに設定されたアップストリームブランチがない限り、デフォルトで &lt;code&gt;origin&lt;/code&gt; リモートが使用されます。</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">ブランチ&amp;lt;name&amp;gt;にある場合、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; ためにbranch。&amp;lt;name&amp;gt; .remoteをオーバーライドします。また、ブランチ&amp;lt;name&amp;gt;からプッシュするために &lt;code&gt;remote.pushDefault&lt;/code&gt; をオーバーライドします。ある場所（上流など）からプルして別の場所（独自の公開リポジトリなど）にプッシュする場合、 &lt;code&gt;remote.pushDefault&lt;/code&gt; を設定して、すべてのブランチにプッシュするリモートを指定し、このオプションを使用してオーバーライドします。特定のブランチ用。</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">ブランチ&amp;lt;name&amp;gt;にあるとき、それは &lt;code&gt;git fetch&lt;/code&gt; と &lt;code&gt;git push&lt;/code&gt; にどのリモートからフェッチする/プッシュするかを伝えます。プッシュ先のリモートは、 &lt;code&gt;remote.pushDefault&lt;/code&gt; （すべてのブランチ）でオーバーライドできます。現在のブランチのプッシュ先のリモートは、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; によってさらにオーバーライドされる場合があります。何のリモートが設定されていない、またはあなたが任意の枝上にない場合、それがデフォルトにされている場合は &lt;code&gt;origin&lt;/code&gt; フェッチとのため &lt;code&gt;remote.pushDefault&lt;/code&gt; プッシュするため。さらに、 &lt;code&gt;.&lt;/code&gt; （ピリオド）は現在のローカルリポジトリ（ドットリポジトリ） &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 下記のbranch。&amp;lt;name&amp;gt; .mergeの最後のメモを参照してください。</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">これらのフラグのいずれかが指定された場合、パスに記録されているオブジェクト名は更新されません。代わりに、これらのオプションはパスの &quot;fsmonitor valid &quot;ビットを設定したり解除したりする。詳細は後述の「ファイルシステムモニタ」を参照してください。</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">これらのフラグのいずれかが指定された場合、パスに記録されたオブジェクト名は更新されません。その代わりに、これらのオプションはパスの「スキップ・ワークツリー」ビットを設定したり解除したりします。詳細については、後述の「スキップワークツリービット」を参照してください。</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">1つ以上の &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; が明示的に指定されている場合（コマンドラインまたは &lt;code&gt;--stdin&lt;/code&gt; を介して）、単一のパターン、またはコロン「：」で区切られたそのようなパターンのペア（これは、refが名前にコロンを含めることはできません）。単一のパターン &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; の省略形にすぎません。</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">blob をパッキングするとき、fast-import は常に最後に書き込まれた blob に対してデルタ化を試みます。フロントエンドが特に指定しない限り、これはおそらく同じファイルの前のバージョンではないので、生成されるデルタは可能な限り最小にはなりません。結果として得られるパックファイルは圧縮されますが、最適ではありません。</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--ignore-paths&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--ignore-refs&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--include-paths&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">パスが指定されたら、それらを表示します（これは実際のパス名ではなく、照合するパターンのリストであることに注意してください）。それ以外の場合は、ツリーのルートレベルを唯一のパス引数として暗黙的に使用します。</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">コマンドラインでpathspecが与えられた場合、すでにインデックスに追加されている変更を記録せずに、pathspecにマッチしたファイルの内容をコミットします。これらのファイルの内容は、それまでにステージされていたものの上に、次のコミットのためにステージされます。</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">&lt;code&gt;git stash push&lt;/code&gt; にpathspecが指定されている場合、新しいstashエントリーは、pathspecに一致するファイルについてのみ変更された状態を記録します。インデックスエントリと作業ツリーファイルは、これらのファイルに対してのみHEADの状態にロールバックされ、pathspecと一致しないファイルはそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">可能であれば、 &lt;code&gt;pack-objects&lt;/code&gt; は既存のディスク上のデルタを再利用して、新しいデルタをその場で検索する必要がないようにします。これはフェッチを提供するための重要な最適化です。これは、サーバーがほとんどのオブジェクトを膨らませることを回避し、ディスクから直接バイトを送信することができることを意味します。この最適化は、オブジェクトが、受信者が持っていない（まだ送信していない）ベースに対するデルタとして格納されている場合は機能しません。その場合、サーバーはデルタを「破壊」し、CPUコストが高い新しいデルタを見つける必要があります。したがって、ディスク上のデルタ関係にあるオブジェクトのセットが、クライアントがフェッチするものと一致することがパフォーマンスにとって重要です。</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">存在する場合は、 &lt;code&gt;submodule.$name.update&lt;/code&gt; 値もコピーします。このコマンドは、.git / config内の既存の情報を変更しません。次に、ローカルセットアップ用に.git / configのサブモジュールクローンURLをカスタマイズして、 &lt;code&gt;git submodule update&lt;/code&gt; 進みます。サブモジュールの場所をカスタマイズするつもりがない場合は、明示的な &lt;code&gt;init&lt;/code&gt; ステップなしで &lt;code&gt;git submodule update --init&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">通常プルするリモートとは異なるリモートにプッシュする場合は、 &lt;code&gt;current&lt;/code&gt; リモートとして動作します。これは最も安全なオプションであり、初心者に適しています。</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">プッシュする場合は、リモートサーバに単一のアトミックトランザクションで refs を更新するように要求します。成功した場合はすべての refs が更新され、そうでない場合は何も更新されません。リモート側がこの機能をサポートしていない場合、プッシュは失敗します。</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">&lt;code&gt;core.repositoryformatversion&lt;/code&gt; 変数を読み取るとき、バージョン1をサポートするgit実装は、構成ファイルの &lt;code&gt;extensions&lt;/code&gt; セクションにある構成キーも読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">トレーラーを読むとき、トークン、区切り文字、値の後に空白が入ることがあります。また、トークンと値の中にも空白を入れることができます。値は、RFC 822の &quot;folding &quot;のように、後続の各行がホワイトスペースで始まるように、複数の行に分割することができます。</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">読み取り時には、値はデフォルトでシステム、グローバルおよびリポジトリローカル構成ファイルから読み取られ、オプション &lt;code&gt;--system&lt;/code&gt; 、-- &lt;code&gt;--global&lt;/code&gt; 、-- &lt;code&gt;--local&lt;/code&gt; 、-- &lt;code&gt;--worktree&lt;/code&gt; および &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; を使用して、その場所からのみ読み取るコマンド（&lt;a href=&quot;#FILES&quot;&gt;FILESを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">コミットを記録するときに、「（チェリーがコミットから選択されました...）」という行を元のコミットメッセージに追加して、この変更がチェリーピックされたコミットを示します。これは、競合のないチェリーピックに対してのみ行われます。情報が受信者にとって役に立たないため、プライベートブランチから厳選する場合は、このオプションを使用しないでください。一方、一般に公開されている2つのブランチ間で選択している場合（たとえば、開発ブランチからの古いリリースのメンテナンスブランチに修正をバックポートする場合）、この情報を追加すると便利です。</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">自分の作業を記録するとき、作業ツリー内の変更されたファイルの内容は、 &lt;code&gt;git add&lt;/code&gt; を使用して「インデックス」と呼ばれるステージング領域に一時的に保存されます。 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; を使用して、ファイルをインデックス内のみで作業ツリー内ではなく、最後のコミットのファイルに戻すことができます。これにより、 &lt;code&gt;git add&lt;/code&gt; が効果的に元に戻され、このファイルへの変更が次のコミット。これらのコマンドで段階的にコミットされる状態を構築した後、 &lt;code&gt;git commit&lt;/code&gt; （パス名パラメーターなし）を使用して、これまでにステージングされた内容を記録します。これは、コマンドの最も基本的な形式です。例：</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">リモートブランチとローカルブランチの両方に &quot;test &quot;という名前がついている場合。</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">名前の変更/コピーが関係する場合、 &lt;code&gt;file1&lt;/code&gt; と &lt;code&gt;file2&lt;/code&gt; はそれぞれ、名前の変更/コピーのソースファイルの名前と、名前の変更/コピーによって生成されるファイルの名前を示します。</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">デルタアイランドで再パックする場合、デルタウィンドウは、構成で禁止されている候補で詰まる傾向があります。大きな--windowで再パックすることは役立ちます（コンテンツに対して計算を行う前にアイランドに基づくオブジェクトのペアを拒否できるため、そうでない場合と同じくらい時間がかかりません）。</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">インデックスから作業ツリー内のファイルを復元する場合、マージされていないパスにはステージ＃2（ &lt;code&gt;ours&lt;/code&gt; ）または＃3（ &lt;code&gt;theirs&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">インデックスから作業ツリー上のファイルを復元するときに、 &lt;code&gt;--theirs&lt;/code&gt; いないエントリがあり、-- &lt;code&gt;--ours&lt;/code&gt; 、-- theirs、 &lt;code&gt;--merge&lt;/code&gt; merge、または &lt;code&gt;--conflict&lt;/code&gt; のいずれも指定されていない場合は、操作を中止しないでください。作業ツリーのマージされていないパスはそのまま残されます。</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">インデックスから作業ツリー上のファイルを復元する際に、マージされていないパスで競合していたマージを再作成します。</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">Gitへのsvnコミットを取得するとき（ &lt;code&gt;fetch&lt;/code&gt; 、 &lt;code&gt;rebase&lt;/code&gt; 、または &lt;code&gt;dcommit&lt;/code&gt; 操作の一部として）、ログメッセージで最初の &lt;code&gt;From:&lt;/code&gt; または &lt;code&gt;Signed-off-by:&lt;/code&gt; 行を探し、それを作成者文字列として使用します。</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">アノテーションを制限するためにリビジョン範囲指定子が使用されている場合、範囲境界から変更されていない行(v2.6.18のコミットか、上記の例では3週間以上前の最新のコミットのいずれか)は、その範囲境界のコミットのせいにされてしまいます。</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt;（現在は &lt;code&gt;amend&lt;/code&gt; または &lt;code&gt;rebase&lt;/code&gt; ）を使用してコミットを書き換え、この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、Gitはメモを元のメモから書き換えられたコミットに自動的にコピーします。デフォルトは &lt;code&gt;true&lt;/code&gt; ですが、以下の「notes.rewriteRef」を参照してください。</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt;を使用してコミットを書き換えるとき（現在は &lt;code&gt;amend&lt;/code&gt; または &lt;code&gt;rebase&lt;/code&gt; ）、この変数が &lt;code&gt;false&lt;/code&gt; の場合、gitは元のメモを書き換えられたコミットにコピーしません。デフォルトは &lt;code&gt;true&lt;/code&gt; です。以下の「 &lt;code&gt;notes.rewriteRef&lt;/code&gt; 」も参照してください。</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">コミットを書き換える際に、元のコミットから書き換えられたコミットにどのメモをコピーするかを指定します。コロンで区切られた参照またはグロブのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">プロジェクトのサブディレクトリから実行する場合、このオプションを使用すると、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ（たとえば、ベアリポジトリ内）にいない場合は、&amp;lt;path&amp;gt;を引数として指定することにより、出力を相対的にするサブディレクトリに名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">サブディレクトリから実行する場合、コマンドは通常、カレントディレクトリからの相対パスを出力します。このオプションは、プロジェクトのトップディレクトリからの相対パスを強制的に出力します。</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">「.git」リポジトリディレクトリのないディレクトリで実行すると、Gitは親ディレクトリでそのようなディレクトリを見つけて作業ツリーの最上部を見つけようとしますが、デフォルトではファイルシステムの境界を越えません。この環境変数をtrueに設定すると、ファイルシステムの境界で停止しないようにGitに指示できます。 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; と同様に、これは &lt;code&gt;GIT_DIR&lt;/code&gt; またはコマンドラインで設定された明示的なリポジトリディレクトリには影響しません。</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; および &lt;code&gt;-m&lt;/code&gt; オプションを指定してコマンドを実行すると、マージ結果で、現在のブランチで追跡されていないパスを上書きする必要がある場合があります。コマンドは通常、そのようなパスが失われないようにするために、マージの続行を拒否します。ただし、この安全弁が邪魔になることがあります。たとえば、他のブランチがブランチで生成されたファイルであったファイルを追加し、 &lt;code&gt;make&lt;/code&gt; を実行した後、 &lt;code&gt;make clean&lt;/code&gt; を実行して生成されたファイルを削除する前にそのブランチに切り替えようとすると、安全弁がトリガーされることがよくありますファイル。このオプションは、ディレクトリごとの除外ファイル（通常は &lt;code&gt;.gitignore&lt;/code&gt; ）を読み取るようにコマンドに指示し、そのような追跡されないが明示的に無視されたファイルを上書きできるようにします。</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">この方法でパッチを送信する場合、ほとんどの場合、独自のパッチを送信するため、「 &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; 」マーカーに加えて、パッチファイルから &lt;code&gt;From:&lt;/code&gt; および &lt;code&gt;Date:&lt;/code&gt; 行を省略します。パッチのタイトルは、パッチが対応するディスカッションの件名とは異なる可能性が高いため、上記の例のように、Subject：行を保持したい場合があります。</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; に設定すると、常に一致を強調表示します。 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）でない場合、決して。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; に設定すると、出力が端末に書き込まれるときにのみ色を使用します。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; に設定すると、インタラクティブなプロンプトとディスプレイに常に色を使用します（「git-add --interactive」や「git-clean --interactive」で使用される色など）。false（または &lt;code&gt;never&lt;/code&gt; ）でない場合、決して。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; に設定されている場合、出力が端末への場合のみ色を使用します。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; に設定すると、-- &lt;code&gt;--ignore-space-change&lt;/code&gt; オプションと同じ方法で、空白の変更を無視するように &lt;code&gt;git apply&lt;/code&gt; に指示します。no、none、never、falseのいずれかに設定すると、すべての空白の違いを尊重 &lt;code&gt;git apply&lt;/code&gt; ようにgit applyに指示します。&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;git rebase --rebase-merges&lt;/code&gt; 設定した場合 &lt;code&gt;merges&lt;/code&gt; 、git rebase --rebase-mergesを使用してリベースし、ローカルマージコミットがリベースに含まれるようにします（詳細は&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; するように設定されている場合（ &lt;code&gt;merges&lt;/code&gt; ため非推奨）、ローカルで作成されたマージコミットがフラット化されないように &lt;code&gt;git rebase&lt;/code&gt; に渡される &lt;code&gt;--preserve-merges&lt;/code&gt; オプションでリベースします。</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git reset&lt;/code&gt; はデフォルトで &lt;code&gt;--quiet&lt;/code&gt; オプションになります。</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git-rerere&lt;/code&gt; は以前に記録された解決策を使用して競合を完全に解決した後、結果のコンテンツでインデックスを更新します。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">trueに設定すると、ユーザが明示的に浅くないクローンを要求しない限り、このサブモジュールのクローンは浅いクローンとして実行されます (履歴の深さは1)。</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">trueに設定すると、操作の開始前に一時的なstashエントリーが自動的に作成され、操作の終了後にそれが適用されます。これは、ダーティなワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;の &lt;code&gt;--no-autostash&lt;/code&gt; および &lt;code&gt;--autostash&lt;/code&gt; オプションで上書きできます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">trueに設定されている場合、一般に &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 、 &lt;code&gt;fetch.prune&lt;/code&gt; または &lt;code&gt;--prune&lt;/code&gt; を介してプルーニングがアクティブ化されていると、デフォルトでこのリモートからフェッチすると、リモートに存在しないローカルタグも削除されます。 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 設定をオーバーライドします（ある場合）。</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">trueに設定すると、デフォルトでこのリモートからフェッチすると、リモートに存在しなくなったリモートトラッキング参照も削除されます（コマンドラインで &lt;code&gt;--prune&lt;/code&gt; オプションを指定した場合と同様）。 &lt;code&gt;fetch.prune&lt;/code&gt; 設定があれば、それをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">true に設定すると、git-receive-pack はクライアントにプッシュオプションの機能を宣伝します。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">true に設定すると、このリモートはプロミバイザオブジェクトのフェッチに使用されます。</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">設定すると、不正なオブジェクトまたは存在しないオブジェクトへのリンクの場合、フェッチまたは受信は中止されます。さらに、レガシーの問題（ &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 参照）や、 &lt;code&gt;.GIT&lt;/code&gt; ディレクトリや悪意のある &lt;code&gt;.gitmodules&lt;/code&gt; ファイルの存在などの潜在的なセキュリティ問題（v2のリリースノートを参照）など、他のさまざまな問題がチェックされます。詳細は2.1およびv2.17.1）。他の健全性およびセキュリティチェックは、将来のリリースで追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; または &lt;code&gt;porcelain&lt;/code&gt; ステータス出力を表示する場合は、ファイル名をそのまま出力し、LFではなくNULでエントリを終了します。形式が指定されていない場合、 &lt;code&gt;--porcelain&lt;/code&gt; 出力形式を意味します。 &lt;code&gt;-z&lt;/code&gt; オプションを使用しない場合、「異常な」文字を含むファイル名は、構成変数 &lt;code&gt;core.quotePath&lt;/code&gt; で説明されているように引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">名前変更またはコピーを伴う変更を表示する場合、 &lt;code&gt;--stat&lt;/code&gt; 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。たとえば、4行を変更しながら &lt;code&gt;arch/i386/Makefile&lt;/code&gt; を &lt;code&gt;arch/x86/Makefile&lt;/code&gt; に移動する変更は、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">コミットメッセージを表示する際には、与えられた ref に保存されているノートも表示します。refは完全に修飾されていなければなりません。指定された ref が存在しない場合はエラーではありませんが、ノートを印刷すべきではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">オブジェクト名を表示するときは、プレフィックスに &lt;code&gt;^&lt;/code&gt; を付け、すでに存在するオブジェクト名から &lt;code&gt;^&lt;/code&gt; プレフィックスを取り除きます。</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;name&amp;gt;の値をシンボリック参照として表示する場合は、値を短くしてください（例： &lt;code&gt;refs/heads/master&lt;/code&gt; から &lt;code&gt;master&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">で示された場合 &lt;code&gt;git diff-tree -c&lt;/code&gt; 、それがマージの親はマージ結果をコミット比較する（すなわちfile1..fileNは親です）。で示される場合には &lt;code&gt;git diff-files -c&lt;/code&gt; 、それは作業ツリーのファイルと2人の未解決のマージ両親を比較する（つまり、file1が「私たちのバージョン」別名、ステージ2で、FILE2は「彼らのバージョン」別名ステージ3です）。</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">いくつかのコミットがスキップされている場合 (「git bisect skip」を使用)、二等分アルゴリズムはステップ 1)から 3)まで同じです。しかし、大まかには次のようなステップを使います。</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; を 1回以上指定すると、注釈は要求された行に制限されます。</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">v オプションを指定すると、使用されるフォーマットは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; を使用してブランチを切り替えると、段階的な変更が失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">ブランチを切り替える際に、現在のブランチと切り替え先のブランチで異なるファイルにローカルで変更があった場合、コマンドは変更内容をコンテキストとして保持するためにブランチの切り替えを拒否します。しかし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、新しいブランチの間で三者間のマージが行われ、新しいブランチに移動します。</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">ブランチを切り替えるときは、インデックスまたは作業ツリーが &lt;code&gt;HEAD&lt;/code&gt; と異なっていても続行してください。これは、ローカルの変更を破棄するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">C &quot;オプションを使用した場合、変更されたファイルの元の内容と削除されたファイル(--find-copies-harderオプションを使用した場合は未変更のファイルも含む)がリネーム/コピー操作の元ファイルの候補として考慮されます。入力が以下のファイルペアのようなものだとすると,修正ファイルYと新規作成ファイル0の話になります.</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">とき &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 引数はブランチ名で、 &lt;code&gt;--detach&lt;/code&gt; オプションは、デタッチに使用することができ &lt;code&gt;HEAD&lt;/code&gt; 枝の先端に（ &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 取り外すことなく、そのブランチをチェックアウトでしょう &lt;code&gt;HEAD&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">&lt;code&gt;--aggressive&lt;/code&gt; オプションが供給される、&lt;a href=&quot;git-repack&quot;&gt;のgit -再梱包[1]&lt;/a&gt;で呼び出される &lt;code&gt;-f&lt;/code&gt; 順番に通過するフラッグ、 &lt;code&gt;--no-reuse-delta&lt;/code&gt; に&lt;a href=&quot;git-pack-objects&quot;&gt;gitのパック・オブジェクト[1] &lt;/a&gt;。これにより、既存のデルタが破棄されて再計算されますが、再パッキングに多くの時間が費やされます。</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">とき &lt;code&gt;--stdin&lt;/code&gt; オプションが提供され、パターンは改行で区切られたリストとしての代わりに、引数から標準でから読み込まれます。</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">ときに &lt;code&gt;-l&lt;/code&gt; オプションを使用する、フォーマットが変更に</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">場合 &lt;code&gt;-z&lt;/code&gt; オプションが指定され、任意の引用なしでラインがNUL（ASCII 0&amp;times;00）バイトで終端されているように、パス名が印刷されています。</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">&lt;code&gt;.gitattributes&lt;/code&gt; ファイルが作業ツリーにない場合、インデックス内のパスがフォールバックとして使用されます。チェックアウトプロセス中に、インデックス内の &lt;code&gt;.gitattributes&lt;/code&gt; が使用され、作業ツリー内のファイルがフォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;LESS&lt;/code&gt; の環境変数が設定されていない、Gitはそれを設定し &lt;code&gt;FRX&lt;/code&gt; （場合 &lt;code&gt;LESS&lt;/code&gt; の環境変数が設定され、Gitがすべてでそれを変更しません）。 &lt;code&gt;core.pager&lt;/code&gt; &lt;code&gt;LESS&lt;/code&gt; のデフォルト設定を選択的にオーバーライドする場合は、core.pagerをたとえば &lt;code&gt;less -S&lt;/code&gt; に設定できます。これはGitによってシェルに渡され、最後のコマンドが &lt;code&gt;LESS=FRX less -S&lt;/code&gt; に変換されます。環境は &lt;code&gt;S&lt;/code&gt; オプションを設定しませんが、コマンドラインは設定し、長い行を切り捨てるように少なく指示します。同様に、 &lt;code&gt;core.pager&lt;/code&gt; をless- &lt;code&gt;less -+F&lt;/code&gt; に設定すると、 &lt;code&gt;F&lt;/code&gt; が非アクティブになります「やめる場合は、1つの画面」行動不活性化するコマンドラインから、環境によって指定されたオプション、 &lt;code&gt;less&lt;/code&gt; 。特定のコマンドに対していくつかのフラグを具体的にアクティブにすることができます。たとえば、 &lt;code&gt;pager.blame&lt;/code&gt; を &lt;code&gt;less -S&lt;/code&gt; に設定すると、 &lt;code&gt;git blame&lt;/code&gt; に対してのみ行の切り捨てが有効になります。</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">場合 &lt;code&gt;core.fsmonitor&lt;/code&gt; の構成変数が変更され、ファイル・システム・モニターは、インデックスからのコマンドは、インデックスを読み取る次回に追加または削除されています。場合 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; 使用される、ファイル・システム・モニターはすぐに追加またはインデックスから削除されます。</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">場合 &lt;code&gt;core.untrackedCache&lt;/code&gt; の構成変数が変更され、追跡されていないキャッシュインデックスからのコマンドは、インデックスを読み取る次回に追加または削除されています。一方、 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; を使用すると、追跡されていないキャッシュがすぐにインデックスに追加されるか、インデックスから削除されます。</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">パスに属性 &lt;code&gt;ident&lt;/code&gt; が設定されると、Gitはblobオブジェクトの &lt;code&gt;$Id$&lt;/code&gt; を &lt;code&gt;$Id:&lt;/code&gt; に置き換え、その後に40文字の16進数のblobオブジェクト名を続け、チェックアウト時にドル記号 &lt;code&gt;$&lt;/code&gt; を続けます。ワークツリーファイルで &lt;code&gt;$Id:&lt;/code&gt; で始まり &lt;code&gt;$&lt;/code&gt; で終わるバイトシーケンスは、チェックイン時に &lt;code&gt;$Id$&lt;/code&gt; に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">コマンドが対話型モードに入ると、クリーンアップするファイルとディレクトリを表示し、対話型コマンドループに入ります。</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">コマンドがインタラクティブモードに入ると、 &lt;code&gt;status&lt;/code&gt; サブコマンドの出力が表示され、インタラクティブコマンドループに入ります。</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">サブディレクトリからコマンドが起動された場合、トップレベルディレクトリからの相対的なカレントディレクトリのパスを表示します。</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">コマンドがサブディレクトリから起動された場合、カレントディレクトリからの相対的なトップレベルディレクトリのパスを表示します (通常は &quot;../&quot; のシーケンス、または空の文字列)。</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">pathspecなしでコマンドを実行すると、すべてをdeinitするのではなく、エラーアウトしてしまうので、ミスを防ぎます。</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">コマンドラインがでプッシュするかを指定しない場合 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 引数または &lt;code&gt;--all&lt;/code&gt; 、 &lt;code&gt;--mirror&lt;/code&gt; 、 &lt;code&gt;--tags&lt;/code&gt; オプション、コマンドはデフォルト見つかっ &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; コンサルティングにより、 &lt;code&gt;remote.*.push&lt;/code&gt; 構成、見つからない場合は、 &lt;code&gt;push.default&lt;/code&gt; 構成を尊重して、何をプッシュするかを決定します（ &lt;code&gt;push.default&lt;/code&gt; の意味については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">コマンドラインで &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 引数を使用してプッシュ先を指定しない場合、現在のブランチの &lt;code&gt;branch.*.remote&lt;/code&gt; 構成が参照され、プッシュ先が決定されます。構成がない場合、デフォルトで &lt;code&gt;origin&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">commit差分が異なる場合、 &lt;code&gt;git range-diff&lt;/code&gt; は元のdiffの色を再作成し、外側の-/ +差分マーカーを追加して&lt;strong&gt;背景&lt;/strong&gt;を赤/緑にして、たとえば正確な行が追加されたときに変更があったときに見やすくします。</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">コミットログメッセージが &quot;squash！&amp;hellip;&quot;（または &quot;fixup！&amp;hellip;&quot;）で始まり、同じ &lt;code&gt;...&lt;/code&gt; に一致するコミットがtodoリストにすでにある場合、rebase -iのtodoリストを自動的に変更します &lt;code&gt;squash&lt;/code&gt; 対象としてマークされたコミットが変更されるコミットの直後に来るようにし、移動されたコミットのアクションを &lt;code&gt;pick&lt;/code&gt; からスカッシュ（または &lt;code&gt;fixup&lt;/code&gt; ）に変更します。コミットサブジェクトが一致する場合、または &lt;code&gt;...&lt;/code&gt; がコミットのハッシュを参照する場合、コミットは &lt;code&gt;...&lt;/code&gt; に一致します。フォールバックとして、コミット対象の部分一致も機能します。fixup / squashコミットを作成するための推奨される方法は、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]の&lt;/a&gt; &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; オプションを使用することです。。</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">構成キー &lt;code&gt;extensions.partialclone&lt;/code&gt; が設定されている場合、これは、リポジトリが部分的なクローンで作成された（または後で部分的なフェッチを実行した）こと、およびリモートが特定の不要なオブジェクトの送信を省略した可能性があることを示します。そのようなリモートは「promisorリモート」と呼ばれ、そのような省略されたすべてのオブジェクトを将来的にそこからフェッチできることを約束します。</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">設定キー &lt;code&gt;extensions.preciousObjects&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、リポジトリ内のオブジェクトを削除してはなりません（たとえば、 &lt;code&gt;git-prune&lt;/code&gt; または &lt;code&gt;git repack -d&lt;/code&gt; によって）。</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">現在の作業ディレクトリがリポジトリの下にある場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">現在の作業ディレクトリがリポジトリの作業ツリー内にある場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">環境変数 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が設定されると、上記のdiff呼び出しの代わりに、それによって名前が付けられたプログラムが呼び出されます。追加、削除、または変更されたパスの場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が7つのパラメーターで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">git-rebaseコマンドを実行すると、「pre-rebase」フックが存在する場合、最初にそれが実行されます。このフックを使用して健全性チェックを行い、適切でない場合はリベースを拒否できます。例については、テンプレートのリベース前フックスクリプトを参照してください。</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">歴史が十字型のマージを含む場合、2つのコミットに対して複数の &lt;code&gt;best&lt;/code&gt; 一般的な祖先が存在する可能性があります。たとえば、次のトポロジでは：</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 構成変数で指定されたmanビューアがサポートされているものの中にない場合、対応する &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 構成変数が検索されます。この変数が存在する場合、指定されたツールはカスタムコマンドとして扱われ、シェルevalが引数として渡されたmanページでコマンドを実行するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">出力が端末に送られると、通常の &lt;code&gt;git diff&lt;/code&gt; の出力と同じように、デフォルトで色分けされます。さらに、最初の行（コミットの追加）は緑、最後の行（コミットの削除）は赤、2行目（完全一致）は &lt;code&gt;git show&lt;/code&gt; の出力のコミットヘッダーのように黄色、3行目は黄色です。線は古いコミットを赤に、新しいコミットを緑に、残りを &lt;code&gt;git show&lt;/code&gt; のコミットヘッダーのように色分けします。</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">パッチがきれいに適用されない場合、パッチが適用するはずのblobのIDをパッチが記録し、ローカルでそれらのblobを使用できる場合は、3ウェイマージにフォールバックします。 &lt;code&gt;--no-3way&lt;/code&gt; を使用して、am.threeWay構成変数をオーバーライドできます。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; am.threeWayを参照してください。</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">パッチがきれいに適用されない場合、パッチが適用するはずのblobのIDをパッチが記録し、ローカルでそれらのblobを使用できる場合、3ウェイマージにフォールバックし、作業ツリーのファイルに競合マーカーを残す可能性があります。ユーザーが解決するため。このオプションは &lt;code&gt;--index&lt;/code&gt; オプションを意味し、 &lt;code&gt;--reject&lt;/code&gt; および &lt;code&gt;--cached&lt;/code&gt; オプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">プッシュが完了すると、1つ以上の &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; または &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; プッシュされた各参照の成功または失敗を示す線。ステータスレポートの出力は空白行で終了します。オプションフィールド&amp;lt;why&amp;gt;にLFが含まれている場合は、Cスタイルの文字列で引用符で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">フェッチするリモートブランチが巻き戻されて定期的にリベースされることがわかっている場合、その新しいチップは以前のチップの子孫にならないことが予想されます（最後にフェッチしたときにリモート追跡ブランチに保存されているため）。 &lt;code&gt;+&lt;/code&gt; 記号を使用して、そのようなブランチで非早送りの更新が必要になることを示します。この動作でブランチがリポジトリで利用可能になることを決定または宣言する方法はありません。プルするユーザーは、これがブランチの予想される使用パターンであることを知っている必要があります。</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">リポジトリがベアの場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">リポジトリが浅い場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; で指定されたリポジトリのコミットが、ローカルの参照とは異なる参照の先端にある場合、 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 構文を使用して、ローカル名のコロン &lt;code&gt;:&lt;/code&gt; を使用できます。とそのリモート名。</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">クローン元のリポジトリがローカルマシン上にある場合、このフラグは通常の「Git対応」トランスポートメカニズムをバイパスし、オブジェクトとrefsディレクトリの下にHEADとすべてのコピーを作成してリポジトリをクローンします。 &lt;code&gt;.git/objects/&lt;/code&gt; ディレクトリの下のファイルは、可能な場合はスペースを節約するためにハードリンクされています。</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; の結果が非マージコミットである場合、通常はそのコミットのみを調べることで問題を発見できるはずです。開発者は、変更を小さな自己完結型のコミットに分割することで、これを簡単に行うことができます。ただし、上記の場合は問題ありません。単一のコミットを調べても問題は明らかではないためです。代わりに、開発のグローバルな視点が必要です。さらに悪いことに、問題のある関数のセマンティクスの変更は、開発の上位ラインの変更のほんの一部にすぎない場合があります。</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">分割インデックス機能を使用すると、この変数が指定する時刻以降に変更されなかった共有インデックスファイルは、新しい共有インデックスファイルが作成されるときに削除されます。値「now」はすべてのエントリをすぐに期限切れにし、「never」は期限切れを完全に抑制します。デフォルト値は「2.weeks.ago」です。共有インデックスファイルは、それに基づいて新しい分割インデックスファイルが作成されるか、またはそこから読み取られるたびに、変更された（期限切れの目的で）と見なされることに注意してください。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">分割インデックス機能を使用する場合、これは、新しい共有インデックスが書き込まれる前の分割インデックスと共有インデックスの両方のエントリの総数と比較した、分割インデックスに含めることができるエントリの割合を指定します。値は0から100の間でなければなりません。値が0の場合、新しい共有インデックスが常に書き込まれ、100の場合、新しい共有インデックスは決して書き込まれません。デフォルトの値は20です。そのため、分割インデックスのエントリ数がエントリの総数の20％を超える場合、新しい共有インデックスが書き込まれます。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">値が &lt;code&gt;interactive&lt;/code&gt; の場合、リベースはインタラクティブモードで実行されます。</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">リポジトリにこれより多くのルーズオブジェクトが存在する場合、 &lt;code&gt;git gc --auto&lt;/code&gt; はそれらをパックします。一部の磁器コマンドは、このコマンドを使用して、軽量のガベージコレクションを時々実行します。デフォルト値は6700です。</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">リポジトリに &lt;code&gt;*.keep&lt;/code&gt; ファイルでマークされていないパックがこれより多い場合、 &lt;code&gt;git gc --auto&lt;/code&gt; はそれらを1つの大きなパックに統合します。デフォルト値は50です。これを0に設定すると、無効になります。 &lt;code&gt;gc.auto&lt;/code&gt; を0に設定すると、これも無効になります。</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">与えられた引数が1つだけあり、それが &lt;code&gt;--&lt;/code&gt; （たとえば &lt;code&gt;git checkout abc&lt;/code&gt; ）ではなく、引数が有効な &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （たとえば、ブランチ &lt;code&gt;abc&lt;/code&gt; が存在する）と有効な &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; （たとえば、ファイル）の両方である場合または「abc」という名前のディレクトリが存在する場合）、Gitは通常、明確にするように要求します。ただし、ブランチのチェックアウトは非常に一般的な操作であるため、このような状況では &lt;code&gt;git checkout abc&lt;/code&gt; は「abc」を &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; として使用します。これらのパスをインデックスからチェックアウトする場合は、 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">これらの環境変数が設定されている場合、対応するコマンドライン引数は使用できません。</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">このフラグを指定すると、代わりにパックがstdinから読み取られ、コピーが&amp;lt;pack-file&amp;gt;に書き込まれます。 &amp;lt;pack-file&amp;gt;が指定されていない場合、パックは現在のGitリポジトリーのobjects / pack /ディレクトリーに書き込まれ、デフォルトの名前はパックの内容から決定されます。 &amp;lt;pack-file&amp;gt;が指定されていない場合は、このプロセスと &lt;code&gt;git repack&lt;/code&gt; repackの間の競合状態を防ぐために--keepの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">このフラグが指定された場合、パスに記録されているオブジェクト名は更新されません。その代わりに、このオプションはパスの &quot;asculus unchanged&quot; ビットを設定したり解除したりします。assume unchanged&quot; ビットがオンの場合、ユーザーはファイルを変更しないことを約束し、Git は作業木ファイルがインデックスに記録されているものと一致しているとみなすようにします。作業木ファイルを変更したい場合は、このビットを解除して Git に伝える必要があります。これは、lstat(2)のシステムコールが非常に遅いファイルシステム上で大きなプロジェクトを扱うときに役立つことがあります (例:cifs)。</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">この形式の &lt;code&gt;git read-tree&lt;/code&gt; が正常に戻ると、 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; することにより、加えられた「ローカル変更」のどれが繰り越されたかを確認できます。これは、そのような2つのツリーのマージ前に &lt;code&gt;git diff-index --cached $H&lt;/code&gt; が生成したものと必ずしも一致しないことに注意してください。これは、ケース18と19が原因です--- $ Mにすでに変更がある場合（たとえば、パッチフォームで電子メールを介して受け取った可能性があります）、 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; は、このマージの前の変更についてですが、2つのツリーのマージ後の &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 出力には表示されません。</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">このオプションを指定すると、コマンドラインの最初に特別な &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 引数が追加されたかのように動作します。&amp;lt;value&amp;gt;は、指定されたコマンドの先頭に任意の末尾の空白は削除されました。</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">この特別な属性が &lt;code&gt;git credential&lt;/code&gt; によって読み取られると、値はURLとして解析され、構成要素が読み取られたかのように処理されます（たとえば、 &lt;code&gt;url=https://example.com&lt;/code&gt; は &lt;code&gt;protocol=https&lt;/code&gt; および &lt;code&gt;host=example.com&lt;/code&gt; ように動作します。 comが提供されていました）。これは、呼び出し元がURL自体を解析するのを避けるのに役立ちます。 URLから欠落しているコンポーネント（上記の例ではユーザー名がないなど）は空に設定されることに注意してください。 URLを指定して一部の属性をオーバーライドする場合は、最初にURL属性を指定してから、オーバーライドを指定します。</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">トレースファイルがターゲットディレクトリに書き込まれると、SID の最後のコンポーネントに応じて名前が付けられます(ファイル名の衝突を避けるために、オプションでカウンターを後に付けます)。</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">複数のディレクトリを追跡する場合（--stdlayout、-branches、または--tagsオプションを使用）、git svnはSubversionリポジトリのルート（または許可されている最高レベル）への接続を試みます。このデフォルトでは、プロジェクト全体がリポジトリ内で移動された場合に履歴の追跡が改善されますが、読み取りアクセス制限が設定されているリポジトリで問題が発生する可能性があります。 &lt;code&gt;--no-minimize-url&lt;/code&gt; を渡すと、git svnが上位レベルのディレクトリに接続することなく、URLをそのまま受け入れることができます。このオプションは、1つのURL /ブランチのみが追跡されている場合、デフォルトではオフになっています（ほとんど役に立ちません）。</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">trueの場合、 &lt;code&gt;--revs&lt;/code&gt; オプションが存在する場合、gitはデフォルトで &lt;code&gt;git pack-objects&lt;/code&gt; の &lt;code&gt;--sparse&lt;/code&gt; オプションを使用します。このアルゴリズムは、新しいオブジェクトを導入するパスに表示されるツリーのみをウォークします。これにより、小さな変更を送信するパックを計算するときに、パフォーマンスが大幅に向上します。ただし、含まれているコミットに特定のタイプの直接名前変更が含まれている場合、余分なオブジェクトがパックファイルに追加される可能性があります。 &lt;code&gt;feature.experimental&lt;/code&gt; が有効でない限り、デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">trueの場合、gitはビットマップインデックスに「ハッシュキャッシュ」セクションを含めます（書き込まれる場合）。このキャッシュを使用してgitのデルタヒューリスティックをフィードし、ビットマップオブジェクトと非ビットマップオブジェクト間のデルタを改善できる可能性があります（たとえば、以前のビットマップパックと最後のgc以降にプッシュされたオブジェクト間のフェッチを提供する場合）。欠点は、ディスク領域のオブジェクトごとに4バイトを消費することです。デフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">true を指定すると、stdout へのパッキング時 (たとえばサーバー側でのフェッチ時など)に git は (利用可能な場合は)pack bitmaps を使用します。デフォルトは true です。pack bitmaps をデバッグしている場合を除いて、一般的にはこの設定をオフにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">trueの場合、すべてのオブジェクトをディスクにパックするとき（たとえば、 &lt;code&gt;git repack -a&lt;/code&gt; を実行するとき）、gitはビットマップインデックスを書き込みます。このインデックスを使用すると、クローンとフェッチのために作成される後続のパックの「オブジェクトのカウント」フェーズを高速化できますが、ディスク容量と初期の再パックに費やされる余分な時間が犠牲になります。複数のパックファイルが作成される場合、これは効果がありません。デフォルトでは、ベアリポジトリではtrue、それ以外の場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">trueの場合、「git pull」の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチをリベースします。これをブランチごとに設定する方法については、「branch。&amp;lt;name&amp;gt; .rebase」を参照してください。</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">trueの場合、「git pull」の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチ&amp;lt;name&amp;gt;をリベースします。ブランチ固有ではない方法でこれを行うには、「pull.rebase」を参照してください。</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">true の場合、フェッチ後に現在のブランチを上流ブランチの上にリベースします。上流ブランチに対応するリモートトラッキングブランチがあり、最後にフェッチした後に上流ブランチがリベースされた場合、リベースはその情報を使用して、ローカル以外の変更をリベースしないようにします。</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">2つの木が与えられた場合、最初の木と2番目の木を比較します。単一のコミットが与えられた場合、そのコミットとその親を比較します。残りのコミットが与えられた場合、最初のコミットの親であるかのように使用されます。</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">2つのツリーが指定されている場合、ユーザーは &lt;code&gt;git read-tree&lt;/code&gt; に次のように伝えます。</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">破損したパックファイルを解凍すると、最初の破損でコマンドが終了します。このフラグは、コマンドを続行し、可能な限り多くのオブジェクトを回復するための最善の努力をするように指示します。</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">指定しない場合、-headsおよび--tagsでフィルタリングした後のすべての参照が表示されます。&amp;lt;refs&amp;gt;&amp;hellip;を指定すると、指定したパターンに一致する参照のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">追跡されていないキャッシュと併用すると、新しいファイルを探すために作業ディレクトリ全体をスキャンするコストを回避して、パフォーマンスをさらに向上させることができます。</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">&lt;code&gt;-B&lt;/code&gt; と一緒に使用すると、削除/作成ペアの削除部分のプリイメージも省略されます。</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">C/c/c/--amend オプションと併用した場合や、競合するチェリーピックの後にコミットする場合には、結果として得られたコミットの作者はコミット者に属することを宣言します。これは作者のタイムスタンプも更新します。</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">-Mと一緒に使用すると、完全に書き換えられたファイルも名前変更のソースと見なされ（通常-Mは、名前が変更されたソースとして表示されなくなったファイルのみを考慮します）、番号 &lt;code&gt;n&lt;/code&gt; は-Bオプションのこの側面を制御します（デフォルトは50％）。 &lt;code&gt;-B20%&lt;/code&gt; は、ファイルのサイズの20％以上と比較した追加および削除を伴う変更が、別のファイルへの名前変更の可能なソースとしてピックアップされる資格があることを指定します。</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; とともに使用すると、認識されたすべてのコマンドの説明が表示されます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">&lt;code&gt;-ad&lt;/code&gt; と一緒に使用すると、既存のパックから到達できないオブジェクトは、削除されるのではなく、パックファイルの最後に追加されます。さらに、到達できないルーズオブジェクトは梱包されます（ルーズな対応物は削除されます）。</target>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">--error-unmatchを使用してユーザーが指定した&amp;lt;file&amp;gt;（パスパターン）引数をパスに展開する場合、名前付きの&amp;lt;tree-ish&amp;gt;がまだ存在するため、インデックスから削除されたパスを偽装します。このオプションを &lt;code&gt;-s&lt;/code&gt; または &lt;code&gt;-u&lt;/code&gt; オプションと一緒に使用しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">--hashを使用する場合（--dereferenceではない）、出力形式は次のとおりです： &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">&lt;code&gt;--get&lt;/code&gt; を使用し、要求された変数が見つからない場合、&amp;lt;value&amp;gt;がその変数に割り当てられた値であるかのように動作します。</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; を使用して作業ツリーファイルと比較する場合、stat-o​​nlyの変更が変更されたと見なさないでください。代わりに、静かに &lt;code&gt;git update-index --refresh&lt;/code&gt; を実行して、作業ツリーのコンテンツがインデックスのコンテンツと一致するパスのキャッシュされた統計情報を更新します。このオプションのデフォルトはtrueです。これは &lt;code&gt;git diff&lt;/code&gt; Porcelainにのみ影響し、 &lt;code&gt;git diff-files&lt;/code&gt; などの低レベルの &lt;code&gt;diff&lt;/code&gt; コマンドには影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">ssh://または file://トランスポートを使用する場合、環境変数 GIT_PROTOCOL に &quot;version=2&quot; を含めるように明示的に設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">複数の--branchesまたは--tagsを使用する場合、 &lt;code&gt;git svn&lt;/code&gt; は名前の衝突を自動的に処理しません（たとえば、異なるパスからの2つのブランチが同じ名前である場合、またはブランチとタグが同じ名前である場合）。このような場合は、 &lt;code&gt;init&lt;/code&gt; を使用してGitリポジトリを設定してから、最初の &lt;code&gt;fetch&lt;/code&gt; 前に、$ GIT_DIR / configファイルを編集して、ブランチとタグが異なる名前空間に関連付けられるようにします。例えば：</target>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; フラグを使用する場合、コマンドには正確なパスが必要です。</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refspec&lt;/code&gt; 機能を使用する場合、gitは通常、プッシュが成功するとプライベート参照を更新します。リモートヘルパーが機能 &lt;code&gt;no-private-update&lt;/code&gt; を宣言すると、この更新は無効になります。</target>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">非推奨の &lt;code&gt;[section.subsection]&lt;/code&gt; 構文を使用する場合、サブセクションに少なくとも1つの大文字が指定されていると、値を変更すると、変更ではなく複数行のキーが追加されます。たとえば、設定が次のようになっている場合</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">git://トランスポートを使用する場合は、追加パラメータとして &quot;version=2&quot; を送ることでプロトコル v2 を使用するようにリクエストすることができます。</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">http：//またはhttps：//トランスポートを使用する場合、クライアントは &lt;code&gt;http-protocol.txt&lt;/code&gt; で説明されているように「スマート」なinfo / refsリクエストを作成し、 &lt;code&gt;Git-Protocol&lt;/code&gt; で「version = 2」を指定してv2を使用するようリクエストします。ヘッダ。</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">マージについて説明すると、MERGE_HEADという特別な名前も表示されます。これは、現在のブランチにマージしている他のブランチを指します。</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">正確な表現が必要な場合は、&quot;branch&quot; という単語を使って開発ラインを意味し、&quot;branch head&quot; (または単に &quot;head&quot;)という単語を使ってブランチの最新のコミットへの参照を意味するようにします。上の例では、&quot;A&quot; という名前のブランチの先頭はある特定のコミットへのポインタですが、そこに至るまでの 3 つのコミットの行はすべて &quot;branch A&quot; の一部であると考えています。</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; &lt;code&gt;D..M&lt;/code&gt; コミットが &lt;code&gt;D&lt;/code&gt; によって導入されたバグで汚染されていて修正が必要なのかを知りたい場合は、実際には &lt;code&gt;D&lt;/code&gt; の子孫であるD..Mのサブセットのみ、つまり &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;K&lt;/code&gt; を除いて表示したい場合があります。これは、 &lt;code&gt;--ancestry-path&lt;/code&gt; オプションが行うこととまったく同じです。 &lt;code&gt;D..M&lt;/code&gt; の範囲に適用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">ランダムなユーザ入力を処理するために期待されているスクリプトを書くときには、引数が一義化配置することにより、どのであることが明示的に作成することをお勧めし &lt;code&gt;--&lt;/code&gt; 適切な場所で。</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">分散型バージョン管理システム用のリモートヘルパーを書くときは、相互作用するリポジトリのローカルコピーを保持し、プライベート名前空間 refs がこのローカルリポジトリを指すようにし、refs/remotes 名前空間がリモートリポジトリを追跡するために使用されるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">書き込むとき、新しい値はデフォルトでリポジトリのローカル構成ファイルに書き込まれ、オプション &lt;code&gt;--system&lt;/code&gt; 、-- &lt;code&gt;--global&lt;/code&gt; 、-- &lt;code&gt;--worktree&lt;/code&gt; 、-- &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; を使用して、コマンドにその場所に書き込むように指示できます（ &lt;code&gt;--local&lt;/code&gt; と言うことができますが、これがデフォルトです）。</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">この変更の状態に満足したら、公開に備えて &quot;test &quot;ブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">あなたが何かの真ん中にいるとき、あなたはあなたがしていることに関連している可能性がある上流の変更があることを学びます。ローカルでの変更がアップストリームでの変更と競合しない場合は、単純な &lt;code&gt;git pull&lt;/code&gt; で先に進むことができます。</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">何かをしている最中に上司が来て、すぐに何かを修正するように要求してきます。伝統的には、一時的なブランチにコミットして変更を保存し、元のブランチに戻って緊急修正を行うのが一般的です。</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">ファイル &lt;code&gt;foo&lt;/code&gt; の 40〜60行目のオリジンを見つけることに興味がある場合は、次のように &lt;code&gt;-L&lt;/code&gt; オプションを使用できます（同じ意味です。どちらも40行目から21行を要求します）。</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">バージョンv2.6.18より古い変更、または3週間より古い変更に関心がない場合は、 &lt;code&gt;git rev-list&lt;/code&gt; と同様のリビジョン範囲指定子を使用できます。</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">密接に結びついた小さなグループで作業している場合、同じリポジトリを何度も何度も操作することは珍しくありません。 &lt;code&gt;remote&lt;/code&gt; リポジトリの省略表現を定義することで、それを簡単にすることができます：</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;に競合を表示するように依頼すると、ステージ2と3のワークツリーで競合したマージ結果の間に3方向の差分が実行され、内容が両側から来ているハンクのみが表示されます（他ではつまり、ハンクのマージ結果がステージ2からのみ得られる場合、その部分は競合せず、表示されません。ステージ3でも同じです。</target>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">あなたが実行すると、 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; または &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; のみ、リモート1を持っている、それが暗黙のうちにチェックアウトすると、例えば追跡に頼ること &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; 。これは、 &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 参照を持つ複数のリモートがあるとすぐに機能を停止します。この設定により、明確化の際に常に優先されるリモートの名前を設定できます。典型的なユースケースは、これを &lt;code&gt;origin&lt;/code&gt; に設定することです。</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">すでにインデックスファイルが埋め込まれている状態で3ウェイマージを開始すると、それが作業ツリー内のファイルの状態を表していると想定され、インデックスファイルに記録されていない変更があるファイルを持つこともできます。さらに、この状態はステージ2のツリーから「派生した」状態であると仮定されています。3 者間マージは、元のインデックスファイルにステージ 2 と一致しないエントリが見つかった場合、実行を拒否します。</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">上流のリリースポイントとの同期など、たまたまタグ付けされたコミットにつながる作業を統合したい場合は、不要なマージコミットをしたくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">準備ができたら、実行してください</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">しかし、トピックブランチの寿命が長い場合、そのトピックブランチにはそのような &quot;master からのマージ&quot; コミットが多数存在することになり、開発履歴が不必要に乱雑になってしまいます。Linux カーネルメーリングリストの読者は、サブシステムのメンテナが「無駄なマージ」でいっぱいのブランチから引っ張ってくるように頼んだときに、Linus がこのような頻繁すぎるテストマージに不満を持っていたことを覚えているかもしれません。</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">トピック ブランチがマスター ブランチ (または上流)からフォークしてから触れた重複領域を変更する場合は、トピック ブランチが上流にプッシュされる準備が整う前であっても、最新のマスターを使用してテストしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">可能な限り、セクションの見出しには、その方法を説明するタスクを必要以上の知識を必要としない言語で明確に説明する必要があります。たとえば、「 &lt;code&gt;git am&lt;/code&gt; コマンド」ではなく「プロジェクトへのパッチのインポート」</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">「oldsha1」は以前に&amp;lt;ref&amp;gt;に保存された40文字の16進値、「newsha1」は&amp;lt;newvalue&amp;gt;の40文字の16進値、「committer」は標準のGitコミッターID形式のコミッターの名前、メールアドレス、日付です。</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">ここで、すべてのフィールドは上記の通りであり、&quot;message &quot;は-mオプションに与えられた値である。</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Git リポジトリを作成する場所。用意されていない場合は、p4 depotパスの最後のコンポーネントが新しいディレクトリの作成に使用されます。</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">一方、 &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; は次のように生成します。</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Git がディレクトリのリネームを検出するかどうか。これは、履歴の一方の側のディレクトリに追加された新しいファイルが履歴の他方の側でリネームされたときにマージ時にどうなるかに影響します。merge.directoryRenames を &quot;false&quot; に設定すると、ディレクトリ名の変更を検出できなくなります。true&quot; に設定すると、ディレクトリ名変更の検出が有効になり、新しいファイルが新しいディレクトリに移動されます。conflict&quot; に設定されている場合は、そのようなパスに対して競合が報告されます。merge.renames が false に設定されている場合、 merge.directoryRenames は無視され、false として扱われます。デフォルトは &quot;conflict&quot; です。</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Git がリネームを検出するかどうか。false&quot; に設定すると、リネームの検出は無効になります。true&quot; に設定すると、基本的なリネーム検出が有効になります。デフォルトは diff.renames の値です。</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Gitが&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;および&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]で&lt;/a&gt;名前変更を検出するかどうか、およびその方法。 「false」に設定すると、名前変更の検出が無効になります。 「true」に設定すると、基本的な名前変更の検出が有効になります。 「コピー」または「コピー」に設定すると、Gitはコピーも検出します。デフォルトはdiff.renamesの値です。</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Gitが名前変更を検出するかどうか、およびその方法。 「false」に設定すると、名前変更の検出が無効になります。 「true」に設定すると、基本的な名前変更の検出が有効になります。 「コピー」または「コピー」に設定すると、Gitはコピーも検出します。デフォルトはtrueです。これは&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;や&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;ような &lt;code&gt;git diff&lt;/code&gt; Porcelainにのみ影響し、&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;などの低レベルのコマンドには影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">gitがHTTPリダイレクトに従う必要があるかどうか。 &lt;code&gt;true&lt;/code&gt; に設定すると、gitはサーバーが発行したリダイレクトを透過的にたどります。 &lt;code&gt;false&lt;/code&gt; に設定すると、gitはすべてのリダイレクトをエラーとして扱います。 &lt;code&gt;initial&lt;/code&gt; に設定すると、gitはリモートへの最初のリクエストに対してのみリダイレクトに従いますが、後続のフォローアップHTTPリクエストに対しては行いません。 gitはリダイレクトされたURLをフォローアップリクエストのベースとして使用するため、通常はこれで十分です。デフォルトは &lt;code&gt;initial&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">その更新が &lt;code&gt;--force&lt;/code&gt; なしで許可されるかどうかは、フェッチ先のref名前空間、フェッチされるオブジェクトのタイプ、および更新が早送りと見なされるかどうかによって異なります。一般に、フェッチの場合と同じルールが適用されます。それらが何であるかについては、&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;の &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; セクションを参照してください。 &lt;code&gt;git fetch&lt;/code&gt; に固有のルールの例外を以下に示します。</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">このリポジトリーでCVSサーバー・インターフェースが有効になっているかどうか。&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">プロジェクトリストページでカテゴリごとにプロジェクトのグループ化を有効にするかどうか。プロジェクトのカテゴリは、 &lt;code&gt;$GIT_DIR/category&lt;/code&gt; ファイル、または各リポジトリの構成の &lt;code&gt;gitweb.category&lt;/code&gt; 変数によって決定されます。デフォルトでは無効になっています（0に設定）。</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">マージ終了時にORIG_HEADとマージ結果のdiffstatを表示するかどうか。デフォルトではTrueです。</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">前回のリベース以降に上流で変更された内容の diffstat を表示するかどうか。デフォルトでは False です。</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">システム全体の$（prefix）/ etc / gitconfigファイルから設定の読み取りをスキップするかどうか。詳細は&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">システム全体の &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; ファイルから設定の読み取りをスキップするかどうか。この環境変数を &lt;code&gt;$HOME&lt;/code&gt; および &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; と一緒に使用して、選択可能なスクリプトの予測可能な環境を作成するか、一時的に設定して、バグのある &lt;code&gt;/etc/gitconfig&lt;/code&gt; ファイルを使用しないようにして、修正するための十分な権限を持つユーザーを待つことができます。</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">ANSIエスケープシーケンスを使用してパッチに色を追加するかどうか。これが &lt;code&gt;always&lt;/code&gt; に設定されている場合、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、および&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;はすべてのパッチに色を使用します。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; に設定されている場合、これらのコマンドは、出力先が端末である場合にのみ色を使用します。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">リネームソースとして空のブロブを使用するかどうか。</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS経由でフェッチまたはプッシュするときにSSL証明書を検証するかどうか。デフォルトはtrueです。 &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">どのファイルにパターンを配置するかは、パターンがどのように使用されるかによって異なります。</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">ノートの競合を解決するときにデフォルトで選択するマージ戦略。 &lt;code&gt;manual&lt;/code&gt; 、 &lt;code&gt;ours&lt;/code&gt; 、 &lt;code&gt;theirs&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、または &lt;code&gt;cat_sort_uniq&lt;/code&gt; のいずれかでなければなりません。デフォルトは &lt;code&gt;manual&lt;/code&gt; です。各戦略の詳細については、上記の「マージ戦略」を参照してください。</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">ノートの競合を解決するときにデフォルトで選択するマージ戦略。 &lt;code&gt;manual&lt;/code&gt; 、 &lt;code&gt;ours&lt;/code&gt; 、 &lt;code&gt;theirs&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、または &lt;code&gt;cat_sort_uniq&lt;/code&gt; のいずれかでなければなりません。デフォルトは &lt;code&gt;manual&lt;/code&gt; です。各戦略の詳細については、&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]の&lt;/a&gt;「NOTES MERGE STRATEGIES」セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">メモをrefs / notes / &amp;lt;name&amp;gt;にマ​​ージするときに選択するマージ戦略。これは、より一般的な「notes.mergeStrategy」をオーバーライドします。使用可能な各戦略の詳細については、上記の「マージ戦略」を参照してください。</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">メモをrefs / notes / &amp;lt;name&amp;gt;にマ​​ージするときに選択するマージ戦略。これは、より一般的な「notes.mergeStrategy」をオーバーライドします。利用可能な戦略の詳細については、&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;の「NOTES MERGE STRATEGIES」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; または &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; で設定されたデフォルトに加えて、コマンドの &lt;code&gt;git log&lt;/code&gt; ファミリーでコミットメッセージを表示するときにメモを読み取るための参照（グロブまたは複数回指定されている場合は参照）。この設定は、コマンドラインまたは &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 環境変数で上書きできます。&lt;a href=&quot;git-log&quot;&gt;git-log [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;refs/notes/commits&lt;/code&gt; ではなく、どのrefからノートを操作するか。これは、 &lt;code&gt;core.notesRef&lt;/code&gt; 設定をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; または &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; によって設定されたデフォルトに加えて、コマンドの &lt;code&gt;log&lt;/code&gt; ファミリーでコミットメッセージを表示するときにメモを読み取るための参照。&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">これにより、ホームディレクトリの &lt;code&gt;.gitconfig&lt;/code&gt; という名前のファイルに以下が追加されます。</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">結果的には</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">一方で &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 、通常、ファイルがであるかを指定するために使用され、あなたはまた、ファイルが何であるかを指定することができ &lt;code&gt;not&lt;/code&gt; 否定パターンを使用して、で。たとえば、 &lt;code&gt;unwanted&lt;/code&gt; ファイルを削除するには：</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">一方で &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 、通常のファイルが含まれているかを指定するために使用されて、あなたはまた、ファイルが何であるかを指定することができ &lt;code&gt;not&lt;/code&gt; 負のパターンを使用して、含まれていました。たとえば、 &lt;code&gt;unwanted&lt;/code&gt; ファイルを削除するには：</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">一方で &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 、単一の親をコミットの指定についてだった、これら三つの表記もその親を検討してください。たとえば、 &lt;code&gt;HEAD^2^@&lt;/code&gt; と言うことはできますが、 &lt;code&gt;HEAD^@^2&lt;/code&gt; と言うことはできません。</target>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">一方で &lt;code&gt;git archimport&lt;/code&gt; それがインポートすることをアーカイブのための賢明なブランチ名を作成しようとします、手動でGitのブランチ名を指定することも可能です。そのためには、各&amp;lt;archive / branch&amp;gt;パラメーターの後に、コロンで区切ってGitブランチ名を記述します。このようにして、Archブランチ名を短縮し、Arch専門用語をGit専門用語に変換できます。たとえば、「PROJECT {litdd} devo {litdd} VERSION」ブランチを「master」にマッピングします。</target>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">一方で &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; このコミット表示され、 &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; とは限らない（その文字列の出現回数が変更されていないため）。</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">一方で &lt;code&gt;git svn&lt;/code&gt; 、それはまだSVNユーザーに内部のGitのバック上流に起こったマージ履歴を表すことができない標準レイアウトを採用リポジトリの（ブランチやタグを含む）のコピーの履歴を追跡することができます。したがって、SVNとの互換性を容易にするために、Git内で履歴をできる限り線形に保つことをお勧めします（以下の「警告」のセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Git は通常ファイルの内容をそのままにしておきますが、リポジトリ内で行末を LF に正規化したり、オプションでファイルをチェックアウトする際に CRLF に変換したりするように設定することができます。</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">ツリーが作業ディレクトリの特定のディレクトリの状態を表すのに対し、コミットはその状態を「時間」で表し、そこにたどり着く方法を説明します。</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">「簡単なケースでのリカバリ」は、ハードケースでも成功するように見える場合がありますが、意図しない結果になる可能性があります。例えば、経由で削除されたことをコミット &lt;code&gt;git rebase --interactive&lt;/code&gt; されます&lt;strong&gt;復活します&lt;/strong&gt;！</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">その間、 &lt;code&gt;info&lt;/code&gt; ファイルと &lt;code&gt;final-commit&lt;/code&gt; ファイルも確認してください。どのような場合には &lt;code&gt;final-commit&lt;/code&gt; ログメッセージをコミットするには、それは非常に可能性の高い受信機があなたのパッチを適用する際に、ログメッセージを編集し、手を終わるだろうということです見たいと思うまさにではありません。「こんにちは、これは私の最初のパッチです。\ n」というメッセージは、コミットメッセージの終わりを示す3本のダッシュ線の後に来るはずです。</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">変更を作成することは便利ですが、後で何が変更されたかがわかると、さらに便利です。これに最も役立つコマンドは、別の &lt;code&gt;diff&lt;/code&gt; ファミリー、つまり &lt;code&gt;git diff-tree&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">gitweb CGI自体の構成設定を変更することもできますが、それらの変更はアップグレード時に失われます。構成設定は、CGIスクリプトと同じディレクトリ内のファイルに配置され、デフォルト名は &lt;code&gt;gitweb_config.perl&lt;/code&gt; になります。シンボリックリンクを使用して、構成が異なる複数のgitwebインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">親オブジェクトの ID はコマンドラインで提供されますが、作者とコミッターの情報は、設定されている場合には以下の環境変数から取得されます。</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">あなたが何か複雑な作業をしている最中に、あなたは無関係ですが明白で些細なバグを見つけました。続行する前に修正してください。&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;を使用して作業の現在の状態を保存し、バグを修正した後（または、必要に応じて別のブランチで実行してから戻った後で）、進行中の変更をunstashできます。</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">空白で区切られたフィールド。空白の任意の実行をフィールド区切り記号として使用できます（Perlの「 &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; の規則）。</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">許可されたSMTP-AUTHメカニズムのホワイトスペースで区切られたリスト。この設定では、リストされたメカニズムのみを強制的に使用します。例。</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">マージコミットの二分法が線形履歴の二分法よりも難しい理由</target>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; などのパターンのワイルドカード リテラル文字として扱われます。</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">インデックスからリストされたすべてのファイルを作業ディレクトリにコピーします(既存のファイルは上書きしません)。</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">&lt;code&gt;git fetch origin-push&lt;/code&gt; を手動で実行しないと失敗します。もちろん、このメソッドは &lt;code&gt;git fetch --all&lt;/code&gt; を実行するものによって完全に打ち負かされています。その場合、それを無効にするか、次のようなより退屈なことをする必要があります。</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Windowsのみ：標準の入力/出力/エラーハンドルを環境変数で指定されたパスにリダイレクトできます。これは、 &lt;code&gt;CreateProcess()&lt;/code&gt; を介して標準ハンドルを渡す標準的な方法がオプションではないマルチスレッドアプリケーションで特に役立ちます。これは、ハンドルを継承可能としてマークする必要があるためです（その結果&lt;strong&gt;、&lt;/strong&gt;生成された&lt;strong&gt;すべての&lt;/strong&gt;プロセスがそれらを継承し、通常のGit操作をブロックする可能性があります。 ）。主な使用目的は、通信に名前付きパイプを使用することです（例： &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Windowsのみ：他のプロセスを起動する前に設定解除する必要がある環境変数の名前のコンマ区切りリスト。Git for Windowsが独自のPerlインタープリターの使用を要求するという事実を考慮して、デフォルトは &lt;code&gt;PERL5LIB&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Windowsのみ：生成されたプロセスが標準のファイルハンドル（ &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; および &lt;code&gt;stderr&lt;/code&gt; ）のみを継承するか、すべてのハンドルを継承するかをオーバーライドします。することができ &lt;code&gt;auto&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。デフォルトは &lt;code&gt;auto&lt;/code&gt; です。これは、Windows 7以降では &lt;code&gt;true&lt;/code&gt; 、古いWindowsバージョンでは &lt;code&gt;false&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">abbrevを0に設定すると、このコマンドを使用して、サフィックスを付けずに最も近いタグ名を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">allを使うと、コマンドはブランチヘッドを参照として使うことができるので、出力には参照パスも表示されます。</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">batchまたは--batch-checkで、 tree-ish:path-in-tree形式の拡張SHA-1式を持つオブジェクトをリクエストする際に、リポジトリ内のシンボリックリンクをたどるようにします。リンク自体に関する出力を提供する代わりに、リンク先のオブジェクトに関する出力を提供してください。シンボリックリンクが tree-ish の外側を指している場合 (例えば /foo へのリンクや ../foo へのルートレベルのリンク)、リンクのうちツリーの外側にある部分が出力されます。</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">no-commit を指定すると、マージコミットを作成する直前にマージを実行して停止し、コミット前にマージ結果を確認したり、さらに微調整したりする機会をユーザーに与えます。</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">no-logでは、マージされる実際のコミットから一行の説明をリストアップしないようにします。</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">no-signoffでは、Signed-off-by行を追加しません。</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">no-squash を指定すると、マージを実行して結果をコミットします。このオプションを使用すると、-squash を上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">-squashでは、--commitは許可されておらず、失敗します。</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">n または --no-stat を指定すると、マージの最後に diffstat を表示しません。</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 、代わりに既存のURLを変更するので、新しいURLが追加されます。</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 、代わりに現在追跡ブランチのリストを置き換えるので、そのリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; フラグ、局所的に存在するすべての参考文献は、リモート側に転送されます。このフラグを使用する場合、 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; を指定することはできません。</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 、リモートのためのすべてのURLが表示されます。</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 、命名含んのみを示す枝は（が、他の言葉で、その先端コミットという名前のコミットの子孫である枝）は、コミット &lt;code&gt;--no-contains&lt;/code&gt; 反転して。 &lt;code&gt;--merged&lt;/code&gt; 、唯一の枝が名前のコミットにマージ（すなわち、先端がコミットコミットという名前から到達可能な枝）が表示されます。 &lt;code&gt;--no-merged&lt;/code&gt; という名前のリストに表示されますコミットにマージされていないだけで枝を。&amp;lt;commit&amp;gt;引数がない場合は、デフォルトで &lt;code&gt;HEAD&lt;/code&gt; （つまり、現在のブランチの先端）になります。</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">&lt;code&gt;--create-reflog&lt;/code&gt; 、更新-refは1が通常作成されない場合でも、各参照用REFLOGを作成します。</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">&lt;code&gt;--delete&lt;/code&gt; 、代わりに既存のURLを変更するのでは、すべてのURLが正規表現&amp;lt;URL&amp;gt;リモート&amp;lt;名前&amp;gt;のために削除され、一致します。非プッシュURLをすべて削除しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; オプション、レポートどのような枝が剪定されますが、実際にそれらを整理しません。</target>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">&lt;code&gt;--ff-only&lt;/code&gt; 可能な場合、早送りとしてマージを解決します。不可能である場合、マージを拒否し、ゼロ以外のステータスで終了します。</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">&lt;code&gt;--ff&lt;/code&gt; 、可能な場合は解決早送りなどのマージ（のみマージされたブランチに一致するように分岐ポインタを更新し、コミットマージを作成しないでください）。できない場合（マージされた履歴が現在の履歴の子孫でない場合）、マージコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">では &lt;code&gt;--force&lt;/code&gt; 、早送りチェックは、すべてのレフリーのために無効になっています。</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--keep-cr&lt;/code&gt; 、呼び出し &lt;code&gt;git mailsplit&lt;/code&gt; （参照&lt;a href=&quot;git-mailsplit&quot;&gt;[1]のgit-mailsplitを&lt;/a&gt;行の末尾にCR剥離を防止するために、同じオプションを使用して）。 &lt;code&gt;am.keepcr&lt;/code&gt; 構成変数を使用して、デフォルトの動作を指定できます。 &lt;code&gt;--no-keep-cr&lt;/code&gt; は、 &lt;code&gt;am.keepcr&lt;/code&gt; をオーバーライドするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">&lt;code&gt;--no-ff&lt;/code&gt; 、マージではなく早送りとして解決することができた場合でも、すべての場合にコミットマージを作成します。</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">&lt;code&gt;--no-tags&lt;/code&gt; オプション、 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; リモートリポジトリからではないインポートタグを行います。</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">では &lt;code&gt;--patch&lt;/code&gt; 、あなたが対話的にHEADとスタッシュする作業ツリー間の差分からハンクを選択することができます。 stashエントリーは、そのインデックス状態がリポジトリのインデックス状態と同じになるように構築され、そのワークツリーには、インタラクティブに選択した変更のみが含まれます。次に、選択した変更がワークツリーからロールバックされます。 &lt;code&gt;--patch&lt;/code&gt; モードの操作方法については、&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;の「インタラクティブモード」セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; 以外のフォーマット &lt;code&gt;oneline&lt;/code&gt; と &lt;code&gt;reference&lt;/code&gt; （明白な理由のために）、これは、出力がREFLOGから採取された情報の2本の余分な線を有するようにします。いくつかのルールに応じて、出力のreflog指定子は &lt;code&gt;ref@{Nth}&lt;/code&gt; （ &lt;code&gt;Nth&lt;/code&gt; はreflogの逆時系列インデックス）または &lt;code&gt;ref@{timestamp}&lt;/code&gt; （そのエントリのタイムスタンプ付き）として表示されます。</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; オプション、更新されたすべてのリモコンに対して剪定実行します。</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 、プッシュURLは代わりにURLをフェッチするのに操作されています。</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 、プッシュURLはむしろ、URLをフェッチするよりも、照会されます。</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 、更新-refは標準入力と一緒に行うすべての変更をから命令を読み出します。次の形式のコマンドを指定します。</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">&lt;code&gt;--tags&lt;/code&gt; オプション、 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; リモートリポジトリからの輸入すべてのタグを。</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">&lt;code&gt;--topo-order&lt;/code&gt; 、それらは8 6 5 3 7 4 2 1（又は8 7 4 2 6 5 3 1）を示すであろう。2つの並行開発トラックからのコミットが混在して表示されるのを避けるために、一部の古いコミットが新しいコミットの前に表示されます。</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; または &lt;code&gt;--auto&lt;/code&gt; 、リモートは、その決定するために照会さ &lt;code&gt;HEAD&lt;/code&gt; を、シンボリック-refの &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 同じ枝に設定されています。たとえば、リモート &lt;code&gt;HEAD&lt;/code&gt; が &lt;code&gt;next&lt;/code&gt; を指している場合、「 &lt;code&gt;git remote set-head origin -a&lt;/code&gt; 」は、symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; を &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; に設定します。これは、 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; がすでに存在する場合にのみ機能します。そうでない場合は、最初にフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; フラグ、それが確認した後、それはまだ&amp;lt;OLDVALUE&amp;gt;含まれた&amp;lt;ref&amp;gt;という名前が削除されます。</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; または &lt;code&gt;--delete&lt;/code&gt; 、シンボリック参照 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 削除されます。</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; オプション、 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; リモート情報が設定された直後に実行されます。</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">&lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; オプション、シンボリック-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 、リモートの時点までに設定されている &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; ブランチ。set-headコマンドも参照してください。</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; オプションは、リモートヘッドが最初に照会されていない &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; 。代わりに、キャッシュされた情報が使用されます。</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">&lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; オプション、代わりにデフォルトグロブrefspec下のすべてのブランチを追跡するために、リモートのための &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; 名前空間、唯一追跡するrefspec &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 作成されます。あなたはより多くのものよりも与えることができます &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; すべての枝をつかむことなく、複数のブランチを追跡します。</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; を使用すると、同じ（&amp;lt;token&amp;gt;、&amp;lt;value&amp;gt;）ペアを持ついくつかのトレーラーがすでにメッセージ内にある場合でも、新しいトレーラーが追加されます。</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; を使用すると、新しいトレーラーが追加されます。</target>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">で &lt;code&gt;add&lt;/code&gt; 、名前の新しいブランチを作成 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; から始まる &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 、およびチェックアウト &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 新しい作業ツリーに。場合は &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; HEADに、そのデフォルトは省略されています。デフォルトでは、 &lt;code&gt;-b&lt;/code&gt; は、新しいブランチがすでに存在する場合、その作成を拒否します。 &lt;code&gt;-B&lt;/code&gt; はこのセーフガードを無効にし、 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; にリセットします。</target>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 、新しい作業ツリー内のデタッチHEAD。&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]の&lt;/a&gt;「DETACHED HEAD」を参照してください。</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; を使用すると、フィードバックメッセージを抑制します。</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">&lt;code&gt;addIfDifferent&lt;/code&gt; 、新たなトレーラは、同じ（&amp;lt;トークン&amp;gt;、&amp;lt;値&amp;gt;）ペアがメッセージ内に既にあるとはトレーラ場合に追加されます。</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">&lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; 、新しいトレーラーは同じとはトレーラーが（&amp;lt;トークン&amp;gt;、&amp;lt;値&amp;gt;）ペアが新しいトレーラーが追加される行の上または下でない場合にのみ追加されます。</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 、何も行われません。</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 、何も行われません。メッセージに同じ&amp;lt;token&amp;gt;のトレーラがすでに存在する場合、新しいトレーラは追加されません。</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">&lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; （またはその変異体、例えばで &lt;code&gt;--cover-letter&lt;/code&gt; または使用 &lt;code&gt;Z..C&lt;/code&gt; の代わり &lt;code&gt;-3 C&lt;/code&gt; の範囲を指定する）、ベース・ツリー情報ブロックがで示されています次のように、コマンドが出力する最初のメッセージの終わり（最初のパッチまたはカバーレターのいずれか）。</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 、スクリプトのための簡単に解析形式で出力。この形式は、Gitのバージョン全体で、ユーザーの設定に関係なく安定したままです。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 、作業ツリーがロックされている理由を説明。</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 、何も削除しないでください。削除するものを報告してください。</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 、唯一の&amp;lt;時間&amp;gt;より古い未使用の作業ツリーを失効します。</target>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 、すべての削除を報告します。</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">で &lt;code&gt;replace&lt;/code&gt; 、&amp;lt;トークン&amp;gt;と同じで、既存のトレーラーが削除され、新しいトレーラーが追加されます。削除されたトレーラーは、新しいトレーラーが追加される場所に最も近い（同じ&amp;lt;token&amp;gt;を持つ）トレーラーになります。</target>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">&lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 、無し &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 、代わりに、遠隔のベース名に一致正確に一つにおけるトラッキング分岐が存在する場合、先頭から新しいブランチを作成する &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; は、リモート・トラッキングに新しいブランチ、ベースブランチ、およびリモートトラッキングブランチを新しいブランチの「上流」としてマークします。</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">Git bisectを使用すると、それは簡単です。最良の場合、自動化された方法で、20〜30分で〜15ステップのカーネルの2等分を行うことができます。手動のヘルプがあっても、複数の重複するバグを二分する場合でも、1時間を超えることはめったにありません。</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; または &lt;code&gt;-D&lt;/code&gt; オプション、 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 削除されます。削除するブランチを複数指定できます。ブランチに現在reflogがある場合、reflogも削除されます。</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; または &lt;code&gt;-M&lt;/code&gt; オプション、&amp;lt;oldbranch&amp;gt; &amp;lt;newbranch&amp;gt;に変更されます。&amp;lt;oldbranch&amp;gt;に対応するreflogがある場合は、&amp;lt;newbranch&amp;gt;と一致するように名前が変更され、ブランチの名前変更を記憶するためにreflogエントリが作成されます。&amp;lt;newbranch&amp;gt;が存在する場合は、-Mを使用して、名前の変更を強制する必要があります。</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">小さなグループでは、開発者は中央のメンテナを必要とせずに、互いのリポジトリから変更をプルするだけで済みます。</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">オプションの &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 引数を指定した場合、refを使用して、表示するメモを検索します。refは、 &lt;code&gt;refs/notes/&lt;/code&gt; で始まる完全なrefnameを指定できます。 &lt;code&gt;notes/&lt;/code&gt; で始まる場合は、 &lt;code&gt;refs/&lt;/code&gt; 、それ以外の場合は &lt;code&gt;refs/notes/&lt;/code&gt; が接頭辞として付けられ、refの完全な名前が形成されます。</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">オプションの引数を指定すると、代わりに別のコミットに戻ることができます。</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">一元化されたリビジョン管理システムでは、1つのリポジトリにすべてのモジュールを含めることでこれを実現しています。開発者はすべてのモジュールをチェックアウトしたり、作業に必要なモジュールだけをチェックアウトしたりすることができます。また、一つのコミットで複数のモジュールにまたがるファイルを修正しながら、物を移動させたり、APIや翻訳を更新したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">引数を指定しない場合、既存のリモコンのリストを表示します。リモコンの操作を行うために、いくつかのサブコマンドが利用できます。</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">引数なしで、既存のサブモジュールの状態を表示します。サブモジュールに対する操作を実行するために、いくつかのサブコマンドが利用可能です。</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">議論がなければ、これは</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">オプションを指定せず、COMMANDまたはGUIDEを指定しない場合、 &lt;code&gt;git&lt;/code&gt; コマンドの概要と最もよく使用されるGitコマンドのリストが標準出力に出力されます。</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">git.git current tree のようなもので、私は取得します。</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">この設定では、リポジトリを閲覧するためのフルパスが必要になります。</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">&lt;code&gt;--append&lt;/code&gt; オプションを使用すると、既存のコミットグラフファイルに存在するすべてのコミットを含めます。</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">&lt;code&gt;--branch&lt;/code&gt; それは（例えば新しいブランチを作成する場合）、有効な支店名として使用できるのであればオプション、コマンドは名前とチェックを取ります。ただし、切り離されたHEAD状態を参照する可能性がある前述のチェックアウト構文を使用する場合は注意が必要です。ルール &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implementsは、 &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; 内容よりも厳しい場合があります（たとえば、refコンポーネントの先頭にダッシュが表示される場合がありますが、明示的にブランチ名の先頭では禁止されています）。リポジトリで &lt;code&gt;--branch&lt;/code&gt; オプションを指定して実行すると、「以前のチェックアウト構文」 &lt;code&gt;@{-n}&lt;/code&gt; の入力が最初に展開されます。たとえば、 &lt;code&gt;@{-1}&lt;/code&gt; 「git switch」または「git checkout」操作を使用してチェックアウトされた最後のものを参照する方法です。磁器がこのオプションを使用して、ブランチ名が必要な場所でこの構文を受け入れるようにして、ブランチ名を入力したかのように動作させることができます。例外として、「前回のチェックアウト操作」では、最後にチェックアウトされたN番目のものがブランチではなかった場合に、コミットオブジェクト名が生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--reachable&lt;/code&gt; オプション、新しいはすべて、引用文献から始まるコミットを歩いてグラフをコミット生成します。（ &lt;code&gt;--stdin-commits&lt;/code&gt; または &lt;code&gt;--stdin-packs&lt;/code&gt; と組み合わせることはできません。）</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">&lt;code&gt;--shallow&lt;/code&gt; オプションのみ分割のチェーンの先端コミットグラフファイルをチェックし、グラフをコミットします。</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">&lt;code&gt;--split&lt;/code&gt; オプション、に格納されている複数のコミット・グラフのファイルのチェーンとしてコミットグラフを書く &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; 。まだコミットグラフに含まれていない新しいコミットは、新しい「ヒント」ファイルに追加されます。次のマージ条件が満たされている場合、このファイルは既存のファイルとマージされます。</target>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--stdin-commits&lt;/code&gt; オプション、新しいヘクス内のOIDのリストを、1行に1つのOIDとして、標準入力で指定したコミットから始まる歩いコミットによってグラフをコミット生成します。（ &lt;code&gt;--stdin-packs&lt;/code&gt; または &lt;code&gt;--reachable&lt;/code&gt; と組み合わせることはできません。）</target>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--stdin-packs&lt;/code&gt; オプション、歩行によって新しいコミットグラフを生成することは、必ず指定のパック、インデックス内のオブジェクト。（ &lt;code&gt;--stdin-commits&lt;/code&gt; または &lt;code&gt;--reachable&lt;/code&gt; と組み合わせることはできません。）</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; REFLOG：後に &lt;code&gt;git fetch&lt;/code&gt; 、古い先端 &lt;code&gt;subsystem&lt;/code&gt; である &lt;code&gt;subsystem@{1}&lt;/code&gt; 。後続のフェッチで数が増加します。（&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">上の例では</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">生のファイルデータ (Git は解釈しません)を除いて、高速インポートの入力フォーマットはテキスト (ASCII)ベースです。このテキストベースのフォーマットは、特に Perl や Python、Ruby などの高レベルの言語を使用している場合に、フロントエンドプログラムの開発やデバッグを簡素化します。</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">後者では、任意の手動ビューアを使用できます。詳細については、&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">正しい引数を指定すると、 &lt;code&gt;git diff&lt;/code&gt; は作業ディレクトリと最後のコミット、またはインデックスと最後のコミットの違いも表示できます。</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">3ウェイマージ（デフォルト、 &lt;code&gt;recursive&lt;/code&gt; を含む）を使用するストラテジーでは、両方のブランチで変更が行われ、後で一方のブランチで元に戻された場合、その変更はマージされた結果に存在します。一部の人々はこの行動を混乱させます。これは、マージを実行するときに、個々のコミットではなく、ヘッドとマージベースのみが考慮されるために発生します。したがって、マージアルゴリズムは、元に戻された変更をまったく変更なしと見なし、代わりに変更されたバージョンを置き換えます。</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;git cherry-pick&lt;/code&gt; を使用して、コミットする前にコミットメッセージを編集できます。</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;git gc&lt;/code&gt; はハウスキーピングが必要かどうかを確認します。そうでない場合は、何も実行せずに終了します。</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;git revert&lt;/code&gt; を使用して、復帰をコミットする前にコミットメッセージを編集できます。これは、端末からコマンドを実行する場合のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;git revert&lt;/code&gt; はコミットメッセージエディターを起動しません。</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;merge-recursive&lt;/code&gt; は少し余分な時間を費やして、重要ではない一致行（たとえば、個別の関数からの括弧）が原因で発生することがある誤マージを回避します。マージするブランチが大幅に分岐した場合に使用します。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">このオプションを使用すると、マージコミットの diff 出力では、親と結果の間の差分を一度に一対ずつ表示するのではなく、それぞれの親からマージ結果への差分を同時に表示します。さらに、すべての親から変更されたファイルのみを表示します。</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">このオプションを指定すると、git は出力のすべての refnames、パス、ブロブの内容、コミットやタグのメッセージ、名前、メールアドレスを匿名化されたデータに置き換えます。同じ文字列のふたつのインスタンスが同等に置き換えられます (たとえば、同じ作者を持つふたつのコミットの場合は匿名化された作者は同じですが、元の作者の文字列とは似ても似つかないということになります)。コミット、ブランチ、タグの関係はコミットのタイムスタンプと同様に保持されます (ただし、コミットメッセージと refnames は元のものとは似ていません)。ツリーの相対的な構成は保持されますが (例えば、ルートツリーに 10 個のファイルと 3 個のツリーがある場合、出力も同様に保持されます)、それらのファイル名とファイルの内容は置き換えられます。</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">このオプションを使用すると、移植片によって隠された親はそれにもかかわらずパックされています。</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">このオプションを指定すると、コマンドラインで指定されていない場合に表示されるリビジョンのリストに現在のブランチを含めることができます。</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">これにより、余分なパラメーターなしで &lt;code&gt;git show-branch&lt;/code&gt; を実行すると、主要なブランチのみが表示されます。また、トピックブランチにいる場合は、それも表示されます。</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">これにより、アリスは &lt;code&gt;git fetch&lt;/code&gt; コマンドを使用して「プル」操作の最初の部分を単独で実行できます。次のコマンドを使用して、自分のブランチとマージする必要はありません。</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">リンクされた作業ツリー内で、$ GIT_DIRはこのプライベートディレクトリ（例では &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ）を指すように設定され、$ GIT_COMMON_DIRはメイン作業ツリーの$ GIT_DIRを指すように設定されます（例えば &lt;code&gt;/path/main/.git&lt;/code&gt; ）。これらの設定は、リンクされた作業ツリーの最上位ディレクトリにある &lt;code&gt;.git&lt;/code&gt; ファイルで行われます。</target>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">なければ &lt;code&gt;--all&lt;/code&gt; と任意のなし &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 、ローカル側とリモート側の両方に存在するヘッドが更新されます。</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">&lt;code&gt;--follow-symlinks&lt;/code&gt; がない場合、これらはシンボリックリンク自体に関するデータを出力します。以下の場合は &lt;code&gt;HEAD:link&lt;/code&gt; 、あなたが見ることが</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; がない場合、&amp;lt;src&amp;gt; refは、&amp;lt;dst&amp;gt;が存在しない場合、または&amp;lt;dst&amp;gt;が&amp;lt;src&amp;gt;の適切なサブセット（つまり祖先）である場合にのみリモートに保存されます。「早送りチェック」として知られるこのチェックは、リモート参照を誤って上書きして、そこから他の人のコミットを失うのを防ぐために実行されます。</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">追加構成なしで、現在のブランチと同じ名前を持つ場合、現在のブランチを構成済みのアップストリーム（ &lt;code&gt;remote.origin.merge&lt;/code&gt; 構成変数）にプッシュし、それ以外の場合はプッシュせずにエラーを出力します。</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">オプションの path パラメーターを指定しないと、カレント作業ディレクトリのすべてのファイルとサブディレクトリがアーカイブに含まれます。1つ以上のパスを指定した場合は、これらのパスのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">クレデンシャルヘルパーが定義されていない場合、Git は次のような方法でユーザーにユーザー名とパスワードを尋ねようとします。</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">明確にすることなく &lt;code&gt;--&lt;/code&gt; 、Gitは妥当な推測を行いますが、エラーが発生し、あいまいな場合は明確にするように求められます。たとえば、作業ツリーにHEADというファイルがある場合、 &lt;code&gt;git diff HEAD&lt;/code&gt; はあいまいであり、明確にするために &lt;code&gt;git diff HEAD --&lt;/code&gt; または &lt;code&gt;git diff -- HEAD&lt;/code&gt; いずれかを言わなければなりません。</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; オプションを使用しない場合、「異常な」文字を含むパス名は、構成変数 &lt;code&gt;core.quotePath&lt;/code&gt; で説明されているように引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; オプションを使用しない場合、「異常な」文字を含むパス名は、構成変数 &lt;code&gt;core.quotePath&lt;/code&gt; で説明されているように引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。 &lt;code&gt;-z&lt;/code&gt; を使用すると、ファイル名がそのまま出力され、行はNULバイトで終了します。</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">なしで&lt;em&gt;--More = 1&lt;/em&gt;オプション、&lt;em&gt;gitのショー分岐が&lt;/em&gt;出力されていないだろう&lt;em&gt;[^マスター]&lt;/em&gt;として、コミット&lt;em&gt;[mybranch]は&lt;/em&gt;、両方の共通の祖先であるコミット&lt;em&gt;マスター&lt;/em&gt;と&lt;em&gt;mybranch&lt;/em&gt;ヒント。詳細は&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">このフラグがない場合、 &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; は指定されたパスに関連するコミットを表示し、同じ指定されたパスについて差分を表示します。これにより、指定されたパスに関係するコミットの完全な差分が表示されます。つまり、「&amp;lt;path&amp;gt;&amp;hellip;」はコミットのみを制限し、それらのコミットの差分を制限しません。</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">このオプションがない場合、「異常な」文字を含むパス名は、設定変数 &lt;code&gt;core.quotePath&lt;/code&gt; で説明されているように引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">サードパーティライブラリのワークフロー</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">人為的に分割されたレポのワークフロー</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">デフォルトは HEAD です。</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">複数の作業ディレクトリ設定のメイン作業ディレクトリ用の作業ディレクトリ固有の構成ファイル（&lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">作業ディレクトリ固有の設定ファイル。</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">作業木は、相対的または絶対的な経路によって識別することができます。</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">他の人との連携</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">他者との共同作業、共有リポジトリスタイル</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">署名がファイルから読み込まれる点を除けば、-signature と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">この変数で指定されたファイルの内容が署名として使用されることを除いては、 format.signature と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">&lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; のように機能します。ここで、&amp;lt;remote&amp;gt;は現在のブランチのリモート（または現在のブランチにリモートが構成されていない場合は &lt;code&gt;origin&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">子プロセスをスポーンするコードをラップします。</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">代替オブジェクトストアにパックファイル用のMIDXファイルを書きます。</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">現在の .git フォルダにある packfiles 用の MIDX ファイルを書きます。</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">配管の使い方やスクリプトの書き方の章を書きましょう。</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">フェッチ後にコミットグラフを書きます。これは、構成設定 &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">packfiles で見つかったコミットを元にコミットグラフファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; から到達可能なコミットとともに、現在のコミットグラフファイル内のすべてのコミットを含むコミットグラフファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">到達可能なすべてのコミットを含むコミットグラフファイルを書きます。</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">ローカルの &lt;code&gt;.git&lt;/code&gt; ディレクトリにパックされたコミットのコミットグラフファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; の commitを使用して現在のコミットグラフファイルを拡張し、コミットグラフファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">新しいMIDXファイルを書きます。</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">再パックの一部として到達可能性ビットマップインデックスを記述します。これは、ビットマップが到達可能なすべてのオブジェクトを参照できる必要があるため、 &lt;code&gt;-a&lt;/code&gt; または &lt;code&gt;-A&lt;/code&gt; とともに使用する場合にのみ意味があります。このオプションは、 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; の設定をオーバーライドします。複数のパックファイルが作成されている場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; サブコマンドに続く引数のリストとして指定されているように、一連のパターンをスパースチェックアウトファイルに書き込みます。新しいパターンに一致するように作業ディレクトリを更新します。core.sparseCheckout構成設定がまだ有効になっていない場合は、有効にします。</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Git のコミットグラフファイルを書き込んで検証する</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">マルチパックインデックスの書き込みと検証</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">ぶら下がっているオブジェクトを .git/lost-found/commit/または .git/lost-found/other/に書き出します。オブジェクトが blob の場合は、オブジェクト名ではなく中身がファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">作成されたファイルの名前を判別するために&amp;lt;base-name&amp;gt;を使用して、ファイルのペア（.packおよび.idx）に書き込みます。このオプションを使用すると、ペアの2つのファイルが&amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;。{pack、idx}ファイルに書き込まれます。&amp;lt;SHA-1&amp;gt;は、パックの内容に基づくハッシュであり、コマンドの標準出力に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">マルチパックインデックス(MIDX)ファイルの書き込みまたは検証。</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">&lt;code&gt;get-mark&lt;/code&gt; 、 &lt;code&gt;cat-blob&lt;/code&gt; 、および &lt;code&gt;ls&lt;/code&gt; クエリに対する応答を、 &lt;code&gt;stdout&lt;/code&gt; ではなくファイル記述子&amp;lt;fd&amp;gt;に書き込みます。可能に &lt;code&gt;progress&lt;/code&gt; エンドユーザのために意図出力が他の出力から分離されます。</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">アーカイブをstdoutではなく&amp;lt;file&amp;gt;に書き込みます。</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">生成 し たパック イ ンデ ッ ク ス を指定 し た フ ァ イ ルへ書 き 込みます。このオプションを指定しないと、パックインデックスファイルの名前は、パックされたアーカイブファイルの名前を .pack を .idx に置き換えて作成されます (パックされたアーカイブの名前が .pack で終わらない場合はプログラムは失敗します)。</target>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">パックの内容(.packファイルに書き込まれていたであろうもの)を標準出力に書き出します。</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">結果のインデックスを名前付きのディスク上のフォーマットバージョンで書き出します。サポートされているバージョンは2、3、4です。現在のデフォルトバージョンは2または3で、 &lt;code&gt;git add -N&lt;/code&gt; などの追加機能が使用されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">標準エラーに書き込みます。 &lt;code&gt;--detach&lt;/code&gt; が指定されている場合、プロセスは実際の標準エラーから切断され、この宛先は事実上 &lt;code&gt;none&lt;/code&gt; と同等になります。</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">&lt;code&gt;git-daemon&lt;/code&gt; 識別子を使用して、syslogに書き込みます。</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">必要なメッセージを書き込んでください。 &lt;code&gt;#&lt;/code&gt; で始まるすべての行が削除され、残りは変更のコミットメッセージとして使用されます。この時点で結局何もコミットしたくないと判断した場合（引き続き編集とインデックスの更新を行うことができます）、空のメッセージを残すことができます。そうでなければ、 &lt;code&gt;git commit&lt;/code&gt; が変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">サブディレクトリ &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; を表すツリーオブジェクトを書き込みます。これは、指定されたサブディレクトリにあるサブプロジェクトのツリーオブジェクトを書き込むために使用できます。</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">転送が完了した後、ローカルエンドの$ GIT_DIR / refs / &amp;lt;filename&amp;gt;の下のファイル名にcommit-idを書き込みます。</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X:&quot;不明&quot; の変更タイプ (ほとんどがバグでしょう。報告してください)</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">したがって、dcommitを実行するブランチの最新のコミットがマージの &lt;code&gt;first&lt;/code&gt; 親であることを確認する &lt;code&gt;must&lt;/code&gt; があります。そうでない場合、特に最初の親が同じSVNブランチの古いコミットである場合、混乱が生じます。</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">選択が一意である限り、上記の &lt;code&gt;c&lt;/code&gt; または &lt;code&gt;clean&lt;/code&gt; と言うこともできます。</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">選択が一意である限り、上記の「 &lt;code&gt;s&lt;/code&gt; 」、「 &lt;code&gt;sta&lt;/code&gt; 」、または「 &lt;code&gt;status&lt;/code&gt; 」と言うこともできます。</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">また、 &lt;code&gt;cvs commit&lt;/code&gt; が機能するためには、各リポジトリが（Gitインデックスファイルなしで）「ベア」であることを確認する必要があります。&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">また、スーパープロジェクトに記録されたコミットを超えてサブモジュール内のブランチを巻き戻してはいけません。</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">あなたは幸運にも何かに取り組んでおり、これらのファイルの変更が順調であることがわかります。 &lt;code&gt;git diff&lt;/code&gt; を実行するときにそれらを表示したくないのは、他のファイルで作業する予定であり、これらのファイルでの変更が煩わしいためです。</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">あなたはリファクタリングセッションの最中で、上司がやって来て、すぐに何かを修正するように要求します。通常は&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;を使用して変更を一時的に保存しますが、作業ツリーは（新しいファイル、移動されたファイル、削除されたファイル、その他の断片が散らばって）混乱した状態にあります。それを邪魔する危険を冒したくない。代わりに、一時的なリンクされた作業ツリーを作成して緊急修正を行い、完了時に削除してから、以前のリファクタリングセッションを再開します。</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">これでコミットする準備ができました。--cachedオプションを指定した &lt;code&gt;git diff&lt;/code&gt; を使用して、コミットされる内容を確認できます。</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">gitweb で生成されたページがどのように見えるかは、以下に説明する変数を使って調整することができます。サイト名を変更したり、すべてのページに共通のヘッダやフッタを追加したり、メインページ (プロジェクト一覧ページ)にこの gitweb インストールの説明を追加したりすることができます。</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">git log にパッチを表示させることもできます。</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;origin/todo&lt;/code&gt; を直接チェックアウトして確認したり、1回限りのパッチを作成したりすることもできます。&lt;a href=&quot;#detached-head&quot;&gt;分離ヘッドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">インタラクティブなリベースでパッチシリーズを編集することもできます。これは、&lt;a href=&quot;#reordering-patch-series&quot;&gt; &lt;code&gt;format-patch&lt;/code&gt; &lt;/a&gt;を使用して一連のパッチを並べ替えるのと同じなので、好きなインターフェイスを使用します。</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">他のリポジトリからブランチを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">最初のコミットが2番目の祖先であるとは限らない場合、 &lt;code&gt;git log&lt;/code&gt; にコミットの「範囲」を与えることもできます。たとえば、ブランチ「stable」と「master」のヒントが共通のコミットから少し前に分岐した場合、</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">自分のコミット名をつけることもできます。</target>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">環境変数 &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; 、 &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 、および &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; を空でない値に設定することで、実行時にgitweb構成ファイルの場所をオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">また、以前の変更を戻すこともできます(例えば、次の変更など)。</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; をinetdサービスとして実行することもできます。詳細は&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]の&lt;/a&gt; manページをご覧ください。（特に例のセクションを参照してください。）</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">また、それがどのような参照を提供しているかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">また、範囲表記を使用して、1つのコミットだけではなく、コミットの範囲をスキップすることもできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;を使用して、クローン元以外のリポジトリからブランチを追跡することもできます。</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">また、使用することができます&lt;a href=&quot;git-gui&quot;&gt;[1]のgit-guiのを&lt;/a&gt; diffの塊を右クリックして（コミット、インデックス内のビューの変更と作業ツリーのファイルを作成し、個別のインデックスに含めるためのハンクを選択し、「ステージハンクの場合を選びますコミット&quot;）。</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">&lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; を使用してA、B、Cのパッチを生成することもできます。P、X、Y、Zの識別子は最初のメッセージの最後に追加されます。</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">&lt;code&gt;git show&lt;/code&gt; を使用して、そのようなファイルを表示することもできます。</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">単一の親とのコミットを維持したくない場合で、ツリーに変更を加えない場合は、 &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; 代わりにgit_commit_non_empty_tree &quot;$ @&quot;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">いつでも元の &lt;code&gt;master&lt;/code&gt; ブランチに戻ることができます</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">最初に正しいリビジョンをチェックアウトするだけで、常に古いバージョンのファイルを表示することができます。しかし、何もチェックアウトせずに古いバージョンのファイルを見ることができる方が便利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">プロジェクト履歴の任意のポイントを選択し、そのオブジェクトのSHA-1名を &lt;code&gt;.git/refs/heads/&lt;/code&gt; 下のファイルに書き込むだけで、いつでも新しいブランチを作成できます。任意のファイル名（および実際にはサブディレクトリ）を使用できますが、 &quot;通常の&quot;ブランチは &lt;code&gt;master&lt;/code&gt; と呼ばれています。ただし、これは単なる慣例であり、強制するものはありません。</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; ファイルの名前を指定することを選択できます。このファイルのURLは、リポジトリへのアクセスに使用されます。このファイルの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; ファイルの名前を指定することを選択できます。このファイルのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このファイルのrefspecがデフォルトとして使用されます。このファイルの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;、&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;使用して、または &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ファイルを手動で編集して、以前に構成したリモートの名前を提供することを選択できます。このリモートのURLは、リポジトリへのアクセスに使用されます。コマンドラインでrefspecを指定しない場合、このリモートのrefspecがデフォルトで使用されます。構成ファイルのエントリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">（ &lt;code&gt;--cached&lt;/code&gt; フラグを使用して）インデックスファイルを完全に信頼するか、統計状態に一致しないファイルを「一時的に変更された」として表示するように差分ロジックに要求するかを選択できます。これらの操作はどちらも非常に便利です。</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">gitweb構成ファイルの &lt;code&gt;$export_ok&lt;/code&gt; 変数を使用して、明示的にエクスポートされたリポジトリーのみをリストして表示できるようにgitwebを構成できます。&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]の&lt;/a&gt;マンページを参照してください。trueと評価された場合、gitwebは &lt;code&gt;$export_ok&lt;/code&gt; 指定されたこのファイルがオブジェクトデータベースに存在する場合にのみリポジトリを表示します（ディレクトリに &lt;code&gt;$export_ok&lt;/code&gt; という名前のマジックファイルがある場合）。</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Gitリポジトリーの &lt;code&gt;GIT_DIR&lt;/code&gt; にファイルを作成するか、リポジトリー構成変数（ &lt;code&gt;GIT_DIR/config&lt;/code&gt; で&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）を設定して、gitwebに表示される個々のリポジトリーを構成できます。</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">データベースのバックエンドは、以下の構成変数で構成できます。</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">古いコミットで行ったことを元に戻す新しいコミットを作成することができます。自分のミスがすでに公開されている場合は、これが正しいです。</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">&quot;diff。*。wordRegex&quot;構成変数で適切な正規表現を指定することにより、 &lt;code&gt;git diff --word-diff&lt;/code&gt; が行内の単語を分割するために使用するルールをカスタマイズできます。たとえば、TeXでは、バックスラッシュとそれに続く一連の文字がコマンドを形成しますが、そのようないくつかのコマンドは、空白を介在させることなく一緒に実行できます。それらを分離するには、次のように &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ファイル（または &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ファイル）で正規表現を使用します。</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">filter。&amp;lt;driver&amp;gt; .required構成変数を &lt;code&gt;true&lt;/code&gt; に設定することにより、フィルター自体が使用できないコンテンツを使用可能なコンテンツに変換することを宣言できます。</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">このようなブランチは、インタラクティブなリベースを使えば、Gitで簡単に作成することができます。</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">更新フックを使用して、よりきめ細かい権限を適用できます。&lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;更新フックを使用したブランチへのアクセスの制御を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">ぶら下がっているコミットの一つは、例えば、次のような方法で調べることができます。</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">このようなインデックスの状態は、 &lt;code&gt;git ls-files --unmerged&lt;/code&gt; コマンドで確認できます。例：</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">さまざまなヘルパーツールを使用して、オブジェクトデータベースとインデックスで表されるデータを調べることができます。すべてのオブジェクトについて、&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt;を使用してオブジェクトの詳細を調べることができます。</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">構成変数 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 設定することにより、ツールへの完全パスを明示的に提供できます。たとえば、 &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; を設定することにより、kdiff3への絶対パスを構成できます。それ以外の場合、 &lt;code&gt;git difftool&lt;/code&gt; は、ツールがPATHで使用できると想定します。</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">構成変数 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 設定することにより、ツールへの完全パスを明示的に提供できます。たとえば、 &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; を設定することにより、kdiff3への絶対パスを構成できます。それ以外の場合、 &lt;code&gt;git mergetool&lt;/code&gt; は、ツールがPATHで使用できると想定します。</target>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">構成変数 &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 設定することで、優先manビューアへのフルパスを明示的に提供できます。たとえば、 &lt;code&gt;man.konqueror.path&lt;/code&gt; を設定することで、konquerorへの絶対パスを設定できます。それ以外の場合、 &lt;code&gt;git help&lt;/code&gt; は、ツールがPATHで使用できると想定します。</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">すべてのTテストケースがすべてのN構成に合格することをいくつかのポイント（たとえば、rcおよびベータリリース）で確認することに集中できます。また、一部のテストに合格しない場合は、「git bisect」（またはより優れた「git bisect run」）を使用できます。したがって、大まかに実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;bisect start&lt;/code&gt; コマンドを発行するときにパスパラメータを指定することで、追跡している問題にツリーのどの部分が関係しているかがわかっている場合、試行回数をさらに減らすことができます。</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;を使用して、任意の2つのバージョン間の差分を生成できます。</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">gitwebから直接project_indexアクション（プロジェクトリストページの &lt;code&gt;TXT&lt;/code&gt; リンク）を使用して、プロジェクトリストインデックスファイルを生成できます。以下の「gitwebを使用したプロジェクトリストの生成」セクションもご覧ください。</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">以下のコマンドで、プラットフォーム上で利用可能なすべてのエンコーディングのリストを取得できます。</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git bisect terms --term-old&lt;/code&gt; または &lt;code&gt;git bisect terms --term-good&lt;/code&gt; を使用すると、古い（それぞれ新しい）用語のみを取得できます。</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">コマンドに &lt;code&gt;-m&lt;/code&gt; フラグを指定すると、3者間マージを試行できます。</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">古いコミットに戻って修正することができます。Git は通常プロジェクトの &quot;履歴&quot; が変わることを期待していませんし、履歴が変更されたブランチから繰り返しマージを行うことはできません。</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">任意のコミットから新しいブランチを成長させることができます。例えば、&quot;HEAD~3&quot; に切り替えて &quot;fixup&quot; というブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">更新されている &quot;と &quot;作業ディレクトリにまだダーティなまま &quot;のファイルを混在して表示させることができます。更新されている &quot;ファイルは有効な sha1 を示し、&quot;インデックスと同期していない &quot;ファイルは常にすべてゼロの特別な sha1 を持つので、どのファイルがどの状態にあるのかを常に知ることができます。</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">特別な &lt;code&gt;include.path&lt;/code&gt; （または &lt;code&gt;includeIf.*.path&lt;/code&gt; ）変数を含めるファイルの名前に設定することで、別の設定ファイルを含めることができます。変数は値としてパス名を取り、チルド展開の対象となります。これらの変数は複数回指定できます。</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">&lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; 変数を含めるファイルの名前に設定することで、別の条件付きの構成ファイルを含めることができます。</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">read_config_file（）サブルーチンを使用して、他の構成ファイルを組み込むことができます。たとえば、Gitolite（Gitリポジトリ管理ツールの1つ）を介してリポジトリを表示するためのアクセス制御に関連するgitweb構成を、 &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; などの別のファイルに配置することができます。それを含めるには、</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">マスターブランチで別の変更を行うことができます。</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">そこに &lt;code&gt;hooks&lt;/code&gt; 設定することで、リポジトリにプッシュするたびに興味深いことが起こります。&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;git show-branch&lt;/code&gt; &lt;code&gt;git merge&lt;/code&gt; 、先ほど行った2つのgitマージの前の状態と一致することを確認できます。次に、2つの &lt;code&gt;git merge&lt;/code&gt; コマンドを続けて実行する代わりに、これらの2つのブランチヘッドをマージします（これは &lt;code&gt;making an Octopus&lt;/code&gt; と呼ばれます）。</target>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 構成変数を設定することにより、サーバーで行末変換属性を使用してファイルの &lt;code&gt;-k&lt;/code&gt; モードを設定できます。&lt;a href=&quot;gitattributes&quot;&gt;行末変換の&lt;/a&gt;詳細については、gitattributes [5]を参照してください。</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">設定変数 &lt;code&gt;interactive.singleKey&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定することで、ここでreturnを入力する必要を省くことができます。</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">これらのルールは、コマンドラインオプションまたは環境変数によって上書きできます。 &lt;code&gt;--global&lt;/code&gt; 、 &lt;code&gt;--system&lt;/code&gt; と &lt;code&gt;--worktree&lt;/code&gt; オプションはそれぞれグローバル、システム全体またはあたりworktreeファイルに使用されるファイルを制限します。 &lt;code&gt;GIT_CONFIG&lt;/code&gt; の環境変数は、同様の効果を持っていますが、あなたが望む任意のファイル名を指定することができます。</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">git pull」を実行し、潜在的なコンフリクトを解決し、結果を「git push」することができます。git pull」を実行すると、コミットAとコミットBの間にマージコミットCが作成されます。</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">credential.helper設定変数を介してオプションを提供することができます(この例では、キャッシュ時間を5分に落とします)。</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">このコマンドでオプションの問い合わせ/設定/置換/アンセットを行うことができます。名前は実際にはセクションとキーをドットで区切ったもので、値はエスケープされます。</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;を使用して、分岐した2つの開発ブランチに再び参加できます。</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">気が向いたときに、このプライベートリポジトリをリパックすることができます。</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">ステップ 2-4 を複数回繰り返すことで、元のコードを任意の数のコミットに分割することができます。</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">&lt;code&gt;--msg-filter&lt;/code&gt; を使用して、コミットログメッセージを書き換えることができます。例えば、 &lt;code&gt;git svn-id&lt;/code&gt; によって作成されたリポジトリ内の文字列 &lt;code&gt;git svn&lt;/code&gt; この方法で除去することができます。</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">&lt;code&gt;git-bundle verify&lt;/code&gt; を実行して、ベースを使用して作成されたバンドルから抽出できるかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">もう一度 &lt;code&gt;gitk --all&lt;/code&gt; を実行して、コミットの祖先がどのように見えるかを確認するか、 &lt;code&gt;show-branch&lt;/code&gt; を実行してこれを通知できます。</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">これらのルーズオブジェクトを「パックファイル」に移動することにより、スペースを節約し、Gitをより高速にできます。このパックファイルには、オブジェクトのグループを効率的な圧縮形式で格納します。パックファイルのフォーマット方法の詳細はで見つけることができる&lt;a href=&quot;pack-format&quot;&gt;パック形式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">上記がリネームであることがすぐにわかります。</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">これを &lt;code&gt;link&lt;/code&gt; に設定できます。この場合、ハードリンクの後にソースが削除され、オブジェクトの作成によって既存のオブジェクトが上書きされないようにします。</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">&lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; ビルド時設定変数を設定することにより、ビルド時に単一の値（このリストの単一のエントリ/アイテム）を設定できます。デフォルトでは（）、つまり空のリストに設定されています。これは、gitwebがプロジェクト名から（フェッチするために）プロジェクトURLを作成しようとしないことを意味します。</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">許可するディレクトリのリストを指定できます。ディレクトリを指定しない場合は、すべて許可されます。これは追加の制限であり、-export &lt;code&gt;--export-all&lt;/code&gt; も指定されていない限り、 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 構成オプションでgitcvsアクセスを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">各メッセージに追加するメールヘッダ行の指定、件名のプレフィックスとファイルサフィックスのデフォルト、複数のパッチを出力する際のパッチの数、&quot;To:&quot; や &quot;Cc:&quot; ヘッダの追加、添付ファイルの設定、パッチの出力ディレクトリの変更、設定変数を使ったパッチのサインオフなどができます。</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">カスタム &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; を使用して、各オブジェクトに表示される情報を指定できます。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 形式のプレースホルダと、オブジェクトごとに標準出力に文字通りコピーされ &lt;code&gt;%(atom)&lt;/code&gt; 改行に続く拡張します、。使用可能なアトムは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">作業ディレクトリの最上位に &lt;code&gt;.gitignore&lt;/code&gt; というファイルを作成し、次のような内容で特定のファイルを無視するようにGitに指示できます。</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">追跡するディレクトリからGitの内部情報を分割するようにGitに指示できますが、ここではそれを無視します。これは通常のプロジェクトの動作方法ではなく、実際には特別な使用のみを目的としています。したがって、「Git情報は常に、それが記述する作業ツリーに直接結びついている」というメンタルモデルは、技術的には100％正確ではないかもしれませんが、通常のすべての使用に適したモデルです。</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">&lt;code&gt;--test-untracked-cache&lt;/code&gt; オプションを使用すると、ファイルシステムがそれをサポートしているかどうかをテストできます。 &lt;code&gt;--untracked-cache&lt;/code&gt; 暗黙的に使用したオプションは、Gitリポジトリの古いバージョンでは、テストを実行していないが、それはもはやケースです。</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">その後、リベース中にコンフリクトを修正してください。おそらく、メール以外でトピックを公開していないので、リベースしても問題ありません。</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">次に、これらをメールクライアントにインポートして、手動で送信できます。ただし、一度に大量に送信する必要がある場合は、&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;スクリプトを使用してプロセスを自動化することをお勧めします。最初にプロジェクトのメーリングリストを参照して、パッチを提出するための要件を確認してください。</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">次に、次のように発言することで、古い &lt;code&gt;subsystem..topic&lt;/code&gt; ..トピックを新しいヒントに移植できます（reflogの場合、 &lt;code&gt;topic&lt;/code&gt; すでに参加していると想定しています）。</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">これは集合演算と考えることができます。コマンドラインで指定されたコミットは、それらのいずれからも到達可能なコミットのセットを形成し、 &lt;code&gt;^&lt;/code&gt; の前に指定されたいずれかのコミットから到達可能なコミットは、そのセットから差し引かれます。残りのコミットは、コマンドの出力に表示されるものです。他のさまざまなオプションとパスパラメータを使用して、結果をさらに制限できます。</target>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">興味がある場合は、 &lt;code&gt;git prune-packed&lt;/code&gt; を実行する前後に &lt;code&gt;find .git/objects -type f&lt;/code&gt; を実行してみてください。また、 &lt;code&gt;git count-objects&lt;/code&gt; は、リポジトリ内にアンパックされたオブジェクトの数と、それらが消費している容量を示します。</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">最初に変更をコミットし、次に &lt;code&gt;git push&lt;/code&gt; コマンドを使用することにより、変更を共有リポジトリに反映できます。</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;を使用して、BLOBの内容を調べることができます。たとえば、上のツリーから &lt;code&gt;COPYING&lt;/code&gt; のエントリのblobを取得します。</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">作業ツリーの変更から2つ以上のコミットを行い、コミットする前に各変更をテストする場合は、 &lt;code&gt;git stash push --keep-index&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">次のように、 &lt;code&gt;git stash&lt;/code&gt; を使用して上記を簡略化できます。</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">&lt;code&gt;stable-1&lt;/code&gt; を使用して、コミット1b2e1d63ffを参照できます。</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">時間を基準にした根拠を使うことができます。</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">両方に存在するタグを使用することができます。</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">さまざまな &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; 値を使用して、この動作を制御できます。</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">人間が読めるバンドルの置き換え（&lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]を&lt;/a&gt;参照）として、または履歴の書き換えを行うために &lt;code&gt;git fast-import&lt;/code&gt; にフィードする前に編集できる形式（ツールに依存する機能）として使用できます。以下のような &lt;code&gt;git filter-repo&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">gitweb で mod_perl を使うことができます。このサポートを有効にするには、Apache::Registry (mod_perl 1.x 用)または ModPerl::Registry (mod_perl 2.x 用)をインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">コミットが書かれた時点では利用できなかった情報で注釈を追加するためにノートを利用することができます。</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">空のrefパーツで &lt;code&gt;@&lt;/code&gt; 構文を使用すると、現在のブランチのreflogエントリを取得できます。たとえば、ブランチ &lt;code&gt;blabla&lt;/code&gt; を使用している場合、 &lt;code&gt;@{1}&lt;/code&gt; は &lt;code&gt;blabla@{1}&lt;/code&gt; と同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">あなたは使用することができます &lt;code&gt;@{-N}&lt;/code&gt; 「gitのチェックアウト」操作を使用してチェックアウトしたコミット/ N番目の最後のブランチを参照するように構文を。 &lt;code&gt;@{-1}&lt;/code&gt; と同義の &lt;code&gt;-&lt;/code&gt; を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">&lt;code&gt;@{-N}&lt;/code&gt; 構文を使用すると、「git switch」または「git checkout」操作を使用して切り替えられた最後のN番目のブランチ/コミットを参照できます。 &lt;code&gt;@{-1}&lt;/code&gt; と同義の &lt;code&gt;-&lt;/code&gt; を指定することもできます。これは、2つのブランチ間をすばやく切り替えるため、または誤ってブランチの切り替えを元に戻すためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">&lt;code&gt;gitweb.owner&lt;/code&gt; リポジトリ設定変数を使用して、リポジトリの所有者を設定できます。プロジェクトリストと概要ページに表示されます。</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Apacheに付属の &lt;code&gt;htpasswd&lt;/code&gt; 機能を使用してこれらのファイルを作成できますが、ApacheのMD5 cryptメソッドは、ほとんどのCライブラリのcrypt（）関数で使用されるメソッドとは異なるため、-mオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">このフィルターでは、 &lt;code&gt;map&lt;/code&gt; の便利な関数やその他の便利な関数も使用できます。たとえば、 &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; を呼び出すと、現在のコミットが除外されます（ただし、変更は含まれません！必要に応じて、代わりに &lt;code&gt;git rebase&lt;/code&gt; を使用してください）。</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">リポジトリには以下のファイルがあります。</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">コミット数を使うことができます。</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">以下のようなものを使えば、壊れたビルドを自動的に簡単に二分することができます。</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">いくつかのツールを使って葛藤を乗り越えていくことができます。</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">必須のオプションパラメータを、コマンドライン上で別の単語としてオプションに書き込むことができます。つまり、以下の使用法がすべて機能するということです。</target>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">独自のカスタムヘルパーを書いて、クレデンシャルを保持している任意のシステムとインターフェースをとることができます。詳細は credential.h を参照してください。</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">他のオブジェクトストアからオブジェクトを &lt;code&gt;borrow&lt;/code&gt; するために、 &lt;code&gt;objects/info/alternates&lt;/code&gt; または &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; メカニズムを使用している可能性があります。この種の不完全なオブジェクトストアを持つリポジトリは、ダムトランスポートで使用するために公開するのには適していませんが、それ以外の場合は、 &lt;code&gt;objects/info/alternates&lt;/code&gt; 借用するオブジェクトストアを指している限り問題ありません。</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">ブランチを必要な数だけローカルリポジトリに保持し、ブランチ間でマージするのと同じように&lt;em&gt;git pull&lt;/em&gt;でそれらをマージすることにより、ブランチをまったく使用せずに実行できます。このアプローチの利点は、各 &lt;code&gt;branch&lt;/code&gt; のファイルのセットをチェックアウトしたままにできることであり、複数の開発行を同時に処理する場合は、簡単に切り替えることができます。もちろん、複数の作業ツリーを保持するためにディスク使用量を増やす代償を払うことになりますが、最近のディスク容量は安価です。</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">浅いクローンを作成することで、不完全ではあるがローカルで使用可能なリポジトリを作成できます。&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">e05db0fd 以降のコミットを目視で確認することができます。</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; を省略できます。この場合、コマンドは縮退して「現在のブランチをチェックアウト」します。これは、現在のブランチの追跡情報（存在する場合）のみを表示するというかなり高価な副作用を伴う、栄光のあるノーオペレーションです。</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">コミット時の状態を記述したツリーと親のリストを与えてコミットオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">追跡するバイナリファイルには、行末変換を適用したり、テキストの差分を生成したりしたくありません。以下のように指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; を実行せずにランダムな編集を行います。そして、あなたは彼から引っ張ってからあなたの「上流」ツリーの先端が進んだことに気づきます：</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">実際の作業は、プライマリリポジトリが &lt;code&gt;.git&lt;/code&gt; サブディレクトリとしてぶら下がっている作業ツリーで行います。そのリポジトリにリモートでアクセスできるようにして、そこからプルするようにユーザーに依頼すること&lt;strong&gt;もでき&lt;/strong&gt;ますが、実際には、通常はそうではありません。推奨される方法は、パブリックリポジトリを用意し、他の人がアクセスできるようにし、プライマリ作業ツリーで行った変更が適切な状態になったら、そこからパブリックリポジトリを更新することです。これはしばしば &lt;code&gt;pushing&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">あなたはいくつかのコミットを行いましたが、それらが &lt;code&gt;master&lt;/code&gt; ブランチに入るのは時期尚早であることに気づきました。トピックブランチでそれらを磨き続けたいので、現在の &lt;code&gt;HEAD&lt;/code&gt; から &lt;code&gt;topic/wip&lt;/code&gt; ブランチを作成します。</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">これで最初のGitリポジトリが作成されました。もちろん、空なのでそれはあまり役に立ちませんので、データを入力してみましょう。</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">これで、他の誰かの（私の）リモートリポジトリが正常にコピーされ、チェックアウトされました。</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">myworkへのマージは実行していないため、それは &lt;code&gt;origin&lt;/code&gt; の上にあるパッチの単純な線形シーケンスです。</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; したい場合は、 &lt;code&gt;git pull&lt;/code&gt; の後にgit submodule updateを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">ノードをヘッドとして指定していないため、親のないコミットとルートノードを区別できません。</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">パッチには存在しない新しいコンテンツを追加することもできます。追加された内容は作業ツリーに戻されて表示されます。</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">サードパーティのヘルパーをインストールすることもできます。 &lt;code&gt;git help -a&lt;/code&gt; の出力で &lt;code&gt;credential-*&lt;/code&gt; を検索し、個々のヘルパーのドキュメントを参照してください。ヘルパーを選択したら、その名前をcredential.helper変数に入れることにより、Gitにそれを使用するように指示できます。</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">また、 &lt;code&gt;!&lt;/code&gt; 以前のエントリが非表示としてマークした場合でも、ref名の前にエントリを否定し、明示的にそれを公開します。複数のhideRefs値がある場合、後のエントリは前のエントリをオーバーライドします（より具体的な構成ファイルのエントリは、それほど具体的でないものをオーバーライドします）。</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]を&lt;/a&gt;使用することもできます。これにより、Emacsやkdiff3などの外部ツールを使用して、マージされていないファイルをマージできます。</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">複数のコマンドで &lt;code&gt;--exec&lt;/code&gt; の 1つのインスタンスを使用して、複数のコマンドを実行できます。</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">このオプションは、トピックブランチのマージを元に戻した後に役立つ場合があります。このオプションは、トピックブランチを新しいコミットで再作成し、「元に戻す」を必要とせずに正常に再マージできるためです（&lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-&lt;/a&gt; faulty -mergeのハウツーを参照）。詳細）。</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">ブランチ名の前にプラス記号を付けることで、 &lt;code&gt;git push&lt;/code&gt; で強制的に更新を実行できます。</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">バイセクションのセッション中に、一時的な修正(例えば、ヘッダファイルの中の#define DEBUG 0/#define DEBUG 1/や、「このコミットを持っていないリビジョンは、このバイセクションが興味のない別の問題を回避するために、このパッチを適用する必要がある」など)をテスト対象のリビジョンに適用したいと思うことがよくあるでしょう。</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; オプションを使用してgitコマンドを実行するときに、個々の構成パラメーターをオーバーライドできます。詳細は&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">設定は .git/config で指定することができます。</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">歴史が書き換えられたブランチを公開することもできますし、他の人がそのブランチを調べたりテストしたりするのに役立つかもしれませんが、そのようなブランチを自分の作品の中に引き込もうとしてはいけません。</target>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">「フォルダが存在しない」というエラーが発生した場合は、代わりにfolder = &quot;[Google Mail] / Drafts&quot;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">タグの場合と同じように、これらのリモートトラッキングブランチのいずれかを自分のブランチにビルドしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">このような履歴がある場合など、マージコミットを作り直したほうがいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">新しいタグを公開の Git サーバーにプッシュする必要があります (後述の &quot;DISTRIBUTED WORKFLOWS&quot; を参照ください)。これにより、プロジェクトを追跡している他の人がそのタグを利用できるようになります。このプッシュは、リリース関連のフックをトリガーにして、リリース用のタルボールを作ったり、フォーマット済みのドキュメントページを作成したりといったリリース関連の作業を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">このコマンドを有効にするには、構成変数 &lt;code&gt;rerere.enabled&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">通常は、メジャーリリースなどの署名付きタグのみを実行しますが、軽量タグは、実行したいマーキングに役立ちます。特定のポイントを覚えておきたい場合は、そのタグ用のプライベートタグを作成するだけです。 、その時点での状態のシンボリック名がわかります。</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">頻繁に同じリモートリポジトリと定期的に繰り返しフェッチすることで、それらと対話します。このようなリモートリポジトリの進行状況を追跡するために、 &lt;code&gt;git fetch&lt;/code&gt; では、 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 構成変数を構成できます。</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">このコマンドを直接呼び出したくないでしょう。Gitの他の部分で資格情報ヘルパーとして使用されることを意図しています。参照&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;または &lt;code&gt;EXAMPLES&lt;/code&gt; 以下。</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">このコマンドを直接呼び出したくないでしょう。gitの他の部分で資格情報ヘルパーとして使用されることを意図しています。参照&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;または &lt;code&gt;EXAMPLES&lt;/code&gt; 以下。</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">オブジェクトデータベースから「ツリー」ファイルを読み取り、それを使用して、現在のインデックスにデータを入力します（上書きします。保存していない状態がインデックスに含まれている場合は、これを行わないでください！）。通常の操作は</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">あなたは本当にすべての参照をフィルタリングしました：git-filter-branchを呼び出すときに &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; allを使用してください。</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">blobが存続期間中に移動された場合、ファイル名のすべてのバリアントを本当に削除しました。 &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; は、名前の変更に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">実はGitは、Git自体のソースを調べるのに最適なツールなんですよね!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">&lt;code&gt;git cvsimport&lt;/code&gt; によって作成されたブランチで独自の作業を行うことは&lt;strong&gt;でき&lt;/strong&gt;ません。デフォルトでは、初期インポートにより、CVSリポジトリーのメインブランチから「マスター」ブランチが作成されて、自由に操作できます。その後、増分インポートまたは任意のCVSブランチを自分で &lt;code&gt;git merge&lt;/code&gt; する必要があります。着信ブランチを分離して保護するには、-rを介して名前付きリモートを指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">このコマンドの代わりに &lt;code&gt;dcommit&lt;/code&gt; の使用を検討する必要があります。指定されたコミットまたはツリーオブジェクトをSVNにコミットします。これは、インポートされたフェッチデータが最新であることを前提としています。これは、SVNにコミットするときにパッチを適用しようとする試みをまったく行わず、ツリーまたはコミットで指定されたファイルでファイルを上書きするだけです。すべてのマージは &lt;code&gt;git svn&lt;/code&gt; 関数とは無関係に行われたと見なされます。</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">チェックアウトしたバージョンをコンパイルしてテストしてください。そのバージョンが正常に動作する場合は</target>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">このオプションを悪用して、実質的な変更をマージコミットの中にこっそり入れるのは控えた方が良いでしょう。リリース名やバージョン名をバンプするような小さな修正でも良いでしょう。</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">すでに公開されているコミットを修正する場合は、履歴を書き換えることによる影響を理解する必要があります。（&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]の&lt;/a&gt;「UPSREAM REBASEからのリカバリ」セクションを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">共有するリポジトリで &lt;code&gt;git rebase&lt;/code&gt; を使用することの影響を理解する必要があります。以下のUPSTREAM REBASEからのリカバリーも参照してください。</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">このチュートリアルを読む前に、&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;に目を通してください。</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">そして、/home/me/tmp/file.bundleを別のマシンに転送して、/home/me/tmp/file.bundleを入れ替えて、そこから引っ張ってきます。</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">ファイルを「チェックアウト」することにより、インデックスから作業ディレクトリを更新します。これはあまり一般的な操作ではありません。通常はファイルを更新したままにし、作業ディレクトリに書き込むのではなく、作業ディレクトリの変更についてインデックスファイルに通知します（つまり、 &lt;code&gt;git update-index&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">あなたは個人リポジトリで日々の作業を続けますが、定期的に個人リポジトリからパブリックリポジトリに変更を「プッシュ」し、他の開発者がそのリポジトリからプルできるようにします。つまり、パブリックリポジトリを持つ他の開発者が一人いる状況での変更の流れは次のようになります。</target>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">これらの両方のことをコード全体で見ることができます。</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">ダングリングオブジェクトに関する情報メッセージが表示されます。これらはまだリポジトリに存在するオブジェクトですが、どのブランチからも参照されなくなり、しばらくすると &lt;code&gt;gc&lt;/code&gt; で削除できます（削除されます）。 &lt;code&gt;git fsck --no-dangling&lt;/code&gt; を実行してこれらのメッセージを抑制しても、実際のエラーを表示できます。</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">あなたは、2つのファイルが表示されます &lt;code&gt;pack-*.pack&lt;/code&gt; と &lt;code&gt;pack-*.idx&lt;/code&gt; で、 &lt;code&gt;.git/objects/pack&lt;/code&gt; ディレクトリを。これらは互いに密接に関連しており、何らかの理由で手動で別のリポジトリにコピーした場合は、必ず一緒にコピーしてください。前者はパック内のオブジェクトからのすべてのデータを保持し、後者はランダムアクセス用のインデックスを保持します。</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">それでも、メールなどの他の方法で人々に伝える必要があります。（Gitは&lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt;を提供して、フォーマット済みのプルリクエストを上流のメンテナーに送信して、このタスクを簡素化します。）</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">通常、この最後の手順を実行するには、提供されている &lt;code&gt;git merge-one-file&lt;/code&gt; で &lt;code&gt;git merge-index&lt;/code&gt; を使用します。スクリプトは、各パスをマージするとき、およびマージが正常に終了したときに、作業ツリー内のファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">gitweb設定ファイルで変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">現在のインデックスファイルを「ツリー」オブジェクトに書き出します。</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">これで作業ディレクトリが初期化されました。「。git」という名前の新しいディレクトリが作成されていることに気付くでしょう。</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">これで、最初の実際のGitコミットが完了しました。そして、あなたが &lt;code&gt;git commit&lt;/code&gt; が実際に何をしているのかに興味があるなら、自由に調査してください：それは有用な（？）コミットメッセージヘッダーを生成するいくつかの非常にシンプルなシェルスクリプトと、実際にコミット自体を行ういくつかのワンライナーです（ &lt;code&gt;git commit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">これであなたの「パブリックリポジトリ」は変更を受け入れる準備ができました。プライベートリポジトリを持っているマシンに戻ってください。そこから、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">プライベートリポジトリのGitディレクトリは通常 &lt;code&gt;.git&lt;/code&gt; ですが、パブリックリポジトリは多くの場合、プロジェクト名（ &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; )にちなんで名付けられます。プロジェクト &lt;code&gt;my-git&lt;/code&gt; のそのようなパブリックリポジトリを作成してみましょう。リモートマシンにログインした後、空のディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">作業ツリーはまだHEAD（$ JC）に基づいていますが、それ以降の編集があります。 3者間マージでは、$ JC以降にインデックスエントリを追加または変更していないことを確認します。追加していない場合は、正しいことを行います。したがって、次のシーケンスで：</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">ゼロ以上の &lt;code&gt;filemodify&lt;/code&gt; 、 &lt;code&gt;filedelete&lt;/code&gt; 、 &lt;code&gt;filecopy&lt;/code&gt; 、 &lt;code&gt;filerename&lt;/code&gt; 、 &lt;code&gt;filedeleteall&lt;/code&gt; および &lt;code&gt;notemodify&lt;/code&gt; コマンドを含めて、コミットを作成する前にブランチの内容を更新できます。これらのコマンドは任意の順序で指定できます。ただし、 &lt;code&gt;filerename&lt;/code&gt; はブランチを &lt;code&gt;filedeleteall&lt;/code&gt; 消去するため（以下を参照）、同じコミット内ですべての &lt;code&gt;filemodify&lt;/code&gt; 、 &lt;code&gt;filecopy&lt;/code&gt; 、filerename、および &lt;code&gt;notemodify&lt;/code&gt; コマンドの前に &lt;code&gt;filedeleteall&lt;/code&gt; コマンドを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">最後の &lt;code&gt;push&lt;/code&gt; コマンドの後、バッチの終了空白行の前に、0個以上のプロトコルオプションを入力できます。</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;パス&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium作業項目：マルチパックインデックス（MIDX）</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; multi-pack-index機能の以前のRFC</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018コントリビューターのサミットノート（MIDXの説明を含む）</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[ &lt;code&gt;--rebase-merges&lt;/code&gt; ：代わりに--rebase-mergesを使用してください ]マージコミットで導入されたコミットを再生して履歴を平坦化する代わりに、マージコミットを再作成します。マージ競合解決またはマージコミットの手動修正は保存されません。</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[EXPERIMENTAL] &lt;code&gt;true&lt;/code&gt; に設定すると、Perlスクリプトバージョンの代わりに&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;のインタラクティブバージョンの実験的な組み込み実装が使用されます。デフォルトでは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[注意] &lt;code&gt;git rerere&lt;/code&gt; はファイル内の競合マーカーに依存して競合を検出します。ファイルに競合マーカーのある行と同じように見える行がすでに含まれている場合、 &lt;code&gt;git rerere&lt;/code&gt; は競合解決の記録に失敗する場合があります。これを回避するには、&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;の &lt;code&gt;conflict-marker-size&lt;/code&gt; 設定を使用できます。</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;ソフトウェアテストのための不十分なインフラストラクチャの経済的影響&lt;/em&gt;。Nist計画レポート02-3&lt;/a&gt;、エグゼクティブサマリーおよび第8章を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Javaプログラミング言語のコード規約&lt;/em&gt;。Sun Microsystems。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;ソフトウェアのメンテナンス&lt;/em&gt;。ウィキペディア。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;ジュニオC浜野。&lt;em&gt;自動化された二分サクセスストーリー&lt;/em&gt;。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;クリスチャンクーダー。&lt;em&gt;「git bisect run」による完全に自動化された二分&lt;/em&gt;。LWN.net。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;ジョナサン・コルベット。&lt;em&gt;二等分は、ユーザーと開発者を分割し​​ます&lt;/em&gt;。LWN.net。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;インゴモルナー。&lt;em&gt;再：バグ2.6.23-rc3はAlphaのsdパーティションを見ることができません&lt;/em&gt;。Linux-kernelメーリングリスト。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamanoとgit-list。&lt;em&gt;git-bisect（1）マニュアルページ&lt;/em&gt;。Linuxカーネルアーカイブ。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf。&lt;em&gt;bbchop&lt;/em&gt;。GitHub。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">\出力時の行末は0にして、ファイル名を引用しないようにしてください。詳細は下記の OUTPUT FORMAT を参照してください。</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">\0行目で出力を終了し、ファイル名を引用しないでください。詳しくは OUTPUT を参照してください。</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; あるディレクトリ &lt;code&gt;bare&lt;/code&gt; リポジトリ（すなわち、自身の作業ツリーなし）一般的に、それに押し、そこからフェッチすることで、他の人と歴史を交換するために使用されます、。</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">作業ツリーのルートにある &lt;code&gt;.git&lt;/code&gt; ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (名前を変更/コピーした場合にのみ存在する)。</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">a NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">のような URL は &quot;git://example.org/path/to/repo.git&quot; に書き換えられますが、push の場合は &quot;ssh://example.org/path/to/repo.git&quot; に書き換えられますが、pull の場合は元の URL を使用します。</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">work:repo.git」のようなURLや「host.xz:/path/to/repo.git」のようなURLは、「git://git.host.xz/repo.git」というURLを取るようなコンテキストでは書き換えられてしまいます。</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">コロンです。</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">このコミットを記述するコメント。</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">コミッターのことです。コミットを実際に作成した人の名前で、そのコミットが行われた日付が記載されています。これは作成者とは異なる場合があります。例えば、作成者がパッチを書いてそれを使ってコミットを作成した人にメールで送った場合などです。</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; というファイルで、 &lt;code&gt;ref: refs/heads/master&lt;/code&gt; れています。これはシンボリックリンクに似ており、 &lt;code&gt;HEAD&lt;/code&gt; ファイルに対して &lt;code&gt;refs/heads/master&lt;/code&gt; を指します。</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; ディレクトリ内のファイル。</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; ディレクトリ内のファイル、または</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">持つファイル &lt;code&gt;any&lt;/code&gt; 3本の木に何-SO-これまでの違いは、インデックス内の別のエントリとしてご利用いただけます。0以外のステージを削除し、マージされたバージョンを挿入する方法を決定するのは、「磁器ポリシー」次第です。</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; と呼ばれる関数。通常は &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; で定義され（以前のバージョンのGitは以前は &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; で使用されていました）、 &lt;code&gt;builtin.h&lt;/code&gt; で宣言されています。</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">で始まる行を指定します。&quot;</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">diff -&quot; で始まる行、または</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">改行します。</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">生の &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">Git構成ファイル内のリモート： &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">時空間</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 日付/時刻区切り文字の代わりにスペース</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">スペース。</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">プロジェクトのすべてのオブジェクトを含む、 &lt;code&gt;objects&lt;/code&gt; というサブディレクトリ。オブジェクトを直接見る本当の理由があるべきではありませんが、これらのオブジェクトがリポジトリ内のすべての実際の &lt;code&gt;data&lt;/code&gt; 含んでいることを知りたい場合があります。</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">オブジェクトへの参照を含む &lt;code&gt;refs&lt;/code&gt; と呼ばれるサブディレクトリ。</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; オプションが使用されている場合はタブまたはNUL 。</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; オプションを使用する場合はタブまたはNUL 。CまたはRにのみ存在します。</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">タブを使用しています。</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">ツリー。ツリーオブジェクトの SHA-1 名 (以下に定義)で、ある時点でのディレクトリの内容を表します。</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">有効なヘッド &lt;code&gt;name&lt;/code&gt; （つまり、 &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">有効なタグ &lt;code&gt;name&lt;/code&gt; （つまり、 &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a)は「悪い」コミットの祖先であり(「悪い」コミット自体を含む)、b)は「良い」コミットの祖先ではない(「良い」コミットを除く)。</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">省略形コミットハッシュ</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">省略された親ハッシュ</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">略木ハッシュ</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">アクセスメソッド</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">&amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]を追加</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">add [-b &amp;lt;branch&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;path &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">必要に応じて、不足している &lt;code&gt;\n&lt;/code&gt; を最後の行に追加します。</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">カレントディレクトリの下にすべてを追加します。</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">追い出す</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (非推奨)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">追加コンテンツ</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">コンテキストの追加 (&quot; &quot;)または削除 (&quot;-&quot;)行</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">以下を &lt;code&gt;.git/config&lt;/code&gt; に追加します：</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice と cindy は master にプッシュできますが、doc-update にプッシュできるのは bob だけです。</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">すべての親オブジェクトのID</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">「drivers」ディレクトリの下のファイルを変更したコミットの過去2週間のコミットを参照できます。（注：Ctrlキーを押しながら「-」または「+」を押すと、gitkのフォントを調整できます。）</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">代替オブジェクトデータベース</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">alternate:代替オブジェクトデータベースの絶対パス。パスに印刷不可能な文字が含まれている場合は、ダブルクォートで囲まれ、Cスタイルのバックスラッシュ付きエスケープシーケンスが含まれている可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">完全な40文字のSHA-1が提供されます。外部参照がまだ存在しない場合、 &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; は40 &lt;code&gt;0&lt;/code&gt; になります。refを削除する場合、 &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; は &lt;code&gt;(delete)&lt;/code&gt; として提供され、 &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; は40 &lt;code&gt;0&lt;/code&gt; になります。ローカルコミットが、展開可能な名前（ &lt;code&gt;HEAD~&lt;/code&gt; やSHA-1など）以外のもので指定された場合、最初に指定されたとおりに提供されます。</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">列をなす</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">HEADとインデックスファイルの違いを常に表示します。これは、今すぐコミットを作成した場合にコミットするものです。</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">前のコミットを修正し、元のメッセージを使って新しい変更点をすべて追加します。</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; オプションを使用してレコードを終了する場合のLFまたはNUL 。</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">作成者。この変更の責任者の名前と日付。</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">エントリ &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; で &lt;code&gt;Makefile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">エントリ &lt;code&gt;commands[]&lt;/code&gt; の配列 &lt;code&gt;git.c&lt;/code&gt; 、及び</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">とGitが残りのパッチを適用し続けます。</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">とGitがコミットを作成し、メールボックスから残りのパッチを適用し続けます。</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">を実行すると、Git がコミットメッセージを要求してきて、新しいコミットが作成されます。で期待したものと同じように見えるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">とバンドルトピックブランチはまだ調理中です。</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">とメールしてみてください。</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">そしてハックしてください。 &lt;code&gt;cvs update&lt;/code&gt; に相当するものは</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">で、「file0」というファイルが完全に書き換えられたことを検知したら、それを変更します。</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">実際、Gitコマンドの一般的な組み合わせの多くは、 &lt;code&gt;git xyz&lt;/code&gt; インターフェースでスクリプト化できます。さまざまなgitスクリプトの機能を確認するだけで学習できます。たとえば、以前は &lt;code&gt;git reset&lt;/code&gt; で実装 &lt;code&gt;git reset&lt;/code&gt; れていた上記の2行がgit resetでしたが、 &lt;code&gt;git status&lt;/code&gt; や &lt;code&gt;git commit&lt;/code&gt; などは、基本的なGitコマンドの周りのスクリプトが少し複雑になっています。</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">であり、変化しないと仮定しています。</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">そしてそれはなくなります。外部レポジトリはなく、作成したプロジェクト以外の履歴はありません。</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">以前のコミットで新しいブランチ &lt;code&gt;mybranch&lt;/code&gt; を作成し、その時の状態をチェックアウトします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
